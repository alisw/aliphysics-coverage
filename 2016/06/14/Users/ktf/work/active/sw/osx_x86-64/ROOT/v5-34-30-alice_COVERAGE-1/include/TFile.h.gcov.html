<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - /Users/ktf/work/active/sw/osx_x86-64/ROOT/v5-34-30-alice_COVERAGE-1/include/TFile.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../../../index.html">top level</a> - <a href="index.html">Users/ktf/work/active/sw/osx_x86-64/ROOT/v5-34-30-alice_COVERAGE-1/include</a> - TFile.h<span style="font-size: 80%;"> (source / <a href="TFile.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">27</td>
            <td class="headerCovTableEntryLo">3.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">27</td>
            <td class="headerCovTableEntryLo">3.7 %</td>
          </tr>
          <tr><td><img src="../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // @(#)root/io:$Id$</a>
<span class="lineNum">       2 </span>            : // Author: Rene Brun   28/11/94
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : /*************************************************************************
<span class="lineNum">       5 </span>            :  * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
<span class="lineNum">       6 </span>            :  * All rights reserved.                                                  *
<span class="lineNum">       7 </span>            :  *                                                                       *
<span class="lineNum">       8 </span>            :  * For the licensing terms see $ROOTSYS/LICENSE.                         *
<span class="lineNum">       9 </span>            :  * For the list of contributors see $ROOTSYS/README/CREDITS.             *
<span class="lineNum">      10 </span>            :  *************************************************************************/
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #ifndef ROOT_TFile
<span class="lineNum">      13 </span>            : #define ROOT_TFile
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : //////////////////////////////////////////////////////////////////////////
<span class="lineNum">      17 </span>            : //                                                                      //
<span class="lineNum">      18 </span>            : // TFile                                                                //
<span class="lineNum">      19 </span>            : //                                                                      //
<span class="lineNum">      20 </span>            : // ROOT file.                                                           //
<span class="lineNum">      21 </span>            : //                                                                      //
<span class="lineNum">      22 </span>            : //////////////////////////////////////////////////////////////////////////
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : #if __cplusplus &gt;= 201103L
<span class="lineNum">      25 </span>            : #include &lt;atomic&gt;
<span class="lineNum">      26 </span>            : #endif
<span class="lineNum">      27 </span>            : #ifndef ROOT_TDirectoryFile
<span class="lineNum">      28 </span>            : #include &quot;TDirectoryFile.h&quot;
<span class="lineNum">      29 </span>            : #endif
<span class="lineNum">      30 </span>            : #ifndef ROOT_TMap
<span class="lineNum">      31 </span>            : #include &quot;TMap.h&quot;
<span class="lineNum">      32 </span>            : #endif
<span class="lineNum">      33 </span>            : #ifndef ROOT_TUrl
<span class="lineNum">      34 </span>            : #include &quot;TUrl.h&quot;
<span class="lineNum">      35 </span>            : #endif
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : class TFree;
<span class="lineNum">      38 </span>            : class TArrayC;
<span class="lineNum">      39 </span>            : class TArchiveFile;
<span class="lineNum">      40 </span>            : class TFileOpenHandle;
<span class="lineNum">      41 </span>            : class TFileCacheRead;
<span class="lineNum">      42 </span>            : class TFileCacheWrite;
<span class="lineNum">      43 </span>            : class TProcessID;
<span class="lineNum">      44 </span>            : class TStopwatch;
<span class="lineNum">      45 </span>            : class TFilePrefetch;
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : class TFile : public TDirectoryFile {
<span class="lineNum">      48 </span>            :   friend class TDirectoryFile;
<span class="lineNum">      49 </span>            :   friend class TFilePrefetch;
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : public:
<span class="lineNum">      52 </span>            :    // Asynchronous open request status
<span class="lineNum">      53 </span>            :    enum EAsyncOpenStatus { kAOSNotAsync = -1,  kAOSFailure = 0,
<span class="lineNum">      54 </span>            :                            kAOSInProgress = 1, kAOSSuccess = 2 };
<span class="lineNum">      55 </span>            :    // Open timeout constants
<span class="lineNum">      56 </span>            :    enum EOpenTimeOut { kInstantTimeout = 0, kEternalTimeout = 999999999 };
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            :    // TTreeCache flushing semantics
<span class="lineNum">      59 </span>            :    enum ECacheAction { kDisconnect = 0, kDoNotDisconnect = 1 };
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            : protected:
<span class="lineNum">      62 </span>            :    Double_t         fSumBuffer;      //Sum of buffer sizes of objects written so far
<span class="lineNum">      63 </span>            :    Double_t         fSum2Buffer;     //Sum of squares of buffer sizes of objects written so far
<span class="lineNum">      64 </span>            :    Long64_t         fBytesWrite;     //Number of bytes written to this file
<span class="lineNum">      65 </span>            :    Long64_t         fBytesRead;      //Number of bytes read from this file
<span class="lineNum">      66 </span>            :    Long64_t         fBytesReadExtra; //Number of extra bytes (overhead) read by the readahead buffer
<span class="lineNum">      67 </span>            :    Long64_t         fBEGIN;          //First used byte in file
<span class="lineNum">      68 </span>            :    Long64_t         fEND;            //Last used byte in file
<span class="lineNum">      69 </span>            :    Long64_t         fSeekFree;       //Location on disk of free segments structure
<span class="lineNum">      70 </span>            :    Long64_t         fSeekInfo;       //Location on disk of StreamerInfo record
<span class="lineNum">      71 </span>            :    Int_t            fD;              //File descriptor
<span class="lineNum">      72 </span>            :    Int_t            fVersion;        //File format version
<span class="lineNum">      73 </span>            :    Int_t            fCompress;       //Compression level and algorithm
<span class="lineNum">      74 </span>            :    Int_t            fNbytesFree;     //Number of bytes for free segments structure
<span class="lineNum">      75 </span>            :    Int_t            fNbytesInfo;     //Number of bytes for StreamerInfo record
<span class="lineNum">      76 </span>            :    Int_t            fWritten;        //Number of objects written so far
<span class="lineNum">      77 </span>            :    Int_t            fNProcessIDs;    //Number of TProcessID written to this file
<span class="lineNum">      78 </span>            :    Int_t            fReadCalls;      //Number of read calls ( not counting the cache calls )
<span class="lineNum">      79 </span>            :    TString          fRealName;       //Effective real file name (not original url)
<span class="lineNum">      80 </span>            :    TString          fOption;         //File options
<span class="lineNum">      81 </span>            :    Char_t           fUnits;          //Number of bytes for file pointers
<span class="lineNum">      82 </span>            :    TList           *fFree;           //Free segments linked list table
<span class="lineNum">      83 </span>            :    TArrayC         *fClassIndex;     //!Index of TStreamerInfo classes written to this file
<span class="lineNum">      84 </span>            :    TObjArray       *fProcessIDs;     //!Array of pointers to TProcessIDs
<span class="lineNum">      85 </span>            :    Long64_t         fOffset;         //!Seek offset cache
<span class="lineNum">      86 </span>            :    TArchiveFile    *fArchive;        //!Archive file from which we read this file
<span class="lineNum">      87 </span>            :    TFileCacheRead  *fCacheRead;      //!Pointer to the read cache (if any)
<span class="lineNum">      88 </span>            :    TMap            *fCacheReadMap;   //!Pointer to the read cache (if any)
<span class="lineNum">      89 </span>            :    TFileCacheWrite *fCacheWrite;     //!Pointer to the write cache (if any)
<span class="lineNum">      90 </span>            :    Long64_t         fArchiveOffset;  //!Offset at which file starts in archive
<span class="lineNum">      91 </span>            :    Bool_t           fIsArchive;      //!True if this is a pure archive file
<span class="lineNum">      92 </span>            :    Bool_t           fNoAnchorInName; //!True if we don't want to force the anchor to be appended to the file name
<span class="lineNum">      93 </span>            :    Bool_t           fIsRootFile;     //!True is this is a ROOT file, raw file otherwise
<span class="lineNum">      94 </span>            :    Bool_t           fInitDone;       //!True if the file has been initialized
<span class="lineNum">      95 </span>            :    Bool_t           fMustFlush;      //!True if the file buffers must be flushed
<span class="lineNum">      96 </span>            :    TFileOpenHandle *fAsyncHandle;    //!For proper automatic cleanup
<span class="lineNum">      97 </span>            :    EAsyncOpenStatus fAsyncOpenStatus; //!Status of an asynchronous open request
<span class="lineNum">      98 </span>            :    TUrl             fUrl;            //!URL of file
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            :    TList           *fInfoCache;      //!Cached list of the streamer infos in this file
<span class="lineNum">     101 </span>            :    TList           *fOpenPhases;     //!Time info about open phases
<span class="lineNum">     102 </span>            : 
<span class="lineNum">     103 </span>            :    static TList    *fgAsyncOpenRequests; //List of handles for pending open requests
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            :    static TString   fgCacheFileDir;          //Directory where to locally stage files
<span class="lineNum">     106 </span>            :    static Bool_t    fgCacheFileDisconnected; //Indicates, we trust in the files in the cache dir without stat on the cached file
<span class="lineNum">     107 </span>            :    static Bool_t    fgCacheFileForce;        //Indicates, to force all READ to CACHEREAD
<span class="lineNum">     108 </span>            :    static UInt_t    fgOpenTimeout;           //Timeout for open operations in ms  - 0 corresponds to blocking i/o
<span class="lineNum">     109 </span>            :    static Bool_t    fgOnlyStaged ;           //Before the file is opened, it is checked, that the file is staged, if not, the open fails
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            : #if __cplusplus &gt;= 201103L
<span class="lineNum">     112 </span>            :    static std::atomic&lt;Long64_t&gt;  fgBytesWrite;            //Number of bytes written by all TFile objects
<span class="lineNum">     113 </span>            :    static std::atomic&lt;Long64_t&gt;  fgBytesRead;             //Number of bytes read by all TFile objects
<span class="lineNum">     114 </span>            :    static std::atomic&lt;Long64_t&gt;  fgFileCounter;           //Counter for all opened files
<span class="lineNum">     115 </span>            :    static std::atomic&lt;Int_t&gt;     fgReadCalls;             //Number of bytes read from all TFile objects
<span class="lineNum">     116 </span>            : #else
<span class="lineNum">     117 </span>            :    static Long64_t  fgBytesWrite;            //Number of bytes written by all TFile objects
<span class="lineNum">     118 </span>            :    static Long64_t  fgBytesRead;             //Number of bytes read by all TFile objects
<span class="lineNum">     119 </span>            :    static Long64_t  fgFileCounter;           //Counter for all opened files
<span class="lineNum">     120 </span>            :    static Int_t     fgReadCalls;             //Number of bytes read from all TFile objects
<span class="lineNum">     121 </span>            : #endif
<a name="122"><span class="lineNum">     122 </span>            :    static Int_t     fgReadaheadSize;         //Readahead buffer size</a>
<span class="lineNum">     123 </span>            :    static Bool_t    fgReadInfo;              //if true (default) ReadStreamerInfo is called when opening a file
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :    virtual EAsyncOpenStatus GetAsyncOpenStatus() { return fAsyncOpenStatus; }</span>
<span class="lineNum">     125 </span>            :    virtual void  Init(Bool_t create);
<span class="lineNum">     126 </span>            :    Bool_t        FlushWriteCache();
<span class="lineNum">     127 </span>            :    Int_t         ReadBufferViaCache(char *buf, Int_t len);
<span class="lineNum">     128 </span>            :    Int_t         WriteBufferViaCache(const char *buf, Int_t len);
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            :    // Creating projects
<span class="lineNum">     131 </span>            :    Int_t         MakeProjectParMake(const char *packname, const char *filename);
<span class="lineNum">     132 </span>            :    Int_t         MakeProjectParProofInf(const char *packname, const char *proofinfdir);
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            :    // Interface to basic system I/O routines
<span class="lineNum">     135 </span>            :    virtual Int_t    SysOpen(const char *pathname, Int_t flags, UInt_t mode);
<span class="lineNum">     136 </span>            :    virtual Int_t    SysClose(Int_t fd);
<span class="lineNum">     137 </span>            :    virtual Int_t    SysRead(Int_t fd, void *buf, Int_t len);
<span class="lineNum">     138 </span>            :    virtual Int_t    SysWrite(Int_t fd, const void *buf, Int_t len);
<span class="lineNum">     139 </span>            :    virtual Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence);
<span class="lineNum">     140 </span>            :    virtual Int_t    SysStat(Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime);
<span class="lineNum">     141 </span>            :    virtual Int_t    SysSync(Int_t fd);
<a name="142"><span class="lineNum">     142 </span>            : </a>
<a name="143"><span class="lineNum">     143 </span>            :    // Interface for text-based TDirectory I/O</a>
<a name="144"><span class="lineNum">     144 </span><span class="lineNoCov">          0 :    virtual Long64_t DirCreateEntry(TDirectory*) { return 0; }</span></a>
<a name="145"><span class="lineNum">     145 </span><span class="lineNoCov">          0 :    virtual Int_t    DirReadKeys(TDirectory*) { return 0; }</span></a>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :    virtual void     DirWriteKeys(TDirectory*) {}</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :    virtual void     DirWriteHeader(TDirectory*) {}</span>
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            : private:
<span class="lineNum">     150 </span>            :    TFile(const TFile &amp;);            //Files cannot be copied
<span class="lineNum">     151 </span>            :    void operator=(const TFile &amp;);
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span>            :    static void   CpProgress(Long64_t bytesread, Long64_t size, TStopwatch &amp;watch);
<span class="lineNum">     154 </span>            :    static TFile *OpenFromCache(const char *name, Option_t * = &quot;&quot;,
<span class="lineNum">     155 </span>            :                                const char *ftitle = &quot;&quot;, Int_t compress = 1,
<span class="lineNum">     156 </span>            :                                Int_t netopt = 0);
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            : public:
<span class="lineNum">     159 </span>            :    // TFile status bits
<span class="lineNum">     160 </span>            :    enum EStatusBits {
<span class="lineNum">     161 </span>            :       kRecovered     = BIT(10),
<span class="lineNum">     162 </span>            :       kHasReferences = BIT(11),
<span class="lineNum">     163 </span>            :       kDevNull       = BIT(12),
<span class="lineNum">     164 </span>            :       kWriteError    = BIT(14), // BIT(13) is taken up by TObject
<span class="lineNum">     165 </span>            :       kBinaryFile    = BIT(15),
<span class="lineNum">     166 </span>            :       kRedirected    = BIT(16)
<span class="lineNum">     167 </span>            :    };
<span class="lineNum">     168 </span>            :    enum ERelativeTo { kBeg = 0, kCur = 1, kEnd = 2 };
<span class="lineNum">     169 </span>            :    enum { kStartBigFile  = 2000000000 };
<span class="lineNum">     170 </span>            :    // File type
<span class="lineNum">     171 </span>            :    enum EFileType { kDefault = 0, kLocal = 1, kNet = 2, kWeb = 3, kFile = 4, kMerge = 5};
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span>            :    TFile();
<span class="lineNum">     174 </span>            :    TFile(const char *fname, Option_t *option=&quot;&quot;, const char *ftitle=&quot;&quot;, Int_t compress=1);
<a name="175"><span class="lineNum">     175 </span>            :    virtual ~TFile();</a>
<span class="lineNum">     176 </span>            :    virtual void        Close(Option_t *option=&quot;&quot;); // *MENU*
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :    virtual void        Copy(TObject &amp;) const { MayNotUse(&quot;Copy(TObject &amp;)&quot;); }</span>
<span class="lineNum">     178 </span>            :    virtual Bool_t      Cp(const char *dst, Bool_t progressbar = kTRUE,UInt_t buffersize = 1000000);
<span class="lineNum">     179 </span>            :    virtual TKey*       CreateKey(TDirectory* mother, const TObject* obj, const char* name, Int_t bufsize);
<span class="lineNum">     180 </span>            :    virtual TKey*       CreateKey(TDirectory* mother, const void* obj, const TClass* cl,
<span class="lineNum">     181 </span>            :                                  const char* name, Int_t bufsize);
<span class="lineNum">     182 </span>            :    static TFile      *&amp;CurrentFile(); // Return the current file for this thread.
<span class="lineNum">     183 </span>            :    virtual void        Delete(const char *namecycle=&quot;&quot;);
<span class="lineNum">     184 </span>            :    virtual void        Draw(Option_t *option=&quot;&quot;);
<span class="lineNum">     185 </span>            :    virtual void        DrawMap(const char *keys=&quot;*&quot;,Option_t *option=&quot;&quot;); // *MENU*
<a name="186"><span class="lineNum">     186 </span>            :    virtual void        FillBuffer(char *&amp;buffer);</a>
<span class="lineNum">     187 </span>            :    virtual void        Flush();
<span class="lineNum">     188 </span><span class="lineCov">          4 :    TArchiveFile       *GetArchive() const { return fArchive; }</span>
<span class="lineNum">     189 </span>            :    Long64_t            GetArchiveOffset() const { return fArchiveOffset; }
<span class="lineNum">     190 </span>            :    Int_t               GetBestBuffer() const;
<span class="lineNum">     191 </span>            :    virtual Int_t       GetBytesToPrefetch() const;
<span class="lineNum">     192 </span>            :    TFileCacheRead     *GetCacheRead(TObject* tree = 0) const;
<span class="lineNum">     193 </span>            :    TFileCacheWrite    *GetCacheWrite() const;
<span class="lineNum">     194 </span>            :    TArrayC            *GetClassIndex() const { return fClassIndex; }
<span class="lineNum">     195 </span>            :    Int_t               GetCompressionAlgorithm() const;
<span class="lineNum">     196 </span>            :    Int_t               GetCompressionLevel() const;
<a name="197"><span class="lineNum">     197 </span>            :    Int_t               GetCompressionSettings() const;</a>
<span class="lineNum">     198 </span>            :    Float_t             GetCompressionFactor();
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :    virtual Long64_t    GetEND() const { return fEND; }</span>
<span class="lineNum">     200 </span>            :    virtual Int_t       GetErrno() const;
<a name="201"><span class="lineNum">     201 </span>            :    virtual void        ResetErrno() const;</a>
<span class="lineNum">     202 </span>            :    Int_t               GetFd() const { return fD; }
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :    virtual const TUrl *GetEndpointUrl() const { return &amp;fUrl; }</span>
<a name="204"><span class="lineNum">     204 </span>            :    TObjArray          *GetListOfProcessIDs() const {return fProcessIDs;}</a>
<a name="205"><span class="lineNum">     205 </span>            :    TList              *GetListOfFree() const { return fFree; }</a>
<a name="206"><span class="lineNum">     206 </span><span class="lineNoCov">          0 :    virtual Int_t       GetNfree() const { return fFree-&gt;GetSize(); }</span></a>
<a name="207"><span class="lineNum">     207 </span><span class="lineNoCov">          0 :    virtual Int_t       GetNProcessIDs() const { return fNProcessIDs; }</span></a>
<a name="208"><span class="lineNum">     208 </span><span class="lineNoCov">          0 :    Option_t           *GetOption() const { return fOption.Data(); }</span></a>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :    virtual Long64_t    GetBytesRead() const { return fBytesRead; }</span>
<a name="210"><span class="lineNum">     210 </span><span class="lineNoCov">          0 :    virtual Long64_t    GetBytesReadExtra() const { return fBytesReadExtra; }</span></a>
<span class="lineNum">     211 </span>            :    virtual Long64_t    GetBytesWritten() const;
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :    virtual Int_t       GetReadCalls() const { return fReadCalls; }</span>
<span class="lineNum">     213 </span>            :    Int_t               GetVersion() const { return fVersion; }
<a name="214"><span class="lineNum">     214 </span>            :    Int_t               GetRecordHeader(char *buf, Long64_t first, Int_t maxbytes,</a>
<a name="215"><span class="lineNum">     215 </span>            :                                        Int_t &amp;nbytes, Int_t &amp;objlen, Int_t &amp;keylen);</a>
<a name="216"><span class="lineNum">     216 </span><span class="lineNoCov">          0 :    virtual Int_t       GetNbytesInfo() const {return fNbytesInfo;}</span></a>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :    virtual Int_t       GetNbytesFree() const {return fNbytesFree;}</span>
<a name="218"><span class="lineNum">     218 </span><span class="lineNoCov">          0 :    virtual TString     GetNewUrl() { return &quot;&quot;; }</span></a>
<a name="219"><span class="lineNum">     219 </span>            :    Long64_t            GetRelOffset() const { return fOffset - fArchiveOffset; }</a>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :    virtual Long64_t    GetSeekFree() const {return fSeekFree;}</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :    virtual Long64_t    GetSeekInfo() const {return fSeekInfo;}</span>
<span class="lineNum">     222 </span>            :    virtual Long64_t    GetSize() const;
<a name="223"><span class="lineNum">     223 </span>            :    virtual TList      *GetStreamerInfoList();</a>
<a name="224"><span class="lineNum">     224 </span>            :    const   TList      *GetStreamerInfoCache();</a>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :    virtual void        IncrementProcessIDs() { fNProcessIDs++; }</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :    virtual Bool_t      IsArchive() const { return fIsArchive; }</span>
<span class="lineNum">     227 </span>            :            Bool_t      IsBinary() const { return TestBit(kBinaryFile); }
<span class="lineNum">     228 </span>            :            Bool_t      IsRaw() const { return !fIsRootFile; }
<span class="lineNum">     229 </span>            :    virtual Bool_t      IsOpen() const;
<span class="lineNum">     230 </span>            :    virtual void        ls(Option_t *option=&quot;&quot;) const;
<span class="lineNum">     231 </span>            :    virtual void        MakeFree(Long64_t first, Long64_t last);
<span class="lineNum">     232 </span>            :    virtual void        MakeProject(const char *dirname, const char *classes=&quot;*&quot;,
<span class="lineNum">     233 </span>            :                                    Option_t *option=&quot;new&quot;); // *MENU*
<a name="234"><span class="lineNum">     234 </span>            :    virtual void        Map(); // *MENU*</a>
<span class="lineNum">     235 </span>            :    virtual Bool_t      Matches(const char *name);
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :    virtual Bool_t      MustFlush() const {return fMustFlush;}</span>
<span class="lineNum">     237 </span>            :    virtual void        Paint(Option_t *option=&quot;&quot;);
<span class="lineNum">     238 </span>            :    virtual void        Print(Option_t *option=&quot;&quot;) const;
<span class="lineNum">     239 </span>            :    virtual Bool_t      ReadBufferAsync(Long64_t offs, Int_t len);
<span class="lineNum">     240 </span>            :    virtual Bool_t      ReadBuffer(char *buf, Int_t len);
<span class="lineNum">     241 </span>            :    virtual Bool_t      ReadBuffer(char *buf, Long64_t pos, Int_t len);
<span class="lineNum">     242 </span>            :    virtual Bool_t      ReadBuffers(char *buf, Long64_t *pos, Int_t *len, Int_t nbuf);
<span class="lineNum">     243 </span>            :    virtual void        ReadFree();
<span class="lineNum">     244 </span>            :    virtual TProcessID *ReadProcessID(UShort_t pidf);
<span class="lineNum">     245 </span>            :    virtual void        ReadStreamerInfo();
<span class="lineNum">     246 </span>            :    virtual Int_t       Recover();
<span class="lineNum">     247 </span>            :    virtual Int_t       ReOpen(Option_t *mode);
<span class="lineNum">     248 </span>            :    virtual void        Seek(Long64_t offset, ERelativeTo pos = kBeg);
<span class="lineNum">     249 </span>            :    virtual void        SetCacheRead(TFileCacheRead *cache, TObject* tree = 0, ECacheAction action = kDisconnect);
<span class="lineNum">     250 </span>            :    virtual void        SetCacheWrite(TFileCacheWrite *cache);
<span class="lineNum">     251 </span>            :    virtual void        SetCompressionAlgorithm(Int_t algorithm=0);
<a name="252"><span class="lineNum">     252 </span>            :    virtual void        SetCompressionLevel(Int_t level=1);</a>
<span class="lineNum">     253 </span>            :    virtual void        SetCompressionSettings(Int_t settings=1);
<a name="254"><span class="lineNum">     254 </span><span class="lineNoCov">          0 :    virtual void        SetEND(Long64_t last) { fEND = last; }</span></a>
<a name="255"><span class="lineNum">     255 </span>            :    virtual void        SetOffset(Long64_t offset, ERelativeTo pos = kBeg);</a>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :    virtual void        SetOption(Option_t *option=&quot;&gt;&quot;) { fOption = option; }</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :    virtual void        SetReadCalls(Int_t readcalls = 0) { fReadCalls = readcalls; }</span>
<span class="lineNum">     258 </span>            :    virtual void        ShowStreamerInfo();
<span class="lineNum">     259 </span>            :    virtual Int_t       Sizeof() const;
<span class="lineNum">     260 </span>            :    void                SumBuffer(Int_t bufsize);
<span class="lineNum">     261 </span>            :    virtual void        UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0);
<span class="lineNum">     262 </span>            :    virtual Bool_t      WriteBuffer(const char *buf, Int_t len);
<span class="lineNum">     263 </span>            :    virtual Int_t       Write(const char *name=0, Int_t opt=0, Int_t bufsiz=0);
<span class="lineNum">     264 </span>            :    virtual Int_t       Write(const char *name=0, Int_t opt=0, Int_t bufsiz=0) const;
<span class="lineNum">     265 </span>            :    virtual void        WriteFree();
<span class="lineNum">     266 </span>            :    virtual void        WriteHeader();
<span class="lineNum">     267 </span>            :    virtual UShort_t    WriteProcessID(TProcessID *pid);
<span class="lineNum">     268 </span>            :    virtual void        WriteStreamerInfo();
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            :    static TFileOpenHandle
<span class="lineNum">     271 </span>            :                       *AsyncOpen(const char *name, Option_t *option = &quot;&quot;,
<span class="lineNum">     272 </span>            :                                  const char *ftitle = &quot;&quot;, Int_t compress = 1,
<span class="lineNum">     273 </span>            :                                  Int_t netopt = 0);
<span class="lineNum">     274 </span>            :    static TFile       *Open(const char *name, Option_t *option = &quot;&quot;,
<span class="lineNum">     275 </span>            :                             const char *ftitle = &quot;&quot;, Int_t compress = 1,
<span class="lineNum">     276 </span>            :                             Int_t netopt = 0);
<span class="lineNum">     277 </span>            :    static TFile       *Open(TFileOpenHandle *handle);
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span>            :    static EFileType    GetType(const char *name, Option_t *option = &quot;&quot;, TString *prefix = 0);
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span>            :    static EAsyncOpenStatus GetAsyncOpenStatus(const char *name);
<span class="lineNum">     282 </span>            :    static EAsyncOpenStatus GetAsyncOpenStatus(TFileOpenHandle *handle);
<span class="lineNum">     283 </span>            :    static const TUrl  *GetEndpointUrl(const char *name);
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            :    static Long64_t     GetFileBytesRead();
<span class="lineNum">     286 </span>            :    static Long64_t     GetFileBytesWritten();
<span class="lineNum">     287 </span>            :    static Int_t        GetFileReadCalls();
<span class="lineNum">     288 </span>            :    static Int_t        GetReadaheadSize();
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span>            :    static void         SetFileBytesRead(Long64_t bytes = 0);
<span class="lineNum">     291 </span>            :    static void         SetFileBytesWritten(Long64_t bytes = 0);
<span class="lineNum">     292 </span>            :    static void         SetFileReadCalls(Int_t readcalls = 0);
<span class="lineNum">     293 </span>            :    static void         SetReadaheadSize(Int_t bufsize = 256000);
<span class="lineNum">     294 </span>            :    static void         SetReadStreamerInfo(Bool_t readinfo=kTRUE);
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span>            :    static Long64_t     GetFileCounter();
<span class="lineNum">     297 </span>            :    static void         IncrementFileCounter();
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            :    static Bool_t       SetCacheFileDir(const char *cacheDir, Bool_t operateDisconnected = kTRUE,
<span class="lineNum">     300 </span>            :                                        Bool_t forceCacheread = kFALSE);
<span class="lineNum">     301 </span>            :    static const char  *GetCacheFileDir();
<span class="lineNum">     302 </span>            :    static Bool_t       ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0);
<span class="lineNum">     303 </span>            :    static Bool_t       Cp(const char *src, const char *dst, Bool_t progressbar = kTRUE,
<span class="lineNum">     304 </span>            :                           UInt_t buffersize = 1000000);
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span>            :    static UInt_t       SetOpenTimeout(UInt_t timeout);  // in ms
<span class="lineNum">     307 </span>            :    static UInt_t       GetOpenTimeout(); // in ms
<span class="lineNum">     308 </span>            :    static Bool_t       SetOnlyStaged(Bool_t onlystaged);
<span class="lineNum">     309 </span>            :    static Bool_t       GetOnlyStaged();
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            :    ClassDef(TFile,8)  //ROOT file
<span class="lineNum">     312 </span>            : };
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span>            : #ifndef __CINT__
<span class="lineNum">     315 </span>            : #define gFile (TFile::CurrentFile())
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span>            : #elif defined(__MAKECINT__)
<span class="lineNum">     318 </span>            : // To properly handle the use of gFile in header files (in static declarations)
<span class="lineNum">     319 </span>            : R__EXTERN TFile   *gFile;
<span class="lineNum">     320 </span>            : #endif
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            : //
<span class="lineNum">     323 </span>            : // Class holding info about the file being opened
<span class="lineNum">     324 </span>            : //
<span class="lineNum">     325 </span>            : class TFileOpenHandle : public TNamed {
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            : friend class TFile;
<span class="lineNum">     328 </span>            : friend class TAlienFile;
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            : private:
<span class="lineNum">     331 </span>            :    TString  fOpt;        // Options
<span class="lineNum">     332 </span>            :    Int_t    fCompress;   // Compression level and algorithm
<span class="lineNum">     333 </span>            :    Int_t    fNetOpt;     // Network options
<span class="lineNum">     334 </span>            :    TFile   *fFile;       // TFile instance of the file being opened
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            :    TFileOpenHandle(TFile *f) : TNamed(&quot;&quot;,&quot;&quot;), fOpt(&quot;&quot;), fCompress(1),
<span class="lineNum">     337 </span>            :                                fNetOpt(0), fFile(f) { }
<span class="lineNum">     338 </span>            :    TFileOpenHandle(const char *n, const char *o, const char *t, Int_t cmp,
<span class="lineNum">     339 </span>            :                    Int_t no) : TNamed(n,t), fOpt(o), fCompress(cmp),
<span class="lineNum">     340 </span>            :                                fNetOpt(no), fFile(0) { }
<span class="lineNum">     341 </span>            :    TFileOpenHandle(const TFileOpenHandle&amp;);
<span class="lineNum">     342 </span>            :    TFileOpenHandle&amp; operator=(const TFileOpenHandle&amp;);
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span>            :    TFile      *GetFile() const { return fFile; }
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span>            : public:
<span class="lineNum">     347 </span>            :    ~TFileOpenHandle() { }
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span>            :    Bool_t      Matches(const char *name);
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span>            :    const char *GetOpt() const { return fOpt; }
<span class="lineNum">     352 </span>            :    Int_t       GetCompress() const { return fCompress; }
<span class="lineNum">     353 </span>            :    Int_t       GetNetOpt() const { return fNetOpt; }
<span class="lineNum">     354 </span>            : };
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span>            : //______________________________________________________________________________
<span class="lineNum">     357 </span>            : inline Int_t TFile::GetCompressionAlgorithm() const
<span class="lineNum">     358 </span>            : {
<span class="lineNum">     359 </span>            :    return (fCompress &lt; 0) ? -1 : fCompress / 100;
<span class="lineNum">     360 </span>            : }
<a name="361"><span class="lineNum">     361 </span>            : </a>
<span class="lineNum">     362 </span>            : //______________________________________________________________________________
<span class="lineNum">     363 </span>            : inline Int_t TFile::GetCompressionLevel() const
<span class="lineNum">     364 </span>            : {
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :    return (fCompress &lt; 0) ? -1 : fCompress % 100;</span>
<span class="lineNum">     366 </span>            : }
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span>            : //______________________________________________________________________________
<span class="lineNum">     369 </span>            : inline Int_t TFile::GetCompressionSettings() const
<span class="lineNum">     370 </span>            : {
<span class="lineNum">     371 </span>            :    return (fCompress &lt; 0) ? -1 : fCompress;
<span class="lineNum">     372 </span>            : }
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
