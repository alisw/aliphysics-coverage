<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - TEvtGen/Photos/src/photos-fortran/forZ-MEc.cxx</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">TEvtGen/Photos/src/photos-fortran</a> - forZ-MEc.cxx<span style="font-size: 80%;"> (source / <a href="forZ-MEc.cxx.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">177</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">7</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : #include &quot;forZ-MEc.h&quot;</a>
<span class="lineNum">       2 </span>            : #include &quot;Photos.h&quot;
<span class="lineNum">       3 </span>            : #include &quot;PhotosUtilities.h&quot;
<span class="lineNum">       4 </span>            : #include &quot;PH_HEPEVT_Interface.h&quot;
<span class="lineNum">       5 </span>            : #include &quot;f_Init.h&quot;
<span class="lineNum">       6 </span>            : #include &lt;cmath&gt;
<span class="lineNum">       7 </span>            : #include &lt;cstdio&gt;
<span class="lineNum">       8 </span>            : #include &lt;cstdlib&gt;
<span class="lineNum">       9 </span>            : #include &lt;iostream&gt;
<span class="lineNum">      10 </span>            : using std::cout;
<span class="lineNum">      11 </span>            : using std::endl;
<span class="lineNum">      12 </span>            : using namespace Photospp;
<span class="lineNum">      13 </span>            : using namespace PhotosUtilities;
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : namespace Photospp
<span class="lineNum">      16 </span>            : {
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : // from photosC.cxx
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : extern void PHODMP();
<span class="lineNum">      21 </span>            : extern double PHINT(int idumm);
<span class="lineNum">      22 </span>            : // ----------------------------------------------------------------------
<span class="lineNum">      23 </span>            : // PROVIDES ELECTRIC CHARGE AND WEAK IZOSPIN OF A FAMILY FERMION
<span class="lineNum">      24 </span>            : // IDFERM=1,2,3,4 DENOTES NEUTRINO, LEPTON, UP AND DOWN QUARK
<span class="lineNum">      25 </span>            : // NEGATIVE IDFERM=-1,-2,-3,-4, DENOTES ANTIPARTICLE
<span class="lineNum">      26 </span>            : // IHELIC=+1,-1 DENOTES RIGHT AND LEFT HANDEDNES ( CHIRALITY)
<span class="lineNum">      27 </span>            : // SIZO3 IS THIRD PROJECTION OF WEAK IZOSPIN (PLUS MINUS HALF)
<span class="lineNum">      28 </span>            : // AND CHARGE IS ELECTRIC CHARGE IN UNITS OF ELECTRON CHARGE
<span class="lineNum">      29 </span>            : // KOLOR IS A QCD COLOUR, 1 FOR LEPTON, 3 FOR QUARKS
<span class="lineNum">      30 </span>            : //
<span class="lineNum">      31 </span>            : //     called by : EVENTE, EVENTM, FUNTIH, .....
<a name="32"><span class="lineNum">      32 </span>            : // ----------------------------------------------------------------------</a>
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : void PhotosMEforZ::GIVIZO(int IDFERM,int IHELIC,double *SIZO3,double *CHARGE,int *KOLOR) {
<span class="lineNum">      35 </span>            :   //
<span class="lineNum">      36 </span>            :   int IH, IDTYPE, IC, LEPQUA, IUPDOW; 
<span class="lineNum">      37 </span><span class="lineNoCov">          0 :   if (IDFERM==0 || abs(IDFERM)&gt;4 || abs(IHELIC)!=1){</span>
<span class="lineNum">      38 </span><span class="lineNoCov">          0 :     cout &lt;&lt; &quot;STOP IN GIVIZO: WRONG PARAMS&quot; &lt;&lt; endl;</span>
<span class="lineNum">      39 </span><span class="lineNoCov">          0 :     exit(-1);</span>
<span class="lineNum">      40 </span>            :    }
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            :   IH  =IHELIC;
<span class="lineNum">      43 </span>            :   IDTYPE =abs(IDFERM);
<span class="lineNum">      44 </span><span class="lineNoCov">          0 :   IC  =IDFERM/IDTYPE;</span>
<span class="lineNum">      45 </span><span class="lineNoCov">          0 :   LEPQUA=(int)(IDTYPE*0.4999999);</span>
<span class="lineNum">      46 </span><span class="lineNoCov">          0 :   IUPDOW=IDTYPE-2*LEPQUA-1;</span>
<span class="lineNum">      47 </span><span class="lineNoCov">          0 :   *CHARGE  =(-IUPDOW+2.0/3.0*LEPQUA)*IC;</span>
<span class="lineNum">      48 </span><span class="lineNoCov">          0 :   *SIZO3   =0.25*(IC-IH)*(1-2*IUPDOW);</span>
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :   *KOLOR=1+2*LEPQUA;</span>
<span class="lineNum">      50 </span>            :   //** NOTE THAT CONVENTIONALY Z0 COUPLING IS
<span class="lineNum">      51 </span>            :   //** XOUPZ=(SIZO3-CHARGE*SWSQ)/SQRT(SWSQ*(1-SWSQ))
<span class="lineNum">      52 </span>            :   return;
<span class="lineNum">      53 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : ////////////////////////////////////////////////////////////////////////////
<span class="lineNum">      57 </span>            : ///                                                                       //
<span class="lineNum">      58 </span>            : /// This routine provides unsophisticated Born differential cross section //
<a name="59"><span class="lineNum">      59 </span>            : /// at the crude x-section level, with Z and gamma s-chanel exchange.     //</a>
<span class="lineNum">      60 </span>            : ///////////////////////////////////////////////////////////////////////////
<span class="lineNum">      61 </span>            : double PhotosMEforZ::PHBORNM(double svar,double costhe,double T3e,double qe,double T3f,double qf,int NCf){
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            :   double   s,Sw2,MZ,MZ2,GammZ,AlfInv,GFermi;  // t,MW,MW2,
<span class="lineNum">      64 </span>            :   double   Ve,Ae,thresh;          //  sum,deno,
<span class="lineNum">      65 </span>            :   double   xe,yf,xf,ye,ff0,ff1,amx2,amfin,Vf,Af;
<span class="lineNum">      66 </span>            :   double   ReChiZ,SqChiZ,RaZ;     //,RaW,ReChiW,SqChiW;
<span class="lineNum">      67 </span>            :   double   Born;                  //, BornS;
<span class="lineNum">      68 </span>            :   //  int  KeyZet,HadMin,KFbeam;
<span class="lineNum">      69 </span>            :   //  int  i,ke,KFfin,kf,IsGenerated,iKF;
<span class="lineNum">      70 </span>            :   int  KeyWidFix;
<span class="lineNum">      71 </span>            :  
<span class="lineNum">      72 </span>            :   AlfInv= 137.0359895;
<span class="lineNum">      73 </span>            :   GFermi=1.16639e-5;
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            :   //--------------------------------------------------------------------
<span class="lineNum">      76 </span>            :   s = svar;
<span class="lineNum">      77 </span>            :   //------------------------------
<span class="lineNum">      78 </span>            :   //     EW paratemetrs taken from BornV
<span class="lineNum">      79 </span>            :   MZ=91.187;
<span class="lineNum">      80 </span>            :   GammZ=2.50072032;
<span class="lineNum">      81 </span>            :   Sw2=.22276773;
<span class="lineNum">      82 </span>            :   //------------------------------
<span class="lineNum">      83 </span>            :   // Z and gamma couplings to beams (electrons)
<span class="lineNum">      84 </span>            :   // Z and gamma couplings to final fermions
<span class="lineNum">      85 </span>            :   // Loop over all flavours defined in m_xpar(400+i)
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            :   //------ incoming fermion
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :   Ve=  2*T3e -4*qe*Sw2;</span>
<span class="lineNum">      90 </span>            :   Ae=  2*T3e;
<span class="lineNum">      91 </span>            :   //------ final fermion couplings
<span class="lineNum">      92 </span>            :   amfin = 0.000511; //  m_xpar(kf+6)
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :   Vf =  2*T3f -4*qf*Sw2;</span>
<span class="lineNum">      94 </span>            :   Af =  2*T3f;
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :   if(fabs(costhe) &gt; 1.0){</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :     cout &lt;&lt; &quot;+++++STOP in PHBORN: costhe&gt;0 =&quot; &lt;&lt; costhe &lt;&lt; endl;</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :     exit(-1);</span>
<span class="lineNum">      98 </span>            :   }
<span class="lineNum">      99 </span>            :   MZ2  = MZ*MZ;
<span class="lineNum">     100 </span>            :   RaZ  = (GFermi *MZ2 *AlfInv  )/( sqrt(2.0) *8.0 *PI); //
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :   RaZ  = 1/(16.0*Sw2*(1.0-Sw2));</span>
<span class="lineNum">     102 </span>            :   KeyWidFix = 1;       // fixed width
<span class="lineNum">     103 </span>            :   KeyWidFix = 0;       // variable width
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :   if( KeyWidFix == 0 ){</span>
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :     ReChiZ=(s-MZ2)*s/((s-MZ2)*(s-MZ2)+(GammZ*s/MZ)*(GammZ*s/MZ)) *RaZ;     // variable width</span>
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :     SqChiZ=      s*s/((s-MZ2)*(s-MZ2)+(GammZ*s/MZ)*(GammZ*s/MZ)) *RaZ*RaZ; // variable width</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     108 </span>            :   else{
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :       ReChiZ=(s-MZ2)*s/((s-MZ2)*(s-MZ2)+(GammZ*MZ)*(GammZ*MZ)) *RaZ;     // fixed width</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :       SqChiZ=      s*s/((s-MZ2)*(s-MZ2)+(GammZ*MZ)*(GammZ*MZ)) *RaZ*RaZ; // fixed width</span>
<span class="lineNum">     111 </span>            :   }
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :   xe= Ve*Ve +Ae*Ae;</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :   xf= Vf*Vf +Af*Af;</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :   ye= 2*Ve*Ae;</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :   yf= 2*Vf*Af;</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :   ff0= qe*qe*qf*qf +2*ReChiZ*qe*qf*Ve*Vf +SqChiZ*xe*xf;</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :   ff1=             +2*ReChiZ*qe*qf*Ae*Af +SqChiZ*ye*yf;</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :   Born    = (1.0+ costhe*costhe)*ff0 +2.0*costhe*ff1;</span>
<span class="lineNum">     119 </span>            :   // Colour factor
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :   Born = NCf*Born;</span>
<span class="lineNum">     121 </span>            :   // Crude method of correcting threshold, cos(theta) depencence incorrect!!!
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :   if(    svar &lt;  4.0*amfin*amfin){ </span>
<span class="lineNum">     123 </span>            :     thresh=0.0;
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :   else if(svar &lt; 16.0*amfin*amfin){</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :     amx2=4.0*amfin*amfin/svar;</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :     thresh=sqrt(1.0-amx2)*(1.0+amx2/2.0);</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     129 </span>            :   else{
<span class="lineNum">     130 </span>            :     thresh=1.0;
<span class="lineNum">     131 </span>            :   }
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :   Born= Born*thresh;</span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :   return Born;</span>
<span class="lineNum">     135 </span>            : }
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            : // ----------------------------------------------------------------------
<span class="lineNum">     139 </span>            : // THIS ROUTINE CALCULATES  BORN ASYMMETRY.
<span class="lineNum">     140 </span>            : // IT EXPLOITS THE FACT THAT BORN X. SECTION = A + B*C + D*C**2
<span class="lineNum">     141 </span>            : //
<span class="lineNum">     142 </span>            : //     called by : EVENTM
<a name="143"><span class="lineNum">     143 </span>            : // ----------------------------------------------------------------------</a>
<span class="lineNum">     144 </span>            : //
<span class="lineNum">     145 </span>            : double PhotosMEforZ::AFBCALC(double SVAR,int IDEE,int IDFF){
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :   int KOLOR,KOLOR1;</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :   double T3e,qe,T3f,qf,A,B;</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :   GIVIZO(IDEE,-1,&amp;T3e,&amp;qe,&amp;KOLOR);</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :   GIVIZO(IDFF,-1,&amp;T3f,&amp;qf,&amp;KOLOR1);</span>
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :   A=PHBORNM(SVAR,0.5,T3e,qe,T3f,qf,KOLOR*KOLOR1);</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :   B=PHBORNM(SVAR,-0.5,T3e,qe,T3f,qf,KOLOR*KOLOR1);</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :   return (A-B)/(A+B)*5.0/2.0 *3.0/8.0;</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 : }</span>
<a name="155"><span class="lineNum">     155 </span>            : </a>
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            : int PhotosMEforZ::GETIDEE(int IDE){
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span>            :   int IDEE;
<span class="lineNum">     160 </span>            :   IDEE=-555;
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :   if((IDE==11)       || (IDE== 13) || (IDE== 15)){</span>
<span class="lineNum">     162 </span>            :     IDEE=2;
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :   else if((IDE==-11) || (IDE==-13) || (IDE==-15)){</span>
<span class="lineNum">     165 </span>            :     IDEE=-2;
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :   else if((IDE== 12) || (IDE== 14) || (IDE== 16)){</span>
<span class="lineNum">     168 </span>            :     IDEE=1;
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :   else if((IDE==-12) || (IDE==-14) || (IDE==-16)){</span>
<span class="lineNum">     171 </span>            :     IDEE=-1;
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :   else if((IDE==  1) || (IDE==  3) || (IDE==  5)){</span>
<span class="lineNum">     174 </span>            :     IDEE=4;
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :   else if((IDE== -1) || (IDE== -3) || (IDE== -5)){</span>
<span class="lineNum">     177 </span>            :     IDEE=-4;
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :   else if((IDE==  2) || (IDE==  4) || (IDE==  6)){</span>
<span class="lineNum">     180 </span>            :     IDEE=3;
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :   else if((IDE==- 2) || (IDE== -4) || (IDE== -6)){</span>
<span class="lineNum">     183 </span>            :     IDEE=-3;
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :   if(IDEE==-555) {cout &lt;&lt; &quot; ERROR IN GETIDEE of PHOTS Z-ME: I3= &amp;4i&quot;&lt;&lt;IDEE&lt;&lt;endl;}</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :   return IDEE;</span>
<span class="lineNum">     187 </span>            : }
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            : //----------------------------------------------------------------------
<span class="lineNum">     193 </span>            : //
<span class="lineNum">     194 </span>            : //    PHASYZ:   PHotosASYmmetry of Z
<span class="lineNum">     195 </span>            : //
<span class="lineNum">     196 </span>            : //    Purpose:  Calculates born level asymmetry for Z
<span class="lineNum">     197 </span>            : //              between distributions (1-C)**2 and (1+C)**2
<span class="lineNum">     198 </span>            : //              At present dummy, requrires effective Z and gamma 
<span class="lineNum">     199 </span>            : //              Couplings and also spin polarization states
<span class="lineNum">     200 </span>            : //              For initial and final states.
<span class="lineNum">     201 </span>            : //              To be correct this function need to be tuned
<span class="lineNum">     202 </span>            : //              to host generator. Axes orientation polarisation
<span class="lineNum">     203 </span>            : //              conventions etc etc. 
<span class="lineNum">     204 </span>            : //              Modularity of PHOTOS would break. 
<span class="lineNum">     205 </span>            : //
<span class="lineNum">     206 </span>            : //    Input Parameters:   SVAR
<span class="lineNum">     207 </span>            : //
<span class="lineNum">     208 </span>            : //    Output Parameters:  Function value
<span class="lineNum">     209 </span>            : //
<span class="lineNum">     210 </span>            : //    Author(s):  Z. Was                          Created at:  10/12/05
<span class="lineNum">     211 </span>            : //                                                Last Update: 19/06/13
<a name="212"><span class="lineNum">     212 </span>            : //</a>
<span class="lineNum">     213 </span>            : //----------------------------------------------------------------------
<span class="lineNum">     214 </span>            : double PhotosMEforZ::PHASYZ(double SVAR,int IDE, int IDF){
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span>            :   double AFB;
<span class="lineNum">     217 </span>            :   int IDEE,IDFF;
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :   IDEE=abs(GETIDEE(IDE));</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :   IDFF=abs(GETIDEE(IDF));</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :   AFB= -AFBCALC(SVAR,IDEE,IDFF);</span>
<span class="lineNum">     222 </span>            :   //      AFB=0
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :   return 4.0/3.0*AFB;</span>
<span class="lineNum">     224 </span>            :   //      write(*,*) 'IDE=',IDE,'  IDF=',IDF,'  SVAR=',SVAR,'AFB=',AFB
<span class="lineNum">     225 </span>            : }
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            : //----------------------------------------------------------------------
<span class="lineNum">     228 </span>            : //
<span class="lineNum">     229 </span>            : //    PHWTNLO:   PHotosWTatNLO
<span class="lineNum">     230 </span>            : //
<span class="lineNum">     231 </span>            : //    Purpose:  calculates instead of interference weight
<span class="lineNum">     232 </span>            : //              complete NLO weight for vector boson decays
<span class="lineNum">     233 </span>            : //              of pure vector (or pseudovector) couplings
<span class="lineNum">     234 </span>            : //              Proper orientation of beams required.
<span class="lineNum">     235 </span>            : //              This is not standard in PHOTOS.
<span class="lineNum">     236 </span>            : //              At NLO more tuning than in standard is needed.
<span class="lineNum">     237 </span>            : //               
<span class="lineNum">     238 </span>            : //              
<span class="lineNum">     239 </span>            : //
<span class="lineNum">     240 </span>            : //    Input Parameters:   as in function declaration
<span class="lineNum">     241 </span>            : //
<span class="lineNum">     242 </span>            : //    Output Parameters:  Function value
<span class="lineNum">     243 </span>            : //
<span class="lineNum">     244 </span>            : //    Author(s):  Z. Was                          Created at:  08/12/05
<span class="lineNum">     245 </span>            : //                                                Last Update: 20/06/13
<a name="246"><span class="lineNum">     246 </span>            : //</a>
<span class="lineNum">     247 </span>            : //----------------------------------------------------------------------
<span class="lineNum">     248 </span>            : double PhotosMEforZ::Zphwtnlo(double svar,double xk,int IDHEP3,int IREP,double qp[4],double qm[4],double ph[4],double pp[4],double pm[4],double COSTHG,double BETA,double th1,int IDE,int IDF){
<span class="lineNum">     249 </span>            :   double C,s,xkaM,xkaP,t,u,t1,u1,BT,BU;
<span class="lineNum">     250 </span>            :   double waga,wagan2;
<span class="lineNum">     251 </span>            :   static int i=1;
<span class="lineNum">     252 </span>            :   int IBREM;
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            :   // IBREM is spurious but it numbers branches of MUSTRAAL
<span class="lineNum">     256 </span>            :   IBREM=1;
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :   if (IREP==1)  IBREM=-1;</span>
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            :   // we calculate C and S, note that TH1 exists in MUSTRAAL as well. 
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :   C=cos(th1); // this parameter is calculated outside of the class</span>
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            :   // from off line application we had:
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :   if(IBREM==-1) C=-C;</span>
<span class="lineNum">     265 </span>            :   // ... we may want to re-check it. 
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :   s=sqrt(1.0-C*C);</span>
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :   if (IBREM==1){</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :     xkaM=(qp[4-i]*ph[4-i]-qp[3-i]*ph[3-i]-qp[2-i]*ph[2-i]-qp[1-i]*ph[1-i])/xk;</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :     xkaP=(qm[4-i]*ph[4-i]-qm[3-i]*ph[3-i]-qm[2-i]*ph[2-i]-qm[1-i]*ph[1-i])/xk;</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     272 </span>            :   else{
<span class="lineNum">     273 </span>            :     xkaP=(qp[4-i]*ph[4-i]-qp[3-i]*ph[3-i]-qp[2-i]*ph[2-i]-qp[1-i]*ph[1-i])/xk;
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :     xkaM=(qm[4-i]*ph[4-i]-qm[3-i]*ph[3-i]-qm[2-i]*ph[2-i]-qm[1-i]*ph[1-i])/xk;</span>
<span class="lineNum">     275 </span>            :   }   
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            :   //        XK=2*PHEP(4,nhep)/PHEP(4,1)/xphmax   ! it is not used becuse here
<span class="lineNum">     278 </span>            :   //                                             ! order of emissions is meaningless
<span class="lineNum">     279 </span>            :   //
<span class="lineNum">     280 </span>            :   //        DELTA=2*PHEP(5,4)**2/svar/(1+(1-XK)**2)*(xKAP/xKAM+xKAM/xKAP)
<span class="lineNum">     281 </span>            :   //        waga=svar/4./xkap
<span class="lineNum">     282 </span>            :   //        waga=waga*(1.D0-COSTHG*BETA) ! sprawdzone 1= svar/xKAp/4   * (1.D0-COSTHG*BETA)
<span class="lineNum">     283 </span>            :   //        waga=waga*(1-delta) /wt2 ! sprawdzone ze to jest =2/(1.D0+COSTHG*BETA)
<span class="lineNum">     284 </span>            :   //                                 ! czyli ubija de-interferencje
<span class="lineNum">     285 </span>            :  
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            :   // this is true only for intermediate resonances with afb=0!
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :   t =2*(qp[4-i]*pp[4-i]-qp[3-i]*pp[3-i]-qp[2-i]*pp[2-i]-qp[1-i]*pp[1-i]);</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :   u =2*(qm[4-i]*pp[4-i]-qm[3-i]*pp[3-i]-qm[2-i]*pp[2-i]-qm[1-i]*pp[1-i]);</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :   u1=2*(qp[4-i]*pm[4-i]-qp[3-i]*pm[3-i]-qp[2-i]*pm[2-i]-qp[1-i]*pm[1-i]);</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :   t1=2*(qm[4-i]*pm[4-i]-qm[3-i]*pm[3-i]-qm[2-i]*pm[2-i]-qm[1-i]*pm[1-i]);</span>
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            :   // basically irrelevant lines  ...
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :   t =t - (qp[4-i]*qp[4-i]-qp[3-i]*qp[3-i]-qp[2-i]*qp[2-i]-qp[1-i]*qp[1-i]);</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :   u =u - (qm[4-i]*qm[4-i]-qm[3-i]*qm[3-i]-qm[2-i]*qm[2-i]-qm[1-i]*qm[1-i]);</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :   u1=u1- (qp[4-i]*qp[4-i]-qp[3-i]*qp[3-i]-qp[2-i]*qp[2-i]-qp[1-i]*qp[1-i]);</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :   t1=t1- (qm[4-i]*qm[4-i]-qm[3-i]*qm[3-i]-qm[2-i]*qm[2-i]-qm[1-i]*qm[1-i]);</span>
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            :   // we adjust to what is f-st,s-nd beam flavour 
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :   if (IDE*IDHEP3&gt;0){</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :     BT=1.0+PHASYZ(svar,IDE,IDF);</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :     BU=1.0-PHASYZ(svar,IDE,IDF);</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     304 </span>            :   else{
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :     BT=1.0-PHASYZ(svar,IDE,IDF);</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :     BU=1.0+PHASYZ(svar,IDE,IDF);</span>
<span class="lineNum">     307 </span>            :   }  
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :   wagan2=2*(BT*t*t+BU*u*u+BT*t1*t1+BU*u1*u1)</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :     /(1+(1-xk)*(1-xk))* 2.0/(BT*(1-C)*(1-C)+BU*(1+C)*(1+C))/svar/svar;</span>
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            :   //!        waga=waga*wagan2
<span class="lineNum">     312 </span>            :   //!        waga=waga*(1-delta) /wt2 ! sprawdzone ze to jest =2/(1.D0+COSTHG*BETA)
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :   waga=2/(1.0+COSTHG*BETA)*wagan2;  </span>
<span class="lineNum">     314 </span>            :   //!     %       * svar/4./xkap*(1.D0-COSTHG*BETA)*sqrt(1.0-xk)
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :   if(wagan2&lt;=3.8) return waga;</span>
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            :   // 
<span class="lineNum">     319 </span>            :   // exceptional case  wagan2&gt;3.8
<span class="lineNum">     320 </span>            :   // it should correspond to extremely high bremssthahlung in multiphot conf.  
<span class="lineNum">     321 </span>            :   //
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :   FILE *PHLUN = stdout;</span>
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span>            :   //         fprintf(PHLUN,&quot;&quot;) 'phwtnlo= ',phwtnlo
<span class="lineNum">     326 </span>            :   //         fprintf(PHLUN,&quot;&quot;) 'idhepy= ',IDHEP[1-i],IDHEP[2-i],IDHEP[3-i],IDHEP[4-i],IDHEP(5)
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :   fprintf(PHLUN,&quot; IDE= %i  IDF= %i&quot;,IDE,IDF);</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :   fprintf(PHLUN,&quot;bt,bu,bt+bu= %f %f %f&quot;,BT,BU,BT+BU);</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :   PHODMP();  // we will activate this once PHODMP(); is re-written</span>
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :   fprintf(PHLUN,&quot; &quot;); </span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :   fprintf(PHLUN,&quot;%i %i &lt;-- IREP,IBREM&quot;, IREP,IBREM);</span>
<span class="lineNum">     333 </span>            :   //!        fprintf(PHLUN,&quot;%f %f %f %f %f&quot;) 'pneutr= ',phomom_.pneutr[0],phomom_.pneutr[1],phomom_.pneutr[2],phomom_.pneutr[3],phomom_.pneutr[4];
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :   fprintf(PHLUN,&quot;%f %f %f %f  qp    = &quot;,qp[0],qp[1],qp[2],qp[3]);</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :   fprintf(PHLUN,&quot;%f %f %f %f  qm    = &quot;,qm[0],qm[1],qm[2],qm[3]);</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :   fprintf(PHLUN,&quot; &quot;);</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :   fprintf(PHLUN,&quot;%f %f %f %f  ph    = &quot;,ph[0],ph[1],ph[2],ph[3]);</span>
<span class="lineNum">     338 </span>            :   //        fprintf(PHLUN,&quot;&quot;) 'p1= ',PHEP(1,1),PHEP(2,1),PHEP(3,1),PHEP(4,1)
<span class="lineNum">     339 </span>            :   //        fprintf(PHLUN,&quot;&quot;) 'p2= ',PHEP(1,2),PHEP(2,2),PHEP(3,2),PHEP(4,2)
<span class="lineNum">     340 </span>            :   //        fprintf(PHLUN,&quot;&quot;) 'p3= ',PHEP(1,3),PHEP(2,3),PHEP(3,3),PHEP(4,3)
<span class="lineNum">     341 </span>            :   //        fprintf(PHLUN,&quot;&quot;) 'p4= ',PHEP(1,4),PHEP(2,4),PHEP(3,4),PHEP(4,4)
<span class="lineNum">     342 </span>            :   //        fprintf(PHLUN,&quot;&quot;) 'p5= ',PHEP(1,5),PHEP(2,5),PHEP(3,5),PHEP(4,5)
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :   fprintf(PHLUN,&quot; c= %f theta= %f&quot;,C,th1);</span>
<span class="lineNum">     345 </span>            :   //         fprintf(PHLUN,&quot;&quot;)  'photos waga daje ... IBREM=',IBREM,' waga=',waga
<span class="lineNum">     346 </span>            :   //         fprintf(PHLUN,&quot;&quot;) 'xk,COSTHG,c',xk,COSTHG,c
<span class="lineNum">     347 </span>            :   //         fprintf(PHLUN,&quot;&quot;) svar/4./xkap*(1.D0-COSTHG*BETA), 
<span class="lineNum">     348 </span>            :   //     $   (1-delta) /wt2 *(1.D0+COSTHG*BETA)/2, wagan2
<span class="lineNum">     349 </span>            :   //         fprintf(PHLUN,&quot;&quot;) ' delta, wt2,beta',  delta, wt2,beta
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :   fprintf(PHLUN,&quot;   -  &quot;);</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :   fprintf(PHLUN,&quot;t,u       = %f %f&quot;,t,u);</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :   fprintf(PHLUN,&quot;t1,u1     = %f %f&quot;,t1,u1);</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :   fprintf(PHLUN,&quot;sredniaki = %f %f&quot;,svar*(1-C)/2,svar*(1+C)/2);</span>
<span class="lineNum">     354 </span>            :   //       !         fprintf(PHLUN,&quot;&quot;) 'xk= %f c= %f COSTHG=  %f' ,xk,c,COSTHG
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :   fprintf(PHLUN,&quot;PHASYZ(svar)=',%f,' svar= %f',' waga= %f&quot;,PHASYZ(svar,IDE,IDF),svar,waga);</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :   fprintf(PHLUN,&quot;  -  &quot;);</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :   fprintf(PHLUN,&quot;BT-part= %f BU-part= %f&quot;,</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :                  2*(BT*t*t+BT*t1*t1)</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :                    /(1+(1-xk)*(1-xk))* 2.0/(BT*(1-C)*(1-C))/svar/svar,</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :                  2*(BU*u*u+BU*u1*u1)</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :                    /(1+(1-xk)*(1-xk))* 2.0/(BU*(1+C)*(1+C))/svar/svar);</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :   fprintf(PHLUN,&quot;BT-part*BU-part= %f wagan2= %f&quot;,</span>
<span class="lineNum">     363 </span>            :                  2*(BT*t*t+BT*t1*t1)
<span class="lineNum">     364 </span>            :                    /(1+(1-xk)*(1-xk))* 2.0/(BT*(1-C)*(1-C))/svar/svar
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :                 *2*(BU*u*u+BU*u1*u1)</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :                    /(1+(1-xk)*(1-xk))* 2.0/(BU*(1+C)*(1+C))/svar/svar,  wagan2);</span>
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :   fprintf(PHLUN,&quot;wagan2= %f&quot;,wagan2);</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :   fprintf(PHLUN,&quot; ###################  &quot;);</span>
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span>            :   wagan2=3.8; //  ! overwrite 
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :   waga=2/(1.0+COSTHG*BETA)*wagan2 ; </span>
<span class="lineNum">     374 </span>            :            //     %       * svar/4./xkap*(1.D0-COSTHG*BETA)*sqrt(1.0-xk)
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span>            :   return waga;
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span>            : //----------------------------------------------------------------------
<span class="lineNum">     384 </span>            : //
<span class="lineNum">     385 </span>            : //    PHWTNLO:   PHotosWTatNLO
<span class="lineNum">     386 </span>            : //
<span class="lineNum">     387 </span>            : //    Purpose:  calculates instead of interference weight
<span class="lineNum">     388 </span>            : //              complete NLO weight for vector boson decays
<span class="lineNum">     389 </span>            : //              of pure vector (or pseudovector) couplings
<span class="lineNum">     390 </span>            : //              Proper orientation of beams required.
<span class="lineNum">     391 </span>            : //              Uses Zphwtnlo encapsulating actual matrix element
<span class="lineNum">     392 </span>            : //              At NLO more tuning on kinematical conf.
<span class="lineNum">     393 </span>            : //              than in standard is needed.
<span class="lineNum">     394 </span>            : //              Works with KORALZ and KKM// 
<span class="lineNum">     395 </span>            : //              Note some commented out commons from MUSTAAL, KORALZ
<span class="lineNum">     396 </span>            : //
<span class="lineNum">     397 </span>            : //    Input Parameters:   Common /PHOEVT/ /PHOPS/ /PHOREST/ /PHOPRO/
<span class="lineNum">     398 </span>            : //
<span class="lineNum">     399 </span>            : //    Output Parameters:  Function value
<span class="lineNum">     400 </span>            : //
<span class="lineNum">     401 </span>            : //    Author(s):  Z. Was                          Created at:  08/12/05
<span class="lineNum">     402 </span>            : //                                                Last Update: 23/06/13
<span class="lineNum">     403 </span>            : //
<a name="404"><span class="lineNum">     404 </span>            : //----------------------------------------------------------------------</a>
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span>            : double PhotosMEforZ::phwtnlo(){
<span class="lineNum">     407 </span>            :   // fi3 orientation of photon, fi1,th1 orientation of neutral
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            :       //      COMMON/PHOPHS/XPHMAX,XPHOTO,COSTHG,SINTHG
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            :       //      COMMON /PHOREST/ FI3,fi1,th1
<span class="lineNum">     412 </span>            :       //      COMMON /PHWT/ BETA,WT1,WT2,WT3
<span class="lineNum">     413 </span>            :       //      COMMON/PHOPRO/PROBH,CORWT,XF,IREP
<span class="lineNum">     414 </span>            :   //      COMMON/PHOMOM/MCHSQR,MNESQR,PNEUTR(5)
<span class="lineNum">     415 </span>            :   //  static double PI=3.141592653589793238462643;
<span class="lineNum">     416 </span>            :   static int i=1;
<span class="lineNum">     417 </span>            :   int K,L,IDHEP3,IDUM=0;
<span class="lineNum">     418 </span>            :   int IDE,IDF;
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :   double  QP[4],QM[4],PH[4],QQ[4],PP[4],PM[4],QQS[4];</span>
<span class="lineNum">     420 </span>            :   double XK,ENE,svar;
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span>            :         //      REAL*8 s,c,svar,xkaM,xkaP,xk,phwtnlo,xdumm,PHINT
<span class="lineNum">     423 </span>            :         //      REAL*8 ENE,a,t,u,t1,u1,wagan2,waga,PHASYZ,BT,BU,ENEB
<span class="lineNum">     424 </span>            :         //      INTEGER IBREM,K,L,IREP,IDUM,IDHEP3
<span class="lineNum">     425 </span>            :         //      integer icont,ide,idf
<span class="lineNum">     426 </span>            :         //      REAL*8 delta
<span class="lineNum">     427 </span>            : 
<span class="lineNum">     428 </span>            : /////////////////////
<span class="lineNum">     429 </span>            : //         phlupa(299500);
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span>            : /////////////////////
<span class="lineNum">     433 </span>            : //        phlupa(299500);
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :   XK=2.0*pho.phep[pho.nhep-i][4-i]/pho.phep[1-i][4-i];</span>
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span>            : //  XK=2.0*pho.phep[pho.nhep-i][4-i]/pho.phep[1-i][4-i]/phophs_.xphmax;  // it is not used becuse here
<span class="lineNum">     438 </span>            :                                                                //order of emissions is meaningless
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :   if(pho.nhep&lt;=4) XK=0.0;</span>
<span class="lineNum">     440 </span>            :   // the mother must be Z or gamma*  !!!!
<span class="lineNum">     441 </span>            :       
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :   if (XK&gt;1.0e-10 &amp;&amp;(pho.idhep[1-i]==22 || pho.idhep[1-i]==23)){</span>
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            :     //        write(*,*) 'nhep=',nhep
<span class="lineNum">     445 </span>            :     //      DO K=1,3 ENDDO
<span class="lineNum">     446 </span>            :     //      IF (K.EQ.1) IBREM= 1
<span class="lineNum">     447 </span>            :     //      IF (K.EQ.2) IBREM=-1
<span class="lineNum">     448 </span>            :     //      ICONT=ICONT+1
<span class="lineNum">     449 </span>            :     //      IBREM=IBREX        ! that will be input parameter.
<span class="lineNum">     450 </span>            :     //      IBREM=IBREY        ! that IS now   input parameter.
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span>            :     // We initialize twice 4-vectors, here and again later after boost 
<span class="lineNum">     453 </span>            :     // must be the same way. Important is how the reduction procedure will work.
<span class="lineNum">     454 </span>            :     // It seems at present that the beams must be translated to be back to back.
<span class="lineNum">     455 </span>            :     // this may be done after initialising, thus on 4-vectors.
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :     for( K=1;K&lt;5;K++){</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :       PP[K-i]=pho.phep[1-i][K-i];</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :       PM[K-i]=pho.phep[2-i][K-i];</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :       QP[K-i]=pho.phep[3-i][K-i];</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :       QM[K-i]=pho.phep[4-i][K-i];</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :       PH[K-i]=pho.phep[pho.nhep-i][K-i];</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :       QQ[K-i]=0.0;</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :       QQS[K-i]=QP[K-i]+QM[K-i];</span>
<span class="lineNum">     465 </span>            :     }
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :     PP[4-i]=(pho.phep[1-i][4-i]+pho.phep[2-i][4-i])/2.0;</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :     PM[4-i]=(pho.phep[1-i][4-i]+pho.phep[2-i][4-i])/2.0;</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :     PP[3-i]= PP[4-i];</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :     PM[3-i]=-PP[4-i];</span>
<span class="lineNum">     472 </span>            :         
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :     for(L=5;L&lt;=pho.nhep-1;L++){</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :       for( K=1;K&lt;5;K++){      </span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :         QQ [K-i]=QQ [K-i]+ pho.phep[L-i][K-i];</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :         QQS[K-i]=QQS[K-i]+ pho.phep[L-i][K-i];</span>
<span class="lineNum">     477 </span>            :       }
<span class="lineNum">     478 </span>            :     }       
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            :     // go to the restframe of 3        
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :     PHOB(1,QQS,QP);</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :     PHOB(1,QQS,QM);</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :     PHOB(1,QQS,QQ);</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :     ENE=(QP[4-i]+QM[4-i]+QQ[4-i])/2;</span>
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            :     // preserve direction of emitting particle and wipeout QQ 
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :     if (phopro_.irep==1){</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :     double  a=sqrt(ENE*ENE-pho.phep[3-i][5-i]*pho.phep[3-i][5-i])/sqrt(QM[4-i]*QM[4-i]-pho.phep[3-i][5-i]*pho.phep[3-i][5-i]);</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :       QM[1-i]= QM[1-i]*a;</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :       QM[2-i]= QM[2-i]*a;</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :       QM[3-i]= QM[3-i]*a;</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :       QP[1-i]=-QM[1-i];</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :       QP[2-i]=-QM[2-i];</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :       QP[3-i]=-QM[3-i];</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     496 </span>            :     else{
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :     double  a=sqrt(ENE*ENE-pho.phep[3-i][5-i]*pho.phep[3-i][5-i])/sqrt(QP[4-i]*QP[4-i]-pho.phep[3-i][5-i]*pho.phep[3-i][5-i]);</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :       QP[1-i]= QP[1-i]*a;</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :       QP[2-i]= QP[2-i]*a;</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :       QP[3-i]= QP[3-i]*a;</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :       QM[1-i]=-QP[1-i];</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :       QM[2-i]=-QP[2-i];</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :       QM[3-i]=-QP[3-i];</span>
<span class="lineNum">     504 </span>            :     }
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :     QP[4-i]=ENE;</span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :     QM[4-i]=ENE;</span>
<span class="lineNum">     507 </span>            :     // go back to reaction frame (QQ eliminated) 
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :     PHOB(-1,QQS,QP);</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :     PHOB(-1,QQS,QM);</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :     PHOB(-1,QQS,QQ);</span>
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :     svar=pho.phep[1-i][4-i]*pho.phep[1-i][4-i];</span>
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :     IDE=hep.idhep[1-i];</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :     IDF=hep.idhep[4-i];</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :     if(abs(hep.idhep[4-i])==abs(hep.idhep[3-i])) IDF=hep.idhep[3-i];</span>
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :     IDHEP3=pho.idhep[3-i];</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :     return Zphwtnlo(svar,XK,IDHEP3,phopro_.irep,QP,QM,PH,PP,PM,phophs_.costhg,phwt_.beta,phorest_.th1,IDE,IDF);</span>
<span class="lineNum">     520 </span>            :   }
<span class="lineNum">     521 </span>            :   else{
<span class="lineNum">     522 </span>            :       // in other cases we just use default setups.
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :     return PHINT(IDUM);</span>
<span class="lineNum">     524 </span>            :   }
<span class="lineNum">     525 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span>            : } // namespace Photospp
<span class="lineNum">     528 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
