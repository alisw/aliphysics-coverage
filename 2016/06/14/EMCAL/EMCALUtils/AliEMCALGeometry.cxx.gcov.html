<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - EMCAL/EMCALUtils/AliEMCALGeometry.cxx</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">EMCAL/EMCALUtils</a> - AliEMCALGeometry.cxx<span style="font-size: 80%;"> (source / <a href="AliEMCALGeometry.cxx.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">295</td>
            <td class="headerCovTableEntry">724</td>
            <td class="headerCovTableEntryLo">40.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">23</td>
            <td class="headerCovTableEntry">55</td>
            <td class="headerCovTableEntryLo">41.8 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**************************************************************************</a>
<span class="lineNum">       2 </span>            :  * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
<span class="lineNum">       3 </span>            :  *                                                                        *
<span class="lineNum">       4 </span>            :  * Author: The ALICE Off-line Project.                                    *
<span class="lineNum">       5 </span>            :  * Contributors are mentioned in the code where appropriate.              *
<span class="lineNum">       6 </span>            :  *                                                                        *
<span class="lineNum">       7 </span>            :  * Permission to use, copy, modify and distribute this software and its   *
<span class="lineNum">       8 </span>            :  * documentation strictly for non-commercial purposes is hereby granted   *
<span class="lineNum">       9 </span>            :  * without fee, provided that the above copyright notice appears in all   *
<span class="lineNum">      10 </span>            :  * copies and that both the copyright notice and this permission notice   *
<span class="lineNum">      11 </span>            :  * appear in the supporting documentation. The authors make no claims     *
<span class="lineNum">      12 </span>            :  * about the suitability of this software for any purpose. It is          *
<span class="lineNum">      13 </span>            :  * provided &quot;as is&quot; without express or implied warranty.                  *
<span class="lineNum">      14 </span>            :  **************************************************************************/
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : // --- ROOT system ---
<span class="lineNum">      17 </span>            : #include &lt;TParticle.h&gt;
<span class="lineNum">      18 </span>            : #include &lt;TGeoManager.h&gt;
<span class="lineNum">      19 </span>            : #include &lt;TGeoMatrix.h&gt;
<span class="lineNum">      20 </span>            : #include &lt;TGeoBBox.h&gt;
<span class="lineNum">      21 </span>            : #include &lt;TList.h&gt;
<span class="lineNum">      22 </span>            : #include &lt;TBrowser.h&gt;
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : // --- Standard library ---
<span class="lineNum">      25 </span>            : //#include &lt;Riostream.h&gt;
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : // --- AliRoot header files ---
<span class="lineNum">      28 </span>            : #include &quot;AliLog.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;AliEMCALGeometry.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;AliEMCALShishKebabTrd1Module.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;AliEMCALTriggerMappingV1.h&quot;
<a name="32"><span class="lineNum">      32 </span>            : #include &quot;AliEMCALTriggerMappingV2.h&quot;</a>
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span><span class="lineCov">         72 : ClassImp(AliEMCALGeometry)</span>
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            : // these initialisations are needed for a singleton
<span class="lineNum">      37 </span>            : AliEMCALGeometry  *AliEMCALGeometry::fgGeom      = 0;
<span class="lineNum">      38 </span>            : const Char_t*      AliEMCALGeometry::fgkDefaultGeometryName = &quot;EMCAL_COMPLETE12SMV1_DCAL_8SM&quot;;
<a name="39"><span class="lineNum">      39 </span>            : </a>
<span class="lineNum">      40 </span>            : //____________________________________________________________________________
<span class="lineNum">      41 </span><span class="lineNoCov">          0 : AliEMCALGeometry::AliEMCALGeometry():</span>
<span class="lineNum">      42 </span><span class="lineNoCov">          0 :   fEMCGeometry(0x0),fTriggerMapping(0x0),fGeoName(0),</span>
<span class="lineNum">      43 </span><span class="lineNoCov">          0 :   fKey110DEG(0),fnSupModInDCAL(0),fNCellsInSupMod(0),fNETAdiv(0),fNPHIdiv(0),</span>
<span class="lineNum">      44 </span><span class="lineNoCov">          0 :   fNCellsInModule(0),fPhiBoundariesOfSM(0x0),fPhiCentersOfSM(0x0),</span>
<span class="lineNum">      45 </span><span class="lineNoCov">          0 :   fPhiCentersOfSMSec(0x0),fPhiCentersOfCells(0x0),fCentersOfCellsEtaDir(0x0),</span>
<span class="lineNum">      46 </span><span class="lineNoCov">          0 :   fCentersOfCellsPhiDir(0x0),fEtaCentersOfCells(0x0),</span>
<span class="lineNum">      47 </span><span class="lineNoCov">          0 :   fNCells(0),fNPhi(0),fCentersOfCellsXDir(0x0),fArm1EtaMin(0),</span>
<span class="lineNum">      48 </span><span class="lineNoCov">          0 :   fArm1EtaMax(0),fArm1PhiMin(0),fArm1PhiMax(0),fEtaMaxOfTRD1(0),</span>
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :   fDCALPhiMin(0),fDCALPhiMax(0),fEMCALPhiMax(0),fDCALStandardPhiMax(0),</span>
<span class="lineNum">      50 </span><span class="lineNoCov">          0 :   fDCALInnerExtandedEta(0),fShishKebabTrd1Modules(0),fPhiModuleSize(0.),</span>
<span class="lineNum">      51 </span><span class="lineNoCov">          0 :   fEtaModuleSize(0.),fPhiTileSize(0.),fEtaTileSize(0.),fNZ(0),</span>
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :   fIPDistance(0.),fLongModuleSize(0.),fShellThickness(0.),</span>
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :   fZLength(0.),fSampling(0.),fUseExternalMatrices(kFALSE)</span>
<span class="lineNum">      54 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">      55 </span>            :   // default ctor 
<span class="lineNum">      56 </span>            :   // must be kept public for root persistency purposes, but should never be called by the outside world
<span class="lineNum">      57 </span><span class="lineNoCov">          0 :   fEnvelop[0] = 0.;</span>
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :   fEnvelop[1] = 0.;</span>
<span class="lineNum">      59 </span><span class="lineNoCov">          0 :   fEnvelop[2] = 0.;</span>
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :   fParSM[0]   = 0.;</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :   fParSM[1]   = 0.;</span>
<span class="lineNum">      62 </span><span class="lineNoCov">          0 :   fParSM[2]   = 0.;</span>
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :   for (Int_t i=0;i&lt;AliEMCALGeoParams::fgkEMCALModules;i++)</span>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :     fkSModuleMatrix[i]=0 ;</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 : }  </span>
<a name="66"><span class="lineNum">      66 </span>            : </a>
<span class="lineNum">      67 </span>            : //____________________________________________________________________________
<span class="lineNum">      68 </span>            : AliEMCALGeometry::AliEMCALGeometry(const AliEMCALGeometry &amp; geo)
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :   : TNamed(geo),</span>
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :     fEMCGeometry(geo.fEMCGeometry),fTriggerMapping(geo.fTriggerMapping),fGeoName(geo.fGeoName),</span>
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :     fKey110DEG(geo.fKey110DEG),fnSupModInDCAL(geo.fnSupModInDCAL),fNCellsInSupMod(geo.fNCellsInSupMod),fNETAdiv(geo.fNETAdiv),fNPHIdiv(geo.fNPHIdiv),</span>
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :     fNCellsInModule(geo.fNCellsInModule),fPhiBoundariesOfSM(geo.fPhiBoundariesOfSM),fPhiCentersOfSM(geo.fPhiCentersOfSM),</span>
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :     fPhiCentersOfSMSec(geo.fPhiCentersOfSMSec),fPhiCentersOfCells(geo.fPhiCentersOfCells),fCentersOfCellsEtaDir(geo.fCentersOfCellsEtaDir),</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :     fCentersOfCellsPhiDir(geo.fCentersOfCellsPhiDir),fEtaCentersOfCells(geo.fEtaCentersOfCells),</span>
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :     fNCells(geo.fNCells),fNPhi(geo.fNPhi),fCentersOfCellsXDir(geo.fCentersOfCellsXDir),fArm1EtaMin(geo.fArm1EtaMin),</span>
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :     fArm1EtaMax(geo.fArm1EtaMax),fArm1PhiMin(geo.fArm1PhiMin),fArm1PhiMax(geo.fArm1PhiMax),fEtaMaxOfTRD1(geo.fEtaMaxOfTRD1),</span>
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :     fDCALPhiMin(geo.fDCALPhiMin),fDCALPhiMax(geo.fDCALPhiMax),fEMCALPhiMax(geo.fEMCALPhiMax),fDCALStandardPhiMax(geo.fDCALStandardPhiMax),</span>
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :     fDCALInnerExtandedEta(geo.fDCALInnerExtandedEta),fShishKebabTrd1Modules(geo.fShishKebabTrd1Modules),fPhiModuleSize(geo.fPhiModuleSize),</span>
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :     fEtaModuleSize(geo.fEtaModuleSize),fPhiTileSize(geo.fPhiTileSize),fEtaTileSize(geo.fEtaTileSize),fNZ(geo.fNZ),</span>
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :     fIPDistance(geo.fIPDistance),fLongModuleSize(geo.fLongModuleSize),fShellThickness(geo.fShellThickness),</span>
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :     fZLength(geo.fZLength),fSampling(geo.fSampling),fUseExternalMatrices(geo.fUseExternalMatrices)</span>
<span class="lineNum">      82 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">      83 </span>            :   // Copy constarctor
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :   fEnvelop[0] = geo.fEnvelop[0];</span>
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :   fEnvelop[1] = geo.fEnvelop[1];</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :   fEnvelop[2] = geo.fEnvelop[2];</span>
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :   fParSM[0]   = geo.fParSM[0];</span>
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :   fParSM[1]   = geo.fParSM[1];</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :   fParSM[2]   = geo.fParSM[2];</span>
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :   for (Int_t i=0;i&lt;AliEMCALGeoParams::fgkEMCALModules;i++)</span>
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :     fkSModuleMatrix[i]=0 ;</span>
<span class="lineNum">      92 </span><span class="lineNoCov">          0 : }</span>
<a name="93"><span class="lineNum">      93 </span>            : </a>
<span class="lineNum">      94 </span>            : //____________________________________________________________________________
<span class="lineNum">      95 </span>            : AliEMCALGeometry::AliEMCALGeometry(const Text_t* name,   const Text_t* title,
<span class="lineNum">      96 </span>            :                                    const Text_t* mcname, const Text_t* mctitle) 
<span class="lineNum">      97 </span><span class="lineCov">          5 :   : TNamed(name, title),</span>
<span class="lineNum">      98 </span><span class="lineCov">          5 :     fEMCGeometry(0x0),fTriggerMapping(0x0),fGeoName(0),</span>
<span class="lineNum">      99 </span><span class="lineCov">          5 :     fKey110DEG(0),fnSupModInDCAL(0),fNCellsInSupMod(0),fNETAdiv(0),fNPHIdiv(0),</span>
<span class="lineNum">     100 </span><span class="lineCov">         10 :     fNCellsInModule(0),fPhiBoundariesOfSM(0x0),fPhiCentersOfSM(0x0),</span>
<span class="lineNum">     101 </span><span class="lineCov">         15 :     fPhiCentersOfSMSec(0x0),fPhiCentersOfCells(0x0),fCentersOfCellsEtaDir(0x0),</span>
<span class="lineNum">     102 </span><span class="lineCov">         10 :     fCentersOfCellsPhiDir(0x0),fEtaCentersOfCells(0x0),</span>
<span class="lineNum">     103 </span><span class="lineCov">         10 :     fNCells(0),fNPhi(0),fCentersOfCellsXDir(0x0),fArm1EtaMin(0),</span>
<span class="lineNum">     104 </span><span class="lineCov">          5 :     fArm1EtaMax(0),fArm1PhiMin(0),fArm1PhiMax(0),fEtaMaxOfTRD1(0),</span>
<span class="lineNum">     105 </span><span class="lineCov">          5 :     fDCALPhiMin(0),fDCALPhiMax(0),fEMCALPhiMax(0),fDCALStandardPhiMax(0),</span>
<span class="lineNum">     106 </span><span class="lineCov">          5 :     fDCALInnerExtandedEta(0),fShishKebabTrd1Modules(0),fPhiModuleSize(0.),</span>
<span class="lineNum">     107 </span><span class="lineCov">          5 :     fEtaModuleSize(0.),fPhiTileSize(0.),fEtaTileSize(0.),fNZ(0),</span>
<span class="lineNum">     108 </span><span class="lineCov">          5 :     fIPDistance(0.),fLongModuleSize(0.),fShellThickness(0.),</span>
<span class="lineNum">     109 </span><span class="lineCov">          5 :     fZLength(0.),fSampling(0.), fUseExternalMatrices(kFALSE)</span>
<span class="lineNum">     110 </span><span class="lineCov">         25 : { </span>
<span class="lineNum">     111 </span>            :   // ctor only for normal usage 
<span class="lineNum">     112 </span>            :   
<span class="lineNum">     113 </span><span class="lineCov">         15 :   fEMCGeometry = new AliEMCALEMCGeometry(name,title,mcname,mctitle);</span>
<span class="lineNum">     114 </span><span class="lineCov">         15 :   fGeoName = fEMCGeometry-&gt;GetGeoName();</span>
<span class="lineNum">     115 </span><span class="lineCov">          5 :   fKey110DEG = fEMCGeometry-&gt;GetKey110DEG();</span>
<span class="lineNum">     116 </span><span class="lineCov">          5 :   fnSupModInDCAL = fEMCGeometry-&gt;GetnSupModInDCAL();</span>
<span class="lineNum">     117 </span><span class="lineCov">          5 :   fNCellsInSupMod = fEMCGeometry-&gt;GetNCellsInSupMod();</span>
<span class="lineNum">     118 </span><span class="lineCov">          5 :   fNETAdiv = fEMCGeometry-&gt;GetNETAdiv();</span>
<span class="lineNum">     119 </span><span class="lineCov">          5 :   fNPHIdiv = fEMCGeometry-&gt;GetNPHIdiv();</span>
<span class="lineNum">     120 </span><span class="lineCov">          5 :   fNCellsInModule = fNPHIdiv*fNETAdiv;</span>
<span class="lineNum">     121 </span>            :   static int i=0;
<span class="lineNum">     122 </span><span class="lineCov">          5 :   Int_t nSMod = fEMCGeometry-&gt;GetNumberOfSuperModules();</span>
<span class="lineNum">     123 </span><span class="lineCov">          5 :   fPhiBoundariesOfSM.Set(nSMod);</span>
<span class="lineNum">     124 </span><span class="lineCov">          5 :   fPhiCentersOfSM.Set(nSMod/2);</span>
<span class="lineNum">     125 </span><span class="lineCov">          5 :   fPhiCentersOfSMSec.Set(nSMod/2);</span>
<span class="lineNum">     126 </span><span class="lineCov">        150 :   for(Int_t sm=0; sm&lt;nSMod; sm++) {</span>
<span class="lineNum">     127 </span><span class="lineCov">         70 :     i = sm/2;</span>
<span class="lineNum">     128 </span><span class="lineCov">        210 :     fEMCGeometry-&gt;GetPhiBoundariesOfSM(sm,fPhiBoundariesOfSM[2*i],fPhiBoundariesOfSM[2*i+1]);</span>
<span class="lineNum">     129 </span>            :   }
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span><span class="lineCov">          5 :   Double_t phiMin =  0.;</span>
<span class="lineNum">     132 </span><span class="lineCov">          5 :   Double_t phiMax =  0.;</span>
<span class="lineNum">     133 </span><span class="lineCov">        150 :   for(Int_t sm=0; sm&lt;nSMod; sm++) {</span>
<span class="lineNum">     134 </span><span class="lineCov">         70 :     fEMCGeometry-&gt;GetPhiBoundariesOfSM(sm,phiMin,phiMax);</span>
<span class="lineNum">     135 </span><span class="lineCov">         70 :     i=sm/2;</span>
<span class="lineNum">     136 </span><span class="lineCov">        210 :     fPhiCentersOfSM[i] = fEMCGeometry-&gt;GetPhiCenterOfSM(sm);</span>
<span class="lineNum">     137 </span><span class="lineCov">        210 :     fPhiCentersOfSMSec[i] = fEMCGeometry-&gt;GetPhiCenterOfSMSec(sm);</span>
<span class="lineNum">     138 </span>            :   }
<span class="lineNum">     139 </span><span class="lineCov">          5 :   fNCells = fEMCGeometry-&gt;GetNCells();</span>
<span class="lineNum">     140 </span><span class="lineCov">          5 :   fNPhi = fEMCGeometry-&gt;GetNPhi();</span>
<span class="lineNum">     141 </span><span class="lineCov">          5 :   fEnvelop[0] = fEMCGeometry-&gt;GetEnvelop(0);</span>
<span class="lineNum">     142 </span><span class="lineCov">          5 :   fEnvelop[1] = fEMCGeometry-&gt;GetEnvelop(1);</span>
<span class="lineNum">     143 </span><span class="lineCov">          5 :   fEnvelop[2] = fEMCGeometry-&gt;GetEnvelop(2);</span>
<span class="lineNum">     144 </span><span class="lineCov">          5 :   fParSM[0]   = fEMCGeometry-&gt;GetSuperModulesPar(0);</span>
<span class="lineNum">     145 </span><span class="lineCov">          5 :   fParSM[1]   = fEMCGeometry-&gt;GetSuperModulesPar(1);</span>
<span class="lineNum">     146 </span><span class="lineCov">          5 :   fParSM[2]   = fEMCGeometry-&gt;GetSuperModulesPar(2);</span>
<span class="lineNum">     147 </span><span class="lineCov">          5 :   fArm1EtaMin = fEMCGeometry-&gt;GetArm1EtaMin();</span>
<span class="lineNum">     148 </span><span class="lineCov">          5 :   fArm1EtaMax = fEMCGeometry-&gt;GetArm1EtaMax();</span>
<span class="lineNum">     149 </span><span class="lineCov">          5 :   fArm1PhiMin = fEMCGeometry-&gt;GetArm1PhiMin();</span>
<span class="lineNum">     150 </span><span class="lineCov">          5 :   fArm1PhiMax = fEMCGeometry-&gt;GetArm1PhiMax();</span>
<span class="lineNum">     151 </span><span class="lineCov">          5 :   fDCALPhiMin = fEMCGeometry-&gt;GetDCALPhiMin();</span>
<span class="lineNum">     152 </span><span class="lineCov">          5 :   fDCALPhiMax = fEMCGeometry-&gt;GetDCALPhiMax();</span>
<span class="lineNum">     153 </span><span class="lineCov">          5 :   fEMCALPhiMax = fEMCGeometry-&gt;GetEMCALPhiMax();</span>
<span class="lineNum">     154 </span><span class="lineCov">          5 :   fDCALStandardPhiMax = fEMCGeometry-&gt;GetDCALStandardPhiMax();</span>
<span class="lineNum">     155 </span><span class="lineCov">          5 :   fDCALInnerExtandedEta = fEMCGeometry-&gt;GetDCALInnerExtandedEta();</span>
<span class="lineNum">     156 </span><span class="lineCov">          5 :   fShellThickness = fEMCGeometry-&gt;GetShellThickness();</span>
<span class="lineNum">     157 </span><span class="lineCov">          5 :   fZLength    = fEMCGeometry-&gt;GetZLength();</span>
<span class="lineNum">     158 </span><span class="lineCov">          5 :   fSampling   = fEMCGeometry-&gt;GetSampling();</span>
<span class="lineNum">     159 </span><span class="lineCov">          5 :   fEtaModuleSize = fEMCGeometry-&gt;GetEtaModuleSize();</span>
<span class="lineNum">     160 </span><span class="lineCov">          5 :   fPhiModuleSize = fEMCGeometry-&gt;GetPhiModuleSize();</span>
<span class="lineNum">     161 </span><span class="lineCov">          5 :   fEtaTileSize = fEMCGeometry-&gt;GetEtaTileSize();</span>
<span class="lineNum">     162 </span><span class="lineCov">          5 :   fPhiTileSize = fEMCGeometry-&gt;GetPhiTileSize();</span>
<span class="lineNum">     163 </span><span class="lineCov">          5 :   fNZ          = fEMCGeometry-&gt;GetNZ();</span>
<span class="lineNum">     164 </span><span class="lineCov">          5 :   fIPDistance  = fEMCGeometry-&gt;GetIPDistance();</span>
<span class="lineNum">     165 </span><span class="lineCov">          5 :   fLongModuleSize = fEMCGeometry-&gt;GetLongModuleSize();</span>
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span><span class="lineCov">          5 :   CreateListOfTrd1Modules();</span>
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span><span class="lineCov">        230 :   for(Int_t smod=0; smod &lt; AliEMCALGeoParams::fgkEMCALModules; smod++)</span>
<span class="lineNum">     170 </span><span class="lineCov">        110 :     fkSModuleMatrix[smod]=0 ;   </span>
<span class="lineNum">     171 </span>            :         
<span class="lineNum">     172 </span><span class="lineCov">         20 :   if (AliDebugLevel()&gt;=2) {</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :     fEMCGeometry-&gt;Print();</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :     PrintGeometryGeoUtils();</span>
<span class="lineNum">     175 </span>            :   }
<span class="lineNum">     176 </span>            :   
<span class="lineNum">     177 </span><span class="lineCov">         10 :   AliLog::Message(AliLog::kInfo, Form(&quot;Name &lt;&lt;%s&gt;&gt;&quot;,name),</span>
<span class="lineNum">     178 </span>            :                   MODULENAME(), &quot;AliEMCALGeometry&quot;, FUNCTIONNAME(), __FILE__, __LINE__);  
<span class="lineNum">     179 </span>            :   
<span class="lineNum">     180 </span><span class="lineCov">         15 :   if ((fEMCGeometry-&gt;GetGeoName()).Contains(&quot;DCAL&quot;)) {</span>
<span class="lineNum">     181 </span><span class="lineCov">          6 :     fTriggerMapping = new AliEMCALTriggerMappingV2(52, this);</span>
<span class="lineNum">     182 </span><span class="lineCov">          2 :     AliLog::Message(AliLog::kInfo, &quot;EMCAL Trigger Mapping Version V2 Enabled&quot;,</span>
<span class="lineNum">     183 </span>            :                     MODULENAME(), &quot;AliEMCALGeometry&quot;, FUNCTIONNAME(), __FILE__, __LINE__);
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            :   } else { 
<span class="lineNum">     186 </span><span class="lineCov">          9 :     fTriggerMapping = new AliEMCALTriggerMappingV1(32, this);</span>
<span class="lineNum">     187 </span><span class="lineCov">          3 :     AliLog::Message(AliLog::kInfo, &quot;EMCAL Trigger Mapping Version V1 Enabled&quot;,</span>
<span class="lineNum">     188 </span>            :                     MODULENAME(), &quot;AliEMCALGeometry&quot;, FUNCTIONNAME(), __FILE__, __LINE__);
<span class="lineNum">     189 </span>            :   }
<span class="lineNum">     190 </span><span class="lineCov">         10 : }</span>
<a name="191"><span class="lineNum">     191 </span>            : </a>
<span class="lineNum">     192 </span>            : //____________________________________________________________________________
<span class="lineNum">     193 </span>            : AliEMCALGeometry &amp; AliEMCALGeometry::operator = (const AliEMCALGeometry  &amp; /*rvalue*/) 
<span class="lineNum">     194 </span>            : { 
<span class="lineNum">     195 </span>            :   //assing operator
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :   Fatal(&quot;assignment operator&quot;, &quot;not implemented&quot;) ; </span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :   return *this ;</span>
<span class="lineNum">     198 </span>            : }
<a name="199"><span class="lineNum">     199 </span>            : </a>
<span class="lineNum">     200 </span>            : //____________________________________________________________________________
<span class="lineNum">     201 </span>            : AliEMCALGeometry::~AliEMCALGeometry(void)
<span class="lineNum">     202 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">     203 </span>            :   // dtor
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :   if (this==fgGeom)</span>
<span class="lineNum">     205 </span>            :   {
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :     AliError(&quot;Do not call delete on me&quot;);</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     208 </span>            :   }
<span class="lineNum">     209 </span>            :   
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :   if (fEMCGeometry)</span>
<span class="lineNum">     211 </span>            :   {
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :     for(Int_t smod = 0 ; smod &lt; fEMCGeometry-&gt;GetNumberOfSuperModules(); smod++)</span>
<span class="lineNum">     213 </span>            :     {
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :       if(fkSModuleMatrix[smod])</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :         delete fkSModuleMatrix[smod] ;</span>
<span class="lineNum">     216 </span>            :       
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :       fkSModuleMatrix[smod]=0 ;</span>
<span class="lineNum">     218 </span>            :     }
<span class="lineNum">     219 </span>            :     
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :     delete fEMCGeometry; // fEMCGeometry = 0 ;</span>
<span class="lineNum">     221 </span>            :   }
<span class="lineNum">     222 </span>            :   
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :   if (fTriggerMapping) delete fTriggerMapping;</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 : }</span>
<a name="225"><span class="lineNum">     225 </span>            : </a>
<span class="lineNum">     226 </span>            : //______________________________________________________________________
<span class="lineNum">     227 </span>            : AliEMCALGeometry *  AliEMCALGeometry::GetInstance()
<span class="lineNum">     228 </span>            : { 
<span class="lineNum">     229 </span>            :   // Returns the pointer of the unique instance
<span class="lineNum">     230 </span>            :   
<span class="lineNum">     231 </span><span class="lineCov">     143214 :   AliEMCALGeometry * rv = static_cast&lt;AliEMCALGeometry *&gt;( fgGeom );</span>
<span class="lineNum">     232 </span><span class="lineCov">      71607 :   return rv; </span>
<span class="lineNum">     233 </span>            : }
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            : //
<span class="lineNum">     236 </span>            : /// \return the pointer of the unique instance
<a name="237"><span class="lineNum">     237 </span>            : ///</a>
<span class="lineNum">     238 </span>            : //______________________________________________________________________
<span class="lineNum">     239 </span>            : AliEMCALGeometry* AliEMCALGeometry::GetInstance(const Text_t* name,   const Text_t* title,
<span class="lineNum">     240 </span>            :                                                 const Text_t* mcname, const Text_t* mctitle )
<span class="lineNum">     241 </span>            : {
<span class="lineNum">     242 </span>            :   AliEMCALGeometry * rv = 0; 
<span class="lineNum">     243 </span>            :   
<span class="lineNum">     244 </span><span class="lineCov">         18 :   if ( fgGeom == 0 ) </span>
<span class="lineNum">     245 </span>            :   {
<span class="lineNum">     246 </span><span class="lineCov">         10 :     if ( strcmp(name,&quot;&quot;) == 0 ) </span>
<span class="lineNum">     247 </span>            :     { // get default geometry
<span class="lineNum">     248 </span><span class="lineCov">          5 :       fgGeom = new AliEMCALGeometry(fgkDefaultGeometryName, title, mcname, mctitle);</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :     } </span>
<span class="lineNum">     250 </span>            :     else 
<span class="lineNum">     251 </span>            :     {
<span class="lineNum">     252 </span><span class="lineCov">         10 :       fgGeom = new AliEMCALGeometry(name, title,mcname,mctitle);</span>
<span class="lineNum">     253 </span>            :     }  // end if strcmp(name,&quot;&quot;)
<span class="lineNum">     254 </span>            :     
<span class="lineNum">     255 </span><span class="lineCov">          5 :     if ( AliEMCALEMCGeometry::fgInit ) </span>
<span class="lineNum">     256 </span>            :     {
<span class="lineNum">     257 </span><span class="lineCov">          5 :       rv = (AliEMCALGeometry * ) fgGeom;</span>
<span class="lineNum">     258 </span><span class="lineCov">          5 :     }</span>
<span class="lineNum">     259 </span>            :     else 
<span class="lineNum">     260 </span>            :     {
<span class="lineNum">     261 </span>            :       rv = 0; 
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :       delete fgGeom; </span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :       fgGeom = 0; </span>
<span class="lineNum">     264 </span>            :     } // end if fgInit
<span class="lineNum">     265 </span>            :   }
<span class="lineNum">     266 </span>            :   else
<span class="lineNum">     267 </span>            :   {
<span class="lineNum">     268 </span><span class="lineCov">          4 :     if ( strcmp(fgGeom-&gt;GetName(), name) != 0)</span>
<span class="lineNum">     269 </span>            :     {
<span class="lineNum">     270 </span><span class="lineCov">          4 :       printf(&quot;\n current geometry is %s : &quot;, fgGeom-&gt;GetName());</span>
<span class="lineNum">     271 </span><span class="lineCov">          4 :       printf(&quot; you should not call %s \n&quot;,name);</span>
<span class="lineNum">     272 </span><span class="lineCov">          4 :     } // end </span>
<span class="lineNum">     273 </span>            :     
<span class="lineNum">     274 </span><span class="lineCov">          4 :     rv = (AliEMCALGeometry *) fgGeom; </span>
<span class="lineNum">     275 </span>            :   }  // end if fgGeom
<span class="lineNum">     276 </span>            :   
<span class="lineNum">     277 </span><span class="lineCov">          9 :   return rv; </span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span>            : ///
<span class="lineNum">     281 </span>            : /// Instanciate geometry depending on the run number
<span class="lineNum">     282 </span>            : ///
<span class="lineNum">     283 </span>            : /// \return the pointer of the unique instance
<a name="284"><span class="lineNum">     284 </span>            : ///</a>
<span class="lineNum">     285 </span>            : //___________________________________________________________________________
<span class="lineNum">     286 </span>            : AliEMCALGeometry* AliEMCALGeometry::GetInstanceFromRunNumber(Int_t runNumber,       TString geoName,
<span class="lineNum">     287 </span>            :                                                              const Text_t* mcname,  const Text_t* mctitle )
<span class="lineNum">     288 </span>            : {
<span class="lineNum">     289 </span>            :   //printf(&quot;AliEMCALGeometry::GetInstanceFromRunNumber() - run %d, geoName &lt;&lt;%s&gt;&gt; \n&quot;,runNumber,geoName.Data());
<span class="lineNum">     290 </span>            :   
<span class="lineNum">     291 </span><span class="lineCov">         18 :   static bool showInfo = !(getenv(&quot;HLT_ONLINE_MODE&quot;) &amp;&amp; strcmp(getenv(&quot;HLT_ONLINE_MODE&quot;), &quot;on&quot;) == 0);</span>
<span class="lineNum">     292 </span>            :   
<span class="lineNum">     293 </span><span class="lineCov">          3 :   if      ( runNumber &gt;= 104064 &amp;&amp; runNumber &lt; 140000  ) </span>
<span class="lineNum">     294 </span>            :   {
<span class="lineNum">     295 </span>            :     // 2009-2010 runs
<span class="lineNum">     296 </span>            :     // First year geometry, 4 SM.
<span class="lineNum">     297 </span>            :     
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :     if (showInfo)</span>
<span class="lineNum">     299 </span>            :     {
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :       if(!geoName.Contains(&quot;FIRSTYEARV1&quot;) &amp;&amp; geoName!=&quot;&quot;)</span>
<span class="lineNum">     301 </span>            :       { 
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :         printf(&quot;AliEMCALGeometry::GetInstanceFromRunNumber() *** ATTENTION *** \n&quot;);</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :         printf(&quot;\t Specified geometry name &lt;&lt;%s&gt;&gt; for run %d is not considered! \n&quot;,geoName.Data(),runNumber);</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :         printf(&quot;\t In use &lt;&lt;EMCAL_FIRSTYEARV1&gt;&gt;, check run number and year\n&quot;);</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     306 </span>            :       else 
<span class="lineNum">     307 </span>            :       {
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :         printf(&quot;AliEMCALGeometry::GetInstanceFromRunNumber() - Initialized geometry with name &lt;&lt;EMCAL_FIRSTYEARV1&gt;&gt;\n&quot;);</span>
<span class="lineNum">     309 </span>            :       }
<span class="lineNum">     310 </span>            :     }
<span class="lineNum">     311 </span>            :     
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :     return AliEMCALGeometry::GetInstance(&quot;EMCAL_FIRSTYEARV1&quot;,&quot;EMCAL&quot;,mcname,mctitle) ;</span>
<span class="lineNum">     313 </span>            :   }
<span class="lineNum">     314 </span><span class="lineCov">          3 :   else if ( runNumber &gt;= 140000 &amp;&amp; runNumber &lt;= 170593 )</span>
<span class="lineNum">     315 </span>            :   {
<span class="lineNum">     316 </span>            :     // Almost complete EMCAL geometry, 10 SM. Year 2011 configuration
<span class="lineNum">     317 </span>            :     
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :     if (showInfo)</span>
<span class="lineNum">     319 </span>            :     {
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :       if(!geoName.Contains(&quot;COMPLETEV1&quot;) &amp;&amp; geoName!=&quot;&quot;)</span>
<span class="lineNum">     321 </span>            :       {
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :         printf(&quot;AliEMCALGeometry::GetInstanceFromRunNumber() *** ATTENTION *** \n&quot;);</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :         printf(&quot;\t Specified geometry name &lt;&lt;%s&gt;&gt; for run %d is not considered! \n&quot;,geoName.Data(),runNumber);</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :         printf(&quot;\t In use &lt;&lt;EMCAL_COMPLETEV1&gt;&gt;, check run number and year\n&quot;);</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     326 </span>            :       else 
<span class="lineNum">     327 </span>            :       {
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :         printf(&quot;AliEMCALGeometry::GetInstanceFromRunNumber() - Initialized geometry with name &lt;&lt;EMCAL_COMPLETEV1&gt;&gt;\n&quot;);</span>
<span class="lineNum">     329 </span>            :       }
<span class="lineNum">     330 </span>            :     }
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :     return AliEMCALGeometry::GetInstance(&quot;EMCAL_COMPLETEV1&quot;,&quot;EMCAL&quot;,mcname,mctitle) ;</span>
<span class="lineNum">     332 </span>            :   }
<span class="lineNum">     333 </span><span class="lineCov">          6 :   else if ( runNumber &gt;  176000 &amp;&amp; runNumber &lt;= 197692 )</span>
<span class="lineNum">     334 </span>            :   {
<span class="lineNum">     335 </span>            :     // Complete EMCAL geometry, 12 SM. Year 2012 and on
<span class="lineNum">     336 </span>            :     // The last 2 SM were not active, anyway they were there.
<span class="lineNum">     337 </span>            :     
<span class="lineNum">     338 </span><span class="lineCov">          3 :     if (showInfo)</span>
<span class="lineNum">     339 </span>            :     {
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :       if(!geoName.Contains(&quot;COMPLETE12SMV1&quot;) &amp;&amp; geoName!=&quot;&quot;)</span>
<span class="lineNum">     341 </span>            :       {
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :         printf(&quot;AliEMCALGeometry::GetInstanceFromRunNumber() *** ATTENTION *** \n&quot;);</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :         printf(&quot;\t Specified geometry name &lt;&lt;%s&gt;&gt; for run %d is not considered! \n&quot;,geoName.Data(),runNumber);</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :         printf(&quot;\t In use &lt;&lt;EMCAL_COMPLETE12SMV1&gt;&gt;, check run number and year\n&quot;);</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     346 </span>            :       else 
<span class="lineNum">     347 </span>            :       {
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :         printf(&quot;AliEMCALGeometry::GetInstanceFromRunNumber() - Initialized geometry with name &lt;&lt;EMCAL_COMPLETE12SMV1&gt;&gt;\n&quot;);</span>
<span class="lineNum">     349 </span>            :       }
<span class="lineNum">     350 </span>            :     }
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :     return AliEMCALGeometry::GetInstance(&quot;EMCAL_COMPLETE12SMV1&quot;,&quot;EMCAL&quot;,mcname,mctitle) ;</span>
<span class="lineNum">     352 </span>            :   }
<span class="lineNum">     353 </span>            :   else // Run 2
<span class="lineNum">     354 </span>            :   {
<span class="lineNum">     355 </span>            :     // EMCAL + DCAL geometry, 20 SM. Year 2015 and on
<span class="lineNum">     356 </span>            :     
<span class="lineNum">     357 </span><span class="lineCov">          3 :     if (showInfo)</span>
<span class="lineNum">     358 </span>            :     {
<span class="lineNum">     359 </span><span class="lineCov">          5 :       if(!geoName.Contains(&quot;DCAL_8SM&quot;) &amp;&amp; geoName!=&quot;&quot;)</span>
<span class="lineNum">     360 </span>            :       {
<span class="lineNum">     361 </span><span class="lineCov">          1 :         printf(&quot;AliEMCALGeometry::GetInstanceFromRunNumber() *** ATTENTION *** \n&quot;);</span>
<span class="lineNum">     362 </span><span class="lineCov">          1 :         printf(&quot;\t Specified geometry name &lt;&lt;%s&gt;&gt; for run %d is not considered! \n&quot;,geoName.Data(),runNumber);</span>
<span class="lineNum">     363 </span><span class="lineCov">          1 :         printf(&quot;\t In use &lt;&lt;EMCAL_COMPLETE12SMV1_DCAL_8SM&gt;&gt;, check run number and year\n&quot;);</span>
<span class="lineNum">     364 </span><span class="lineCov">          1 :       }</span>
<span class="lineNum">     365 </span>            :       else 
<span class="lineNum">     366 </span>            :       {
<span class="lineNum">     367 </span><span class="lineCov">          2 :         printf(&quot;AliEMCALGeometry::GetInstanceFromRunNumber() - Initialized geometry with name &lt;&lt;EMCAL_COMPLETE12SMV1_DCAL_8SM&gt;&gt;\n&quot;);</span>
<span class="lineNum">     368 </span>            :       }
<span class="lineNum">     369 </span>            :     }
<span class="lineNum">     370 </span><span class="lineCov">          3 :     return AliEMCALGeometry::GetInstance(&quot;EMCAL_COMPLETE12SMV1_DCAL_8SM&quot;,&quot;EMCAL&quot;,mcname,mctitle) ;</span>
<span class="lineNum">     371 </span>            :   }  
<span class="lineNum">     372 </span><span class="lineCov">          3 : }</span>
<a name="373"><span class="lineNum">     373 </span>            : </a>
<span class="lineNum">     374 </span>            : //________________________________________________________________________________________________
<span class="lineNum">     375 </span>            : void AliEMCALGeometry::Browse(TBrowser* b)
<span class="lineNum">     376 </span>            : {
<span class="lineNum">     377 </span>            :   //Browse the modules
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :   if(fShishKebabTrd1Modules) b-&gt;Add(fShishKebabTrd1Modules);</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 : }</span>
<a name="380"><span class="lineNum">     380 </span>            : </a>
<span class="lineNum">     381 </span>            : //________________________________________________________________________________________________
<span class="lineNum">     382 </span>            : Bool_t AliEMCALGeometry::IsFolder() const
<span class="lineNum">     383 </span>            : {
<span class="lineNum">     384 </span>            :   //Check if fShishKebabTrd1Modules is in folder
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :   if(fShishKebabTrd1Modules) return kTRUE;</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :   else                       return kFALSE;</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 : }</span>
<a name="388"><span class="lineNum">     388 </span>            : </a>
<span class="lineNum">     389 </span>            : //________________________________________________________________________________________________
<span class="lineNum">     390 </span>            : void AliEMCALGeometry::GetGlobal(const Double_t *loc, Double_t *glob, int ind) const
<span class="lineNum">     391 </span>            : {
<span class="lineNum">     392 </span>            :   // Figure out the global numbering
<span class="lineNum">     393 </span>            :   // of a given supermodule from the
<span class="lineNum">     394 </span>            :   // local numbering and the transformation
<span class="lineNum">     395 </span>            :   // matrix stored by the geometry manager (allows for misaligned
<span class="lineNum">     396 </span>            :   // geometry)
<span class="lineNum">     397 </span>            :         
<span class="lineNum">     398 </span><span class="lineCov">        194 :   const TGeoHMatrix* m = GetMatrixForSuperModule(ind);</span>
<span class="lineNum">     399 </span><span class="lineCov">         97 :   if(m) {</span>
<span class="lineNum">     400 </span><span class="lineCov">         97 :     m-&gt;LocalToMaster(loc, glob);</span>
<span class="lineNum">     401 </span><span class="lineCov">         97 :   } else {</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :     AliFatal(&quot;Geo matrixes are not loaded \n&quot;) ;</span>
<span class="lineNum">     403 </span>            :   }
<span class="lineNum">     404 </span><span class="lineCov">         97 : }</span>
<a name="405"><span class="lineNum">     405 </span>            : </a>
<span class="lineNum">     406 </span>            : //________________________________________________________________________________________________
<span class="lineNum">     407 </span>            : void AliEMCALGeometry::GetGlobal(const TVector3 &amp;vloc, TVector3 &amp;vglob, int ind) const
<span class="lineNum">     408 </span>            : {
<span class="lineNum">     409 </span>            :   //Figure out the global numbering
<span class="lineNum">     410 </span>            :   //of a given supermodule from the
<span class="lineNum">     411 </span>            :   //local numbering given a 3-vector location
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span>            :   static Double_t tglob[3], tloc[3];
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :   vloc.GetXYZ(tloc);</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :   GetGlobal(tloc, tglob, ind);</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :   vglob.SetXYZ(tglob[0], tglob[1], tglob[2]);</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 : }</span>
<a name="418"><span class="lineNum">     418 </span>            : </a>
<span class="lineNum">     419 </span>            : //________________________________________________________________________________________________
<span class="lineNum">     420 </span>            : void AliEMCALGeometry::GetGlobal(Int_t absId , double glob[3]) const
<span class="lineNum">     421 </span>            : {
<span class="lineNum">     422 </span>            :   // Alice numbering scheme - Jun 03, 2006
<span class="lineNum">     423 </span>            :   static Int_t nSupMod=-1, nModule=-1, nIphi=-1, nIeta=-1;
<span class="lineNum">     424 </span>            :   static double loc[3];
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :   glob[0]=glob[1]=glob[2]=0.0; // bad case</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :   if(RelPosCellInSModule(absId, loc)) {</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :     GetCellIndex(absId, nSupMod, nModule, nIphi, nIeta);</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :     const TGeoHMatrix* m = GetMatrixForSuperModule(nSupMod);</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :     if(m) {</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :       m-&gt;LocalToMaster(loc, glob);</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :       AliFatal(&quot;Geo matrixes are not loaded \n&quot;) ;</span>
<span class="lineNum">     434 </span>            :     }
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 : }</span>
<a name="437"><span class="lineNum">     437 </span>            : </a>
<span class="lineNum">     438 </span>            : //___________________________________________________________________
<span class="lineNum">     439 </span>            : void AliEMCALGeometry::GetGlobal(Int_t absId , TVector3 &amp;vglob) const
<span class="lineNum">     440 </span>            : {
<span class="lineNum">     441 </span>            :   // Alice numbering scheme - Jun 03, 2006
<span class="lineNum">     442 </span>            :   static Double_t glob[3];
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :   GetGlobal(absId, glob);</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :   vglob.SetXYZ(glob[0], glob[1], glob[2]);</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 : }</span>
<a name="447"><span class="lineNum">     447 </span>            : </a>
<span class="lineNum">     448 </span>            : //______________________________________________________________________
<span class="lineNum">     449 </span>            : void AliEMCALGeometry::PrintCellIndexes(Int_t absId, int pri, const char *tit) const
<span class="lineNum">     450 </span>            : {
<span class="lineNum">     451 </span>            :   // Service methods
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :   Int_t nSupMod, nModule, nIphi, nIeta;</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :   Int_t iphi, ieta;</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :   TVector3 vg;</span>
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :   GetCellIndex(absId,  nSupMod, nModule, nIphi, nIeta);</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :   printf(&quot; %s | absId : %i -&gt; nSupMod %i nModule %i nIphi %i nIeta %i \n&quot;, tit, absId,  nSupMod, nModule, nIphi, nIeta);</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :   if(pri&gt;0) {</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :     GetCellPhiEtaIndexInSModule(nSupMod,nModule,nIphi,nIeta, iphi,ieta);</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :     printf(&quot; local SM index : iphi %i : ieta %i \n&quot;, iphi,ieta);</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :     GetGlobal(absId, vg);</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :     printf(&quot; vglob : mag %7.2f : perp %7.2f : z %7.2f : eta %6.4f : phi %6.4f(%6.2f) \n&quot;, </span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :            vg.Mag(), vg.Perp(), vg.Z(), vg.Eta(), vg.Phi(), vg.Phi()*TMath::RadToDeg());</span>
<span class="lineNum">     464 </span>            :   }
<a name="465"><span class="lineNum">     465 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            : void AliEMCALGeometry::PrintLocalTrd1(Int_t pri) const
<span class="lineNum">     468 </span>            : {
<span class="lineNum">     469 </span>            :   // For comparing with numbers from drawing
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :   for(Int_t i=0; i&lt;GetShishKebabTrd1Modules()-&gt;GetSize(); i++){</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :     printf(&quot; %s | &quot;, GetShishKebabModule(i)-&gt;GetName());</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :     if(i==0 &amp;&amp; pri&lt;1) GetShishKebabModule(i)-&gt;PrintShish(1);</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :     else     GetShishKebabModule(i)-&gt;PrintShish(pri);</span>
<span class="lineNum">     474 </span>            :   }
<span class="lineNum">     475 </span><span class="lineNoCov">          0 : }</span>
<a name="476"><span class="lineNum">     476 </span>            : </a>
<span class="lineNum">     477 </span>            : //________________________________________________________________________________________________
<span class="lineNum">     478 </span>            : void AliEMCALGeometry::EtaPhiFromIndex(Int_t absId,Double_t &amp;eta,Double_t &amp;phi) const
<span class="lineNum">     479 </span>            : {
<span class="lineNum">     480 </span>            :   // Nov 16, 2006- float to double
<span class="lineNum">     481 </span>            :   // version for TRD1 only
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :   static TVector3 vglob;</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :   GetGlobal(absId, vglob);</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :   eta = vglob.Eta();</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :   phi = vglob.Phi();</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 : }</span>
<a name="487"><span class="lineNum">     487 </span>            : </a>
<span class="lineNum">     488 </span>            : //________________________________________________________________________________________________
<span class="lineNum">     489 </span>            : void AliEMCALGeometry::EtaPhiFromIndex(Int_t absId,Float_t &amp;eta,Float_t &amp;phi) const
<span class="lineNum">     490 </span>            : {
<span class="lineNum">     491 </span>            :   // Nov 16,2006 - should be discard in future
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :   static TVector3 vglob;</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :   GetGlobal(absId, vglob);</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :   eta = float(vglob.Eta());</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :   phi = float(vglob.Phi());</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span>            : //
<span class="lineNum">     499 </span>            : // == Shish-kebab cases ==
<a name="500"><span class="lineNum">     500 </span>            : //</a>
<span class="lineNum">     501 </span>            : //________________________________________________________________________________________________
<span class="lineNum">     502 </span>            : Int_t AliEMCALGeometry::GetAbsCellId(Int_t nSupMod, Int_t nModule, Int_t nIphi, Int_t nIeta) const
<span class="lineNum">     503 </span>            : { 
<span class="lineNum">     504 </span>            :   // 27-aug-04; 
<span class="lineNum">     505 </span>            :   // corr. 21-sep-04; 
<span class="lineNum">     506 </span>            :   //       13-oct-05; 110 degree case
<span class="lineNum">     507 </span>            :   // May 31, 2006; ALICE numbering scheme:
<span class="lineNum">     508 </span>            :   // 0 &lt;= nSupMod &lt; fNumberOfSuperModules
<span class="lineNum">     509 </span>            :   // 0 &lt;= nModule  &lt; fNPHI * fNZ ( fNPHI * fNZ/2 for fKey110DEG=1)
<span class="lineNum">     510 </span>            :   // 0 &lt;= nIphi   &lt; fNPHIdiv
<span class="lineNum">     511 </span>            :   // 0 &lt;= nIeta   &lt; fNETAdiv
<span class="lineNum">     512 </span>            :   // 0 &lt;= absid   &lt; fNCells
<span class="lineNum">     513 </span>            :   Int_t id=0; // have to change from 0 to fNCells-1
<span class="lineNum">     514 </span><span class="lineCov">     894622 :   for( int i = 0 ; i &lt; nSupMod; i++) {</span>
<span class="lineNum">     515 </span><span class="lineCov">     698181 :     if(      GetSMType(i) == kEMCAL_Standard) id += fNCellsInSupMod;</span>
<span class="lineNum">     516 </span><span class="lineCov">       1747 :     else if( GetSMType(i) == kEMCAL_Half)     id += fNCellsInSupMod/2;</span>
<span class="lineNum">     517 </span><span class="lineCov">       2960 :     else if( GetSMType(i) == kEMCAL_3rd)      id += fNCellsInSupMod/3;</span>
<span class="lineNum">     518 </span><span class="lineCov">       1068 :     else if( GetSMType(i) == kDCAL_Standard)  id += 2*fNCellsInSupMod/3;</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :     else if( GetSMType(i) == kDCAL_Ext)       id += fNCellsInSupMod/3;</span>
<span class="lineNum">     520 </span>            :     else {
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :       AliError(Form(&quot;Uknown SuperModule Type !!&quot;));</span>
<span class="lineNum">     522 </span>            :     }
<span class="lineNum">     523 </span>            :   }
<span class="lineNum">     524 </span>            :   
<span class="lineNum">     525 </span><span class="lineCov">      64898 :   id += fNCellsInModule *nModule;</span>
<span class="lineNum">     526 </span><span class="lineCov">      64898 :   id += fNPHIdiv *nIphi;</span>
<span class="lineNum">     527 </span><span class="lineCov">      64898 :   id += nIeta;</span>
<span class="lineNum">     528 </span><span class="lineCov">      64898 :   if( !CheckAbsCellId(id) ) {</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :     id = -TMath::Abs(id); // if negative something wrong</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     531 </span><span class="lineCov">      64898 :   return id;</span>
<span class="lineNum">     532 </span>            : }
<a name="533"><span class="lineNum">     533 </span>            : </a>
<span class="lineNum">     534 </span>            : //________________________________________________________________________________________________
<span class="lineNum">     535 </span>            : void  AliEMCALGeometry::GetModuleIndexesFromCellIndexesInSModule(Int_t nSupMod, Int_t iphi, Int_t ieta, 
<span class="lineNum">     536 </span>            :                         Int_t &amp;iphim, Int_t &amp;ietam, Int_t &amp;nModule) const
<span class="lineNum">     537 </span>            : {
<span class="lineNum">     538 </span>            :   // Transition from cell indexes (ieta,iphi) to module indexes (ietam,iphim, nModule)
<span class="lineNum">     539 </span>            :   static Int_t nphi=-1;
<span class="lineNum">     540 </span><span class="lineCov">     129796 :   nphi  = GetNumberOfModuleInPhiDirection(nSupMod);  </span>
<span class="lineNum">     541 </span>            : 
<span class="lineNum">     542 </span><span class="lineCov">      64898 :   ietam  = ieta/fNETAdiv;</span>
<span class="lineNum">     543 </span><span class="lineCov">      64898 :   iphim  = iphi/fNPHIdiv;</span>
<span class="lineNum">     544 </span><span class="lineCov">      64898 :   nModule = ietam * nphi + iphim; </span>
<span class="lineNum">     545 </span><span class="lineCov">      64898 : }</span>
<a name="546"><span class="lineNum">     546 </span>            : </a>
<span class="lineNum">     547 </span>            : //________________________________________________________________________________________________
<span class="lineNum">     548 </span>            : Int_t  AliEMCALGeometry::GetAbsCellIdFromCellIndexes(Int_t nSupMod, Int_t iphi, Int_t ieta) const
<span class="lineNum">     549 </span>            : {
<span class="lineNum">     550 </span>            :   // Transition from super module number(nSupMod) and cell indexes (ieta,iphi) to absId
<span class="lineNum">     551 </span>            :   
<span class="lineNum">     552 </span>            :   // Check if the indeces correspond to existing SM or tower indeces
<span class="lineNum">     553 </span><span class="lineCov">     389406 :   if(iphi    &lt; 0 || iphi    &gt;= AliEMCALGeoParams::fgkEMCALRows || </span>
<span class="lineNum">     554 </span><span class="lineCov">     129802 :      ieta    &lt; 0 || ieta    &gt;= AliEMCALGeoParams::fgkEMCALCols ||</span>
<span class="lineNum">     555 </span><span class="lineCov">     129802 :      nSupMod &lt; 0 || nSupMod &gt;= GetNumberOfSuperModules()         )</span>
<span class="lineNum">     556 </span>            :   {
<span class="lineNum">     557 </span><span class="lineCov">          9 :     AliDebug(1,Form(&quot;Wrong cell indexes : SM %d, column (eta) %d, row (phi) %d&quot;, nSupMod,ieta,iphi));</span>
<span class="lineNum">     558 </span><span class="lineCov">          3 :     return -1 ;</span>
<span class="lineNum">     559 </span>            :   }
<span class="lineNum">     560 </span>            :   
<span class="lineNum">     561 </span>            :   static Int_t ietam=-1, iphim=-1, nModule=-1;
<span class="lineNum">     562 </span>            :   static Int_t nIeta=-1, nIphi=-1; // cell indexes in module
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span><span class="lineCov">      64898 :   GetModuleIndexesFromCellIndexesInSModule(nSupMod, iphi, ieta, ietam, iphim, nModule);</span>
<span class="lineNum">     565 </span>            : 
<span class="lineNum">     566 </span><span class="lineCov">      64898 :   nIeta = ieta%fNETAdiv;</span>
<span class="lineNum">     567 </span><span class="lineCov">      64898 :   nIeta = fNETAdiv - 1 - nIeta;</span>
<span class="lineNum">     568 </span><span class="lineCov">      64898 :   nIphi = iphi%fNPHIdiv;</span>
<span class="lineNum">     569 </span>            :   
<span class="lineNum">     570 </span><span class="lineCov">      64898 :   return GetAbsCellId(nSupMod, nModule, nIphi, nIeta);</span>
<span class="lineNum">     571 </span><span class="lineCov">      64901 : }</span>
<a name="572"><span class="lineNum">     572 </span>            : </a>
<span class="lineNum">     573 </span>            : //________________________________________________________________________________________________
<span class="lineNum">     574 </span>            : Bool_t AliEMCALGeometry::SuperModuleNumberFromEtaPhi(Double_t eta, Double_t phi, Int_t &amp;nSupMod) const
<span class="lineNum">     575 </span>            : { 
<span class="lineNum">     576 </span>            :   // Return false if phi belongs a phi cracks between SM
<span class="lineNum">     577 </span>            :  
<span class="lineNum">     578 </span>            :   static Int_t i=0;
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :   if(TMath::Abs(eta) &gt; fEtaMaxOfTRD1) return kFALSE;</span>
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :   phi = TVector2::Phi_0_2pi(phi); // move phi to (0,2pi) boundaries</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :   Int_t nphism = fEMCGeometry-&gt;GetNumberOfSuperModules()/2;</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :   for(i=0; i&lt;nphism; i++) {</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :     if(phi&gt;=fPhiBoundariesOfSM[2*i] &amp;&amp; phi&lt;=fPhiBoundariesOfSM[2*i+1]) {</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :       nSupMod = 2*i;</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :       if(eta &lt; 0.0) nSupMod++;</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :       if( GetSMType(nSupMod) == kDCAL_Standard) {// Gap between DCAL</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :         if(TMath::Abs(eta) &lt; GetNEta()/3*(GetEMCGeometry()-&gt;GetTrd1Angle())*TMath::DegToRad()) return kFALSE;</span>
<span class="lineNum">     590 </span>            :       }
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :       AliDebug(1,Form(&quot;eta %f phi %f(%5.2f) : nSupMod %i : #bound %i&quot;, eta,phi,phi*TMath::RadToDeg(), nSupMod,i));</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :       return kTRUE;</span>
<span class="lineNum">     593 </span>            :     }
<span class="lineNum">     594 </span>            :   }
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :   return kFALSE;</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span>            : ///
<span class="lineNum">     599 </span>            : /// Online mapping and numbering is the same for EMCal and DCal SMs but:
<span class="lineNum">     600 </span>            : ///  - DCal odd SM (13,15,17) has online cols: 16-47; offline cols 0-31.
<span class="lineNum">     601 </span>            : ///  - Even DCal SMs have the same numbering online and offline 0-31.
<span class="lineNum">     602 </span>            : ///  - DCal 1/3 SM (18,19), online rows 16-23; offline rows 0-7
<span class="lineNum">     603 </span>            : ///
<span class="lineNum">     604 </span>            : /// Here shift the online cols or rows depending on the
<span class="lineNum">     605 </span>            : /// super-module number to match the offline mapping.
<span class="lineNum">     606 </span>            : ///
<span class="lineNum">     607 </span>            : /// \param sm: super module number of the channel/cell
<span class="lineNum">     608 </span>            : /// \param iphi: row/phi cell index, modified for DCal
<span class="lineNum">     609 </span>            : /// \param ieta: column/eta index, modified for DCal
<a name="610"><span class="lineNum">     610 </span>            : ///</a>
<span class="lineNum">     611 </span>            : //________________________________________________________________________________________________
<span class="lineNum">     612 </span>            : void AliEMCALGeometry::ShiftOnlineToOfflineCellIndexes(Int_t sm, Int_t &amp; iphi, Int_t &amp; ieta) const 
<span class="lineNum">     613 </span>            : {
<span class="lineNum">     614 </span><span class="lineCov">        116 :   if ( sm == 13 || sm == 15 || sm == 17 )</span>
<span class="lineNum">     615 </span>            :   {
<span class="lineNum">     616 </span>            :     // DCal odd SMs
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :     ieta -= 16; // Same cabling mapping as for EMCal, not considered offline.</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     619 </span><span class="lineCov">         58 :   else if ( sm == 18 || sm == 19 )</span>
<span class="lineNum">     620 </span>            :   {
<span class="lineNum">     621 </span>            :     // DCal 1/3 SMs
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :     iphi -= 16; // Needed due to cabling mistake.</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     624 </span><span class="lineCov">         58 : }</span>
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span>            : ///
<span class="lineNum">     627 </span>            : /// Here shift the DCal online cols or rows depending on the
<span class="lineNum">     628 </span>            : /// super-module number to match the online mapping. 
<span class="lineNum">     629 </span>            : ///
<span class="lineNum">     630 </span>            : /// Reverse procedure to the one in the method above
<span class="lineNum">     631 </span>            : /// ShiftOnlineToOfflineCellIndexes().
<span class="lineNum">     632 </span>            : ///
<span class="lineNum">     633 </span>            : /// \param sm: super module number of the channel/cell
<span class="lineNum">     634 </span>            : /// \param iphi: row/phi cell index, modified for DCal
<span class="lineNum">     635 </span>            : /// \param ieta: column/eta index, modified for DCal
<a name="636"><span class="lineNum">     636 </span>            : ///</a>
<span class="lineNum">     637 </span>            : //________________________________________________________________________________________________
<span class="lineNum">     638 </span>            : void AliEMCALGeometry::ShiftOfflineToOnlineCellIndexes(Int_t sm, Int_t &amp; iphi, Int_t &amp; ieta) const 
<span class="lineNum">     639 </span>            : {
<span class="lineNum">     640 </span><span class="lineCov">        116 :   if ( sm == 13 || sm == 15 || sm == 17 )</span>
<span class="lineNum">     641 </span>            :   {
<span class="lineNum">     642 </span>            :     // DCal odd SMs
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :     ieta += 16; // Same cabling mapping as for EMCal, not considered offline.</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     645 </span><span class="lineCov">         58 :   else if ( sm == 18 || sm == 19 )</span>
<span class="lineNum">     646 </span>            :   {
<span class="lineNum">     647 </span>            :     // DCal 1/3 SMs
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :     iphi += 16; // Needed due to cabling mistake.</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     650 </span><span class="lineCov">         58 : }</span>
<a name="651"><span class="lineNum">     651 </span>            : </a>
<span class="lineNum">     652 </span>            : //________________________________________________________________________________________________
<span class="lineNum">     653 </span>            : Bool_t AliEMCALGeometry::GetAbsCellIdFromEtaPhi(Double_t eta, Double_t phi, Int_t &amp;absId) const
<span class="lineNum">     654 </span>            : {
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span>            :   // Nov 17,2006
<span class="lineNum">     657 </span>            :   // stay here - phi problem as usual 
<span class="lineNum">     658 </span>            :   static Int_t nSupMod=-1, i=0, ieta=-1, iphi=-1, etaShift=0, neta=-1, nphi=-1;
<span class="lineNum">     659 </span>            :   static Double_t absEta=0.0, d=0.0, dmin=0.0, phiLoc=0;
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :   absId = nSupMod = - 1;</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :   if(SuperModuleNumberFromEtaPhi(eta, phi, nSupMod)) {</span>
<span class="lineNum">     662 </span>            :     // phi index first
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :     phi    = TVector2::Phi_0_2pi(phi);</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :     phiLoc = phi - fPhiCentersOfSMSec[nSupMod/2];</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :     nphi   = fPhiCentersOfCells.GetSize();</span>
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :     if (     GetSMType(nSupMod) == kEMCAL_Half ) nphi  /= 2;</span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :     else if( GetSMType(nSupMod) == kEMCAL_3rd )  nphi  /= 3;</span>
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :     else if( GetSMType(nSupMod) == kDCAL_Ext )   nphi  /= 3;</span>
<span class="lineNum">     669 </span>            :     
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :     dmin   = TMath::Abs(fPhiCentersOfCells[0]-phiLoc);</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :     iphi   = 0;</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :     for(i=1; i&lt;nphi; i++) {</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :       d = TMath::Abs(fPhiCentersOfCells[i] - phiLoc);</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :       if(d &lt; dmin) {</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :         dmin = d;</span>
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :         iphi = i;</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     678 </span>            :       //printf(&quot; i %i : d %f : dmin %f : fPhiCentersOfCells[i] %f \n&quot;, i, d, dmin, fPhiCentersOfCells[i]);
<span class="lineNum">     679 </span>            :     }
<span class="lineNum">     680 </span>            :     // odd SM are turned with respect of even SM - reverse indexes
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :     AliDebug(2,Form(&quot; iphi %i : dmin %f (phi %f, phiLoc %f ) &quot;, iphi, dmin, phi, phiLoc));</span>
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span>            :     // eta index
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :     absEta   = TMath::Abs(eta);</span>
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :     neta     = fCentersOfCellsEtaDir.GetSize();</span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :     etaShift = iphi*neta;</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :     ieta     = 0;</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :     if( GetSMType(nSupMod) == kDCAL_Standard) ieta += 16; //jump 16 cells for DCSM</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :     dmin     = TMath::Abs(fEtaCentersOfCells[etaShift + ieta]-absEta);</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :     for(i= ieta+1 ; i&lt;neta; i++) {</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :       d = TMath::Abs(fEtaCentersOfCells[i+etaShift] - absEta);</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :       if(d &lt; dmin) {</span>
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :         dmin = d;</span>
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :         ieta = i;</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     696 </span>            :     }
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :     if( GetSMType(nSupMod) == kDCAL_Standard) ieta -= 16; //jump 16 cells for DCSM</span>
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :     AliDebug(2,Form(&quot; ieta %i : dmin %f (eta=%f) : nSupMod %i &quot;, ieta, dmin, eta, nSupMod));</span>
<span class="lineNum">     700 </span>            :      
<span class="lineNum">     701 </span>            :    //patch for mapping following alice convention  
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :     if(nSupMod%2 == 0) {// 47 + 16 -ieta for DCSM, 47 - ieta for others, revert the ordering on A side in order to keep convention.</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :       ieta = (neta -1)-ieta;</span>
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :       if( GetSMType(nSupMod) == kDCAL_Standard) ieta -= 16; //recover cells for DCSM</span>
<span class="lineNum">     705 </span>            :     }
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :     absId = GetAbsCellIdFromCellIndexes(nSupMod, iphi, ieta);</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :     return kTRUE;</span>
<span class="lineNum">     709 </span>            :   }
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :   return kFALSE;</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 : }</span>
<a name="712"><span class="lineNum">     712 </span>            : </a>
<span class="lineNum">     713 </span>            : //________________________________________________________________________________________________
<span class="lineNum">     714 </span>            : Bool_t  AliEMCALGeometry::CheckAbsCellId(Int_t absId) const
<span class="lineNum">     715 </span>            : { 
<span class="lineNum">     716 </span>            :   // May 31, 2006; only trd1 now
<span class="lineNum">     717 </span><span class="lineCov">     420711 :   if(absId&lt;0 || absId &gt;= fNCells) return kFALSE;</span>
<span class="lineNum">     718 </span><span class="lineCov">     140233 :   else                            return kTRUE;</span>
<span class="lineNum">     719 </span><span class="lineCov">     140237 : }</span>
<a name="720"><span class="lineNum">     720 </span>            : </a>
<span class="lineNum">     721 </span>            : //________________________________________________________________________________________________
<span class="lineNum">     722 </span>            : Bool_t AliEMCALGeometry::GetCellIndex(Int_t absId,Int_t &amp;nSupMod,Int_t &amp;nModule,Int_t &amp;nIphi,Int_t &amp;nIeta) const
<span class="lineNum">     723 </span>            : { 
<span class="lineNum">     724 </span>            :   // 21-sep-04; 19-oct-05;
<span class="lineNum">     725 </span>            :   // May 31, 2006; ALICE numbering scheme:
<span class="lineNum">     726 </span>            :   // 
<span class="lineNum">     727 </span>            :   // In:
<span class="lineNum">     728 </span>            :   // absId   - cell is as in Geant,     0&lt;= absId   &lt; fNCells;
<span class="lineNum">     729 </span>            :   // Out:
<span class="lineNum">     730 </span>            :   // nSupMod - super module(SM) number, 0&lt;= nSupMod &lt; fNumberOfSuperModules;
<span class="lineNum">     731 </span>            :   // nModule  - module number in SM,     0&lt;= nModule  &lt; fNCellsInSupMod/fNCellsInSupMod or(/2) for tow last SM (10th and 11th);
<span class="lineNum">     732 </span>            :   // nIphi   - cell number in phi driection inside module; 0&lt;= nIphi &lt; fNPHIdiv; 
<span class="lineNum">     733 </span>            :   // nIeta   - cell number in eta driection inside module; 0&lt;= nIeta &lt; fNETAdiv; 
<span class="lineNum">     734 </span>            :   // 
<span class="lineNum">     735 </span><span class="lineCov">     149364 :   if(!CheckAbsCellId(absId)) return kFALSE;</span>
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span><span class="lineCov">      74682 :   static Int_t tmp = absId;</span>
<span class="lineNum">     738 </span>            :   Int_t test = absId;
<span class="lineNum">     739 </span>            :  
<span class="lineNum">     740 </span><span class="lineCov">     811798 :   for(nSupMod = -1; test &gt;= 0; ) {</span>
<span class="lineNum">     741 </span><span class="lineCov">     662446 :     nSupMod++;</span>
<span class="lineNum">     742 </span><span class="lineCov">     662446 :     tmp = test;</span>
<span class="lineNum">     743 </span><span class="lineCov">    1189360 :     if(      GetSMType(nSupMod) == kEMCAL_Standard) test -= fNCellsInSupMod;</span>
<span class="lineNum">     744 </span><span class="lineCov">     135532 :     else if( GetSMType(nSupMod) == kEMCAL_Half)     test -= fNCellsInSupMod/2;</span>
<span class="lineNum">     745 </span><span class="lineCov">     183389 :     else if( GetSMType(nSupMod) == kEMCAL_3rd)      test -= fNCellsInSupMod/3;</span>
<span class="lineNum">     746 </span><span class="lineCov">     170742 :     else if( GetSMType(nSupMod) == kDCAL_Standard)  test -= 2*fNCellsInSupMod/3;</span>
<span class="lineNum">     747 </span><span class="lineCov">       9216 :     else if( GetSMType(nSupMod) == kDCAL_Ext)       test -= fNCellsInSupMod/3;</span>
<span class="lineNum">     748 </span>            :     else {
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :       AliError(Form(&quot;Uknown SuperModule Type !!&quot;));</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :       return kFALSE;</span>
<span class="lineNum">     751 </span>            :     }
<span class="lineNum">     752 </span>            :   }
<span class="lineNum">     753 </span><span class="lineCov">      74676 :   nModule = tmp / fNCellsInModule;</span>
<span class="lineNum">     754 </span><span class="lineCov">      74676 :   tmp     = tmp % fNCellsInModule;</span>
<span class="lineNum">     755 </span><span class="lineCov">      74676 :   nIphi   = tmp / fNPHIdiv;</span>
<span class="lineNum">     756 </span><span class="lineCov">      74676 :   nIeta   = tmp % fNPHIdiv;</span>
<span class="lineNum">     757 </span>            : 
<span class="lineNum">     758 </span><span class="lineCov">      74676 :   return kTRUE;</span>
<span class="lineNum">     759 </span><span class="lineCov">      74680 : }</span>
<a name="760"><span class="lineNum">     760 </span>            : </a>
<span class="lineNum">     761 </span>            : //________________________________________________________________________________________________
<span class="lineNum">     762 </span>            : Int_t  AliEMCALGeometry::GetSuperModuleNumber(Int_t absId)  const
<span class="lineNum">     763 </span>            : {
<span class="lineNum">     764 </span>            :   // Return the number of the  supermodule given the absolute
<span class="lineNum">     765 </span>            :   // ALICE numbering id
<span class="lineNum">     766 </span>            : 
<span class="lineNum">     767 </span>            :   static Int_t nSupMod=-1, nModule=-1, nIphi=-1, nIeta=-1;
<span class="lineNum">     768 </span><span class="lineCov">        382 :   GetCellIndex(absId, nSupMod, nModule, nIphi, nIeta);</span>
<span class="lineNum">     769 </span><span class="lineCov">        191 :   return nSupMod;</span>
<span class="lineNum">     770 </span>            : } 
<a name="771"><span class="lineNum">     771 </span>            : </a>
<span class="lineNum">     772 </span>            : //________________________________________________________________________________________________
<span class="lineNum">     773 </span>            : void AliEMCALGeometry::GetModulePhiEtaIndexInSModule(Int_t nSupMod, Int_t nModule,  int &amp;iphim, int &amp;ietam) const
<span class="lineNum">     774 </span>            : { 
<span class="lineNum">     775 </span>            :   // added nSupMod; - 19-oct-05 !
<span class="lineNum">     776 </span>            :   // Alice numbering scheme        - Jun 01,2006 
<span class="lineNum">     777 </span>            :   // ietam, iphi - indexes of module in two dimensional grid of SM
<span class="lineNum">     778 </span>            :   // ietam - have to change from 0 to fNZ-1
<span class="lineNum">     779 </span>            :   // iphim - have to change from 0 to nphi-1 (fNPhi-1 or fNPhi/2-1)
<span class="lineNum">     780 </span>            :   static Int_t nphi=-1;
<span class="lineNum">     781 </span><span class="lineCov">     279524 :   if(      GetSMType(nSupMod) == kEMCAL_Half )  nphi = fNPhi/2; // halfSM</span>
<span class="lineNum">     782 </span><span class="lineCov">     143653 :   else if( GetSMType(nSupMod) == kEMCAL_3rd  )  nphi = fNPhi/3; // 1/3 SM</span>
<span class="lineNum">     783 </span><span class="lineCov">     138943 :   else if( GetSMType(nSupMod) == kDCAL_Ext   )  nphi = fNPhi/3; // 1/3 SM</span>
<span class="lineNum">     784 </span><span class="lineCov">     132799 :   else                                          nphi = fNPhi;   // full SM</span>
<span class="lineNum">     785 </span>            :   
<span class="lineNum">     786 </span><span class="lineCov">     139762 :   ietam = nModule/nphi;</span>
<span class="lineNum">     787 </span><span class="lineCov">     139762 :   iphim = nModule%nphi;</span>
<span class="lineNum">     788 </span><span class="lineCov">     139762 : }</span>
<a name="789"><span class="lineNum">     789 </span>            : </a>
<span class="lineNum">     790 </span>            : //________________________________________________________________________________________________
<span class="lineNum">     791 </span>            : void AliEMCALGeometry::GetCellPhiEtaIndexInSModule(Int_t nSupMod, Int_t nModule, Int_t nIphi, Int_t nIeta, 
<span class="lineNum">     792 </span>            : int &amp;iphi, int &amp;ieta) const
<span class="lineNum">     793 </span>            : { 
<span class="lineNum">     794 </span>            :   // 
<span class="lineNum">     795 </span>            :   // Added nSupMod; Nov 25, 05
<span class="lineNum">     796 </span>            :   // Alice numbering scheme  - Jun 01,2006 
<span class="lineNum">     797 </span>            :   // IN:
<span class="lineNum">     798 </span>            :   // nSupMod - super module(SM) number, 0&lt;= nSupMod &lt; fNumberOfSuperModules;
<span class="lineNum">     799 </span>            :   // nModule  - module number in SM,     0&lt;= nModule  &lt; fNCellsInSupMod/fNCellsInSupMod or(/2) for tow last SM (10th and 11th);
<span class="lineNum">     800 </span>            :   // nIphi   - cell number in phi driection inside module; 0&lt;= nIphi &lt; fNPHIdiv; 
<span class="lineNum">     801 </span>            :   // nIeta   - cell number in eta driection inside module; 0&lt;= nIeta &lt; fNETAdiv; 
<span class="lineNum">     802 </span>            :   // 
<span class="lineNum">     803 </span>            :   // OUT:
<span class="lineNum">     804 </span>            :   // ieta, iphi - indexes of cell(tower) in two dimensional grid of SM
<span class="lineNum">     805 </span>            :   // ieta - have to change from 0 to (fNZ*fNETAdiv-1)
<span class="lineNum">     806 </span>            :   // iphi - have to change from 0 to (fNPhi*fNPHIdiv-1 or fNPhi*fNPHIdiv/2-1)
<span class="lineNum">     807 </span>            :   //
<span class="lineNum">     808 </span>            :   static Int_t iphim=-1, ietam=-1;
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span><span class="lineCov">     279136 :   GetModulePhiEtaIndexInSModule(nSupMod,nModule, iphim, ietam); </span>
<span class="lineNum">     811 </span>            :   //  ieta  = ietam*fNETAdiv + (1-nIeta); // x(module) = -z(SM) 
<span class="lineNum">     812 </span><span class="lineCov">     139568 :   ieta  = ietam*fNETAdiv + (fNETAdiv - 1 - nIeta); // x(module) = -z(SM) </span>
<span class="lineNum">     813 </span><span class="lineCov">     139568 :   iphi  = iphim*fNPHIdiv + nIphi;     // y(module) =  y(SM) </span>
<span class="lineNum">     814 </span>            : 
<span class="lineNum">     815 </span><span class="lineCov">     279136 :   if(iphi&lt;0 || ieta&lt;0)</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :   AliDebug(1,Form(&quot; nSupMod %i nModule %i nIphi %i nIeta %i =&gt; ieta %i iphi %i\n&quot;, </span>
<span class="lineNum">     817 </span>            :   nSupMod, nModule, nIphi, nIeta, ieta, iphi));
<span class="lineNum">     818 </span><span class="lineCov">     139568 : }</span>
<span class="lineNum">     819 </span>            : 
<a name="820"><span class="lineNum">     820 </span>            : // Methods for AliEMCALRecPoint - Feb 19, 2006</a>
<span class="lineNum">     821 </span>            : //________________________________________________________________________________________________
<span class="lineNum">     822 </span>            : Bool_t AliEMCALGeometry::RelPosCellInSModule(Int_t absId, Double_t &amp;xr, Double_t &amp;yr, Double_t &amp;zr) const
<span class="lineNum">     823 </span>            : {
<span class="lineNum">     824 </span>            :   // Look to see what the relative
<span class="lineNum">     825 </span>            :   // position inside a given cell is
<span class="lineNum">     826 </span>            :   // for a recpoint.
<span class="lineNum">     827 </span>            :   // Alice numbering scheme - Jun 08, 2006
<span class="lineNum">     828 </span>            :   // In:
<span class="lineNum">     829 </span>            :   // absId   - cell is as in Geant,     0&lt;= absId   &lt; fNCells;
<span class="lineNum">     830 </span>            :   // OUT:
<span class="lineNum">     831 </span>            :   // xr,yr,zr - x,y,z coordinates of cell with absId inside SM 
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span>            :   // Shift index taking into account the difference between standard SM 
<span class="lineNum">     834 </span>            :   // and SM of half (or one third) size in phi direction
<span class="lineNum">     835 </span>            :  
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :   const Int_t kNphiIndex = fCentersOfCellsPhiDir.GetSize(); </span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :   Double_t  zshift = 0.5*GetDCALInnerEdge();</span>
<span class="lineNum">     838 </span>            :       
<span class="lineNum">     839 </span>            :   static Int_t nSupMod=-1, nModule=-1, nIphi=-1, nIeta=-1, iphi=-1, ieta=-1;
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :   if(!CheckAbsCellId(absId)) return kFALSE;</span>
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :   GetCellIndex(absId, nSupMod, nModule, nIphi, nIeta);</span>
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :   GetCellPhiEtaIndexInSModule(nSupMod,nModule,nIphi,nIeta, iphi, ieta); </span>
<span class="lineNum">     844 </span>            :         
<span class="lineNum">     845 </span>            :   //Get eta position. Careful with ALICE conventions (increase index decrease eta)      
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :   Int_t ieta2 = ieta;</span>
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :   if(nSupMod%2 == 0) {</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :     ieta2 = (fCentersOfCellsEtaDir.GetSize()-1)-ieta;// 47-ieta, revert the ordering on A side in order to keep convention.</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :   if( GetSMType(nSupMod) == kDCAL_Standard &amp;&amp; nSupMod%2 ) ieta2 += 16; // DCAL revert the ordering on C side ...</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :   zr = fCentersOfCellsEtaDir.At(ieta2); </span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :   if( GetSMType(nSupMod) == kDCAL_Standard ) zr -= zshift; // DCAL shift (SMALLER SM)</span>
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :   xr = fCentersOfCellsXDir.At(ieta2);</span>
<span class="lineNum">     854 </span>            : 
<span class="lineNum">     855 </span>            :   //Get phi position. Careful with ALICE conventions (increase index increase phi)
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :   Int_t iphi2 = iphi;</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :   if( GetSMType(nSupMod) == kDCAL_Ext ) {</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :   if(nSupMod%2 != 0)   iphi2 = (kNphiIndex/3 -1)-iphi;  // 7-iphi [1/3SM], revert the ordering on C side in order to keep convention.</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :     yr = fCentersOfCellsPhiDir.At(iphi2 + kNphiIndex/3);</span>
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :   } else if( GetSMType(nSupMod) == kEMCAL_Half ){</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :     if(nSupMod%2 != 0)   iphi2 = (kNphiIndex/2 -1)-iphi;  //11-iphi [1/2SM], revert the ordering on C side in order to keep convention.</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :     yr = fCentersOfCellsPhiDir.At(iphi2 + kNphiIndex/4);</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :   } else if( GetSMType(nSupMod) == kEMCAL_3rd ){</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :     if(nSupMod%2 != 0)   iphi2 = (kNphiIndex/3 -1)-iphi;  // 7-iphi [1/3SM], revert the ordering on C side in order to keep convention.</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :     yr = fCentersOfCellsPhiDir.At(iphi2 + kNphiIndex/3);</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :     if(nSupMod%2 != 0)   iphi2 = (kNphiIndex   -1)-iphi;// 23-iphi, revert the ordering on C side in order to keep conventi</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :     yr = fCentersOfCellsPhiDir.At(iphi2);</span>
<span class="lineNum">     869 </span>            :   } 
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :   AliDebug(1,Form(&quot;absId %i nSupMod %i iphi %i ieta %i xr %f yr %f zr %f &quot;,absId,nSupMod,iphi,ieta,xr,yr,zr));</span>
<span class="lineNum">     871 </span>            : 
<span class="lineNum">     872 </span>            :   return kTRUE;
<span class="lineNum">     873 </span><span class="lineNoCov">          0 : }</span>
<a name="874"><span class="lineNum">     874 </span>            : </a>
<span class="lineNum">     875 </span>            : //________________________________________________________________________________________________
<span class="lineNum">     876 </span>            : Bool_t AliEMCALGeometry::RelPosCellInSModule(Int_t absId, Double_t loc[3]) const
<span class="lineNum">     877 </span>            : {
<span class="lineNum">     878 </span>            :   // Look to see what the relative
<span class="lineNum">     879 </span>            :   // position inside a given cell is
<span class="lineNum">     880 </span>            :   // for a recpoint.    // Alice numbering scheme - Jun 03, 2006
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :   loc[0] = loc[1] = loc[2]=0.0;</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :   if(RelPosCellInSModule(absId, loc[0],loc[1],loc[2])) {</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :     return kTRUE;</span>
<span class="lineNum">     884 </span>            :   }
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :   return kFALSE;</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 : }</span>
<a name="887"><span class="lineNum">     887 </span>            : </a>
<span class="lineNum">     888 </span>            : //________________________________________________________________________________________________
<span class="lineNum">     889 </span>            : Bool_t AliEMCALGeometry::RelPosCellInSModule(Int_t absId, TVector3 &amp;vloc) const
<span class="lineNum">     890 </span>            : {
<span class="lineNum">     891 </span>            :   // Look to see what the relative
<span class="lineNum">     892 </span>            :   // position inside a given cell is
<span class="lineNum">     893 </span>            :   // for a recpoint.  
<span class="lineNum">     894 </span>            :   // Alice numbering scheme - Jun 03, 2006
<span class="lineNum">     895 </span>            :   static Double_t loc[3];
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :   if(RelPosCellInSModule(absId,loc)) {</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :     vloc.SetXYZ(loc[0], loc[1], loc[2]);</span>
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :     return kTRUE;</span>
<span class="lineNum">     899 </span>            :   } else {
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :     vloc.SetXYZ(0,0,0);</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">     902 </span>            :   }
<span class="lineNum">     903 </span><span class="lineNoCov">          0 : }</span>
<a name="904"><span class="lineNum">     904 </span>            : </a>
<span class="lineNum">     905 </span>            : //________________________________________________________________________________________________
<span class="lineNum">     906 </span>            : Bool_t AliEMCALGeometry::RelPosCellInSModule(Int_t absId, Double_t distEff, Double_t &amp;xr, Double_t &amp;yr, Double_t &amp;zr) const
<span class="lineNum">     907 </span>            : {
<span class="lineNum">     908 </span>            :   // Jul 30, 2007 - taking into account position of shower max
<span class="lineNum">     909 </span>            :   // Look to see what the relative
<span class="lineNum">     910 </span>            :   // position inside a given cell is
<span class="lineNum">     911 </span>            :   // for a recpoint.
<span class="lineNum">     912 </span>            :   // In:
<span class="lineNum">     913 </span>            :   // absId   - cell is as in Geant,     0&lt;= absId   &lt; fNCells;
<span class="lineNum">     914 </span>            :   // e       - cluster energy
<span class="lineNum">     915 </span>            :   // OUT:
<span class="lineNum">     916 </span>            :   // xr,yr,zr - x,y,z coordinates of cell with absId inside SM 
<span class="lineNum">     917 </span>            :   
<span class="lineNum">     918 </span>            :   // Shift index taking into account the difference between standard SM 
<span class="lineNum">     919 </span>            :   // and SM of half (or one third) size in phi direction
<span class="lineNum">     920 </span>            :   
<span class="lineNum">     921 </span><span class="lineCov">        388 :   const Int_t kNphiIndex = fCentersOfCellsPhiDir.GetSize();</span>
<span class="lineNum">     922 </span><span class="lineCov">        194 :   Double_t  zshift = 0.5*GetDCALInnerEdge();</span>
<span class="lineNum">     923 </span>            :   Int_t kDCalshift = 8;//wangml DCal cut first 8 modules(16 cells)
<span class="lineNum">     924 </span>            :    
<span class="lineNum">     925 </span>            :   static Int_t nSupMod=0, nModule=-1, nIphi=-1, nIeta=-1, iphi=-1, ieta=-1;
<span class="lineNum">     926 </span>            :   static Int_t iphim=-1, ietam=-1;
<span class="lineNum">     927 </span>            :   static AliEMCALShishKebabTrd1Module *mod = 0;
<span class="lineNum">     928 </span><span class="lineCov">        200 :   static TVector2 v;</span>
<span class="lineNum">     929 </span><span class="lineCov">        194 :   if(!CheckAbsCellId(absId)) return kFALSE;</span>
<span class="lineNum">     930 </span>            :   
<span class="lineNum">     931 </span><span class="lineCov">        194 :   GetCellIndex(absId, nSupMod, nModule, nIphi, nIeta);</span>
<span class="lineNum">     932 </span><span class="lineCov">        194 :   GetModulePhiEtaIndexInSModule(nSupMod, nModule, iphim, ietam);</span>
<span class="lineNum">     933 </span><span class="lineCov">        194 :   GetCellPhiEtaIndexInSModule(nSupMod,nModule,nIphi,nIeta, iphi, ieta); </span>
<span class="lineNum">     934 </span>            :   
<span class="lineNum">     935 </span>            :   //Get eta position. Careful with ALICE conventions (increase index decrease eta)      
<span class="lineNum">     936 </span><span class="lineCov">        194 :   if(nSupMod%2 == 0) {             </span>
<span class="lineNum">     937 </span><span class="lineCov">         32 :     ietam = (fCentersOfCellsEtaDir.GetSize()/2-1)-ietam;// 24-ietam, revert the ordering on A side in order to keep convention.</span>
<span class="lineNum">     938 </span><span class="lineCov">         64 :     if(nIeta == 0) nIeta = 1;</span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :     else           nIeta = 0;</span>
<span class="lineNum">     940 </span>            :   }
<span class="lineNum">     941 </span><span class="lineCov">        194 :   if( GetSMType(nSupMod) == kDCAL_Standard &amp;&amp; nSupMod%2) ietam += kDCalshift; // DCAL revert the ordering on C side ....</span>
<span class="lineNum">     942 </span><span class="lineCov">        194 :   mod = GetShishKebabModule(ietam);</span>
<span class="lineNum">     943 </span><span class="lineCov">        194 :   mod -&gt;GetPositionAtCenterCellLine(nIeta, distEff, v); </span>
<span class="lineNum">     944 </span><span class="lineCov">        194 :   xr = v.Y() - fParSM[0];</span>
<span class="lineNum">     945 </span><span class="lineCov">        194 :   zr = v.X() - fParSM[2];</span>
<span class="lineNum">     946 </span><span class="lineCov">        194 :   if( GetSMType(nSupMod) == kDCAL_Standard ) zr -= zshift; // DCAL shift (SMALLER SM)</span>
<span class="lineNum">     947 </span>            :  
<span class="lineNum">     948 </span>            :   //Get phi position. Careful with ALICE conventions (increase index increase phi)
<span class="lineNum">     949 </span><span class="lineCov">        194 :   Int_t iphi2 = iphi;</span>
<span class="lineNum">     950 </span><span class="lineCov">        388 :   if( GetSMType(nSupMod) == kDCAL_Ext ) {</span>
<span class="lineNum">     951 </span><span class="lineCov">        194 :      if(nSupMod%2 != 0)  iphi2 = (kNphiIndex/3 -1)-iphi;  // 7-iphi [1/3SM], revert the ordering on C side in order to keep convention.</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :      yr = fCentersOfCellsPhiDir.At(iphi2 + kNphiIndex/3);</span>
<span class="lineNum">     953 </span><span class="lineCov">        388 :    } else if( GetSMType(nSupMod) == kEMCAL_Half ){</span>
<span class="lineNum">     954 </span><span class="lineCov">        194 :      if(nSupMod%2 != 0)  iphi2 = (kNphiIndex/2 -1)-iphi;  //11-iphi [1/2SM], revert the ordering on C side in order to keep convention.</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :      yr = fCentersOfCellsPhiDir.At(iphi2 + kNphiIndex/2);</span>
<span class="lineNum">     956 </span><span class="lineCov">        388 :    } else if( GetSMType(nSupMod) == kEMCAL_3rd ){</span>
<span class="lineNum">     957 </span><span class="lineCov">        202 :      if(nSupMod%2 != 0)  iphi2 = (kNphiIndex/3 -1)-iphi;  // 7-iphi [1/3SM], revert the ordering on C side in order to keep convention.</span>
<span class="lineNum">     958 </span><span class="lineCov">          4 :      yr = fCentersOfCellsPhiDir.At(iphi2 + kNphiIndex/3);</span>
<span class="lineNum">     959 </span><span class="lineCov">          4 :    } else {</span>
<span class="lineNum">     960 </span><span class="lineCov">        348 :      if(nSupMod%2 != 0)  iphi2 = (kNphiIndex   -1)-iphi;// 23-iphi, revert the ordering on C side in order to keep convention.</span>
<span class="lineNum">     961 </span><span class="lineCov">        190 :      yr = fCentersOfCellsPhiDir.At(iphi2);</span>
<span class="lineNum">     962 </span>            :    }
<span class="lineNum">     963 </span>            :   
<span class="lineNum">     964 </span><span class="lineCov">        582 :   AliDebug(1,Form(&quot;absId %i nSupMod %i iphi %i ieta %i xr %f yr %f zr %f &quot;,absId,nSupMod,iphi,ieta,xr,yr,zr));</span>
<span class="lineNum">     965 </span>            :   
<span class="lineNum">     966 </span>            :   return kTRUE;
<span class="lineNum">     967 </span><span class="lineCov">        194 : }</span>
<a name="968"><span class="lineNum">     968 </span>            : </a>
<span class="lineNum">     969 </span>            : //________________________________________________________________________________________________
<span class="lineNum">     970 </span>            : void AliEMCALGeometry::CreateListOfTrd1Modules()
<span class="lineNum">     971 </span>            : {
<span class="lineNum">     972 </span>            :   // Generate the list of Trd1 modules
<span class="lineNum">     973 </span>            :   // which will make up the EMCAL
<span class="lineNum">     974 </span>            :   // geometry
<span class="lineNum">     975 </span>            :   // key: look to the AliEMCALShishKebabTrd1Module::
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span><span class="lineCov">         20 :   AliDebug(2,Form(&quot; AliEMCALGeometry::CreateListOfTrd1Modules() started &quot;));</span>
<span class="lineNum">     978 </span>            : 
<span class="lineNum">     979 </span>            :   AliEMCALShishKebabTrd1Module *mod=0, *mTmp=0; // current module
<span class="lineNum">     980 </span><span class="lineCov">          5 :   if(fShishKebabTrd1Modules == 0) {</span>
<span class="lineNum">     981 </span><span class="lineCov">         10 :     fShishKebabTrd1Modules = new TList;</span>
<span class="lineNum">     982 </span><span class="lineCov">          5 :     fShishKebabTrd1Modules-&gt;SetName(&quot;ListOfTRD1&quot;);</span>
<span class="lineNum">     983 </span><span class="lineCov">        250 :     for(int iz=0; iz&lt; fEMCGeometry-&gt;GetNZ(); iz++) {</span>
<span class="lineNum">     984 </span><span class="lineCov">        240 :       if(iz==0) {</span>
<span class="lineNum">     985 </span>            :         //        mod  = new AliEMCALShishKebabTrd1Module(TMath::Pi()/2.,this);
<span class="lineNum">     986 </span><span class="lineCov">        125 :         mod  = new AliEMCALShishKebabTrd1Module(TMath::Pi()/2.,fEMCGeometry);</span>
<span class="lineNum">     987 </span><span class="lineCov">          5 :       } else {</span>
<span class="lineNum">     988 </span><span class="lineCov">        115 :         mTmp  = new AliEMCALShishKebabTrd1Module(*mod);</span>
<span class="lineNum">     989 </span>            :         mod   = mTmp;
<span class="lineNum">     990 </span>            :       }
<span class="lineNum">     991 </span><span class="lineCov">        120 :       fShishKebabTrd1Modules-&gt;Add(mod);</span>
<span class="lineNum">     992 </span>            :     }
<span class="lineNum">     993 </span><span class="lineCov">          5 :   } else {</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :     AliDebug(2,Form(&quot; Already exits : &quot;));</span>
<span class="lineNum">     995 </span>            :   }
<span class="lineNum">     996 </span><span class="lineCov">          5 :   mod = (AliEMCALShishKebabTrd1Module*)fShishKebabTrd1Modules-&gt;At(fShishKebabTrd1Modules-&gt;GetSize()-1);</span>
<span class="lineNum">     997 </span><span class="lineCov">          5 :   fEtaMaxOfTRD1 = mod-&gt;GetMaxEtaOfModule(0);</span>
<span class="lineNum">     998 </span>            : 
<span class="lineNum">     999 </span><span class="lineCov">         15 :   AliDebug(2,Form(&quot; fShishKebabTrd1Modules has %i modules : max eta %5.4f \n&quot;,</span>
<span class="lineNum">    1000 </span>            :                   fShishKebabTrd1Modules-&gt;GetSize(),fEtaMaxOfTRD1));
<span class="lineNum">    1001 </span>            :   // Feb 20,2006;
<span class="lineNum">    1002 </span>            :   // Jun 01, 2006 - ALICE numbering scheme
<span class="lineNum">    1003 </span>            :   // define grid for cells in eta(z) and x directions in local coordinates system of SM
<span class="lineNum">    1004 </span>            :   // Works just for 2x2 case only -- ?? start here
<span class="lineNum">    1005 </span>            :   //
<span class="lineNum">    1006 </span>            :   //
<span class="lineNum">    1007 </span>            :   // Define grid for cells in phi(y) direction in local coordinates system of SM
<span class="lineNum">    1008 </span>            :   // as for 2X2 as for 3X3 - Nov 8,2006
<span class="lineNum">    1009 </span>            :   //
<span class="lineNum">    1010 </span><span class="lineCov">         15 :   AliDebug(2,Form(&quot; Cells grid in phi directions : size %i\n&quot;, fCentersOfCellsPhiDir.GetSize()));</span>
<span class="lineNum">    1011 </span>            :   Int_t ind=0; // this is phi index
<span class="lineNum">    1012 </span><span class="lineCov">          5 :   Int_t ieta=0, nModule=0, iphiTemp;</span>
<span class="lineNum">    1013 </span><span class="lineCov">          5 :   Double_t xr=0., zr=0., theta=0., phi=0., eta=0., r=0., x=0.,y=0.;</span>
<span class="lineNum">    1014 </span><span class="lineCov">          5 :   TVector3 vglob;</span>
<span class="lineNum">    1015 </span>            :   Double_t ytCenterModule=0.0, ytCenterCell=0.0;
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span><span class="lineCov">          5 :   fCentersOfCellsPhiDir.Set(fNPhi*fNPHIdiv);</span>
<span class="lineNum">    1018 </span><span class="lineCov">          5 :   fPhiCentersOfCells.Set(fNPhi*fNPHIdiv);</span>
<span class="lineNum">    1019 </span>            : 
<span class="lineNum">    1020 </span><span class="lineCov">          5 :   Double_t r0 = fIPDistance + fLongModuleSize/2.;</span>
<span class="lineNum">    1021 </span><span class="lineCov">        130 :   for(Int_t it=0; it&lt;fNPhi; it++) { // cycle on modules</span>
<span class="lineNum">    1022 </span><span class="lineCov">         60 :     ytCenterModule = -fParSM[1] + fPhiModuleSize*(2*it+1)/2;  // center of module</span>
<span class="lineNum">    1023 </span><span class="lineCov">        360 :     for(Int_t ic=0; ic&lt;fNPHIdiv; ic++) { // cycle on cells in module</span>
<span class="lineNum">    1024 </span><span class="lineCov">        120 :       if(fNPHIdiv==2) {</span>
<span class="lineNum">    1025 </span><span class="lineCov">        120 :         ytCenterCell = ytCenterModule + fPhiTileSize *(2*ic-1)/2.;</span>
<span class="lineNum">    1026 </span><span class="lineCov">        120 :       } else if(fNPHIdiv==3){</span>
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :         ytCenterCell = ytCenterModule + fPhiTileSize *(ic-1);</span>
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :       } else if(fNPHIdiv==1){</span>
<span class="lineNum">    1029 </span>            :         ytCenterCell = ytCenterModule;
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1031 </span><span class="lineCov">        120 :       fCentersOfCellsPhiDir.AddAt(ytCenterCell,ind);</span>
<span class="lineNum">    1032 </span>            :       // Define grid on phi direction
<span class="lineNum">    1033 </span>            :       // Grid is not the same for different eta bin;
<span class="lineNum">    1034 </span>            :       // Effect is small but is still here
<span class="lineNum">    1035 </span><span class="lineCov">        120 :       phi = TMath::ATan2(ytCenterCell, r0);</span>
<span class="lineNum">    1036 </span><span class="lineCov">        120 :       fPhiCentersOfCells.AddAt(phi, ind);</span>
<span class="lineNum">    1037 </span>            : 
<span class="lineNum">    1038 </span><span class="lineCov">        600 :       AliDebug(2,Form(&quot; ind %2.2i : y %8.3f &quot;, ind, fCentersOfCellsPhiDir.At(ind)));</span>
<span class="lineNum">    1039 </span><span class="lineCov">        120 :       ind++;</span>
<span class="lineNum">    1040 </span>            :     }
<span class="lineNum">    1041 </span>            :   }
<span class="lineNum">    1042 </span>            : 
<span class="lineNum">    1043 </span><span class="lineCov">          5 :   fCentersOfCellsEtaDir.Set(fNZ *fNETAdiv);</span>
<span class="lineNum">    1044 </span><span class="lineCov">          5 :   fCentersOfCellsXDir.Set(fNZ *fNETAdiv);</span>
<span class="lineNum">    1045 </span><span class="lineCov">          5 :   fEtaCentersOfCells.Set(fNZ *fNETAdiv * fNPhi*fNPHIdiv);</span>
<span class="lineNum">    1046 </span><span class="lineCov">         25 :   AliDebug(2,Form(&quot; Cells grid in eta directions : size %i\n&quot;, fCentersOfCellsEtaDir.GetSize()));</span>
<span class="lineNum">    1047 </span><span class="lineCov">        250 :   for(Int_t it=0; it&lt;fNZ; it++) {</span>
<span class="lineNum">    1048 </span><span class="lineCov">        120 :     AliEMCALShishKebabTrd1Module *trd1 = GetShishKebabModule(it);</span>
<span class="lineNum">    1049 </span><span class="lineCov">        120 :     nModule = fNPhi*it;</span>
<span class="lineNum">    1050 </span><span class="lineCov">        720 :     for(Int_t ic=0; ic&lt;fNETAdiv; ic++) {</span>
<span class="lineNum">    1051 </span><span class="lineCov">        240 :       if(fNPHIdiv==2) {</span>
<span class="lineNum">    1052 </span><span class="lineCov">        240 :         trd1-&gt;GetCenterOfCellInLocalCoordinateofSM(ic, xr, zr);      // case of 2X2</span>
<span class="lineNum">    1053 </span><span class="lineCov">        240 :         GetCellPhiEtaIndexInSModule(0, nModule, 0, ic, iphiTemp, ieta);</span>
<span class="lineNum">    1054 </span><span class="lineCov">        240 :       } if(fNPHIdiv==3) {</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :         trd1-&gt;GetCenterOfCellInLocalCoordinateofSM3X3(ic, xr, zr);  // case of 3X3</span>
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :         GetCellPhiEtaIndexInSModule(0, nModule, 0, ic, iphiTemp, ieta);</span>
<span class="lineNum">    1057 </span><span class="lineCov">        240 :       } if(fNPHIdiv==1) {</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :         trd1-&gt;GetCenterOfCellInLocalCoordinateofSM1X1(xr, zr);      // case of 1X1</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :         GetCellPhiEtaIndexInSModule(0, nModule, 0, ic, iphiTemp, ieta);</span>
<span class="lineNum">    1060 </span>            :       }
<span class="lineNum">    1061 </span><span class="lineCov">        240 :       fCentersOfCellsXDir.AddAt(float(xr) - fParSM[0],ieta);</span>
<span class="lineNum">    1062 </span><span class="lineCov">        240 :       fCentersOfCellsEtaDir.AddAt(float(zr) - fParSM[2],ieta);</span>
<span class="lineNum">    1063 </span>            :       // Define grid on eta direction for each bin in phi
<span class="lineNum">    1064 </span><span class="lineCov">      12000 :       for(int iphi=0; iphi&lt;fCentersOfCellsPhiDir.GetSize(); iphi++) {</span>
<span class="lineNum">    1065 </span><span class="lineCov">       5760 :         x = xr + trd1-&gt;GetRadius();</span>
<span class="lineNum">    1066 </span><span class="lineCov">      11520 :         y = fCentersOfCellsPhiDir[iphi];</span>
<span class="lineNum">    1067 </span><span class="lineCov">       5760 :         r = TMath::Sqrt(x*x + y*y + zr*zr);</span>
<span class="lineNum">    1068 </span><span class="lineCov">       5760 :         theta = TMath::ACos(zr/r);</span>
<span class="lineNum">    1069 </span><span class="lineCov">       5760 :         eta   = AliEMCALShishKebabTrd1Module::ThetaToEta(theta);</span>
<span class="lineNum">    1070 </span>            :         //        ind   = ieta*fCentersOfCellsPhiDir.GetSize() + iphi;
<span class="lineNum">    1071 </span><span class="lineCov">       5760 :         ind   = iphi*fCentersOfCellsEtaDir.GetSize() + ieta;</span>
<span class="lineNum">    1072 </span><span class="lineCov">       5760 :         fEtaCentersOfCells.AddAt(eta, ind);</span>
<span class="lineNum">    1073 </span>            :       }
<span class="lineNum">    1074 </span>            :       //printf(&quot; ieta %i : xr + trd1-&gt;GetRadius() %f : zr %f : eta %f \n&quot;, ieta, xr + trd1-&gt;GetRadius(), zr, eta);
<span class="lineNum">    1075 </span>            :     }
<span class="lineNum">    1076 </span>            :   }
<span class="lineNum">    1077 </span><span class="lineCov">        490 :   for(Int_t i=0; i&lt;fCentersOfCellsEtaDir.GetSize(); i++) {</span>
<span class="lineNum">    1078 </span><span class="lineCov">       1200 :     AliDebug(2,Form(&quot; ind %2.2i : z %8.3f : x %8.3f&quot;, i+1,</span>
<span class="lineNum">    1079 </span>            :                     fCentersOfCellsEtaDir.At(i),fCentersOfCellsXDir.At(i)));
<span class="lineNum">    1080 </span>            :   }
<span class="lineNum">    1081 </span>            : 
<span class="lineNum">    1082 </span><span class="lineCov">          5 : }</span>
<a name="1083"><span class="lineNum">    1083 </span>            : </a>
<span class="lineNum">    1084 </span>            : //________________________________________________________________________________________________
<span class="lineNum">    1085 </span>            : AliEMCALShishKebabTrd1Module* AliEMCALGeometry::GetShishKebabModule(Int_t neta) const
<span class="lineNum">    1086 </span>            : {
<span class="lineNum">    1087 </span>            :   //This method was too long to be
<span class="lineNum">    1088 </span>            :   //included in the header file - the
<span class="lineNum">    1089 </span>            :   //rule checker complained about it's
<span class="lineNum">    1090 </span>            :   //length, so we move it here.  It returns the
<span class="lineNum">    1091 </span>            :   //shishkebabmodule at a given eta index point.
<span class="lineNum">    1092 </span>            : 
<span class="lineNum">    1093 </span>            :   static AliEMCALShishKebabTrd1Module* trd1=0;
<span class="lineNum">    1094 </span><span class="lineCov">        942 :   if(fShishKebabTrd1Modules &amp;&amp; neta&gt;=0 &amp;&amp; neta&lt;fShishKebabTrd1Modules-&gt;GetSize()) {</span>
<span class="lineNum">    1095 </span><span class="lineCov">        314 :     trd1 = (AliEMCALShishKebabTrd1Module*)fShishKebabTrd1Modules-&gt;At(neta);</span>
<span class="lineNum">    1096 </span><span class="lineCov">        314 :   } else trd1 = 0;</span>
<span class="lineNum">    1097 </span><span class="lineCov">        314 :   return trd1;</span>
<span class="lineNum">    1098 </span>            : }
<a name="1099"><span class="lineNum">    1099 </span>            : </a>
<span class="lineNum">    1100 </span>            : //___________________________________________________________________
<span class="lineNum">    1101 </span>            : void AliEMCALGeometry::PrintGeometryGeoUtils()
<span class="lineNum">    1102 </span>            : {
<span class="lineNum">    1103 </span>            :   //Print information from geometry
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :   fEMCGeometry-&gt;PrintGeometry();</span>
<span class="lineNum">    1105 </span>            : 
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :   printf(&quot; fShishKebabTrd1Modules has %i modules : max eta %5.4f \n&quot;, </span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :          fShishKebabTrd1Modules-&gt;GetSize(),fEtaMaxOfTRD1);</span>
<span class="lineNum">    1108 </span>            :   
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :   printf(&quot;\n Cells grid in eta directions : size %i\n&quot;, fCentersOfCellsEtaDir.GetSize());</span>
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :   for(Int_t i=0; i&lt;fCentersOfCellsEtaDir.GetSize(); i++) {</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :     printf(&quot; ind %2.2i : z %8.3f : x %8.3f \n&quot;, i, </span>
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :            fCentersOfCellsEtaDir.At(i),fCentersOfCellsXDir.At(i));</span>
<span class="lineNum">    1113 </span>            :     int ind=0; // Nov 21,2006
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :     for(Int_t iphi=0; iphi&lt;fCentersOfCellsPhiDir.GetSize(); iphi++) {</span>
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :       ind = iphi*fCentersOfCellsEtaDir.GetSize() + i;</span>
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :       printf(&quot;%6.4f &quot;, fEtaCentersOfCells[ind]);</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :       if((iphi+1)%12 == 0) printf(&quot;\n&quot;);</span>
<span class="lineNum">    1118 </span>            :     }
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :     printf(&quot;\n&quot;);</span>
<span class="lineNum">    1120 </span>            :     
<span class="lineNum">    1121 </span>            :   }
<span class="lineNum">    1122 </span>            : 
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :   printf(&quot;\n Cells grid in phi directions : size %i\n&quot;, fCentersOfCellsPhiDir.GetSize());</span>
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :   for(Int_t i=0; i&lt;fCentersOfCellsPhiDir.GetSize(); i++) {</span>
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :     double phi=fPhiCentersOfCells.At(i);</span>
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :     printf(&quot; ind %2.2i : y %8.3f : phi %7.5f(%6.2f) \n&quot;, i, fCentersOfCellsPhiDir.At(i), </span>
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :            phi, phi*TMath::RadToDeg());</span>
<span class="lineNum">    1128 </span>            :   }
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 : }</span>
<a name="1130"><span class="lineNum">    1130 </span>            : </a>
<span class="lineNum">    1131 </span>            : //____________________________________________________________________________
<span class="lineNum">    1132 </span>            : Bool_t  AliEMCALGeometry::Impact(const TParticle * particle) const 
<span class="lineNum">    1133 </span>            : {
<span class="lineNum">    1134 </span>            :   // Tells if a particle enters EMCAL
<span class="lineNum">    1135 </span>            :   Bool_t in=kFALSE;
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :   Int_t absID=0;</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :   TVector3 vtx(particle-&gt;Vx(),particle-&gt;Vy(),particle-&gt;Vz());</span>
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :   TVector3 vimpact(0,0,0);</span>
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :   ImpactOnEmcal(vtx,particle-&gt;Theta(),particle-&gt;Phi(),absID,vimpact);</span>
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :   if(absID&gt;=0) </span>
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :     in=kTRUE;</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :   return in;</span>
<a name="1143"><span class="lineNum">    1143 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1144 </span>            : //____________________________________________________________________________
<span class="lineNum">    1145 </span>            : void AliEMCALGeometry::ImpactOnEmcal(TVector3 vtx, Double_t theta, Double_t phi, 
<span class="lineNum">    1146 </span>            :                                      Int_t &amp; absId, TVector3 &amp; vimpact) const
<span class="lineNum">    1147 </span>            : {
<span class="lineNum">    1148 </span>            :   // calculates the impact coordinates on EMCAL (centre of a tower/not on EMCAL surface) 
<span class="lineNum">    1149 </span>            :   // of a neutral particle  
<span class="lineNum">    1150 </span>            :   // emitted in the vertex vtx[3] with direction theta and phi in the ALICE global coordinate system
<span class="lineNum">    1151 </span>            : 
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :   TVector3 p(TMath::Sin(theta)*TMath::Cos(phi),TMath::Sin(theta)*TMath::Sin(phi),TMath::Cos(theta)) ;</span>
<span class="lineNum">    1153 </span>            : 
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :   vimpact.SetXYZ(0,0,0);</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :   absId=-1;</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :   if(phi==0 || theta==0) return;</span>
<span class="lineNum">    1157 </span>            : 
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :   TVector3 direction;</span>
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :   Double_t factor = (fIPDistance-vtx[1])/p[1];</span>
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :   direction = vtx + factor*p;</span>
<span class="lineNum">    1161 </span>            : 
<span class="lineNum">    1162 </span>            :   //from particle direction -&gt; tower hitted
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :   GetAbsCellIdFromEtaPhi(direction.Eta(),direction.Phi(),absId);</span>
<span class="lineNum">    1164 </span>            :   
<span class="lineNum">    1165 </span>            :   //tower absID hitted -&gt; tower/module plane (evaluated at the center of the tower)
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :   Int_t nSupMod=-1, nModule=-1, nIphi=-1, nIeta=-1;</span>
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :   Double_t loc[3],loc2[3],loc3[3];</span>
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :   Double_t glob[3]={},glob2[3]={},glob3[3]={};</span>
<span class="lineNum">    1169 </span>            :   
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :   if(!RelPosCellInSModule(absId,loc)) return;</span>
<span class="lineNum">    1171 </span>            :   
<span class="lineNum">    1172 </span>            :   //loc is cell center of tower
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :   GetCellIndex(absId, nSupMod, nModule, nIphi, nIeta);</span>
<span class="lineNum">    1174 </span>            : 
<span class="lineNum">    1175 </span>            :   //look at 2 neighbours-s cell using nIphi={0,1} and nIeta={0,1}
<span class="lineNum">    1176 </span>            :   Int_t nIphi2=-1,nIeta2=-1,absId2=-1,absId3=-1;
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :   if(nIeta==0) nIeta2=1;</span>
<span class="lineNum">    1178 </span>            :   else nIeta2=0;
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :   absId2=GetAbsCellId(nSupMod,nModule,nIphi,nIeta2);  </span>
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :   if(nIphi==0) nIphi2=1;</span>
<span class="lineNum">    1181 </span>            :   else nIphi2=0;
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :   absId3=GetAbsCellId(nSupMod,nModule,nIphi2,nIeta);</span>
<span class="lineNum">    1183 </span>            : 
<span class="lineNum">    1184 </span>            :   //2nd point on emcal cell plane
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :   if(!RelPosCellInSModule(absId2,loc2)) return;</span>
<span class="lineNum">    1186 </span>            :     
<span class="lineNum">    1187 </span>            :   //3rd point on emcal cell plane
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :   if(!RelPosCellInSModule(absId3,loc3)) return;</span>
<span class="lineNum">    1189 </span>            :     
<span class="lineNum">    1190 </span>            :   // Get Matrix
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :   const TGeoHMatrix* m = GetMatrixForSuperModule(nSupMod);</span>
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :   if(m) {</span>
<span class="lineNum">    1193 </span><span class="lineNoCov">          0 :     m-&gt;LocalToMaster(loc, glob);</span>
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :     m-&gt;LocalToMaster(loc2, glob2);</span>
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :     m-&gt;LocalToMaster(loc3, glob3);</span>
<span class="lineNum">    1196 </span>            :   } else {
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :     AliFatal(&quot;Geo matrixes are not loaded \n&quot;) ;</span>
<span class="lineNum">    1198 </span>            :   }
<span class="lineNum">    1199 </span>            : 
<span class="lineNum">    1200 </span>            :   //Equation of Plane from glob,glob2,glob3 (Ax+By+Cz+D=0)
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :   Double_t a = glob[1]*(glob2[2]-glob3[2]) + glob2[1]*(glob3[2]-glob[2]) + glob3[1]*(glob[2]-glob2[2]);</span>
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :   Double_t b = glob[2]*(glob2[0]-glob3[0]) + glob2[2]*(glob3[0]-glob[0]) + glob3[2]*(glob[0]-glob2[0]);</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :   Double_t c = glob[0]*(glob2[1]-glob3[1]) + glob2[0]*(glob3[1]-glob[1]) + glob3[0]*(glob[1]-glob2[1]);</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :   Double_t d = glob[0]*(glob2[1]*glob3[2]-glob3[1]*glob2[2]) + glob2[0]*(glob3[1]*glob[2]-glob[1]*glob3[2]) + glob3[0]*(glob[1]*glob2[2]-glob2[1]*glob[2]);</span>
<span class="lineNum">    1205 </span>            :   d=-d;
<span class="lineNum">    1206 </span>            :   
<span class="lineNum">    1207 </span>            :   //shift equation of plane from tower/module center to surface along vector (A,B,C) normal to tower/module plane
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :   Double_t dist = fLongModuleSize/2.;</span>
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :   Double_t norm = TMath::Sqrt(a*a+b*b+c*c);</span>
<span class="lineNum">    1210 </span>            :   Double_t glob4[3]={};
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :   TVector3 dir(a,b,c);</span>
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :   TVector3 point(glob[0],glob[1],glob[2]); </span>
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :   if(point.Dot(dir)&lt;0) dist*=-1;</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :   glob4[0]=glob[0]-dist*a/norm;</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :   glob4[1]=glob[1]-dist*b/norm;</span>
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :   glob4[2]=glob[2]-dist*c/norm;</span>
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :   d = glob4[0]*a +  glob4[1]*b +  glob4[2]*c ;</span>
<span class="lineNum">    1218 </span><span class="lineNoCov">          0 :   d = -d;</span>
<span class="lineNum">    1219 </span>            : 
<span class="lineNum">    1220 </span>            :   //Line determination (2 points for equation of line : vtx and direction)
<span class="lineNum">    1221 </span>            :   //impact between line (particle) and plane (module/tower plane)
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :   Double_t den = a*(vtx(0)-direction(0)) + b*(vtx(1)-direction(1)) + c*(vtx(2)-direction(2));</span>
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :   if(den==0){</span>
<span class="lineNum">    1224 </span><span class="lineNoCov">          0 :     printf(&quot;ImpactOnEmcal() No solution :\n&quot;);</span>
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1226 </span>            :   }
<span class="lineNum">    1227 </span>            :   
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :   Double_t length = a*vtx(0)+b*vtx(1)+c*vtx(2)+d;</span>
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :   length /=den;</span>
<span class="lineNum">    1230 </span>            :   
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :   vimpact.SetXYZ(vtx(0)+length*(direction(0)-vtx(0)),vtx(1)+length*(direction(1)-vtx(1)),vtx(2)+length*(direction(2)-vtx(2)));</span>
<span class="lineNum">    1232 </span>            :   
<span class="lineNum">    1233 </span>            :   //shift vimpact from tower/module surface to center along vector (A,B,C) normal to tower/module plane
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :   vimpact.SetXYZ(vimpact(0)+dist*a/norm,vimpact(1)+dist*b/norm,vimpact(2)+dist*c/norm);</span>
<span class="lineNum">    1235 </span>            :   
<span class="lineNum">    1236 </span>            :   return;
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 : }</span>
<a name="1238"><span class="lineNum">    1238 </span>            : </a>
<span class="lineNum">    1239 </span>            : //_____________________________________________________________________________
<span class="lineNum">    1240 </span>            : Bool_t AliEMCALGeometry::IsInEMCAL(Double_t x, Double_t y, Double_t z) const 
<span class="lineNum">    1241 </span>            : {
<span class="lineNum">    1242 </span>            :   // Checks whether point is inside the EMCal volume 
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :   if( IsInEMCALOrDCAL(x,y,z) == 1 ) return kTRUE;</span>
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 :   else return kFALSE;</span>
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 : }</span>
<a name="1246"><span class="lineNum">    1246 </span>            : </a>
<span class="lineNum">    1247 </span>            : //_____________________________________________________________________________
<span class="lineNum">    1248 </span>            : Bool_t AliEMCALGeometry::IsInDCAL(Double_t x, Double_t y, Double_t z) const 
<span class="lineNum">    1249 </span>            : {
<span class="lineNum">    1250 </span>            :   // Checks whether point is inside the DCal volume
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :   if( IsInEMCALOrDCAL(x,y,z) == 2 ) return kTRUE;</span>
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 :   else return kFALSE;</span>
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 : }</span>
<a name="1254"><span class="lineNum">    1254 </span>            : </a>
<span class="lineNum">    1255 </span>            : //_____________________________________________________________________________
<span class="lineNum">    1256 </span>            : Int_t AliEMCALGeometry::IsInEMCALOrDCAL(Double_t x, Double_t y, Double_t z) const 
<span class="lineNum">    1257 </span>            : {
<span class="lineNum">    1258 </span>            :   // Checks whether point is inside the EMCal volume (included DCal), used in AliEMCALv*.cxx
<span class="lineNum">    1259 </span>            :   //
<span class="lineNum">    1260 </span>            :   // Code uses cylindrical approximation made of inner radius (for speed)
<span class="lineNum">    1261 </span>            :   //
<span class="lineNum">    1262 </span>            :   // Points behind EMCAl/DCal, i.e. R &gt; outer radius, but eta, phi in acceptance 
<span class="lineNum">    1263 </span>            :   // are considered to inside
<span class="lineNum">    1264 </span>            : 
<span class="lineNum">    1265 </span><span class="lineCov">        290 :   Double_t r=sqrt(x*x+y*y);</span>
<span class="lineNum">    1266 </span>            : 
<span class="lineNum">    1267 </span><span class="lineCov">        221 :   if ( r &lt;= fEnvelop[0] ) return 0;</span>
<span class="lineNum">    1268 </span>            :   else {
<span class="lineNum">    1269 </span><span class="lineCov">         69 :     Double_t theta = TMath::ATan2(r,z);</span>
<span class="lineNum">    1270 </span>            :     Double_t eta;
<span class="lineNum">    1271 </span><span class="lineCov">         69 :     if(theta == 0)  eta = 9999;</span>
<span class="lineNum">    1272 </span><span class="lineCov">         69 :     else            eta = -TMath::Log(TMath::Tan(theta/2.));</span>
<span class="lineNum">    1273 </span><span class="lineCov">        138 :     if (eta &lt; fArm1EtaMin || eta &gt; fArm1EtaMax) return 0;</span>
<span class="lineNum">    1274 </span>            : 
<span class="lineNum">    1275 </span><span class="lineCov">         69 :     Double_t phi = TMath::ATan2(y,x) * 180./TMath::Pi();</span>
<span class="lineNum">    1276 </span><span class="lineCov">         78 :     if (phi &lt; 0) phi += 360;  // phi should go from 0 to 360 in this case</span>
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span><span class="lineCov">        203 :     if (      phi &gt;= fArm1PhiMin         &amp;&amp; phi &lt;= fEMCALPhiMax ) return 1;</span>
<span class="lineNum">    1279 </span><span class="lineCov">         16 :     else if ( phi &gt;= fDCALPhiMin         &amp;&amp; phi &lt;= fDCALStandardPhiMax &amp;&amp; TMath::Abs(eta) &gt; fDCALInnerExtandedEta ) return 2;</span>
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :     else if ( phi &gt; fDCALStandardPhiMax  &amp;&amp; phi &lt;= fDCALPhiMax  ) return 2;</span>
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :     else return 0;</span>
<span class="lineNum">    1282 </span>            :   } 
<span class="lineNum">    1283 </span><span class="lineCov">        145 : }</span>
<span class="lineNum">    1284 </span>            : 
<span class="lineNum">    1285 </span>            : ///
<span class="lineNum">    1286 </span>            : /// Provides shift-rotation matrix for EMCAL from externally set matrix or 
<span class="lineNum">    1287 </span>            : /// from TGeoManager
<span class="lineNum">    1288 </span>            : /// \return alignment matrix for a super module number
<span class="lineNum">    1289 </span>            : /// \param smod: super module number
<a name="1290"><span class="lineNum">    1290 </span>            : ///</a>
<span class="lineNum">    1291 </span>            : //____________________________________________________________________________
<span class="lineNum">    1292 </span>            : const TGeoHMatrix * AliEMCALGeometry::GetMatrixForSuperModule(Int_t smod) const 
<span class="lineNum">    1293 </span>            : {       
<span class="lineNum">    1294 </span><span class="lineCov">        291 :   if(smod &lt; 0 || smod &gt; fEMCGeometry-&gt;GetNumberOfSuperModules()) </span>
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 :     AliFatal(Form(&quot;Wrong supermodule index -&gt; %d&quot;,smod));</span>
<span class="lineNum">    1296 </span>            :                 
<span class="lineNum">    1297 </span>            :   // Use matrices set externally
<span class="lineNum">    1298 </span><span class="lineCov">        291 :   if(!gGeoManager || (gGeoManager &amp;&amp; fUseExternalMatrices))</span>
<span class="lineNum">    1299 </span>            :   {
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :     if(fkSModuleMatrix[smod])</span>
<span class="lineNum">    1301 </span>            :     {
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 :       return fkSModuleMatrix[smod] ;</span>
<span class="lineNum">    1303 </span>            :     }
<span class="lineNum">    1304 </span>            :     else
<span class="lineNum">    1305 </span>            :     {
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :       AliInfo(&quot;Stop:&quot;);</span>
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :       printf(&quot;\t Can not find EMCAL misalignment matrixes\n&quot;) ;</span>
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :       printf(&quot;\t Either import TGeoManager from geometry.root or \n&quot;);</span>
<span class="lineNum">    1309 </span><span class="lineNoCov">          0 :       printf(&quot;\t read stored matrixes from AliESD Header:  \n&quot;) ;   </span>
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :       printf(&quot;\t AliEMCALGeometry::SetMisalMatrixes(header-&gt;GetEMCALMisalMatrix()) \n&quot;) ;</span>
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 :       AliFatal(&quot;&quot;) ;</span>
<span class="lineNum">    1312 </span>            :     }  
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :   }//external matrices</span>
<span class="lineNum">    1314 </span>            :   
<span class="lineNum">    1315 </span>            :   // If gGeoManager exists, take matrix from it
<span class="lineNum">    1316 </span><span class="lineCov">        194 :   if(gGeoManager) return GetMatrixForSuperModuleFromGeoManager(smod);</span>
<span class="lineNum">    1317 </span>            :   
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :   return 0 ;</span>
<span class="lineNum">    1319 </span><span class="lineCov">         97 : }</span>
<span class="lineNum">    1320 </span>            : 
<span class="lineNum">    1321 </span>            : 
<span class="lineNum">    1322 </span>            : ///
<span class="lineNum">    1323 </span>            : /// Provides shift-rotation matrix for EMCAL from fkSModuleMatrix[smod]
<span class="lineNum">    1324 </span>            : /// Unsafe method, not to be used in reconstruction, just check there is 
<span class="lineNum">    1325 </span>            : /// something in the array of matrices without crashing, for EVE checks.
<span class="lineNum">    1326 </span>            : ///
<span class="lineNum">    1327 </span>            : /// \return alignment matrix for a super module number
<span class="lineNum">    1328 </span>            : /// \param smod: super module number
<a name="1329"><span class="lineNum">    1329 </span>            : ///</a>
<span class="lineNum">    1330 </span>            : //______________________________________________________________________________________
<span class="lineNum">    1331 </span>            : const TGeoHMatrix * AliEMCALGeometry::GetMatrixForSuperModuleFromArray(Int_t smod) const 
<span class="lineNum">    1332 </span>            : {       
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 :   if(smod &lt; 0 || smod &gt; fEMCGeometry-&gt;GetNumberOfSuperModules()) </span>
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 :     AliFatal(Form(&quot;Wrong supermodule index -&gt; %d&quot;,smod));</span>
<span class="lineNum">    1335 </span>            :   
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :   return fkSModuleMatrix[smod] ;</span>
<span class="lineNum">    1337 </span>            : }
<span class="lineNum">    1338 </span>            : 
<span class="lineNum">    1339 </span>            : 
<span class="lineNum">    1340 </span>            : ///
<span class="lineNum">    1341 </span>            : /// Provides shift-rotation matrix for EMCAL from the TGeoManager.
<span class="lineNum">    1342 </span>            : /// \return alignment matrix for a super module number
<span class="lineNum">    1343 </span>            : /// \param smod: super module number
<a name="1344"><span class="lineNum">    1344 </span>            : ///</a>
<span class="lineNum">    1345 </span>            : //____________________________________________________________________________
<span class="lineNum">    1346 </span>            : const TGeoHMatrix * AliEMCALGeometry::GetMatrixForSuperModuleFromGeoManager(Int_t smod) const 
<span class="lineNum">    1347 </span>            : {  
<span class="lineNum">    1348 </span>            :   const Int_t buffersize = 255;
<span class="lineNum">    1349 </span><span class="lineCov">        194 :   char  path[buffersize] ;</span>
<span class="lineNum">    1350 </span>            :   Int_t tmpType = -1;
<span class="lineNum">    1351 </span>            :   Int_t smOrder = 0;
<span class="lineNum">    1352 </span>            :   
<span class="lineNum">    1353 </span>            :   //Get the order for SM
<span class="lineNum">    1354 </span><span class="lineCov">       1378 :   for( Int_t i = 0; i &lt; smod+1; i++)</span>
<span class="lineNum">    1355 </span>            :   {
<span class="lineNum">    1356 </span><span class="lineCov">        592 :     if(GetSMType(i) == tmpType) </span>
<span class="lineNum">    1357 </span>            :     {
<span class="lineNum">    1358 </span><span class="lineCov">        493 :       smOrder++;</span>
<span class="lineNum">    1359 </span><span class="lineCov">        493 :     } </span>
<span class="lineNum">    1360 </span>            :     else 
<span class="lineNum">    1361 </span>            :     {
<span class="lineNum">    1362 </span><span class="lineCov">         99 :       tmpType = GetSMType(i);</span>
<span class="lineNum">    1363 </span>            :       smOrder = 1;
<span class="lineNum">    1364 </span>            :     }
<span class="lineNum">    1365 </span>            :   } 
<span class="lineNum">    1366 </span>            :   
<span class="lineNum">    1367 </span><span class="lineCov">         97 :   Int_t   smType = GetSMType(smod);</span>
<span class="lineNum">    1368 </span><span class="lineCov">         97 :   TString smName = &quot;&quot;;</span>
<span class="lineNum">    1369 </span>            :   
<span class="lineNum">    1370 </span><span class="lineCov">        192 :   if      ( smType == kEMCAL_Standard ) smName = &quot;SMOD&quot;;</span>
<span class="lineNum">    1371 </span><span class="lineCov">          2 :   else if ( smType == kEMCAL_Half )     smName = &quot;SM10&quot;;</span>
<span class="lineNum">    1372 </span><span class="lineCov">          4 :   else if ( smType == kEMCAL_3rd )      smName = &quot;SM3rd&quot;;</span>
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 :   else if ( smType == kDCAL_Standard )  smName = &quot;DCSM&quot;;</span>
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :   else if ( smType == kDCAL_Ext )       smName = &quot;DCEXT&quot;;</span>
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :   else AliError(&quot;Unkown SM Type!!&quot;);</span>
<span class="lineNum">    1376 </span>            :   
<span class="lineNum">    1377 </span><span class="lineCov">        194 :   snprintf(path,buffersize,&quot;/ALIC_1/XEN1_1/%s_%d&quot;, smName.Data(), smOrder) ;</span>
<span class="lineNum">    1378 </span>            :   
<span class="lineNum">    1379 </span><span class="lineCov">        194 :   if (!gGeoManager-&gt;cd(path))</span>
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :     AliFatal(Form(&quot;Geo manager can not find path %s!\n&quot;,path));</span>
<span class="lineNum">    1381 </span>            :   
<span class="lineNum">    1382 </span><span class="lineCov">         97 :   return gGeoManager-&gt;GetCurrentMatrix();</span>
<span class="lineNum">    1383 </span><span class="lineCov">         97 : }</span>
<span class="lineNum">    1384 </span>            : 
<a name="1385"><span class="lineNum">    1385 </span>            : </a>
<span class="lineNum">    1386 </span>            : //__________________________________________________________________________________________________________________
<span class="lineNum">    1387 </span>            : void AliEMCALGeometry::RecalculateTowerPosition(Float_t drow, Float_t dcol, const Int_t sm, const Float_t depth,
<span class="lineNum">    1388 </span>            :                                                 const Float_t misaligTransShifts[15], const Float_t misaligRotShifts[15], Float_t global[3]) const
<span class="lineNum">    1389 </span>            : { 
<span class="lineNum">    1390 </span>            :   //Transform clusters cell position into global with alternative method, taking into account the depth calculation.
<span class="lineNum">    1391 </span>            :   //Input are: the tower indeces, 
<span class="lineNum">    1392 </span>            :   //           supermodule, 
<span class="lineNum">    1393 </span>            :   //           particle type (photon 0, electron 1, hadron 2 )
<span class="lineNum">    1394 </span>            :   //           misalignment shifts to global position in case of need.
<span class="lineNum">    1395 </span>            :   // Federico.Ronchetti@cern.ch
<span class="lineNum">    1396 </span>            :     
<span class="lineNum">    1397 </span>            :   // To use in a print later
<span class="lineNum">    1398 </span>            :   Float_t droworg = drow;
<span class="lineNum">    1399 </span>            :   Float_t dcolorg = dcol;
<span class="lineNum">    1400 </span>            :   
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :   if(gGeoManager){</span>
<span class="lineNum">    1402 </span>            :     //Recover some stuff
<span class="lineNum">    1403 </span>            : 
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 :     const Int_t nSMod = fEMCGeometry-&gt;GetNumberOfSuperModules();</span>
<span class="lineNum">    1405 </span>            :  
<span class="lineNum">    1406 </span><span class="lineNoCov">          0 :     gGeoManager-&gt;cd(&quot;ALIC_1/XEN1_1&quot;);</span>
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :     TGeoNode        *geoXEn1 = gGeoManager-&gt;GetCurrentNode();</span>
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :     TGeoNodeMatrix  *geoSM[nSMod];        </span>
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 :     TGeoVolume      *geoSMVol[nSMod];     </span>
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :     TGeoShape       *geoSMShape[nSMod];    </span>
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :     TGeoBBox        *geoBox[nSMod];        </span>
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :     TGeoMatrix      *geoSMMatrix[nSMod];       </span>
<span class="lineNum">    1413 </span>            :     
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :     for(int iSM = 0; iSM &lt; nSMod; iSM++) {  </span>
<span class="lineNum">    1415 </span><span class="lineNoCov">          0 :       geoSM[iSM]       = dynamic_cast&lt;TGeoNodeMatrix *&gt;(geoXEn1-&gt;GetDaughter(iSM));</span>
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :       geoSMVol[iSM]    = geoSM[iSM]-&gt;GetVolume(); </span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :       geoSMShape[iSM]  = geoSMVol[iSM]-&gt;GetShape();</span>
<span class="lineNum">    1418 </span><span class="lineNoCov">          0 :       geoBox[iSM]      = dynamic_cast&lt;TGeoBBox *&gt;(geoSMShape[iSM]);</span>
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :       geoSMMatrix[iSM] = geoSM[iSM]-&gt;GetMatrix();</span>
<span class="lineNum">    1420 </span>            :     }
<span class="lineNum">    1421 </span>            :     
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :     if(sm % 2 == 0) {</span>
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :       dcol = 47. - dcol;</span>
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :       drow = 23. - drow;</span>
<span class="lineNum">    1425 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1426 </span>            :     
<span class="lineNum">    1427 </span>            :     Int_t istrip = 0;
<span class="lineNum">    1428 </span>            :     Float_t z0   = 0;
<span class="lineNum">    1429 </span>            :     Float_t zb   = 0;
<span class="lineNum">    1430 </span>            :     Float_t zIs = 0;
<span class="lineNum">    1431 </span>            :     
<span class="lineNum">    1432 </span>            :     Float_t x,y,z; // return variables in terry's RF
<span class="lineNum">    1433 </span>            :     
<span class="lineNum">    1434 </span>            :     //***********************************************************
<span class="lineNum">    1435 </span>            :     //Do not like this: too many hardcoded values, is it not already stored somewhere else?
<span class="lineNum">    1436 </span>            :     //                : need more comments in the code 
<span class="lineNum">    1437 </span>            :     //***********************************************************
<span class="lineNum">    1438 </span>            :     
<span class="lineNum">    1439 </span>            :     Float_t dz = 6.0;   // base cell width in eta
<span class="lineNum">    1440 </span>            :     Float_t dx = 6.004; // base cell width in phi
<span class="lineNum">    1441 </span>            :     
<span class="lineNum">    1442 </span>            :     
<span class="lineNum">    1443 </span>            :     //Float_t L = 26.04; // active tower length for hadron (lead+scint+paper)
<span class="lineNum">    1444 </span>            :     // we use the geant numbers 13.87*2=27.74
<span class="lineNum">    1445 </span>            :     Float_t teta1 = 0.;
<span class="lineNum">    1446 </span>            :       
<span class="lineNum">    1447 </span>            :     //Do some basic checks
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :     if (dcol &gt;= 47.5 || dcol&lt;-0.5) {</span>
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :       AliError(Form(&quot;Bad tower coordinate dcol=%f, where dcol &gt;= 47.5 || dcol&lt;-0.5; org: %f&quot;, dcol, dcolorg));</span>
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1451 </span>            :     }
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :     if (drow &gt;= 23.5 || drow&lt;-0.5) {</span>
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :       AliError(Form(&quot;Bad tower coordinate drow=%f, where drow &gt;= 23.5 || drow&lt;-0.5; org: %f&quot;, drow, droworg));</span>
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1455 </span>            :     }
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 :     if (sm &gt;= nSMod || sm &lt; 0) {</span>
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :       AliError(Form(&quot;Bad SM number sm=%d, where sm &gt;= %d || sm &lt; 0&quot;, nSMod, sm));</span>
<span class="lineNum">    1458 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1459 </span>            :     }    
<span class="lineNum">    1460 </span>            :     
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :     istrip = int ((dcol+0.5)/2);</span>
<span class="lineNum">    1462 </span>            :     
<span class="lineNum">    1463 </span>            :     // tapering angle
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 :     teta1 = TMath::DegToRad() * istrip * 1.5;</span>
<span class="lineNum">    1465 </span>            :     
<span class="lineNum">    1466 </span>            :     // calculation of module corner along z 
<span class="lineNum">    1467 </span>            :     // as a function of strip
<span class="lineNum">    1468 </span>            :     
<span class="lineNum">    1469 </span><span class="lineNoCov">          0 :     for (int is=0; is&lt;= istrip; is++) {</span>
<span class="lineNum">    1470 </span>            :       
<span class="lineNum">    1471 </span><span class="lineNoCov">          0 :       teta1 = TMath::DegToRad() * (is*1.5 + 0.75);</span>
<span class="lineNum">    1472 </span><span class="lineNoCov">          0 :       if(is==0)</span>
<span class="lineNum">    1473 </span><span class="lineNoCov">          0 :         zIs = zIs + 2*dz*TMath::Cos(teta1);</span>
<span class="lineNum">    1474 </span>            :       else
<span class="lineNum">    1475 </span><span class="lineNoCov">          0 :         zIs = zIs + 2*dz*TMath::Cos(teta1) + 2*dz*TMath::Sin(teta1)*TMath::Tan(teta1-0.75*TMath::DegToRad());</span>
<span class="lineNum">    1476 </span>            :       
<span class="lineNum">    1477 </span>            :     }
<span class="lineNum">    1478 </span>            :     
<span class="lineNum">    1479 </span><span class="lineNoCov">          0 :     z0 = dz*(dcol-2*istrip+0.5);</span>
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :     zb = (2*dz-z0-depth*TMath::Tan(teta1));</span>
<span class="lineNum">    1481 </span>            :     
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 :     z = zIs - zb*TMath::Cos(teta1);</span>
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 :     y = depth/TMath::Cos(teta1) + zb*TMath::Sin(teta1);</span>
<span class="lineNum">    1484 </span>            :     
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :     x = (drow + 0.5)*dx;</span>
<span class="lineNum">    1486 </span>            :     
<span class="lineNum">    1487 </span>            :     // moving the origin from terry's RF
<span class="lineNum">    1488 </span>            :     // to the GEANT one
<span class="lineNum">    1489 </span>            :     
<span class="lineNum">    1490 </span><span class="lineNoCov">          0 :     double xx =  y - geoBox[sm]-&gt;GetDX();</span>
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 :     double yy = -x + geoBox[sm]-&gt;GetDY(); </span>
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :     double zz =  z - geoBox[sm]-&gt;GetDZ(); </span>
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :     const double localIn[3] = {xx, yy, zz};</span>
<span class="lineNum">    1494 </span><span class="lineNoCov">          0 :     double dglobal[3];</span>
<span class="lineNum">    1495 </span>            :     //geoSMMatrix[sm]-&gt;Print();
<span class="lineNum">    1496 </span>            :     //printf(&quot;TFF Local    (row = %d, col = %d, x = %3.2f,  y = %3.2f, z = %3.2f)\n&quot;, iroworg, icolorg, localIn[0], localIn[1], localIn[2]);
<span class="lineNum">    1497 </span><span class="lineNoCov">          0 :     geoSMMatrix[sm]-&gt;LocalToMaster(localIn, dglobal);</span>
<span class="lineNum">    1498 </span>            :     //printf(&quot;TFF Global   (row = %2.0f, col = %2.0f, x = %3.2f,  y = %3.2f, z = %3.2f)\n&quot;, drow, dcol, dglobal[0], dglobal[1], dglobal[2]);
<span class="lineNum">    1499 </span>            :     
<span class="lineNum">    1500 </span>            :     //apply global shifts
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 :     if(sm == 2 || sm == 3) {//sector 1</span>
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 :       global[0] = dglobal[0] + misaligTransShifts[3] + misaligRotShifts[3]*TMath::Sin(TMath::DegToRad()*20) ; </span>
<span class="lineNum">    1503 </span><span class="lineNoCov">          0 :       global[1] = dglobal[1] + misaligTransShifts[4] + misaligRotShifts[4]*TMath::Cos(TMath::DegToRad()*20) ; </span>
<span class="lineNum">    1504 </span><span class="lineNoCov">          0 :       global[2] = dglobal[2] + misaligTransShifts[5];</span>
<span class="lineNum">    1505 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1506 </span><span class="lineNoCov">          0 :     else if(sm == 0 || sm == 1){//sector 0</span>
<span class="lineNum">    1507 </span><span class="lineNoCov">          0 :       global[0] = dglobal[0] + misaligTransShifts[0]; </span>
<span class="lineNum">    1508 </span><span class="lineNoCov">          0 :       global[1] = dglobal[1] + misaligTransShifts[1]; </span>
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :       global[2] = dglobal[2] + misaligTransShifts[2];</span>
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1511 </span>            :     else {
<span class="lineNum">    1512 </span><span class="lineNoCov">          0 :       AliInfo(&quot;Careful, correction not implemented yet!&quot;);</span>
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :       global[0] = dglobal[0] ;</span>
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 :       global[1] = dglobal[1] ;</span>
<span class="lineNum">    1515 </span><span class="lineNoCov">          0 :       global[2] = dglobal[2] ;</span>
<span class="lineNum">    1516 </span>            :     }
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1518 </span>            :   else{
<span class="lineNum">    1519 </span><span class="lineNoCov">          0 :     AliFatal(&quot;Geometry boxes information, check that geometry.root is loaded\n&quot;);</span>
<span class="lineNum">    1520 </span>            :   }
<span class="lineNum">    1521 </span><span class="lineNoCov">          0 : }</span>
<a name="1522"><span class="lineNum">    1522 </span>            : </a>
<span class="lineNum">    1523 </span>            : //__________________________________________________________________________________________________________________
<span class="lineNum">    1524 </span>            : void AliEMCALGeometry::SetMisalMatrix(const TGeoHMatrix * m, Int_t smod) 
<span class="lineNum">    1525 </span>            : {
<span class="lineNum">    1526 </span>            :   // Method to set shift-rotational matrixes from ESDHeader
<span class="lineNum">    1527 </span>            :   // Move from header due to coding violations : Dec 2,2011 by PAI
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 :   fUseExternalMatrices = kTRUE;</span>
<span class="lineNum">    1529 </span>            : 
<span class="lineNum">    1530 </span><span class="lineNoCov">          0 :   if (smod &gt;= 0 &amp;&amp; smod &lt; fEMCGeometry-&gt;GetNumberOfSuperModules()){</span>
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :     if(!fkSModuleMatrix[smod]) fkSModuleMatrix[smod] = new TGeoHMatrix(*m) ; //Set only if not set yet</span>
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :   } else AliFatal(Form(&quot;Wrong supermodule index -&gt; %d&quot;,smod));</span>
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 : }</span>
<a name="1534"><span class="lineNum">    1534 </span>            : </a>
<span class="lineNum">    1535 </span>            : //__________________________________________________________________________________________________________________
<span class="lineNum">    1536 </span>            : Bool_t AliEMCALGeometry::IsDCALSM(Int_t iSupMod) const
<span class="lineNum">    1537 </span>            : {
<span class="lineNum">    1538 </span><span class="lineNoCov">          0 :   if( fEMCGeometry-&gt;GetEMCSystem()[iSupMod] == kDCAL_Standard || fEMCGeometry-&gt;GetEMCSystem()[iSupMod] == kDCAL_Ext ) return kTRUE;</span>
<span class="lineNum">    1539 </span><span class="lineNoCov">          0 :   return kFALSE;</span>
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 : }</span>
<a name="1541"><span class="lineNum">    1541 </span>            : </a>
<span class="lineNum">    1542 </span>            : //__________________________________________________________________________________________________________________
<span class="lineNum">    1543 </span>            : Bool_t AliEMCALGeometry::IsDCALExtSM(Int_t iSupMod) const
<span class="lineNum">    1544 </span>            : {
<span class="lineNum">    1545 </span><span class="lineNoCov">          0 :   if( fEMCGeometry-&gt;GetEMCSystem()[iSupMod] == kDCAL_Ext ) return kTRUE;</span>
<span class="lineNum">    1546 </span><span class="lineNoCov">          0 :   return kFALSE;</span>
<span class="lineNum">    1547 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
