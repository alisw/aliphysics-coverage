<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - EMCAL/EMCALUtils/AliEMCALRecoUtils.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">EMCAL/EMCALUtils</a> - AliEMCALRecoUtils.h<span style="font-size: 80%;"> (source / <a href="AliEMCALRecoUtils.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">175</td>
            <td class="headerCovTableEntryLo">0.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">146</td>
            <td class="headerCovTableEntryLo">0.7 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : #ifndef ALIEMCALRECOUTILS_H</a>
<span class="lineNum">       2 </span>            : #define ALIEMCALRECOUTILS_H
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">       5 </span>            : ///
<span class="lineNum">       6 </span>            : /// \class AliEMCALRecoUtils
<span class="lineNum">       7 </span>            : /// \brief Some utilities for cluster and cell treatment.
<span class="lineNum">       8 </span>            : ///
<span class="lineNum">       9 </span>            : /// This class contains methods to correct and select the clusters and cells:
<span class="lineNum">      10 </span>            : ///   * Calibration of cells/clusters
<span class="lineNum">      11 </span>            : ///      * Energy
<span class="lineNum">      12 </span>            : ///      * Time
<span class="lineNum">      13 </span>            : ///      * Temperature
<span class="lineNum">      14 </span>            : ///   * Cluster energy non linearity
<span class="lineNum">      15 </span>            : ///   * Rejection of clusters close to borders
<span class="lineNum">      16 </span>            : ///   * Rejection of clusters/cells containing/considered bad channels
<span class="lineNum">      17 </span>            : ///   * Recalculation of clusters
<span class="lineNum">      18 </span>            : ///      * Shower shape
<span class="lineNum">      19 </span>            : ///      * Position
<span class="lineNum">      20 </span>            : ///      * Matching to tracks
<span class="lineNum">      21 </span>            : ///
<span class="lineNum">      22 </span>            : /// Plus other helper methods.
<span class="lineNum">      23 </span>            : ///
<span class="lineNum">      24 </span>            : /// \author:  Gustavo Conesa Balbastre, &lt;Gustavo.Conesa.Balbastre@cern.ch&gt;, LPSC- Grenoble 
<span class="lineNum">      25 </span>            : /// \author:  Rongrong Ma, Yale. Track matching part
<span class="lineNum">      26 </span>            : ///
<span class="lineNum">      27 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : // Root includes
<span class="lineNum">      30 </span>            : #include &lt;TNamed.h&gt;
<span class="lineNum">      31 </span>            : #include &lt;TMath.h&gt;
<span class="lineNum">      32 </span>            : class TObjArray;
<span class="lineNum">      33 </span>            : class TArrayI;
<span class="lineNum">      34 </span>            : class TArrayF;
<span class="lineNum">      35 </span>            : #include &lt;TH2I.h&gt;
<span class="lineNum">      36 </span>            : class TH2F;
<span class="lineNum">      37 </span>            : #include &lt;TRandom3.h&gt;
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : // AliRoot includes
<span class="lineNum">      40 </span>            : class AliVCluster;
<span class="lineNum">      41 </span>            : class AliVCaloCells;
<span class="lineNum">      42 </span>            : class AliVEvent;
<span class="lineNum">      43 </span>            : #include &quot;AliLog.h&quot;
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : // EMCAL includes
<span class="lineNum">      46 </span>            : class AliEMCALGeometry;
<span class="lineNum">      47 </span>            : class AliEMCALPIDUtils;
<span class="lineNum">      48 </span>            : class AliESDtrack;
<span class="lineNum">      49 </span>            : class AliExternalTrackParam;
<span class="lineNum">      50 </span>            : class AliVTrack;
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : class AliEMCALRecoUtils : public TNamed {
<span class="lineNum">      53 </span>            :   
<span class="lineNum">      54 </span>            : public:
<span class="lineNum">      55 </span>            :   
<span class="lineNum">      56 </span>            :   AliEMCALRecoUtils();
<span class="lineNum">      57 </span>            :   AliEMCALRecoUtils(           const AliEMCALRecoUtils&amp;); 
<span class="lineNum">      58 </span>            :   AliEMCALRecoUtils&amp; operator=(const AliEMCALRecoUtils&amp;); 
<span class="lineNum">      59 </span>            :   virtual ~AliEMCALRecoUtils() ;  
<span class="lineNum">      60 </span>            :   
<span class="lineNum">      61 </span>            :   void     InitParameters();
<span class="lineNum">      62 </span>            :   void     Print(const Option_t*) const;
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            :   /// Non linearity enum list of possible parametrizations. 
<span class="lineNum">      65 </span>            :   /// Recomended for data kBeamTestCorrectedv3 and for simulation kPi0MCv3
<span class="lineNum">      66 </span>            :   enum     NonlinearityFunctions{ kPi0MC   = 0, kPi0GammaGamma = 1,
<span class="lineNum">      67 </span>            :                                   kPi0GammaConversion = 2, kNoCorrection = 3,
<span class="lineNum">      68 </span>            :                                   kBeamTest= 4, kBeamTestCorrected = 5,
<span class="lineNum">      69 </span>            :                                   kPi0MCv2 = 6, kPi0MCv3 = 7,
<span class="lineNum">      70 </span>            :                                   kBeamTestCorrectedv2   = 8,
<span class="lineNum">      71 </span>            :                                   kSDMv5   = 9, kPi0MCv5 = 10,
<span class="lineNum">      72 </span>            :                                   kSDMv6   =11, kPi0MCv6 = 12,
<span class="lineNum">      73 </span>            :                                   kBeamTestCorrectedv3   = 13};
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            :   /// Cluster position enum list of possible algoritms
<span class="lineNum">      76 </span>            :   enum     PositionAlgorithms{kUnchanged=-1,kPosTowerIndex=0, kPosTowerGlobal=1};
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span>            :   /// Position depth enum list of possible particle types
<span class="lineNum">      79 </span>            :   enum     ParticleType{kPhoton=0, kElectron=1, kHadron =2, kUnknown=-1};
<span class="lineNum">      80 </span>            :   
<span class="lineNum">      81 </span>            :   /// Track matching, Marcel
<span class="lineNum">      82 </span>            :   enum     { kNCuts = 12 }; 
<span class="lineNum">      83 </span>            :   
<span class="lineNum">      84 </span>            :   /// Track matching cuts enum list 
<span class="lineNum">      85 </span>            :   enum     TrackCutsType{ kTPCOnlyCut = 0, kGlobalCut = 1, kLooseCut = 2, kITSStandAlone = 3, 
<span class="lineNum">      86 </span>            :                           kGlobalCut2011 = 4, kLooseCutWithITSrefit = 5};  
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            :   //-----------------------------------------------------
<span class="lineNum">      89 </span>            :   // Position recalculation
<span class="lineNum">      90 </span>            :   //-----------------------------------------------------
<span class="lineNum">      91 </span>            :   void     RecalculateClusterPosition               (const AliEMCALGeometry *geom, AliVCaloCells* cells, AliVCluster* clu); 
<a name="92"><span class="lineNum">      92 </span>            :   void     RecalculateClusterPositionFromTowerIndex (const AliEMCALGeometry *geom, AliVCaloCells* cells, AliVCluster* clu); </a>
<span class="lineNum">      93 </span>            :   void     RecalculateClusterPositionFromTowerGlobal(const AliEMCALGeometry *geom, AliVCaloCells* cells, AliVCluster* clu); 
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :   Float_t  GetCellWeight(Float_t eCell, Float_t eCluster) const { if (eCell &gt; 0 &amp;&amp; eCluster &gt; 0) return TMath::Max( 0., fW0 + TMath::Log( eCell / eCluster )) ;</span>
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :                                                                   else                           return 0.                                                    ; }</span>
<span class="lineNum">      96 </span>            :   Float_t  GetDepth(Float_t eCluster, Int_t iParticle, Int_t iSM) const; 
<span class="lineNum">      97 </span>            :   void     GetMaxEnergyCell(const AliEMCALGeometry *geom, AliVCaloCells* cells, const AliVCluster* clu, 
<a name="98"><span class="lineNum">      98 </span>            :                             Int_t &amp; absId,  Int_t&amp; iSupMod, Int_t&amp; ieta, Int_t&amp; iphi, Bool_t &amp;shared);</a>
<span class="lineNum">      99 </span>            :   
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :   Float_t  GetMisalTransShift(Int_t i)       const { if(i &lt; 15 ) { return fMisalTransShift[i] ; }</span>
<a name="101"><span class="lineNum">     101 </span><span class="lineNoCov">          0 :                                                      else        { AliInfo(Form(&quot;Index %d larger than 15, do nothing\n&quot;,i)) ; </span></a>
<a name="102"><span class="lineNum">     102 </span><span class="lineNoCov">          0 :                                                                    return 0.                  ; } }</span></a>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :   Float_t* GetMisalTransShiftArray()                  { return fMisalTransShift ; }</span>
<a name="104"><span class="lineNum">     104 </span><span class="lineNoCov">          0 :   void     SetMisalTransShift(Int_t i, Float_t shift) { if(i &lt; 15 ) { fMisalTransShift[i] = shift ; }</span></a>
<a name="105"><span class="lineNum">     105 </span><span class="lineNoCov">          0 :                                                         else        { AliInfo(Form(&quot;Index %d larger than 15, do nothing\n&quot;,i)) ; } }</span></a>
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :   void     SetMisalTransShiftArray(Float_t * misal)   { for(Int_t i = 0; i &lt; 15; i++) fMisalTransShift[i] = misal[i]  ; }</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :   Float_t  GetMisalRotShift(Int_t i)         const    { if(i &lt; 15 ) { return fMisalRotShift[i]    ; }</span>
<a name="108"><span class="lineNum">     108 </span><span class="lineNoCov">          0 :                                                         else        { AliInfo(Form(&quot;Index %d larger than 15, do nothing\n&quot;,i)) ; </span></a>
<a name="109"><span class="lineNum">     109 </span><span class="lineNoCov">          0 :                                                                       return 0.                   ; } }</span></a>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :   Float_t* GetMisalRotShiftArray()                    { return fMisalRotShift                     ; }</span>
<a name="111"><span class="lineNum">     111 </span><span class="lineNoCov">          0 :   void     SetMisalRotShift(Int_t i, Float_t shift)   { if(i &lt; 15 ) { fMisalRotShift[i] = shift   ; }</span></a>
<a name="112"><span class="lineNum">     112 </span><span class="lineNoCov">          0 :                                                         else        { AliInfo(Form(&quot;Index %d larger than 15, do nothing\n&quot;,i)) ; } }</span></a>
<a name="113"><span class="lineNum">     113 </span><span class="lineNoCov">          0 :   void     SetMisalRotShiftArray(Float_t * misal)     { for(Int_t i = 0; i &lt; 15; i++)fMisalRotShift[i] = misal[i] ; }</span></a>
<a name="114"><span class="lineNum">     114 </span><span class="lineNoCov">          0 :   Int_t    GetParticleType()                       const { return  fParticleType    ; }</span></a>
<a name="115"><span class="lineNum">     115 </span><span class="lineNoCov">          0 :   void     SetParticleType(Int_t particle)               { fParticleType = particle ; }</span></a>
<a name="116"><span class="lineNum">     116 </span><span class="lineNoCov">          0 :   Int_t    GetPositionAlgorithm()                  const { return fPosAlgo          ; }</span></a>
<a name="117"><span class="lineNum">     117 </span><span class="lineNoCov">          0 :   void     SetPositionAlgorithm(Int_t alg)               { fPosAlgo = alg           ; }</span></a>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :   Float_t  GetW0()                                 const { return fW0               ; }</span>
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :   void     SetW0(Float_t w0)                             { fW0  = w0                ; }</span>
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            :   //-----------------------------------------------------
<span class="lineNum">     122 </span>            :   // Non Linearity
<a name="123"><span class="lineNum">     123 </span>            :   //-----------------------------------------------------</a>
<span class="lineNum">     124 </span>            :   Float_t  CorrectClusterEnergyLinearity(AliVCluster* clu) ;
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :   Float_t  GetNonLinearityParam(Int_t i)     const { if(i &lt; 7 &amp;&amp; i &gt;=0 ){ return fNonLinearityParams[i]  ; }</span>
<a name="126"><span class="lineNum">     126 </span><span class="lineNoCov">          0 :                                                      else  { AliInfo(Form(&quot;Index %d larger than 6 or negative, do nothing\n&quot;,i)) ;</span></a>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :                                                                          return 0.                     ; } }</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :   void     SetNonLinearityParam(Int_t i, Float_t param)  { if(i &lt; 7 &amp;&amp; i &gt;=0 ){ fNonLinearityParams[i] = param ; }</span>
<a name="129"><span class="lineNum">     129 </span><span class="lineNoCov">          0 :                                                            else { AliInfo(Form(&quot;Index %d larger than 6 or negative, do nothing\n&quot;,i)) ; } }</span></a>
<a name="130"><span class="lineNum">     130 </span>            :   void     InitNonLinearityParam();</a>
<a name="131"><span class="lineNum">     131 </span><span class="lineNoCov">          0 :   Int_t    GetNonLinearityFunction() const               { return fNonLinearityFunction    ; }</span></a>
<a name="132"><span class="lineNum">     132 </span><span class="lineNoCov">          0 :   void     SetNonLinearityFunction(Int_t fun)            { fNonLinearityFunction = fun     ; InitNonLinearityParam() ; }</span></a>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :   void     SetNonLinearityThreshold(Int_t threshold)     { fNonLinearThreshold = threshold ; } //only for Alexie's non linearity correction</span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :   Int_t    GetNonLinearityThreshold()              const { return fNonLinearThreshold      ; }</span>
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span>            :   //-----------------------------------------------------
<span class="lineNum">     137 </span>            :   // MC clusters energy smearing
<a name="138"><span class="lineNum">     138 </span>            :   //-----------------------------------------------------</a>
<a name="139"><span class="lineNum">     139 </span>            :   Float_t  SmearClusterEnergy(const AliVCluster* clu) ;</a>
<a name="140"><span class="lineNum">     140 </span><span class="lineNoCov">          0 :   void     SwitchOnClusterEnergySmearing()               { fSmearClusterEnergy = kTRUE         ; }</span></a>
<a name="141"><span class="lineNum">     141 </span><span class="lineNoCov">          0 :   void     SwitchOffClusterEnergySmearing()              { fSmearClusterEnergy = kFALSE        ; }</span></a>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :   Bool_t   IsClusterEnergySmeared()                const { return fSmearClusterEnergy          ; }   </span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :   void     SetSmearingParameters(Int_t i, Float_t param) { if(i &lt; 3){ fSmearClusterParam[i] = param ; }</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :                                                            else     { AliInfo(Form(&quot;Index %d larger than 2, do nothing\n&quot;,i)) ; } }</span>
<span class="lineNum">     145 </span>            :   //-----------------------------------------------------
<span class="lineNum">     146 </span>            :   // Recalibration
<span class="lineNum">     147 </span>            :   //-----------------------------------------------------
<span class="lineNum">     148 </span>            :   Bool_t   AcceptCalibrateCell(Int_t absId, Int_t bc,
<span class="lineNum">     149 </span>            :                                Float_t &amp; amp, Double_t &amp; time, AliVCaloCells* cells) ; // Energy and Time
<a name="150"><span class="lineNum">     150 </span>            :   void     RecalibrateCells(AliVCaloCells * cells, Int_t bc) ; // Energy and Time</a>
<span class="lineNum">     151 </span>            :   void     RecalibrateClusterEnergy(const AliEMCALGeometry* geom, AliVCluster* cluster, AliVCaloCells * cells, Int_t bc=-1) ; // Energy and time
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :   void     ResetCellsCalibrated()                        { fCellsRecalibrated = kFALSE; }</span>
<a name="153"><span class="lineNum">     153 </span>            : </a>
<a name="154"><span class="lineNum">     154 </span>            :   // Energy recalibration</a>
<a name="155"><span class="lineNum">     155 </span><span class="lineNoCov">          0 :   Bool_t   IsRecalibrationOn()                     const { return fRecalibration ; }</span></a>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :   void     SwitchOffRecalibration()                      { fRecalibration = kFALSE ; }</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :   void     SwitchOnRecalibration()                       { fRecalibration = kTRUE  ; </span>
<a name="158"><span class="lineNum">     158 </span><span class="lineNoCov">          0 :                                                            if(!fEMCALRecalibrationFactors)InitEMCALRecalibrationFactors() ; }</span></a>
<a name="159"><span class="lineNum">     159 </span>            :   void     InitEMCALRecalibrationFactors() ;</a>
<a name="160"><span class="lineNum">     160 </span><span class="lineNoCov">          0 :   TObjArray* GetEMCALRecalibrationFactorsArray()   const { return fEMCALRecalibrationFactors ; }</span></a>
<a name="161"><span class="lineNum">     161 </span><span class="lineNoCov">          0 :   TH2F *   GetEMCALChannelRecalibrationFactors(Int_t iSM)     const { return (TH2F*)fEMCALRecalibrationFactors-&gt;At(iSM) ; }  </span></a>
<a name="162"><span class="lineNum">     162 </span><span class="lineNoCov">          0 :   void     SetEMCALChannelRecalibrationFactors(TObjArray *map)      { fEMCALRecalibrationFactors = map                  ; }</span></a>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :   void     SetEMCALChannelRecalibrationFactors(Int_t iSM , TH2F* h) { fEMCALRecalibrationFactors-&gt;AddAt(h,iSM)          ; }</span>
<span class="lineNum">     164 </span>            :   Float_t  GetEMCALChannelRecalibrationFactor(Int_t iSM , Int_t iCol, Int_t iRow) const { 
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :     if(fEMCALRecalibrationFactors) </span>
<a name="166"><span class="lineNum">     166 </span><span class="lineNoCov">          0 :       return (Float_t) ((TH2F*)fEMCALRecalibrationFactors-&gt;At(iSM))-&gt;GetBinContent(iCol,iRow); </span></a>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :     else return 1 ; } </span>
<span class="lineNum">     168 </span>            :   void     SetEMCALChannelRecalibrationFactor(Int_t iSM , Int_t iCol, Int_t iRow, Double_t c = 1) { 
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :     if(!fEMCALRecalibrationFactors) InitEMCALRecalibrationFactors() ;</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :     ((TH2F*)fEMCALRecalibrationFactors-&gt;At(iSM))-&gt;SetBinContent(iCol,iRow,c) ; }</span>
<a name="171"><span class="lineNum">     171 </span>            :   </a>
<a name="172"><span class="lineNum">     172 </span>            :   // Recalibrate channels energy with run dependent corrections</a>
<a name="173"><span class="lineNum">     173 </span><span class="lineNoCov">          0 :   Bool_t   IsRunDepRecalibrationOn()               const { return fUseRunCorrectionFactors ; }</span></a>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :   void     SwitchOffRunDepCorrection()                   { fUseRunCorrectionFactors = kFALSE ; }</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :   void     SwitchOnRunDepCorrection()                    { fUseRunCorrectionFactors = kTRUE  ; </span>
<a name="176"><span class="lineNum">     176 </span><span class="lineNoCov">          0 :                                                            SwitchOnRecalibration()           ; }      </span></a>
<span class="lineNum">     177 </span>            :   // Time Recalibration  
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :   void     SetConstantTimeShift(Float_t shift)           { fConstantTimeShift = shift  ; }</span>
<span class="lineNum">     179 </span>            : 
<a name="180"><span class="lineNum">     180 </span>            :   void     RecalibrateCellTime(Int_t absId, Int_t bc, Double_t &amp; time,Bool_t isLGon = kFALSE) const;</a>
<a name="181"><span class="lineNum">     181 </span>            :   </a>
<a name="182"><span class="lineNum">     182 </span><span class="lineNoCov">          0 :   Bool_t   IsTimeRecalibrationOn()                 const { return fTimeRecalibration   ; }</span></a>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :   void     SwitchOffTimeRecalibration()                  { fTimeRecalibration = kFALSE ; }</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :   void     SwitchOnTimeRecalibration()                   { fTimeRecalibration = kTRUE  ; </span>
<a name="185"><span class="lineNum">     185 </span><span class="lineNoCov">          0 :                                                            if(!fEMCALTimeRecalibrationFactors)InitEMCALTimeRecalibrationFactors() ; }</span></a>
<span class="lineNum">     186 </span>            :   void     InitEMCALTimeRecalibrationFactors() ;
<a name="187"><span class="lineNum">     187 </span><span class="lineNoCov">          0 :   TObjArray* GetEMCALTimeRecalibrationFactorsArray() const { return fEMCALTimeRecalibrationFactors ; }</span></a>
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            :   Float_t  GetEMCALChannelTimeRecalibrationFactor(Int_t bc, Int_t absID, Bool_t isLGon = kFALSE) const { 
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :     if(fEMCALTimeRecalibrationFactors) </span>
<a name="191"><span class="lineNum">     191 </span><span class="lineNoCov">          0 :       return (Float_t) ((TH1F*)fEMCALTimeRecalibrationFactors-&gt;At(bc+4*isLGon))-&gt;GetBinContent(absID); </span></a>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :     else return 0 ; } </span>
<span class="lineNum">     193 </span>            :   void     SetEMCALChannelTimeRecalibrationFactor(Int_t bc, Int_t absID, Double_t c = 0, Bool_t isLGon=kFALSE) { 
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :     if(!fEMCALTimeRecalibrationFactors) InitEMCALTimeRecalibrationFactors() ;</span>
<a name="195"><span class="lineNum">     195 </span><span class="lineNoCov">          0 :     ((TH1F*)fEMCALTimeRecalibrationFactors-&gt;At(bc+4*isLGon))-&gt;SetBinContent(absID,c) ; }  </span></a>
<a name="196"><span class="lineNum">     196 </span>            :   </a>
<a name="197"><span class="lineNum">     197 </span><span class="lineNoCov">          0 :   TH1F *   GetEMCALChannelTimeRecalibrationFactors(Int_t bc)const       { return (TH1F*)fEMCALTimeRecalibrationFactors-&gt;At(bc) ; }   </span></a>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :   void     SetEMCALChannelTimeRecalibrationFactors(TObjArray *map)            { fEMCALTimeRecalibrationFactors = map                 ; }</span>
<a name="199"><span class="lineNum">     199 </span><span class="lineNoCov">          0 :   void     SetEMCALChannelTimeRecalibrationFactors(Int_t bc , TH1F* h)  { fEMCALTimeRecalibrationFactors-&gt;AddAt(h,bc)          ; }</span></a>
<a name="200"><span class="lineNum">     200 </span>            : </a>
<a name="201"><span class="lineNum">     201 </span><span class="lineNoCov">          0 :   Bool_t   IsLGOn()const { return fLowGain   ; }</span></a>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :   void     SwitchOffLG() { fLowGain = kFALSE ; }</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :   void     SwitchOnLG()  { fLowGain = kTRUE  ; }</span>
<span class="lineNum">     204 </span>            : 
<a name="205"><span class="lineNum">     205 </span>            : </a>
<a name="206"><span class="lineNum">     206 </span>            :   // Time Recalibration with L1 phase</a>
<a name="207"><span class="lineNum">     207 </span><span class="lineNoCov">          0 :   Bool_t   IsL1PhaseInTimeRecalibrationOn()          const { return fUseL1PhaseInTimeRecalibration   ; }</span></a>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :   void     SwitchOffL1PhaseInTimeRecalibration()           { fUseL1PhaseInTimeRecalibration = kFALSE ; }</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :   void     SwitchOnL1PhaseInTimeRecalibration()            { fUseL1PhaseInTimeRecalibration = kTRUE  ; </span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :     if(!fEMCALL1PhaseInTimeRecalibration) InitEMCALL1PhaseInTimeRecalibration() ; }</span>
<span class="lineNum">     211 </span>            :   void     InitEMCALL1PhaseInTimeRecalibration() ;
<a name="212"><span class="lineNum">     212 </span>            : </a>
<a name="213"><span class="lineNum">     213 </span>            :   void     RecalibrateCellTimeL1Phase(Int_t iSM, Int_t bc, Double_t &amp; time) const;</a>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :   TObjArray* GetEMCALL1PhaseInTimeRecalibrationArray() const { return fEMCALL1PhaseInTimeRecalibration ; }</span>
<span class="lineNum">     215 </span>            :   Int_t  GetEMCALL1PhaseInTimeRecalibrationForSM(Int_t iSM) const { 
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :     if(fEMCALL1PhaseInTimeRecalibration) </span>
<a name="217"><span class="lineNum">     217 </span><span class="lineNoCov">          0 :       return (Int_t) ((TH1C*)fEMCALL1PhaseInTimeRecalibration-&gt;At(0))-&gt;GetBinContent(iSM); </span></a>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :     else return 0 ; } </span>
<span class="lineNum">     219 </span>            :   void     SetEMCALL1PhaseInTimeRecalibrationForSM(Int_t iSM, Int_t c = 0) { 
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :     if(!fEMCALL1PhaseInTimeRecalibration) InitEMCALL1PhaseInTimeRecalibration();</span>
<a name="221"><span class="lineNum">     221 </span><span class="lineNoCov">          0 :     ((TH1C*)fEMCALL1PhaseInTimeRecalibration-&gt;At(0))-&gt;SetBinContent(iSM,c) ; }  </span></a>
<a name="222"><span class="lineNum">     222 </span>            :   </a>
<a name="223"><span class="lineNum">     223 </span><span class="lineNoCov">          0 :   TH1C *   GetEMCALL1PhaseInTimeRecalibrationForAllSM()const       { return (TH1C*)fEMCALL1PhaseInTimeRecalibration-&gt;At(0) ; }       </span></a>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :   void     SetEMCALL1PhaseInTimeRecalibrationForAllSM(TObjArray *map)            { fEMCALL1PhaseInTimeRecalibration = map  ; }</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :   void     SetEMCALL1PhaseInTimeRecalibrationForAllSM(TH1C* h)     { fEMCALL1PhaseInTimeRecalibration-&gt;AddAt(h,0)          ; }</span>
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            :   //-----------------------------------------------------
<span class="lineNum">     228 </span>            :   // Modules fiducial region, remove clusters in borders
<span class="lineNum">     229 </span>            :   //-----------------------------------------------------
<span class="lineNum">     230 </span>            :   Bool_t   CheckCellFiducialRegion(const AliEMCALGeometry* geom, 
<a name="231"><span class="lineNum">     231 </span>            :                                    const AliVCluster* cluster, </a>
<a name="232"><span class="lineNum">     232 </span>            :                                    AliVCaloCells* cells) ;</a>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :   void     SetNumberOfCellsFromEMCALBorder(Int_t n){ fNCellsFromEMCALBorder = n      ; }</span>
<a name="234"><span class="lineNum">     234 </span><span class="lineNoCov">          0 :   Int_t    GetNumberOfCellsFromEMCALBorder()      const  { return fNCellsFromEMCALBorder   ; }</span></a>
<a name="235"><span class="lineNum">     235 </span>            :     </a>
<a name="236"><span class="lineNum">     236 </span><span class="lineNoCov">          0 :   void     SwitchOnNoFiducialBorderInEMCALEta0()         { fNoEMCALBorderAtEta0 = kTRUE    ; }</span></a>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :   void     SwitchOffNoFiducialBorderInEMCALEta0()        { fNoEMCALBorderAtEta0 = kFALSE   ; }</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :   Bool_t   IsEMCALNoBorderAtEta0()                 const { return fNoEMCALBorderAtEta0     ; }</span>
<span class="lineNum">     239 </span>            :   
<span class="lineNum">     240 </span>            :   //-----------------------------------------------------
<a name="241"><span class="lineNum">     241 </span>            :   // Bad channels</a>
<a name="242"><span class="lineNum">     242 </span>            :   //-----------------------------------------------------</a>
<a name="243"><span class="lineNum">     243 </span><span class="lineNoCov">          0 :   Bool_t   IsBadChannelsRemovalSwitchedOn()        const { return fRemoveBadChannels       ; }</span></a>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :   void     SwitchOffBadChannelsRemoval()                 { fRemoveBadChannels = kFALSE     ; }</span>
<a name="245"><span class="lineNum">     245 </span><span class="lineNoCov">          0 :   void     SwitchOnBadChannelsRemoval ()                 { fRemoveBadChannels = kTRUE ; </span></a>
<a name="246"><span class="lineNum">     246 </span><span class="lineNoCov">          0 :                                                            if(!fEMCALBadChannelMap)InitEMCALBadChannelStatusMap() ; }</span></a>
<a name="247"><span class="lineNum">     247 </span><span class="lineNoCov">          0 :   Bool_t   IsDistanceToBadChannelRecalculated()    const { return fRecalDistToBadChannels   ; }</span></a>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :   void     SwitchOffDistToBadChannelRecalculation()      { fRecalDistToBadChannels = kFALSE ; }</span>
<a name="249"><span class="lineNum">     249 </span><span class="lineNoCov">          0 :   void     SwitchOnDistToBadChannelRecalculation()       { fRecalDistToBadChannels = kTRUE  ; </span></a>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :                                                            if(!fEMCALBadChannelMap)InitEMCALBadChannelStatusMap() ; }</span>
<a name="251"><span class="lineNum">     251 </span><span class="lineNoCov">          0 :   TObjArray* GetEMCALBadChannelStatusMapArray()    const { return fEMCALBadChannelMap ; }</span></a>
<span class="lineNum">     252 </span>            :   void     InitEMCALBadChannelStatusMap() ;
<span class="lineNum">     253 </span>            :   Int_t    GetEMCALChannelStatus(Int_t iSM , Int_t iCol, Int_t iRow) const { 
<a name="254"><span class="lineNum">     254 </span><span class="lineNoCov">          0 :     if(fEMCALBadChannelMap) return (Int_t) ((TH2I*)fEMCALBadChannelMap-&gt;At(iSM))-&gt;GetBinContent(iCol,iRow); </span></a>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :     else return 0;}//Channel is ok by default</span>
<span class="lineNum">     256 </span>            :   void     SetEMCALChannelStatus(Int_t iSM , Int_t iCol, Int_t iRow, Double_t c = 1) { 
<a name="257"><span class="lineNum">     257 </span><span class="lineNoCov">          0 :     if(!fEMCALBadChannelMap)InitEMCALBadChannelStatusMap()               ;</span></a>
<a name="258"><span class="lineNum">     258 </span><span class="lineNoCov">          0 :     ((TH2I*)fEMCALBadChannelMap-&gt;At(iSM))-&gt;SetBinContent(iCol,iRow,c)    ; }</span></a>
<a name="259"><span class="lineNum">     259 </span><span class="lineNoCov">          0 :   TH2I *   GetEMCALChannelStatusMap(Int_t iSM)     const { return (TH2I*)fEMCALBadChannelMap-&gt;At(iSM) ; }</span></a>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :   void     SetEMCALChannelStatusMap(TObjArray *map)      { fEMCALBadChannelMap = map                  ; }</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :   void     SetEMCALChannelStatusMap(Int_t iSM , TH2I* h) { fEMCALBadChannelMap-&gt;AddAt(h,iSM)          ; }</span>
<span class="lineNum">     262 </span>            :   Bool_t   ClusterContainsBadChannel(const AliEMCALGeometry* geom, const UShort_t* cellList, Int_t nCells);
<span class="lineNum">     263 </span>            :  
<span class="lineNum">     264 </span>            :   //-----------------------------------------------------
<span class="lineNum">     265 </span>            :   // Recalculate other cluster parameters
<span class="lineNum">     266 </span>            :   //-----------------------------------------------------
<span class="lineNum">     267 </span>            :   void     RecalculateClusterDistanceToBadChannel (const AliEMCALGeometry * geom, AliVCaloCells* cells, AliVCluster * cluster);
<span class="lineNum">     268 </span>            :   void     RecalculateClusterShowerShapeParameters(const AliEMCALGeometry * geom, AliVCaloCells* cells, AliVCluster * cluster);
<span class="lineNum">     269 </span>            :   void     RecalculateClusterShowerShapeParameters(const AliEMCALGeometry * geom, AliVCaloCells* cells, AliVCluster * cluster,
<span class="lineNum">     270 </span>            :                                                    Float_t &amp; l0,   Float_t &amp; l1,   
<span class="lineNum">     271 </span>            :                                                    Float_t &amp; disp, Float_t &amp; dEta, Float_t &amp; dPhi,
<span class="lineNum">     272 </span>            :                                                    Float_t &amp; sEta, Float_t &amp; sPhi, Float_t &amp; sEtaPhi);
<span class="lineNum">     273 </span>            :   
<span class="lineNum">     274 </span>            :   void     RecalculateClusterShowerShapeParametersWithCellCuts(const AliEMCALGeometry * geom, AliVCaloCells* cells, AliVCluster * cluster, 
<span class="lineNum">     275 </span>            :                                                                Float_t cellEcut, Float_t cellTimeCut, Int_t bc, Float_t &amp; enAfterCuts);
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            :   void     RecalculateClusterShowerShapeParametersWithCellCuts(const AliEMCALGeometry * geom, AliVCaloCells* cells, AliVCluster * cluster,
<span class="lineNum">     278 </span>            :                                                                Float_t cellEcut, Float_t cellTimeCut, Int_t bc,
<span class="lineNum">     279 </span>            :                                                                Float_t &amp; enAfterCuts, Float_t &amp; l0,   Float_t &amp; l1,   
<span class="lineNum">     280 </span>            :                                                                Float_t &amp; disp, Float_t &amp; dEta, Float_t &amp; dPhi,
<a name="281"><span class="lineNum">     281 </span>            :                                                                Float_t &amp; sEta, Float_t &amp; sPhi, Float_t &amp; sEtaPhi);</a>
<span class="lineNum">     282 </span>            :   void     RecalculateClusterPID(AliVCluster * cluster);
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :   AliEMCALPIDUtils * GetPIDUtils() { return fPIDUtils;}</span>
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            :   //----------------------------------------------------
<span class="lineNum">     286 </span>            :   // Track matching
<span class="lineNum">     287 </span>            :   //----------------------------------------------------
<span class="lineNum">     288 </span>            :   void     FindMatches(AliVEvent *event, TObjArray * clusterArr=0x0, const AliEMCALGeometry *geom=0x0);
<span class="lineNum">     289 </span>            :   Int_t    FindMatchedClusterInEvent(const AliESDtrack *track, const AliVEvent *event, 
<span class="lineNum">     290 </span>            :                                      const AliEMCALGeometry *geom, Float_t &amp;dEta, Float_t &amp;dPhi);
<span class="lineNum">     291 </span>            :   Int_t    FindMatchedClusterInClusterArr(const AliExternalTrackParam *emcalParam, 
<span class="lineNum">     292 </span>            :                                           AliExternalTrackParam *trkParam, 
<span class="lineNum">     293 </span>            :                                           const TObjArray * clusterArr, 
<span class="lineNum">     294 </span>            :                                           Float_t &amp;dEta, Float_t &amp;dPhi);
<span class="lineNum">     295 </span>            :   static Bool_t ExtrapolateTrackToEMCalSurface(AliVTrack *track, /*note, on success the call will change the track*/
<span class="lineNum">     296 </span>            :                                                Double_t emcalR=440, Double_t mass=0.1396,
<span class="lineNum">     297 </span>            :                                                Double_t step=20, Double_t minpT=0.35,
<span class="lineNum">     298 </span>            :                                                Bool_t useMassForTracking = kFALSE);
<span class="lineNum">     299 </span>            :   static Bool_t ExtrapolateTrackToEMCalSurface(AliExternalTrackParam *trkParam, 
<span class="lineNum">     300 </span>            :                                                Double_t emcalR, Double_t mass, Double_t step, 
<span class="lineNum">     301 </span>            :                                                Float_t &amp;eta, Float_t &amp;phi, Float_t &amp;pt);
<span class="lineNum">     302 </span>            :   static Bool_t ExtrapolateTrackToPosition(AliExternalTrackParam *trkParam, const Float_t *clsPos, 
<span class="lineNum">     303 </span>            :                                            Double_t mass, Double_t step, 
<span class="lineNum">     304 </span>            :                                            Float_t &amp;tmpEta, Float_t &amp;tmpPhi);
<span class="lineNum">     305 </span>            :   static Bool_t ExtrapolateTrackToCluster (AliExternalTrackParam *trkParam, const AliVCluster *cluster, 
<span class="lineNum">     306 </span>            :                                            Double_t mass, Double_t step,
<span class="lineNum">     307 </span>            :                                            Float_t &amp;tmpEta, Float_t &amp;tmpPhi);
<span class="lineNum">     308 </span>            :   Bool_t        ExtrapolateTrackToCluster (AliExternalTrackParam *trkParam, const AliVCluster *cluster, 
<span class="lineNum">     309 </span>            :                                            Float_t &amp;tmpEta, Float_t &amp;tmpPhi);
<span class="lineNum">     310 </span>            :   UInt_t   FindMatchedPosForCluster(Int_t clsIndex) const;
<span class="lineNum">     311 </span>            :   UInt_t   FindMatchedPosForTrack  (Int_t trkIndex) const;
<span class="lineNum">     312 </span>            :   void     GetMatchedResiduals       (Int_t clsIndex, Float_t &amp;dEta, Float_t &amp;dPhi);
<span class="lineNum">     313 </span>            :   void     GetMatchedClusterResiduals(Int_t trkIndex, Float_t &amp;dEta, Float_t &amp;dPhi);
<span class="lineNum">     314 </span>            :   Int_t    GetMatchedTrackIndex(Int_t clsIndex);
<span class="lineNum">     315 </span>            :   Int_t    GetMatchedClusterIndex(Int_t trkIndex);
<span class="lineNum">     316 </span>            :   Bool_t   IsClusterMatched(Int_t clsIndex)         const;
<span class="lineNum">     317 </span>            :   Bool_t   IsTrackMatched  (Int_t trkIndex)         const;
<a name="318"><span class="lineNum">     318 </span>            :   void     SetClusterMatchedToTrack (const AliVEvent *event);</a>
<span class="lineNum">     319 </span>            :   void     SetTracksMatchedToCluster(const AliVEvent *event);  
<a name="320"><span class="lineNum">     320 </span><span class="lineNoCov">          0 :   void     SwitchOnCutEtaPhiSum()                     { fCutEtaPhiSum      = kTRUE    ; </span></a>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :                                                         fCutEtaPhiSeparate = kFALSE   ; }</span>
<a name="322"><span class="lineNum">     322 </span><span class="lineNoCov">          0 :   void     SwitchOnCutEtaPhiSeparate()                { fCutEtaPhiSeparate = kTRUE    ;</span></a>
<a name="323"><span class="lineNum">     323 </span><span class="lineNoCov">          0 :                                                         fCutEtaPhiSum      = kFALSE   ; }</span></a>
<a name="324"><span class="lineNum">     324 </span><span class="lineNoCov">          0 :   Float_t  GetCutR()                            const { return fCutR                  ; }</span></a>
<a name="325"><span class="lineNum">     325 </span><span class="lineNoCov">          0 :   Float_t  GetCutEta()                          const { return fCutEta                ; }</span></a>
<a name="326"><span class="lineNum">     326 </span><span class="lineNoCov">          0 :   Float_t  GetCutPhi()                          const { return fCutPhi                ; }</span></a>
<a name="327"><span class="lineNum">     327 </span><span class="lineNoCov">          0 :   Double_t GetClusterWindow()                   const { return fClusterWindow         ; }</span></a>
<a name="328"><span class="lineNum">     328 </span><span class="lineNoCov">          0 :   void     SetCutR(Float_t cutR)                      { fCutR   = cutR                ; }</span></a>
<a name="329"><span class="lineNum">     329 </span><span class="lineNoCov">          0 :   void     SetCutEta(Float_t cutEta)                  { fCutEta = cutEta              ; }</span></a>
<a name="330"><span class="lineNum">     330 </span><span class="lineNoCov">          0 :   void     SetCutPhi(Float_t cutPhi)                  { fCutPhi = cutPhi              ; }</span></a>
<a name="331"><span class="lineNum">     331 </span><span class="lineNoCov">          0 :   void     SetClusterWindow(Double_t window)          { fClusterWindow = window       ; }</span></a>
<a name="332"><span class="lineNum">     332 </span><span class="lineNoCov">          0 :   void     SetCutZ(Float_t cutZ)                      { printf(&quot;Obsolete fucntion of cutZ=%1.1f\n&quot;,cutZ) ; } //Obsolete</span></a>
<a name="333"><span class="lineNum">     333 </span><span class="lineNoCov">          0 :   void     SetEMCalSurfaceDistance(Double_t d)        { fEMCalSurfaceDistance = d     ; }</span></a>
<a name="334"><span class="lineNum">     334 </span><span class="lineNoCov">          0 :   Double_t GetMass()                            const { return fMass                  ; }</span></a>
<a name="335"><span class="lineNum">     335 </span><span class="lineNoCov">          0 :   Double_t GetStep()                            const { return fStepCluster           ; }</span></a>
<a name="336"><span class="lineNum">     336 </span><span class="lineNoCov">          0 :   Double_t GetStepSurface()                     const { return fStepSurface           ; }</span></a>
<a name="337"><span class="lineNum">     337 </span><span class="lineNoCov">          0 :   void     SetMass(Double_t mass)                     { fMass = mass                  ; }</span></a>
<a name="338"><span class="lineNum">     338 </span><span class="lineNoCov">          0 :   void     SetStep(Double_t step)                     { fStepSurface = step           ; }</span></a>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :   void     SetStepCluster(Double_t step)              { fStepCluster = step           ; }</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :   void     SetITSTrackSA(Bool_t isITS)                { fITSTrackSA = isITS           ; } //Special Handle of AliExternTrackParam    </span>
<span class="lineNum">     341 </span>            :     
<span class="lineNum">     342 </span>            :   // Track Cuts 
<a name="343"><span class="lineNum">     343 </span>            :   Bool_t   IsAccepted(AliESDtrack *track);</a>
<span class="lineNum">     344 </span>            :   void     InitTrackCuts();
<a name="345"><span class="lineNum">     345 </span><span class="lineNoCov">          0 :   void     SetTrackCutsType(Int_t type)              { fTrackCutsType = type           ; </span></a>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :                                                        InitTrackCuts()                 ; }</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :   Int_t    GetTrackCutsType() const                  { return fTrackCutsType; }</span>
<a name="348"><span class="lineNum">     348 </span>            : </a>
<a name="349"><span class="lineNum">     349 </span>            :   // Define AOD track type for matching</a>
<a name="350"><span class="lineNum">     350 </span><span class="lineNoCov">          0 :   void     SwitchOffAODHybridTracksMatch()           { fAODHybridTracks         = kFALSE ; }</span></a>
<a name="351"><span class="lineNum">     351 </span><span class="lineNoCov">          0 :   void     SwitchOffAODTPCOnlyTracksMatch()          { fAODTPCOnlyTracks        = kFALSE ; }</span></a>
<a name="352"><span class="lineNum">     352 </span><span class="lineNoCov">          0 :   void     SwitchOnAODHybridTracksMatch()            { fAODHybridTracks         = kTRUE  ; SwitchOffAODTPCOnlyTracksMatch() ; }</span></a>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :   void     SwitchOnAODTPCOnlyTracksMatch()           { fAODTPCOnlyTracks        = kTRUE  ; SwitchOffAODHybridTracksMatch()  ; }</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :   void     SetAODTrackFilterMask( UInt_t mask)       { fAODFilterMask           = mask   ;</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :                                                        SwitchOffAODTPCOnlyTracksMatch()  ; SwitchOffAODHybridTracksMatch()  ; }</span>
<a name="356"><span class="lineNum">     356 </span>            : </a>
<a name="357"><span class="lineNum">     357 </span>            :   // track quality cut setters</a>
<a name="358"><span class="lineNum">     358 </span><span class="lineNoCov">          0 :   void     SetMinTrackPt(Double_t pt=0)              { fCutMinTrackPt           = pt   ; }</span></a>
<a name="359"><span class="lineNum">     359 </span><span class="lineNoCov">          0 :   void     SetMinNClustersTPC(Int_t min=-1)          { fCutMinNClusterTPC       = min  ; }</span></a>
<a name="360"><span class="lineNum">     360 </span><span class="lineNoCov">          0 :   void     SetMinNClustersITS(Int_t min=-1)          { fCutMinNClusterITS       = min  ; }</span></a>
<a name="361"><span class="lineNum">     361 </span><span class="lineNoCov">          0 :   void     SetMaxChi2PerClusterTPC(Float_t max=1e10) { fCutMaxChi2PerClusterTPC = max  ; }</span></a>
<a name="362"><span class="lineNum">     362 </span><span class="lineNoCov">          0 :   void     SetMaxChi2PerClusterITS(Float_t max=1e10) { fCutMaxChi2PerClusterITS = max  ; }</span></a>
<a name="363"><span class="lineNum">     363 </span><span class="lineNoCov">          0 :   void     SetRequireTPCRefit(Bool_t b=kFALSE)       { fCutRequireTPCRefit      = b    ; }</span></a>
<a name="364"><span class="lineNum">     364 </span><span class="lineNoCov">          0 :   void     SetRequireITSRefit(Bool_t b=kFALSE)       { fCutRequireITSRefit      = b    ; }</span></a>
<a name="365"><span class="lineNum">     365 </span><span class="lineNoCov">          0 :   void     SetAcceptKinkDaughters(Bool_t b=kTRUE)    { fCutAcceptKinkDaughters  = b    ; }</span></a>
<a name="366"><span class="lineNum">     366 </span><span class="lineNoCov">          0 :   void     SetMaxDCAToVertexXY(Float_t dist=1e10)    { fCutMaxDCAToVertexXY     = dist ; }</span></a>
<a name="367"><span class="lineNum">     367 </span><span class="lineNoCov">          0 :   void     SetMaxDCAToVertexZ(Float_t dist=1e10)     { fCutMaxDCAToVertexZ      = dist ; }</span></a>
<a name="368"><span class="lineNum">     368 </span><span class="lineNoCov">          0 :   void     SetDCAToVertex2D(Bool_t b=kFALSE)         { fCutDCAToVertex2D        = b    ; }</span></a>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :   void     SetRequireITSStandAlone(Bool_t b=kFALSE)    {fCutRequireITSStandAlone = b;} //Marcel</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :   void     SetRequireITSPureStandAlone(Bool_t b=kFALSE){fCutRequireITSpureSA     = b;}</span>
<a name="371"><span class="lineNum">     371 </span>            :   </a>
<a name="372"><span class="lineNum">     372 </span>            :   // getters                                                            </a>
<a name="373"><span class="lineNum">     373 </span><span class="lineNoCov">          0 :   Double_t GetMinTrackPt()                     const { return fCutMinTrackPt           ; }</span></a>
<a name="374"><span class="lineNum">     374 </span><span class="lineNoCov">          0 :   Int_t    GetMinNClusterTPC()                 const { return fCutMinNClusterTPC       ; }</span></a>
<a name="375"><span class="lineNum">     375 </span><span class="lineNoCov">          0 :   Int_t    GetMinNClustersITS()                const { return fCutMinNClusterITS       ; }</span></a>
<a name="376"><span class="lineNum">     376 </span><span class="lineNoCov">          0 :   Float_t  GetMaxChi2PerClusterTPC()           const { return fCutMaxChi2PerClusterTPC ; }</span></a>
<a name="377"><span class="lineNum">     377 </span><span class="lineNoCov">          0 :   Float_t  GetMaxChi2PerClusterITS()           const { return fCutMaxChi2PerClusterITS ; }</span></a>
<a name="378"><span class="lineNum">     378 </span><span class="lineNoCov">          0 :   Bool_t   GetRequireTPCRefit()                const { return fCutRequireTPCRefit      ; }</span></a>
<a name="379"><span class="lineNum">     379 </span><span class="lineNoCov">          0 :   Bool_t   GetRequireITSRefit()                const { return fCutRequireITSRefit      ; }</span></a>
<a name="380"><span class="lineNum">     380 </span><span class="lineNoCov">          0 :   Bool_t   GetAcceptKinkDaughters()            const { return fCutAcceptKinkDaughters  ; }</span></a>
<a name="381"><span class="lineNum">     381 </span><span class="lineNoCov">          0 :   Float_t  GetMaxDCAToVertexXY()               const { return fCutMaxDCAToVertexXY     ; }</span></a>
<a name="382"><span class="lineNum">     382 </span><span class="lineNoCov">          0 :   Float_t  GetMaxDCAToVertexZ()                const { return fCutMaxDCAToVertexZ      ; }</span></a>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :   Bool_t   GetDCAToVertex2D()                  const { return fCutDCAToVertex2D        ; }</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :   Bool_t   GetRequireITSStandAlone()           const { return fCutRequireITSStandAlone ; } //Marcel     </span>
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span>            :   //----------------------------------------------------
<span class="lineNum">     387 </span>            :   // Exotic cells / clusters
<span class="lineNum">     388 </span>            :   //----------------------------------------------------
<a name="389"><span class="lineNum">     389 </span>            :   </a>
<a name="390"><span class="lineNum">     390 </span>            :   Bool_t   IsExoticCell(Int_t absId, AliVCaloCells* cells, Int_t bc =-1) ;</a>
<a name="391"><span class="lineNum">     391 </span><span class="lineNoCov">          0 :   void     SwitchOnRejectExoticCell()                 { fRejectExoticCells = kTRUE     ; }</span></a>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :   void     SwitchOffRejectExoticCell()                { fRejectExoticCells = kFALSE    ; } </span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :   Bool_t   IsRejectExoticCell()                 const { return fRejectExoticCells      ; }</span>
<a name="394"><span class="lineNum">     394 </span>            :   Float_t  GetECross(Int_t absID, Double_t tcell,</a>
<a name="395"><span class="lineNum">     395 </span>            :                      AliVCaloCells* cells, Int_t bc);</a>
<a name="396"><span class="lineNum">     396 </span><span class="lineNoCov">          0 :   Float_t  GetExoticCellFractionCut()           const { return fExoticCellFraction     ; }</span></a>
<a name="397"><span class="lineNum">     397 </span><span class="lineNoCov">          0 :   Float_t  GetExoticCellDiffTimeCut()           const { return fExoticCellDiffTime     ; }</span></a>
<a name="398"><span class="lineNum">     398 </span><span class="lineNoCov">          0 :   Float_t  GetExoticCellMinAmplitudeCut()       const { return fExoticCellMinAmplitude ; }</span></a>
<a name="399"><span class="lineNum">     399 </span><span class="lineNoCov">          0 :   void     SetExoticCellFractionCut(Float_t f)        { fExoticCellFraction     = f    ; }</span></a>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :   void     SetExoticCellDiffTimeCut(Float_t dt)       { fExoticCellDiffTime     = dt   ; }</span>
<a name="401"><span class="lineNum">     401 </span><span class="lineNoCov">          0 :   void     SetExoticCellMinAmplitudeCut(Float_t ma)   { fExoticCellMinAmplitude = ma   ; }</span></a>
<span class="lineNum">     402 </span>            :   Bool_t   IsExoticCluster(const AliVCluster *cluster, AliVCaloCells* cells, Int_t bc=0) ;
<a name="403"><span class="lineNum">     403 </span><span class="lineNoCov">          0 :   void     SwitchOnRejectExoticCluster()              { fRejectExoticCluster = kTRUE   ;</span></a>
<a name="404"><span class="lineNum">     404 </span><span class="lineNoCov">          0 :     fRejectExoticCells   = kTRUE   ; }</span></a>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :   void     SwitchOffRejectExoticCluster()             { fRejectExoticCluster = kFALSE  ; }</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :   Bool_t   IsRejectExoticCluster()              const { return fRejectExoticCluster    ; }</span>
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            :   // Cluster selection
<span class="lineNum">     409 </span>            :   Bool_t   IsGoodCluster(AliVCluster *cluster, const AliEMCALGeometry *geom, 
<span class="lineNum">     410 </span>            :                          AliVCaloCells* cells, Int_t bc =-1);
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span>            : private:  
<span class="lineNum">     413 </span>            :   
<span class="lineNum">     414 </span>            :   // Position recalculation
<span class="lineNum">     415 </span>            :   Float_t    fMisalTransShift[15];       ///&lt; Cluster position translation shift parameters
<span class="lineNum">     416 </span>            :   Float_t    fMisalRotShift[15];         ///&lt; Cluster position rotation shift parameters
<span class="lineNum">     417 </span>            :   Int_t      fParticleType;              ///&lt; Particle type for depth calculation, see enum ParticleType
<span class="lineNum">     418 </span>            :   Int_t      fPosAlgo;                   ///&lt; Position recalculation algorithm, see enum PositionAlgorithms
<span class="lineNum">     419 </span>            :   
<span class="lineNum">     420 </span>            :   Float_t    fW0;                        ///&lt; Energy weight used in cluster position and shower shape calculations
<span class="lineNum">     421 </span>            :     
<span class="lineNum">     422 </span>            :   // Non linearity
<span class="lineNum">     423 </span>            :   Int_t      fNonLinearityFunction;      ///&lt; Non linearity function choice, see enum NonlinearityFunctions
<span class="lineNum">     424 </span>            :   Float_t    fNonLinearityParams[7];     ///&lt; Parameters for the non linearity function
<span class="lineNum">     425 </span>            :   Int_t      fNonLinearThreshold;        ///&lt; Non linearity threshold value for kBeamTest non linearity function 
<span class="lineNum">     426 </span>            :   
<span class="lineNum">     427 </span>            :   // Energy smearing for MC
<span class="lineNum">     428 </span>            :   Bool_t     fSmearClusterEnergy;        ///&lt; Smear cluster energy, to be done only for simulated data to match real data
<span class="lineNum">     429 </span>            :   Float_t    fSmearClusterParam[3];      ///&lt; Energy smearing parameters
<span class="lineNum">     430 </span>            :   TRandom3   fRandom;                    ///&lt; Random generator for cluster energy smearing
<span class="lineNum">     431 </span>            :     
<span class="lineNum">     432 </span>            :   // Energy Recalibration 
<span class="lineNum">     433 </span>            :   Bool_t     fCellsRecalibrated;         ///&lt; Internal bool to check if cells (time/energy) where recalibrated and not recalibrate them when recalculating different things
<span class="lineNum">     434 </span>            :   Bool_t     fRecalibration;             ///&lt; Switch on or off the recalibration
<span class="lineNum">     435 </span>            :   TObjArray* fEMCALRecalibrationFactors; ///&lt; Array of histograms with map of recalibration factors, EMCAL
<span class="lineNum">     436 </span>            :     
<span class="lineNum">     437 </span>            :   // Time Recalibration 
<span class="lineNum">     438 </span>            :   Float_t    fConstantTimeShift;         ///&lt; Apply a 600 ns (+15.8) time shift in case of simulation, shift in ns.
<span class="lineNum">     439 </span>            :   Bool_t     fTimeRecalibration;         ///&lt; Switch on or off the time recalibration
<span class="lineNum">     440 </span>            :   TObjArray* fEMCALTimeRecalibrationFactors;   ///&lt; Array of histograms with map of time recalibration factors, EMCAL
<span class="lineNum">     441 </span>            :   Bool_t     fLowGain;                   ///&lt; Switch on or off calibration with low gain channels
<span class="lineNum">     442 </span>            : 
<span class="lineNum">     443 </span>            :   // Time Recalibration with L1 phase 
<span class="lineNum">     444 </span>            :   Bool_t     fUseL1PhaseInTimeRecalibration;   ///&lt; Switch on or off the L1 phase in time recalibration
<span class="lineNum">     445 </span>            :   TObjArray* fEMCALL1PhaseInTimeRecalibration; ///&lt; Histogram with map of L1 phase per SM, EMCAL
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span>            :   // Recalibrate with run dependent corrections, energy
<span class="lineNum">     448 </span>            :   Bool_t     fUseRunCorrectionFactors;   ///&lt; Use Run Dependent Correction
<span class="lineNum">     449 </span>            :     
<span class="lineNum">     450 </span>            :   // Bad Channels
<span class="lineNum">     451 </span>            :   Bool_t     fRemoveBadChannels;         ///&lt; Check the channel status provided and remove clusters with bad channels
<span class="lineNum">     452 </span>            :   Bool_t     fRecalDistToBadChannels;    ///&lt; Calculate distance from highest energy tower of cluster to closes bad channel
<span class="lineNum">     453 </span>            :   TObjArray* fEMCALBadChannelMap;        ///&lt; Array of histograms with map of bad channels, EMCAL
<span class="lineNum">     454 </span>            : 
<span class="lineNum">     455 </span>            :   // Border cells
<span class="lineNum">     456 </span>            :   Int_t      fNCellsFromEMCALBorder;     ///&lt; Number of cells from EMCAL border the cell with maximum amplitude has to be.
<span class="lineNum">     457 </span>            :   Bool_t     fNoEMCALBorderAtEta0;       ///&lt; Do fiducial cut in EMCAL region eta = 0?
<span class="lineNum">     458 </span>            :   
<span class="lineNum">     459 </span>            :   // Exotic cell / cluster
<span class="lineNum">     460 </span>            :   Bool_t     fRejectExoticCluster;       ///&lt; Switch on or off exotic cluster rejection
<span class="lineNum">     461 </span>            :   Bool_t     fRejectExoticCells;         ///&lt; Remove exotic cells
<span class="lineNum">     462 </span>            :   Float_t    fExoticCellFraction;        ///&lt; Good cell if fraction &lt; 1-ecross/ecell
<span class="lineNum">     463 </span>            :   Float_t    fExoticCellDiffTime;        ///&lt; If time of candidate to exotic and close cell is too different (in ns), it must be noisy, set amp to 0
<span class="lineNum">     464 </span>            :   Float_t    fExoticCellMinAmplitude;    ///&lt; Check for exotic only if amplitud is larger than this value
<span class="lineNum">     465 </span>            :   
<span class="lineNum">     466 </span>            :   // PID
<span class="lineNum">     467 </span>            :   AliEMCALPIDUtils * fPIDUtils;          ///&lt; Recalculate PID parameters
<span class="lineNum">     468 </span>            :     
<span class="lineNum">     469 </span>            :   // Track matching
<span class="lineNum">     470 </span>            :   UInt_t     fAODFilterMask;             ///&lt; Filter mask to select AOD tracks. Refer to $ALICE_ROOT/ANALYSIS/macros/AddTaskESDFilter.C
<span class="lineNum">     471 </span>            :   Bool_t     fAODHybridTracks;           ///&lt; Match with hybrid
<span class="lineNum">     472 </span>            :   Bool_t     fAODTPCOnlyTracks;          ///&lt; Match with TPC only tracks
<span class="lineNum">     473 </span>            :   
<span class="lineNum">     474 </span>            :   TArrayI  * fMatchedTrackIndex;         ///&lt; Array that stores indexes of matched tracks      
<span class="lineNum">     475 </span>            :   TArrayI  * fMatchedClusterIndex;       ///&lt; Array that stores indexes of matched clusters
<span class="lineNum">     476 </span>            :   TArrayF  * fResidualEta;               ///&lt; Array that stores the residual eta
<span class="lineNum">     477 </span>            :   TArrayF  * fResidualPhi;               ///&lt; Array that stores the residual phi
<span class="lineNum">     478 </span>            :   Bool_t     fCutEtaPhiSum;              ///&lt; Place cut on sqrt(dEta^2+dPhi^2)
<span class="lineNum">     479 </span>            :   Bool_t     fCutEtaPhiSeparate;         ///&lt; Cut on dEta and dPhi separately
<span class="lineNum">     480 </span>            :   Float_t    fCutR;                      ///&lt; sqrt(dEta^2+dPhi^2) cut on matching
<span class="lineNum">     481 </span>            :   Float_t    fCutEta;                    ///&lt; dEta cut on matching
<span class="lineNum">     482 </span>            :   Float_t    fCutPhi;                    ///&lt; dPhi cut on matching
<span class="lineNum">     483 </span>            :   Double_t   fClusterWindow;             ///&lt; Select clusters in the window to be matched
<span class="lineNum">     484 </span>            :   Double_t   fMass;                      ///&lt; Mass hypothesis of the track
<span class="lineNum">     485 </span>            :   Double_t   fStepSurface;               ///&lt; Length of step to extrapolate tracks to EMCal surface
<span class="lineNum">     486 </span>            :   Double_t   fStepCluster;               ///&lt; Length of step to extrapolate tracks to clusters
<span class="lineNum">     487 </span>            :   Bool_t     fITSTrackSA;                ///&lt; If track matching is to be done with ITS tracks standing alone 
<span class="lineNum">     488 </span>            :   Double_t   fEMCalSurfaceDistance;      ///&lt; EMCal surface distance (= 430 by default, the last 10 cm are propagated on a cluster-track pair basis)
<span class="lineNum">     489 </span>            :  
<span class="lineNum">     490 </span>            :   // Track cuts  
<span class="lineNum">     491 </span>            :   Int_t      fTrackCutsType;             ///&lt; ESD track cuts type for matching, see enum TrackCutsType
<span class="lineNum">     492 </span>            :   Double_t   fCutMinTrackPt;             ///&lt; Cut on track pT
<span class="lineNum">     493 </span>            :   Int_t      fCutMinNClusterTPC;         ///&lt; Min number of tpc clusters
<span class="lineNum">     494 </span>            :   Int_t      fCutMinNClusterITS;         ///&lt; Min number of its clusters  
<span class="lineNum">     495 </span>            :   Float_t    fCutMaxChi2PerClusterTPC;   ///&lt; Max tpc fit chi2 per tpc cluster
<span class="lineNum">     496 </span>            :   Float_t    fCutMaxChi2PerClusterITS;   ///&lt; Max its fit chi2 per its cluster
<span class="lineNum">     497 </span>            :   Bool_t     fCutRequireTPCRefit;        ///&lt; Require TPC refit
<span class="lineNum">     498 </span>            :   Bool_t     fCutRequireITSRefit;        ///&lt; Require ITS refit
<span class="lineNum">     499 </span>            :   Bool_t     fCutAcceptKinkDaughters;    ///&lt; Accepting kink daughters?
<span class="lineNum">     500 </span>            :   Float_t    fCutMaxDCAToVertexXY;       ///&lt; Track-to-vertex cut in max absolute distance in xy-plane
<span class="lineNum">     501 </span>            :   Float_t    fCutMaxDCAToVertexZ;        ///&lt; Track-to-vertex cut in max absolute distance in z-plane
<span class="lineNum">     502 </span>            :   Bool_t     fCutDCAToVertex2D;          ///&lt; If true a 2D DCA cut is made.
<span class="lineNum">     503 </span>            :   Bool_t     fCutRequireITSStandAlone;   ///&lt; Require ITSStandAlone
<span class="lineNum">     504 </span>            :   Bool_t     fCutRequireITSpureSA;       ///&lt; ITS pure standalone tracks
<a name="505"><span class="lineNum">     505 </span>            :   </a>
<span class="lineNum">     506 </span>            :   /// \cond CLASSIMP
<span class="lineNum">     507 </span><span class="lineCov">         72 :   ClassDef(AliEMCALRecoUtils, 24) ;</span>
<span class="lineNum">     508 </span>            :   /// \endcond
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span>            : };
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span>            : #endif // ALIEMCALRECOUTILS_H
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
