<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - EMCAL/EMCALraw/AliCaloRawAnalyzer.cxx</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">EMCAL/EMCALraw</a> - AliCaloRawAnalyzer.cxx<span style="font-size: 80%;"> (source / <a href="AliCaloRawAnalyzer.cxx.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">95</td>
            <td class="headerCovTableEntry">153</td>
            <td class="headerCovTableEntryLo">62.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">10</td>
            <td class="headerCovTableEntry">16</td>
            <td class="headerCovTableEntryLo">62.5 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // -*- mode: c++ -*-</a>
<span class="lineNum">       2 </span>            : /**************************************************************************
<span class="lineNum">       3 </span>            :  * This file is property of and copyright by                              *
<span class="lineNum">       4 </span>            :  * the Relativistic Heavy Ion Group (RHIG), Yale University, US, 2009     *
<span class="lineNum">       5 </span>            :  *                                                                        *
<span class="lineNum">       6 </span>            :  * Primary Author: Per Thomas Hille &lt;perthomas.hille@yale.edu&gt;            *
<span class="lineNum">       7 </span>            :  *                                                                        *
<span class="lineNum">       8 </span>            :  * Contributors are mentioned in the code where appropriate.              *
<span class="lineNum">       9 </span>            :  * Please report bugs to p.t.hille@fys.uio.no                             *
<span class="lineNum">      10 </span>            :  *                                                                        *
<span class="lineNum">      11 </span>            :  * Permission to use, copy, modify and distribute this software and its   *
<span class="lineNum">      12 </span>            :  * documentation strictly for non-commercial purposes is hereby granted   *
<span class="lineNum">      13 </span>            :  * without fee, provided that the above copyright notice appears in all   *
<span class="lineNum">      14 </span>            :  * copies and that both the copyright notice and this permission notice   *
<span class="lineNum">      15 </span>            :  * appear in the supporting documentation. The authors make no claims     *
<span class="lineNum">      16 </span>            :  * about the suitability of this software for any purpose. It is          *
<span class="lineNum">      17 </span>            :  * provided &quot;as is&quot; without express or implied warranty.                  *
<span class="lineNum">      18 </span>            :  **************************************************************************/
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : // Base class for extraction 
<span class="lineNum">      22 </span>            : // of signal amplitude and peak position
<span class="lineNum">      23 </span>            : // From CALO Calorimeter RAW data (from the RCU)
<span class="lineNum">      24 </span>            : // Contains some utilities for preparing / selecting
<span class="lineNum">      25 </span>            : // Signals suitable for signal extraction
<span class="lineNum">      26 </span>            : // By derived classes
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : #include &quot;AliLog.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;AliCaloRawAnalyzer.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;AliCaloBunchInfo.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;AliCaloFitResults.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;TMath.h&quot;
<span class="lineNum">      33 </span>            : #include &lt;iostream&gt;
<a name="34"><span class="lineNum">      34 </span>            : using namespace std;</a>
<span class="lineNum">      35 </span>            : 
<a name="36"><span class="lineNum">      36 </span><span class="lineCov">         42 : ClassImp(AliCaloRawAnalyzer)  </span></a>
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span><span class="lineCov">         20 : AliCaloRawAnalyzer::AliCaloRawAnalyzer(const char *name, const char *nameshort) :  TObject(),</span>
<span class="lineNum">      39 </span><span class="lineCov">         20 :   fMinTimeIndex(-1),</span>
<span class="lineNum">      40 </span><span class="lineCov">         20 :   fMaxTimeIndex(-1),</span>
<span class="lineNum">      41 </span><span class="lineCov">         20 :   fFitArrayCut(5),</span>
<span class="lineNum">      42 </span><span class="lineCov">         20 :   fAmpCut(4),</span>
<span class="lineNum">      43 </span><span class="lineCov">         20 :   fNsampleCut(5),</span>
<span class="lineNum">      44 </span><span class="lineCov">         20 :   fOverflowCut(950),</span>
<span class="lineNum">      45 </span><span class="lineCov">         20 :   fNsamplePed(3),</span>
<span class="lineNum">      46 </span><span class="lineCov">         20 :   fIsZerosupressed( false ),</span>
<span class="lineNum">      47 </span><span class="lineCov">         20 :   fVerbose( false ),</span>
<span class="lineNum">      48 </span><span class="lineCov">         20 :   fAlgo(Algo::kNONE), </span>
<span class="lineNum">      49 </span><span class="lineCov">         20 :   fL1Phase(0),</span>
<span class="lineNum">      50 </span><span class="lineCov">         20 :   fAmp(0),</span>
<span class="lineNum">      51 </span><span class="lineCov">         20 :   fTof(0),</span>
<span class="lineNum">      52 </span><span class="lineCov">         20 :   fTau( EMCAL::TAU ),</span>
<span class="lineNum">      53 </span><span class="lineCov">         20 :   fFixTau( true )</span>
<span class="lineNum">      54 </span><span class="lineCov">         60 : {</span>
<span class="lineNum">      55 </span>            :   // Ctor
<span class="lineNum">      56 </span>            :   
<span class="lineNum">      57 </span><span class="lineCov">         20 :   snprintf(fName,     256, &quot;%s&quot;, name);</span>
<span class="lineNum">      58 </span><span class="lineCov">         20 :   snprintf(fNameShort,256, &quot;%s&quot;, nameshort);</span>
<span class="lineNum">      59 </span>            :   
<span class="lineNum">      60 </span><span class="lineCov">      40360 :   for(int i=0; i &lt; ALTROMAXSAMPLES; i++ )</span>
<span class="lineNum">      61 </span>            :     {
<span class="lineNum">      62 </span><span class="lineCov">      20160 :       fReversed[i] = 0;</span>
<span class="lineNum">      63 </span>            :     }
<span class="lineNum">      64 </span><span class="lineCov">         20 : }</span>
<span class="lineNum">      65 </span>            : 
<a name="66"><span class="lineNum">      66 </span>            : </a>
<span class="lineNum">      67 </span>            : void 
<span class="lineNum">      68 </span>            : AliCaloRawAnalyzer::SetTimeConstraint(const int min, const int max ) 
<span class="lineNum">      69 </span>            : {
<span class="lineNum">      70 </span>            :   //Require that the bin if the maximum ADC value is between min and max (timebin)
<span class="lineNum">      71 </span>            :   
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :   if(  ( min &gt; max ) || min &gt; ALTROMAXSAMPLES  || max &gt; ALTROMAXSAMPLES  )</span>
<span class="lineNum">      73 </span>            :     {
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :       AliWarning( Form( &quot;Attempt to set Invalid time bin range (Min , Max) = (%d, %d), Ingored&quot;,  min, max ) ); </span>
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">      76 </span>            :   else
<span class="lineNum">      77 </span>            :     {
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :       fMinTimeIndex  = min;</span>
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :       fMaxTimeIndex  = max;</span>
<span class="lineNum">      80 </span>            :     }
<span class="lineNum">      81 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      82 </span>            : 
<a name="83"><span class="lineNum">      83 </span>            : </a>
<span class="lineNum">      84 </span>            : UShort_t 
<span class="lineNum">      85 </span>            : AliCaloRawAnalyzer::Max(const UShort_t *data, const int length ) const
<span class="lineNum">      86 </span>            : {
<span class="lineNum">      87 </span>            :   // Get maximum of array
<span class="lineNum">      88 </span>            :   
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :   UShort_t tmpmax  = data[0];</span>
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :   for(int i=0; i &lt; length; i++)</span>
<span class="lineNum">      92 </span>            :     {
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :       if( tmpmax  &lt;  data[i] )</span>
<span class="lineNum">      94 </span>            :         {
<span class="lineNum">      95 </span>            :           tmpmax = data[i];
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">      97 </span>            :     }
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :   return tmpmax;</span>
<span class="lineNum">      99 </span>            : }
<span class="lineNum">     100 </span>            : 
<a name="101"><span class="lineNum">     101 </span>            : </a>
<span class="lineNum">     102 </span>            : void 
<span class="lineNum">     103 </span>            : AliCaloRawAnalyzer::SelectSubarray( const Double_t *data, int length, short maxindex,
<span class="lineNum">     104 </span>            :                                     int * first, int * last, int cut) const
<span class="lineNum">     105 </span>            : {
<span class="lineNum">     106 </span>            :   //Selection of subset of data from one bunch that will be used for fitting or
<span class="lineNum">     107 </span>            :   //Peak finding.  Go to the left and right of index of the maximum time bin
<span class="lineNum">     108 </span>            :   //Until the ADC value is less that fFitArrayCut, or derivative changes sign (data jump)
<span class="lineNum">     109 </span><span class="lineCov">        116 :   int tmpfirst =  maxindex;</span>
<span class="lineNum">     110 </span>            :   int tmplast  =  maxindex;
<span class="lineNum">     111 </span><span class="lineCov">         58 :   Double_t prevFirst =  data[maxindex];</span>
<span class="lineNum">     112 </span>            :   Double_t prevLast  =  data[maxindex];  
<span class="lineNum">     113 </span>            :   bool firstJump = false;
<span class="lineNum">     114 </span>            :   bool lastJump = false;
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span><span class="lineCov">        651 :   while( (tmpfirst &gt;= 0) &amp;&amp; (data[tmpfirst] &gt;= cut ) &amp;&amp; (!firstJump) ) </span>
<span class="lineNum">     117 </span>            :     {
<span class="lineNum">     118 </span>            :       // jump check:
<span class="lineNum">     119 </span><span class="lineCov">        121 :       if (tmpfirst != maxindex) { // neighbor to maxindex can share peak with maxindex</span>
<span class="lineNum">     120 </span><span class="lineCov">         63 :         if ( data[tmpfirst] &gt;= prevFirst) {</span>
<span class="lineNum">     121 </span>            :           firstJump = true;
<span class="lineNum">     122 </span><span class="lineCov">         15 :         }</span>
<span class="lineNum">     123 </span>            :       }
<span class="lineNum">     124 </span><span class="lineCov">        121 :       prevFirst = data[tmpfirst];</span>
<span class="lineNum">     125 </span><span class="lineCov">        121 :       tmpfirst -- ;</span>
<span class="lineNum">     126 </span>            :     }
<span class="lineNum">     127 </span>            :   
<span class="lineNum">     128 </span><span class="lineCov">       1208 :   while( (tmplast &lt; length) &amp;&amp; (data[tmplast] &gt;=  cut ) &amp;&amp; (!lastJump) ) </span>
<span class="lineNum">     129 </span>            :     {
<span class="lineNum">     130 </span>            :       // jump check:
<span class="lineNum">     131 </span><span class="lineCov">        273 :       if (tmplast != maxindex) { // neighbor to maxindex can share peak with maxindex</span>
<span class="lineNum">     132 </span><span class="lineCov">        215 :         if ( data[tmplast] &gt;= prevLast) {</span>
<span class="lineNum">     133 </span>            :           lastJump = true;
<span class="lineNum">     134 </span><span class="lineCov">          1 :         }</span>
<span class="lineNum">     135 </span>            :       }
<span class="lineNum">     136 </span><span class="lineCov">        273 :       prevLast = data[tmplast];</span>
<span class="lineNum">     137 </span><span class="lineCov">        273 :       tmplast ++;</span>
<span class="lineNum">     138 </span>            :     }
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            :   // we keep one pre- or post- sample if we can (as in online)
<span class="lineNum">     141 </span>            :   // check though if we ended up on a 'jump', or out of bounds: if so, back up
<span class="lineNum">     142 </span><span class="lineCov">         90 :   if (firstJump || tmpfirst&lt;0) tmpfirst ++;</span>
<span class="lineNum">     143 </span><span class="lineCov">        116 :   if (lastJump || tmplast&gt;=length) tmplast --;</span>
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span><span class="lineCov">         58 :   *first = tmpfirst;</span>
<span class="lineNum">     146 </span><span class="lineCov">         58 :   *last =  tmplast;</span>
<span class="lineNum">     147 </span>            :   
<span class="lineNum">     148 </span>            :   return;
<span class="lineNum">     149 </span><span class="lineCov">         58 : }</span>
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            : 
<a name="152"><span class="lineNum">     152 </span>            : </a>
<span class="lineNum">     153 </span>            : Float_t 
<span class="lineNum">     154 </span>            : AliCaloRawAnalyzer::ReverseAndSubtractPed( const AliCaloBunchInfo *bunch,
<span class="lineNum">     155 </span>            :                                            UInt_t /*altrocfg1*/, UInt_t /*altrocfg2*/,
<span class="lineNum">     156 </span>            :                                            double *outarray ) const
<span class="lineNum">     157 </span>            : {
<span class="lineNum">     158 </span>            :   //Time sample comes in reversed order, revers them back
<span class="lineNum">     159 </span>            :   //Subtract the baseline based on content of altrocfg1 and altrocfg2.
<span class="lineNum">     160 </span>            :   
<span class="lineNum">     161 </span><span class="lineCov">        116 :   Int_t length =  bunch-&gt;GetLength(); </span>
<span class="lineNum">     162 </span><span class="lineCov">         58 :   const UShort_t *sig = bunch-&gt;GetData();</span>
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span><span class="lineCov">         58 :   double ped = EvaluatePedestal( sig , length);</span>
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span><span class="lineCov">       1196 :   for( int i=0; i &lt; length; i++ )</span>
<span class="lineNum">     167 </span>            :     {
<span class="lineNum">     168 </span><span class="lineCov">        540 :       outarray[i] = sig[length -i -1] - ped;</span>
<span class="lineNum">     169 </span>            :     }
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span><span class="lineCov">         58 :   return ped;</span>
<span class="lineNum">     172 </span>            : }
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span>            : 
<a name="175"><span class="lineNum">     175 </span>            : </a>
<span class="lineNum">     176 </span>            : Float_t 
<span class="lineNum">     177 </span>            : AliCaloRawAnalyzer::EvaluatePedestal(const UShort_t * data, int /*length*/ ) const
<span class="lineNum">     178 </span>            : {
<span class="lineNum">     179 </span>            :   //  Pedestal evaluation if not zero suppressed
<span class="lineNum">     180 </span>            :   
<span class="lineNum">     181 </span>            :   double tmp = 0;
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span><span class="lineCov">        116 :   if( fIsZerosupressed == false ) </span>
<span class="lineNum">     184 </span>            :     {
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :       for(int i=0; i &lt; fNsamplePed; i++ )</span>
<span class="lineNum">     186 </span>            :         {
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :           tmp += data[i];</span>
<span class="lineNum">     188 </span>            :         }
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :    }</span>
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span><span class="lineCov">         58 :   return  tmp/fNsamplePed;</span>
<span class="lineNum">     192 </span>            :  }
<span class="lineNum">     193 </span>            : 
<a name="194"><span class="lineNum">     194 </span>            : </a>
<span class="lineNum">     195 </span>            : short  
<span class="lineNum">     196 </span>            : AliCaloRawAnalyzer::Max( const AliCaloBunchInfo * bunch , int * maxindex ) const
<span class="lineNum">     197 </span>            : {
<span class="lineNum">     198 </span>            :   // Get maximum in bunch array
<span class="lineNum">     199 </span>            :   
<span class="lineNum">     200 </span>            :   short tmpmax = -1;
<span class="lineNum">     201 </span>            :   int tmpindex = -1;
<span class="lineNum">     202 </span><span class="lineCov">        116 :   const UShort_t *sig = bunch-&gt;GetData();</span>
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span><span class="lineCov">       1196 :   for(int i=0; i &lt; bunch-&gt;GetLength(); i++ )</span>
<span class="lineNum">     205 </span>            :     {
<span class="lineNum">     206 </span><span class="lineCov">        540 :       if( sig[i] &gt; tmpmax )</span>
<span class="lineNum">     207 </span>            :         {
<span class="lineNum">     208 </span>            :           tmpmax   =  sig[i];
<span class="lineNum">     209 </span>            :           tmpindex =  i; 
<span class="lineNum">     210 </span><span class="lineCov">        383 :         }</span>
<span class="lineNum">     211 </span>            :     }
<span class="lineNum">     212 </span>            :   
<span class="lineNum">     213 </span><span class="lineCov">         58 :   if(maxindex != 0 )</span>
<span class="lineNum">     214 </span>            :     {
<span class="lineNum">     215 </span>            :       //   *maxindex =  bunch-&gt;GetLength() -1 - tmpindex + bunch-&gt;GetStartBin(); 
<span class="lineNum">     216 </span><span class="lineCov">         58 :        *maxindex =  bunch-&gt;GetLength() -1 - tmpindex + bunch-&gt;GetStartBin(); </span>
<span class="lineNum">     217 </span><span class="lineCov">         58 :     }</span>
<span class="lineNum">     218 </span>            :   
<span class="lineNum">     219 </span><span class="lineCov">         58 :   return  tmpmax;</span>
<span class="lineNum">     220 </span>            : }
<span class="lineNum">     221 </span>            : 
<a name="222"><span class="lineNum">     222 </span>            : </a>
<span class="lineNum">     223 </span>            : bool  
<span class="lineNum">     224 </span>            : AliCaloRawAnalyzer::CheckBunchEdgesForMax( const AliCaloBunchInfo *const bunch ) const
<span class="lineNum">     225 </span>            : {
<span class="lineNum">     226 </span>            :   // a bunch is considered invalid if the maximum is in the first or last time-bin
<span class="lineNum">     227 </span>            :   short tmpmax = -1;
<span class="lineNum">     228 </span>            :   int tmpindex = -1;
<span class="lineNum">     229 </span><span class="lineCov">        116 :   const UShort_t *sig = bunch-&gt;GetData();</span>
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span><span class="lineCov">       1196 :   for(int i=0; i &lt; bunch-&gt;GetLength(); i++ )</span>
<span class="lineNum">     232 </span>            :     {
<span class="lineNum">     233 </span><span class="lineCov">        540 :       if( sig[i] &gt; tmpmax )</span>
<span class="lineNum">     234 </span>            :         {
<span class="lineNum">     235 </span>            :           tmpmax   =  sig[i];
<span class="lineNum">     236 </span>            :           tmpindex =  i; 
<span class="lineNum">     237 </span><span class="lineCov">        383 :         }</span>
<span class="lineNum">     238 </span>            :     }
<span class="lineNum">     239 </span>            :   
<span class="lineNum">     240 </span>            :   bool bunchOK = true;
<span class="lineNum">     241 </span><span class="lineCov">        116 :   if (tmpindex == 0 || tmpindex == (bunch-&gt;GetLength()-1) )</span>
<span class="lineNum">     242 </span>            :     {
<span class="lineNum">     243 </span>            :       bunchOK = false;
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     245 </span>            :   
<span class="lineNum">     246 </span><span class="lineCov">         58 :   return  bunchOK;</span>
<span class="lineNum">     247 </span>            : }
<span class="lineNum">     248 </span>            : 
<a name="249"><span class="lineNum">     249 </span>            : </a>
<span class="lineNum">     250 </span>            : int 
<span class="lineNum">     251 </span>            : AliCaloRawAnalyzer::SelectBunch( const vector&lt;AliCaloBunchInfo&gt; &amp;bunchvector,
<span class="lineNum">     252 </span>            :                                  short * maxampbin, short * maxamplitude )
<span class="lineNum">     253 </span>            : {
<span class="lineNum">     254 </span>            :   //We select the bunch with the highest amplitude unless any time constraints is set
<span class="lineNum">     255 </span>            :   short max = -1;
<span class="lineNum">     256 </span>            :   short bunchindex = -1;
<span class="lineNum">     257 </span>            :   short maxall = -1;
<span class="lineNum">     258 </span><span class="lineCov">        116 :   int indx = -1;</span>
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span><span class="lineCov">        232 :   for(unsigned int i=0; i &lt; bunchvector.size(); i++ )</span>
<span class="lineNum">     261 </span>            :     {
<span class="lineNum">     262 </span><span class="lineCov">         58 :       max = Max(  &amp;bunchvector.at(i), &amp;indx ); // CRAP PTH, bug fix, trouble if more than one bunches  </span>
<span class="lineNum">     263 </span><span class="lineCov">         58 :       if( IsInTimeRange( indx, fMaxTimeIndex, fMinTimeIndex) )</span>
<span class="lineNum">     264 </span>            :         {
<span class="lineNum">     265 </span><span class="lineCov">         58 :           if( max &gt; maxall )</span>
<span class="lineNum">     266 </span>            :             {
<span class="lineNum">     267 </span>            :               maxall = max;
<span class="lineNum">     268 </span><span class="lineCov">         58 :               bunchindex = i;</span>
<span class="lineNum">     269 </span><span class="lineCov">         58 :               *maxampbin     = indx;</span>
<span class="lineNum">     270 </span><span class="lineCov">         58 :               *maxamplitude  = max;</span>
<span class="lineNum">     271 </span><span class="lineCov">         58 :             }</span>
<span class="lineNum">     272 </span>            :         }
<span class="lineNum">     273 </span>            :     }
<span class="lineNum">     274 </span>            :  
<span class="lineNum">     275 </span><span class="lineCov">         58 :   if (bunchindex &gt;= 0) {</span>
<span class="lineNum">     276 </span><span class="lineCov">         58 :     bool bunchOK = CheckBunchEdgesForMax( &amp;bunchvector.at(bunchindex) );</span>
<span class="lineNum">     277 </span><span class="lineCov">         58 :     if (! bunchOK) { </span>
<span class="lineNum">     278 </span>            :       bunchindex = -1; 
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     280 </span><span class="lineCov">         58 :   }</span>
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span><span class="lineCov">        116 :   return  bunchindex;</span>
<span class="lineNum">     283 </span><span class="lineCov">         58 : }</span>
<span class="lineNum">     284 </span>            : 
<a name="285"><span class="lineNum">     285 </span>            : </a>
<span class="lineNum">     286 </span>            : bool 
<span class="lineNum">     287 </span>            : AliCaloRawAnalyzer::IsInTimeRange( const int maxindex, const int maxtindx, const int mintindx ) const
<span class="lineNum">     288 </span>            : {
<span class="lineNum">     289 </span>            :   // Ckeck if the index of the max ADC vaue is consistent with trigger.
<span class="lineNum">     290 </span><span class="lineCov">        116 :   if( ( mintindx  &lt; 0 &amp;&amp; maxtindx   &lt; 0) ||maxtindx  &lt; 0 )</span>
<span class="lineNum">     291 </span>            :     {
<span class="lineNum">     292 </span><span class="lineCov">         58 :       return true; </span>
<span class="lineNum">     293 </span>            :     }
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :   return ( maxindex &lt; maxtindx ) &amp;&amp; ( maxindex &gt; mintindx  ) ? true : false;</span>
<span class="lineNum">     295 </span><span class="lineCov">         58 : }</span>
<span class="lineNum">     296 </span>            : 
<a name="297"><span class="lineNum">     297 </span>            : </a>
<span class="lineNum">     298 </span>            : void 
<span class="lineNum">     299 </span>            : AliCaloRawAnalyzer::PrintBunches( const vector&lt;AliCaloBunchInfo&gt; &amp;bvctr ) 
<span class="lineNum">     300 </span>            : {
<span class="lineNum">     301 </span>            :   // Print bunch vector info
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :   cout &lt;&lt; __FILE__ &lt;&lt; __LINE__&lt;&lt; &quot;*************** Printing Bunches *******************&quot; &lt;&lt; endl;</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :   cout &lt;&lt; __FILE__ &lt;&lt; __LINE__&lt;&lt; &quot;*** There are &quot; &lt;&lt; bvctr.size() &lt;&lt; &quot;, bunches&quot; &lt;&lt; endl;</span>
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :   for(unsigned int i=0; i &lt; bvctr.size() ; i++ )</span>
<span class="lineNum">     306 </span>            :     {
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :       PrintBunch( bvctr.at(i) );</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :       cout &lt;&lt; &quot; bunch = &quot;  &lt;&lt;  i  &lt;&lt; endl;</span>
<span class="lineNum">     309 </span>            :     }
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :   cout &lt;&lt; __FILE__ &lt;&lt; __LINE__&lt;&lt; &quot;*************** Done ... *******************&quot; &lt;&lt; endl;</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     312 </span>            : 
<a name="313"><span class="lineNum">     313 </span>            : </a>
<span class="lineNum">     314 </span>            : void 
<span class="lineNum">     315 </span>            : AliCaloRawAnalyzer::PrintBunch( const AliCaloBunchInfo &amp;bunch )
<span class="lineNum">     316 </span>            : {
<span class="lineNum">     317 </span>            :   // Print bunch infor
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :   cout &lt;&lt; __FILE__ &lt;&lt; &quot;:&quot; &lt;&lt; __LINE__ &lt;&lt; endl;</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :   cout &lt;&lt; __FILE__ &lt;&lt; __LINE__   &lt;&lt; &quot;, startimebin = &quot; &lt;&lt; bunch.GetStartBin() &lt;&lt; &quot;, length =&quot; &lt;&lt;  bunch.GetLength() &lt;&lt; endl;</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :   const UShort_t *sig =  bunch.GetData();  </span>
<span class="lineNum">     321 </span>            :   
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :   for ( Int_t j = 0; j &lt;  bunch.GetLength();  j++) </span>
<span class="lineNum">     323 </span>            :     {
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :       printf(&quot;%d\t&quot;, sig[j] );</span>
<span class="lineNum">     325 </span>            :     }
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :   cout &lt;&lt; endl; </span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     328 </span>            : 
<a name="329"><span class="lineNum">     329 </span>            : </a>
<span class="lineNum">     330 </span>            : Double_t
<span class="lineNum">     331 </span>            : AliCaloRawAnalyzer::CalculateChi2( Double_t amp,    Double_t time,
<span class="lineNum">     332 </span>            :                                    Int_t    first,  Int_t    last,
<span class="lineNum">     333 </span>            :                                    Double_t adcErr, Double_t tau) const
<span class="lineNum">     334 </span>            : {
<span class="lineNum">     335 </span>            :   //   Input:
<span class="lineNum">     336 </span>            :   //   amp   - max amplitude;
<span class="lineNum">     337 </span>            :   //   time    - time of max amplitude; 
<span class="lineNum">     338 </span>            :   //   first, last - sample array indices to be used
<span class="lineNum">     339 </span>            :   //   adcErr   - nominal error of amplitude measurement (one value for all channels)
<span class="lineNum">     340 </span>            :   //           if adcErr&lt;0 that mean adcErr=1.
<span class="lineNum">     341 </span>            :   //   tau   - filter time response (in timebin units)
<span class="lineNum">     342 </span>            :   // Output:
<span class="lineNum">     343 </span>            :   //   chi2 - chi2
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :   if (first == last || first&lt;0 ) { // signal consists of single sample, chi2 estimate (0) not too well defined.. </span>
<span class="lineNum">     346 </span>            :     // or, first is negative, the indices are not valid
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :     return Ret::kDummy;</span>
<span class="lineNum">     348 </span>            :   }
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :   int nsamples =  last - first + 1;</span>
<span class="lineNum">     351 </span>            :   // printf(&quot; AliCaloRawAnalyzer::CalculateChi2 : first %i last %i : nsamples %i : amp %3.2f time %3.2f \n&quot;, first, last, nsamples, amp, time); 
<span class="lineNum">     352 </span>            : 
<span class="lineNum">     353 </span>            :   Int_t x = 0;
<span class="lineNum">     354 </span>            :   Double_t chi2 = 0;
<span class="lineNum">     355 </span>            :   Double_t dy = 0.0, xx = 0.0, f=0.0;
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;nsamples; i++) {</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :     x     = first + i; // timebin</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :     xx    = (x - time + tau) / tau; // help variable</span>
<span class="lineNum">     360 </span>            :     f     = 0;
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :     if (xx &gt; 0) {</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :       f = amp * xx*xx * TMath::Exp(2 * (1 - xx )) ;</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :     dy    = fReversed[x] - f; </span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :     chi2 += dy*dy;</span>
<span class="lineNum">     366 </span>            :     // printf(&quot; AliCaloRawAnalyzer::CalculateChi2 : %i : y %f -&gt; f %f : dy %f \n&quot;, i, fReversed[first+i], f, dy); 
<span class="lineNum">     367 </span>            :   }
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :   if (adcErr&gt;0.0) { // weight chi2</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :     chi2 /= (adcErr*adcErr);</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     372 </span>            :   return chi2;
<span class="lineNum">     373 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     374 </span>            : 
<a name="375"><span class="lineNum">     375 </span>            : </a>
<span class="lineNum">     376 </span>            : void
<span class="lineNum">     377 </span>            : AliCaloRawAnalyzer::CalculateMeanAndRMS(Int_t first, Int_t last,
<span class="lineNum">     378 </span>            :                                         Double_t &amp; mean, Double_t &amp; rms)
<span class="lineNum">     379 </span>            : {
<span class="lineNum">     380 </span>            :   //   Input:
<span class="lineNum">     381 </span>            :   //   first, last - sample array indices to be used
<span class="lineNum">     382 </span>            :   // Output:
<span class="lineNum">     383 </span>            :   //   mean and RMS of samples 
<span class="lineNum">     384 </span>            :   //
<span class="lineNum">     385 </span>            :   // To possibly be used to differentiate good signals from bad before fitting
<span class="lineNum">     386 </span>            :   // 
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :   mean = Ret::kDummy;</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :   rms =  Ret::kDummy;</span>
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :   if (first == last || first&lt;0 ) { // signal consists of single sample, chi2 estimate (0) not too well defined.. </span>
<span class="lineNum">     391 </span>            :     // or, first is negative, the indices are not valid
<span class="lineNum">     392 </span>            :     return;
<span class="lineNum">     393 </span>            :   }
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :   int nsamples =  last - first + 1;</span>
<span class="lineNum">     396 </span>            :   //  printf(&quot; AliCaloRawAnalyzer::CalculateMeanAndRMS : first %i last %i : nsamples %i \n&quot;, first, last, nsamples); 
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span>            :   int x = 0;
<span class="lineNum">     399 </span>            :   Double_t sampleSum = 0; // sum of samples
<span class="lineNum">     400 </span>            :   Double_t squaredSampleSum = 0; // sum of samples squared
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;nsamples; i++) {</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :     x = first + i;</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :     sampleSum += fReversed[x];</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :     squaredSampleSum += (fReversed[x] * fReversed[x]);</span>
<span class="lineNum">     406 </span>            :   }
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :   mean = sampleSum / nsamples;   </span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :   Double_t squaredMean = squaredSampleSum / nsamples;    </span>
<span class="lineNum">     410 </span>            :   // The variance (rms squared) is equal to the mean of the squares minus the square of the mean..       
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :   rms = sqrt(squaredMean - mean*mean);</span>
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span>            :   return;
<span class="lineNum">     414 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span>            : 
<a name="417"><span class="lineNum">     417 </span>            : </a>
<span class="lineNum">     418 </span>            : int
<span class="lineNum">     419 </span>            : AliCaloRawAnalyzer::PreFitEvaluateSamples( const vector&lt;AliCaloBunchInfo&gt;  &amp;bunchvector,
<span class="lineNum">     420 </span>            :                                           UInt_t altrocfg1, UInt_t altrocfg2, Int_t &amp; index,
<span class="lineNum">     421 </span>            :                                           Float_t &amp; maxf, short &amp; maxamp,
<span class="lineNum">     422 </span>            :                                           short &amp; maxrev, Float_t &amp; ped,
<span class="lineNum">     423 </span>            :                                           int &amp; first, int &amp; last, int acut )
<span class="lineNum">     424 </span>            : {
<span class="lineNum">     425 </span>            :   // method to do the selection of what should possibly be fitted
<span class="lineNum">     426 </span>            :   
<span class="lineNum">     427 </span>            :   int nsamples  = 0;
<span class="lineNum">     428 </span><span class="lineCov">        116 :   short maxampindex = 0;</span>
<span class="lineNum">     429 </span><span class="lineCov">         58 :   index = SelectBunch( bunchvector,  &amp;maxampindex,  &amp;maxamp ); // select the bunch with the highest amplitude unless any time constraints is set</span>
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span>            :   
<span class="lineNum">     432 </span><span class="lineCov">        116 :   if( index &gt;= 0 &amp;&amp; maxamp &gt;= acut ) // something valid was found, and non-zero amplitude</span>
<span class="lineNum">     433 </span>            :     {
<span class="lineNum">     434 </span>            :       // use more convenient numbering and possibly subtract pedestal
<span class="lineNum">     435 </span><span class="lineCov">         58 :       ped  = ReverseAndSubtractPed( &amp;(bunchvector.at(index)),  altrocfg1, altrocfg2, fReversed  );</span>
<span class="lineNum">     436 </span><span class="lineCov">         58 :       maxf = TMath::MaxElement( bunchvector.at(index).GetLength(),  fReversed );</span>
<span class="lineNum">     437 </span>            :       
<span class="lineNum">     438 </span><span class="lineCov">         58 :       if ( maxf &gt;= acut  ) // possibly significant signal</span>
<span class="lineNum">     439 </span>            :         {
<span class="lineNum">     440 </span>            :           // select array around max to possibly be used in fit
<span class="lineNum">     441 </span><span class="lineCov">         58 :           maxrev = maxampindex - bunchvector.at(index).GetStartBin(); </span>
<span class="lineNum">     442 </span><span class="lineCov">         58 :           SelectSubarray( fReversed,  bunchvector.at(index).GetLength(),  maxrev, &amp;first, &amp;last, acut );</span>
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            :           // sanity check: maximum should not be in first or last bin
<span class="lineNum">     445 </span>            :           // if we should do a fit
<span class="lineNum">     446 </span><span class="lineCov">        116 :           if (first!=maxrev &amp;&amp; last!=maxrev) </span>
<span class="lineNum">     447 </span>            :             {
<span class="lineNum">     448 </span>            :               // calculate how many samples we have 
<span class="lineNum">     449 </span><span class="lineCov">         58 :               nsamples =  last - first + 1;       </span>
<span class="lineNum">     450 </span><span class="lineCov">         58 :             }</span>
<span class="lineNum">     451 </span>            :         }
<span class="lineNum">     452 </span>            :     }
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span><span class="lineCov">         58 :   return nsamples;</span>
<span class="lineNum">     455 </span><span class="lineCov">         58 : }</span>
<span class="lineNum">     456 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
