<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - HMPID/HMPIDbase/AliHMPIDCluster.cxx</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">HMPID/HMPIDbase</a> - AliHMPIDCluster.cxx<span style="font-size: 80%;"> (source / <a href="AliHMPIDCluster.cxx.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">181</td>
            <td class="headerCovTableEntry">214</td>
            <td class="headerCovTableEntryMed">84.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">10</td>
            <td class="headerCovTableEntry">12</td>
            <td class="headerCovTableEntryMed">83.3 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : //  **************************************************************************</a>
<span class="lineNum">       2 </span>            : //  * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
<span class="lineNum">       3 </span>            : //  *                                                                        *
<span class="lineNum">       4 </span>            : //  * Author: The ALICE Off-line Project.                                    *
<span class="lineNum">       5 </span>            : //  * Contributors are mentioned in the code where appropriate.              *
<span class="lineNum">       6 </span>            : //  *                                                                        *
<span class="lineNum">       7 </span>            : //  * Permission to use, copy, modify and distribute this software and its   *
<span class="lineNum">       8 </span>            : //  * documentation strictly for non-commercial purposes is hereby granted   *
<span class="lineNum">       9 </span>            : //  * without fee, provided that the above copyright notice appears in all   *
<span class="lineNum">      10 </span>            : //  * copies and that both the copyright notice and this permission notice   *
<span class="lineNum">      11 </span>            : //  * appear in the supporting documentation. The authors make no claims     *
<span class="lineNum">      12 </span>            : //  * about the suitability of this software for any purpose. It is          *
<span class="lineNum">      13 </span>            : //  * provided &quot;as is&quot; without express or implied warranty.                  *
<span class="lineNum">      14 </span>            : //  **************************************************************************
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : #include &quot;AliHMPIDCluster.h&quot;  //class header
<span class="lineNum">      17 </span>            : #include &lt;TVirtualFitter.h&gt;  //Solve()
<span class="lineNum">      18 </span>            : #include &lt;TMinuit.h&gt;         //Solve()
<span class="lineNum">      19 </span>            : #include &lt;TClonesArray.h&gt;    //Solve()
<span class="lineNum">      20 </span>            : #include &lt;TMarker.h&gt;         //Draw()
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : #include &quot;AliLog.h&quot;          //FindCusterSize()
<span class="lineNum">      23 </span>            : 
<a name="24"><span class="lineNum">      24 </span>            : Bool_t AliHMPIDCluster::fgDoCorrSin=kTRUE;</a>
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span><span class="lineCov">         16 : ClassImp(AliHMPIDCluster)</span>
<a name="27"><span class="lineNum">      27 </span>            :     </a>
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : void AliHMPIDCluster::SetClusterParams(Double_t xL,Double_t yL,Int_t iCh  )
<span class="lineNum">      30 </span>            : {
<span class="lineNum">      31 </span>            :   //------------------------------------------------------------------------
<span class="lineNum">      32 </span>            :   //Set the cluster properties for the AliCluster3D part
<span class="lineNum">      33 </span>            :   //------------------------------------------------------------------------
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span><span class="lineCov">       1758 :   fParam = AliHMPIDParam::Instance();</span>
<span class="lineNum">      36 </span>            :     
<span class="lineNum">      37 </span><span class="lineCov">        879 :   if(!fParam-&gt;GetInstType())               //if there is no geometry we cannot retrieve the volId (only for monitoring)</span>
<span class="lineNum">      38 </span>            :   {
<span class="lineNum">      39 </span><span class="lineNoCov">          0 :     new(this) AliCluster3D(); return;</span>
<span class="lineNum">      40 </span>            :   }
<span class="lineNum">      41 </span>            :   
<span class="lineNum">      42 </span>            :   //Get the volume ID from the previously set PNEntry
<span class="lineNum">      43 </span><span class="lineCov">        879 :   UShort_t volId=AliGeomManager::LayerToVolUID(AliGeomManager::kHMPID,iCh);</span>
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            :   
<span class="lineNum">      46 </span>            :   //get L-&gt;T cs matrix for a given chamber
<span class="lineNum">      47 </span><span class="lineCov">        879 :   const TGeoHMatrix *t2l= AliGeomManager::GetTracking2LocalMatrix(volId);</span>
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span><span class="lineCov">        879 :   fParam = AliHMPIDParam::Instance();</span>
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            :   //transformation from the pad cs to local
<span class="lineNum">      52 </span><span class="lineCov">        879 :   xL -= 0.5*fParam-&gt;SizeAllX();      //size of all pads with dead zones included</span>
<span class="lineNum">      53 </span><span class="lineCov">        879 :   yL -= 0.5*fParam-&gt;SizeAllY();</span>
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            :   // Get the position in the tracking cs
<span class="lineNum">      56 </span><span class="lineCov">        879 :   Double_t posL[3]={xL, yL, 0.};            //this is the LORS of HMPID</span>
<span class="lineNum">      57 </span><span class="lineCov">        879 :   Double_t posT[3];</span>
<span class="lineNum">      58 </span><span class="lineCov">        879 :   t2l-&gt;MasterToLocal(posL,posT);</span>
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            :  //Get the cluster covariance matrix in the tracking cs
<span class="lineNum">      61 </span><span class="lineCov">        879 :   Double_t covL[9] = {</span>
<span class="lineNum">      62 </span>            :     0.8*0.8/12., 0.,            0.0,                 //pad size X
<span class="lineNum">      63 </span>            :     0.,          0.84*0.84/12., 0.0,                 //pad size Y
<span class="lineNum">      64 </span>            :     0.,          0.,            0.1,                 //just 1 , no Z dimension ???
<span class="lineNum">      65 </span>            :   };
<span class="lineNum">      66 </span>            :                 
<span class="lineNum">      67 </span><span class="lineCov">        879 :   TGeoHMatrix m;</span>
<span class="lineNum">      68 </span><span class="lineCov">        879 :   m.SetRotation(covL);</span>
<span class="lineNum">      69 </span><span class="lineCov">        879 :   m.Multiply(t2l);</span>
<span class="lineNum">      70 </span><span class="lineCov">       1758 :   m.MultiplyLeft(&amp;t2l-&gt;Inverse());</span>
<span class="lineNum">      71 </span><span class="lineCov">        879 :   Double_t *covT = m.GetRotationMatrix();</span>
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span><span class="lineCov">       2637 :   new(this) AliCluster3D(volId,            // Can be done safer</span>
<span class="lineNum">      74 </span><span class="lineCov">        879 :        posT[0],posT[1],posT[2],</span>
<span class="lineNum">      75 </span><span class="lineCov">        879 :        covT[0],covT[1],covT[2],</span>
<span class="lineNum">      76 </span><span class="lineCov">        879 :                covT[4],covT[5],</span>
<span class="lineNum">      77 </span><span class="lineCov">        879 :                        covT[8], </span>
<span class="lineNum">      78 </span>            :                           0x0);            // No MC labels ?
<a name="79"><span class="lineNum">      79 </span><span class="lineCov">       1758 : }</span></a>
<span class="lineNum">      80 </span>            : //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<span class="lineNum">      81 </span>            : AliHMPIDCluster::~AliHMPIDCluster()
<span class="lineNum">      82 </span><span class="lineCov">       3276 : {</span>
<span class="lineNum">      83 </span><span class="lineCov">       1120 :   if(fDigs)  delete fDigs; fDigs=0;</span>
<span class="lineNum">      84 </span>            :   //PH  if(fParam) delete fParam; fParam=0;
<a name="85"><span class="lineNum">      85 </span><span class="lineCov">       1638 : }</span></a>
<span class="lineNum">      86 </span>            : //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<span class="lineNum">      87 </span>            : void AliHMPIDCluster::CoG()
<span class="lineNum">      88 </span>            : {
<span class="lineNum">      89 </span>            : // Calculates naive cluster position as a center of gravity of its digits.
<span class="lineNum">      90 </span>            : // Arguments: none 
<span class="lineNum">      91 </span>            : //   Returns: none
<span class="lineNum">      92 </span>            :   Int_t minPadX=999,minPadY=999,maxPadX=-1,maxPadY=-1;      //for box finding  
<span class="lineNum">      93 </span><span class="lineCov">        848 :   if(fDigs==0) return;                                      //no digits in this cluster</span>
<span class="lineNum">      94 </span><span class="lineCov">        424 :   fXX=fYY=fQRaw=0;                                          //init summable parameters</span>
<span class="lineNum">      95 </span><span class="lineCov">        424 :   fCh = -1;                                                 //init chamber</span>
<span class="lineNum">      96 </span>            :   Int_t maxQpad=-1,maxQ=-1;                                 //to calculate the pad with the highest charge
<span class="lineNum">      97 </span>            :   AliHMPIDDigit *pDig=0x0;
<span class="lineNum">      98 </span><span class="lineCov">       2672 :   for(Int_t iDig=0;iDig&lt;fDigs-&gt;GetEntriesFast();iDig++){    //digits loop</span>
<span class="lineNum">      99 </span><span class="lineCov">        912 :     pDig=(AliHMPIDDigit*)fDigs-&gt;At(iDig);                   //get pointer to next digit</span>
<span class="lineNum">     100 </span><span class="lineCov">        912 :     if(!pDig) continue;                                     //protection</span>
<span class="lineNum">     101 </span><span class="lineCov">       1568 :     if(pDig-&gt;PadPcX() &gt; maxPadX) maxPadX = pDig-&gt;PadPcX();  // find the minimum box that contain the cluster  MaxX                            </span>
<span class="lineNum">     102 </span><span class="lineCov">       1457 :     if(pDig-&gt;PadPcY() &gt; maxPadY) maxPadY = pDig-&gt;PadPcY();  //                                                MaxY</span>
<span class="lineNum">     103 </span><span class="lineCov">       1336 :     if(pDig-&gt;PadPcX() &lt; minPadX) minPadX = pDig-&gt;PadPcX();  //                                                MinX   </span>
<span class="lineNum">     104 </span><span class="lineCov">       1396 :     if(pDig-&gt;PadPcY() &lt; minPadY) minPadY = pDig-&gt;PadPcY();  //                                                MinY   </span>
<span class="lineNum">     105 </span>            :     
<span class="lineNum">     106 </span><span class="lineCov">        912 :     Float_t q=pDig-&gt;Q();                                    //get QDC </span>
<span class="lineNum">     107 </span><span class="lineCov">        912 :     fXX += pDig-&gt;LorsX()*q;fYY +=pDig-&gt;LorsY()*q;             //add digit center weighted by QDC</span>
<span class="lineNum">     108 </span><span class="lineCov">        912 :     fQRaw+=q;                                               //increment total charge </span>
<span class="lineNum">     109 </span><span class="lineCov">       1482 :     if(q&gt;maxQ) {maxQpad = pDig-&gt;Pad();maxQ=(Int_t)q;}       // to find pad with highest charge</span>
<span class="lineNum">     110 </span><span class="lineCov">        912 :     fCh=pDig-&gt;Ch();                                         //initialize chamber number</span>
<span class="lineNum">     111 </span><span class="lineCov">        912 :   }//digits loop</span>
<span class="lineNum">     112 </span>            :   
<span class="lineNum">     113 </span><span class="lineCov">        424 :   fBox=(maxPadX-minPadX+1)*100+maxPadY-minPadY+1;           // dimension of the box: format Xdim*100+Ydim</span>
<span class="lineNum">     114 </span>            :   
<span class="lineNum">     115 </span><span class="lineCov">        840 :   if ( fQRaw != 0 ) {fXX/=fQRaw;fYY/=fQRaw;}                //final center of gravity</span>
<span class="lineNum">     116 </span>            :    
<span class="lineNum">     117 </span><span class="lineCov">        810 :   if(fDigs-&gt;GetEntriesFast()&gt;1&amp;&amp;fgDoCorrSin)CorrSin();       //correct it by sinoid   </span>
<span class="lineNum">     118 </span>            :   
<span class="lineNum">     119 </span><span class="lineCov">        424 :   fQ  = fQRaw;                                              // Before starting fit procedure, Q and QRaw must be equal</span>
<span class="lineNum">     120 </span><span class="lineCov">        424 :   fMaxQpad = maxQpad; fMaxQ=maxQ;                           //store max charge pad to the field</span>
<span class="lineNum">     121 </span><span class="lineCov">        424 :   fChi2=0;                                                  // no Chi2 to find</span>
<span class="lineNum">     122 </span><span class="lineCov">        424 :   fNlocMax=0;                                               // proper status from this method</span>
<span class="lineNum">     123 </span><span class="lineCov">        424 :   fSt=kCoG;</span>
<span class="lineNum">     124 </span>            :   
<span class="lineNum">     125 </span><span class="lineCov">        424 :   SetClusterParams(fXX,fYY,fCh);                              //need to fill the AliCluster3D part</span>
<span class="lineNum">     126 </span>            :  
<a name="127"><span class="lineNum">     127 </span><span class="lineCov">        848 : }//CoG()</span></a>
<span class="lineNum">     128 </span>            : //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<span class="lineNum">     129 </span>            : void AliHMPIDCluster::CorrSin() 
<span class="lineNum">     130 </span>            : {
<span class="lineNum">     131 </span>            : // Correction of cluster x position due to sinoid, see HMPID TDR  page 30
<span class="lineNum">     132 </span>            : // Arguments: none
<span class="lineNum">     133 </span>            : //   Returns: none
<span class="lineNum">     134 </span><span class="lineCov">        386 :   Int_t pc,px,py;</span>
<span class="lineNum">     135 </span><span class="lineCov">        193 :   fParam-&gt;Lors2Pad(fXX,fYY,pc,px,py);             //tmp digit to get it center</span>
<span class="lineNum">     136 </span><span class="lineCov">        193 :   Float_t x=fXX-fParam-&gt;LorsX(pc,px);                    //diff between cluster x and center of the pad contaning this cluster   </span>
<span class="lineNum">     137 </span><span class="lineCov">        193 :   fXX+=3.31267e-2*TMath::Sin(2*TMath::Pi()/0.8*x)-2.66575e-3*TMath::Sin(4*TMath::Pi()/0.8*x)+2.80553e-3*TMath::Sin(6*TMath::Pi()/0.8*x)+0.0070;</span>
<a name="138"><span class="lineNum">     138 </span><span class="lineCov">        193 : }</span></a>
<span class="lineNum">     139 </span>            : //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<span class="lineNum">     140 </span>            : void AliHMPIDCluster::Draw(Option_t*)
<span class="lineNum">     141 </span>            : {
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :   TMarker *pMark=new TMarker(X(),Y(),5); pMark-&gt;SetUniqueID(fSt);pMark-&gt;SetMarkerColor(kBlue); pMark-&gt;Draw();</span>
<a name="143"><span class="lineNum">     143 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     144 </span>            : //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<span class="lineNum">     145 </span>            : void AliHMPIDCluster::FitFunc(Int_t &amp;iNpars, Double_t* deriv, Double_t &amp;chi2, Double_t *par, Int_t iflag)
<span class="lineNum">     146 </span>            : {
<span class="lineNum">     147 </span>            : // Cluster fit function 
<span class="lineNum">     148 </span>            : // par[0]=x par[1]=y par[2]=q for the first Mathieson shape
<span class="lineNum">     149 </span>            : // par[3]=x par[4]=y par[5]=q for the second Mathieson shape and so on up to iNpars/3 Mathieson shapes
<span class="lineNum">     150 </span>            : // For each pad of the cluster calculates the difference between actual pad charge and the charge induced to this pad by all Mathieson distributions
<span class="lineNum">     151 </span>            : // Then the chi2 is calculated as the sum of this value squared for all pad in the cluster.  
<span class="lineNum">     152 </span>            : // Arguments: iNpars - number of parameters which is number of local maxima of cluster * 3
<span class="lineNum">     153 </span>            : //            chi2   - function result to be minimised 
<span class="lineNum">     154 </span>            : //            par   - parameters array of size iNpars            
<span class="lineNum">     155 </span>            : //   Returns: none  
<span class="lineNum">     156 </span>            :   
<span class="lineNum">     157 </span><span class="lineCov">      52190 :   AliHMPIDCluster *pClu=(AliHMPIDCluster*)TVirtualFitter::GetFitter()-&gt;GetObjectFit();</span>
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span><span class="lineCov">      26095 :   Int_t nPads = pClu-&gt;Size();  </span>
<span class="lineNum">     160 </span>            :   
<span class="lineNum">     161 </span><span class="lineCov">      26095 :   chi2 = 0;</span>
<span class="lineNum">     162 </span>            :   
<span class="lineNum">     163 </span><span class="lineCov">      26095 :   Int_t iNshape = iNpars/3;</span>
<span class="lineNum">     164 </span>            :   
<span class="lineNum">     165 </span><span class="lineCov">     266766 :   for(Int_t i=0;i&lt;nPads;i++){                                                          //loop on all pads of the cluster</span>
<span class="lineNum">     166 </span>            :     Double_t dQpadMath = 0;
<span class="lineNum">     167 </span><span class="lineCov">     706936 :     for(Int_t j=0;j&lt;iNshape;j++){                                                      //Mathiesons loop as all of them may contribute to this pad</span>
<span class="lineNum">     168 </span><span class="lineCov">     246180 :       Double_t fracMathi = pClu-&gt;Dig(i)-&gt;IntMathieson(par[3*j],par[3*j+1]);</span>
<span class="lineNum">     169 </span><span class="lineCov">     246180 :       dQpadMath+=par[3*j+2]*fracMathi;                                                 // par[3*j+2] is charge par[3*j] is x par[3*j+1] is y of current Mathieson</span>
<span class="lineNum">     170 </span>            :     }
<span class="lineNum">     171 </span><span class="lineCov">     214576 :     if(dQpadMath&gt;0 &amp;&amp; pClu-&gt;Dig(i)-&gt;Q()&gt;0) {</span>
<span class="lineNum">     172 </span><span class="lineCov">     107288 :       chi2 +=TMath::Power((pClu-&gt;Dig(i)-&gt;Q()-dQpadMath),2)/pClu-&gt;Dig(i)-&gt;Q();          //chi2 function to be minimized</span>
<span class="lineNum">     173 </span><span class="lineCov">     107288 :     }</span>
<span class="lineNum">     174 </span>            :   }
<span class="lineNum">     175 </span>            : //---calculate gradients...  
<span class="lineNum">     176 </span><span class="lineCov">      26095 :   if(iflag==2) {</span>
<span class="lineNum">     177 </span>            :     Double_t **derivPart;
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span><span class="lineCov">        661 :     derivPart = new Double_t*[iNpars];</span>
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span><span class="lineCov">      10190 :     for(Int_t j=0;j&lt;iNpars;j++){                                                      </span>
<span class="lineNum">     182 </span><span class="lineCov">       4434 :       deriv[j] = 0;</span>
<span class="lineNum">     183 </span><span class="lineCov">       4434 :       derivPart[j] = new Double_t[nPads];</span>
<span class="lineNum">     184 </span><span class="lineCov">      41454 :       for(Int_t i=0;i&lt;nPads;i++){                                                          </span>
<span class="lineNum">     185 </span><span class="lineCov">      16293 :         derivPart[j][i] = 0;</span>
<span class="lineNum">     186 </span>            :       }
<span class="lineNum">     187 </span>            :     }
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span><span class="lineCov">       6046 :     for(Int_t i=0;i&lt;nPads;i++){                                                          //loop on all pads of the cluster</span>
<span class="lineNum">     190 </span><span class="lineCov">      15586 :       for(Int_t j=0;j&lt;iNshape;j++){                                                      //Mathiesons loop as all of them may contribute to this pad</span>
<span class="lineNum">     191 </span><span class="lineCov">       5431 :         Double_t fracMathi = pClu-&gt;Dig(i)-&gt;IntMathieson(par[3*j],par[3*j+1]);</span>
<span class="lineNum">     192 </span><span class="lineCov">      16293 :         derivPart[3*j  ][i] += par[3*j+2]*(pClu-&gt;Dig(i)-&gt;MathiesonX(par[3*j]-pClu-&gt;Dig(i)-&gt;LorsX()-0.5*AliHMPIDParam::SizePadX())-</span>
<span class="lineNum">     193 </span><span class="lineCov">      10862 :                                            pClu-&gt;Dig(i)-&gt;MathiesonX(par[3*j]-pClu-&gt;Dig(i)-&gt;LorsX()+0.5*AliHMPIDParam::SizePadX()))*</span>
<span class="lineNum">     194 </span><span class="lineCov">       5431 :                                            pClu-&gt;Dig(i)-&gt;IntPartMathiY(par[3*j+1]);</span>
<span class="lineNum">     195 </span><span class="lineCov">      16293 :         derivPart[3*j+1][i] += par[3*j+2]*(pClu-&gt;Dig(i)-&gt;MathiesonY(par[3*j+1]-pClu-&gt;Dig(i)-&gt;LorsY()-0.5*AliHMPIDParam::SizePadY())-</span>
<span class="lineNum">     196 </span><span class="lineCov">      10862 :                                            pClu-&gt;Dig(i)-&gt;MathiesonY(par[3*j+1]-pClu-&gt;Dig(i)-&gt;LorsY()+0.5*AliHMPIDParam::SizePadY()))*</span>
<span class="lineNum">     197 </span><span class="lineCov">       5431 :                                            pClu-&gt;Dig(i)-&gt;IntPartMathiX(par[3*j]);</span>
<span class="lineNum">     198 </span><span class="lineCov">       5431 :         derivPart[3*j+2][i] += fracMathi;</span>
<span class="lineNum">     199 </span>            :       }
<span class="lineNum">     200 </span>            :     }
<span class="lineNum">     201 </span>            :                                                                                          //loop on all pads of the cluster     
<span class="lineNum">     202 </span><span class="lineCov">       6046 :     for(Int_t i=0;i&lt;nPads;i++){                                                          //loop on all pads of the cluster</span>
<span class="lineNum">     203 </span>            :       Double_t dQpadMath = 0;                                                            //pad charge collector  
<span class="lineNum">     204 </span><span class="lineCov">      15586 :       for(Int_t j=0;j&lt;iNshape;j++){                                                      //Mathiesons loop as all of them may contribute to this pad</span>
<span class="lineNum">     205 </span><span class="lineCov">       5431 :         Double_t fracMathi = pClu-&gt;Dig(i)-&gt;IntMathieson(par[3*j],par[3*j+1]);</span>
<span class="lineNum">     206 </span><span class="lineCov">       5431 :         dQpadMath+=par[3*j+2]*fracMathi;                                                 </span>
<span class="lineNum">     207 </span><span class="lineCov">      10862 :         if(dQpadMath&gt;0 &amp;&amp; pClu-&gt;Dig(i)-&gt;Q()&gt;0) {</span>
<span class="lineNum">     208 </span><span class="lineCov">       5431 :           deriv[3*j]   += 2/pClu-&gt;Dig(i)-&gt;Q()*(pClu-&gt;Dig(i)-&gt;Q()-dQpadMath)*derivPart[3*j  ][i];</span>
<span class="lineNum">     209 </span><span class="lineCov">       5431 :           deriv[3*j+1] += 2/pClu-&gt;Dig(i)-&gt;Q()*(pClu-&gt;Dig(i)-&gt;Q()-dQpadMath)*derivPart[3*j+1][i];</span>
<span class="lineNum">     210 </span><span class="lineCov">       5431 :           deriv[3*j+2] += 2/pClu-&gt;Dig(i)-&gt;Q()*(pClu-&gt;Dig(i)-&gt;Q()-dQpadMath)*derivPart[3*j+2][i];</span>
<span class="lineNum">     211 </span><span class="lineCov">       5431 :         }</span>
<span class="lineNum">     212 </span>            :       }
<span class="lineNum">     213 </span>            :     }
<span class="lineNum">     214 </span>            :     //delete array...
<span class="lineNum">     215 </span><span class="lineCov">      20380 :     for(Int_t i=0;i&lt;iNpars;i++) delete [] derivPart[i]; delete [] derivPart;</span>
<span class="lineNum">     216 </span><span class="lineCov">        661 :   }</span>
<span class="lineNum">     217 </span>            : //---gradient calculations ended
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            : // fit ended. Final calculations
<span class="lineNum">     220 </span>            :   
<span class="lineNum">     221 </span>            :   
<a name="222"><span class="lineNum">     222 </span><span class="lineCov">      26095 : }//FitFunction()</span></a>
<span class="lineNum">     223 </span>            : //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<span class="lineNum">     224 </span>            : void AliHMPIDCluster::Print(Option_t* opt)const
<span class="lineNum">     225 </span>            : {
<span class="lineNum">     226 </span>            : //Print current cluster  
<span class="lineNum">     227 </span>            :   const char *status=0;
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :   switch(fSt){</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :     case        kFrm  : status=&quot;formed        &quot;   ;break;</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     case        kUnf  : status=&quot;unfolded (fit)&quot;   ;break;</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :     case        kCoG  : status=&quot;coged         &quot;   ;break;</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :     case        kLo1  : status=&quot;locmax 1 (fit)&quot;   ;break;</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :     case        kMax  : status=&quot;exceeded (cog)&quot;   ;break;</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :     case        kNot  : status=&quot;not done (cog)&quot;   ;break;</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :     case        kEmp  : status=&quot;empty         &quot;   ;break;</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :     case        kEdg  : status=&quot;edge     (fit)&quot;   ;break;</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :     case        kSi1  : status=&quot;size 1   (cog)&quot;   ;break;</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :     case        kNoLoc: status=&quot;no LocMax(fit)&quot;   ;break;</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :     case        kAbn  : status=&quot;Abnormal fit  &quot;   ;break;</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :     case        kBig  : status=&quot;Big Clu(&gt;100) &quot;   ;break;</span>
<span class="lineNum">     241 </span>            :     
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :     default:            status=&quot;??????&quot;          ;break;   </span>
<span class="lineNum">     243 </span>            :   }
<span class="lineNum">     244 </span>            :   Double_t ratio=0;
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :   if(Q()&gt;0&amp;&amp;QRaw()&gt;0) ratio = Q()/QRaw()*100;</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :   Printf(&quot;%sCLU: ch=%i  (%7.3f,%7.3f) Q=%8.3f Qraw=%8.3f(%3.0f%%) Size=%2i DimBox=%i LocMax=%i Chi2=%7.3f   %s&quot;,</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :          opt,Ch(),X(),Y(),Q(),QRaw(),ratio,Size(),fBox,fNlocMax,fChi2,status);</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :   if(fDigs) fDigs-&gt;Print();    </span>
<a name="249"><span class="lineNum">     249 </span><span class="lineNoCov">          0 : }//Print()</span></a>
<span class="lineNum">     250 </span>            : //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<span class="lineNum">     251 </span>            : Int_t AliHMPIDCluster::Solve(TClonesArray *pCluLst,Int_t *pSigmaCut, Bool_t isTryUnfold)
<span class="lineNum">     252 </span>            : {
<span class="lineNum">     253 </span>            : //This methode is invoked when the cluster is formed to solve it. Solve the cluster means to try to unfold the cluster
<span class="lineNum">     254 </span>            : //into the local maxima number of clusters. This methode is invoked by AliHMPIDRconstructor::Dig2Clu() on cluster by cluster basis.  
<span class="lineNum">     255 </span>            : //At this point, cluster contains a list of digits, cluster charge and size is precalculated in AddDigit(), position is preset to (-1,-1) in ctor,
<span class="lineNum">     256 </span>            : //status is preset to kFormed in AddDigit(), chamber-sector info is preseted to actual values in AddDigit()
<span class="lineNum">     257 </span>            : //Method first finds number of local maxima and if it's more then one tries to unfold this cluster into local maxima number of clusters
<span class="lineNum">     258 </span>            : //Arguments: pCluLst     - cluster list pointer where to add new cluster(s)
<span class="lineNum">     259 </span>            : //           isTryUnfold - flag to switch on/off unfolding   
<span class="lineNum">     260 </span>            : //  Returns: number of local maxima of original cluster
<span class="lineNum">     261 </span>            :   const Int_t kMaxLocMax=6;                                                              //max allowed number of loc max for fitting
<span class="lineNum">     262 </span>            : //  
<span class="lineNum">     263 </span><span class="lineCov">        424 :   CoG();                                                                                 //First calculate CoG for the given cluster</span>
<span class="lineNum">     264 </span>            :   
<span class="lineNum">     265 </span><span class="lineCov">        424 :   Int_t iCluCnt=pCluLst-&gt;GetEntriesFast();                                               //get current number of clusters already stored in the list by previous operations</span>
<span class="lineNum">     266 </span>            :   
<span class="lineNum">     267 </span><span class="lineCov">        424 :   Int_t rawSize = Size();                                                                //get current raw cluster size</span>
<span class="lineNum">     268 </span>            :   
<span class="lineNum">     269 </span><span class="lineCov">        424 :   if(rawSize&gt;100) {</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :     fSt = kBig;</span>
<span class="lineNum">     271 </span><span class="lineCov">        424 :   } else if(isTryUnfold==kFALSE) {</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :     fSt = kNot;</span>
<span class="lineNum">     273 </span><span class="lineCov">        424 :   } else if(rawSize==1) {</span>
<span class="lineNum">     274 </span><span class="lineCov">        231 :     fSt = kSi1;</span>
<span class="lineNum">     275 </span><span class="lineCov">        231 :   }</span>
<span class="lineNum">     276 </span>            :   
<span class="lineNum">     277 </span><span class="lineCov">        848 :   if(rawSize&gt;100 || isTryUnfold==kFALSE || rawSize==1) {                                 //No deconv if: 1 - big cluster (also avoid no zero suppression!)</span>
<span class="lineNum">     278 </span>            :                                                                                          //              2 - flag is set to FALSE
<span class="lineNum">     279 </span><span class="lineCov">        231 :     SetClusterParams(fXX,fYY,fCh);                                                       //              3 - size = 1</span>
<span class="lineNum">     280 </span><span class="lineCov">        231 :     new ((*pCluLst)[iCluCnt++]) AliHMPIDCluster(*this);  //add this raw cluster </span>
<span class="lineNum">     281 </span><span class="lineCov">        231 :     return 1;</span>
<span class="lineNum">     282 </span>            :     
<span class="lineNum">     283 </span>            :   } 
<span class="lineNum">     284 </span>            :   
<span class="lineNum">     285 </span>            : //Phase 0. Initialise Fitter  
<span class="lineNum">     286 </span><span class="lineCov">        193 :   Double_t arglist[10];</span>
<span class="lineNum">     287 </span>            :   Int_t ierflg = 0;
<span class="lineNum">     288 </span><span class="lineCov">        193 :   TVirtualFitter* fitter = TVirtualFitter::Fitter(this,3*6);                       //initialize Fitter</span>
<span class="lineNum">     289 </span>            :   //
<span class="lineNum">     290 </span><span class="lineCov">        193 :   arglist[0] = -1;</span>
<span class="lineNum">     291 </span><span class="lineCov">        193 :   ierflg = fitter-&gt;ExecuteCommand(&quot;SET PRI&quot;, arglist, 1);                               // no printout</span>
<span class="lineNum">     292 </span><span class="lineCov">        193 :   ierflg = fitter-&gt;ExecuteCommand(&quot;SET NOW&quot;, arglist, 0);                               //no warning messages</span>
<span class="lineNum">     293 </span><span class="lineCov">        193 :   arglist[0] =  1;</span>
<span class="lineNum">     294 </span><span class="lineCov">        193 :   ierflg = fitter-&gt;ExecuteCommand(&quot;SET GRA&quot;, arglist, 1);                               //force Fitter to use my gradient</span>
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span><span class="lineCov">        193 :   fitter-&gt;SetFCN(AliHMPIDCluster::FitFunc);</span>
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            : //  arglist[0] = 1;
<span class="lineNum">     299 </span>            : //  ierflg = fitter-&gt;ExecuteCommand(&quot;SET ERR&quot;, arglist ,1);
<span class="lineNum">     300 </span>            :   
<span class="lineNum">     301 </span>            : // Set starting values and step sizes for parameters
<span class="lineNum">     302 </span>            :     
<span class="lineNum">     303 </span>            : //Phase 1. Find number of local maxima. Strategy is to check if the current pad has QDC more then all neigbours. Also find the box contaning the cluster   
<span class="lineNum">     304 </span><span class="lineCov">        193 :   fNlocMax=0;</span>
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span><span class="lineCov">       1748 :   for(Int_t iDig1=0;iDig1&lt;rawSize;iDig1++) {                                               //first digits loop</span>
<span class="lineNum">     307 </span>            :     
<span class="lineNum">     308 </span><span class="lineCov">        681 :     AliHMPIDDigit *pDig1 = Dig(iDig1);                                                   //take next digit    </span>
<span class="lineNum">     309 </span>            :     Int_t iCnt = 0;                                                                      //counts how many neighbouring pads has QDC more then current one
<span class="lineNum">     310 </span>            :     
<span class="lineNum">     311 </span><span class="lineCov">       7644 :     for(Int_t iDig2=0;iDig2&lt;rawSize;iDig2++) {                                            //loop on all digits again</span>
<span class="lineNum">     312 </span>            :       
<span class="lineNum">     313 </span><span class="lineCov">       3141 :       if(iDig1==iDig2) continue;                                                         //the same digit, no need to compare </span>
<span class="lineNum">     314 </span><span class="lineCov">       2460 :       AliHMPIDDigit *pDig2 = Dig(iDig2);                                                 //take second digit to compare with the first one</span>
<span class="lineNum">     315 </span><span class="lineCov">       2460 :       Int_t dist = TMath::Sign(Int_t(pDig1-&gt;PadChX()-pDig2-&gt;PadChX()),1)+TMath::Sign(Int_t(pDig1-&gt;PadChY()-pDig2-&gt;PadChY()),1);//distance between pads</span>
<span class="lineNum">     316 </span><span class="lineCov">       2460 :       if(dist==1)                                                                        //means dig2 is a neighbour of dig1</span>
<span class="lineNum">     317 </span><span class="lineCov">       1679 :          if(pDig2-&gt;Q()&gt;=pDig1-&gt;Q()) iCnt++;                                              //count number of pads with Q more then Q of current pad</span>
<span class="lineNum">     318 </span>            :       
<span class="lineNum">     319 </span><span class="lineCov">       2460 :     }//second digits loop</span>
<span class="lineNum">     320 </span>            :     
<span class="lineNum">     321 </span><span class="lineCov">        901 :     if(iCnt==0&amp;&amp;fNlocMax&lt;kMaxLocMax){                                                    //this pad has Q more then any neighbour so it's local maximum</span>
<span class="lineNum">     322 </span>            :       
<span class="lineNum">     323 </span><span class="lineCov">        220 :       Double_t xStart=pDig1-&gt;LorsX();Double_t yStart=pDig1-&gt;LorsY();</span>
<span class="lineNum">     324 </span><span class="lineCov">        220 :       Double_t xMin=xStart-fParam-&gt;SizePadX();</span>
<span class="lineNum">     325 </span><span class="lineCov">        220 :       Double_t xMax=xStart+fParam-&gt;SizePadX();</span>
<span class="lineNum">     326 </span><span class="lineCov">        220 :       Double_t yMin=yStart-fParam-&gt;SizePadY();</span>
<span class="lineNum">     327 </span><span class="lineCov">        220 :       Double_t yMax=yStart+fParam-&gt;SizePadY();</span>
<span class="lineNum">     328 </span>            :       
<span class="lineNum">     329 </span><span class="lineCov">        220 :       ierflg = fitter-&gt;SetParameter(3*fNlocMax  ,Form(&quot;x%i&quot;,fNlocMax),xStart,0.1,xMin,xMax);    // X,Y,Q initial values of the loc max pad</span>
<span class="lineNum">     330 </span><span class="lineCov">        220 :       ierflg = fitter-&gt;SetParameter(3*fNlocMax+1,Form(&quot;y%i&quot;,fNlocMax),yStart,0.1,yMin,yMax);    // X, Y constrained to be near the loc max</span>
<span class="lineNum">     331 </span><span class="lineCov">        220 :       ierflg = fitter-&gt;SetParameter(3*fNlocMax+2,Form(&quot;q%i&quot;,fNlocMax),pDig1-&gt;Q(),0.1,0,10000);  // Q constrained to be positive</span>
<span class="lineNum">     332 </span>            :       
<span class="lineNum">     333 </span><span class="lineCov">        220 :       fNlocMax++;</span>
<span class="lineNum">     334 </span>            :       
<span class="lineNum">     335 </span><span class="lineCov">        220 :     }//if this pad is local maximum</span>
<span class="lineNum">     336 </span>            :   }//first digits loop
<span class="lineNum">     337 </span>            :   
<span class="lineNum">     338 </span>            : //Phase 2. Fit loc max number of Mathiesons or add this current cluster to the list
<span class="lineNum">     339 </span>            : // case 1 -&gt; no loc max found
<span class="lineNum">     340 </span><span class="lineCov">        193 :  if ( fNlocMax == 0) {                                                                       // case of no local maxima found: pads with same charge...</span>
<span class="lineNum">     341 </span><span class="lineCov">          4 :    fNlocMax = 1;</span>
<span class="lineNum">     342 </span><span class="lineCov">          4 :    fSt=kNoLoc;</span>
<span class="lineNum">     343 </span><span class="lineCov">          4 :    SetClusterParams(fXX,fYY,fCh);                                                          //need to fill the AliCluster3D part</span>
<span class="lineNum">     344 </span><span class="lineCov">          4 :    new ((*pCluLst)[iCluCnt++]) AliHMPIDCluster(*this);                                     //add new unfolded cluster</span>
<span class="lineNum">     345 </span><span class="lineCov">          4 :    return fNlocMax;</span>
<span class="lineNum">     346 </span>            :  }
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span>            : // case 2 -&gt; loc max found. Check # of loc maxima 
<span class="lineNum">     349 </span><span class="lineCov">        189 :  if ( fNlocMax &gt;= kMaxLocMax)  { </span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :    SetClusterParams(fXX,fYY,fCh);                                                           // if # of local maxima exceeds kMaxLocMax...</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :    fSt = kMax;   new ((*pCluLst)[iCluCnt++]) AliHMPIDCluster(*this);                      //...add this raw cluster  </span>
<span class="lineNum">     352 </span>            :  } else {                                                                               //or resonable number of local maxima to fit and user requested it
<span class="lineNum">     353 </span>            :   // Now ready for minimization step
<span class="lineNum">     354 </span><span class="lineCov">        189 :    arglist[0] = 500;                                                                      //number of steps and sigma on pads charges</span>
<span class="lineNum">     355 </span><span class="lineCov">        189 :    arglist[1] = 1.;                                                                       //</span>
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span><span class="lineCov">        189 :    ierflg = fitter-&gt;ExecuteCommand(&quot;SIMPLEX&quot;,arglist,2);                                  //start fitting with Simplex</span>
<span class="lineNum">     358 </span><span class="lineCov">        189 :    if (!ierflg)</span>
<span class="lineNum">     359 </span><span class="lineCov">        189 :      fitter-&gt;ExecuteCommand(&quot;MIGRAD&quot; ,arglist,2);                                         //fitting improved by Migrad</span>
<span class="lineNum">     360 </span><span class="lineCov">        189 :    if(ierflg) {</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :      Double_t strategy=2;</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :      ierflg = fitter-&gt;ExecuteCommand(&quot;SET STR&quot;,&amp;strategy,1);                              //change level of strategy </span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :      if(!ierflg) {</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :        ierflg = fitter-&gt;ExecuteCommand(&quot;SIMPLEX&quot;,arglist,2);                              //start fitting with Simplex</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :        if (!ierflg)</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :          fitter-&gt;ExecuteCommand(&quot;MIGRAD&quot; ,arglist,2);                                     //fitting improved by Migrad</span>
<span class="lineNum">     367 </span>            :      }
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :    }        </span>
<span class="lineNum">     369 </span><span class="lineCov">        189 :    if(ierflg) fSt=kAbn;                                                                   //no convergence of the fit...</span>
<span class="lineNum">     370 </span><span class="lineCov">        189 :    Double_t dummy; char sName[80];                                                        //vars to get results from Minuit</span>
<span class="lineNum">     371 </span><span class="lineCov">        189 :    Double_t edm, errdef;</span>
<span class="lineNum">     372 </span><span class="lineCov">        189 :    Int_t nvpar, nparx;</span>
<span class="lineNum">     373 </span>            :    
<span class="lineNum">     374 </span><span class="lineCov">        818 :    for(Int_t i=0;i&lt;fNlocMax;i++){                                                        //store the local maxima parameters</span>
<span class="lineNum">     375 </span><span class="lineCov">        220 :      fitter-&gt;GetParameter(3*i   ,sName,  fXX, fErrX , dummy, dummy);                     // X</span>
<span class="lineNum">     376 </span><span class="lineCov">        220 :      fitter-&gt;GetParameter(3*i+1 ,sName,  fYY, fErrY , dummy, dummy);                     // Y</span>
<span class="lineNum">     377 </span><span class="lineCov">        220 :      fitter-&gt;GetParameter(3*i+2 ,sName,  fQ, fErrQ , dummy, dummy);                      // Q</span>
<span class="lineNum">     378 </span><span class="lineCov">        220 :      fitter-&gt;GetStats(fChi2, edm, errdef, nvpar, nparx);                                 //get fit infos</span>
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span><span class="lineCov">        279 :      if(fNlocMax&gt;1)FindClusterSize(i,pSigmaCut);                                         //find clustersize for deconvoluted clusters</span>
<span class="lineNum">     381 </span>            :                                                                                          //after this call, fSi temporarly is the calculated size. Later is set again 
<span class="lineNum">     382 </span>            :                                                                                          //to its original value
<span class="lineNum">     383 </span><span class="lineCov">        220 :      if(fSt!=kAbn) {         </span>
<span class="lineNum">     384 </span><span class="lineCov">        279 :       if(fNlocMax!=1)fSt=kUnf;                                                           // if unfolded</span>
<span class="lineNum">     385 </span><span class="lineCov">        542 :       if(fNlocMax==1&amp;&amp;fSt!=kNoLoc) fSt=kLo1;                                             // if only 1 loc max</span>
<span class="lineNum">     386 </span><span class="lineCov">        220 :       if ( !IsInPc()) fSt = kEdg;                                                        // if Out of Pc</span>
<span class="lineNum">     387 </span><span class="lineCov">        220 :       if(fSt==kNoLoc) fNlocMax=0;                                                        // if with no loc max (pads with same charge..)</span>
<span class="lineNum">     388 </span>            :      }
<span class="lineNum">     389 </span><span class="lineCov">        220 :      SetClusterParams(fXX,fYY,fCh);                                                      //need to fill the AliCluster3D part</span>
<span class="lineNum">     390 </span><span class="lineCov">        220 :      new ((*pCluLst)[iCluCnt++]) AliHMPIDCluster(*this);                                 //add new unfolded cluster</span>
<span class="lineNum">     391 </span><span class="lineCov">        279 :      if(fNlocMax&gt;1)SetSize(rawSize);                                                     //Original raw size is set again to its proper value</span>
<span class="lineNum">     392 </span>            :    }
<span class="lineNum">     393 </span><span class="lineCov">        189 :  }</span>
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span><span class="lineCov">        189 :  return fNlocMax;</span>
<span class="lineNum">     396 </span>            :  
<a name="397"><span class="lineNum">     397 </span><span class="lineCov">        617 : }//Solve()</span></a>
<span class="lineNum">     398 </span>            : //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<span class="lineNum">     399 </span>            : void AliHMPIDCluster::FindClusterSize(Int_t i,Int_t *pSigmaCut)
<span class="lineNum">     400 </span>            : {
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            : //Estimate of the clustersize for a deconvoluted cluster
<span class="lineNum">     403 </span>            :   Int_t size = 0;
<span class="lineNum">     404 </span><span class="lineCov">        975 :   for(Int_t iDig=0;iDig&lt;Size();iDig++) {                                               //digits loop</span>
<span class="lineNum">     405 </span><span class="lineCov">        399 :     AliHMPIDDigit *pDig = Dig(iDig);                                                   //take digit</span>
<span class="lineNum">     406 </span><span class="lineCov">        399 :     Int_t iCh = pDig-&gt;Ch();</span>
<span class="lineNum">     407 </span><span class="lineCov">        399 :     Double_t qPad = Q()*pDig-&gt;IntMathieson(X(),Y());                                   //pad charge</span>
<span class="lineNum">     408 </span><span class="lineCov">       1197 :     AliDebug(1,Form(&quot;Chamber %i X %i Y %i SigmaCut %i pad %i qpadMath %8.2f qPadRaw %8.2f Qtotal %8.2f cluster n.%i&quot;,iCh,pDig-&gt;PadChX(),pDig-&gt;PadChY(),</span>
<span class="lineNum">     409 </span>            :         pSigmaCut[iCh],iDig,qPad,pDig-&gt;Q(),QRaw(),i));
<span class="lineNum">     410 </span><span class="lineCov">        568 :     if(qPad&gt;pSigmaCut[iCh]) size++;</span>
<span class="lineNum">     411 </span>            :    }
<span class="lineNum">     412 </span><span class="lineCov">        177 :   AliDebug(1,Form(&quot; Calculated size %i&quot;,size));</span>
<span class="lineNum">     413 </span><span class="lineCov">        118 :   if(size&gt;0) SetSize(size);                                                            //in case of size == 0, original raw clustersize used </span>
<span class="lineNum">     414 </span><span class="lineCov">         59 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
