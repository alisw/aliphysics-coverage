<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - TPC/TPCbase/AliTPCSpaceCharge3D.cxx</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">TPC/TPCbase</a> - AliTPCSpaceCharge3D.cxx<span style="font-size: 80%;"> (source / <a href="AliTPCSpaceCharge3D.cxx.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">819</td>
            <td class="headerCovTableEntryLo">0.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">18</td>
            <td class="headerCovTableEntryLo">5.6 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**************************************************************************</a>
<span class="lineNum">       2 </span>            :  * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
<span class="lineNum">       3 </span>            :  *                                                                        *
<span class="lineNum">       4 </span>            :  * Author: The ALICE Off-line Project.                                    *
<span class="lineNum">       5 </span>            :  * Contributors are mentioned in the code where appropriate.              *
<span class="lineNum">       6 </span>            :  *                                                                        *
<span class="lineNum">       7 </span>            :  * Permission to use, copy, modify and distribute this software and its   *
<span class="lineNum">       8 </span>            :  * documentation strictly for non-commercial purposes is hereby granted   *
<span class="lineNum">       9 </span>            :  * without fee, provided that the above copyright notice appears in all   *
<span class="lineNum">      10 </span>            :  * copies and that both the copyright notice and this permission notice   *
<span class="lineNum">      11 </span>            :  * appear in the supporting documentation. The authors make no claims     *
<span class="lineNum">      12 </span>            :  * about the suitability of this software for any purpose. It is          *
<span class="lineNum">      13 </span>            :  * provided &quot;as is&quot; without express or implied warranty.                  *
<span class="lineNum">      14 </span>            :  **************************************************************************/
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : /// \class AliTPCSpaceCharge3D
<span class="lineNum">      17 </span>            : /// \brief The class calculates the space point distortions due to an arbitrary space charge distribution in 3D.
<span class="lineNum">      18 </span>            : ///
<span class="lineNum">      19 </span>            : /// The method of calculation is based on the analytical solution for the Poisson
<span class="lineNum">      20 </span>            : /// problem in 3D (cylindrical coordinates). The solution is used in form of
<span class="lineNum">      21 </span>            : /// look up tables, where the pre calculated solutions for different voxel
<span class="lineNum">      22 </span>            : /// positions are stored. These voxel solutions can be summed up according
<span class="lineNum">      23 </span>            : /// to the weight of the position of the applied space charge distribution.
<span class="lineNum">      24 </span>            : /// Further details can be found in \cite[chap.5]{PhD-thesis_S.Rossegger}.
<span class="lineNum">      25 </span>            : ///
<span class="lineNum">      26 </span>            : /// The class also allows a simple scaling of the resulting distortions
<span class="lineNum">      27 </span>            : /// via the function SetCorrectionFactor. This speeds up the calculation
<span class="lineNum">      28 </span>            : /// time under the assumption, that the distortions scales linearly with the
<span class="lineNum">      29 </span>            : /// magnitude of the space charge distribution $\rho(r,z)$ and the shape stays
<span class="lineNum">      30 </span>            : /// the same at higher luminosities.
<span class="lineNum">      31 </span>            : ///
<span class="lineNum">      32 </span>            : /// In contrast to the implementation in 2D (see the class AliTPCSpaceChargeabove),
<span class="lineNum">      33 </span>            : /// the input charge distribution can be of arbitrary character. An example on how
<span class="lineNum">      34 </span>            : /// to produce a corresponding charge distribution can be found in the function
<span class="lineNum">      35 </span>            : /// WriteChargeDistributionToFile. In there, a $\rho(r,z) = (A-B\,z)/r^2$,
<span class="lineNum">      36 </span>            : /// with slightly different magnitude on the A and C side (due to the muon absorber),
<span class="lineNum">      37 </span>            : /// is superpositioned with a few leaking wires at arbitrary positions.
<span class="lineNum">      38 </span>            : ///
<span class="lineNum">      39 </span>            : /// Marian Ivanov change: 26.06.2013
<span class="lineNum">      40 </span>            : /// Usage of the realy 3D space charge map as an optional input
<span class="lineNum">      41 </span>            : /// SetInputSpaceCharge map.
<span class="lineNum">      42 </span>            : /// In case given map is used 2 2D maps are ignored and  scaling functions  $\rho(r,z) = (A-B\,z)/r^2$,
<span class="lineNum">      43 </span>            : /// will not work
<span class="lineNum">      44 </span>            : /// ![Picture from ROOT macro](AliTPCSpaceCharge3D_cxx_2829f39.png)
<span class="lineNum">      45 </span>            : ///
<span class="lineNum">      46 </span>            : /// \author Stefan Rossegger
<span class="lineNum">      47 </span>            : /// \date 19/06/2010
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            : #include &quot;AliMagF.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;TGeoGlobalMagField.h&quot;
<span class="lineNum">      52 </span>            : #include &quot;AliTPCcalibDB.h&quot;
<span class="lineNum">      53 </span>            : #include &quot;AliTPCParam.h&quot;
<span class="lineNum">      54 </span>            : #include &quot;AliLog.h&quot;
<span class="lineNum">      55 </span>            : #include &quot;TH2F.h&quot;
<span class="lineNum">      56 </span>            : #include &quot;TH3F.h&quot;
<span class="lineNum">      57 </span>            : #include &quot;TFile.h&quot;
<span class="lineNum">      58 </span>            : #include &quot;TVector.h&quot;
<span class="lineNum">      59 </span>            : #include &quot;TMatrix.h&quot;
<span class="lineNum">      60 </span>            : #include &quot;TMatrixD.h&quot;
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            : #include &quot;TMath.h&quot;
<span class="lineNum">      63 </span>            : #include &quot;AliTPCROC.h&quot;
<span class="lineNum">      64 </span>            : #include &quot;AliTPCSpaceCharge3D.h&quot;
<span class="lineNum">      65 </span>            : #include &quot;AliSysInfo.h&quot;
<a name="66"><span class="lineNum">      66 </span>            : </a>
<span class="lineNum">      67 </span>            : /// \cond CLASSIMP
<span class="lineNum">      68 </span><span class="lineCov">         24 : ClassImp(AliTPCSpaceCharge3D)</span>
<a name="69"><span class="lineNum">      69 </span>            : /// \endcond</a>
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span>            : AliTPCSpaceCharge3D::AliTPCSpaceCharge3D()
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :   : AliTPCCorrection(&quot;SpaceCharge3D&quot;,&quot;Space Charge - 3D&quot;),</span>
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :     fC0(0.),fC1(0.),</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :     fCorrectionFactor(1.),</span>
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :     fInitLookUp(kFALSE),</span>
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :     fSCDataFileName(&quot;&quot;),</span>
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :     fSCLookUpPOCsFileName3D(&quot;&quot;),</span>
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :     fSCLookUpPOCsFileNameRZ(&quot;&quot;),</span>
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :     fSCLookUpPOCsFileNameRPhi(&quot;&quot;),</span>
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :     fSCdensityInRZ(0),</span>
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :     fSCdensityInRPhiA(0),</span>
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :     fSCdensityInRPhiC(0),</span>
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :     fSpaceChargeHistogram3D(0),</span>
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :     fSpaceChargeHistogramRPhi(0),</span>
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :     fSpaceChargeHistogramRZ(0)</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">      87 </span>            :   //
<span class="lineNum">      88 </span>            :   // default constructor
<span class="lineNum">      89 </span>            :   //
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            :   // Array which will contain the solution according to the setted charge density distribution
<span class="lineNum">      92 </span>            :   // see InitSpaceCharge3DDistortion() function
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :   for ( Int_t k = 0 ; k &lt; kNPhi ; k++ ) {</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :     fLookUpErOverEz[k]   =  new TMatrixF(kNR,kNZ);</span>
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :     fLookUpEphiOverEz[k] =  new TMatrixF(kNR,kNZ);</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :     fLookUpDeltaEz[k]    =  new TMatrixF(kNR,kNZ);</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :     fSCdensityDistribution[k] = new TMatrixF(kNR,kNZ);</span>
<span class="lineNum">      98 </span>            :   }
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :   fSCdensityInRZ   = new TMatrixD(kNR,kNZ);</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :   fSCdensityInRPhiA = new TMatrixD(kNR,kNPhi);</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :   fSCdensityInRPhiC = new TMatrixD(kNR,kNPhi);</span>
<span class="lineNum">     102 </span>            : 
<span class="lineNum">     103 </span>            :   // location of the precalculated look up tables
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :   fSCLookUpPOCsFileName3D=&quot;$(ALICE_ROOT)/TPC/TPCcalib/maps/sc_3D_raw_18-18-26_17p-18p-25p-MN30.root&quot;; // rough estimate</span>
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :   fSCLookUpPOCsFileNameRZ=&quot;$(ALICE_ROOT)/TPC/TPCcalib/maps/sc_radSym_35-01-51_34p-01p-50p_MN60.root&quot;;</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :   fSCLookUpPOCsFileNameRPhi=&quot;$(ALICE_ROOT)/TPC/TPCcalib/maps/sc_cChInZ_35-144-26_34p-18p-01p-MN30.root&quot;;</span>
<span class="lineNum">     108 </span>            :   //  fSCLookUpPOCsFileNameRPhi=&quot;$(ALICE_ROOT)/TPC/Calib/maps/sc_cChInZ_35-36-26_34p-18p-01p-MN40.root&quot;;
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span>            :   // standard location of the space charge distibution ... can be changes
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :   fSCDataFileName=&quot;$(ALICE_ROOT)/TPC/TPCcalib/maps/sc_3D_distribution_Sim.root&quot;;</span>
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            :   //  SetSCDataFileName(fSCDataFileName.Data()); // should be done by the user
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            : 
<a name="118"><span class="lineNum">     118 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span><span class="lineNoCov">          0 : AliTPCSpaceCharge3D::~AliTPCSpaceCharge3D() {</span>
<span class="lineNum">     121 </span>            :   /// default destructor
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :   for ( Int_t k = 0 ; k &lt; kNPhi ; k++ ) {</span>
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :     delete fLookUpErOverEz[k];</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :     delete fLookUpEphiOverEz[k];</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :     delete fLookUpDeltaEz[k];</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :     delete fSCdensityDistribution[k];</span>
<span class="lineNum">     128 </span>            :   }
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :   delete fSCdensityInRZ;</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :   delete fSCdensityInRPhiA;</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :   delete fSCdensityInRPhiC;</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :   delete fSpaceChargeHistogram3D;</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :   delete fSpaceChargeHistogramRPhi;</span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :   delete fSpaceChargeHistogramRZ;</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 : }</span>
<a name="136"><span class="lineNum">     136 </span>            : </a>
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            : void AliTPCSpaceCharge3D::Init() {
<span class="lineNum">     139 </span>            :   /// Initialization funtion
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :   AliMagF* magF= (AliMagF*)TGeoGlobalMagField::Instance()-&gt;GetField();</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :   if (!magF) AliError(&quot;Magneticd field - not initialized&quot;);</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :   Double_t bzField = magF-&gt;SolenoidField()/10.; //field in T</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :   AliTPCParam *param= AliTPCcalibDB::Instance()-&gt;GetParameters();</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :   if (!param) AliError(&quot;Parameters - not initialized&quot;);</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :   Double_t vdrift = param-&gt;GetDriftV()/1000000.; // [cm/us]   // From dataBase: to be updated: per second (ideally)</span>
<span class="lineNum">     147 </span>            :   Double_t ezField = 400; // [V/cm]   // to be updated: never (hopefully)
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :   Double_t wt = -10.0 * (bzField*10) * vdrift / ezField ;</span>
<span class="lineNum">     149 </span>            :   // Correction Terms for effective omegaTau; obtained by a laser calibration run
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :   SetOmegaTauT1T2(wt,fT1,fT2);</span>
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :   InitSpaceCharge3DDistortion(); // fill the look up table</span>
<a name="153"><span class="lineNum">     153 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span>            : void AliTPCSpaceCharge3D::Update(const TTimeStamp &amp;/*timeStamp*/) {
<span class="lineNum">     156 </span>            :   /// Update function
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :   AliMagF* magF= (AliMagF*)TGeoGlobalMagField::Instance()-&gt;GetField();</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :   if (!magF) AliError(&quot;Magneticd field - not initialized&quot;);</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :   Double_t bzField = magF-&gt;SolenoidField()/10.; //field in T</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :   AliTPCParam *param= AliTPCcalibDB::Instance()-&gt;GetParameters();</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :   if (!param) AliError(&quot;Parameters - not initialized&quot;);</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :   Double_t vdrift = param-&gt;GetDriftV()/1000000.; // [cm/us]  // From dataBase: to be updated: per second (ideally)</span>
<span class="lineNum">     164 </span>            :   Double_t ezField = 400; // [V/cm]   // to be updated: never (hopefully)
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :   Double_t wt = -10.0 * (bzField*10) * vdrift / ezField ;</span>
<span class="lineNum">     166 </span>            :   // Correction Terms for effective omegaTau; obtained by a laser calibration run
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :   SetOmegaTauT1T2(wt,fT1,fT2);</span>
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span>            :   //  SetCorrectionFactor(1.); // should come from some database
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span><span class="lineNoCov">          0 : }</span>
<a name="172"><span class="lineNum">     172 </span>            : </a>
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span>            : void AliTPCSpaceCharge3D::GetCorrection(const Float_t x[],const Short_t roc,Float_t dx[]) {
<span class="lineNum">     175 </span>            :   /// Calculates the correction due the Space Charge effect within the TPC drift volume
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :   if (!fInitLookUp) {</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :     AliInfo(&quot;Lookup table was not initialized! Performing the inizialisation now ...&quot;);</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :     InitSpaceCharge3DDistortion();</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            :   Int_t   order     = 1 ;    // FIXME: hardcoded? Linear interpolation = 1, Quadratic = 2
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            :   Float_t intEr, intEphi, intdEz ;
<span class="lineNum">     185 </span>            :   Double_t r, phi, z ;
<span class="lineNum">     186 </span>            :   Int_t    sign;
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :   r      =  TMath::Sqrt( x[0]*x[0] + x[1]*x[1] ) ;</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :   phi    =  TMath::ATan2(x[1],x[0]) ;</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :   if ( phi &lt; 0 ) phi += TMath::TwoPi() ;                   // Table uses phi from 0 to 2*Pi</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :   z      =  x[2] ;                                         // Create temporary copy of x[2]</span>
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :   if ( (roc%36) &lt; 18 ) {</span>
<span class="lineNum">     194 </span>            :     sign =  1;       // (TPC A side)
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">     196 </span>            :     sign = -1;       // (TPC C side)
<span class="lineNum">     197 </span>            :   }
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :   if ( sign==1  &amp;&amp; z &lt;  fgkZOffSet ) z =  fgkZOffSet;    // Protect against discontinuity at CE</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :   if ( sign==-1 &amp;&amp; z &gt; -fgkZOffSet ) z = -fgkZOffSet;    // Protect against discontinuity at CE</span>
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :   if ( (sign==1 &amp;&amp; z&lt;0) || (sign==-1 &amp;&amp; z&gt;0) ) // just a consistency check</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :     AliError(&quot;ROC number does not correspond to z coordinate! Calculation of distortions is most likely wrong!&quot;);</span>
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            :   // Get the Er and Ephi field integrals plus the integral over DeltaEz
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :   intEr      = Interpolate3DTable(order, r, z, phi, kNR, kNZ, kNPhi,</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :                                   fgkRList, fgkZList, fgkPhiList, fLookUpErOverEz  );</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :   intEphi    = Interpolate3DTable(order, r, z, phi, kNR, kNZ, kNPhi,</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :                                   fgkRList, fgkZList, fgkPhiList, fLookUpEphiOverEz);</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :   intdEz = Interpolate3DTable(order, r, z, phi, kNR, kNZ, kNPhi,</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :                                   fgkRList, fgkZList, fgkPhiList, fLookUpDeltaEz   );</span>
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            :   // Calculate distorted position
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :   if ( r &gt; 0.0 ) {</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :     phi =  phi + fCorrectionFactor *( fC0*intEphi - fC1*intEr ) / r;</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :     r   =  r   + fCorrectionFactor *( fC0*intEr   + fC1*intEphi );</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :   Double_t dz = intdEz * fCorrectionFactor * fgkdvdE;</span>
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span>            :   // Calculate correction in cartesian coordinates
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :   dx[0] = - (r * TMath::Cos(phi) - x[0]);</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :   dx[1] = - (r * TMath::Sin(phi) - x[1]);</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :   dx[2] = - dz;  // z distortion - (scaled with driftvelocity dependency on the Ez field and the overall scaling factor)</span>
<span class="lineNum">     225 </span>            : 
<a name="226"><span class="lineNum">     226 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span>            : void AliTPCSpaceCharge3D::InitSpaceCharge3DDistortion() {
<span class="lineNum">     229 </span>            :  /// Initialization of the Lookup table which contains the solutions of the
<span class="lineNum">     230 </span>            :  /// &quot;space charge&quot; (poisson) problem - Faster and more accureate
<span class="lineNum">     231 </span>            :  ///
<span class="lineNum">     232 </span>            :  /// Method: Weighted sum-up of the different fields within the look up table
<span class="lineNum">     233 </span>            :  /// but using two lookup tables with higher granularity in the (r,z) and the (rphi)- plane to emulate
<span class="lineNum">     234 </span>            :  /// more realistic space charges. (r,z) from primary ionisation. (rphi) for possible Gating leaks
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :   if (fInitLookUp) {</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :     AliInfo(&quot;Lookup table was already initialized!  Doing it again anyway ...&quot;);</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     239 </span>            :   }
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span>            :   // ------------------------------------------------------------------------------------------------------
<span class="lineNum">     242 </span>            :   // step 1: lookup table in rz, fine grid, radial symetric, to emulate primary ionization
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :   AliInfo(&quot;Step 1: Preparation of the weighted look-up tables.&quot;);</span>
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span>            :   // lookup table in rz, fine grid
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :   TFile *fZR = new TFile(fSCLookUpPOCsFileNameRZ.Data(),&quot;READ&quot;);</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :   if ( !fZR ) {</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :     AliError(&quot;Precalculated POC-looup-table in ZR could not be found&quot;);</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     252 </span>            :   }
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            :   // units are in [m]
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :   TVector *gridf1  = (TVector*) fZR-&gt;Get(&quot;constants&quot;);</span>
<span class="lineNum">     256 </span>            :   TVector &amp;grid1 = *gridf1;
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :   TMatrix *coordf1  = (TMatrix*) fZR-&gt;Get(&quot;coordinates&quot;);</span>
<span class="lineNum">     258 </span>            :   TMatrix &amp;coord1 = *coordf1;
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :   TMatrix *coordPOCf1  = (TMatrix*) fZR-&gt;Get(&quot;POCcoord&quot;);</span>
<span class="lineNum">     260 </span>            :   TMatrix &amp;coordPOC1 = *coordPOCf1;
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :   Int_t rows      = (Int_t)grid1(0);   // number of points in r direction  - from RZ or RPhi table</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :   Int_t phiSlices = (Int_t)grid1(1);   // number of points in phi          - from RPhi table</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :   Int_t columns   = (Int_t)grid1(2);   // number of points in z direction  - from RZ table</span>
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :   Float_t gridSizeR   =  (fgkOFCRadius-fgkIFCRadius)/(rows-1);   // unit in [cm]</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :   Float_t gridSizeZ   =  fgkTPCZ0/(columns-1);                  // unit in [cm]</span>
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span>            :   // temporary matrices needed for the calculation // for rotational symmetric RZ table, phislices is 1
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :   TMatrixD *arrayofErA[kNPhiSlices], *arrayofdEzA[kNPhiSlices];</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :   TMatrixD *arrayofErC[kNPhiSlices], *arrayofdEzC[kNPhiSlices];</span>
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :   TMatrixD *arrayofEroverEzA[kNPhiSlices], *arrayofDeltaEzA[kNPhiSlices];</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :   TMatrixD *arrayofEroverEzC[kNPhiSlices], *arrayofDeltaEzC[kNPhiSlices];</span>
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :   for ( Int_t k = 0 ; k &lt; phiSlices ; k++ ) {</span>
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :     arrayofErA[k]   =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :     arrayofdEzA[k]  =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :     arrayofErC[k]   =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :     arrayofdEzC[k]  =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :     arrayofEroverEzA[k]   =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :     arrayofDeltaEzA[k]    =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :     arrayofEroverEzC[k]   =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :     arrayofDeltaEzC[k]    =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span>            :     // zero initialization not necessary, it is done in the constructor of TMatrix
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            :   }
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            :   // list of points as used during sum up
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :   Double_t  rlist1[kNRows], zedlist1[kNColumns];// , philist1[phiSlices];</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :   for ( Int_t i = 0 ; i &lt; rows ; i++ )    {</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :     rlist1[i] = fgkIFCRadius + i*gridSizeR ;</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :     for ( Int_t j = 0 ; j &lt; columns ; j++ ) {</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :       zedlist1[j]  = j * gridSizeZ ;</span>
<span class="lineNum">     300 </span>            :     }
<span class="lineNum">     301 </span>            :   }
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :   TTree *treePOC = (TTree*)fZR-&gt;Get(&quot;POCall&quot;);</span>
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :   TVector *bEr  = 0;   //TVector *bEphi= 0;</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :   TVector *bEz  = 0;</span>
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :   treePOC-&gt;SetBranchAddress(&quot;Er&quot;,&amp;bEr);</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :   treePOC-&gt;SetBranchAddress(&quot;Ez&quot;,&amp;bEz);</span>
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            :   // Read the complete tree and do a weighted sum-up over the POC configurations
<span class="lineNum">     313 </span>            :   // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :   Int_t treeNumPOC = (Int_t)treePOC-&gt;GetEntries(); // Number of POC conf. in the look-up table</span>
<span class="lineNum">     316 </span>            :   Int_t ipC = 0; // POC Conf. counter (note: different to the POC number in the tree!)
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :   for (Int_t itreepC=0; itreepC&lt;treeNumPOC; itreepC++) { // ------------- loop over POC configurations in tree</span>
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :     treePOC-&gt;GetEntry(itreepC);</span>
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            :     // center of the POC voxel in [meter]
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :     Double_t r0 = coordPOC1(ipC,0);</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :     Double_t phi0 = coordPOC1(ipC,1);</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :     Double_t z0 = coordPOC1(ipC,2);</span>
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :     ipC++; // POC configuration counter</span>
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            :     // weights (charge density) at POC position on the A and C side (in C/m^3/e0)
<span class="lineNum">     330 </span>            :     // note: coordinates are in [cm]
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :     Double_t weightA = GetSpaceChargeDensity(r0*100,phi0, z0*100);  // partial load in r,z</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :     Double_t weightC = GetSpaceChargeDensity(r0*100,phi0,-z0*100);  // partial load in r,z</span>
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            :     // Summing up the vector components according to their weight
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            :     Int_t ip = 0;
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :     for ( Int_t j = 0 ; j &lt; columns ; j++ ) {</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :       for ( Int_t i = 0 ; i &lt; rows ; i++ )    {</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :         for ( Int_t k = 0 ; k &lt; phiSlices ; k++ ) {</span>
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span>            :           // check wether the coordinates were screwed
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :           if (TMath::Abs((coord1(0,ip)*100-rlist1[i]))&gt;1 ||</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :               TMath::Abs((coord1(2,ip)*100-zedlist1[j])&gt;1)) {</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :             AliError(&quot;internal error: coordinate system was screwed during the sum-up&quot;);</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :             printf(&quot;sum-up: (r,z)=(%f,%f)\n&quot;,rlist1[i],zedlist1[j]);</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :             printf(&quot;lookup: (r,z)=(%f,%f)\n&quot;,coord1(0,ip)*100,coord1(2,ip)*100);</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :             AliError(&quot;Don't trust the results of the space charge calculation!&quot;);</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span>            :           // unfortunately, the lookup tables were produced to be faster for phi symmetric charges
<span class="lineNum">     351 </span>            :           // This will be the most frequent usage (hopefully)
<span class="lineNum">     352 </span>            :           // That's why we have to do this here ...
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :           TMatrixD &amp;erA   =  *arrayofErA[k]  ;</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :           TMatrixD &amp;dEzA  =  *arrayofdEzA[k]   ;</span>
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :           TMatrixD &amp;erC   =  *arrayofErC[k]  ;</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :           TMatrixD &amp;dEzC  =  *arrayofdEzC[k]   ;</span>
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span>            :           // Sum up - Efield values in [V/m] -&gt; transition to [V/cm]
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :           erA(i,j) += ((*bEr)(ip)) * weightA /100;</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :           erC(i,j) += ((*bEr)(ip)) * weightC /100;</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :           dEzA(i,j)  += ((*bEz)(ip)) * weightA /100;</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :           dEzC(i,j)  += ((*bEz)(ip)) * weightC /100;</span>
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span>            :           // increase the counter
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :           ip++;</span>
<span class="lineNum">     368 </span>            :         }
<span class="lineNum">     369 </span>            :       }
<span class="lineNum">     370 </span>            :     } // end coordinate loop
<span class="lineNum">     371 </span>            :   } // end POC loop
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            :   // -------------------------------------------------------------------------------
<span class="lineNum">     375 </span>            :   // Division by the Ez (drift) field and integration along z
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span>            :   //  AliInfo(&quot;Step 1: Division and integration&quot;);
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :   Double_t ezField = (fgkCathodeV-fgkGG)/fgkTPCZ0; // = Electric Field (V/cm) Magnitude ~ -400 V/cm;</span>
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :   for ( Int_t k = 0 ; k &lt; phiSlices ; k++ ) { // phi loop</span>
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span>            :     // matrices holding the solution - summation of POC charges // see above
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :     TMatrixD &amp;erA   =  *arrayofErA[k]  ;</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :     TMatrixD &amp;dezA  =  *arrayofdEzA[k]   ;</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :     TMatrixD &amp;erC   =  *arrayofErC[k]  ;</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :     TMatrixD &amp;dezC  =  *arrayofdEzC[k]   ;</span>
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span>            :     // matrices which will contain the integrated fields (divided by the drift field)
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :     TMatrixD &amp;erOverEzA   =  *arrayofEroverEzA[k]  ;</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :     TMatrixD &amp;deltaEzA    =  *arrayofDeltaEzA[k];</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :     TMatrixD &amp;erOverEzC   =  *arrayofEroverEzC[k]  ;</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :     TMatrixD &amp;deltaEzC    =  *arrayofDeltaEzC[k];</span>
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :     for ( Int_t i = 0 ; i &lt; rows ; i++ )    { // r loop</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :       for ( Int_t j = columns-1 ; j &gt;= 0 ; j-- ) {// z loop</span>
<span class="lineNum">     397 </span>            :         // Count backwards to facilitate integration over Z
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span>            :         Int_t index = 1 ; // Simpsons rule if N=odd.If N!=odd then add extra point
<span class="lineNum">     400 </span>            :                           // by trapezoidal rule.
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :         erOverEzA(i,j) = 0; //ephiOverEzA(i,j) = 0;</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :         deltaEzA(i,j) = 0;</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :         erOverEzC(i,j) = 0; //ephiOverEzC(i,j) = 0;</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :         deltaEzC(i,j) = 0;</span>
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :         for ( Int_t m = j ; m &lt; columns ; m++ ) { // integration</span>
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :           erOverEzA(i,j)   += index*(gridSizeZ/3.0)*erA(i,m)/(-1*ezField) ;</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :           erOverEzC(i,j)   += index*(gridSizeZ/3.0)*erC(i,m)/(-1*ezField)  ;</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :           deltaEzA(i,j)    += index*(gridSizeZ/3.0)*dezA(i,m)/(-1) ;</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :           deltaEzC(i,j)    += index*(gridSizeZ/3.0)*dezC(i,m)/(-1) ;</span>
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :           if ( index != 4 )  index = 4; else index = 2 ;</span>
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span>            :         }
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :         if ( index == 4 ) {</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :           erOverEzA(i,j)   -= (gridSizeZ/3.0)*erA(i,columns-1)/(-1*ezField) ;</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :           erOverEzC(i,j)   -= (gridSizeZ/3.0)*erC(i,columns-1)/(-1*ezField) ;</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :           deltaEzA(i,j)    -= (gridSizeZ/3.0)*dezA(i,columns-1)/(-1) ;</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :           deltaEzC(i,j)    -= (gridSizeZ/3.0)*dezC(i,columns-1)/(-1) ;</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :         if ( index == 2 ) {</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :           erOverEzA(i,j)   += (gridSizeZ/3.0)*(0.5*erA(i,columns-2)-2.5*erA(i,columns-1))/(-1*ezField) ;</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :           erOverEzC(i,j)   += (gridSizeZ/3.0)*(0.5*erC(i,columns-2)-2.5*erC(i,columns-1))/(-1*ezField) ;</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :           deltaEzA(i,j)    += (gridSizeZ/3.0)*(0.5*dezA(i,columns-2)-2.5*dezA(i,columns-1))/(-1) ;</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :           deltaEzC(i,j)    += (gridSizeZ/3.0)*(0.5*dezC(i,columns-2)-2.5*dezC(i,columns-1))/(-1) ;</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :         if ( j == columns-2 ) {</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :           erOverEzA(i,j)   = (gridSizeZ/3.0)*(1.5*erA(i,columns-2)+1.5*erA(i,columns-1))/(-1*ezField) ;</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :           erOverEzC(i,j)   = (gridSizeZ/3.0)*(1.5*erC(i,columns-2)+1.5*erC(i,columns-1))/(-1*ezField) ;</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :           deltaEzA(i,j)    = (gridSizeZ/3.0)*(1.5*dezA(i,columns-2)+1.5*dezA(i,columns-1))/(-1) ;</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :           deltaEzC(i,j)    = (gridSizeZ/3.0)*(1.5*dezC(i,columns-2)+1.5*dezC(i,columns-1))/(-1) ;</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :         if ( j == columns-1 ) {</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :           erOverEzA(i,j)   = 0;</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :           erOverEzC(i,j)   = 0;</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :           deltaEzA(i,j)    = 0;</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :           deltaEzC(i,j)    = 0;</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     442 </span>            :       }
<span class="lineNum">     443 </span>            :     }
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span>            :   }
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span>            :   //  AliInfo(&quot;Step 1: Interpolation to Standard grid&quot;);
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span>            :   // -------------------------------------------------------------------------------
<span class="lineNum">     450 </span>            :   // Interpolate results onto the standard grid which is used for all AliTPCCorrections classes
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span>            :   const Int_t order  = 1  ;  // Linear interpolation = 1, Quadratic = 2
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            :   Double_t  r, z;//phi, z ;
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :   for ( Int_t k = 0 ; k &lt; kNPhi ; k++ ) {</span>
<span class="lineNum">     456 </span>            :     //    phi = fgkPhiList[k] ;
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span>            :     // final lookup table
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :     TMatrixF &amp;erOverEzFinal   =  *fLookUpErOverEz[k]  ;</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :     TMatrixF &amp;deltaEzFinal    =  *fLookUpDeltaEz[k]   ;</span>
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span>            :     // calculated and integrated tables - just one phi slice
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :     TMatrixD &amp;erOverEzA   =  *arrayofEroverEzA[0]  ;</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :     TMatrixD &amp;deltaEzA    =  *arrayofDeltaEzA[0];</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :     TMatrixD &amp;erOverEzC   =  *arrayofEroverEzC[0]  ;</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :     TMatrixD &amp;deltaEzC    =  *arrayofDeltaEzC[0];</span>
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :     for ( Int_t j = 0 ; j &lt; kNZ ; j++ ) {</span>
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :       z = TMath::Abs(fgkZList[j]) ;  // z position is symmetric</span>
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :       for ( Int_t i = 0 ; i &lt; kNR ; i++ ) {</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :         r = fgkRList[i] ;</span>
<span class="lineNum">     475 </span>            : 
<span class="lineNum">     476 </span>            :         // Interpolate Lookup tables onto standard grid
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :         if (fgkZList[j]&gt;0) {</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :           erOverEzFinal(i,j)   = Interpolate2DTable(order, r, z, rows, columns, rlist1, zedlist1, erOverEzA  );</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :           deltaEzFinal(i,j)    = Interpolate2DTable(order, r, z, rows, columns, rlist1, zedlist1, deltaEzA   );</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :           erOverEzFinal(i,j)   = Interpolate2DTable(order, r, z, rows, columns, rlist1, zedlist1, erOverEzC  );</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :           deltaEzFinal(i,j)    = - Interpolate2DTable(order, r, z, rows, columns, rlist1, zedlist1, deltaEzC   );</span>
<span class="lineNum">     483 </span>            :           // negative coordinate system on C side
<span class="lineNum">     484 </span>            :         }
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            :       } // end r loop
<span class="lineNum">     487 </span>            :     } // end z loop
<span class="lineNum">     488 </span>            :   } // end phi loop
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span>            :   // clear the temporary arrays lists
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :   for ( Int_t k = 0 ; k &lt; phiSlices ; k++ )  {</span>
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :     delete arrayofErA[k];</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :     delete arrayofdEzA[k];</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :     delete arrayofErC[k];</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :     delete arrayofdEzC[k];</span>
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :     delete arrayofEroverEzA[k];</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :     delete arrayofDeltaEzA[k];</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :     delete arrayofEroverEzC[k];</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :     delete arrayofDeltaEzC[k];</span>
<span class="lineNum">     503 </span>            : 
<span class="lineNum">     504 </span>            :   }
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :   fZR-&gt;Close();</span>
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span>            :   // ------------------------------------------------------------------------------------------------------
<span class="lineNum">     509 </span>            :   // Step 2: Load and sum up lookup table in rphi, fine grid, to emulate for example a GG leak
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span>            :   //  AliInfo(&quot;Step 2: Preparation of the weighted look-up table&quot;);
<span class="lineNum">     512 </span>            : 
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :   TFile *fRPhi = new TFile(fSCLookUpPOCsFileNameRPhi.Data(),&quot;READ&quot;);</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :   if ( !fRPhi ) {</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :     AliError(&quot;Precalculated POC-looup-table in RPhi could not be found&quot;);</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     517 </span>            :   }
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span>            :   // units are in [m]
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :   TVector *gridf2  = (TVector*) fRPhi-&gt;Get(&quot;constants&quot;);</span>
<span class="lineNum">     521 </span>            :   TVector &amp;grid2 = *gridf2;
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :   TMatrix *coordf2  = (TMatrix*) fRPhi-&gt;Get(&quot;coordinates&quot;);</span>
<span class="lineNum">     523 </span>            :   TMatrix &amp;coord2 = *coordf2;
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :   TMatrix *coordPOCf2  = (TMatrix*) fRPhi-&gt;Get(&quot;POCcoord&quot;);</span>
<span class="lineNum">     525 </span>            :   TMatrix &amp;coordPOC2 = *coordPOCf2;
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :   rows      = (Int_t)grid2(0);   // number of points in r direction</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :   phiSlices = (Int_t)grid2(1);   // number of points in phi</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :   columns   = (Int_t)grid2(2);   // number of points in z direction</span>
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :   gridSizeR   =  (fgkOFCRadius-fgkIFCRadius)/(rows-1);   // unit in [cm]</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :   Float_t gridSizePhi =  TMath::TwoPi()/phiSlices;         // unit in [rad]</span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :   gridSizeZ   =  fgkTPCZ0/(columns-1);                  // unit in [cm]</span>
<span class="lineNum">     534 </span>            : 
<span class="lineNum">     535 </span>            :   // list of points as used during sum up
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :   Double_t  rlist2[kNRows], philist2[kNPhiSlices], zedlist2[kNColumns];</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :   for ( Int_t k = 0 ; k &lt; phiSlices ; k++ ) {</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :     philist2[k] =  gridSizePhi * k;</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :     for ( Int_t i = 0 ; i &lt; rows ; i++ )    {</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :       rlist2[i] = fgkIFCRadius + i*gridSizeR ;</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :       for ( Int_t j = 0 ; j &lt; columns ; j++ ) {</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :         zedlist2[j]  = j * gridSizeZ ;</span>
<span class="lineNum">     543 </span>            :       }
<span class="lineNum">     544 </span>            :     }
<span class="lineNum">     545 </span>            :   } // only done once
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span>            :   // temporary matrices needed for the calculation
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :   TMatrixD *arrayofErA2[kNPhiSlices], *arrayofEphiA2[kNPhiSlices], *arrayofdEzA2[kNPhiSlices];</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :   TMatrixD *arrayofErC2[kNPhiSlices], *arrayofEphiC2[kNPhiSlices], *arrayofdEzC2[kNPhiSlices];</span>
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :   TMatrixD *arrayofEroverEzA2[kNPhiSlices], *arrayofEphioverEzA2[kNPhiSlices], *arrayofDeltaEzA2[kNPhiSlices];</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :   TMatrixD *arrayofEroverEzC2[kNPhiSlices], *arrayofEphioverEzC2[kNPhiSlices], *arrayofDeltaEzC2[kNPhiSlices];</span>
<span class="lineNum">     554 </span>            : 
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :   for ( Int_t k = 0 ; k &lt; phiSlices ; k++ ) {</span>
<span class="lineNum">     557 </span>            : 
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :     arrayofErA2[k]   =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :     arrayofEphiA2[k] =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :     arrayofdEzA2[k]  =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :     arrayofErC2[k]   =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :     arrayofEphiC2[k] =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :     arrayofdEzC2[k]  =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     564 </span>            : 
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :     arrayofEroverEzA2[k]   =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :     arrayofEphioverEzA2[k] =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :     arrayofDeltaEzA2[k]    =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :     arrayofEroverEzC2[k]   =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :     arrayofEphioverEzC2[k] =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :     arrayofDeltaEzC2[k]    =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span>            :     // zero initialization not necessary, it is done in the constructor of TMatrix
<span class="lineNum">     573 </span>            : 
<span class="lineNum">     574 </span>            :   }
<span class="lineNum">     575 </span>            : 
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :   treePOC = (TTree*)fRPhi-&gt;Get(&quot;POCall&quot;);</span>
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span>            :   //  TVector *bEr  = 0;   // done above
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :   TVector *bEphi= 0;</span>
<span class="lineNum">     581 </span>            :   //  TVector *bEz  = 0;   // done above
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :   treePOC-&gt;SetBranchAddress(&quot;Er&quot;,&amp;bEr);</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :   treePOC-&gt;SetBranchAddress(&quot;Ephi&quot;,&amp;bEphi);</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :   treePOC-&gt;SetBranchAddress(&quot;Ez&quot;,&amp;bEz);</span>
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span>            :   // Read the complete tree and do a weighted sum-up over the POC configurations
<span class="lineNum">     588 </span>            :   // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :   treeNumPOC = (Int_t)treePOC-&gt;GetEntries(); // Number of POC conf. in the look-up table</span>
<span class="lineNum">     591 </span>            :   ipC = 0; // POC Conf. counter (note: different to the POC number in the tree!)
<span class="lineNum">     592 </span>            : 
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :   for (Int_t itreepC=0; itreepC&lt;treeNumPOC; itreepC++) { // ------------- loop over POC configurations in tree</span>
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :     treePOC-&gt;GetEntry(itreepC);</span>
<span class="lineNum">     596 </span>            : 
<span class="lineNum">     597 </span>            :     // center of the POC voxel in [meter]
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :     Double_t r0 = coordPOC2(ipC,0);</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :     Double_t phi0 = coordPOC2(ipC,1);</span>
<span class="lineNum">     600 </span>            :     //    Double_t z0 = coordPOC2(ipC,2);
<span class="lineNum">     601 </span>            : 
<span class="lineNum">     602 </span>            :      // weights (charge density) at POC position on the A and C side (in C/m^3/e0)
<span class="lineNum">     603 </span>            :     // note: coordinates are in [cm]
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :     Double_t weightA = GetSpaceChargeDensity(r0*100,phi0, 0.499);  // partial load in r,phi</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :     Double_t weightC = GetSpaceChargeDensity(r0*100,phi0,-0.499);  // partial load in r,phi</span>
<span class="lineNum">     606 </span>            : 
<span class="lineNum">     607 </span>            :     //    printf(&quot;-----\n%f %f : %e %e\n&quot;,r0,phi0,weightA,weightC);
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span>            :     // Summing up the vector components according to their weight
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span>            :     Int_t ip = 0;
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :     for ( Int_t j = 0 ; j &lt; columns ; j++ ) {</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :       for ( Int_t i = 0 ; i &lt; rows ; i++ )    {</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :         for ( Int_t k = 0 ; k &lt; phiSlices ; k++ ) {</span>
<span class="lineNum">     615 </span>            : 
<span class="lineNum">     616 </span>            :           // check wether the coordinates were screwed
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :           if (TMath::Abs((coord2(0,ip)*100-rlist2[i]))&gt;1 ||</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :               TMath::Abs((coord2(1,ip)-philist2[k]))&gt;1 ||</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :               TMath::Abs((coord2(2,ip)*100-zedlist2[j]))&gt;1) {</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :             AliError(&quot;internal error: coordinate system was screwed during the sum-up&quot;);</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :             printf(&quot;lookup: (r,phi,z)=(%f,%f,%f)\n&quot;,coord2(0,ip)*100,coord2(1,ip),coord2(2,ip)*100);</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :             printf(&quot;sum-up: (r,phi,z)=(%f,%f,%f)\n&quot;,rlist2[i],philist2[k],zedlist2[j]);</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :             AliError(&quot;Don't trust the results of the space charge calculation!&quot;);</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span>            :           // unfortunately, the lookup tables were produced to be faster for phi symmetric charges
<span class="lineNum">     627 </span>            :           // This will be the most frequent usage (hopefully)
<span class="lineNum">     628 </span>            :           // That's why we have to do this here ...
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :           TMatrixD &amp;erA   =  *arrayofErA2[k]  ;</span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :           TMatrixD &amp;ephiA =  *arrayofEphiA2[k];</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :           TMatrixD &amp;dEzA  =  *arrayofdEzA2[k] ;</span>
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :           TMatrixD &amp;erC   =  *arrayofErC2[k]  ;</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :           TMatrixD &amp;ephiC =  *arrayofEphiC2[k];</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :           TMatrixD &amp;dEzC  =  *arrayofdEzC2[k]   ;</span>
<span class="lineNum">     637 </span>            : 
<span class="lineNum">     638 </span>            :           // Sum up - Efield values in [V/m] -&gt; transition to [V/cm]
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :           erA(i,j) += ((*bEr)(ip)) * weightA /100;</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :           erC(i,j) += ((*bEr)(ip)) * weightC /100;</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :           ephiA(i,j) += ((*bEphi)(ip)) * weightA/100; // [V/rad]</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :           ephiC(i,j) += ((*bEphi)(ip)) * weightC/100; // [V/rad]</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :           dEzA(i,j)  += ((*bEz)(ip)) * weightA /100;</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :           dEzC(i,j)  += ((*bEz)(ip)) * weightC /100;</span>
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span>            :           // increase the counter
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :           ip++;</span>
<span class="lineNum">     648 </span>            :         }
<span class="lineNum">     649 </span>            :       }
<span class="lineNum">     650 </span>            :     } // end coordinate loop
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span>            :     // Rotation and summation in the rest of the dPhiSteps
<span class="lineNum">     654 </span>            :     // which were not stored in the this tree due to storage &amp; symmetry reasons
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span>            : 
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :     Int_t phiPoints = (Int_t) grid2(1);</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :     Int_t phiPOC    = (Int_t) grid2(4);</span>
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span>            :     //   printf(&quot;%d %d\n&quot;,phiPOC,flagRadSym);
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :     for (Int_t phiiC = 1; phiiC&lt;phiPOC; phiiC++) { // just used for non-radial symetric table</span>
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :       Double_t phi0R = phiiC*phi0*2 + phi0; // rotate further</span>
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span>            :       // weights (charge density) at POC position on the A and C side (in C/m^3/e0)
<span class="lineNum">     667 </span>            :       // note: coordinates are in [cm] // ecxept z
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :       weightA = GetSpaceChargeDensity(r0*100,phi0R, 0.499);  // partial load in r,phi</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :       weightC = GetSpaceChargeDensity(r0*100,phi0R,-0.499);  // partial load in r,phi</span>
<span class="lineNum">     670 </span>            : 
<span class="lineNum">     671 </span>            :       // printf(&quot;%f %f : %e %e\n&quot;,r0,phi0R,weightA,weightC);
<span class="lineNum">     672 </span>            : 
<span class="lineNum">     673 </span>            :       // Summing up the vector components according to their weight
<span class="lineNum">     674 </span>            :       ip = 0;
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :       for ( Int_t j = 0 ; j &lt; columns ; j++ ) {</span>
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :         for ( Int_t i = 0 ; i &lt; rows ; i++ )    {</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :           for ( Int_t k = 0 ; k &lt; phiSlices ; k++ ) {</span>
<span class="lineNum">     678 </span>            : 
<span class="lineNum">     679 </span>            :             // Note: rotating the coordinated during the sum up
<span class="lineNum">     680 </span>            : 
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :             Int_t rotVal = (phiPoints/phiPOC)*phiiC;</span>
<span class="lineNum">     682 </span>            :             Int_t ipR = -1;
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :             if ((ip%phiPoints)&gt;=rotVal) {</span>
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :               ipR = ip-rotVal;</span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :             } else {</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :               ipR = ip+(phiPoints-rotVal);</span>
<span class="lineNum">     688 </span>            :             }
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span>            :             // unfortunately, the lookup tables were produced to be faster for phi symmetric charges
<span class="lineNum">     691 </span>            :             // This will be the most frequent usage
<span class="lineNum">     692 </span>            :             // That's why we have to do this here and not outside the loop ...
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :             TMatrixD &amp;erA   =  *arrayofErA2[k]  ;</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :             TMatrixD &amp;ephiA =  *arrayofEphiA2[k];</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :             TMatrixD &amp;dEzA  =  *arrayofdEzA2[k]   ;</span>
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :             TMatrixD &amp;erC   =  *arrayofErC2[k]  ;</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :             TMatrixD &amp;ephiC =  *arrayofEphiC2[k];</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :             TMatrixD &amp;dEzC  =  *arrayofdEzC2[k]   ;</span>
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span>            :             // Sum up - Efield values in [V/m] -&gt; transition to [V/cm]
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :             erA(i,j) += ((*bEr)(ipR)) * weightA /100;</span>
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :             erC(i,j) += ((*bEr)(ipR)) * weightC /100;</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :             ephiA(i,j) += ((*bEphi)(ipR)) * weightA/100; // [V/rad]</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :             ephiC(i,j) += ((*bEphi)(ipR)) * weightC/100; // [V/rad]</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :             dEzA(i,j)  += ((*bEz)(ipR)) * weightA /100;</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :             dEzC(i,j)  += ((*bEz)(ipR)) * weightC /100;</span>
<span class="lineNum">     709 </span>            : 
<span class="lineNum">     710 </span>            :             // increase the counter
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :             ip++;</span>
<span class="lineNum">     712 </span>            :           }
<span class="lineNum">     713 </span>            :         }
<span class="lineNum">     714 </span>            :       } // end coordinate loop
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span>            :     } // end phi-POC summation (phiiC)
<span class="lineNum">     717 </span>            : 
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :     ipC++; // POC configuration counter</span>
<span class="lineNum">     719 </span>            : 
<span class="lineNum">     720 </span>            :     //   printf(&quot;POC: (r,phi,z) = (%f %f %f) | weight(A,C): %03.1lf %03.1lf\n&quot;,r0,phi0,z0, weightA, weightC);
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span>            :   }
<span class="lineNum">     723 </span>            : 
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span>            : 
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span>            :   // -------------------------------------------------------------------------------
<span class="lineNum">     728 </span>            :   // Division by the Ez (drift) field and integration along z
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span>            :   //  AliInfo(&quot;Step 2: Division and integration&quot;);
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span>            : 
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :   for ( Int_t k = 0 ; k &lt; phiSlices ; k++ ) { // phi loop</span>
<span class="lineNum">     734 </span>            : 
<span class="lineNum">     735 </span>            :     // matrices holding the solution - summation of POC charges // see above
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :     TMatrixD &amp;erA   =  *arrayofErA2[k]  ;</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :     TMatrixD &amp;ephiA =  *arrayofEphiA2[k];</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :     TMatrixD &amp;dezA  =  *arrayofdEzA2[k]   ;</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :     TMatrixD &amp;erC   =  *arrayofErC2[k]  ;</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :     TMatrixD &amp;ephiC =  *arrayofEphiC2[k];</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :     TMatrixD &amp;dezC  =  *arrayofdEzC2[k]   ;</span>
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span>            :     // matrices which will contain the integrated fields (divided by the drift field)
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :     TMatrixD &amp;erOverEzA   =  *arrayofEroverEzA2[k]  ;</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :     TMatrixD &amp;ephiOverEzA =  *arrayofEphioverEzA2[k];</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :     TMatrixD &amp;deltaEzA    =  *arrayofDeltaEzA2[k];</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :     TMatrixD &amp;erOverEzC   =  *arrayofEroverEzC2[k]  ;</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :     TMatrixD &amp;ephiOverEzC =  *arrayofEphioverEzC2[k];</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :     TMatrixD &amp;deltaEzC    =  *arrayofDeltaEzC2[k];</span>
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :     for ( Int_t i = 0 ; i &lt; rows ; i++ )    { // r loop</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :       for ( Int_t j = columns-1 ; j &gt;= 0 ; j-- ) {// z loop</span>
<span class="lineNum">     753 </span>            :         // Count backwards to facilitate integration over Z
<span class="lineNum">     754 </span>            : 
<span class="lineNum">     755 </span>            :         Int_t index = 1 ; // Simpsons rule if N=odd.If N!=odd then add extra point by trapezoidal rule.
<span class="lineNum">     756 </span>            : 
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :         erOverEzA(i,j) = 0;</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :         ephiOverEzA(i,j) = 0;</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :         deltaEzA(i,j) = 0;</span>
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :         erOverEzC(i,j) = 0;</span>
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :         ephiOverEzC(i,j) = 0;</span>
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :         deltaEzC(i,j) = 0;</span>
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :         for ( Int_t m = j ; m &lt; columns ; m++ ) { // integration</span>
<span class="lineNum">     765 </span>            : 
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :           erOverEzA(i,j)   += index*(gridSizeZ/3.0)*erA(i,m)/(-1*ezField) ;</span>
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :           erOverEzC(i,j)   += index*(gridSizeZ/3.0)*erC(i,m)/(-1*ezField)  ;</span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :           ephiOverEzA(i,j) += index*(gridSizeZ/3.0)*ephiA(i,m)/(-1*ezField)  ;</span>
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :           ephiOverEzC(i,j) += index*(gridSizeZ/3.0)*ephiC(i,m)/(-1*ezField)  ;</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :           deltaEzA(i,j)    += index*(gridSizeZ/3.0)*dezA(i,m)/(-1) ;</span>
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :           deltaEzC(i,j)    += index*(gridSizeZ/3.0)*dezC(i,m)/(-1) ;</span>
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :           if ( index != 4 )  index = 4; else index = 2 ;</span>
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span>            :         }
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :         if ( index == 4 ) {</span>
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :           erOverEzA(i,j)   -= (gridSizeZ/3.0)*erA(i,columns-1)/(-1*ezField) ;</span>
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :           erOverEzC(i,j)   -= (gridSizeZ/3.0)*erC(i,columns-1)/(-1*ezField) ;</span>
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :           ephiOverEzA(i,j) -= (gridSizeZ/3.0)*ephiA(i,columns-1)/(-1*ezField) ;</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :           ephiOverEzC(i,j) -= (gridSizeZ/3.0)*ephiC(i,columns-1)/(-1*ezField) ;</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :           deltaEzA(i,j)    -= (gridSizeZ/3.0)*dezA(i,columns-1)/(-1) ;</span>
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :           deltaEzC(i,j)    -= (gridSizeZ/3.0)*dezC(i,columns-1)/(-1) ;</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :         if ( index == 2 ) {</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :           erOverEzA(i,j)   += (gridSizeZ/3.0)*(0.5*erA(i,columns-2)-2.5*erA(i,columns-1))/(-1*ezField) ;</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :           erOverEzC(i,j)   += (gridSizeZ/3.0)*(0.5*erC(i,columns-2)-2.5*erC(i,columns-1))/(-1*ezField) ;</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :           ephiOverEzA(i,j) += (gridSizeZ/3.0)*(0.5*ephiA(i,columns-2)-2.5*ephiA(i,columns-1))/(-1*ezField) ;</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :           ephiOverEzC(i,j) += (gridSizeZ/3.0)*(0.5*ephiC(i,columns-2)-2.5*ephiC(i,columns-1))/(-1*ezField) ;</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :           deltaEzA(i,j)    += (gridSizeZ/3.0)*(0.5*dezA(i,columns-2)-2.5*dezA(i,columns-1))/(-1) ;</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :           deltaEzC(i,j)    += (gridSizeZ/3.0)*(0.5*dezC(i,columns-2)-2.5*dezC(i,columns-1))/(-1) ;</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :         if ( j == columns-2 ) {</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :           erOverEzA(i,j)   = (gridSizeZ/3.0)*(1.5*erA(i,columns-2)+1.5*erA(i,columns-1))/(-1*ezField) ;</span>
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :           erOverEzC(i,j)   = (gridSizeZ/3.0)*(1.5*erC(i,columns-2)+1.5*erC(i,columns-1))/(-1*ezField) ;</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :           ephiOverEzA(i,j) = (gridSizeZ/3.0)*(1.5*ephiA(i,columns-2)+1.5*ephiA(i,columns-1))/(-1*ezField) ;</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :           ephiOverEzC(i,j) = (gridSizeZ/3.0)*(1.5*ephiC(i,columns-2)+1.5*ephiC(i,columns-1))/(-1*ezField) ;</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :           deltaEzA(i,j)    = (gridSizeZ/3.0)*(1.5*dezA(i,columns-2)+1.5*dezA(i,columns-1))/(-1) ;</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :           deltaEzC(i,j)    = (gridSizeZ/3.0)*(1.5*dezC(i,columns-2)+1.5*dezC(i,columns-1))/(-1) ;</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :         if ( j == columns-1 ) {</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :           erOverEzA(i,j)   = 0;</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :           erOverEzC(i,j)   = 0;</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :           ephiOverEzA(i,j) = 0;</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :           ephiOverEzC(i,j) = 0;</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :           deltaEzA(i,j)    = 0;</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :           deltaEzC(i,j)    = 0;</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     809 </span>            :       }
<span class="lineNum">     810 </span>            :     }
<span class="lineNum">     811 </span>            : 
<span class="lineNum">     812 </span>            :   }
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :   AliInfo(&quot;Step 2: Interpolation to Standard grid&quot;);</span>
<span class="lineNum">     815 </span>            : 
<span class="lineNum">     816 </span>            :   // -------------------------------------------------------------------------------
<span class="lineNum">     817 </span>            :   // Interpolate results onto the standard grid which is used for all AliTPCCorrections classes
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :   for ( Int_t k = 0 ; k &lt; kNPhi ; k++ ) {</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :     Double_t phi = fgkPhiList[k] ;</span>
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span>            :     // final lookup table
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :     TMatrixF &amp;erOverEzFinal   =  *fLookUpErOverEz[k]  ;</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :     TMatrixF &amp;ephiOverEzFinal =  *fLookUpEphiOverEz[k];</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :     TMatrixF &amp;deltaEzFinal    =  *fLookUpDeltaEz[k]   ;</span>
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :     for ( Int_t j = 0 ; j &lt; kNZ ; j++ ) {</span>
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :       z = TMath::Abs(fgkZList[j]) ;  // z position is symmetric</span>
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :       for ( Int_t i = 0 ; i &lt; kNR ; i++ ) {</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :         r = fgkRList[i] ;</span>
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span>            :         // Interpolate Lookup tables onto standard grid
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :         if (fgkZList[j]&gt;0) {</span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :           erOverEzFinal(i,j)   += Interpolate3DTable(order, r, z, phi, rows, columns, phiSlices,</span>
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :                                                rlist2, zedlist2, philist2, arrayofEroverEzA2  );</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :           ephiOverEzFinal(i,j) += Interpolate3DTable(order, r, z, phi, rows, columns, phiSlices,</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :                                                rlist2, zedlist2, philist2, arrayofEphioverEzA2);</span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :           deltaEzFinal(i,j)    += Interpolate3DTable(order, r, z, phi, rows, columns, phiSlices,</span>
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :                                                rlist2, zedlist2, philist2, arrayofDeltaEzA2   );</span>
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :           erOverEzFinal(i,j)   += Interpolate3DTable(order, r, z, phi, rows, columns, phiSlices,</span>
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :                                                rlist2, zedlist2, philist2, arrayofEroverEzC2  );</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :           ephiOverEzFinal(i,j) += Interpolate3DTable(order, r, z, phi, rows, columns, phiSlices,</span>
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :                                                rlist2, zedlist2, philist2, arrayofEphioverEzC2);</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :           deltaEzFinal(i,j)  -=  Interpolate3DTable(order, r, z, phi, rows, columns, phiSlices,</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :                                                rlist2, zedlist2, philist2, arrayofDeltaEzC2   );</span>
<span class="lineNum">     850 </span>            :         }
<span class="lineNum">     851 </span>            : 
<span class="lineNum">     852 </span>            :       } // end r loop
<span class="lineNum">     853 </span>            :     } // end z loop
<span class="lineNum">     854 </span>            :   } // end phi loop
<span class="lineNum">     855 </span>            : 
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span>            :   // clear the temporary arrays lists
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :   for ( Int_t k = 0 ; k &lt; phiSlices ; k++ )  {</span>
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :     delete arrayofErA2[k];</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :     delete arrayofEphiA2[k];</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :     delete arrayofdEzA2[k];</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :     delete arrayofErC2[k];</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :     delete arrayofEphiC2[k];</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :     delete arrayofdEzC2[k];</span>
<span class="lineNum">     866 </span>            : 
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :     delete arrayofEroverEzA2[k];</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :     delete arrayofEphioverEzA2[k];</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :     delete arrayofDeltaEzA2[k];</span>
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :     delete arrayofEroverEzC2[k];</span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :     delete arrayofEphioverEzC2[k];</span>
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :     delete arrayofDeltaEzC2[k];</span>
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            :   }
<span class="lineNum">     875 </span>            : 
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :   fRPhi-&gt;Close();</span>
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span>            :   // FINISHED
<span class="lineNum">     879 </span>            : 
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :   fInitLookUp = kTRUE;</span>
<span class="lineNum">     881 </span>            : 
<a name="882"><span class="lineNum">     882 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     883 </span>            : 
<span class="lineNum">     884 </span>            : void AliTPCSpaceCharge3D::InitSpaceCharge3DDistortionCourse() {
<span class="lineNum">     885 </span>            :   /// Initialization of the Lookup table which contains the solutions of the
<span class="lineNum">     886 </span>            :   /// &quot;space charge&quot; (poisson) problem
<span class="lineNum">     887 </span>            :   ///
<span class="lineNum">     888 </span>            :   /// The sum-up uses a look-up table which contains different discretized Space charge fields
<span class="lineNum">     889 </span>            :   /// in order to calculate the corresponding field deviations due to a given (discretized)
<span class="lineNum">     890 </span>            :   /// space charge distribution ....
<span class="lineNum">     891 </span>            :   ///
<span class="lineNum">     892 </span>            :   /// Method of calculation: Weighted sum-up of the different fields within the look up table
<span class="lineNum">     893 </span>            :   /// Note: Full 3d version: Course and slow ...
<span class="lineNum">     894 </span>            : 
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :   if (fInitLookUp) {</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :     AliInfo(&quot;Lookup table was already initialized!&quot;);</span>
<span class="lineNum">     897 </span>            :     //    return;
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     899 </span>            : 
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :   AliInfo(&quot;Preparation of the weighted look-up table&quot;);</span>
<span class="lineNum">     901 </span>            : 
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :   TFile *f = new TFile(fSCLookUpPOCsFileName3D.Data(),&quot;READ&quot;);</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :   if ( !f ) {</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :     AliError(&quot;Precalculated POC-looup-table could not be found&quot;);</span>
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     906 </span>            :   }
<span class="lineNum">     907 </span>            : 
<span class="lineNum">     908 </span>            :   // units are in [m]
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :   TVector *gridf  = (TVector*) f-&gt;Get(&quot;constants&quot;);</span>
<span class="lineNum">     910 </span>            :   TVector &amp;grid = *gridf;
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :   TMatrix *coordf  = (TMatrix*) f-&gt;Get(&quot;coordinates&quot;);</span>
<span class="lineNum">     912 </span>            :   TMatrix &amp;coord = *coordf;
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :   TMatrix *coordPOCf  = (TMatrix*) f-&gt;Get(&quot;POCcoord&quot;);</span>
<span class="lineNum">     914 </span>            :   TMatrix &amp;coordPOC = *coordPOCf;
<span class="lineNum">     915 </span>            : 
<span class="lineNum">     916 </span>            :   Bool_t flagRadSym = 0;
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :   if (grid(1)==1 &amp;&amp; grid(4)==1) {</span>
<span class="lineNum">     918 </span>            :     //   AliInfo(&quot;LOOK UP TABLE IS RADIAL SYMETTRIC - Field in Phi is ZERO&quot;);
<span class="lineNum">     919 </span>            :     flagRadSym=1;
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     921 </span>            : 
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :   Int_t rows      = (Int_t)grid(0);   // number of points in r direction</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :   Int_t phiSlices = (Int_t)grid(1);   // number of points in phi</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :   Int_t columns   = (Int_t)grid(2);   // number of points in z direction</span>
<span class="lineNum">     925 </span>            : 
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :   const Float_t gridSizeR   =  (fgkOFCRadius-fgkIFCRadius)/(rows-1);   // unit in [cm]</span>
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :   const Float_t gridSizePhi =  TMath::TwoPi()/phiSlices;         // unit in [rad]</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :   const Float_t gridSizeZ   =  fgkTPCZ0/(columns-1);                  // unit in [cm]</span>
<span class="lineNum">     929 </span>            : 
<span class="lineNum">     930 </span>            :   // temporary matrices needed for the calculation
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :   TMatrixD *arrayofErA[kNPhiSlices], *arrayofEphiA[kNPhiSlices], *arrayofdEzA[kNPhiSlices];</span>
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :   TMatrixD *arrayofErC[kNPhiSlices], *arrayofEphiC[kNPhiSlices], *arrayofdEzC[kNPhiSlices];</span>
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :   TMatrixD *arrayofEroverEzA[kNPhiSlices], *arrayofEphioverEzA[kNPhiSlices], *arrayofDeltaEzA[kNPhiSlices];</span>
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :   TMatrixD *arrayofEroverEzC[kNPhiSlices], *arrayofEphioverEzC[kNPhiSlices], *arrayofDeltaEzC[kNPhiSlices];</span>
<span class="lineNum">     936 </span>            : 
<span class="lineNum">     937 </span>            : 
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :   for ( Int_t k = 0 ; k &lt; phiSlices ; k++ ) {</span>
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :     arrayofErA[k]   =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :     arrayofEphiA[k] =   new TMatrixD(rows,columns) ; // zero if radial symmetric</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :     arrayofdEzA[k]  =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :     arrayofErC[k]   =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :     arrayofEphiC[k] =   new TMatrixD(rows,columns) ; // zero if radial symmetric</span>
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :     arrayofdEzC[k]  =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     946 </span>            : 
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :     arrayofEroverEzA[k]   =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :     arrayofEphioverEzA[k] =   new TMatrixD(rows,columns) ; // zero if radial symmetric</span>
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :     arrayofDeltaEzA[k]    =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :     arrayofEroverEzC[k]   =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :     arrayofEphioverEzC[k] =   new TMatrixD(rows,columns) ; // zero if radial symmetric</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :     arrayofDeltaEzC[k]    =   new TMatrixD(rows,columns) ;</span>
<span class="lineNum">     953 </span>            : 
<span class="lineNum">     954 </span>            :     // Set the values to zero the lookup tables
<span class="lineNum">     955 </span>            :     // not necessary, it is done in the constructor of TMatrix - code deleted
<span class="lineNum">     956 </span>            : 
<span class="lineNum">     957 </span>            :   }
<span class="lineNum">     958 </span>            : 
<span class="lineNum">     959 </span>            :   // list of points as used in the interpolation (during sum up)
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :   Double_t  rlist[kNRows], zedlist[kNColumns] , philist[kNPhiSlices];</span>
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :   for ( Int_t k = 0 ; k &lt; phiSlices ; k++ ) {</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :     philist[k] =  gridSizePhi * k;</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :     for ( Int_t i = 0 ; i &lt; rows ; i++ )    {</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :       rlist[i] = fgkIFCRadius + i*gridSizeR ;</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :       for ( Int_t j = 0 ; j &lt; columns ; j++ ) {</span>
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :         zedlist[j]  = j * gridSizeZ ;</span>
<span class="lineNum">     967 </span>            :       }
<span class="lineNum">     968 </span>            :     }
<span class="lineNum">     969 </span>            :   } // only done once
<span class="lineNum">     970 </span>            : 
<span class="lineNum">     971 </span>            : 
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :   TTree *treePOC = (TTree*)f-&gt;Get(&quot;POCall&quot;);</span>
<span class="lineNum">     973 </span>            : 
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :   TVector *bEr  = 0;   TVector *bEphi= 0;   TVector *bEz  = 0;</span>
<span class="lineNum">     975 </span>            : 
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :   treePOC-&gt;SetBranchAddress(&quot;Er&quot;,&amp;bEr);</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :   if (!flagRadSym) treePOC-&gt;SetBranchAddress(&quot;Ephi&quot;,&amp;bEphi);</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :   treePOC-&gt;SetBranchAddress(&quot;Ez&quot;,&amp;bEz);</span>
<span class="lineNum">     979 </span>            : 
<span class="lineNum">     980 </span>            : 
<span class="lineNum">     981 </span>            :   // Read the complete tree and do a weighted sum-up over the POC configurations
<span class="lineNum">     982 </span>            :   // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<span class="lineNum">     983 </span>            : 
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :   Int_t treeNumPOC = (Int_t)treePOC-&gt;GetEntries(); // Number of POC conf. in the look-up table</span>
<span class="lineNum">     985 </span>            :   Int_t ipC = 0; // POC Conf. counter (note: different to the POC number in the tree!)
<span class="lineNum">     986 </span>            : 
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :   for (Int_t itreepC=0; itreepC&lt;treeNumPOC; itreepC++) { // ------------- loop over POC configurations in tree</span>
<span class="lineNum">     988 </span>            : 
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :     treePOC-&gt;GetEntry(itreepC);</span>
<span class="lineNum">     990 </span>            : 
<span class="lineNum">     991 </span>            :     // center of the POC voxel in [meter]
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :     Double_t r0 = coordPOC(ipC,0);</span>
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :     Double_t phi0 = coordPOC(ipC,1);</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :     Double_t z0 = coordPOC(ipC,2);</span>
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :     ipC++; // POC configuration counter</span>
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span>            :     // weights (charge density) at POC position on the A and C side (in C/m^3/e0)
<span class="lineNum">     999 </span>            :     // note: coordinates are in [cm]
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :     Double_t weightA = GetSpaceChargeDensity(r0*100,phi0, z0*100);</span>
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :     Double_t weightC = GetSpaceChargeDensity(r0*100,phi0,-z0*100);</span>
<span class="lineNum">    1002 </span>            : 
<span class="lineNum">    1003 </span>            :     // Summing up the vector components according to their weight
<span class="lineNum">    1004 </span>            : 
<span class="lineNum">    1005 </span>            :     Int_t ip = 0;
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :     for ( Int_t j = 0 ; j &lt; columns ; j++ ) {</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :       for ( Int_t i = 0 ; i &lt; rows ; i++ )    {</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :         for ( Int_t k = 0 ; k &lt; phiSlices ; k++ ) {</span>
<span class="lineNum">    1009 </span>            : 
<span class="lineNum">    1010 </span>            :           // check wether the coordinates were screwed
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :           if (TMath::Abs((coord(0,ip)*100-rlist[i]))&gt;1 ||</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :               TMath::Abs((coord(1,ip)-philist[k]))&gt;1 ||</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :               TMath::Abs((coord(2,ip)*100-zedlist[j]))&gt;1) {</span>
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :             AliError(&quot;internal error: coordinate system was screwed during the sum-up&quot;);</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :             printf(&quot;lookup: (r,phi,z)=(%f,%f,%f)\n&quot;,coord(0,ip)*100,coord(1,ip),coord(2,ip)*100);</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :             printf(&quot;sum-up: (r,phi,z)=(%f,%f,%f)\n&quot;,rlist[i],philist[k],zedlist[j]);</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :             AliError(&quot;Don't trust the results of the space charge calculation!&quot;);</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    1019 </span>            : 
<span class="lineNum">    1020 </span>            :           // unfortunately, the lookup tables were produced to be faster for phi symmetric charges
<span class="lineNum">    1021 </span>            :           // This will be the most frequent usage (hopefully)
<span class="lineNum">    1022 </span>            :           // That's why we have to do this here ...
<span class="lineNum">    1023 </span>            : 
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :           TMatrixD &amp;erA   =  *arrayofErA[k]  ;</span>
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :           TMatrixD &amp;ephiA =  *arrayofEphiA[k];</span>
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :           TMatrixD &amp;dEzA  =  *arrayofdEzA[k]   ;</span>
<span class="lineNum">    1027 </span>            : 
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :           TMatrixD &amp;erC   =  *arrayofErC[k]  ;</span>
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :           TMatrixD &amp;ephiC =  *arrayofEphiC[k];</span>
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :           TMatrixD &amp;dEzC  =  *arrayofdEzC[k]   ;</span>
<span class="lineNum">    1031 </span>            : 
<span class="lineNum">    1032 </span>            :           // Sum up - Efield values in [V/m] -&gt; transition to [V/cm]
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :           erA(i,j) += ((*bEr)(ip)) * weightA /100;</span>
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :           erC(i,j) += ((*bEr)(ip)) * weightC /100;</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :           if (!flagRadSym) {</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :             ephiA(i,j) += ((*bEphi)(ip)) * weightA/100; // [V/rad]</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :             ephiC(i,j) += ((*bEphi)(ip)) * weightC/100; // [V/rad]</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :           dEzA(i,j)  += ((*bEz)(ip)) * weightA /100;</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :           dEzC(i,j)  += ((*bEz)(ip)) * weightC /100;</span>
<span class="lineNum">    1041 </span>            : 
<span class="lineNum">    1042 </span>            :           // increase the counter
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :           ip++;</span>
<span class="lineNum">    1044 </span>            :         }
<span class="lineNum">    1045 </span>            :       }
<span class="lineNum">    1046 </span>            :     } // end coordinate loop
<span class="lineNum">    1047 </span>            : 
<span class="lineNum">    1048 </span>            : 
<span class="lineNum">    1049 </span>            :     // Rotation and summation in the rest of the dPhiSteps
<span class="lineNum">    1050 </span>            :     // which were not stored in the this tree due to storage &amp; symmetry reasons
<span class="lineNum">    1051 </span>            : 
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :     Int_t phiPoints = (Int_t) grid(1);</span>
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :     Int_t phiPOC    = (Int_t) grid(4);</span>
<span class="lineNum">    1054 </span>            : 
<span class="lineNum">    1055 </span>            :     //   printf(&quot;%d %d\n&quot;,phiPOC,flagRadSym);
<span class="lineNum">    1056 </span>            : 
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :     for (Int_t phiiC = 1; phiiC&lt;phiPOC; phiiC++) { // just used for non-radial symetric table</span>
<span class="lineNum">    1058 </span>            : 
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :       r0 = coordPOC(ipC,0);</span>
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :       phi0 = coordPOC(ipC,1);</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :       z0 = coordPOC(ipC,2);</span>
<span class="lineNum">    1062 </span>            : 
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :       ipC++; // POC conf. counter</span>
<span class="lineNum">    1064 </span>            : 
<span class="lineNum">    1065 </span>            :       // weights (charge density) at POC position on the A and C side (in C/m^3/e0)
<span class="lineNum">    1066 </span>            :       // note: coordinates are in [cm]
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :       weightA = GetSpaceChargeDensity(r0*100,phi0, z0*100);</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :       weightC = GetSpaceChargeDensity(r0*100,phi0,-z0*100);</span>
<span class="lineNum">    1069 </span>            : 
<span class="lineNum">    1070 </span>            :       //     printf(&quot;%f %f %f: %e %e\n&quot;,r0,phi0,z0,weightA,weightC);
<span class="lineNum">    1071 </span>            : 
<span class="lineNum">    1072 </span>            :       // Summing up the vector components according to their weight
<span class="lineNum">    1073 </span>            :       ip = 0;
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :       for ( Int_t j = 0 ; j &lt; columns ; j++ ) {</span>
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :         for ( Int_t i = 0 ; i &lt; rows ; i++ )    {</span>
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :           for ( Int_t k = 0 ; k &lt; phiSlices ; k++ ) {</span>
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span>            :             // Note: rotating the coordinated during the sum up
<span class="lineNum">    1079 </span>            : 
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :             Int_t rotVal = (phiPoints/phiPOC)*phiiC;</span>
<span class="lineNum">    1081 </span>            :             Int_t ipR = -1;
<span class="lineNum">    1082 </span>            : 
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :             if ((ip%phiPoints)&gt;=rotVal) {</span>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :               ipR = ip-rotVal;</span>
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :             } else {</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :               ipR = ip+(phiPoints-rotVal);</span>
<span class="lineNum">    1087 </span>            :             }
<span class="lineNum">    1088 </span>            : 
<span class="lineNum">    1089 </span>            :             // unfortunately, the lookup tables were produced to be faster for phi symmetric charges
<span class="lineNum">    1090 </span>            :             // This will be the most frequent usage
<span class="lineNum">    1091 </span>            :             // That's why we have to do this here and not outside the loop ...
<span class="lineNum">    1092 </span>            : 
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :             TMatrixD &amp;erA   =  *arrayofErA[k]  ;</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :             TMatrixD &amp;ephiA =  *arrayofEphiA[k];</span>
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :             TMatrixD &amp;dEzA  =  *arrayofdEzA[k]   ;</span>
<span class="lineNum">    1096 </span>            : 
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :             TMatrixD &amp;erC   =  *arrayofErC[k]  ;</span>
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :             TMatrixD &amp;ephiC =  *arrayofEphiC[k];</span>
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :             TMatrixD &amp;dEzC  =  *arrayofdEzC[k]   ;</span>
<span class="lineNum">    1100 </span>            : 
<span class="lineNum">    1101 </span>            :             // Sum up - Efield values in [V/m] -&gt; transition to [V/cm]
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :             erA(i,j) += ((*bEr)(ipR)) * weightA /100;</span>
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :             erC(i,j) += ((*bEr)(ipR)) * weightC /100;</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :             if (!flagRadSym) {</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :               ephiA(i,j) += ((*bEphi)(ipR)) * weightA/100; // [V/rad]</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :               ephiC(i,j) += ((*bEphi)(ipR)) * weightC/100; // [V/rad]</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :             dEzA(i,j)  += ((*bEz)(ipR)) * weightA /100;</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :             dEzC(i,j)  += ((*bEz)(ipR)) * weightC /100;</span>
<span class="lineNum">    1110 </span>            : 
<span class="lineNum">    1111 </span>            :             // increase the counter
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :             ip++;</span>
<span class="lineNum">    1113 </span>            :           }
<span class="lineNum">    1114 </span>            :         }
<span class="lineNum">    1115 </span>            :       } // end coordinate loop
<span class="lineNum">    1116 </span>            : 
<span class="lineNum">    1117 </span>            :     } // end phi-POC summation (phiiC)
<span class="lineNum">    1118 </span>            : 
<span class="lineNum">    1119 </span>            : 
<span class="lineNum">    1120 </span>            :     // printf(&quot;POC: (r,phi,z) = (%f %f %f) | weight(A,C): %03.1lf %03.1lf\n&quot;,r0,phi0,z0, weightA, weightC);
<span class="lineNum">    1121 </span>            : 
<span class="lineNum">    1122 </span>            :   }
<span class="lineNum">    1123 </span>            : 
<span class="lineNum">    1124 </span>            : 
<span class="lineNum">    1125 </span>            : 
<span class="lineNum">    1126 </span>            :   // -------------------------------------------------------------------------------
<span class="lineNum">    1127 </span>            :   // Division by the Ez (drift) field and integration along z
<span class="lineNum">    1128 </span>            : 
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :   AliInfo(&quot;Division and integration&quot;);</span>
<span class="lineNum">    1130 </span>            : 
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :   Double_t ezField = (fgkCathodeV-fgkGG)/fgkTPCZ0; // = Electric Field (V/cm) Magnitude ~ -400 V/cm;</span>
<span class="lineNum">    1132 </span>            : 
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :   for ( Int_t k = 0 ; k &lt; phiSlices ; k++ ) { // phi loop</span>
<span class="lineNum">    1134 </span>            : 
<span class="lineNum">    1135 </span>            :     // matrices holding the solution - summation of POC charges // see above
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :     TMatrixD &amp;erA   =  *arrayofErA[k]  ;</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :     TMatrixD &amp;ephiA =  *arrayofEphiA[k];</span>
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :     TMatrixD &amp;dezA  =  *arrayofdEzA[k]   ;</span>
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :     TMatrixD &amp;erC   =  *arrayofErC[k]  ;</span>
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :     TMatrixD &amp;ephiC =  *arrayofEphiC[k];</span>
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :     TMatrixD &amp;dezC  =  *arrayofdEzC[k]   ;</span>
<span class="lineNum">    1142 </span>            : 
<span class="lineNum">    1143 </span>            :     // matrices which will contain the integrated fields (divided by the drift field)
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :     TMatrixD &amp;erOverEzA   =  *arrayofEroverEzA[k]  ;</span>
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :     TMatrixD &amp;ephiOverEzA =  *arrayofEphioverEzA[k];</span>
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :     TMatrixD &amp;deltaEzA    =  *arrayofDeltaEzA[k];</span>
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :     TMatrixD &amp;erOverEzC   =  *arrayofEroverEzC[k]  ;</span>
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :     TMatrixD &amp;ephiOverEzC =  *arrayofEphioverEzC[k];</span>
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :     TMatrixD &amp;deltaEzC    =  *arrayofDeltaEzC[k];</span>
<span class="lineNum">    1150 </span>            : 
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :     for ( Int_t i = 0 ; i &lt; rows ; i++ )    { // r loop</span>
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :       for ( Int_t j = columns-1 ; j &gt;= 0 ; j-- ) {// z loop</span>
<span class="lineNum">    1153 </span>            :         // Count backwards to facilitate integration over Z
<span class="lineNum">    1154 </span>            : 
<span class="lineNum">    1155 </span>            :         Int_t index = 1 ; // Simpsons rule if N=odd.If N!=odd then add extra point by trapezoidal rule.
<span class="lineNum">    1156 </span>            : 
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :         erOverEzA(i,j) = 0; ephiOverEzA(i,j) = 0;  deltaEzA(i,j) = 0;</span>
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :         erOverEzC(i,j) = 0; ephiOverEzC(i,j) = 0;  deltaEzC(i,j) = 0;</span>
<span class="lineNum">    1159 </span>            : 
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :         for ( Int_t m = j ; m &lt; columns ; m++ ) { // integration</span>
<span class="lineNum">    1161 </span>            : 
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :           erOverEzA(i,j)   += index*(gridSizeZ/3.0)*erA(i,m)/(-1*ezField) ;</span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :           erOverEzC(i,j)   += index*(gridSizeZ/3.0)*erC(i,m)/(-1*ezField)  ;</span>
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :           if (!flagRadSym) {</span>
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :             ephiOverEzA(i,j) += index*(gridSizeZ/3.0)*ephiA(i,m)/(-1*ezField)  ;</span>
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :             ephiOverEzC(i,j) += index*(gridSizeZ/3.0)*ephiC(i,m)/(-1*ezField)  ;</span>
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :           deltaEzA(i,j)    += index*(gridSizeZ/3.0)*dezA(i,m)/(-1) ;</span>
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :           deltaEzC(i,j)    += index*(gridSizeZ/3.0)*dezC(i,m)/(-1) ;</span>
<span class="lineNum">    1170 </span>            : 
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :           if ( index != 4 )  index = 4; else index = 2 ;</span>
<span class="lineNum">    1172 </span>            : 
<span class="lineNum">    1173 </span>            :         }
<span class="lineNum">    1174 </span>            : 
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :         if ( index == 4 ) {</span>
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 :           erOverEzA(i,j)   -= (gridSizeZ/3.0)*erA(i,columns-1)/(-1*ezField) ;</span>
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :           erOverEzC(i,j)   -= (gridSizeZ/3.0)*erC(i,columns-1)/(-1*ezField) ;</span>
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :           if (!flagRadSym) {</span>
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :             ephiOverEzA(i,j) -= (gridSizeZ/3.0)*ephiA(i,columns-1)/(-1*ezField) ;</span>
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :             ephiOverEzC(i,j) -= (gridSizeZ/3.0)*ephiC(i,columns-1)/(-1*ezField) ;</span>
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :           deltaEzA(i,j)    -= (gridSizeZ/3.0)*dezA(i,columns-1)/(-1) ;</span>
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :           deltaEzC(i,j)    -= (gridSizeZ/3.0)*dezC(i,columns-1)/(-1) ;</span>
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :         if ( index == 2 ) {</span>
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :           erOverEzA(i,j)   += (gridSizeZ/3.0)*(0.5*erA(i,columns-2)-2.5*erA(i,columns-1))/(-1*ezField) ;</span>
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :           erOverEzC(i,j)   += (gridSizeZ/3.0)*(0.5*erC(i,columns-2)-2.5*erC(i,columns-1))/(-1*ezField) ;</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :           if (!flagRadSym) {</span>
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :             ephiOverEzA(i,j) += (gridSizeZ/3.0)*(0.5*ephiA(i,columns-2)-2.5*ephiA(i,columns-1))/(-1*ezField) ;</span>
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :             ephiOverEzC(i,j) += (gridSizeZ/3.0)*(0.5*ephiC(i,columns-2)-2.5*ephiC(i,columns-1))/(-1*ezField) ;</span>
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :           deltaEzA(i,j)    += (gridSizeZ/3.0)*(0.5*dezA(i,columns-2)-2.5*dezA(i,columns-1))/(-1) ;</span>
<span class="lineNum">    1193 </span><span class="lineNoCov">          0 :           deltaEzC(i,j)    += (gridSizeZ/3.0)*(0.5*dezC(i,columns-2)-2.5*dezC(i,columns-1))/(-1) ;</span>
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :         if ( j == columns-2 ) {</span>
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :           erOverEzA(i,j)   = (gridSizeZ/3.0)*(1.5*erA(i,columns-2)+1.5*erA(i,columns-1))/(-1*ezField) ;</span>
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :           erOverEzC(i,j)   = (gridSizeZ/3.0)*(1.5*erC(i,columns-2)+1.5*erC(i,columns-1))/(-1*ezField) ;</span>
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :           if (!flagRadSym) {</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :             ephiOverEzA(i,j) = (gridSizeZ/3.0)*(1.5*ephiA(i,columns-2)+1.5*ephiA(i,columns-1))/(-1*ezField) ;</span>
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :             ephiOverEzC(i,j) = (gridSizeZ/3.0)*(1.5*ephiC(i,columns-2)+1.5*ephiC(i,columns-1))/(-1*ezField) ;</span>
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :           deltaEzA(i,j)    = (gridSizeZ/3.0)*(1.5*dezA(i,columns-2)+1.5*dezA(i,columns-1))/(-1) ;</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :           deltaEzC(i,j)    = (gridSizeZ/3.0)*(1.5*dezC(i,columns-2)+1.5*dezC(i,columns-1))/(-1) ;</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 :         if ( j == columns-1 ) {</span>
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :           erOverEzA(i,j)   = 0;</span>
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :           erOverEzC(i,j)   = 0;</span>
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :           if (!flagRadSym) {</span>
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :             ephiOverEzA(i,j) = 0;</span>
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :             ephiOverEzC(i,j) = 0;</span>
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :           deltaEzA(i,j)    = 0;</span>
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :           deltaEzC(i,j)    = 0;</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1215 </span>            :       }
<span class="lineNum">    1216 </span>            :     }
<span class="lineNum">    1217 </span>            : 
<span class="lineNum">    1218 </span>            :   }
<span class="lineNum">    1219 </span>            : 
<span class="lineNum">    1220 </span>            : 
<span class="lineNum">    1221 </span>            : 
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :   AliInfo(&quot;Interpolation to Standard grid&quot;);</span>
<span class="lineNum">    1223 </span>            : 
<span class="lineNum">    1224 </span>            :   // -------------------------------------------------------------------------------
<span class="lineNum">    1225 </span>            :   // Interpolate results onto the standard grid which is used for all AliTPCCorrections classes
<span class="lineNum">    1226 </span>            : 
<span class="lineNum">    1227 </span>            :   const Int_t order  = 1  ;  // Linear interpolation = 1, Quadratic = 2
<span class="lineNum">    1228 </span>            : 
<span class="lineNum">    1229 </span>            :   Double_t  r, phi, z ;
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :   for ( Int_t k = 0 ; k &lt; kNPhi ; k++ ) {</span>
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :     phi = fgkPhiList[k] ;</span>
<span class="lineNum">    1232 </span>            : 
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :     TMatrixF &amp;erOverEz   =  *fLookUpErOverEz[k]  ;</span>
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :     TMatrixF &amp;ephiOverEz =  *fLookUpEphiOverEz[k];</span>
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :     TMatrixF &amp;deltaEz    =  *fLookUpDeltaEz[k]   ;</span>
<span class="lineNum">    1236 </span>            : 
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :     for ( Int_t j = 0 ; j &lt; kNZ ; j++ ) {</span>
<span class="lineNum">    1238 </span>            : 
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :       z = TMath::Abs(fgkZList[j]) ;  // z position is symmetric</span>
<span class="lineNum">    1240 </span>            : 
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :       for ( Int_t i = 0 ; i &lt; kNR ; i++ ) {</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :         r = fgkRList[i] ;</span>
<span class="lineNum">    1243 </span>            : 
<span class="lineNum">    1244 </span>            :         // Interpolate Lookup tables onto standard grid
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :         if (fgkZList[j]&gt;0) {</span>
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 :           erOverEz(i,j)   = Interpolate3DTable(order, r, z, phi, rows, columns, phiSlices,</span>
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :                                                rlist, zedlist, philist, arrayofEroverEzA  );</span>
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :           ephiOverEz(i,j) = Interpolate3DTable(order, r, z, phi, rows, columns, phiSlices,</span>
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :                                                rlist, zedlist, philist, arrayofEphioverEzA);</span>
<span class="lineNum">    1250 </span><span class="lineNoCov">          0 :           deltaEz(i,j)    = Interpolate3DTable(order, r, z, phi, rows, columns, phiSlices,</span>
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :                                                rlist, zedlist, philist, arrayofDeltaEzA   );</span>
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :           erOverEz(i,j)   = Interpolate3DTable(order, r, z, phi, rows, columns, phiSlices,</span>
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :                                                rlist, zedlist, philist, arrayofEroverEzC  );</span>
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :           ephiOverEz(i,j) = Interpolate3DTable(order, r, z, phi, rows, columns, phiSlices,</span>
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :                                                rlist, zedlist, philist, arrayofEphioverEzC);</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :           deltaEz(i,j)  = - Interpolate3DTable(order, r, z, phi, rows, columns, phiSlices,</span>
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :                                                rlist, zedlist, philist, arrayofDeltaEzC   );</span>
<span class="lineNum">    1259 </span>            :           // negative coordinate system on C side
<span class="lineNum">    1260 </span>            :         }
<span class="lineNum">    1261 </span>            : 
<span class="lineNum">    1262 </span>            :       } // end r loop
<span class="lineNum">    1263 </span>            :     } // end z loop
<span class="lineNum">    1264 </span>            :   } // end phi loop
<span class="lineNum">    1265 </span>            : 
<span class="lineNum">    1266 </span>            : 
<span class="lineNum">    1267 </span>            :   // clear the temporary arrays lists
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :   for ( Int_t k = 0 ; k &lt; phiSlices ; k++ )  {</span>
<span class="lineNum">    1269 </span>            : 
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :     delete arrayofErA[k];</span>
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :     delete arrayofEphiA[k];</span>
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :     delete arrayofdEzA[k];</span>
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :     delete arrayofErC[k];</span>
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 :     delete arrayofEphiC[k];</span>
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :     delete arrayofdEzC[k];</span>
<span class="lineNum">    1276 </span>            : 
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :     delete arrayofEroverEzA[k];</span>
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :     delete arrayofEphioverEzA[k];</span>
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :     delete arrayofDeltaEzA[k];</span>
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :     delete arrayofEroverEzC[k];</span>
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :     delete arrayofEphioverEzC[k];</span>
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :     delete arrayofDeltaEzC[k];</span>
<span class="lineNum">    1283 </span>            : 
<span class="lineNum">    1284 </span>            :   }
<span class="lineNum">    1285 </span>            : 
<span class="lineNum">    1286 </span><span class="lineNoCov">          0 :   fInitLookUp = kTRUE;</span>
<span class="lineNum">    1287 </span>            : 
<a name="1288"><span class="lineNum">    1288 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1289 </span>            : 
<span class="lineNum">    1290 </span>            : void     AliTPCSpaceCharge3D::SetInputSpaceCharge(TH3 * hisSpaceCharge3D, Double_t norm){
<span class="lineNum">    1291 </span>            :   /// Use 3D space charge map as an optional input
<span class="lineNum">    1292 </span>            :   /// The layout of the input histogram is assumed to be: (phi,r,z)
<span class="lineNum">    1293 </span>            :   /// Density histogram is expreseed is expected to bin in  C/m^3
<span class="lineNum">    1294 </span>            :   ///
<span class="lineNum">    1295 </span>            :   /// Standard histogram interpolation is used in order to use the density at center of voxel
<span class="lineNum">    1296 </span>            : 
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 :   fSpaceChargeHistogram3D = hisSpaceCharge3D;</span>
<span class="lineNum">    1298 </span>            : 
<span class="lineNum">    1299 </span>            :   Double_t  r, phi, z ;
<span class="lineNum">    1300 </span>            :   //
<span class="lineNum">    1301 </span><span class="lineNoCov">          0 :   Double_t rmin=hisSpaceCharge3D-&gt;GetYaxis()-&gt;GetBinCenter(0);</span>
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 :   Double_t rmax=hisSpaceCharge3D-&gt;GetYaxis()-&gt;GetBinUpEdge(hisSpaceCharge3D-&gt;GetYaxis()-&gt;GetNbins());</span>
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :   Double_t zmin=hisSpaceCharge3D-&gt;GetZaxis()-&gt;GetBinCenter(0);</span>
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 :   Double_t zmax=hisSpaceCharge3D-&gt;GetZaxis()-&gt;GetBinCenter(hisSpaceCharge3D-&gt;GetZaxis()-&gt;GetNbins());</span>
<span class="lineNum">    1305 </span>            : 
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :   for ( Int_t k = 0 ; k &lt; kNPhi ; k++ ) {</span>
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :     phi = fgkPhiList[k] ;</span>
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :     TMatrixF &amp;scDensity   =  *fSCdensityDistribution[k]  ;</span>
<span class="lineNum">    1309 </span><span class="lineNoCov">          0 :     for ( Int_t j = 0 ; j &lt; kNZ ; j++ ) {</span>
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :       z = fgkZList[j] ;</span>
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 :       for ( Int_t i = 0 ; i &lt; kNR ; i++ ) {</span>
<span class="lineNum">    1312 </span>            :         // Full 3D configuration ...
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :         r = fgkRList[i] ;</span>
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :         if (r&gt;rmin &amp;&amp; r&lt;rmax &amp;&amp; z&gt;zmin &amp;&amp; z&lt; zmax){</span>
<span class="lineNum">    1315 </span>            :           // partial load in (r,z)
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :             scDensity(i,j) = norm*fSpaceChargeHistogram3D-&gt;Interpolate(phi,r,z);</span>
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1318 </span>            :       }
<span class="lineNum">    1319 </span>            :     }
<span class="lineNum">    1320 </span>            :   }
<span class="lineNum">    1321 </span>            : 
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :   fInitLookUp = kFALSE;</span>
<span class="lineNum">    1323 </span>            : 
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 : }</span>
<a name="1325"><span class="lineNum">    1325 </span>            : </a>
<span class="lineNum">    1326 </span>            : 
<span class="lineNum">    1327 </span>            : Float_t  AliTPCSpaceCharge3D::GetSpaceChargeDensity(Float_t r, Float_t phi, Float_t z) {
<span class="lineNum">    1328 </span>            :   /// returns the (input) space charge density at a given point according
<span class="lineNum">    1329 </span>            :   /// Note: input in [cm], output in [C/m^3/e0] !!
<span class="lineNum">    1330 </span>            : 
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :   while (phi&lt;0) phi += TMath::TwoPi();</span>
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :   while (phi&gt;TMath::TwoPi()) phi -= TMath::TwoPi();</span>
<span class="lineNum">    1333 </span>            : 
<span class="lineNum">    1334 </span>            : 
<span class="lineNum">    1335 </span>            :   // Float_t sc =fSCdensityDistribution-&gt;Interpolate(r0,phi0,z0);
<span class="lineNum">    1336 </span>            :   const Int_t order = 1; //
<span class="lineNum">    1337 </span>            : 
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :   const Float_t  sc = Interpolate3DTable(order, r, z, phi, kNR, kNZ, kNPhi,</span>
<span class="lineNum">    1339 </span><span class="lineNoCov">          0 :                       fgkRList, fgkZList, fgkPhiList, fSCdensityDistribution );</span>
<span class="lineNum">    1340 </span>            : 
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :   return sc;</span>
<span class="lineNum">    1342 </span>            : }
<a name="1343"><span class="lineNum">    1343 </span>            : </a>
<span class="lineNum">    1344 </span>            : 
<span class="lineNum">    1345 </span>            : TH2F * AliTPCSpaceCharge3D::CreateHistoSCinXY(Float_t z, Int_t nx, Int_t ny) {
<span class="lineNum">    1346 </span>            :   /// return a simple histogramm containing the space charge distribution (input for the calculation)
<span class="lineNum">    1347 </span>            : 
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 :   TH2F *h=CreateTH2F(&quot;spaceCharge&quot;,GetTitle(),&quot;x [cm]&quot;,&quot;y [cm]&quot;,&quot;#rho_{sc} [C/m^{3}/e_{0}]&quot;,</span>
<span class="lineNum">    1349 </span>            :                      nx,-250.,250.,ny,-250.,250.);
<span class="lineNum">    1350 </span>            : 
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :   for (Int_t iy=1;iy&lt;=ny;++iy) {</span>
<span class="lineNum">    1352 </span><span class="lineNoCov">          0 :     Double_t yp = h-&gt;GetYaxis()-&gt;GetBinCenter(iy);</span>
<span class="lineNum">    1353 </span><span class="lineNoCov">          0 :     for (Int_t ix=1;ix&lt;=nx;++ix) {</span>
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 :       Double_t xp = h-&gt;GetXaxis()-&gt;GetBinCenter(ix);</span>
<span class="lineNum">    1355 </span>            : 
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 :       Float_t r = TMath::Sqrt(xp*xp+yp*yp);</span>
<span class="lineNum">    1357 </span><span class="lineNoCov">          0 :       Float_t phi = TMath::ATan2(yp,xp);</span>
<span class="lineNum">    1358 </span>            : 
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :       if (85.&lt;=r &amp;&amp; r&lt;=250.) {</span>
<span class="lineNum">    1360 </span><span class="lineNoCov">          0 :         Float_t sc = GetSpaceChargeDensity(r,phi,z)/fgke0; // in [C/m^3/e0]</span>
<span class="lineNum">    1361 </span><span class="lineNoCov">          0 :         h-&gt;SetBinContent(ix,iy,sc);</span>
<span class="lineNum">    1362 </span><span class="lineNoCov">          0 :       } else {</span>
<span class="lineNum">    1363 </span><span class="lineNoCov">          0 :         h-&gt;SetBinContent(ix,iy,0.);</span>
<span class="lineNum">    1364 </span>            :       }
<span class="lineNum">    1365 </span>            :     }
<span class="lineNum">    1366 </span>            :   }
<span class="lineNum">    1367 </span>            : 
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :   return h;</span>
<a name="1369"><span class="lineNum">    1369 </span>            : }</a>
<span class="lineNum">    1370 </span>            : 
<span class="lineNum">    1371 </span>            : TH2F * AliTPCSpaceCharge3D::CreateHistoSCinZR(Float_t phi, Int_t nz, Int_t nr) {
<span class="lineNum">    1372 </span>            :   /// return a simple histogramm containing the space charge distribution (input for the calculation)
<span class="lineNum">    1373 </span>            : 
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :   TH2F *h=CreateTH2F(&quot;spaceCharge&quot;,GetTitle(),&quot;z [cm]&quot;,&quot;r [cm]&quot;,&quot;#rho_{sc} [C/m^{3}/e_{0}]&quot;,</span>
<span class="lineNum">    1375 </span>            :                      nz,-250.,250.,nr,85.,250.);
<span class="lineNum">    1376 </span>            : 
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :   for (Int_t ir=1;ir&lt;=nr;++ir) {</span>
<span class="lineNum">    1378 </span><span class="lineNoCov">          0 :     Float_t r = h-&gt;GetYaxis()-&gt;GetBinCenter(ir);</span>
<span class="lineNum">    1379 </span><span class="lineNoCov">          0 :     for (Int_t iz=1;iz&lt;=nz;++iz) {</span>
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :       Float_t z = h-&gt;GetXaxis()-&gt;GetBinCenter(iz);</span>
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :       Float_t sc = GetSpaceChargeDensity(r,phi,z)/fgke0; // in [C/m^3/e0]</span>
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 :       h-&gt;SetBinContent(iz,ir,sc);</span>
<span class="lineNum">    1383 </span>            :     }
<span class="lineNum">    1384 </span>            :   }
<span class="lineNum">    1385 </span>            : 
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 :   return h;</span>
<a name="1387"><span class="lineNum">    1387 </span>            : }</a>
<span class="lineNum">    1388 </span>            : 
<span class="lineNum">    1389 </span>            : void AliTPCSpaceCharge3D::WriteChargeDistributionToFile(const char* fname) {
<span class="lineNum">    1390 </span>            :   /// Example on how to write a Space charge distribution into a File
<span class="lineNum">    1391 </span>            :   ///  (see below: estimate from scaling STAR measurements to Alice)
<span class="lineNum">    1392 </span>            :   /// Charge distribution is splitted into two (RZ and RPHI) in order to speed up
<span class="lineNum">    1393 </span>            :   /// the needed calculation time
<span class="lineNum">    1394 </span>            : 
<span class="lineNum">    1395 </span><span class="lineNoCov">          0 :   TFile *f = new TFile(fname,&quot;RECREATE&quot;);</span>
<span class="lineNum">    1396 </span>            : 
<span class="lineNum">    1397 </span>            :   // some grid, not too course
<span class="lineNum">    1398 </span>            :   Int_t nr = 350;
<span class="lineNum">    1399 </span>            :   Int_t nphi = 180;
<span class="lineNum">    1400 </span>            :   Int_t nz = 500;
<span class="lineNum">    1401 </span>            : 
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 :   Double_t dr = (fgkOFCRadius-fgkIFCRadius)/(nr+1);</span>
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :   Double_t dphi = TMath::TwoPi()/(nphi+1);</span>
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 :   Double_t dz = 500./(nz+1);</span>
<span class="lineNum">    1405 </span>            :   Double_t safty = 0.; // due to a root bug which does not interpolate the boundary (first and last bin) correctly
<span class="lineNum">    1406 </span>            : 
<span class="lineNum">    1407 </span>            : 
<span class="lineNum">    1408 </span>            :   // Charge distribution in ZR (rotational symmetric) ------------------
<span class="lineNum">    1409 </span>            : 
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :   TH2F *histoZR = new TH2F(&quot;chargeZR&quot;,&quot;chargeZR&quot;,</span>
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :                            nr,fgkIFCRadius-dr-safty,fgkOFCRadius+dr+safty,</span>
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :                            nz,-250-dz-safty,250+dz+safty);</span>
<span class="lineNum">    1413 </span>            : 
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :   for (Int_t ir=1;ir&lt;=nr;++ir) {</span>
<span class="lineNum">    1415 </span><span class="lineNoCov">          0 :     Double_t rp = histoZR-&gt;GetXaxis()-&gt;GetBinCenter(ir);</span>
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :     for (Int_t iz=1;iz&lt;=nz;++iz) {</span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :       Double_t zp = histoZR-&gt;GetYaxis()-&gt;GetBinCenter(iz);</span>
<span class="lineNum">    1418 </span>            : 
<span class="lineNum">    1419 </span>            :       // recalculation to meter
<span class="lineNum">    1420 </span>            :       Double_t lZ = 2.5; // approx. TPC drift length
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 :       Double_t rpM = rp/100.; // in [m]</span>
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :       Double_t zpM = TMath::Abs(zp/100.); // in [m]</span>
<span class="lineNum">    1423 </span>            : 
<span class="lineNum">    1424 </span>            :       // setting of mb multiplicity and Interaction rate
<span class="lineNum">    1425 </span>            :       Double_t multiplicity = 950;
<span class="lineNum">    1426 </span>            :       Double_t intRate = 7800;
<span class="lineNum">    1427 </span>            : 
<span class="lineNum">    1428 </span>            :       // calculation of &quot;scaled&quot; parameters
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 :       Double_t a = multiplicity*intRate/79175;</span>
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :       Double_t b = a/lZ;</span>
<span class="lineNum">    1431 </span>            : 
<span class="lineNum">    1432 </span><span class="lineNoCov">          0 :       Double_t charge = (a - b*zpM)/(rpM*rpM); // charge in [C/m^3/e0]</span>
<span class="lineNum">    1433 </span>            : 
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :       charge = charge*fgke0; // [C/m^3]</span>
<span class="lineNum">    1435 </span>            : 
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :       if (zp&lt;0) charge *= 0.9; // e.g. slightly less on C side due to front absorber</span>
<span class="lineNum">    1437 </span>            : 
<span class="lineNum">    1438 </span>            :       //  charge = 0; // for tests
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :       histoZR-&gt;SetBinContent(ir,iz,charge);</span>
<span class="lineNum">    1440 </span>            :     }
<span class="lineNum">    1441 </span>            :   }
<span class="lineNum">    1442 </span>            : 
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :   histoZR-&gt;Write(&quot;SpaceChargeInRZ&quot;);</span>
<span class="lineNum">    1444 </span>            : 
<span class="lineNum">    1445 </span>            : 
<span class="lineNum">    1446 </span>            :   // Charge distribution in RPhi (e.g. Floating GG wire) ------------
<span class="lineNum">    1447 </span>            : 
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :   TH3F *histoRPhi = new TH3F(&quot;chargeRPhi&quot;,&quot;chargeRPhi&quot;,</span>
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :                              nr,fgkIFCRadius-dr-safty,fgkOFCRadius+dr+safty,</span>
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :                              nphi,0-dphi-safty,TMath::TwoPi()+dphi+safty,</span>
<span class="lineNum">    1451 </span>            :                              2,-1,1); // z part - to allow A and C side differences
<span class="lineNum">    1452 </span>            : 
<span class="lineNum">    1453 </span>            :   // some 'arbitrary' GG leaks
<span class="lineNum">    1454 </span>            :   Int_t   nGGleaks = 5;
<span class="lineNum">    1455 </span><span class="lineNoCov">          0 :   Double_t secPosA[5]    = {3,6,6,11,13};         // sector</span>
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 :   Double_t radialPosA[5] = {125,100,160,200,230}; // radius in cm</span>
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :   Double_t secPosC[5]    = {1,8,12,15,15};        // sector</span>
<span class="lineNum">    1458 </span><span class="lineNoCov">          0 :   Double_t radialPosC[5] = {245,120,140,120,190}; // radius in cm</span>
<span class="lineNum">    1459 </span>            : 
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :   for (Int_t ir=1;ir&lt;=nr;++ir) {</span>
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :     Double_t rp = histoRPhi-&gt;GetXaxis()-&gt;GetBinCenter(ir);</span>
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :     for (Int_t iphi=1;iphi&lt;=nphi;++iphi) {</span>
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :       Double_t phip = histoRPhi-&gt;GetYaxis()-&gt;GetBinCenter(iphi);</span>
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 :       for (Int_t iz=1;iz&lt;=2;++iz) {</span>
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :         Double_t zp = histoRPhi-&gt;GetZaxis()-&gt;GetBinCenter(iz);</span>
<span class="lineNum">    1466 </span>            : 
<span class="lineNum">    1467 </span>            :         Double_t charge = 0;
<span class="lineNum">    1468 </span>            : 
<span class="lineNum">    1469 </span><span class="lineNoCov">          0 :         for (Int_t igg = 0; igg&lt;nGGleaks; igg++) { // loop over GG leaks</span>
<span class="lineNum">    1470 </span>            : 
<span class="lineNum">    1471 </span>            :           // A side
<span class="lineNum">    1472 </span><span class="lineNoCov">          0 :           Double_t secPos = secPosA[igg];</span>
<span class="lineNum">    1473 </span><span class="lineNoCov">          0 :           Double_t radialPos = radialPosA[igg];</span>
<span class="lineNum">    1474 </span>            : 
<span class="lineNum">    1475 </span><span class="lineNoCov">          0 :           if (zp&lt;0) { // C side</span>
<span class="lineNum">    1476 </span><span class="lineNoCov">          0 :             secPos = secPosC[igg];</span>
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :             radialPos = radialPosC[igg];</span>
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    1479 </span>            : 
<span class="lineNum">    1480 </span>            :           // some 'arbitrary' GG leaks
<span class="lineNum">    1481 </span><span class="lineNoCov">          0 :           if (  (phip&lt;(TMath::Pi()/9*(secPos+1)) &amp;&amp; phip&gt;(TMath::Pi()/9*secPos) ) ) { // sector slice</span>
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 :             if ( rp&gt;(radialPos-2.5) &amp;&amp; rp&lt;(radialPos+2.5))  // 5 cm slice</span>
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 :               charge = 300;</span>
<span class="lineNum">    1484 </span>            :           }
<span class="lineNum">    1485 </span>            : 
<span class="lineNum">    1486 </span>            :         }
<span class="lineNum">    1487 </span>            : 
<span class="lineNum">    1488 </span><span class="lineNoCov">          0 :         charge = charge*fgke0; // [C/m^3]</span>
<span class="lineNum">    1489 </span>            : 
<span class="lineNum">    1490 </span><span class="lineNoCov">          0 :         histoRPhi-&gt;SetBinContent(ir,iphi,iz,charge);</span>
<span class="lineNum">    1491 </span>            :       }
<span class="lineNum">    1492 </span>            :     }
<span class="lineNum">    1493 </span>            :   }
<span class="lineNum">    1494 </span>            : 
<span class="lineNum">    1495 </span><span class="lineNoCov">          0 :   histoRPhi-&gt;Write(&quot;SpaceChargeInRPhi&quot;);</span>
<span class="lineNum">    1496 </span>            : 
<span class="lineNum">    1497 </span><span class="lineNoCov">          0 :   f-&gt;Close();</span>
<span class="lineNum">    1498 </span>            : 
<span class="lineNum">    1499 </span><span class="lineNoCov">          0 : }</span>
<a name="1500"><span class="lineNum">    1500 </span>            : </a>
<span class="lineNum">    1501 </span>            : 
<span class="lineNum">    1502 </span>            : void AliTPCSpaceCharge3D::Print(const Option_t* option) const {
<span class="lineNum">    1503 </span>            :   /// Print function to check the settings of the boundary vectors
<span class="lineNum">    1504 </span>            :   /// option==&quot;a&quot; prints the C0 and C1 coefficents for calibration purposes
<span class="lineNum">    1505 </span>            : 
<span class="lineNum">    1506 </span><span class="lineNoCov">          0 :   TString opt = option; opt.ToLower();</span>
<span class="lineNum">    1507 </span><span class="lineNoCov">          0 :   printf(&quot;%s\n&quot;,GetTitle());</span>
<span class="lineNum">    1508 </span><span class="lineNoCov">          0 :   printf(&quot; - Space Charge effect with arbitrary 3D charge density (as input).\n&quot;);</span>
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :   printf(&quot;   SC correction factor: %f \n&quot;,fCorrectionFactor);</span>
<span class="lineNum">    1510 </span>            : 
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :   if (opt.Contains(&quot;a&quot;)) { // Print all details</span>
<span class="lineNum">    1512 </span><span class="lineNoCov">          0 :     printf(&quot; - T1: %1.4f, T2: %1.4f \n&quot;,fT1,fT2);</span>
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :     printf(&quot; - C1: %1.4f, C0: %1.4f \n&quot;,fC1,fC0);</span>
<span class="lineNum">    1514 </span>            :   }
<span class="lineNum">    1515 </span>            : 
<span class="lineNum">    1516 </span><span class="lineNoCov">          0 :   if (!fInitLookUp) AliError(&quot;Lookup table was not initialized! You should do InitSpaceCharge3DDistortion() ...&quot;);</span>
<span class="lineNum">    1517 </span>            : 
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1519 </span>            : 
<a name="1520"><span class="lineNum">    1520 </span>            : </a>
<span class="lineNum">    1521 </span>            : 
<span class="lineNum">    1522 </span>            : void AliTPCSpaceCharge3D::InitSpaceCharge3DPoisson(Int_t kRows, Int_t kColumns, Int_t kPhiSlices,
<span class="lineNum">    1523 </span>            :                                                    Int_t kIterations, IntegrationType integrationType/*=kIntegral*/){
<span class="lineNum">    1524 </span>            :   /// MI extension  - calculate E field
<span class="lineNum">    1525 </span>            :   /// - inspired by  AliTPCROCVoltError3D::InitROCVoltError3D()
<span class="lineNum">    1526 </span>            :   /// Initialization of the Lookup table which contains the solutions of the
<span class="lineNum">    1527 </span>            :   /// Dirichlet boundary problem
<span class="lineNum">    1528 </span>            :   /// Calculation of the single 3D-Poisson solver is done just if needed
<span class="lineNum">    1529 </span>            :   /// (see basic lookup tables in header file)
<span class="lineNum">    1530 </span>            : 
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :   Int_t kPhiSlicesPerSector = kPhiSlices/18;</span>
<span class="lineNum">    1532 </span>            :   //
<span class="lineNum">    1533 </span>            :   const Int_t   order       =    1  ;  // Linear interpolation = 1, Quadratic = 2
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :   const Float_t gridSizeR   =  (fgkOFCRadius-fgkIFCRadius) / (kRows-1) ;</span>
<span class="lineNum">    1535 </span><span class="lineNoCov">          0 :   const Float_t gridSizeZ   =  fgkTPCZ0 / (kColumns-1) ;</span>
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 :   const Float_t gridSizePhi =  TMath::TwoPi() / ( 18.0 * kPhiSlicesPerSector);</span>
<span class="lineNum">    1537 </span>            : 
<span class="lineNum">    1538 </span>            :   // temporary arrays to create the boundary conditions
<span class="lineNum">    1539 </span><span class="lineNoCov">          0 :   TMatrixD *arrayofArrayV[kPhiSlices], *arrayofCharge[kPhiSlices] ;</span>
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :   TMatrixD *arrayofEroverEz[kPhiSlices], *arrayofEphioverEz[kPhiSlices], *arrayofDeltaEz[kPhiSlices] ;</span>
<span class="lineNum">    1541 </span>            : 
<span class="lineNum">    1542 </span><span class="lineNoCov">          0 :   for ( Int_t k = 0 ; k &lt; kPhiSlices ; k++ ) {</span>
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :     arrayofArrayV[k]     =   new TMatrixD(kRows,kColumns) ;</span>
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :     arrayofCharge[k]     =   new TMatrixD(kRows,kColumns) ;</span>
<span class="lineNum">    1545 </span><span class="lineNoCov">          0 :     arrayofEroverEz[k]   =   new TMatrixD(kRows,kColumns) ;</span>
<span class="lineNum">    1546 </span><span class="lineNoCov">          0 :     arrayofEphioverEz[k] =   new TMatrixD(kRows,kColumns) ;</span>
<span class="lineNum">    1547 </span><span class="lineNoCov">          0 :     arrayofDeltaEz[k]    =   new TMatrixD(kRows,kColumns) ;</span>
<span class="lineNum">    1548 </span>            :   }
<span class="lineNum">    1549 </span>            : 
<span class="lineNum">    1550 </span>            :   // list of point as used in the poisson relation and the interpolation (during sum up)
<span class="lineNum">    1551 </span><span class="lineNoCov">          0 :   Double_t  rlist[kRows], zedlist[kColumns] , philist[kPhiSlices];</span>
<span class="lineNum">    1552 </span><span class="lineNoCov">          0 :   for ( Int_t k = 0 ; k &lt; kPhiSlices ; k++ ) {</span>
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :     philist[k] =  gridSizePhi * k;</span>
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :     for ( Int_t i = 0 ; i &lt; kRows ; i++ )    {</span>
<span class="lineNum">    1555 </span><span class="lineNoCov">          0 :       rlist[i] = fgkIFCRadius + i*gridSizeR ;</span>
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 :       for ( Int_t j = 0 ; j &lt; kColumns ; j++ ) { // Fill Vmatrix with Boundary Conditions</span>
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :         zedlist[j]  = j * gridSizeZ ;</span>
<span class="lineNum">    1558 </span>            :       }
<span class="lineNum">    1559 </span>            :     }
<span class="lineNum">    1560 </span>            :   }
<span class="lineNum">    1561 </span>            : 
<span class="lineNum">    1562 </span>            :   // ==========================================================================
<span class="lineNum">    1563 </span>            :   // Solve Poisson's equation in 3D cylindrical coordinates by relaxation technique
<span class="lineNum">    1564 </span>            :   // Allow for different size grid spacing in R and Z directions
<span class="lineNum">    1565 </span>            : 
<span class="lineNum">    1566 </span>            :   const Int_t   symmetry = 0;
<span class="lineNum">    1567 </span>            : 
<span class="lineNum">    1568 </span>            :   // Set bondaries and solve Poisson's equation --------------------------
<span class="lineNum">    1569 </span>            : 
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :   if ( !fInitLookUp ) {</span>
<span class="lineNum">    1571 </span>            : 
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :     AliInfo(Form(&quot;Solving the poisson equation (~ %d sec)&quot;,2*10*(int)(kPhiSlices/10)));</span>
<span class="lineNum">    1573 </span>            : 
<span class="lineNum">    1574 </span><span class="lineNoCov">          0 :     for ( Int_t side = 0 ; side &lt; 2 ; side++ ) {  // Solve Poisson3D twice; once for +Z and once for -Z</span>
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :       AliSysInfo::AddStamp(&quot;RunSide&quot;, 1,side,0);</span>
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 :       for ( Int_t k = 0 ; k &lt; kPhiSlices ; k++ )  {</span>
<span class="lineNum">    1577 </span><span class="lineNoCov">          0 :         TMatrixD &amp;arrayV    =  *arrayofArrayV[k] ;</span>
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 :         TMatrixD &amp;charge    =  *arrayofCharge[k] ;</span>
<span class="lineNum">    1579 </span>            : 
<span class="lineNum">    1580 </span>            :         //Fill arrays with initial conditions.  V on the boundary and Charge in the volume.
<span class="lineNum">    1581 </span>            : //      for ( Int_t i = 0 ; i &lt; kRows ; i++ ) {
<span class="lineNum">    1582 </span>            : //        for ( Int_t j = 0 ; j &lt; kColumns ; j++ ) {  // Fill Vmatrix with Boundary Conditions
<span class="lineNum">    1583 </span>            : //          arrayV(i,j) = 0.0 ;
<span class="lineNum">    1584 </span>            : //          charge(i,j) = 0.0 ;
<span class="lineNum">    1585 </span>            : 
<span class="lineNum">    1586 </span>            : // //       Float_t radius0 = rlist[i] ;
<span class="lineNum">    1587 </span>            : // //       Float_t phi0    = gridSizePhi * k ;
<span class="lineNum">    1588 </span>            : 
<span class="lineNum">    1589 </span>            : //          // To avoid problems at sector boundaries, use an average of +- 1 degree from actual phi location
<span class="lineNum">    1590 </span>            : // //       if ( j == (kColumns-1) ) {
<span class="lineNum">    1591 </span>            : // //         arrayV(i,j) = 0.5*  ( GetROCVoltOffset( side, radius0, phi0+0.02 ) + GetROCVoltOffset( side, radius0, phi0-0.02 ) ) ;
<span class="lineNum">    1592 </span>            : 
<span class="lineNum">    1593 </span>            : // //         if (side==1) // C side
<span class="lineNum">    1594 </span>            : // //           arrayV(i,j) = -arrayV(i,j); // minus sign on the C side to allow a consistent usage of global z when setting the boundaries
<span class="lineNum">    1595 </span>            : // //       }
<span class="lineNum">    1596 </span>            : //        }
<span class="lineNum">    1597 </span>            : //      }
<span class="lineNum">    1598 </span>            : 
<span class="lineNum">    1599 </span><span class="lineNoCov">          0 :         for ( Int_t i = 1 ; i &lt; kRows-1 ; i++ ) {</span>
<span class="lineNum">    1600 </span><span class="lineNoCov">          0 :           for ( Int_t j = 1 ; j &lt; kColumns-1 ; j++ ) {</span>
<span class="lineNum">    1601 </span><span class="lineNoCov">          0 :             Float_t radius0 = rlist[i] ;</span>
<span class="lineNum">    1602 </span><span class="lineNoCov">          0 :             Float_t phi0    = gridSizePhi * k ;</span>
<span class="lineNum">    1603 </span><span class="lineNoCov">          0 :             Double_t z0 = zedlist[j];</span>
<span class="lineNum">    1604 </span><span class="lineNoCov">          0 :             if (side==1) z0= -TMath::Abs(zedlist[j]);</span>
<span class="lineNum">    1605 </span><span class="lineNoCov">          0 :             arrayV(i,j) = 0.0 ;</span>
<span class="lineNum">    1606 </span><span class="lineNoCov">          0 :             charge(i,j)  =  fSpaceChargeHistogram3D-&gt;Interpolate(phi0,radius0,z0);</span>
<span class="lineNum">    1607 </span>            :           }
<span class="lineNum">    1608 </span>            :         }
<span class="lineNum">    1609 </span>            :       }
<span class="lineNum">    1610 </span><span class="lineNoCov">          0 :       AliSysInfo::AddStamp(&quot;RunPoisson&quot;, 2,side,0);</span>
<span class="lineNum">    1611 </span>            : 
<span class="lineNum">    1612 </span>            :       // Solve Poisson's equation in 3D cylindrical coordinates by relaxation technique
<span class="lineNum">    1613 </span>            :       // Allow for different size grid spacing in R and Z directions
<span class="lineNum">    1614 </span>            : 
<span class="lineNum">    1615 </span>            :       //      PoissonRelaxation3D( arrayofArrayV, arrayofCharge,
<span class="lineNum">    1616 </span>            :       //                           arrayofEroverEz, arrayofEphioverEz, arrayofDeltaEz,
<span class="lineNum">    1617 </span>            :       //                           kRows, kColumns, kPhiSlices, gridSizePhi, kIterations,
<span class="lineNum">    1618 </span>            :       //                           symmetry , fROCdisplacement) ;
<span class="lineNum">    1619 </span>            :       // TODO: Check if ROCdisplacement == kTRUE is fine (second last parameter)
<span class="lineNum">    1620 </span><span class="lineNoCov">          0 :       PoissonRelaxation3D( arrayofArrayV, arrayofCharge,</span>
<span class="lineNum">    1621 </span>            :                            arrayofEroverEz, arrayofEphioverEz, arrayofDeltaEz,
<span class="lineNum">    1622 </span>            :                            kRows, kColumns, kPhiSlices, gridSizePhi, kIterations,
<span class="lineNum">    1623 </span>            :                            symmetry, kTRUE,integrationType ) ;
<span class="lineNum">    1624 </span>            : 
<span class="lineNum">    1625 </span>            :       //Interpolate results onto a custom grid which is used just for these calculations.
<span class="lineNum">    1626 </span>            :       Double_t  r, phi, z ;
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 :       for ( Int_t k = 0 ; k &lt; kNPhi ; k++ ) {</span>
<span class="lineNum">    1628 </span><span class="lineNoCov">          0 :         phi = fgkPhiList[k] ;</span>
<span class="lineNum">    1629 </span>            : 
<span class="lineNum">    1630 </span><span class="lineNoCov">          0 :         TMatrixF &amp;erOverEz   =  *fLookUpErOverEz[k]  ;</span>
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 :         TMatrixF &amp;ephiOverEz =  *fLookUpEphiOverEz[k];</span>
<span class="lineNum">    1632 </span><span class="lineNoCov">          0 :         TMatrixF &amp;deltaEz    =  *fLookUpDeltaEz[k]   ;</span>
<span class="lineNum">    1633 </span>            : 
<span class="lineNum">    1634 </span><span class="lineNoCov">          0 :         for ( Int_t j = 0 ; j &lt; kNZ ; j++ ) {</span>
<span class="lineNum">    1635 </span>            : 
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :           z = TMath::Abs(fgkZList[j]) ;  // Symmetric solution in Z that depends only on ABS(Z)</span>
<span class="lineNum">    1637 </span>            : 
<span class="lineNum">    1638 </span><span class="lineNoCov">          0 :           if ( side == 0 &amp;&amp;  fgkZList[j] &lt; 0 ) continue; // Skip rest of this loop if on the wrong side</span>
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 :           if ( side == 1 &amp;&amp;  fgkZList[j] &gt; 0 ) continue; // Skip rest of this loop if on the wrong side</span>
<span class="lineNum">    1640 </span>            : 
<span class="lineNum">    1641 </span><span class="lineNoCov">          0 :           for ( Int_t i = 0 ; i &lt; kNR ; i++ ) {</span>
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 :             r = fgkRList[i] ;</span>
<span class="lineNum">    1643 </span>            : 
<span class="lineNum">    1644 </span>            :             // Interpolate basicLookup tables; once for each rod, then sum the results
<span class="lineNum">    1645 </span><span class="lineNoCov">          0 :             erOverEz(i,j)   = Interpolate3DTable(order, r, z, phi, kRows, kColumns, kPhiSlices,</span>
<span class="lineNum">    1646 </span>            :                                                  rlist, zedlist, philist, arrayofEroverEz  );
<span class="lineNum">    1647 </span><span class="lineNoCov">          0 :             ephiOverEz(i,j) = Interpolate3DTable(order, r, z, phi, kRows, kColumns, kPhiSlices,</span>
<span class="lineNum">    1648 </span>            :                                                  rlist, zedlist, philist, arrayofEphioverEz);
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 :             deltaEz(i,j)    = Interpolate3DTable(order, r, z, phi, kRows, kColumns, kPhiSlices,</span>
<span class="lineNum">    1650 </span>            :                                                  rlist, zedlist, philist, arrayofDeltaEz  );
<span class="lineNum">    1651 </span>            : 
<span class="lineNum">    1652 </span><span class="lineNoCov">          0 :             if (side == 1)  deltaEz(i,j) = -  deltaEz(i,j); // negative coordinate system on C side</span>
<span class="lineNum">    1653 </span>            : 
<span class="lineNum">    1654 </span>            :           } // end r loop
<span class="lineNum">    1655 </span><span class="lineNoCov">          0 :         }// end z loop</span>
<span class="lineNum">    1656 </span>            :       }// end phi loop
<span class="lineNum">    1657 </span><span class="lineNoCov">          0 :       AliSysInfo::AddStamp(&quot;Interpolate Poisson&quot;, 3,side,0);</span>
<span class="lineNum">    1658 </span><span class="lineNoCov">          0 :       if ( side == 0 ) AliInfo(&quot; A side done&quot;);</span>
<span class="lineNum">    1659 </span><span class="lineNoCov">          0 :       if ( side == 1 ) AliInfo(&quot; C side done&quot;);</span>
<span class="lineNum">    1660 </span>            :     } // end side loop
<span class="lineNum">    1661 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1662 </span>            : 
<span class="lineNum">    1663 </span>            :   // clear the temporary arrays lists
<span class="lineNum">    1664 </span><span class="lineNoCov">          0 :   for ( Int_t k = 0 ; k &lt; kPhiSlices ; k++ )  {</span>
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :     delete arrayofArrayV[k];</span>
<span class="lineNum">    1666 </span><span class="lineNoCov">          0 :     delete arrayofCharge[k];</span>
<span class="lineNum">    1667 </span><span class="lineNoCov">          0 :     delete arrayofEroverEz[k];</span>
<span class="lineNum">    1668 </span><span class="lineNoCov">          0 :     delete arrayofEphioverEz[k];</span>
<span class="lineNum">    1669 </span><span class="lineNoCov">          0 :     delete arrayofDeltaEz[k];</span>
<span class="lineNum">    1670 </span>            :   }
<span class="lineNum">    1671 </span>            : 
<span class="lineNum">    1672 </span>            : 
<span class="lineNum">    1673 </span><span class="lineNoCov">          0 :   fInitLookUp = kTRUE;</span>
<span class="lineNum">    1674 </span>            : 
<span class="lineNum">    1675 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1676 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
