<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - TPC/TPCbase/AliTPCCalibCE.cxx</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">TPC/TPCbase</a> - AliTPCCalibCE.cxx<span style="font-size: 80%;"> (source / <a href="AliTPCCalibCE.cxx.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">1690</td>
            <td class="headerCovTableEntryLo">0.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">61</td>
            <td class="headerCovTableEntryLo">1.6 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**************************************************************************</a>
<span class="lineNum">       2 </span>            :  * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
<span class="lineNum">       3 </span>            :  *                                                                        *
<span class="lineNum">       4 </span>            :  * Author: The ALICE Off-line Project.                                    *
<span class="lineNum">       5 </span>            :  * Contributors are mentioned in the code where appropriate.              *
<span class="lineNum">       6 </span>            :  *                                                                        *
<span class="lineNum">       7 </span>            :  * Permission to use, copy, modify and distribute this software and its   *
<span class="lineNum">       8 </span>            :  * documentation strictly for non-commercial purposes is hereby granted   *
<span class="lineNum">       9 </span>            :  * without fee, provided that the above copyright notice appears in all   *
<span class="lineNum">      10 </span>            :  * copies and that both the copyright notice and this permission notice   *
<span class="lineNum">      11 </span>            :  * appear in the supporting documentation. The authors make no claims     *
<span class="lineNum">      12 </span>            :  * about the suitability of this software for any purpose. It is          *
<span class="lineNum">      13 </span>            :  * provided &quot;as is&quot; without express or implied warranty.                  *
<span class="lineNum">      14 </span>            :  **************************************************************************/
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : /// \class AliTPCCalibCE
<span class="lineNum">      17 </span>            : /// \brief Implementation of the TPC Central Electrode calibration
<span class="lineNum">      18 </span>            : ///
<span class="lineNum">      19 </span>            : /// \author Jens Wiechula, Marian Ivanov   J.Wiechula@gsi.de, Marian.Ivanov@cern.ch
<span class="lineNum">      20 </span>            : ///
<span class="lineNum">      21 </span>            : /// Class Description
<span class="lineNum">      22 </span>            : /// The AliTPCCalibCE class is used to get calibration data from the Central Electrode
<span class="lineNum">      23 </span>            : /// using laser runs.
<span class="lineNum">      24 </span>            : ///
<span class="lineNum">      25 </span>            : ///  The information retrieved is
<span class="lineNum">      26 </span>            : ///  &lt;ul style=&quot;list-style-type: square;&quot;&gt;
<span class="lineNum">      27 </span>            : ///    &lt;li&gt;Time arrival from the CE&lt;/li&gt;
<span class="lineNum">      28 </span>            : ///    &lt;li&gt;Signal width&lt;/li&gt;
<span class="lineNum">      29 </span>            : ///    &lt;li&gt;Signal sum&lt;/li&gt;
<span class="lineNum">      30 </span>            : ///  &lt;/ul&gt;
<span class="lineNum">      31 </span>            : ///
<span class="lineNum">      32 </span>            : /// &lt;h4&gt;Overview:&lt;/h4&gt;
<span class="lineNum">      33 </span>            : ///  &lt;ol style=&quot;list-style-type: upper-roman;&quot;&gt;
<span class="lineNum">      34 </span>            : ///    &lt;li&gt;&lt;a href=&quot;#working&quot;&gt;Working principle&lt;/a&gt;&lt;/li&gt;
<span class="lineNum">      35 </span>            : ///    &lt;li&gt;&lt;a href=&quot;#user&quot;&gt;User interface for filling data&lt;/a&gt;&lt;/li&gt;
<span class="lineNum">      36 </span>            : ///    &lt;li&gt;&lt;a href=&quot;#info&quot;&gt;Stored information&lt;/a&gt;&lt;/li&gt;
<span class="lineNum">      37 </span>            : ///  &lt;/ol&gt;
<span class="lineNum">      38 </span>            : ///
<span class="lineNum">      39 </span>            : ///  &lt;h3&gt;&lt;a name=&quot;working&quot;&gt;I. Working principle&lt;/a&gt;&lt;/h3&gt;
<span class="lineNum">      40 </span>            : ///
<span class="lineNum">      41 </span>            : ///  &lt;h4&gt;Raw laser data is processed by calling one of the ProcessEvent(...) functions
<span class="lineNum">      42 </span>            : ///  (see below). These in the end call the Update(...) function.&lt;/h4&gt;
<span class="lineNum">      43 </span>            : ///
<span class="lineNum">      44 </span>            : ///  &lt;ul style=&quot;list-style-type: square;&quot;&gt;
<span class="lineNum">      45 </span>            : ///    &lt;li&gt;the Update(...) function:&lt;br /&gt;
<span class="lineNum">      46 </span>            : ///        In this function the array fPadSignal is filled with the adc signals between the specified range
<span class="lineNum">      47 </span>            : ///        fFirstTimeBin and fLastTimeBin for the current pad.
<span class="lineNum">      48 </span>            : ///        before going to the next pad the ProcessPad() function is called, which analyses the data for one pad
<span class="lineNum">      49 </span>            : ///        stored in fPadSignal.
<span class="lineNum">      50 </span>            : ///    &lt;/li&gt;
<span class="lineNum">      51 </span>            : ///    &lt;ul style=&quot;list-style-type: square;&quot;&gt;
<span class="lineNum">      52 </span>            : ///    &lt;li&gt;the ProcessPad() function:&lt;/li&gt;
<span class="lineNum">      53 </span>            : ///    &lt;ol style=&quot;list-style-type: decimal;&quot;&gt;
<span class="lineNum">      54 </span>            : ///      &lt;li&gt;Find Pedestal and Noise information&lt;/li&gt;
<span class="lineNum">      55 </span>            : ///      &lt;ul style=&quot;list-style-type: square;&quot;&gt;
<span class="lineNum">      56 </span>            : ///        &lt;li&gt;use database information which has to be set by calling&lt;br /&gt;
<span class="lineNum">      57 </span>            : ///            SetPedestalDatabase(AliTPCCalPad *pedestalTPC, AliTPCCalPad *padNoiseTPC)&lt;/li&gt;
<span class="lineNum">      58 </span>            : ///        &lt;li&gt;if no information from the pedestal data base
<span class="lineNum">      59 </span>            : ///            is available the informaion is calculated on the fly
<span class="lineNum">      60 </span>            : ///            ( see FindPedestal() function )&lt;/li&gt;
<span class="lineNum">      61 </span>            : ///      &lt;/ul&gt;
<span class="lineNum">      62 </span>            : ///      &lt;li&gt;Find local maxima of the pad signal&lt;/li&gt;
<span class="lineNum">      63 </span>            : ///      &lt;ul style=&quot;list-style-type: square;&quot;&gt;
<span class="lineNum">      64 </span>            : ///        &lt;li&gt;maxima arise from the laser tracks, the CE and also periodic postpeaks after the CE signal have
<span class="lineNum">      65 </span>            : ///        have been observed ( see FindLocalMaxima(...) )&lt;/li&gt;
<span class="lineNum">      66 </span>            : ///      &lt;/ul&gt;
<span class="lineNum">      67 </span>            : ///      &lt;li&gt;Find the CE signal information&lt;/li&gt;
<span class="lineNum">      68 </span>            : ///      &lt;ul style=&quot;list-style-type: square;&quot;&gt;
<span class="lineNum">      69 </span>            : ///        &lt;li&gt;to find the position of the CE signal the Tmean information from the previos event is used
<span class="lineNum">      70 </span>            : ///            as the CE signal the local maximum closest to this Tmean is identified&lt;/li&gt;
<span class="lineNum">      71 </span>            : ///        &lt;li&gt;calculate  mean = T0, RMS = signal width and Q sum in a range of -4+7 timebins around Q max position
<span class="lineNum">      72 </span>            : ///            the Q sum is scaled by pad area (see FindPulserSignal(...) function)&lt;/li&gt;
<span class="lineNum">      73 </span>            : ///      &lt;/ul&gt;
<span class="lineNum">      74 </span>            : ///      &lt;li&gt;Fill a temprary array for the T0 information (GetPadTimesEvent(fCurrentSector,kTRUE)) (why see below)&lt;/li&gt;
<span class="lineNum">      75 </span>            : ///      &lt;li&gt;Fill the Q sum and RMS values in the histograms (GetHisto[RMS,Q](ROC,kTRUE))&lt;/li&gt;
<span class="lineNum">      76 </span>            : ///      &lt;/ol&gt;
<span class="lineNum">      77 </span>            : ///    &lt;/ul&gt;
<span class="lineNum">      78 </span>            : ///  &lt;/ul&gt;
<span class="lineNum">      79 </span>            : ///
<span class="lineNum">      80 </span>            : ///  &lt;h4&gt;At the end of each event the EndEvent() function is called&lt;/h4&gt;
<span class="lineNum">      81 </span>            : ///
<span class="lineNum">      82 </span>            : ///  &lt;ul style=&quot;list-style-type: square;&quot;&gt;
<span class="lineNum">      83 </span>            : ///    &lt;li&gt;the EndEvent() function:&lt;/li&gt;
<span class="lineNum">      84 </span>            : ///    &lt;ul style=&quot;list-style-type: square;&quot;&gt;
<span class="lineNum">      85 </span>            : ///      &lt;li&gt;calculate the mean T0 for side A and side C. Fill T0 histogram with Time0-&lt;Time0 for side[A,C]&gt;
<span class="lineNum">      86 </span>            : ///          This is done to overcome syncronisation problems between the trigger and the fec clock.&lt;/li&gt;
<span class="lineNum">      87 </span>            : ///      &lt;li&gt;calculate Mean T for each ROC using the COG aroud the median of the LocalMaxima distribution in one sector&lt;/li&gt;
<span class="lineNum">      88 </span>            : ///      &lt;li&gt;calculate Mean Q&lt;/li&gt;
<span class="lineNum">      89 </span>            : ///      &lt;li&gt;calculate Global fit parameters for Pol1 and Pol2 fits&lt;/li&gt;
<span class="lineNum">      90 </span>            : ///    &lt;/ul&gt;
<span class="lineNum">      91 </span>            : ///  &lt;/ul&gt;
<span class="lineNum">      92 </span>            : ///
<span class="lineNum">      93 </span>            : ///  &lt;h4&gt;After accumulating the desired statistics the Analyse() function has to be called.&lt;/h4&gt;
<span class="lineNum">      94 </span>            : ///   &lt;ul style=&quot;list-style-type: square;&quot;&gt;
<span class="lineNum">      95 </span>            : ///   &lt;li&gt;the Analyse() function:&lt;/li&gt;
<span class="lineNum">      96 </span>            : ///     &lt;ul style=&quot;list-style-type: square;&quot;&gt;
<span class="lineNum">      97 </span>            : ///       &lt;li&gt;calculate the mean values of T0, RMS, Q for each pad, using
<span class="lineNum">      98 </span>            : ///           the AliMathBase::GetCOG(...) function&lt;/li&gt;
<span class="lineNum">      99 </span>            : ///       &lt;li&gt;fill the calibration storage classes (AliTPCCalROC) for each ROC&lt;/li&gt;
<span class="lineNum">     100 </span>            : ///          (The calibration information is stored in the TObjArrays fCalRocArrayT0, fCalRocArrayRMS and fCalRocArrayQ&lt;/li&gt;
<span class="lineNum">     101 </span>            : ///     &lt;/ul&gt;
<span class="lineNum">     102 </span>            : ///   &lt;/ul&gt;
<span class="lineNum">     103 </span>            : ///
<span class="lineNum">     104 </span>            : ///  &lt;h3&gt;&lt;a name=&quot;user&quot;&gt;II. User interface for filling data&lt;/a&gt;&lt;/h3&gt;
<span class="lineNum">     105 </span>            : ///
<span class="lineNum">     106 </span>            : ///  &lt;h4&gt;To Fill information one of the following functions can be used:&lt;/h4&gt;
<span class="lineNum">     107 </span>            : ///
<span class="lineNum">     108 </span>            : ///  &lt;ul style=&quot;list-style-type: none;&quot;&gt;
<span class="lineNum">     109 </span>            : ///   &lt;li&gt; Bool_t ProcessEvent(eventHeaderStruct *event);&lt;/li&gt;
<span class="lineNum">     110 </span>            : ///     &lt;ul style=&quot;list-style-type: square;&quot;&gt;
<span class="lineNum">     111 </span>            : ///       &lt;li&gt;process Date event&lt;/li&gt;
<span class="lineNum">     112 </span>            : ///       &lt;li&gt;use AliTPCRawReaderDate and call ProcessEvent(AliRawReader *rawReader)&lt;/li&gt;
<span class="lineNum">     113 </span>            : ///     &lt;/ul&gt;
<span class="lineNum">     114 </span>            : ///     &lt;br /&gt;
<span class="lineNum">     115 </span>            : ///
<span class="lineNum">     116 </span>            : ///   &lt;li&gt; Bool_t ProcessEvent(AliRawReader *rawReader);&lt;/li&gt;
<span class="lineNum">     117 </span>            : ///     &lt;ul style=&quot;list-style-type: square;&quot;&gt;
<span class="lineNum">     118 </span>            : ///       &lt;li&gt;process AliRawReader event&lt;/li&gt;
<span class="lineNum">     119 </span>            : ///       &lt;li&gt;use AliTPCRawStream to loop over data and call ProcessEvent(AliTPCRawStream *rawStream)&lt;/li&gt;
<span class="lineNum">     120 </span>            : ///     &lt;/ul&gt;
<span class="lineNum">     121 </span>            : ///     &lt;br /&gt;
<span class="lineNum">     122 </span>            : ///
<span class="lineNum">     123 </span>            : ///   &lt;li&gt; Bool_t ProcessEvent(AliTPCRawStream *rawStream);&lt;/li&gt;
<span class="lineNum">     124 </span>            : ///     &lt;ul style=&quot;list-style-type: square;&quot;&gt;
<span class="lineNum">     125 </span>            : ///       &lt;li&gt;process event from AliTPCRawStream&lt;/li&gt;
<span class="lineNum">     126 </span>            : ///       &lt;li&gt;call Update function for signal filling&lt;/li&gt;
<span class="lineNum">     127 </span>            : ///     &lt;/ul&gt;
<span class="lineNum">     128 </span>            : ///     &lt;br /&gt;
<span class="lineNum">     129 </span>            : ///
<span class="lineNum">     130 </span>            : ///   &lt;li&gt; Int_t Update(const Int_t isector, const Int_t iRow, const Int_t
<span class="lineNum">     131 </span>            : ///               iPad,  const Int_t iTimeBin, const Float_t signal);&lt;/li&gt;
<span class="lineNum">     132 </span>            : ///     &lt;ul style=&quot;list-style-type: square;&quot;&gt;
<span class="lineNum">     133 </span>            : ///       &lt;li&gt;directly  fill signal information (sector, row, pad, time bin, pad)
<span class="lineNum">     134 </span>            : ///           to the reference histograms&lt;/li&gt;
<span class="lineNum">     135 </span>            : ///     &lt;/ul&gt;
<span class="lineNum">     136 </span>            : ///  &lt;/ul&gt;
<span class="lineNum">     137 </span>            : ///
<span class="lineNum">     138 </span>            : ///  &lt;h4&gt;It is also possible to merge two independently taken calibrations using the function&lt;/h4&gt;
<span class="lineNum">     139 </span>            : ///
<span class="lineNum">     140 </span>            : ///  &lt;ul style=&quot;list-style-type: none;&quot;&gt;
<span class="lineNum">     141 </span>            : ///   &lt;li&gt; void Merge(AliTPCCalibSignal *sig)&lt;/li&gt;
<span class="lineNum">     142 </span>            : ///     &lt;ul style=&quot;list-style-type: square;&quot;&gt;
<span class="lineNum">     143 </span>            : ///       &lt;li&gt;copy histograms in 'sig' if they do not exist in this instance&lt;/li&gt;
<span class="lineNum">     144 </span>            : ///       &lt;li&gt;Add histograms in 'sig' to the histograms in this instance if the allready exist&lt;/li&gt;
<span class="lineNum">     145 </span>            : ///       &lt;li&gt;After merging call Analyse again!&lt;/li&gt;
<span class="lineNum">     146 </span>            : ///     &lt;/ul&gt;
<span class="lineNum">     147 </span>            : ///  &lt;/ul&gt;
<span class="lineNum">     148 </span>            : ///
<span class="lineNum">     149 </span>            : ///
<span class="lineNum">     150 </span>            : ///  &lt;h4&gt;example: filling data using root raw data:&lt;/h4&gt;
<span class="lineNum">     151 </span>            : ///  &lt;pre&gt;
<span class="lineNum">     152 </span>            : ///  void fillCE(Char_t *filename)
<span class="lineNum">     153 </span>            : ///  {
<span class="lineNum">     154 </span>            : ///     rawReader = new AliRawReaderRoot(fileName);
<span class="lineNum">     155 </span>            : ///     if ( !rawReader ) return;
<span class="lineNum">     156 </span>            : ///     AliTPCCalibCE *calib = new AliTPCCalibCE;
<span class="lineNum">     157 </span>            : ///     while (rawReader-&gt;NextEvent()){
<span class="lineNum">     158 </span>            : ///       calib-&gt;ProcessEvent(rawReader);
<span class="lineNum">     159 </span>            : ///     }
<span class="lineNum">     160 </span>            : ///     calib-&gt;Analyse();
<span class="lineNum">     161 </span>            : ///     calib-&gt;DumpToFile(&quot;CEData.root&quot;);
<span class="lineNum">     162 </span>            : ///     delete rawReader;
<span class="lineNum">     163 </span>            : ///     delete calib;
<span class="lineNum">     164 </span>            : ///  }
<span class="lineNum">     165 </span>            : ///  &lt;/pre&gt;
<span class="lineNum">     166 </span>            : ///
<span class="lineNum">     167 </span>            : ///  &lt;h3&gt;&lt;a name=&quot;info&quot;&gt;III. What kind of information is stored and how to retrieve it&lt;/a&gt;&lt;/h4&gt;
<span class="lineNum">     168 </span>            : ///
<span class="lineNum">     169 </span>            : ///  &lt;h4&gt;&lt;a name=&quot;info:stored&quot;&gt;III.1 Stored information&lt;/a&gt;&lt;/h4&gt;
<span class="lineNum">     170 </span>            : ///  &lt;ul style=&quot;list-style-type: none;&quot;&gt;
<span class="lineNum">     171 </span>            : ///   &lt;li&gt;Histograms:&lt;/li&gt;
<span class="lineNum">     172 </span>            : ///   &lt;ul style=&quot;list-style-type: none;&quot;&gt;
<span class="lineNum">     173 </span>            : ///     &lt;li&gt;For each ROC three TH2S histos 'Reference Histograms'  (ROC channel vs. [Time0, signal width, Q sum])
<span class="lineNum">     174 </span>            : ///         is created when it is filled for the first time (GetHisto[T0,RMS,Q](ROC,kTRUE)). The histos are
<span class="lineNum">     175 </span>            : ///         stored in the TObjArrays fHistoT0Array, fHistoRMSArray and fHistoQArray.&lt;/li&gt;
<span class="lineNum">     176 </span>            : ///   &lt;/ul&gt;
<span class="lineNum">     177 </span>            : ///   &lt;br /&gt;
<span class="lineNum">     178 </span>            : ///
<span class="lineNum">     179 </span>            : ///  &lt;li&gt;Calibration Data:&lt;/li&gt;
<span class="lineNum">     180 </span>            : ///  &lt;ul style=&quot;list-style-type: none;&quot;&gt;
<span class="lineNum">     181 </span>            : ///       &lt;li&gt;For each ROC three types of calibration data (AliTPCCalROC) is stored: for the mean arrival Time,
<span class="lineNum">     182 </span>            : ///           the signal width and the signal Sum. The AliTPCCalROC objects are stored in the TObjArrays
<span class="lineNum">     183 </span>            : ///           fCalRocArrayT0, fCalRocArrayRMS , fCalRocArrayQ. The object for each roc is created the first time it
<span class="lineNum">     184 </span>            : ///           is accessed (GetCalRoc[T0,RMS,Q](ROC,kTRUE));&lt;/li&gt;
<span class="lineNum">     185 </span>            : ///  &lt;/ul&gt;
<span class="lineNum">     186 </span>            : ///  &lt;br /&gt;
<span class="lineNum">     187 </span>            : ///
<span class="lineNum">     188 </span>            : ///  &lt;li&gt;For each event the following information is stored:&lt;/li&gt;
<span class="lineNum">     189 </span>            : ///
<span class="lineNum">     190 </span>            : ///  &lt;ul style=&quot;list-style-type: square;&quot;&gt;
<span class="lineNum">     191 </span>            : ///    &lt;li&gt;event time ( TVectorD  fVEventTime )&lt;/li&gt;
<span class="lineNum">     192 </span>            : ///    &lt;li&gt;event id   ( TVectorD  fVEventNumber )&lt;/li&gt;
<span class="lineNum">     193 </span>            : ///    &lt;br /&gt;
<span class="lineNum">     194 </span>            : ///    &lt;li&gt;mean arrival time for each ROC                ( TObjArray fTMeanArrayEvent )&lt;/li&gt;
<span class="lineNum">     195 </span>            : ///    &lt;li&gt;mean Q for each ROC                           ( TObjArray fQMeanArrayEvent )&lt;/li&gt;
<span class="lineNum">     196 </span>            : ///    &lt;li&gt;parameters of a plane fit for each ROC        ( TObjArray fParamArrayEventPol1 )&lt;/li&gt;
<span class="lineNum">     197 </span>            : ///    &lt;li&gt;parameters of a 2D parabola fit for each ROC  ( TObjArray fParamArrayEventPol2 )&lt;/li&gt;
<span class="lineNum">     198 </span>            : ///   &lt;/ul&gt;
<span class="lineNum">     199 </span>            : ///  &lt;/ul&gt;
<span class="lineNum">     200 </span>            : ///
<span class="lineNum">     201 </span>            : ///  &lt;h4&gt;&lt;a name=&quot;info:retrieve&quot;&gt;III.2 Retrieving information&lt;/a&gt;&lt;/h4&gt;
<span class="lineNum">     202 </span>            : ///  &lt;ul style=&quot;list-style-type: none;&quot;&gt;
<span class="lineNum">     203 </span>            : ///   &lt;li&gt;Accessing the 'Reference Histograms' (Time0, signal width and Q sum information pad by pad):&lt;/li&gt;
<span class="lineNum">     204 </span>            : ///     &lt;ul style=&quot;list-style-type: square;&quot;&gt;
<span class="lineNum">     205 </span>            : ///       &lt;li&gt;TH2F *GetHistoT0(Int_t sector);&lt;/li&gt;
<span class="lineNum">     206 </span>            : ///       &lt;li&gt;TH2F *GetHistoRMS(Int_t sector);&lt;/li&gt;
<span class="lineNum">     207 </span>            : ///       &lt;li&gt;TH2F *GetHistoQ(Int_t sector);&lt;/li&gt;
<span class="lineNum">     208 </span>            : ///     &lt;/ul&gt;
<span class="lineNum">     209 </span>            : ///     &lt;br /&gt;
<span class="lineNum">     210 </span>            : ///
<span class="lineNum">     211 </span>            : ///   &lt;li&gt;Accessing the calibration storage objects:&lt;/li&gt;
<span class="lineNum">     212 </span>            : ///     &lt;ul style=&quot;list-style-type: square;&quot;&gt;
<span class="lineNum">     213 </span>            : ///       &lt;li&gt;AliTPCCalROC *GetCalRocT0(Int_t sector);   // for the Time0 values&lt;/li&gt;
<span class="lineNum">     214 </span>            : ///       &lt;li&gt;AliTPCCalROC *GetCalRocRMS(Int_t sector);  // for the signal width values&lt;/li&gt;
<span class="lineNum">     215 </span>            : ///       &lt;li&gt;AliTPCCalROC *GetCalRocQ(Int_t sector);    // for the Q sum values&lt;/li&gt;
<span class="lineNum">     216 </span>            : ///     &lt;/ul&gt;
<span class="lineNum">     217 </span>            : ///     &lt;br /&gt;
<span class="lineNum">     218 </span>            : ///
<span class="lineNum">     219 </span>            : ///   &lt;li&gt;Accessin the event by event information:&lt;/li&gt;
<span class="lineNum">     220 </span>            : ///     &lt;ul style=&quot;list-style-type: square;&quot;&gt;
<span class="lineNum">     221 </span>            : ///       &lt;li&gt;The event by event information can be displayed using the&lt;/li&gt;
<span class="lineNum">     222 </span>            : ///       &lt;li&gt;MakeGraphTimeCE(Int_t sector, Int_t xVariable, Int_t fitType, Int_t fitParameter)&lt;/li&gt;
<span class="lineNum">     223 </span>            : ///       &lt;li&gt;which creates a graph from the specified variables&lt;/li&gt;
<span class="lineNum">     224 </span>            : ///     &lt;/ul&gt;
<span class="lineNum">     225 </span>            : ///   &lt;/ul&gt;
<span class="lineNum">     226 </span>            : ///
<span class="lineNum">     227 </span>            : ///   &lt;h4&gt;example for visualisation:&lt;/h4&gt;
<span class="lineNum">     228 </span>            : ///   &lt;pre&gt;
<span class="lineNum">     229 </span>            : ///   //if the file &quot;CEData.root&quot; was created using the above example one could do the following:
<span class="lineNum">     230 </span>            : ///   TFile fileCE(&quot;CEData.root&quot;)
<span class="lineNum">     231 </span>            : ///   AliTPCCalibCE *ce = (AliTPCCalibCE*)fileCE-&gt;Get(&quot;AliTPCCalibCE&quot;);
<span class="lineNum">     232 </span>            : ///   ce-&gt;GetCalRocT0(0)-&gt;Draw(&quot;colz&quot;);
<span class="lineNum">     233 </span>            : ///   ce-&gt;GetCalRocRMS(0)-&gt;Draw(&quot;colz&quot;);
<span class="lineNum">     234 </span>            : ///
<span class="lineNum">     235 </span>            : ///   //or use the AliTPCCalPad functionality:
<span class="lineNum">     236 </span>            : ///   AliTPCCalPad padT0(ped-&gt;GetCalPadT0());
<span class="lineNum">     237 </span>            : ///   AliTPCCalPad padSigWidth(ped-&gt;GetCalPadRMS());
<span class="lineNum">     238 </span>            : ///   padT0-&gt;MakeHisto2D()-&gt;Draw(&quot;colz&quot;);       //Draw A-Side Time0 Information
<span class="lineNum">     239 </span>            : ///   padSigWidth-&gt;MakeHisto2D()-&gt;Draw(&quot;colz&quot;); //Draw A-Side signal width Information
<span class="lineNum">     240 </span>            : ///
<span class="lineNum">     241 </span>            : ///   //display event by event information:
<span class="lineNum">     242 </span>            : ///   //Draw mean arrival time as a function of the event time for oroc sector A00
<span class="lineNum">     243 </span>            : ///   ce-&gt;MakeGraphTimeCE(36, 0, 2)-&gt;Draw(&quot;alp&quot;);
<span class="lineNum">     244 </span>            : ///   //Draw first derivative in local x from a plane fit as a function of the event time for oroc sector A00
<span class="lineNum">     245 </span>            : ///   ce-&gt;MakeGraphTimeCE(36, 0, 0, 1)-&gt;Draw(&quot;alp&quot;);
<span class="lineNum">     246 </span>            : ///   &lt;/pre&gt;
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span>            : //Root includes
<span class="lineNum">     249 </span>            : #include &lt;TObjArray.h&gt;
<span class="lineNum">     250 </span>            : #include &lt;TH1.h&gt;
<span class="lineNum">     251 </span>            : #include &lt;TH1F.h&gt;
<span class="lineNum">     252 </span>            : #include &lt;TH2S.h&gt;
<span class="lineNum">     253 </span>            : #include &lt;TF1.h&gt;
<span class="lineNum">     254 </span>            : #include &lt;TString.h&gt;
<span class="lineNum">     255 </span>            : #include &lt;TVectorF.h&gt;
<span class="lineNum">     256 </span>            : #include &lt;TVectorD.h&gt;
<span class="lineNum">     257 </span>            : #include &lt;TVector3.h&gt;
<span class="lineNum">     258 </span>            : #include &lt;TMatrixD.h&gt;
<span class="lineNum">     259 </span>            : #include &lt;TMath.h&gt;
<span class="lineNum">     260 </span>            : #include &lt;TGraph.h&gt;
<span class="lineNum">     261 </span>            : #include &lt;TGraphErrors.h&gt;
<span class="lineNum">     262 </span>            : #include &lt;TString.h&gt;
<span class="lineNum">     263 </span>            : #include &lt;TMap.h&gt;
<span class="lineNum">     264 </span>            : #include &lt;TDirectory.h&gt;
<span class="lineNum">     265 </span>            : #include &lt;TSystem.h&gt;
<span class="lineNum">     266 </span>            : #include &lt;TFile.h&gt;
<span class="lineNum">     267 </span>            : #include &lt;TCollection.h&gt;
<span class="lineNum">     268 </span>            : #include &lt;TTimeStamp.h&gt;
<span class="lineNum">     269 </span>            : #include &lt;TList.h&gt;
<span class="lineNum">     270 </span>            : #include &lt;TKey.h&gt;
<span class="lineNum">     271 </span>            : #include &lt;TSpectrum.h&gt;
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span>            : //AliRoot includes
<span class="lineNum">     274 </span>            : #include &quot;AliLog.h&quot;
<span class="lineNum">     275 </span>            : #include &quot;AliRawReader.h&quot;
<span class="lineNum">     276 </span>            : #include &quot;AliRawReaderRoot.h&quot;
<span class="lineNum">     277 </span>            : #include &quot;AliRawReaderDate.h&quot;
<span class="lineNum">     278 </span>            : #include &quot;AliRawEventHeaderBase.h&quot;
<span class="lineNum">     279 </span>            : #include &quot;AliTPCCalROC.h&quot;
<span class="lineNum">     280 </span>            : #include &quot;AliTPCCalPad.h&quot;
<span class="lineNum">     281 </span>            : #include &quot;AliTPCROC.h&quot;
<span class="lineNum">     282 </span>            : #include &quot;AliTPCParam.h&quot;
<span class="lineNum">     283 </span>            : #include &quot;AliTPCCalibCE.h&quot;
<span class="lineNum">     284 </span>            : #include &quot;AliMathBase.h&quot;
<span class="lineNum">     285 </span>            : #include &quot;AliTPCTransform.h&quot;
<span class="lineNum">     286 </span>            : #include &quot;AliTPCLaserTrack.h&quot;
<span class="lineNum">     287 </span>            : #include &quot;TTreeStream.h&quot;
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            : #include &quot;AliCDBManager.h&quot;
<span class="lineNum">     290 </span>            : #include &quot;AliCDBEntry.h&quot;
<span class="lineNum">     291 </span>            : //date
<a name="292"><span class="lineNum">     292 </span>            : #include &quot;event.h&quot;</a>
<span class="lineNum">     293 </span>            : /// \cond CLASSIMP
<span class="lineNum">     294 </span><span class="lineCov">         24 : ClassImp(AliTPCCalibCE)</span>
<span class="lineNum">     295 </span>            : /// \endcond
<a name="296"><span class="lineNum">     296 </span>            : </a>
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            : AliTPCCalibCE::AliTPCCalibCE() :
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :   AliTPCCalibRawBase(),</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :   fNbinsT0(200),</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :   fXminT0(-5),</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :   fXmaxT0(5),</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :   fNbinsQ(200),</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :   fXminQ(1),</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :   fXmaxQ(40),</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :   fNbinsRMS(100),</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :   fXminRMS(0.1),</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :   fXmaxRMS(5.1),</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :   fPeakDetMinus(2),</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :   fPeakDetPlus(3),</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :   fPeakIntMinus(2),</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :   fPeakIntPlus(2),</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :   fNoiseThresholdMax(5.),</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :   fNoiseThresholdSum(8.),</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :   fROCblackDataDown(-1),</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :   fROCblackDataUp(-1),</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :   fIsZeroSuppressed(kFALSE),</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :   fLastSector(-1),</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :   fSecRejectRatio(.4),</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :   fParam(new AliTPCParam),</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :   fPedestalTPC(0x0),</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :   fPadNoiseTPC(0x0),</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :   fPedestalROC(0x0),</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :   fPadNoiseROC(0x0),</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :   fCalRocArrayT0(72),</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :   fCalRocArrayT0Err(72),</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :   fCalRocArrayQ(72),</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :   fCalRocArrayRMS(72),</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :   fCalRocArrayOutliers(72),</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :   fHistoQArray(72),</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :   fHistoT0Array(72),</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :   fHistoRMSArray(72),</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :   fMeanT0rms(0),</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :   fMeanQrms(0),</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :   fMeanRMSrms(0),</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :   fHistoTmean(72),</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :   fParamArrayEventPol1(72),</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :   fParamArrayEventPol2(72),</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :   fTMeanArrayEvent(72),</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :   fQMeanArrayEvent(72),</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :   fVEventTime(1000),</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :   fVEventNumber(1000),</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :   fVTime0SideA(1000),</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :   fVTime0SideC(1000),</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :   fEventId(-1),</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :   fOldRunNumber(0),</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :   fPadTimesArrayEvent(72),</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :   fPadQArrayEvent(72),</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :   fPadRMSArrayEvent(72),</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :   fPadPedestalArrayEvent(72),</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :   fCurrentChannel(-1),</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :   fCurrentSector(-1),</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :   fCurrentRow(-1),</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :   fMaxPadSignal(-1),</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :   fMaxTimeBin(-1),</span>
<span class="lineNum">     356 </span>            : //   fPadSignal(1024),
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :   fPadPedestal(0),</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :   fPadNoise(0),</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :   fVTime0Offset(72),</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :   fVTime0OffsetCounter(72),</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :   fVMeanQ(72),</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :   fVMeanQCounter(72),</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :   fCurrentCETimeRef(0),</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :   fProcessOld(kTRUE),</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :   fProcessNew(kFALSE),</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :   fAnalyseNew(kTRUE),</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :   fHnDrift(0x0),</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :   fArrHnDrift(100),</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :   fTimeBursts(100),</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :   fArrFitGraphs(0x0),</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :   fEventInBunch(0)</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">     373 </span>            :   //
<span class="lineNum">     374 </span>            :   // AliTPCSignal default constructor
<span class="lineNum">     375 </span>            :   //
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :   SetNameTitle(&quot;AliTPCCalibCE&quot;,&quot;AliTPCCalibCE&quot;);</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :   fFirstTimeBin=650;</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :   fLastTimeBin=1030;</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :   fParam-&gt;Update();</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :   for (Int_t i=0;i&lt;1024;++i) fPadSignal[i]=0;</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :   for (Int_t i=0;i&lt;14;++i){</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     fPeaks[i]=0;</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :     fPeakWidths[i]=0;</span>
<span class="lineNum">     384 </span>            :   }
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;100; ++i) fBinsLastAna[i]=0;</span>
<a name="386"><span class="lineNum">     386 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     387 </span>            : //_____________________________________________________________________
<span class="lineNum">     388 </span>            : AliTPCCalibCE::AliTPCCalibCE(const AliTPCCalibCE &amp;sig) :
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :   AliTPCCalibRawBase(sig),</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :   fNbinsT0(sig.fNbinsT0),</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :   fXminT0(sig.fXminT0),</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :   fXmaxT0(sig.fXmaxT0),</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :   fNbinsQ(sig.fNbinsQ),</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :   fXminQ(sig.fXminQ),</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :   fXmaxQ(sig.fXmaxQ),</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :   fNbinsRMS(sig.fNbinsRMS),</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :   fXminRMS(sig.fXminRMS),</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :   fXmaxRMS(sig.fXmaxRMS),</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :   fPeakDetMinus(sig.fPeakDetMinus),</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :   fPeakDetPlus(sig.fPeakDetPlus),</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :   fPeakIntMinus(sig.fPeakIntMinus),</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :   fPeakIntPlus(sig.fPeakIntPlus),</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :   fNoiseThresholdMax(sig.fNoiseThresholdMax),</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :   fNoiseThresholdSum(sig.fNoiseThresholdSum),</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :   fROCblackDataDown(-1),</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :   fROCblackDataUp(-1),</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :   fIsZeroSuppressed(sig.fIsZeroSuppressed),</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :   fLastSector(-1),</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :   fSecRejectRatio(.4),</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :   fParam(new AliTPCParam),</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :   fPedestalTPC(0x0),</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :   fPadNoiseTPC(0x0),</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :   fPedestalROC(0x0),</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :   fPadNoiseROC(0x0),</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :   fCalRocArrayT0(72),</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :   fCalRocArrayT0Err(72),</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :   fCalRocArrayQ(72),</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :   fCalRocArrayRMS(72),</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :   fCalRocArrayOutliers(72),</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :   fHistoQArray(72),</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :   fHistoT0Array(72),</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :   fHistoRMSArray(72),</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :   fMeanT0rms(sig.fMeanT0rms),</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :   fMeanQrms(sig.fMeanQrms),</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :   fMeanRMSrms(sig.fMeanRMSrms),</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :   fHistoTmean(72),</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :   fParamArrayEventPol1(72),</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :   fParamArrayEventPol2(72),</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :   fTMeanArrayEvent(72),</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :   fQMeanArrayEvent(72),</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :   fVEventTime(sig.fVEventTime),</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :   fVEventNumber(sig.fVEventNumber),</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :   fVTime0SideA(sig.fVTime0SideA),</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :   fVTime0SideC(sig.fVTime0SideC),</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :   fEventId(-1),</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :   fOldRunNumber(0),</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :   fPadTimesArrayEvent(72),</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :   fPadQArrayEvent(72),</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :   fPadRMSArrayEvent(72),</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :   fPadPedestalArrayEvent(72),</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :   fCurrentChannel(-1),</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :   fCurrentSector(-1),</span>
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :   fCurrentRow(-1),</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :   fMaxPadSignal(-1),</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :   fMaxTimeBin(-1),</span>
<span class="lineNum">     446 </span>            : //   fPadSignal(1024),
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :   fPadPedestal(0),</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :   fPadNoise(0),</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :   fVTime0Offset(72),</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :   fVTime0OffsetCounter(72),</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :   fVMeanQ(72),</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :   fVMeanQCounter(72),</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :   fCurrentCETimeRef(0),</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :   fProcessOld(sig.fProcessOld),</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :   fProcessNew(sig.fProcessNew),</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :   fAnalyseNew(sig.fAnalyseNew),</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :   fHnDrift(0x0),</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :   fArrHnDrift(100),</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :   fTimeBursts(100),</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :   fArrFitGraphs(0x0),</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :   fEventInBunch(0)</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">     463 </span>            :   /// AliTPCSignal copy constructor
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :   for (Int_t i=0;i&lt;1024;++i) fPadSignal[i]=0;</span>
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :   for (Int_t iSec = 0; iSec &lt; 72; ++iSec){</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :     const AliTPCCalROC *calQ   = (AliTPCCalROC*)sig.fCalRocArrayQ.UncheckedAt(iSec);</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :     const AliTPCCalROC *calT0  = (AliTPCCalROC*)sig.fCalRocArrayT0.UncheckedAt(iSec);</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :     const AliTPCCalROC *calRMS = (AliTPCCalROC*)sig.fCalRocArrayRMS.UncheckedAt(iSec);</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :     const AliTPCCalROC *calOut = (AliTPCCalROC*)sig.fCalRocArrayOutliers.UncheckedAt(iSec);</span>
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :     const TH2S *hQ   = (TH2S*)sig.fHistoQArray.UncheckedAt(iSec);</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :     const TH2S *hT0  = (TH2S*)sig.fHistoT0Array.UncheckedAt(iSec);</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :     const TH2S *hRMS = (TH2S*)sig.fHistoRMSArray.UncheckedAt(iSec);</span>
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :     if ( calQ   != 0x0 ) fCalRocArrayQ.AddAt(new AliTPCCalROC(*calQ), iSec);</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :     if ( calT0  != 0x0 ) fCalRocArrayT0.AddAt(new AliTPCCalROC(*calT0), iSec);</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :     if ( calRMS != 0x0 ) fCalRocArrayRMS.AddAt(new AliTPCCalROC(*calRMS), iSec);</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :     if ( calOut != 0x0 ) fCalRocArrayOutliers.AddAt(new AliTPCCalROC(*calOut), iSec);</span>
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :     if ( hQ != 0x0 ){</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :       TH2S *hNew = new TH2S(*hQ);</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :       hNew-&gt;SetDirectory(0);</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :       fHistoQArray.AddAt(hNew,iSec);</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :     if ( hT0 != 0x0 ){</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :       TH2S *hNew = new TH2S(*hT0);</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :       hNew-&gt;SetDirectory(0);</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :       fHistoT0Array.AddAt(hNew,iSec);</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :     if ( hRMS != 0x0 ){</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :       TH2S *hNew = new TH2S(*hRMS);</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :       hNew-&gt;SetDirectory(0);</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :       fHistoRMSArray.AddAt(hNew,iSec);</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     497 </span>            :   }
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span>            :   //copy fit parameters event by event
<span class="lineNum">     500 </span>            :   TObjArray *arr=0x0;
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :   for (Int_t iSec=0; iSec&lt;72; ++iSec){</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :     arr = (TObjArray*)sig.fParamArrayEventPol1.UncheckedAt(iSec);</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :     if ( arr ){</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :       TObjArray *arrEvents = new TObjArray(arr-&gt;GetSize());</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :       fParamArrayEventPol1.AddAt(arrEvents, iSec);</span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :       for (Int_t iEvent=0; iEvent&lt;arr-&gt;GetSize(); ++iEvent)</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :         if ( TVectorD *vec=(TVectorD*)arr-&gt;UncheckedAt(iEvent) )</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :           arrEvents-&gt;AddAt(new TVectorD(*vec),iEvent);</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :     arr = (TObjArray*)sig.fParamArrayEventPol2.UncheckedAt(iSec);</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :     if ( arr ){</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :       TObjArray *arrEvents = new TObjArray(arr-&gt;GetSize());</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :       fParamArrayEventPol2.AddAt(arrEvents, iSec);</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :       for (Int_t iEvent=0; iEvent&lt;arr-&gt;GetSize(); ++iEvent)</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :         if ( TVectorD *vec=(TVectorD*)arr-&gt;UncheckedAt(iEvent) )</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :           arrEvents-&gt;AddAt(new TVectorD(*vec),iEvent);</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :     TVectorF *vMeanTime = (TVectorF*)sig.fTMeanArrayEvent.UncheckedAt(iSec);</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :     TVectorF *vMeanQ    = (TVectorF*)sig.fQMeanArrayEvent.UncheckedAt(iSec);</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :     if ( vMeanTime )</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :       fTMeanArrayEvent.AddAt(new TVectorF(*vMeanTime), iSec);</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :     if ( vMeanQ )</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :       fQMeanArrayEvent.AddAt(new TVectorF(*vMeanQ), iSec);</span>
<span class="lineNum">     526 </span>            :   }
<span class="lineNum">     527 </span>            : 
<span class="lineNum">     528 </span>            : 
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :   fVEventTime.ResizeTo(sig.fVEventTime);</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :   fVEventNumber.ResizeTo(sig.fVEventNumber);</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :   fVEventTime.SetElements(sig.fVEventTime.GetMatrixArray());</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :   fVEventNumber.SetElements(sig.fVEventNumber.GetMatrixArray());</span>
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :   fParam-&gt;Update();</span>
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;sig.fArrHnDrift.GetEntries();++i){</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :     TObject *o=sig.fArrHnDrift.UncheckedAt(i);</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :     if (o){</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :       TObject *newo=o-&gt;Clone(&quot;fHnDrift&quot;);</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :       fArrHnDrift.AddAt(newo,i);</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :       if (sig.fHnDrift &amp;&amp; o==sig.fHnDrift) fHnDrift=(THnSparseI*)newo;</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     543 </span>            :   }
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :   for (Int_t i=0;i&lt;sig.fTimeBursts.GetNrows();++i){</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :     fTimeBursts[i]=sig.fTimeBursts[i];</span>
<span class="lineNum">     547 </span>            :   }
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :   for (Int_t i=0;i&lt;14;++i){</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :     fPeaks[i]=sig.fPeaks[i];</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :     fPeakWidths[i]=sig.fPeakWidths[i];</span>
<span class="lineNum">     552 </span>            :   }
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :   if (sig.fArrFitGraphs) {</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :     fArrFitGraphs=(TObjArray*)sig.fArrFitGraphs-&gt;Clone();</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :     fArrFitGraphs-&gt;SetOwner();</span>
<span class="lineNum">     556 </span>            :   }
<span class="lineNum">     557 </span>            : 
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;100; ++i) fBinsLastAna[i]=sig.fBinsLastAna[i];</span>
<span class="lineNum">     559 </span>            : 
<a name="560"><span class="lineNum">     560 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     561 </span>            : //_____________________________________________________________________
<span class="lineNum">     562 </span>            : AliTPCCalibCE::AliTPCCalibCE(const TMap *config) :
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :   AliTPCCalibRawBase(),</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :   fNbinsT0(200),</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :   fXminT0(-5),</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :   fXmaxT0(5),</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :   fNbinsQ(200),</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :   fXminQ(1),</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :   fXmaxQ(40),</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :   fNbinsRMS(100),</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :   fXminRMS(0.1),</span>
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :   fXmaxRMS(5.1),</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :   fPeakDetMinus(2),</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :   fPeakDetPlus(3),</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :   fPeakIntMinus(2),</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :   fPeakIntPlus(2),</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :   fNoiseThresholdMax(5.),</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :   fNoiseThresholdSum(8.),</span>
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :   fROCblackDataDown(-1),</span>
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :   fROCblackDataUp(-1),</span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :   fIsZeroSuppressed(kFALSE),</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :   fLastSector(-1),</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :   fSecRejectRatio(.4),</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :   fParam(new  AliTPCParam),</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :   fPedestalTPC(0x0),</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :   fPadNoiseTPC(0x0),</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :   fPedestalROC(0x0),</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :   fPadNoiseROC(0x0),</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :   fCalRocArrayT0(72),</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :   fCalRocArrayT0Err(72),</span>
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :   fCalRocArrayQ(72),</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :   fCalRocArrayRMS(72),</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :   fCalRocArrayOutliers(72),</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :   fHistoQArray(72),</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :   fHistoT0Array(72),</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :   fHistoRMSArray(72),</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :   fMeanT0rms(0),</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :   fMeanQrms(0),</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :   fMeanRMSrms(0),</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :   fHistoTmean(72),</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :   fParamArrayEventPol1(72),</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :   fParamArrayEventPol2(72),</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :   fTMeanArrayEvent(72),</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :   fQMeanArrayEvent(72),</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :   fVEventTime(1000),</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :   fVEventNumber(1000),</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :   fVTime0SideA(1000),</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :   fVTime0SideC(1000),</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :   fEventId(-1),</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :   fOldRunNumber(0),</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :   fPadTimesArrayEvent(72),</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :   fPadQArrayEvent(72),</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :   fPadRMSArrayEvent(72),</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :   fPadPedestalArrayEvent(72),</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :   fCurrentChannel(-1),</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :   fCurrentSector(-1),</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :   fCurrentRow(-1),</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :   fMaxPadSignal(-1),</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :   fMaxTimeBin(-1),</span>
<span class="lineNum">     620 </span>            : //   fPadSignal(1024),
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :   fPadPedestal(0),</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :   fPadNoise(0),</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :   fVTime0Offset(72),</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :   fVTime0OffsetCounter(72),</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :   fVMeanQ(72),</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :   fVMeanQCounter(72),</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :   fCurrentCETimeRef(0),</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :   fProcessOld(kTRUE),</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :   fProcessNew(kFALSE),</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :   fAnalyseNew(kTRUE),</span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :   fHnDrift(0x0),</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :   fArrHnDrift(100),</span>
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :   fTimeBursts(100),</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :   fArrFitGraphs(0x0),</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :   fEventInBunch(0)</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">     637 </span>            :   /// constructor which uses a tmap as input to set some specific parameters
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :   SetNameTitle(&quot;AliTPCCalibCE&quot;,&quot;AliTPCCalibCE&quot;);</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :   fFirstTimeBin=650;</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :   fLastTimeBin=1030;</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :   if (config-&gt;GetValue(&quot;FirstTimeBin&quot;)) fFirstTimeBin = ((TObjString*)config-&gt;GetValue(&quot;FirstTimeBin&quot;))-&gt;GetString().Atoi();</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :   if (config-&gt;GetValue(&quot;LastTimeBin&quot;)) fLastTimeBin = ((TObjString*)config-&gt;GetValue(&quot;LastTimeBin&quot;))-&gt;GetString().Atoi();</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :   if (config-&gt;GetValue(&quot;NbinsT0&quot;)) fNbinsT0 = ((TObjString*)config-&gt;GetValue(&quot;NbinsT0&quot;))-&gt;GetString().Atoi();</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :   if (config-&gt;GetValue(&quot;XminT0&quot;)) fXminT0 = ((TObjString*)config-&gt;GetValue(&quot;XminT0&quot;))-&gt;GetString().Atof();</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :   if (config-&gt;GetValue(&quot;XmaxT0&quot;)) fXmaxT0 = ((TObjString*)config-&gt;GetValue(&quot;XmaxT0&quot;))-&gt;GetString().Atof();</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :   if (config-&gt;GetValue(&quot;NbinsQ&quot;)) fNbinsQ = ((TObjString*)config-&gt;GetValue(&quot;NbinsQ&quot;))-&gt;GetString().Atoi();</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :   if (config-&gt;GetValue(&quot;XminQ&quot;)) fXminQ = ((TObjString*)config-&gt;GetValue(&quot;XminQ&quot;))-&gt;GetString().Atof();</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :   if (config-&gt;GetValue(&quot;XmaxQ&quot;)) fXmaxQ = ((TObjString*)config-&gt;GetValue(&quot;XmaxQ&quot;))-&gt;GetString().Atof();</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :   if (config-&gt;GetValue(&quot;NbinsRMS&quot;)) fNbinsRMS = ((TObjString*)config-&gt;GetValue(&quot;NbinsRMS&quot;))-&gt;GetString().Atoi();</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :   if (config-&gt;GetValue(&quot;XminRMS&quot;)) fXminRMS = ((TObjString*)config-&gt;GetValue(&quot;XminRMS&quot;))-&gt;GetString().Atof();</span>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :   if (config-&gt;GetValue(&quot;XmaxRMS&quot;)) fXmaxRMS = ((TObjString*)config-&gt;GetValue(&quot;XmaxRMS&quot;))-&gt;GetString().Atof();</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :   if (config-&gt;GetValue(&quot;PeakDetMinus&quot;)) fPeakDetMinus = ((TObjString*)config-&gt;GetValue(&quot;PeakDetMinus&quot;))-&gt;GetString().Atoi();</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :   if (config-&gt;GetValue(&quot;PeakDetPlus&quot;)) fPeakDetPlus = ((TObjString*)config-&gt;GetValue(&quot;PeakDetPlus&quot;))-&gt;GetString().Atoi();</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :   if (config-&gt;GetValue(&quot;PeakIntMinus&quot;)) fPeakIntMinus = ((TObjString*)config-&gt;GetValue(&quot;PeakIntMinus&quot;))-&gt;GetString().Atoi();</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :   if (config-&gt;GetValue(&quot;PeakIntPlus&quot;)) fPeakIntPlus = ((TObjString*)config-&gt;GetValue(&quot;PeakIntPlus&quot;))-&gt;GetString().Atoi();</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :   if (config-&gt;GetValue(&quot;NoiseThresholdMax&quot;)) fNoiseThresholdMax = ((TObjString*)config-&gt;GetValue(&quot;NoiseThresholdMax&quot;))-&gt;GetString().Atof();</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :   if (config-&gt;GetValue(&quot;NoiseThresholdSum&quot;)) fNoiseThresholdSum = ((TObjString*)config-&gt;GetValue(&quot;NoiseThresholdSum&quot;))-&gt;GetString().Atof();</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :   if (config-&gt;GetValue(&quot;IsZeroSuppressed&quot;)) fIsZeroSuppressed = (Bool_t)((TObjString*)config-&gt;GetValue(&quot;IsZeroSuppressed&quot;))-&gt;GetString().Atoi();</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :   if (config-&gt;GetValue(&quot;UseL1Phase&quot;)) fUseL1Phase = (Bool_t)((TObjString*)config-&gt;GetValue(&quot;UseL1Phase&quot;))-&gt;GetString().Atoi();</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :   if (config-&gt;GetValue(&quot;SecRejectRatio&quot;)) fSecRejectRatio = ((TObjString*)config-&gt;GetValue(&quot;SecRejectRatio&quot;))-&gt;GetString().Atof();</span>
<span class="lineNum">     662 </span>            : 
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :   if (config-&gt;GetValue(&quot;ProcessOld&quot;)) fProcessOld = (Bool_t)((TObjString*)config-&gt;GetValue(&quot;ProcessOld&quot;))-&gt;GetString().Atoi();</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :   if (config-&gt;GetValue(&quot;ProcessNew&quot;)) fProcessNew = (Bool_t)((TObjString*)config-&gt;GetValue(&quot;ProcessNew&quot;))-&gt;GetString().Atoi();</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :   if (config-&gt;GetValue(&quot;AnalyseNew&quot;)) fAnalyseNew = (Bool_t)((TObjString*)config-&gt;GetValue(&quot;AnalyseNew&quot;))-&gt;GetString().Atoi();</span>
<span class="lineNum">     666 </span>            : 
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :   for (Int_t i=0;i&lt;1024;++i) fPadSignal[i]=0;</span>
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :   for (Int_t i=0;i&lt;14;++i){</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :     fPeaks[i]=0;</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :     fPeakWidths[i]=0;</span>
<span class="lineNum">     671 </span>            :   }
<span class="lineNum">     672 </span>            : 
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :   fParam-&gt;Update();</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;100; ++i) fBinsLastAna[i]=0;</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 : }</span>
<a name="676"><span class="lineNum">     676 </span>            : </a>
<span class="lineNum">     677 </span>            : //_____________________________________________________________________
<span class="lineNum">     678 </span>            : AliTPCCalibCE&amp; AliTPCCalibCE::operator = (const  AliTPCCalibCE &amp;source)
<span class="lineNum">     679 </span>            : {
<span class="lineNum">     680 </span>            :   /// assignment operator
<span class="lineNum">     681 </span>            : 
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :   if (&amp;source == this) return *this;</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :   new (this) AliTPCCalibCE(source);</span>
<span class="lineNum">     684 </span>            : 
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :   return *this;</span>
<a name="686"><span class="lineNum">     686 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     687 </span>            : //_____________________________________________________________________
<span class="lineNum">     688 </span>            : AliTPCCalibCE::~AliTPCCalibCE()
<span class="lineNum">     689 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">     690 </span>            :   /// destructor
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :   fCalRocArrayT0.Delete();</span>
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :   fCalRocArrayT0Err.Delete();</span>
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :   fCalRocArrayQ.Delete();</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :   fCalRocArrayRMS.Delete();</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :   fCalRocArrayOutliers.Delete();</span>
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :   fHistoQArray.Delete();</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :   fHistoT0Array.Delete();</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :   fHistoRMSArray.Delete();</span>
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :   fHistoTmean.Delete();</span>
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :   fParamArrayEventPol1.Delete();</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :   fParamArrayEventPol2.Delete();</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :   fTMeanArrayEvent.Delete();</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :   fQMeanArrayEvent.Delete();</span>
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :   fPadTimesArrayEvent.Delete();</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :   fPadQArrayEvent.Delete();</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :   fPadRMSArrayEvent.Delete();</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :   fPadPedestalArrayEvent.Delete();</span>
<span class="lineNum">     713 </span>            : 
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :   fArrHnDrift.SetOwner();</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :   fArrHnDrift.Delete();</span>
<span class="lineNum">     716 </span>            : 
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :   if (fArrFitGraphs){</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :     fArrFitGraphs-&gt;SetOwner();</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :     delete fArrFitGraphs;</span>
<span class="lineNum">     720 </span>            :   }
<a name="721"><span class="lineNum">     721 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     722 </span>            : //_____________________________________________________________________
<span class="lineNum">     723 </span>            : Int_t AliTPCCalibCE::Update(const Int_t icsector,
<span class="lineNum">     724 </span>            :                                 const Int_t icRow,
<span class="lineNum">     725 </span>            :                                 const Int_t icPad,
<span class="lineNum">     726 </span>            :                                 const Int_t icTimeBin,
<span class="lineNum">     727 </span>            :                                 const Float_t csignal)
<span class="lineNum">     728 </span>            : {
<span class="lineNum">     729 </span>            :   /// Signal filling methode on the fly pedestal and Time offset correction if necessary.
<span class="lineNum">     730 </span>            :   /// no extra analysis necessary. Assumes knowledge of the signal shape!
<span class="lineNum">     731 </span>            :   /// assumes that it is looped over consecutive time bins of one pad
<span class="lineNum">     732 </span>            : 
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :   if (!fProcessOld) return 0;</span>
<span class="lineNum">     734 </span>            :   //temp
<span class="lineNum">     735 </span>            : 
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :   if (icRow&lt;0) return 0;</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :   if (icPad&lt;0) return 0;</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :   if (icTimeBin&lt;0) return 0;</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :   if ( (icTimeBin&gt;fLastTimeBin) || (icTimeBin&lt;fFirstTimeBin)   ) return 0;</span>
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :   Int_t iChannel  = fROC-&gt;GetRowIndexes(icsector)[icRow]+icPad; //  global pad position in sector</span>
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span>            :   //init first pad and sector in this event
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :   if ( fCurrentChannel == -1 ) {</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :     fLastSector=-1;</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :     fCurrentChannel = iChannel;</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :     fCurrentSector  = icsector;</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :     fCurrentRow     = icRow;</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span>            :   //process last pad if we change to a new one
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :   if ( iChannel != fCurrentChannel ){</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :     ProcessPad();</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :     fLastSector=fCurrentSector;</span>
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :     fCurrentChannel = iChannel;</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :     fCurrentSector  = icsector;</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :     fCurrentRow     = icRow;</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     759 </span>            : 
<span class="lineNum">     760 </span>            :   //fill signals for current pad
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :   fPadSignal[icTimeBin]=csignal;</span>
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :   if ( csignal &gt; fMaxPadSignal ){</span>
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :     fMaxPadSignal = csignal;</span>
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :     fMaxTimeBin   = icTimeBin;</span>
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     766 </span>            :   return 0;
<span class="lineNum">     767 </span><span class="lineNoCov">          0 : }</span>
<a name="768"><span class="lineNum">     768 </span>            : </a>
<span class="lineNum">     769 </span>            : //_____________________________________________________________________
<span class="lineNum">     770 </span>            : void AliTPCCalibCE::ProcessBunch(const Int_t sector, const Int_t row, const Int_t pad,
<span class="lineNum">     771 </span>            :                   const Int_t length, const UInt_t startTimeBin, const UShort_t* signal)
<span class="lineNum">     772 </span>            : {
<span class="lineNum">     773 </span>            :   /// new filling method to fill the THnSparse histogram
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :   UShort_t  timeBin    = (UShort_t)startTimeBin;</span>
<span class="lineNum">     776 </span>            :   Int_t padFill = pad;
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :   Double_t timeBurst=SetBurstHnDrift();</span>
<span class="lineNum">     778 </span>            : 
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :   if (fROCblackDataDown==-1 || fROCblackDataUp==-1){</span>
<span class="lineNum">     780 </span>            :     //only in new processing mode
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :     if (!fProcessNew) return;</span>
<span class="lineNum">     782 </span>            :     //don't use the IROCs and inner part of OROCs
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :     if (sector&lt;36) return;</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :     if (row&lt;40) return;</span>
<span class="lineNum">     785 </span>            :     //only bunches with reasonable length
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :     if (length&lt;3||length&gt;10) return;</span>
<span class="lineNum">     787 </span>            :     
<span class="lineNum">     788 </span>            :     //skip first laser layer
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :     if (timeBin&lt;280) return;</span>
<span class="lineNum">     790 </span>            :     
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :     Int_t cePeak=((sector/18)%2)*7+6;</span>
<span class="lineNum">     792 </span>            :     //after 1 event setup peak ranges
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :     if (fEventInBunch==1 &amp;&amp; fPeaks[cePeak]==0) {</span>
<span class="lineNum">     794 </span>            :       // set time range
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :       fHnDrift-&gt;GetAxis(4)-&gt;SetRangeUser(timeBurst-2*60,timeBurst+2*60);</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :       FindLaserLayers();</span>
<span class="lineNum">     797 </span>            :       // set time range
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :       fHnDrift-&gt;GetAxis(4)-&gt;SetRangeUser(fHnDrift-&gt;GetAxis(4)-&gt;GetXmin(),fHnDrift-&gt;GetAxis(4)-&gt;GetXmax());</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :       fHnDrift-&gt;Reset();</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     801 </span>            :     
<span class="lineNum">     802 </span>            :     // After the first event only fill every 5th  bin in a row with the CE information
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :     if (fEventInBunch==0||(fPeaks[cePeak]&gt;100&amp;&amp;TMath::Abs((Short_t)fPeaks[cePeak]-(Short_t)timeBin)&lt;(Short_t)fPeakWidths[cePeak])){</span>
<span class="lineNum">     804 </span>            :       Int_t mod=5;
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :       Int_t n=pad/mod;</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :       padFill=mod*n+mod/2;</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     808 </span>            :     
<span class="lineNum">     809 </span>            :     //noise removal
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :     if (!IsPeakInRange(timeBin+length/2,sector)) return;</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :   } else if( !(sector&gt;=fROCblackDataDown &amp;&amp; sector&lt;fROCblackDataUp) ) return;</span>
<span class="lineNum">     812 </span>            :   
<span class="lineNum">     813 </span>            :     
<span class="lineNum">     814 </span>            :     
<span class="lineNum">     815 </span>            :   
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :   Double_t x[kHnBinsDV]={(Double_t)sector,(Double_t)row,</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :       (Double_t)padFill,(Double_t)timeBin,timeBurst};</span>
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :   for (Int_t iTimeBin = 0; iTimeBin&lt;length; iTimeBin++){</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :     Float_t sig=(Float_t)signal[iTimeBin];</span>
<span class="lineNum">     821 </span>            :      // if (fPeaks[6]&gt;900&amp;&amp;timeBin&gt;(fPeaks[6]-20)&amp;&amp;sig&lt;20) continue;
<span class="lineNum">     822 </span>            :      // if (fPeaks[6]&gt;900&amp;&amp;timeBin&lt;(fPeaks[6]-fPeakWidth[6])&amp;&amp;sig&lt;5) continue;
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :     x[3]=timeBin;</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :     fHnDrift-&gt;Fill(x,sig);</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :     --timeBin;</span>
<span class="lineNum">     826 </span>            :   }
<a name="827"><span class="lineNum">     827 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     828 </span>            : //_____________________________________________________________________
<span class="lineNum">     829 </span>            : void AliTPCCalibCE::FindLaserLayers()
<span class="lineNum">     830 </span>            : {
<span class="lineNum">     831 </span>            :   /// Find the laser layer positoins
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span>            :   //A-side + C-side
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :   for (Int_t iside=0;iside&lt;2;++iside){</span>
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :     Int_t add=7*iside;</span>
<span class="lineNum">     836 </span>            :     //find CE signal position and width
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :     fHnDrift-&gt;GetAxis(0)-&gt;SetRangeUser(36+iside*18,53+iside*18);</span>
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :     TH1D *hproj=fHnDrift-&gt;Projection(3);</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :     hproj-&gt;GetXaxis()-&gt;SetRangeUser(700,1030);</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :     Int_t maxbin=hproj-&gt;GetMaximumBin();</span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :     Double_t binc=hproj-&gt;GetBinCenter(maxbin);</span>
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :     hproj-&gt;GetXaxis()-&gt;SetRangeUser(binc-5,binc+5);</span>
<span class="lineNum">     843 </span>            : 
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :     fPeaks[add+6]=(UShort_t)TMath::Nint(binc);</span>
<span class="lineNum">     845 </span>            :   //   fPeakWidths[4]=(UShort_t)TMath::Nint(4*hproj-&gt;GetRMS()+.5);
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :     fPeakWidths[add+6]=7;</span>
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :     hproj-&gt;GetXaxis()-&gt;SetRangeUser(0,maxbin-10);</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :     TSpectrum s(6);</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :     s.Search(hproj,2,&quot;goff&quot;);</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :     Int_t index[6];</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :     TMath::Sort(6,s.GetPositionX(),index,kFALSE);</span>
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :     for (Int_t i=0; i&lt;6; ++i){</span>
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :       fPeaks[i+add]=(UShort_t)TMath::Nint(s.GetPositionX()[index[i]]);</span>
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :       fPeakWidths[i+add]=5;</span>
<span class="lineNum">     856 </span>            :     }
<span class="lineNum">     857 </span>            : 
<span class="lineNum">     858 </span>            :     //other peaks
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span>            : //    Int_t timepos=fPeaks[4]-2*fPeakWidths[4];
<span class="lineNum">     861 </span>            : //    Int_t width=100;
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span>            : //    for (Int_t i=3; i&gt;=0; --i){
<span class="lineNum">     864 </span>            : //      hproj-&gt;GetXaxis()-&gt;SetRangeUser(timepos-width,timepos);
<span class="lineNum">     865 </span>            : //      fPeaks[i]=hproj-&gt;GetMaximumBin();
<span class="lineNum">     866 </span>            : //      fPeakWidths[i]=(UShort_t)TMath::Nint(10.);
<span class="lineNum">     867 </span>            : //      width=250;
<span class="lineNum">     868 </span>            : //      timepos=fPeaks[i]-width/2;
<span class="lineNum">     869 </span>            : //    }
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span>            : //    for (Int_t i=add; i&lt;add+7; ++i){
<span class="lineNum">     872 </span>            : //      printf(&quot;Peak: %u +- %u\n&quot;,fPeaks[i],fPeakWidths[i]);
<span class="lineNum">     873 </span>            : //    }
<span class="lineNum">     874 </span>            :     //check width and reset peak if &gt;100
<span class="lineNum">     875 </span>            : //    for (Int_t i=0; i&lt;5; ++i){
<span class="lineNum">     876 </span>            : //      if (fPeakWidths[i]&gt;100) {
<span class="lineNum">     877 </span>            : //        fPeaks[i]=0;
<span class="lineNum">     878 </span>            : //        fPeakWidths[i]=0;
<span class="lineNum">     879 </span>            : //      }
<span class="lineNum">     880 </span>            : //    }
<span class="lineNum">     881 </span>            : 
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :     delete hproj;</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     884 </span><span class="lineNoCov">          0 : }</span>
<a name="885"><span class="lineNum">     885 </span>            : </a>
<span class="lineNum">     886 </span>            : //_____________________________________________________________________
<span class="lineNum">     887 </span>            : void AliTPCCalibCE::FindPedestal(Float_t part)
<span class="lineNum">     888 </span>            : {
<span class="lineNum">     889 </span>            :   /// find pedestal and noise for the current pad. Use either database or
<span class="lineNum">     890 </span>            :   /// truncated mean with part*100%
<span class="lineNum">     891 </span>            : 
<span class="lineNum">     892 </span>            :   Bool_t noPedestal = kTRUE;
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span>            :     //use pedestal database if set
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :   if (fPedestalTPC&amp;&amp;fPadNoiseTPC){</span>
<span class="lineNum">     896 </span>            :         //only load new pedestals if the sector has changed
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :     if ( fCurrentSector!=fLastSector ){</span>
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :       fPedestalROC = fPedestalTPC-&gt;GetCalROC(fCurrentSector);</span>
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :       fPadNoiseROC = fPadNoiseTPC-&gt;GetCalROC(fCurrentSector);</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     901 </span>            : 
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :     if ( fPedestalROC&amp;&amp;fPadNoiseROC ){</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :       fPadPedestal = fPedestalROC-&gt;GetValue(fCurrentChannel)*(Float_t)(!fIsZeroSuppressed);</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :       fPadNoise    = fPadNoiseROC-&gt;GetValue(fCurrentChannel);</span>
<span class="lineNum">     905 </span>            :       noPedestal   = kFALSE;
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     907 </span>            : 
<span class="lineNum">     908 </span>            :   }
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span>            :     //if we are not running with pedestal database, or for the current sector there is no information
<span class="lineNum">     911 </span>            :     //available, calculate the pedestal and noise on the fly
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :   if ( noPedestal ) {</span>
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :     fPadPedestal = 0;</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :     fPadNoise    = 0;</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :     if ( fIsZeroSuppressed ) return;</span>
<span class="lineNum">     916 </span>            :     const Int_t kPedMax = 100;  //maximum pedestal value
<span class="lineNum">     917 </span>            :     Float_t  max    =  0;
<span class="lineNum">     918 </span>            :     Float_t  maxPos =  0;
<span class="lineNum">     919 </span>            :     Int_t    median =  -1;
<span class="lineNum">     920 </span>            :     Int_t    count0 =  0;
<span class="lineNum">     921 </span>            :     Int_t    count1 =  0;
<span class="lineNum">     922 </span>            :     //
<span class="lineNum">     923 </span>            :     Float_t padSignal=0;
<span class="lineNum">     924 </span>            :     //
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :     UShort_t histo[kPedMax];</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :     memset(histo,0,kPedMax*sizeof(UShort_t));</span>
<span class="lineNum">     927 </span>            : 
<span class="lineNum">     928 </span>            :         //fill pedestal histogram
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :     for (Int_t i=fFirstTimeBin; i&lt;=fLastTimeBin; ++i){</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :       padSignal = fPadSignal[i];</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :       if (padSignal&lt;=0) continue;</span>
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :       if (padSignal&gt;max &amp;&amp; i&gt;10) {</span>
<span class="lineNum">     933 </span>            :         max = padSignal;
<span class="lineNum">     934 </span>            :         maxPos = i;
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :       if (padSignal&gt;kPedMax-1) continue;</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :       histo[int(padSignal+0.5)]++;</span>
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :       count0++;</span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     940 </span>            :         //find median
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :     for (Int_t i=1; i&lt;kPedMax; ++i){</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :       if (count1&lt;count0*0.5) median=i;</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :       count1+=histo[i];</span>
<span class="lineNum">     944 </span>            :     }
<span class="lineNum">     945 </span>            :         // truncated mean
<span class="lineNum">     946 </span>            :     //
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :     Float_t count=histo[median] ,mean=histo[median]*median,  rms=histo[median]*median*median ;</span>
<span class="lineNum">     948 </span>            :     //
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :     for (Int_t idelta=1; idelta&lt;10; ++idelta){</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :       if (median-idelta&lt;=0) continue;</span>
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :       if (median+idelta&gt;kPedMax) continue;</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :       if (count&lt;part*count1){</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :         count+=histo[median-idelta];</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :         mean +=histo[median-idelta]*(median-idelta);</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :         rms  +=histo[median-idelta]*(median-idelta)*(median-idelta);</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :         count+=histo[median+idelta];</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :         mean +=histo[median+idelta]*(median+idelta);</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :         rms  +=histo[median+idelta]*(median+idelta)*(median+idelta);</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     960 </span>            :     }
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :     if ( count &gt; 0 ) {</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :       mean/=count;</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :       rms    = TMath::Sqrt(TMath::Abs(rms/count-mean*mean));</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :       fPadPedestal = mean;</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :       fPadNoise    = rms;</span>
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :   }</span>
<a name="968"><span class="lineNum">     968 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     969 </span>            : //_____________________________________________________________________
<span class="lineNum">     970 </span>            : void AliTPCCalibCE::UpdateCETimeRef()
<span class="lineNum">     971 </span>            : {
<span class="lineNum">     972 </span>            :   /// Find the time reference of the last valid CE signal in sector
<span class="lineNum">     973 </span>            :   /// for irocs of the A-Side the reference of the corresponging OROC is returned
<span class="lineNum">     974 </span>            :   /// the reason are the non reflective bands on the A-Side, which make the reference very uncertain
<span class="lineNum">     975 </span>            : 
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :   if ( fLastSector == fCurrentSector ) return;</span>
<span class="lineNum">     977 </span>            :   Int_t sector=fCurrentSector;
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :   if ( sector &lt; 18 ) sector+=36;</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :   fCurrentCETimeRef=0;</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :   TVectorF *vtRef = GetTMeanEvents(sector);</span>
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :   if ( !vtRef ) return;</span>
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :   Int_t vtRefSize= vtRef-&gt;GetNrows();</span>
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :   if ( vtRefSize &lt; fNevents+1 ) vtRef-&gt;ResizeTo(vtRefSize+100);</span>
<span class="lineNum">     984 </span>            :   else vtRefSize=fNevents;
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :   while ( (*vtRef)[vtRefSize]==0 &amp;&amp; vtRefSize&gt;=0 ) --vtRefSize;</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :   fCurrentCETimeRef=(*vtRef)[vtRefSize];</span>
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :   AliDebug(3,Form(&quot;Sector: %02d - T0 ref: %.2f&quot;,fCurrentSector,fCurrentCETimeRef));</span>
<a name="988"><span class="lineNum">     988 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     989 </span>            : //_____________________________________________________________________
<span class="lineNum">     990 </span>            : void AliTPCCalibCE::FindCESignal(TVectorD &amp;param, Float_t &amp;qSum, const TVectorF maxima)
<span class="lineNum">     991 </span>            : {
<span class="lineNum">     992 </span>            :   ///  Find position, signal width and height of the CE signal (last signal)
<span class="lineNum">     993 </span>            :   ///  param[0] = Qmax, param[1] = mean time, param[2] = rms;
<span class="lineNum">     994 </span>            :   ///  maxima: array of local maxima of the pad signal use the one closest to the mean CE position
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span>            :   Float_t ceQmax  =0, ceQsum=0, ceTime=0, ceRMS=0;
<span class="lineNum">     997 </span>            :   Int_t   cemaxpos       = 0;
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :   Float_t ceSumThreshold = fNoiseThresholdSum*fPadNoise;  // threshold for the signal sum</span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :   const Int_t    kCemin  = fPeakIntMinus;             // range for the analysis of the ce signal +- channels from the peak</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :   const Int_t    kCemax  = fPeakIntPlus;</span>
<span class="lineNum">    1001 </span>            : 
<span class="lineNum">    1002 </span>            :   Float_t minDist  = 25;  //initial minimum distance betweek roc mean ce signal and pad ce signal
<span class="lineNum">    1003 </span>            : 
<span class="lineNum">    1004 </span>            :     // find maximum closest to the sector mean from the last event
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :   for ( Int_t imax=0; imax&lt;maxima.GetNrows(); ++imax){</span>
<span class="lineNum">    1006 </span>            :         // get sector mean of last event
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :     Float_t tmean = fCurrentCETimeRef;</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :     if ( TMath::Abs( tmean-maxima[imax] ) &lt; minDist ) {</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :       minDist  = tmean-maxima[imax];</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :       cemaxpos = (Int_t)maxima[imax];</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1012 </span>            :   }
<span class="lineNum">    1013 </span>            : //   printf(&quot;L1 phase TB: %f\n&quot;,GetL1PhaseTB());
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :   if (cemaxpos!=0){</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :     ceQmax = fPadSignal[cemaxpos]-fPadPedestal;</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :     for (Int_t i=cemaxpos-kCemin; i&lt;=cemaxpos+kCemax; ++i){</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :       if ( (i&gt;fFirstTimeBin) &amp;&amp; (i&lt;fLastTimeBin) ){</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :         Float_t signal = fPadSignal[i]-fPadPedestal;</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :         if (signal&gt;0) {</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :           ceTime+=signal*(i+0.5);</span>
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :           ceRMS +=signal*(i+0.5)*(i+0.5);</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :           ceQsum+=signal;</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1025 </span>            :     }
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :   if (ceQmax&amp;&amp;ceQsum&gt;ceSumThreshold) {</span>
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :     ceTime/=ceQsum;</span>
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :     ceRMS  = TMath::Sqrt(TMath::Abs(ceRMS/ceQsum-ceTime*ceTime));</span>
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :     ceTime-=GetL1PhaseTB();</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :     fVTime0Offset.GetMatrixArray()[fCurrentSector]+=ceTime;   // mean time for each sector</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :     fVTime0OffsetCounter.GetMatrixArray()[fCurrentSector]++;</span>
<span class="lineNum">    1033 </span>            : 
<span class="lineNum">    1034 </span>            :   //Normalise Q to the 'cell-size': The wire density is the same in the IROC and OROC, therefore the
<span class="lineNum">    1035 </span>            :   //                                the pick-up signal should scale with the pad area. In addition
<span class="lineNum">    1036 </span>            :   //                                the signal should decrease with the wire distance (4mm in IROC, 6mm in OROC),
<span class="lineNum">    1037 </span>            :   //                                ratio 2/3. The pad area we express in cm2. We normalise the signal
<span class="lineNum">    1038 </span>            :   //                                to the OROC signal (factor 2/3 for the IROCs).
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :     Float_t norm = fParam-&gt;GetPadPitchWidth(fCurrentSector)*fParam-&gt;GetPadPitchLength(fCurrentSector,fCurrentRow);</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :     if ( fCurrentSector&lt;fParam-&gt;GetNInnerSector() ) norm*=3./2.;</span>
<span class="lineNum">    1041 </span>            : 
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :     ceQsum/=norm;</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :     fVMeanQ.GetMatrixArray()[fCurrentSector]+=ceQsum;</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :     fVMeanQCounter.GetMatrixArray()[fCurrentSector]++;</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">    1046 </span>            :     ceQmax=0;
<span class="lineNum">    1047 </span>            :     ceTime=0;
<span class="lineNum">    1048 </span>            :     ceRMS =0;
<span class="lineNum">    1049 </span>            :     ceQsum=0;
<span class="lineNum">    1050 </span>            :   }
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :   param[0] = ceQmax;</span>
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :   param[1] = ceTime;</span>
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :   param[2] = ceRMS;</span>
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :   qSum     = ceQsum;</span>
<a name="1055"><span class="lineNum">    1055 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1056 </span>            : //_____________________________________________________________________
<span class="lineNum">    1057 </span>            : Bool_t AliTPCCalibCE::IsPeak(Int_t pos, Int_t tminus, Int_t tplus) const
<span class="lineNum">    1058 </span>            : {
<span class="lineNum">    1059 </span>            :   /// Check if 'pos' is a Maximum. Consider 'tminus' timebins before
<span class="lineNum">    1060 </span>            :   /// and 'tplus' timebins after 'pos'
<span class="lineNum">    1061 </span>            : 
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :   if ( (pos-tminus)&lt;fFirstTimeBin || (pos+tplus)&gt;fLastTimeBin ) return kFALSE;</span>
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :   for (Int_t iTime = pos; iTime&gt;pos-tminus; --iTime)</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :     if ( fPadSignal[iTime-1] &gt;= fPadSignal[iTime] ) return kFALSE;</span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :   for (Int_t iTime = pos, iTime2=pos; iTime&lt;pos+tplus; ++iTime, ++iTime2){</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :     if ( (iTime==pos) &amp;&amp; (fPadSignal[iTime+1]==fPadSignal[iTime]) ) // allow two timebins with same adc value</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :       ++iTime2;</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :     if ( fPadSignal[iTime2+1] &gt;= fPadSignal[iTime2] ) return kFALSE;</span>
<span class="lineNum">    1069 </span>            :   }
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :   return kTRUE;</span>
<a name="1071"><span class="lineNum">    1071 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1072 </span>            : //_____________________________________________________________________
<span class="lineNum">    1073 </span>            : void AliTPCCalibCE::FindLocalMaxima(TVectorF &amp;maxima)
<span class="lineNum">    1074 </span>            : {
<span class="lineNum">    1075 </span>            :   /// Find local maxima on the pad signal and Histogram them
<span class="lineNum">    1076 </span>            : 
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :   Float_t ceThreshold = fNoiseThresholdMax*TMath::Max(fPadNoise,Float_t(1.));  // threshold for the signal</span>
<span class="lineNum">    1078 </span>            :   Int_t   count       = 0;
<span class="lineNum">    1079 </span>            : 
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :   for (Int_t i=fLastTimeBin-fPeakDetPlus+1; i&gt;=fFirstTimeBin+fPeakDetMinus; --i){</span>
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :     if ( (fPadSignal[i]-fPadPedestal)&lt;ceThreshold ) continue;</span>
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :     if (IsPeak(i,fPeakDetMinus,fPeakDetPlus) ){</span>
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :       if (count&lt;maxima.GetNrows()){</span>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :         maxima.GetMatrixArray()[count++]=i;</span>
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :         GetHistoTmean(fCurrentSector,kTRUE)-&gt;Fill(i);</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :         i-=(fPeakDetMinus+fPeakDetPlus-1); // next peak cannot be at bin  fPeakDetMinus+fPeakDetPlus-1</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1088 </span>            :     }
<span class="lineNum">    1089 </span>            :   }
<a name="1090"><span class="lineNum">    1090 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1091 </span>            : //_____________________________________________________________________
<span class="lineNum">    1092 </span>            : void AliTPCCalibCE::ProcessPad()
<span class="lineNum">    1093 </span>            : {
<span class="lineNum">    1094 </span>            :   ///  Process data of current pad
<span class="lineNum">    1095 </span>            : 
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :   FindPedestal();</span>
<span class="lineNum">    1097 </span>            : 
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :   TVectorF maxima(15);     // the expected maximum number of maxima in the complete TPC should be 8 laser beam layers</span>
<span class="lineNum">    1099 </span>            :                              // + central electrode and possibly post peaks from the CE signal
<span class="lineNum">    1100 </span>            :                              // however if we are on a high noise pad a lot more peaks due to the noise might occur
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :   FindLocalMaxima(maxima);</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :   if ( (fNevents == 0) || (fOldRunNumber!=fRunNumber) ) return;  // return because we don't have Time0 info for the CE yet</span>
<span class="lineNum">    1103 </span>            : 
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :   UpdateCETimeRef();                       // update the time refenrence for the current sector</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :   if ( fCurrentCETimeRef&lt;1e-30 ) return;      //return if we don't have time 0 info, eg if only one side has laser</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :   TVectorD param(3);</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :   Float_t  qSum;</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :   FindCESignal(param, qSum, maxima);</span>
<span class="lineNum">    1109 </span>            : 
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :   Double_t meanT  = param[1];</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :   Double_t sigmaT = param[2];</span>
<span class="lineNum">    1112 </span>            : 
<span class="lineNum">    1113 </span>            :     //Fill Event T0 counter
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :   (*GetPadTimesEvent(fCurrentSector,kTRUE)).GetMatrixArray()[fCurrentChannel] = meanT;</span>
<span class="lineNum">    1115 </span>            : 
<span class="lineNum">    1116 </span>            :     //Fill Q histogram
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :   GetHistoQ(fCurrentSector,kTRUE)-&gt;Fill( TMath::Sqrt(qSum), fCurrentChannel );</span>
<span class="lineNum">    1118 </span>            : 
<span class="lineNum">    1119 </span>            :     //Fill RMS histogram
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :   GetHistoRMS(fCurrentSector,kTRUE)-&gt;Fill( sigmaT, fCurrentChannel );</span>
<span class="lineNum">    1121 </span>            : 
<span class="lineNum">    1122 </span>            : 
<span class="lineNum">    1123 </span>            :     //Fill debugging info
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :   if ( GetStreamLevel()&gt;0 ){</span>
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :     (*GetPadPedestalEvent(fCurrentSector,kTRUE)).GetMatrixArray()[fCurrentChannel]=fPadPedestal;</span>
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :     (*GetPadRMSEvent(fCurrentSector,kTRUE)).GetMatrixArray()[fCurrentChannel]=sigmaT;</span>
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :     (*GetPadQEvent(fCurrentSector,kTRUE)).GetMatrixArray()[fCurrentChannel]=qSum;</span>
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1129 </span>            : 
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :   ResetPad();</span>
<a name="1131"><span class="lineNum">    1131 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1132 </span>            : //_____________________________________________________________________
<span class="lineNum">    1133 </span>            : void AliTPCCalibCE::EndEvent()
<span class="lineNum">    1134 </span>            : {
<span class="lineNum">    1135 </span>            :   ///  Process data of current pad
<span class="lineNum">    1136 </span>            :   ///  The Functions 'SetTimeStamp' and 'SetRunNumber'  should be called
<span class="lineNum">    1137 </span>            :   ///  before the EndEvent function to set the event timestamp and number!!!
<span class="lineNum">    1138 </span>            :   ///  This is automatically done if the ProcessEvent(AliRawReader *rawReader)
<span class="lineNum">    1139 </span>            :   ///  function was called
<span class="lineNum">    1140 </span>            : 
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :   if (!fProcessOld) {</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :     if (fProcessNew){</span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :       ++fNevents;</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :       ++fEventInBunch;</span>
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1146 </span>            :     return;
<span class="lineNum">    1147 </span>            :   }
<span class="lineNum">    1148 </span>            : 
<span class="lineNum">    1149 </span>            :   //check if last pad has allready been processed, if not do so
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :   if ( fMaxTimeBin&gt;-1 ) ProcessPad();</span>
<span class="lineNum">    1151 </span>            : 
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :   AliDebug(3, Form(&quot;EndEvent() - Start; Event: %05d&quot;, fNevents));</span>
<span class="lineNum">    1153 </span>            : 
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :   TVectorD param(3);</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :   TMatrixD dummy(3,3);</span>
<span class="lineNum">    1156 </span>            : //    TVectorF vMeanTime(72);
<span class="lineNum">    1157 </span>            : //    TVectorF vMeanQ(72);
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :   AliTPCCalROC *calIroc=new AliTPCCalROC(0);</span>
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :   AliTPCCalROC *calOroc=new AliTPCCalROC(36);</span>
<span class="lineNum">    1160 </span>            : 
<span class="lineNum">    1161 </span>            :   //find mean time0 offset for side A and C
<span class="lineNum">    1162 </span>            :   //use only orocs due to the better statistics
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :   Double_t time0Side[2];       //time0 for side A:0 and C:1</span>
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :   Double_t time0SideCount[2];  //time0 counter for side A:0 and C:1</span>
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :   time0Side[0]=0;time0Side[1]=0;time0SideCount[0]=0;time0SideCount[1]=0;</span>
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :   for ( Int_t iSec = 36; iSec&lt;72; ++iSec ){</span>
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :     time0Side[(iSec/18)%2] += fVTime0Offset.GetMatrixArray()[iSec];</span>
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :     time0SideCount[(iSec/18)%2] += fVTime0OffsetCounter.GetMatrixArray()[iSec];</span>
<span class="lineNum">    1169 </span>            :   }
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :   if ( time0SideCount[0] &gt;0  )</span>
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :     time0Side[0]/=time0SideCount[0];</span>
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :   if ( time0SideCount[1] &gt;0 )</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :     time0Side[1]/=time0SideCount[1];</span>
<span class="lineNum">    1174 </span>            :     // end find time0 offset
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :   AliDebug(3,Form(&quot;time0Side/time0SideCount: A=%.2f/%.2f, C=%.2f/%.2f&quot;,time0Side[0],time0SideCount[0],time0Side[1],time0SideCount[1]));</span>
<span class="lineNum">    1176 </span>            :   Int_t nSecMeanT=0;
<span class="lineNum">    1177 </span>            :   //loop over all ROCs, fill CE Time histogram corrected for the mean Time0 of each ROC
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :   for ( Int_t iSec = 0; iSec&lt;72; ++iSec ){</span>
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :     AliDebug(4,Form(&quot;Processing sector '%02d'\n&quot;,iSec));</span>
<span class="lineNum">    1180 </span>            :     //find median and then calculate the mean around it
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :     TH1S *hMeanT    = GetHistoTmean(iSec); //histogram with local maxima position information</span>
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :     if ( !hMeanT ) continue;</span>
<span class="lineNum">    1183 </span>            :     //continue if not enough data is filled in the meanT histogram. This is the case if we do not have a laser event.
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :     if ( hMeanT-&gt;GetEffectiveEntries() &lt; fROC-&gt;GetNChannels(iSec)*fSecRejectRatio ){</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :       hMeanT-&gt;Reset();</span>
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :       AliDebug(3,Form(&quot;Skipping sec. '%02d': Not enough statistics\n&quot;,iSec));</span>
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">    1188 </span>            :     }
<span class="lineNum">    1189 </span>            : 
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :     Double_t entries = hMeanT-&gt;GetEffectiveEntries();</span>
<span class="lineNum">    1191 </span>            :     Double_t sum     = 0;
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :     Short_t *arr     = hMeanT-&gt;GetArray()+1;</span>
<span class="lineNum">    1193 </span>            :     Int_t ibin=0;
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :     for ( ibin=0; ibin&lt;hMeanT-&gt;GetNbinsX(); ++ibin){</span>
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :       sum+=arr[ibin];</span>
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :       if ( sum&gt;=(entries/2.) ) break;</span>
<span class="lineNum">    1197 </span>            :     }
<span class="lineNum">    1198 </span>            :     Int_t delta = 4;
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :     Int_t firstBin = fFirstTimeBin+ibin-delta;</span>
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :     Int_t lastBin  = fFirstTimeBin+ibin+delta;</span>
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :     if ( firstBin&lt;fFirstTimeBin ) firstBin=fFirstTimeBin;</span>
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :     if ( lastBin&gt;fLastTimeBin   ) lastBin =fLastTimeBin;</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :     Float_t median =AliMathBase::GetCOG(arr+ibin-delta,2*delta,firstBin,lastBin);</span>
<span class="lineNum">    1204 </span>            : 
<span class="lineNum">    1205 </span>            :         // check boundaries for ebye info of mean time
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :     TVectorF *vMeanTime=GetTMeanEvents(iSec,kTRUE);</span>
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :     Int_t vSize=vMeanTime-&gt;GetNrows();</span>
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :     if ( vSize &lt; fNevents+1 ){</span>
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :       vMeanTime-&gt;ResizeTo(vSize+100);</span>
<span class="lineNum">    1210 </span>            :     }
<span class="lineNum">    1211 </span>            : 
<span class="lineNum">    1212 </span>            :     // store mean time for the readout sides
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :     vSize=fVTime0SideA.GetNrows();</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :     if ( vSize &lt; fNevents+1 ){</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :       fVTime0SideA.ResizeTo(vSize+100);</span>
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :       fVTime0SideC.ResizeTo(vSize+100);</span>
<span class="lineNum">    1217 </span>            :     }
<span class="lineNum">    1218 </span><span class="lineNoCov">          0 :     fVTime0SideA.GetMatrixArray()[fNevents]=time0Side[0];</span>
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :     fVTime0SideC.GetMatrixArray()[fNevents]=time0Side[1];</span>
<span class="lineNum">    1220 </span>            : 
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :     vMeanTime-&gt;GetMatrixArray()[fNevents]=median;</span>
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :     nSecMeanT++;</span>
<span class="lineNum">    1223 </span>            :     // end find median
<span class="lineNum">    1224 </span>            : 
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :     TVectorF *vTimes = GetPadTimesEvent(iSec);</span>
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :     if ( !vTimes ) continue;                     //continue if no time information for this sector is available</span>
<span class="lineNum">    1227 </span>            : 
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :     AliTPCCalROC calIrocOutliers(0);</span>
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :     AliTPCCalROC calOrocOutliers(36);</span>
<span class="lineNum">    1230 </span>            : 
<span class="lineNum">    1231 </span>            :     // calculate mean Q of the sector
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :     TVectorF *vMeanQ=GetQMeanEvents(iSec,kTRUE);</span>
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :     vSize=vMeanQ-&gt;GetNrows();</span>
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :     if ( vSize &lt; fNevents+1 ){</span>
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :       vMeanQ-&gt;ResizeTo(vSize+100);</span>
<span class="lineNum">    1236 </span>            :     }
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :     Float_t meanQ = 0;</span>
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :     if ( fVMeanQCounter.GetMatrixArray()[iSec]&gt;0 ) meanQ=fVMeanQ.GetMatrixArray()[iSec]/fVMeanQCounter.GetMatrixArray()[iSec];</span>
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :     vMeanQ-&gt;GetMatrixArray()[fNevents]=meanQ;</span>
<span class="lineNum">    1240 </span>            : 
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :     for ( UInt_t iChannel=0; iChannel&lt;fROC-&gt;GetNChannels(iSec); ++iChannel ){</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :       Float_t time  = (*vTimes).GetMatrixArray()[iChannel];</span>
<span class="lineNum">    1243 </span>            : 
<span class="lineNum">    1244 </span>            :             //set values for temporary roc calibration class
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :       if ( iSec &lt; 36 ) {</span>
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 :         calIroc-&gt;SetValue(iChannel, time);</span>
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :         if ( TMath::Abs(time) &lt; 1e-30 ) calIrocOutliers.SetValue(iChannel,1);</span>
<span class="lineNum">    1248 </span>            : 
<span class="lineNum">    1249 </span>            :       } else {
<span class="lineNum">    1250 </span><span class="lineNoCov">          0 :         calOroc-&gt;SetValue(iChannel, time);</span>
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :         if ( TMath::Abs(time) &lt; 1e-30 ) calOrocOutliers.SetValue(iChannel,1);</span>
<span class="lineNum">    1252 </span>            :       }
<span class="lineNum">    1253 </span>            : 
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :       if ( (fNevents&gt;0) &amp;&amp; (fOldRunNumber==fRunNumber) )</span>
<span class="lineNum">    1255 </span>            :         // test that we really found the CE signal reliably
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :         if ( TMath::Abs(fVTime0SideA.GetMatrixArray()[fNevents-1]-time0Side[0])&lt;.05)</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :           GetHistoT0(iSec,kTRUE)-&gt;Fill( time-time0Side[(iSec/18)%2],iChannel );</span>
<span class="lineNum">    1258 </span>            : 
<span class="lineNum">    1259 </span>            : 
<span class="lineNum">    1260 </span>            : 
<span class="lineNum">    1261 </span>            :             //-------------------------------  Debug start  ------------------------------
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :       if ( GetStreamLevel()&gt;0 ){</span>
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :         TTreeSRedirector *streamer=GetDebugStreamer();</span>
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :         if (streamer){</span>
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :           Int_t row=0;</span>
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :           Int_t pad=0;</span>
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :           Int_t padc=0;</span>
<span class="lineNum">    1268 </span>            : 
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :           Float_t q   = (*GetPadQEvent(iSec))[iChannel];</span>
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :           Float_t rms = (*GetPadRMSEvent(iSec))[iChannel];</span>
<span class="lineNum">    1271 </span>            : 
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :           UInt_t channel=iChannel;</span>
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :           Int_t sector=iSec;</span>
<span class="lineNum">    1274 </span>            : 
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :           while ( channel &gt; (fROC-&gt;GetRowIndexes(sector)[row]+fROC-&gt;GetNPads(sector,row)-1) ) row++;</span>
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :           pad = channel-fROC-&gt;GetRowIndexes(sector)[row];</span>
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :           padc = pad-(fROC-&gt;GetNPads(sector,row)/2);</span>
<span class="lineNum">    1278 </span>            : 
<span class="lineNum">    1279 </span>            : //              TH1F *h1 = new TH1F(Form(&quot;hSignalD%d.%d.%d&quot;,sector,row,pad),
<span class="lineNum">    1280 </span>            : //                                  Form(&quot;hSignalD%d.%d.%d&quot;,sector,row,pad),
<span class="lineNum">    1281 </span>            : //                                  fLastTimeBin-fFirstTimeBin,
<span class="lineNum">    1282 </span>            : //                                  fFirstTimeBin,fLastTimeBin);
<span class="lineNum">    1283 </span>            : //              h1-&gt;SetDirectory(0);
<span class="lineNum">    1284 </span>            :         //
<span class="lineNum">    1285 </span>            : //              for (Int_t i=fFirstTimeBin; i&lt;fLastTimeBin+1; ++i)
<span class="lineNum">    1286 </span>            : //                  h1-&gt;Fill(i,fPadSignal(i));
<span class="lineNum">    1287 </span>            : 
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :           Double_t t0Sec = 0;</span>
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 :           if (fVTime0OffsetCounter.GetMatrixArray()[iSec]&gt;0)</span>
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :             t0Sec = fVTime0Offset.GetMatrixArray()[iSec]/fVTime0OffsetCounter.GetMatrixArray()[iSec];</span>
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :           Double_t t0Side = time0Side[(iSec/18)%2];</span>
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :           (*streamer) &lt;&lt; &quot;DataPad&quot; &lt;&lt;</span>
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :             &quot;Event=&quot; &lt;&lt; fNevents &lt;&lt;</span>
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 :             &quot;RunNumber=&quot; &lt;&lt; fRunNumber &lt;&lt;</span>
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 :             &quot;TimeStamp=&quot;   &lt;&lt; fTimeStamp &lt;&lt;</span>
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :             &quot;Sector=&quot;&lt;&lt; sector &lt;&lt;</span>
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 :             &quot;Row=&quot;   &lt;&lt; row&lt;&lt;</span>
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :             &quot;Pad=&quot;   &lt;&lt; pad &lt;&lt;</span>
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 :             &quot;PadC=&quot;  &lt;&lt; padc &lt;&lt;</span>
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :             &quot;PadSec=&quot;&lt;&lt; channel &lt;&lt;</span>
<span class="lineNum">    1301 </span><span class="lineNoCov">          0 :             &quot;Time0Sec=&quot;  &lt;&lt; t0Sec &lt;&lt;</span>
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 :             &quot;Time0Side=&quot; &lt;&lt; t0Side &lt;&lt;</span>
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :             &quot;Time=&quot;  &lt;&lt; time &lt;&lt;</span>
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 :             &quot;RMS=&quot;   &lt;&lt; rms &lt;&lt;</span>
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 :             &quot;Sum=&quot;   &lt;&lt; q &lt;&lt;</span>
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :             &quot;MeanQ=&quot; &lt;&lt; meanQ &lt;&lt;</span>
<span class="lineNum">    1307 </span>            :         //                  &quot;hist.=&quot; &lt;&lt; h1 &lt;&lt;
<span class="lineNum">    1308 </span>            :             &quot;\n&quot;;
<span class="lineNum">    1309 </span>            : 
<span class="lineNum">    1310 </span>            :     //          delete h1;
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1313 </span>            :       //-----------------------------  Debug end  ------------------------------
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :     }// end channel loop</span>
<span class="lineNum">    1315 </span>            : 
<span class="lineNum">    1316 </span>            : 
<span class="lineNum">    1317 </span>            :     //do fitting now only in debug mode
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :     if (GetDebugLevel()&gt;0){</span>
<span class="lineNum">    1319 </span><span class="lineNoCov">          0 :       TVectorD paramPol1(3);</span>
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :       TVectorD paramPol2(6);</span>
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :       TMatrixD matPol1(3,3);</span>
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :       TMatrixD matPol2(6,6);</span>
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :       Float_t  chi2Pol1=0;</span>
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :       Float_t  chi2Pol2=0;</span>
<span class="lineNum">    1325 </span>            : 
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :       if ( (fNevents&gt;0) &amp;&amp; (fOldRunNumber==fRunNumber) ){</span>
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :         if ( iSec &lt; 36 ){</span>
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :           calIroc-&gt;GlobalFit(&amp;calIrocOutliers,0,paramPol1,matPol1,chi2Pol1,0);</span>
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :           calIroc-&gt;GlobalFit(&amp;calIrocOutliers,0,paramPol2,matPol2,chi2Pol2,1);</span>
<span class="lineNum">    1330 </span>            :         } else {
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :           calOroc-&gt;GlobalFit(&amp;calOrocOutliers,0,paramPol1,matPol1,chi2Pol1,0);</span>
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :           calOroc-&gt;GlobalFit(&amp;calOrocOutliers,0,paramPol2,matPol2,chi2Pol2,1);</span>
<span class="lineNum">    1333 </span>            :         }
<span class="lineNum">    1334 </span>            : 
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :         GetParamArrayPol1(iSec,kTRUE)-&gt;AddAtAndExpand(new TVectorD(paramPol1), fNevents);</span>
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :         GetParamArrayPol2(iSec,kTRUE)-&gt;AddAtAndExpand(new TVectorD(paramPol2), fNevents);</span>
<span class="lineNum">    1337 </span>            :       }
<span class="lineNum">    1338 </span>            : 
<span class="lineNum">    1339 </span>            :   //-------------------------------  Debug start  ------------------------------
<span class="lineNum">    1340 </span><span class="lineNoCov">          0 :       if ( GetStreamLevel()&gt;0 ){</span>
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :         TTreeSRedirector *streamer=GetDebugStreamer();</span>
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :         if ( streamer ) {</span>
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :           (*streamer) &lt;&lt; &quot;DataRoc&quot; &lt;&lt;</span>
<span class="lineNum">    1344 </span>            : //    &quot;Event=&quot; &lt;&lt; fEvent &lt;&lt;
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :             &quot;RunNumber=&quot; &lt;&lt; fRunNumber &lt;&lt;</span>
<span class="lineNum">    1346 </span><span class="lineNoCov">          0 :             &quot;TimeStamp=&quot;   &lt;&lt; fTimeStamp &lt;&lt;</span>
<span class="lineNum">    1347 </span><span class="lineNoCov">          0 :             &quot;Sector=&quot;&lt;&lt; iSec &lt;&lt;</span>
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 :             &quot;hMeanT.=&quot; &lt;&lt; hMeanT &lt;&lt;</span>
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :             &quot;median=&quot; &lt;&lt; median &lt;&lt;</span>
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :             &quot;paramPol1.=&quot; &lt;&lt; &amp;paramPol1 &lt;&lt;</span>
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :             &quot;paramPol2.=&quot; &lt;&lt; &amp;paramPol2 &lt;&lt;</span>
<span class="lineNum">    1352 </span><span class="lineNoCov">          0 :             &quot;matPol1.=&quot;   &lt;&lt; &amp;matPol1 &lt;&lt;</span>
<span class="lineNum">    1353 </span><span class="lineNoCov">          0 :             &quot;matPol2.=&quot;   &lt;&lt; &amp;matPol2 &lt;&lt;</span>
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 :             &quot;chi2Pol1=&quot;   &lt;&lt; chi2Pol1 &lt;&lt;</span>
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :             &quot;chi2Pol2=&quot;   &lt;&lt; chi2Pol2 &lt;&lt;</span>
<span class="lineNum">    1356 </span>            :             &quot;\n&quot;;
<span class="lineNum">    1357 </span>            :         }
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1360 </span>            :         //-------------------------------  Debug end  ------------------------------
<span class="lineNum">    1361 </span><span class="lineNoCov">          0 :     hMeanT-&gt;Reset();</span>
<span class="lineNum">    1362 </span><span class="lineNoCov">          0 :   }// end sector loop</span>
<span class="lineNum">    1363 </span>            :     //return if no sector has a valid mean time
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :   if ( nSecMeanT == 0 ) return;</span>
<span class="lineNum">    1365 </span>            : 
<span class="lineNum">    1366 </span>            : 
<span class="lineNum">    1367 </span>            : //    fTMeanArrayEvent.AddAtAndExpand(new TVectorF(vMeanTime),fNevents);
<span class="lineNum">    1368 </span>            : //    fQMeanArrayEvent.AddAtAndExpand(new TVectorF(vMeanQ),fNevents);
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :   if ( fVEventTime.GetNrows() &lt; fNevents+1 ) {</span>
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :     fVEventTime.ResizeTo((Int_t)(fVEventTime.GetNrows()+100));</span>
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :     fVEventNumber.ResizeTo((Int_t)(fVEventNumber.GetNrows()+100));</span>
<span class="lineNum">    1372 </span>            :   }
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 :   fVEventTime.GetMatrixArray()[fNevents] = fTimeStamp;</span>
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :   fVEventNumber.GetMatrixArray()[fNevents] = fEventId;</span>
<span class="lineNum">    1375 </span>            : 
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 :   ++fNevents;</span>
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :   if (fProcessNew) ++fEventInBunch;</span>
<span class="lineNum">    1378 </span><span class="lineNoCov">          0 :   fOldRunNumber = fRunNumber;</span>
<span class="lineNum">    1379 </span>            : 
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :   delete calIroc;</span>
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :   delete calOroc;</span>
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 :   AliDebug(3, Form(&quot;EndEvent() - End; Event: %05d&quot;, fNevents));</span>
<a name="1383"><span class="lineNum">    1383 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1384 </span>            : //_____________________________________________________________________
<span class="lineNum">    1385 </span>            : TH2S* AliTPCCalibCE::GetHisto(Int_t sector, TObjArray *arr,
<span class="lineNum">    1386 </span>            :                                   Int_t nbinsY, Float_t ymin, Float_t ymax,
<span class="lineNum">    1387 </span>            :                                   const Char_t *type, Bool_t force)
<span class="lineNum">    1388 </span>            : {
<span class="lineNum">    1389 </span>            :     /// return pointer to TH2S histogram of 'type'
<span class="lineNum">    1390 </span>            :     /// if force is true create a new histogram if it doesn't exist allready
<span class="lineNum">    1391 </span>            : 
<span class="lineNum">    1392 </span><span class="lineNoCov">          0 :     if ( !force || arr-&gt;UncheckedAt(sector) )</span>
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :       return (TH2S*)arr-&gt;UncheckedAt(sector);</span>
<span class="lineNum">    1394 </span>            : 
<span class="lineNum">    1395 </span>            :     // if we are forced and histogram doesn't exist yet create it
<span class="lineNum">    1396 </span>            :     // new histogram with Q calib information. One value for each pad!
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :     TH2S* hist = new TH2S(Form(&quot;hCalib%s%.2d&quot;,type,sector),Form(&quot;%s calibration histogram sector %.2d&quot;,type,sector),</span>
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :                           nbinsY, ymin, ymax,</span>
<span class="lineNum">    1399 </span><span class="lineNoCov">          0 :                           fROC-&gt;GetNChannels(sector),0,fROC-&gt;GetNChannels(sector));</span>
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :     hist-&gt;SetDirectory(0);</span>
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :     arr-&gt;AddAt(hist,sector);</span>
<span class="lineNum">    1402 </span>            :     return hist;
<a name="1403"><span class="lineNum">    1403 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1404 </span>            : //_____________________________________________________________________
<span class="lineNum">    1405 </span>            : TH2S* AliTPCCalibCE::GetHistoT0(Int_t sector, Bool_t force)
<span class="lineNum">    1406 </span>            : {
<span class="lineNum">    1407 </span>            :     /// return pointer to T0 histogram
<span class="lineNum">    1408 </span>            :     /// if force is true create a new histogram if it doesn't exist allready
<span class="lineNum">    1409 </span>            : 
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :     TObjArray *arr = &amp;fHistoT0Array;</span>
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :     return GetHisto(sector, arr, fNbinsT0, fXminT0, fXmaxT0, &quot;T0&quot;, force);</span>
<a name="1412"><span class="lineNum">    1412 </span>            : }</a>
<span class="lineNum">    1413 </span>            : //_____________________________________________________________________
<span class="lineNum">    1414 </span>            : TH2S* AliTPCCalibCE::GetHistoQ(Int_t sector, Bool_t force)
<span class="lineNum">    1415 </span>            : {
<span class="lineNum">    1416 </span>            :     /// return pointer to Q histogram
<span class="lineNum">    1417 </span>            :     /// if force is true create a new histogram if it doesn't exist allready
<span class="lineNum">    1418 </span>            : 
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :     TObjArray *arr = &amp;fHistoQArray;</span>
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :     return GetHisto(sector, arr, fNbinsQ, fXminQ, fXmaxQ, &quot;Q&quot;, force);</span>
<a name="1421"><span class="lineNum">    1421 </span>            : }</a>
<span class="lineNum">    1422 </span>            : //_____________________________________________________________________
<span class="lineNum">    1423 </span>            : TH2S* AliTPCCalibCE::GetHistoRMS(Int_t sector, Bool_t force)
<span class="lineNum">    1424 </span>            : {
<span class="lineNum">    1425 </span>            :     /// return pointer to Q histogram
<span class="lineNum">    1426 </span>            :     /// if force is true create a new histogram if it doesn't exist allready
<span class="lineNum">    1427 </span>            : 
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :     TObjArray *arr = &amp;fHistoRMSArray;</span>
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 :     return GetHisto(sector, arr, fNbinsRMS, fXminRMS, fXmaxRMS, &quot;RMS&quot;, force);</span>
<a name="1430"><span class="lineNum">    1430 </span>            : }</a>
<span class="lineNum">    1431 </span>            : //_____________________________________________________________________
<span class="lineNum">    1432 </span>            : TH1S* AliTPCCalibCE::GetHisto(Int_t sector, TObjArray *arr,
<span class="lineNum">    1433 </span>            :                               const Char_t *type, Bool_t force)
<span class="lineNum">    1434 </span>            : {
<span class="lineNum">    1435 </span>            :     /// return pointer to TH1S histogram
<span class="lineNum">    1436 </span>            :     /// if force is true create a new histogram if it doesn't exist allready
<span class="lineNum">    1437 </span>            : 
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :     if ( !force || arr-&gt;UncheckedAt(sector) )</span>
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :       return (TH1S*)arr-&gt;UncheckedAt(sector);</span>
<span class="lineNum">    1440 </span>            : 
<span class="lineNum">    1441 </span>            :     // if we are forced and histogram doesn't yes exist create it
<span class="lineNum">    1442 </span>            :     // new histogram with calib information. One value for each pad!
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :     TH1S* hist = new TH1S(Form(&quot;hCalib%s%.2d&quot;,type,sector),Form(&quot;%s calibration histogram sector %.2d&quot;,type,sector),</span>
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :                           fLastTimeBin-fFirstTimeBin,fFirstTimeBin,fLastTimeBin);</span>
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :     hist-&gt;SetDirectory(0);</span>
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :     arr-&gt;AddAt(hist,sector);</span>
<span class="lineNum">    1447 </span>            :     return hist;
<a name="1448"><span class="lineNum">    1448 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1449 </span>            : //_____________________________________________________________________
<span class="lineNum">    1450 </span>            : TH1S* AliTPCCalibCE::GetHistoTmean(Int_t sector, Bool_t force)
<span class="lineNum">    1451 </span>            : {
<span class="lineNum">    1452 </span>            :     /// return pointer to Q histogram
<span class="lineNum">    1453 </span>            :     /// if force is true create a new histogram if it doesn't exist allready
<span class="lineNum">    1454 </span>            : 
<span class="lineNum">    1455 </span><span class="lineNoCov">          0 :     TObjArray *arr = &amp;fHistoTmean;</span>
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 :     return GetHisto(sector, arr, &quot;LastTmean&quot;, force);</span>
<a name="1457"><span class="lineNum">    1457 </span>            : }</a>
<span class="lineNum">    1458 </span>            : //_____________________________________________________________________
<span class="lineNum">    1459 </span>            : TVectorF* AliTPCCalibCE::GetVectSector(Int_t sector, TObjArray *arr, UInt_t size, Bool_t force) const
<span class="lineNum">    1460 </span>            : {
<span class="lineNum">    1461 </span>            :     /// return pointer to Pad Info from 'arr' for the current event and sector
<span class="lineNum">    1462 </span>            :     /// if force is true create it if it doesn't exist allready
<span class="lineNum">    1463 </span>            : 
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 :     if ( !force || arr-&gt;UncheckedAt(sector) )</span>
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :         return (TVectorF*)arr-&gt;UncheckedAt(sector);</span>
<span class="lineNum">    1466 </span>            : 
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 :     TVectorF *vect = new TVectorF(size);</span>
<span class="lineNum">    1468 </span><span class="lineNoCov">          0 :     arr-&gt;AddAt(vect,sector);</span>
<span class="lineNum">    1469 </span>            :     return vect;
<a name="1470"><span class="lineNum">    1470 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1471 </span>            : //_____________________________________________________________________
<span class="lineNum">    1472 </span>            : TVectorF* AliTPCCalibCE::GetPadTimesEvent(Int_t sector, Bool_t force)
<span class="lineNum">    1473 </span>            : {
<span class="lineNum">    1474 </span>            :     /// return pointer to Pad Times Array for the current event and sector
<span class="lineNum">    1475 </span>            :     /// if force is true create it if it doesn't exist allready
<span class="lineNum">    1476 </span>            : 
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :     TObjArray *arr = &amp;fPadTimesArrayEvent;</span>
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :     return GetVectSector(sector,arr,fROC-&gt;GetNChannels(sector),force);</span>
<a name="1479"><span class="lineNum">    1479 </span>            : }</a>
<span class="lineNum">    1480 </span>            : //_____________________________________________________________________
<span class="lineNum">    1481 </span>            : TVectorF* AliTPCCalibCE::GetPadQEvent(Int_t sector, Bool_t force)
<span class="lineNum">    1482 </span>            : {
<span class="lineNum">    1483 </span>            :     /// return pointer to Pad Q Array for the current event and sector
<span class="lineNum">    1484 </span>            :     /// if force is true create it if it doesn't exist allready
<span class="lineNum">    1485 </span>            :     /// for debugging purposes only
<span class="lineNum">    1486 </span>            : 
<span class="lineNum">    1487 </span><span class="lineNoCov">          0 :     TObjArray *arr = &amp;fPadQArrayEvent;</span>
<span class="lineNum">    1488 </span><span class="lineNoCov">          0 :     return GetVectSector(sector,arr,fROC-&gt;GetNChannels(sector),force);</span>
<a name="1489"><span class="lineNum">    1489 </span>            : }</a>
<span class="lineNum">    1490 </span>            : //_____________________________________________________________________
<span class="lineNum">    1491 </span>            : TVectorF* AliTPCCalibCE::GetPadRMSEvent(Int_t sector, Bool_t force)
<span class="lineNum">    1492 </span>            : {
<span class="lineNum">    1493 </span>            :     /// return pointer to Pad RMS Array for the current event and sector
<span class="lineNum">    1494 </span>            :     /// if force is true create it if it doesn't exist allready
<span class="lineNum">    1495 </span>            :     /// for debugging purposes only
<span class="lineNum">    1496 </span>            : 
<span class="lineNum">    1497 </span><span class="lineNoCov">          0 :     TObjArray *arr = &amp;fPadRMSArrayEvent;</span>
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 :     return GetVectSector(sector,arr,fROC-&gt;GetNChannels(sector),force);</span>
<a name="1499"><span class="lineNum">    1499 </span>            : }</a>
<span class="lineNum">    1500 </span>            : //_____________________________________________________________________
<span class="lineNum">    1501 </span>            : TVectorF* AliTPCCalibCE::GetPadPedestalEvent(Int_t sector, Bool_t force)
<span class="lineNum">    1502 </span>            : {
<span class="lineNum">    1503 </span>            :     /// return pointer to Pad RMS Array for the current event and sector
<span class="lineNum">    1504 </span>            :     /// if force is true create it if it doesn't exist allready
<span class="lineNum">    1505 </span>            :     /// for debugging purposes only
<span class="lineNum">    1506 </span>            : 
<span class="lineNum">    1507 </span><span class="lineNoCov">          0 :     TObjArray *arr = &amp;fPadPedestalArrayEvent;</span>
<span class="lineNum">    1508 </span><span class="lineNoCov">          0 :     return GetVectSector(sector,arr,fROC-&gt;GetNChannels(sector),force);</span>
<a name="1509"><span class="lineNum">    1509 </span>            : }</a>
<span class="lineNum">    1510 </span>            : //_____________________________________________________________________
<span class="lineNum">    1511 </span>            : TVectorF* AliTPCCalibCE::GetTMeanEvents(Int_t sector, Bool_t force)
<span class="lineNum">    1512 </span>            : {
<span class="lineNum">    1513 </span>            :     /// return pointer to the EbyE info of the mean arrival time for 'sector'
<span class="lineNum">    1514 </span>            :     /// if force is true create it if it doesn't exist allready
<span class="lineNum">    1515 </span>            : 
<span class="lineNum">    1516 </span><span class="lineNoCov">          0 :     TObjArray *arr = &amp;fTMeanArrayEvent;</span>
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 :     return GetVectSector(sector,arr,100,force);</span>
<a name="1518"><span class="lineNum">    1518 </span>            : }</a>
<span class="lineNum">    1519 </span>            : //_____________________________________________________________________
<span class="lineNum">    1520 </span>            : TVectorF* AliTPCCalibCE::GetQMeanEvents(Int_t sector, Bool_t force)
<span class="lineNum">    1521 </span>            : {
<span class="lineNum">    1522 </span>            :     /// return pointer to the EbyE info of the mean arrival time for 'sector'
<span class="lineNum">    1523 </span>            :     /// if force is true create it if it doesn't exist allready
<span class="lineNum">    1524 </span>            : 
<span class="lineNum">    1525 </span><span class="lineNoCov">          0 :     TObjArray *arr = &amp;fQMeanArrayEvent;</span>
<span class="lineNum">    1526 </span><span class="lineNoCov">          0 :     return GetVectSector(sector,arr,100,force);</span>
<a name="1527"><span class="lineNum">    1527 </span>            : }</a>
<span class="lineNum">    1528 </span>            : //_____________________________________________________________________
<span class="lineNum">    1529 </span>            : AliTPCCalROC* AliTPCCalibCE::GetCalRoc(Int_t sector, TObjArray* arr, Bool_t force) const
<span class="lineNum">    1530 </span>            : {
<span class="lineNum">    1531 </span>            :     /// return pointer to ROC Calibration
<span class="lineNum">    1532 </span>            :     /// if force is true create a new histogram if it doesn't exist allready
<span class="lineNum">    1533 </span>            : 
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :     if ( !force || arr-&gt;UncheckedAt(sector) )</span>
<span class="lineNum">    1535 </span><span class="lineNoCov">          0 :         return (AliTPCCalROC*)arr-&gt;UncheckedAt(sector);</span>
<span class="lineNum">    1536 </span>            : 
<span class="lineNum">    1537 </span>            :     // if we are forced and histogram doesn't yes exist create it
<span class="lineNum">    1538 </span>            : 
<span class="lineNum">    1539 </span>            :     // new AliTPCCalROC for T0 information. One value for each pad!
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :     AliTPCCalROC *croc = new AliTPCCalROC(sector);</span>
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 :     arr-&gt;AddAt(croc,sector);</span>
<span class="lineNum">    1542 </span>            :     return croc;
<a name="1543"><span class="lineNum">    1543 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1544 </span>            : //_____________________________________________________________________
<span class="lineNum">    1545 </span>            : AliTPCCalROC* AliTPCCalibCE::GetCalRocT0(Int_t sector, Bool_t force)
<span class="lineNum">    1546 </span>            : {
<span class="lineNum">    1547 </span>            :     /// return pointer to Time 0 ROC Calibration
<span class="lineNum">    1548 </span>            :     /// if force is true create a new histogram if it doesn't exist allready
<span class="lineNum">    1549 </span>            : 
<span class="lineNum">    1550 </span><span class="lineNoCov">          0 :     TObjArray *arr = &amp;fCalRocArrayT0;</span>
<span class="lineNum">    1551 </span><span class="lineNoCov">          0 :     return GetCalRoc(sector, arr, force);</span>
<a name="1552"><span class="lineNum">    1552 </span>            : }</a>
<span class="lineNum">    1553 </span>            : //_____________________________________________________________________
<span class="lineNum">    1554 </span>            : AliTPCCalROC* AliTPCCalibCE::GetCalRocT0Err(Int_t sector, Bool_t force)
<span class="lineNum">    1555 </span>            : {
<span class="lineNum">    1556 </span>            :     /// return pointer to the error of Time 0 ROC Calibration
<span class="lineNum">    1557 </span>            :     /// if force is true create a new histogram if it doesn't exist allready
<span class="lineNum">    1558 </span>            : 
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :     TObjArray *arr = &amp;fCalRocArrayT0Err;</span>
<span class="lineNum">    1560 </span><span class="lineNoCov">          0 :     return GetCalRoc(sector, arr, force);</span>
<a name="1561"><span class="lineNum">    1561 </span>            : }</a>
<span class="lineNum">    1562 </span>            : //_____________________________________________________________________
<span class="lineNum">    1563 </span>            : AliTPCCalROC* AliTPCCalibCE::GetCalRocQ(Int_t sector, Bool_t force)
<span class="lineNum">    1564 </span>            : {
<span class="lineNum">    1565 </span>            :     /// return pointer to T0 ROC Calibration
<span class="lineNum">    1566 </span>            :     /// if force is true create a new histogram if it doesn't exist allready
<span class="lineNum">    1567 </span>            : 
<span class="lineNum">    1568 </span><span class="lineNoCov">          0 :     TObjArray *arr = &amp;fCalRocArrayQ;</span>
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :     return GetCalRoc(sector, arr, force);</span>
<a name="1570"><span class="lineNum">    1570 </span>            : }</a>
<span class="lineNum">    1571 </span>            : //_____________________________________________________________________
<span class="lineNum">    1572 </span>            : AliTPCCalROC* AliTPCCalibCE::GetCalRocRMS(Int_t sector, Bool_t force)
<span class="lineNum">    1573 </span>            : {
<span class="lineNum">    1574 </span>            :     /// return pointer to signal width ROC Calibration
<span class="lineNum">    1575 </span>            :     /// if force is true create a new histogram if it doesn't exist allready
<span class="lineNum">    1576 </span>            : 
<span class="lineNum">    1577 </span><span class="lineNoCov">          0 :     TObjArray *arr = &amp;fCalRocArrayRMS;</span>
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 :     return GetCalRoc(sector, arr, force);</span>
<a name="1579"><span class="lineNum">    1579 </span>            : }</a>
<span class="lineNum">    1580 </span>            : //_____________________________________________________________________
<span class="lineNum">    1581 </span>            : AliTPCCalROC* AliTPCCalibCE::GetCalRocOutliers(Int_t sector, Bool_t force)
<span class="lineNum">    1582 </span>            : {
<span class="lineNum">    1583 </span>            :     /// return pointer to Outliers
<span class="lineNum">    1584 </span>            :     /// if force is true create a new histogram if it doesn't exist allready
<span class="lineNum">    1585 </span>            : 
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :     TObjArray *arr = &amp;fCalRocArrayOutliers;</span>
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :     return GetCalRoc(sector, arr, force);</span>
<a name="1588"><span class="lineNum">    1588 </span>            : }</a>
<span class="lineNum">    1589 </span>            : //_____________________________________________________________________
<span class="lineNum">    1590 </span>            : TObjArray* AliTPCCalibCE::GetParamArray(Int_t sector, TObjArray* arr, Bool_t force) const
<span class="lineNum">    1591 </span>            : {
<span class="lineNum">    1592 </span>            :     /// return pointer to TObjArray of fit parameters
<span class="lineNum">    1593 </span>            :     /// if force is true create a new histogram if it doesn't exist allready
<span class="lineNum">    1594 </span>            : 
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 :     if ( !force || arr-&gt;UncheckedAt(sector) )</span>
<span class="lineNum">    1596 </span><span class="lineNoCov">          0 :         return (TObjArray*)arr-&gt;UncheckedAt(sector);</span>
<span class="lineNum">    1597 </span>            : 
<span class="lineNum">    1598 </span>            :     // if we are forced and array doesn't yes exist create it
<span class="lineNum">    1599 </span>            : 
<span class="lineNum">    1600 </span>            :     // new TObjArray for parameters
<span class="lineNum">    1601 </span><span class="lineNoCov">          0 :     TObjArray *newArr = new TObjArray;</span>
<span class="lineNum">    1602 </span><span class="lineNoCov">          0 :     arr-&gt;AddAt(newArr,sector);</span>
<span class="lineNum">    1603 </span>            :     return newArr;
<a name="1604"><span class="lineNum">    1604 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1605 </span>            : //_____________________________________________________________________
<span class="lineNum">    1606 </span>            : TObjArray* AliTPCCalibCE::GetParamArrayPol1(Int_t sector, Bool_t force)
<span class="lineNum">    1607 </span>            : {
<span class="lineNum">    1608 </span>            :     /// return pointer to TObjArray of fit parameters from plane fit
<span class="lineNum">    1609 </span>            :     /// if force is true create a new histogram if it doesn't exist allready
<span class="lineNum">    1610 </span>            : 
<span class="lineNum">    1611 </span><span class="lineNoCov">          0 :     TObjArray *arr = &amp;fParamArrayEventPol1;</span>
<span class="lineNum">    1612 </span><span class="lineNoCov">          0 :     return GetParamArray(sector, arr, force);</span>
<a name="1613"><span class="lineNum">    1613 </span>            : }</a>
<span class="lineNum">    1614 </span>            : //_____________________________________________________________________
<span class="lineNum">    1615 </span>            : TObjArray* AliTPCCalibCE::GetParamArrayPol2(Int_t sector, Bool_t force)
<span class="lineNum">    1616 </span>            : {
<span class="lineNum">    1617 </span>            :     /// return pointer to TObjArray of fit parameters from parabola fit
<span class="lineNum">    1618 </span>            :     /// if force is true create a new histogram if it doesn't exist allready
<span class="lineNum">    1619 </span>            : 
<span class="lineNum">    1620 </span><span class="lineNoCov">          0 :     TObjArray *arr = &amp;fParamArrayEventPol2;</span>
<span class="lineNum">    1621 </span><span class="lineNoCov">          0 :     return GetParamArray(sector, arr, force);</span>
<span class="lineNum">    1622 </span>            : }
<a name="1623"><span class="lineNum">    1623 </span>            : </a>
<span class="lineNum">    1624 </span>            : //_____________________________________________________________________
<span class="lineNum">    1625 </span>            : void AliTPCCalibCE::CreateDVhist()
<span class="lineNum">    1626 </span>            : {
<span class="lineNum">    1627 </span>            :   /// Setup the THnSparse for the drift velocity determination
<span class="lineNum">    1628 </span>            : 
<span class="lineNum">    1629 </span>            :   //HnSparse bins
<span class="lineNum">    1630 </span>            :   //roc, row, pad, timebin, timestamp
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 :   TTimeStamp begin(2010,01,01,0,0,0);</span>
<span class="lineNum">    1632 </span><span class="lineNoCov">          0 :   TTimeStamp end(2035,01,01,0,0,0);</span>
<span class="lineNum">    1633 </span><span class="lineNoCov">          0 :   Int_t nbinsTime=(end.GetSec()-begin.GetSec())/60; //Minutes resolution</span>
<span class="lineNum">    1634 </span>            : 
<span class="lineNum">    1635 </span><span class="lineNoCov">          0 :   Int_t    bins[kHnBinsDV] = { 72,  96,  140,  1030, nbinsTime};</span>
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :   Double_t xmin[kHnBinsDV] = { 0.,  0.,   0.,    0., (Double_t)begin.GetSec()};</span>
<span class="lineNum">    1637 </span><span class="lineNoCov">          0 :   Double_t xmax[kHnBinsDV] = {72., 96., 140., 1030., (Double_t)end.GetSec()};</span>
<span class="lineNum">    1638 </span>            : 
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 :   fHnDrift=new THnSparseI(&quot;fHnDrift&quot;,&quot;Laser digits&quot;,kHnBinsDV, bins, xmin, xmax);</span>
<span class="lineNum">    1640 </span><span class="lineNoCov">          0 :   fHnDrift-&gt;GetAxis(0)-&gt;SetNameTitle(&quot;ROC&quot;,&quot;Read-out chamber number&quot;);</span>
<span class="lineNum">    1641 </span><span class="lineNoCov">          0 :   fHnDrift-&gt;GetAxis(1)-&gt;SetNameTitle(&quot;Row&quot;,&quot;Row number&quot;);</span>
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 :   fHnDrift-&gt;GetAxis(2)-&gt;SetNameTitle(&quot;Pad&quot;,&quot;Pad number&quot;);</span>
<span class="lineNum">    1643 </span><span class="lineNoCov">          0 :   fHnDrift-&gt;GetAxis(3)-&gt;SetNameTitle(&quot;Timebin&quot;,&quot;Time bin [x100ns]&quot;);</span>
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :   fHnDrift-&gt;GetAxis(4)-&gt;SetNameTitle(&quot;EventTime&quot;,&quot;Event time&quot;);</span>
<span class="lineNum">    1645 </span><span class="lineNoCov">          0 :   fHnDrift-&gt;Reset();</span>
<span class="lineNum">    1646 </span><span class="lineNoCov">          0 : }</span>
<a name="1647"><span class="lineNum">    1647 </span>            : </a>
<span class="lineNum">    1648 </span>            : //_____________________________________________________________________
<span class="lineNum">    1649 </span>            : void AliTPCCalibCE::ResetEvent()
<span class="lineNum">    1650 </span>            : {
<span class="lineNum">    1651 </span>            :     ///  Reset global counters  -- Should be called before each event is processed
<span class="lineNum">    1652 </span>            : 
<span class="lineNum">    1653 </span><span class="lineNoCov">          0 :     fLastSector=-1;</span>
<span class="lineNum">    1654 </span><span class="lineNoCov">          0 :     fCurrentSector=-1;</span>
<span class="lineNum">    1655 </span><span class="lineNoCov">          0 :     fCurrentRow=-1;</span>
<span class="lineNum">    1656 </span><span class="lineNoCov">          0 :     fCurrentChannel=-1;</span>
<span class="lineNum">    1657 </span>            : 
<span class="lineNum">    1658 </span><span class="lineNoCov">          0 :     ResetPad();</span>
<span class="lineNum">    1659 </span>            : 
<span class="lineNum">    1660 </span><span class="lineNoCov">          0 :     fPadTimesArrayEvent.Delete();</span>
<span class="lineNum">    1661 </span><span class="lineNoCov">          0 :     fPadQArrayEvent.Delete();</span>
<span class="lineNum">    1662 </span><span class="lineNoCov">          0 :     fPadRMSArrayEvent.Delete();</span>
<span class="lineNum">    1663 </span><span class="lineNoCov">          0 :     fPadPedestalArrayEvent.Delete();</span>
<span class="lineNum">    1664 </span>            : 
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :     for ( Int_t i=0; i&lt;72; ++i ){</span>
<span class="lineNum">    1666 </span><span class="lineNoCov">          0 :         fVTime0Offset.GetMatrixArray()[i]=0;</span>
<span class="lineNum">    1667 </span><span class="lineNoCov">          0 :         fVTime0OffsetCounter.GetMatrixArray()[i]=0;</span>
<span class="lineNum">    1668 </span><span class="lineNoCov">          0 :         fVMeanQ.GetMatrixArray()[i]=0;</span>
<span class="lineNum">    1669 </span><span class="lineNoCov">          0 :         fVMeanQCounter.GetMatrixArray()[i]=0;</span>
<span class="lineNum">    1670 </span>            :     }
<a name="1671"><span class="lineNum">    1671 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1672 </span>            : //_____________________________________________________________________
<span class="lineNum">    1673 </span>            : void AliTPCCalibCE::ResetPad()
<span class="lineNum">    1674 </span>            : {
<span class="lineNum">    1675 </span>            :     ///  Reset pad infos -- Should be called after a pad has been processed
<span class="lineNum">    1676 </span>            : 
<span class="lineNum">    1677 </span><span class="lineNoCov">          0 :     for (Int_t i=fFirstTimeBin; i&lt;fLastTimeBin+1; ++i)</span>
<span class="lineNum">    1678 </span><span class="lineNoCov">          0 :       fPadSignal[i] = 0;</span>
<span class="lineNum">    1679 </span><span class="lineNoCov">          0 :     fMaxTimeBin   = -1;</span>
<span class="lineNum">    1680 </span><span class="lineNoCov">          0 :     fMaxPadSignal = -1;</span>
<span class="lineNum">    1681 </span><span class="lineNoCov">          0 :     fPadPedestal  = -1;</span>
<span class="lineNum">    1682 </span><span class="lineNoCov">          0 :     fPadNoise     = -1;</span>
<a name="1683"><span class="lineNum">    1683 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1684 </span>            : //_____________________________________________________________________
<span class="lineNum">    1685 </span>            : void AliTPCCalibCE::Merge(AliTPCCalibCE * const ce)
<span class="lineNum">    1686 </span>            : {
<span class="lineNum">    1687 </span>            :   ///  Merge ce to the current AliTPCCalibCE
<span class="lineNum">    1688 </span>            : 
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 :   MergeBase(ce);</span>
<span class="lineNum">    1690 </span><span class="lineNoCov">          0 :   Int_t nCEevents = ce-&gt;GetNeventsProcessed();</span>
<span class="lineNum">    1691 </span>            : 
<span class="lineNum">    1692 </span><span class="lineNoCov">          0 :   if (fProcessOld&amp;&amp;ce-&gt;fProcessOld){</span>
<span class="lineNum">    1693 </span>            :   //merge histograms
<span class="lineNum">    1694 </span><span class="lineNoCov">          0 :     for (Int_t iSec=0; iSec&lt;72; ++iSec){</span>
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :       TH2S *hRefQmerge   = ce-&gt;GetHistoQ(iSec);</span>
<span class="lineNum">    1696 </span><span class="lineNoCov">          0 :       TH2S *hRefT0merge  = ce-&gt;GetHistoT0(iSec);</span>
<span class="lineNum">    1697 </span><span class="lineNoCov">          0 :       TH2S *hRefRMSmerge = ce-&gt;GetHistoRMS(iSec);</span>
<span class="lineNum">    1698 </span>            : 
<span class="lineNum">    1699 </span>            : 
<span class="lineNum">    1700 </span><span class="lineNoCov">          0 :       if ( hRefQmerge ){</span>
<span class="lineNum">    1701 </span><span class="lineNoCov">          0 :         TDirectory *dir = hRefQmerge-&gt;GetDirectory(); hRefQmerge-&gt;SetDirectory(0);</span>
<span class="lineNum">    1702 </span><span class="lineNoCov">          0 :         TH2S *hRefQ   = GetHistoQ(iSec);</span>
<span class="lineNum">    1703 </span><span class="lineNoCov">          0 :         if ( hRefQ ) hRefQ-&gt;Add(hRefQmerge);</span>
<span class="lineNum">    1704 </span>            :         else {
<span class="lineNum">    1705 </span><span class="lineNoCov">          0 :           TH2S *hist = new TH2S(*hRefQmerge);</span>
<span class="lineNum">    1706 </span><span class="lineNoCov">          0 :           hist-&gt;SetDirectory(0);</span>
<span class="lineNum">    1707 </span><span class="lineNoCov">          0 :           fHistoQArray.AddAt(hist, iSec);</span>
<span class="lineNum">    1708 </span>            :         }
<span class="lineNum">    1709 </span><span class="lineNoCov">          0 :         hRefQmerge-&gt;SetDirectory(dir);</span>
<span class="lineNum">    1710 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1711 </span><span class="lineNoCov">          0 :       if ( hRefT0merge ){</span>
<span class="lineNum">    1712 </span><span class="lineNoCov">          0 :         TDirectory *dir = hRefT0merge-&gt;GetDirectory(); hRefT0merge-&gt;SetDirectory(0);</span>
<span class="lineNum">    1713 </span><span class="lineNoCov">          0 :         TH2S *hRefT0  = GetHistoT0(iSec);</span>
<span class="lineNum">    1714 </span><span class="lineNoCov">          0 :         if ( hRefT0 ) hRefT0-&gt;Add(hRefT0merge);</span>
<span class="lineNum">    1715 </span>            :         else {
<span class="lineNum">    1716 </span><span class="lineNoCov">          0 :           TH2S *hist = new TH2S(*hRefT0merge);</span>
<span class="lineNum">    1717 </span><span class="lineNoCov">          0 :           hist-&gt;SetDirectory(0);</span>
<span class="lineNum">    1718 </span><span class="lineNoCov">          0 :           fHistoT0Array.AddAt(hist, iSec);</span>
<span class="lineNum">    1719 </span>            :         }
<span class="lineNum">    1720 </span><span class="lineNoCov">          0 :         hRefT0merge-&gt;SetDirectory(dir);</span>
<span class="lineNum">    1721 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1722 </span><span class="lineNoCov">          0 :       if ( hRefRMSmerge ){</span>
<span class="lineNum">    1723 </span><span class="lineNoCov">          0 :         TDirectory *dir = hRefRMSmerge-&gt;GetDirectory(); hRefRMSmerge-&gt;SetDirectory(0);</span>
<span class="lineNum">    1724 </span><span class="lineNoCov">          0 :         TH2S *hRefRMS = GetHistoRMS(iSec);</span>
<span class="lineNum">    1725 </span><span class="lineNoCov">          0 :         if ( hRefRMS ) hRefRMS-&gt;Add(hRefRMSmerge);</span>
<span class="lineNum">    1726 </span>            :         else {
<span class="lineNum">    1727 </span><span class="lineNoCov">          0 :           TH2S *hist = new TH2S(*hRefRMSmerge);</span>
<span class="lineNum">    1728 </span><span class="lineNoCov">          0 :           hist-&gt;SetDirectory(0);</span>
<span class="lineNum">    1729 </span><span class="lineNoCov">          0 :           fHistoRMSArray.AddAt(hist, iSec);</span>
<span class="lineNum">    1730 </span>            :         }
<span class="lineNum">    1731 </span><span class="lineNoCov">          0 :         hRefRMSmerge-&gt;SetDirectory(dir);</span>
<span class="lineNum">    1732 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1733 </span>            : 
<span class="lineNum">    1734 </span>            :     }
<span class="lineNum">    1735 </span>            : 
<span class="lineNum">    1736 </span>            :     // merge time information
<span class="lineNum">    1737 </span>            : 
<span class="lineNum">    1738 </span>            : 
<span class="lineNum">    1739 </span><span class="lineNoCov">          0 :     for (Int_t iSec=0; iSec&lt;72; ++iSec){</span>
<span class="lineNum">    1740 </span><span class="lineNoCov">          0 :       TObjArray *arrPol1CE  = ce-&gt;GetParamArrayPol1(iSec);</span>
<span class="lineNum">    1741 </span><span class="lineNoCov">          0 :       TObjArray *arrPol2CE  = ce-&gt;GetParamArrayPol2(iSec);</span>
<span class="lineNum">    1742 </span><span class="lineNoCov">          0 :       TVectorF *vMeanTimeCE = ce-&gt;GetTMeanEvents(iSec);</span>
<span class="lineNum">    1743 </span><span class="lineNoCov">          0 :       TVectorF *vMeanQCE    = ce-&gt;GetQMeanEvents(iSec);</span>
<span class="lineNum">    1744 </span>            : 
<span class="lineNum">    1745 </span>            :       TObjArray *arrPol1  = 0x0;
<span class="lineNum">    1746 </span>            :       TObjArray *arrPol2  = 0x0;
<span class="lineNum">    1747 </span>            :       TVectorF *vMeanTime = 0x0;
<span class="lineNum">    1748 </span>            :       TVectorF *vMeanQ    = 0x0;
<span class="lineNum">    1749 </span>            : 
<span class="lineNum">    1750 </span>            :   //resize arrays
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :       if ( arrPol1CE &amp;&amp; arrPol2CE ){</span>
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :         arrPol1 = GetParamArrayPol1(iSec,kTRUE);</span>
<span class="lineNum">    1753 </span><span class="lineNoCov">          0 :         arrPol2 = GetParamArrayPol2(iSec,kTRUE);</span>
<span class="lineNum">    1754 </span><span class="lineNoCov">          0 :         arrPol1-&gt;Expand(fNevents+nCEevents);</span>
<span class="lineNum">    1755 </span><span class="lineNoCov">          0 :         arrPol2-&gt;Expand(fNevents+nCEevents);</span>
<span class="lineNum">    1756 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1757 </span><span class="lineNoCov">          0 :       if ( vMeanTimeCE &amp;&amp; vMeanQCE ){</span>
<span class="lineNum">    1758 </span><span class="lineNoCov">          0 :         vMeanTime = GetTMeanEvents(iSec,kTRUE);</span>
<span class="lineNum">    1759 </span><span class="lineNoCov">          0 :         vMeanQ    = GetQMeanEvents(iSec,kTRUE);</span>
<span class="lineNum">    1760 </span><span class="lineNoCov">          0 :         vMeanTime-&gt;ResizeTo(fNevents+nCEevents);</span>
<span class="lineNum">    1761 </span><span class="lineNoCov">          0 :         vMeanQ-&gt;ResizeTo(fNevents+nCEevents);</span>
<span class="lineNum">    1762 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1763 </span>            : 
<span class="lineNum">    1764 </span><span class="lineNoCov">          0 :       for (Int_t iEvent=0; iEvent&lt;nCEevents; ++iEvent){</span>
<span class="lineNum">    1765 </span><span class="lineNoCov">          0 :         if ( arrPol1CE &amp;&amp; arrPol2CE ){</span>
<span class="lineNum">    1766 </span><span class="lineNoCov">          0 :           TVectorD *paramPol1 = (TVectorD*)(arrPol1CE-&gt;UncheckedAt(iEvent));</span>
<span class="lineNum">    1767 </span><span class="lineNoCov">          0 :           TVectorD *paramPol2 = (TVectorD*)(arrPol2CE-&gt;UncheckedAt(iEvent));</span>
<span class="lineNum">    1768 </span><span class="lineNoCov">          0 :           if ( paramPol1 &amp;&amp; paramPol2 ){</span>
<span class="lineNum">    1769 </span><span class="lineNoCov">          0 :             GetParamArrayPol1(iSec,kTRUE)-&gt;AddAt(new TVectorD(*paramPol1), fNevents+iEvent);</span>
<span class="lineNum">    1770 </span><span class="lineNoCov">          0 :             GetParamArrayPol2(iSec,kTRUE)-&gt;AddAt(new TVectorD(*paramPol2), fNevents+iEvent);</span>
<span class="lineNum">    1771 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    1772 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1773 </span><span class="lineNoCov">          0 :         if ( vMeanTimeCE &amp;&amp; vMeanQCE ){</span>
<span class="lineNum">    1774 </span><span class="lineNoCov">          0 :           vMeanTime-&gt;GetMatrixArray()[fNevents+iEvent]=vMeanTimeCE-&gt;GetMatrixArray()[iEvent];</span>
<span class="lineNum">    1775 </span><span class="lineNoCov">          0 :           vMeanQ-&gt;GetMatrixArray()[fNevents+iEvent]=vMeanQCE-&gt;GetMatrixArray()[iEvent];</span>
<span class="lineNum">    1776 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1777 </span>            :       }
<span class="lineNum">    1778 </span>            :     }
<span class="lineNum">    1779 </span>            : 
<span class="lineNum">    1780 </span>            : 
<span class="lineNum">    1781 </span>            : 
<span class="lineNum">    1782 </span><span class="lineNoCov">          0 :     const TVectorD&amp;  eventTimes  = ce-&gt;fVEventTime;</span>
<span class="lineNum">    1783 </span><span class="lineNoCov">          0 :     const TVectorD&amp;  eventIds    = ce-&gt;fVEventNumber;</span>
<span class="lineNum">    1784 </span><span class="lineNoCov">          0 :     const TVectorF&amp;  time0SideA  = ce-&gt;fVTime0SideA;</span>
<span class="lineNum">    1785 </span><span class="lineNoCov">          0 :     const TVectorF&amp;  time0SideC  = ce-&gt;fVTime0SideC;</span>
<span class="lineNum">    1786 </span><span class="lineNoCov">          0 :     fVEventTime.ResizeTo(fNevents+nCEevents);</span>
<span class="lineNum">    1787 </span><span class="lineNoCov">          0 :     fVEventNumber.ResizeTo(fNevents+nCEevents);</span>
<span class="lineNum">    1788 </span><span class="lineNoCov">          0 :     fVTime0SideA.ResizeTo(fNevents+nCEevents);</span>
<span class="lineNum">    1789 </span><span class="lineNoCov">          0 :     fVTime0SideC.ResizeTo(fNevents+nCEevents);</span>
<span class="lineNum">    1790 </span>            : 
<span class="lineNum">    1791 </span><span class="lineNoCov">          0 :     for (Int_t iEvent=0; iEvent&lt;nCEevents; ++iEvent){</span>
<span class="lineNum">    1792 </span><span class="lineNoCov">          0 :       Double_t evTime     = eventTimes.GetMatrixArray()[iEvent];</span>
<span class="lineNum">    1793 </span><span class="lineNoCov">          0 :       Double_t evId       = eventIds.GetMatrixArray()[iEvent];</span>
<span class="lineNum">    1794 </span><span class="lineNoCov">          0 :       Float_t  t0SideA    = time0SideA.GetMatrixArray()[iEvent];</span>
<span class="lineNum">    1795 </span><span class="lineNoCov">          0 :       Float_t  t0SideC    = time0SideC.GetMatrixArray()[iEvent];</span>
<span class="lineNum">    1796 </span>            : 
<span class="lineNum">    1797 </span><span class="lineNoCov">          0 :       fVEventTime.GetMatrixArray()[fNevents+iEvent]   = evTime;</span>
<span class="lineNum">    1798 </span><span class="lineNoCov">          0 :       fVEventNumber.GetMatrixArray()[fNevents+iEvent] = evId;</span>
<span class="lineNum">    1799 </span><span class="lineNoCov">          0 :       fVTime0SideA.GetMatrixArray()[fNevents+iEvent]  = t0SideA;</span>
<span class="lineNum">    1800 </span><span class="lineNoCov">          0 :       fVTime0SideC.GetMatrixArray()[fNevents+iEvent]  = t0SideC;</span>
<span class="lineNum">    1801 </span>            :     }
<span class="lineNum">    1802 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1803 </span>            : 
<span class="lineNum">    1804 </span><span class="lineNoCov">          0 :   if (fProcessNew&amp;&amp;ce-&gt;fProcessNew) {</span>
<span class="lineNum">    1805 </span><span class="lineNoCov">          0 :     if (fArrHnDrift.GetEntries() != ce-&gt;fArrHnDrift.GetEntries() ){</span>
<span class="lineNum">    1806 </span><span class="lineNoCov">          0 :       AliError(&quot;Number of bursts in the instances to merge are different. No merging done!&quot;);</span>
<span class="lineNum">    1807 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">    1808 </span><span class="lineNoCov">          0 :       for (Int_t i=0;i&lt;fArrHnDrift.GetEntries();++i){</span>
<span class="lineNum">    1809 </span><span class="lineNoCov">          0 :         THnSparseI *h=(THnSparseI*)fArrHnDrift.UncheckedAt(i);</span>
<span class="lineNum">    1810 </span><span class="lineNoCov">          0 :         THnSparseI *hce=(THnSparseI*)ce-&gt;fArrHnDrift.UncheckedAt(i);</span>
<span class="lineNum">    1811 </span><span class="lineNoCov">          0 :         if (h &amp;&amp; hce) h-&gt;Add(hce);</span>
<span class="lineNum">    1812 </span><span class="lineNoCov">          0 :         else AliError(Form(&quot;AliTPCCalibCE::Merge - one THnSparse missing in burst %d&quot;,i));</span>
<span class="lineNum">    1813 </span>            :       }
<span class="lineNum">    1814 </span>            :       //TODO: What to do with fTimeBursts???
<span class="lineNum">    1815 </span>            :     }
<span class="lineNum">    1816 </span>            :   }
<span class="lineNum">    1817 </span>            : 
<span class="lineNum">    1818 </span><span class="lineNoCov">          0 :   fNevents+=nCEevents; //increase event counter</span>
<span class="lineNum">    1819 </span><span class="lineNoCov">          0 : }</span>
<a name="1820"><span class="lineNum">    1820 </span>            : </a>
<span class="lineNum">    1821 </span>            : //_____________________________________________________________________
<span class="lineNum">    1822 </span>            : Long64_t AliTPCCalibCE::Merge(TCollection * const list)
<span class="lineNum">    1823 </span>            : {
<span class="lineNum">    1824 </span>            :   /// Merge all objects of this type in list
<span class="lineNum">    1825 </span>            : 
<span class="lineNum">    1826 </span>            :   Long64_t nmerged=1;
<span class="lineNum">    1827 </span>            : 
<span class="lineNum">    1828 </span><span class="lineNoCov">          0 :   TIter next(list);</span>
<span class="lineNum">    1829 </span>            :   AliTPCCalibCE *ce=0;
<span class="lineNum">    1830 </span>            :   TObject *o=0;
<span class="lineNum">    1831 </span>            : 
<span class="lineNum">    1832 </span><span class="lineNoCov">          0 :   while ( (o=next()) ){</span>
<span class="lineNum">    1833 </span><span class="lineNoCov">          0 :     ce=dynamic_cast&lt;AliTPCCalibCE*&gt;(o);</span>
<span class="lineNum">    1834 </span><span class="lineNoCov">          0 :     if (ce){</span>
<span class="lineNum">    1835 </span><span class="lineNoCov">          0 :       Merge(ce);</span>
<span class="lineNum">    1836 </span><span class="lineNoCov">          0 :       ++nmerged;</span>
<span class="lineNum">    1837 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1838 </span>            :   }
<span class="lineNum">    1839 </span>            : 
<span class="lineNum">    1840 </span>            :   return nmerged;
<span class="lineNum">    1841 </span><span class="lineNoCov">          0 : }</span>
<a name="1842"><span class="lineNum">    1842 </span>            : </a>
<span class="lineNum">    1843 </span>            : //_____________________________________________________________________
<span class="lineNum">    1844 </span>            : TGraph *AliTPCCalibCE::MakeGraphTimeCE(Int_t sector, Int_t xVariable, Int_t fitType, Int_t fitParameter)
<span class="lineNum">    1845 </span>            : {
<span class="lineNum">    1846 </span>            :   /// Make graph from fit parameters of pol1 fit, pol2 fit, mean arrival time or mean Q for ROC 'sector'
<span class="lineNum">    1847 </span>            :   /// or side (-1: A-Side, -2: C-Side)
<span class="lineNum">    1848 </span>            :   /// xVariable:    0-event time, 1-event id, 2-internal event counter
<span class="lineNum">    1849 </span>            :   /// fitType:      0-pol1 fit, 1-pol2 fit, 2-mean time, 3-mean Q
<span class="lineNum">    1850 </span>            :   /// fitParameter: fit parameter ( 0-2 for pol1 ([0]+[1]*x+[2]*y),
<span class="lineNum">    1851 </span>            :   ///                               0-5 for pol2 ([0]+[1]*x+[2]*y+[3]*x*x+[4]*y*y+[5]*x*y),
<span class="lineNum">    1852 </span>            :   ///                               not used for mean time and mean Q )
<span class="lineNum">    1853 </span>            :   /// for an example see class description at the beginning
<span class="lineNum">    1854 </span>            : 
<span class="lineNum">    1855 </span>            :   TVectorD *xVar = 0x0;
<span class="lineNum">    1856 </span>            :   TObjArray *aType = 0x0;
<span class="lineNum">    1857 </span>            :   Int_t npoints=0;
<span class="lineNum">    1858 </span>            : 
<span class="lineNum">    1859 </span>            :   // sanity checks
<span class="lineNum">    1860 </span><span class="lineNoCov">          0 :   if ( (sector&lt;-2)   || (sector&gt;71)   ) return 0x0;  //sector outside valid range</span>
<span class="lineNum">    1861 </span><span class="lineNoCov">          0 :   if ( (xVariable&lt;0) || (xVariable&gt;2) ) return 0x0;  //invalid x-variable</span>
<span class="lineNum">    1862 </span><span class="lineNoCov">          0 :   if ( (fitType&lt;0)   || (fitType&gt;3)   ) return 0x0;  //invalid fit type</span>
<span class="lineNum">    1863 </span><span class="lineNoCov">          0 :   if ( sector&gt;=0 &amp;&amp; fitType==2 &amp;&amp; !GetTMeanEvents(sector) ) return 0x0; //no mean time information available</span>
<span class="lineNum">    1864 </span><span class="lineNoCov">          0 :   if ( sector&gt;=0 &amp;&amp; fitType==3 &amp;&amp; !GetQMeanEvents(sector) ) return 0x0; //no mean charge information available</span>
<span class="lineNum">    1865 </span><span class="lineNoCov">          0 :   if ( sector&lt;0 &amp;&amp; fitType!=2) return 0x0;  //for side wise information only mean time is available</span>
<span class="lineNum">    1866 </span>            : 
<span class="lineNum">    1867 </span><span class="lineNoCov">          0 :   if (sector&gt;=0){</span>
<span class="lineNum">    1868 </span><span class="lineNoCov">          0 :     if ( fitType==0 ){</span>
<span class="lineNum">    1869 </span><span class="lineNoCov">          0 :       if ( (fitParameter&lt;0) || (fitParameter&gt;2) ) return 0x0;</span>
<span class="lineNum">    1870 </span><span class="lineNoCov">          0 :       aType = &amp;fParamArrayEventPol1;</span>
<span class="lineNum">    1871 </span><span class="lineNoCov">          0 :       if ( aType-&gt;At(sector)==0x0 ) return 0x0;</span>
<span class="lineNum">    1872 </span>            :     }
<span class="lineNum">    1873 </span><span class="lineNoCov">          0 :     else if ( fitType==1 ){</span>
<span class="lineNum">    1874 </span><span class="lineNoCov">          0 :       if ( (fitParameter&lt;0) || (fitParameter&gt;5) ) return 0x0;</span>
<span class="lineNum">    1875 </span><span class="lineNoCov">          0 :       aType = &amp;fParamArrayEventPol2;</span>
<span class="lineNum">    1876 </span><span class="lineNoCov">          0 :       if ( aType-&gt;At(sector)==0x0 ) return 0x0;</span>
<span class="lineNum">    1877 </span>            :     }
<span class="lineNum">    1878 </span>            : 
<span class="lineNum">    1879 </span>            :   }
<span class="lineNum">    1880 </span><span class="lineNoCov">          0 :   if ( xVariable == 0 ) xVar = &amp;fVEventTime;</span>
<span class="lineNum">    1881 </span><span class="lineNoCov">          0 :   if ( xVariable == 1 ) xVar = &amp;fVEventNumber;</span>
<span class="lineNum">    1882 </span><span class="lineNoCov">          0 :   if ( xVariable == 2 ) {</span>
<span class="lineNum">    1883 </span><span class="lineNoCov">          0 :     xVar = new TVectorD(fNevents);</span>
<span class="lineNum">    1884 </span><span class="lineNoCov">          0 :     for ( Int_t i=0;i&lt;fNevents; ++i) (*xVar)[i]=i;</span>
<span class="lineNum">    1885 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1886 </span>            : 
<span class="lineNum">    1887 </span><span class="lineNoCov">          0 :   Double_t *x = new Double_t[fNevents];</span>
<span class="lineNum">    1888 </span><span class="lineNoCov">          0 :   Double_t *y = new Double_t[fNevents];</span>
<span class="lineNum">    1889 </span>            : 
<span class="lineNum">    1890 </span><span class="lineNoCov">          0 :   for (Int_t ievent =0; ievent&lt;fNevents; ++ievent){</span>
<span class="lineNum">    1891 </span><span class="lineNoCov">          0 :     if ( fitType&lt;2 ){</span>
<span class="lineNum">    1892 </span><span class="lineNoCov">          0 :       TObjArray *events = (TObjArray*)(aType-&gt;At(sector));</span>
<span class="lineNum">    1893 </span><span class="lineNoCov">          0 :       if ( events-&gt;GetSize()&lt;=ievent ) break;</span>
<span class="lineNum">    1894 </span><span class="lineNoCov">          0 :       TVectorD *v = (TVectorD*)(events-&gt;At(ievent));</span>
<span class="lineNum">    1895 </span><span class="lineNoCov">          0 :       if ( (v!=0x0) &amp;&amp; ((*xVar)[ievent]&gt;0) ) { x[npoints]=(*xVar)[ievent]; y[npoints]=(*v)[fitParameter]; npoints++;}</span>
<span class="lineNum">    1896 </span><span class="lineNoCov">          0 :     } else if (fitType == 2) {</span>
<span class="lineNum">    1897 </span><span class="lineNoCov">          0 :       Double_t xValue=(*xVar)[ievent];</span>
<span class="lineNum">    1898 </span>            :       Double_t yValue=0;
<span class="lineNum">    1899 </span><span class="lineNoCov">          0 :       if (sector&gt;=0) yValue = (*GetTMeanEvents(sector))[ievent];</span>
<span class="lineNum">    1900 </span><span class="lineNoCov">          0 :       else if (sector==-1) yValue=fVTime0SideA(ievent);</span>
<span class="lineNum">    1901 </span><span class="lineNoCov">          0 :       else if (sector==-2) yValue=fVTime0SideC(ievent);</span>
<span class="lineNum">    1902 </span><span class="lineNoCov">          0 :       if ( yValue&gt;0 &amp;&amp; xValue&gt;0 ) { x[npoints]=xValue; y[npoints]=yValue;npoints++;}</span>
<span class="lineNum">    1903 </span><span class="lineNoCov">          0 :     }else if (fitType == 3) {</span>
<span class="lineNum">    1904 </span><span class="lineNoCov">          0 :       Double_t xValue=(*xVar)[ievent];</span>
<span class="lineNum">    1905 </span><span class="lineNoCov">          0 :       Double_t yValue=(*GetQMeanEvents(sector))[ievent];</span>
<span class="lineNum">    1906 </span><span class="lineNoCov">          0 :       if ( yValue&gt;0 &amp;&amp; xValue&gt;0 ) { x[npoints]=xValue; y[npoints]=yValue;npoints++;}</span>
<span class="lineNum">    1907 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1908 </span>            :   }
<span class="lineNum">    1909 </span>            : 
<span class="lineNum">    1910 </span><span class="lineNoCov">          0 :   TGraph *gr = new TGraph(npoints);</span>
<span class="lineNum">    1911 </span>            :     //sort xVariable increasing
<span class="lineNum">    1912 </span><span class="lineNoCov">          0 :   Int_t    *sortIndex = new Int_t[npoints];</span>
<span class="lineNum">    1913 </span><span class="lineNoCov">          0 :   TMath::Sort(npoints,x,sortIndex, kFALSE);</span>
<span class="lineNum">    1914 </span><span class="lineNoCov">          0 :   for (Int_t i=0;i&lt;npoints;++i){</span>
<span class="lineNum">    1915 </span><span class="lineNoCov">          0 :     gr-&gt;SetPoint(i,x[sortIndex[i]],y[sortIndex[i]]);</span>
<span class="lineNum">    1916 </span>            :   }
<span class="lineNum">    1917 </span>            : 
<span class="lineNum">    1918 </span>            : 
<span class="lineNum">    1919 </span><span class="lineNoCov">          0 :   if ( xVariable == 2 ) delete xVar;</span>
<span class="lineNum">    1920 </span><span class="lineNoCov">          0 :   delete [] x;</span>
<span class="lineNum">    1921 </span><span class="lineNoCov">          0 :   delete [] y;</span>
<span class="lineNum">    1922 </span><span class="lineNoCov">          0 :   delete [] sortIndex;</span>
<span class="lineNum">    1923 </span>            :   return gr;
<a name="1924"><span class="lineNum">    1924 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1925 </span>            : //_____________________________________________________________________
<span class="lineNum">    1926 </span>            : void AliTPCCalibCE::Analyse()
<span class="lineNum">    1927 </span>            : {
<span class="lineNum">    1928 </span>            :   ///  Calculate calibration constants
<span class="lineNum">    1929 </span>            : 
<span class="lineNum">    1930 </span><span class="lineNoCov">          0 :   if (fProcessOld){</span>
<span class="lineNum">    1931 </span><span class="lineNoCov">          0 :     TVectorD paramQ(3);</span>
<span class="lineNum">    1932 </span><span class="lineNoCov">          0 :     TVectorD paramT0(3);</span>
<span class="lineNum">    1933 </span><span class="lineNoCov">          0 :     TVectorD paramRMS(3);</span>
<span class="lineNum">    1934 </span><span class="lineNoCov">          0 :     TMatrixD dummy(3,3);</span>
<span class="lineNum">    1935 </span>            : 
<span class="lineNum">    1936 </span>            :     Float_t channelCounter=0;
<span class="lineNum">    1937 </span><span class="lineNoCov">          0 :     fMeanT0rms=0;</span>
<span class="lineNum">    1938 </span><span class="lineNoCov">          0 :     fMeanQrms=0;</span>
<span class="lineNum">    1939 </span><span class="lineNoCov">          0 :     fMeanRMSrms=0;</span>
<span class="lineNum">    1940 </span>            : 
<span class="lineNum">    1941 </span><span class="lineNoCov">          0 :     for (Int_t iSec=0; iSec&lt;72; ++iSec){</span>
<span class="lineNum">    1942 </span><span class="lineNoCov">          0 :       TH2S *hT0 = GetHistoT0(iSec);</span>
<span class="lineNum">    1943 </span><span class="lineNoCov">          0 :       if (!hT0 ) continue;</span>
<span class="lineNum">    1944 </span>            : 
<span class="lineNum">    1945 </span><span class="lineNoCov">          0 :       AliTPCCalROC *rocQ     = GetCalRocQ  (iSec,kTRUE);</span>
<span class="lineNum">    1946 </span><span class="lineNoCov">          0 :       AliTPCCalROC *rocT0    = GetCalRocT0 (iSec,kTRUE);</span>
<span class="lineNum">    1947 </span><span class="lineNoCov">          0 :       AliTPCCalROC *rocT0Err = GetCalRocT0Err (iSec,kTRUE);</span>
<span class="lineNum">    1948 </span><span class="lineNoCov">          0 :       AliTPCCalROC *rocRMS   = GetCalRocRMS(iSec,kTRUE);</span>
<span class="lineNum">    1949 </span><span class="lineNoCov">          0 :       AliTPCCalROC *rocOut   = GetCalRocOutliers(iSec,kTRUE);</span>
<span class="lineNum">    1950 </span>            : 
<span class="lineNum">    1951 </span><span class="lineNoCov">          0 :       TH2S *hQ   = GetHistoQ(iSec);</span>
<span class="lineNum">    1952 </span><span class="lineNoCov">          0 :       TH2S *hRMS = GetHistoRMS(iSec);</span>
<span class="lineNum">    1953 </span>            : 
<span class="lineNum">    1954 </span><span class="lineNoCov">          0 :       Short_t *arrayhQ   = hQ-&gt;GetArray();</span>
<span class="lineNum">    1955 </span><span class="lineNoCov">          0 :       Short_t *arrayhT0  = hT0-&gt;GetArray();</span>
<span class="lineNum">    1956 </span><span class="lineNoCov">          0 :       Short_t *arrayhRMS = hRMS-&gt;GetArray();</span>
<span class="lineNum">    1957 </span>            : 
<span class="lineNum">    1958 </span><span class="lineNoCov">          0 :       UInt_t nChannels = fROC-&gt;GetNChannels(iSec);</span>
<span class="lineNum">    1959 </span>            : 
<span class="lineNum">    1960 </span>            :   //debug
<span class="lineNum">    1961 </span><span class="lineNoCov">          0 :       Int_t row=0;</span>
<span class="lineNum">    1962 </span><span class="lineNoCov">          0 :       Int_t pad=0;</span>
<span class="lineNum">    1963 </span><span class="lineNoCov">          0 :       Int_t padc=0;</span>
<span class="lineNum">    1964 </span>            :   //! debug
<span class="lineNum">    1965 </span>            : 
<span class="lineNum">    1966 </span><span class="lineNoCov">          0 :       for (UInt_t iChannel=0; iChannel&lt;nChannels; ++iChannel){</span>
<span class="lineNum">    1967 </span>            : 
<span class="lineNum">    1968 </span>            : 
<span class="lineNum">    1969 </span><span class="lineNoCov">          0 :         Float_t cogTime0 = -1000;</span>
<span class="lineNum">    1970 </span><span class="lineNoCov">          0 :         Float_t cogQ     = -1000;</span>
<span class="lineNum">    1971 </span><span class="lineNoCov">          0 :         Float_t cogRMS   = -1000;</span>
<span class="lineNum">    1972 </span>            :         Float_t cogOut   = 0;
<span class="lineNum">    1973 </span><span class="lineNoCov">          0 :         Float_t rms      = 0;</span>
<span class="lineNum">    1974 </span><span class="lineNoCov">          0 :         Float_t rmsT0    = 0;</span>
<span class="lineNum">    1975 </span>            : 
<span class="lineNum">    1976 </span>            : 
<span class="lineNum">    1977 </span><span class="lineNoCov">          0 :         Int_t offsetQ = (fNbinsQ+2)*(iChannel+1)+1;</span>
<span class="lineNum">    1978 </span><span class="lineNoCov">          0 :         Int_t offsetT0 = (fNbinsT0+2)*(iChannel+1)+1;</span>
<span class="lineNum">    1979 </span><span class="lineNoCov">          0 :         Int_t offsetRMS = (fNbinsRMS+2)*(iChannel+1)+1;</span>
<span class="lineNum">    1980 </span>            : 
<span class="lineNum">    1981 </span><span class="lineNoCov">          0 :         cogQ     = AliMathBase::GetCOG(arrayhQ+offsetQ,fNbinsQ,fXminQ,fXmaxQ,&amp;rms);</span>
<span class="lineNum">    1982 </span><span class="lineNoCov">          0 :         fMeanQrms+=rms;</span>
<span class="lineNum">    1983 </span><span class="lineNoCov">          0 :         cogTime0 = AliMathBase::GetCOG(arrayhT0+offsetT0,fNbinsT0,fXminT0,fXmaxT0,&amp;rmsT0);</span>
<span class="lineNum">    1984 </span><span class="lineNoCov">          0 :         fMeanT0rms+=rmsT0;</span>
<span class="lineNum">    1985 </span><span class="lineNoCov">          0 :         cogRMS   = AliMathBase::GetCOG(arrayhRMS+offsetRMS,fNbinsRMS,fXminRMS,fXmaxRMS,&amp;rms);</span>
<span class="lineNum">    1986 </span><span class="lineNoCov">          0 :         fMeanRMSrms+=rms;</span>
<span class="lineNum">    1987 </span><span class="lineNoCov">          0 :         channelCounter++;</span>
<span class="lineNum">    1988 </span>            : 
<span class="lineNum">    1989 </span>            :       /*
<span class="lineNum">    1990 </span>            :              //outlier specifications
<span class="lineNum">    1991 </span>            :          if ( (cogQ &lt; ??) &amp;&amp; (cogTime0 &gt; ??) &amp;&amp; (cogTime0&lt;??) &amp;&amp; ( cogRMS&gt;??) ){
<span class="lineNum">    1992 </span>            :          cogOut = 1;
<span class="lineNum">    1993 </span>            :           cogTime0 = 0;
<span class="lineNum">    1994 </span>            :           cogQ     = 0;
<span class="lineNum">    1995 </span>            :           cogRMS   = 0;
<span class="lineNum">    1996 </span>            :       }
<span class="lineNum">    1997 </span>            :       */
<span class="lineNum">    1998 </span><span class="lineNoCov">          0 :         rocQ-&gt;SetValue(iChannel, cogQ*cogQ);</span>
<span class="lineNum">    1999 </span><span class="lineNoCov">          0 :         rocT0-&gt;SetValue(iChannel, cogTime0);</span>
<span class="lineNum">    2000 </span><span class="lineNoCov">          0 :         rocT0Err-&gt;SetValue(iChannel, rmsT0);</span>
<span class="lineNum">    2001 </span><span class="lineNoCov">          0 :         rocRMS-&gt;SetValue(iChannel, cogRMS);</span>
<span class="lineNum">    2002 </span><span class="lineNoCov">          0 :         rocOut-&gt;SetValue(iChannel, cogOut);</span>
<span class="lineNum">    2003 </span>            : 
<span class="lineNum">    2004 </span>            : 
<span class="lineNum">    2005 </span>            :       //debug
<span class="lineNum">    2006 </span><span class="lineNoCov">          0 :         if ( GetStreamLevel() &gt; 0 ){</span>
<span class="lineNum">    2007 </span><span class="lineNoCov">          0 :           TTreeSRedirector *streamer=GetDebugStreamer();</span>
<span class="lineNum">    2008 </span><span class="lineNoCov">          0 :           if ( streamer ) {</span>
<span class="lineNum">    2009 </span>            : 
<span class="lineNum">    2010 </span><span class="lineNoCov">          0 :             while ( iChannel &gt; (fROC-&gt;GetRowIndexes(iSec)[row]+fROC-&gt;GetNPads(iSec,row)-1) ) row++;</span>
<span class="lineNum">    2011 </span><span class="lineNoCov">          0 :             pad = iChannel-fROC-&gt;GetRowIndexes(iSec)[row];</span>
<span class="lineNum">    2012 </span><span class="lineNoCov">          0 :             padc = pad-(fROC-&gt;GetNPads(iSec,row)/2);</span>
<span class="lineNum">    2013 </span>            : 
<span class="lineNum">    2014 </span><span class="lineNoCov">          0 :             (*streamer) &lt;&lt; &quot;DataEnd&quot; &lt;&lt;</span>
<span class="lineNum">    2015 </span><span class="lineNoCov">          0 :               &quot;Sector=&quot;  &lt;&lt; iSec      &lt;&lt;</span>
<span class="lineNum">    2016 </span><span class="lineNoCov">          0 :               &quot;Pad=&quot;     &lt;&lt; pad       &lt;&lt;</span>
<span class="lineNum">    2017 </span><span class="lineNoCov">          0 :               &quot;PadC=&quot;    &lt;&lt; padc      &lt;&lt;</span>
<span class="lineNum">    2018 </span><span class="lineNoCov">          0 :               &quot;Row=&quot;     &lt;&lt; row       &lt;&lt;</span>
<span class="lineNum">    2019 </span><span class="lineNoCov">          0 :               &quot;PadSec=&quot;  &lt;&lt; iChannel   &lt;&lt;</span>
<span class="lineNum">    2020 </span><span class="lineNoCov">          0 :               &quot;Q=&quot;       &lt;&lt; cogQ      &lt;&lt;</span>
<span class="lineNum">    2021 </span><span class="lineNoCov">          0 :               &quot;T0=&quot;      &lt;&lt; cogTime0  &lt;&lt;</span>
<span class="lineNum">    2022 </span><span class="lineNoCov">          0 :               &quot;RMS=&quot;     &lt;&lt; cogRMS    &lt;&lt;</span>
<span class="lineNum">    2023 </span>            :               &quot;\n&quot;;
<span class="lineNum">    2024 </span>            :           }
<span class="lineNum">    2025 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2026 </span>            :       //! debug
<span class="lineNum">    2027 </span>            : 
<span class="lineNum">    2028 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    2029 </span>            : 
<span class="lineNum">    2030 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2031 </span><span class="lineNoCov">          0 :     if ( channelCounter&gt;0 ){</span>
<span class="lineNum">    2032 </span><span class="lineNoCov">          0 :       fMeanT0rms/=channelCounter;</span>
<span class="lineNum">    2033 </span><span class="lineNoCov">          0 :       fMeanQrms/=channelCounter;</span>
<span class="lineNum">    2034 </span><span class="lineNoCov">          0 :       fMeanRMSrms/=channelCounter;</span>
<span class="lineNum">    2035 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2036 </span>            :     //   if ( fDebugStreamer ) fDebugStreamer-&gt;GetFile()-&gt;Write();
<span class="lineNum">    2037 </span>            :     //    delete fDebugStreamer;
<span class="lineNum">    2038 </span>            :     //    fDebugStreamer = 0x0;
<span class="lineNum">    2039 </span><span class="lineNoCov">          0 :     fVEventTime.ResizeTo(fNevents);</span>
<span class="lineNum">    2040 </span><span class="lineNoCov">          0 :     fVEventNumber.ResizeTo(fNevents);</span>
<span class="lineNum">    2041 </span><span class="lineNoCov">          0 :     fVTime0SideA.ResizeTo(fNevents);</span>
<span class="lineNum">    2042 </span><span class="lineNoCov">          0 :     fVTime0SideC.ResizeTo(fNevents);</span>
<span class="lineNum">    2043 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2044 </span>            : 
<span class="lineNum">    2045 </span><span class="lineNoCov">          0 :   if (fProcessNew&amp;&amp;fAnalyseNew){</span>
<span class="lineNum">    2046 </span><span class="lineNoCov">          0 :     AnalyseTrack();</span>
<span class="lineNum">    2047 </span><span class="lineNoCov">          0 :     for (Int_t iburst=0; iburst&lt;fArrHnDrift.GetEntries(); ++iburst){</span>
<span class="lineNum">    2048 </span><span class="lineNoCov">          0 :       THnSparseI *h=(THnSparseI*)fArrHnDrift.UncheckedAt(iburst);</span>
<span class="lineNum">    2049 </span><span class="lineNoCov">          0 :       h-&gt;GetAxis(4)-&gt;SetRangeUser(fTimeBursts[iburst]-60*5,fTimeBursts[iburst]+60*5);</span>
<span class="lineNum">    2050 </span>            :     }
<span class="lineNum">    2051 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2052 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2053 </span>            : 
<span class="lineNum">    2054 </span>            : 
<span class="lineNum">    2055 </span>            : 
<span class="lineNum">    2056 </span>            : 
<span class="lineNum">    2057 </span>            : //
<span class="lineNum">    2058 </span>            : // New functions that also use the laser tracks
<span class="lineNum">    2059 </span>            : //
<span class="lineNum">    2060 </span>            : 
<span class="lineNum">    2061 </span>            : 
<a name="2062"><span class="lineNum">    2062 </span>            : </a>
<span class="lineNum">    2063 </span>            : //_____________________________________________________________________
<span class="lineNum">    2064 </span>            : void AliTPCCalibCE::FindLocalMaxima(TObjArray * const arrObj, Double_t timestamp, Int_t burst)
<span class="lineNum">    2065 </span>            : {
<span class="lineNum">    2066 </span>            :   /// Find the local maximums for the projections to each axis
<span class="lineNum">    2067 </span>            : 
<span class="lineNum">    2068 </span>            :   //find laser layer positoins
<span class="lineNum">    2069 </span><span class="lineNoCov">          0 :   fHnDrift-&gt;GetAxis(4)-&gt;SetRangeUser(timestamp-2*60,timestamp+2*60);</span>
<span class="lineNum">    2070 </span><span class="lineNoCov">          0 :   FindLaserLayers();</span>
<span class="lineNum">    2071 </span><span class="lineNoCov">          0 :   THnSparse *hProj=fHnDrift;</span>
<span class="lineNum">    2072 </span><span class="lineNoCov">          0 :   Double_t posCE[4]={0.,0.,0.,0.};</span>
<span class="lineNum">    2073 </span><span class="lineNoCov">          0 :   Double_t widthCE[4]={0.,0.,0.,0.};</span>
<span class="lineNum">    2074 </span>            : 
<span class="lineNum">    2075 </span>            : //   if(fPeaks[4]!=0){
<span class="lineNum">    2076 </span>            :   // find central electrode position once more, separately for IROC, OROC, A-, C-Side
<span class="lineNum">    2077 </span>            : 
<span class="lineNum">    2078 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;4; ++i){</span>
<span class="lineNum">    2079 </span><span class="lineNoCov">          0 :     Int_t ce=(i/2&gt;0)*7+6;</span>
<span class="lineNum">    2080 </span><span class="lineNoCov">          0 :     hProj-&gt;GetAxis(0)-&gt;SetRangeUser(i*18,(i+1)*18-1);</span>
<span class="lineNum">    2081 </span><span class="lineNoCov">          0 :     TH1 *h=fHnDrift-&gt;Projection(3);</span>
<span class="lineNum">    2082 </span><span class="lineNoCov">          0 :     h-&gt;GetXaxis()-&gt;SetRangeUser(fPeaks[ce]-fPeakWidths[ce],fPeaks[ce]+fPeakWidths[ce]);</span>
<span class="lineNum">    2083 </span><span class="lineNoCov">          0 :     Int_t nbinMax=h-&gt;GetMaximumBin();</span>
<span class="lineNum">    2084 </span><span class="lineNoCov">          0 :     Double_t maximum=h-&gt;GetMaximum();</span>
<span class="lineNum">    2085 </span>            : //     Double_t maxExpected=fNevents/fArrHnDrift-&gt;GetEntries()*556568./5./10.;
<span class="lineNum">    2086 </span>            : //     if (nbinMax&lt;700||maximum&lt;maxExpected) continue;
<span class="lineNum">    2087 </span><span class="lineNoCov">          0 :     Double_t xbinMax=h-&gt;GetBinCenter(nbinMax);</span>
<span class="lineNum">    2088 </span><span class="lineNoCov">          0 :     TF1 fgaus(&quot;gaus&quot;,&quot;gaus&quot;,xbinMax-5,xbinMax+5);</span>
<span class="lineNum">    2089 </span><span class="lineNoCov">          0 :     fgaus.SetParameters(maximum,xbinMax,2);</span>
<span class="lineNum">    2090 </span><span class="lineNoCov">          0 :     fgaus.SetParLimits(1,xbinMax-5.,xbinMax+5.);</span>
<span class="lineNum">    2091 </span><span class="lineNoCov">          0 :     fgaus.SetParLimits(2,0.2,4.);</span>
<span class="lineNum">    2092 </span><span class="lineNoCov">          0 :     h-&gt;Fit(&amp;fgaus,&quot;RQN&quot;);</span>
<span class="lineNum">    2093 </span>            : //     Double_t deltaX=4*fgaus.GetParameter(2);
<span class="lineNum">    2094 </span>            : //     xbinMax=fgaus.GetParameter(1);
<span class="lineNum">    2095 </span><span class="lineNoCov">          0 :     delete h;</span>
<span class="lineNum">    2096 </span><span class="lineNoCov">          0 :     posCE[i]=fgaus.GetParameter(1);</span>
<span class="lineNum">    2097 </span><span class="lineNoCov">          0 :     widthCE[i]=4*fgaus.GetParameter(2);</span>
<span class="lineNum">    2098 </span><span class="lineNoCov">          0 :     hProj-&gt;GetAxis(0)-&gt;SetRangeUser(0,72);</span>
<span class="lineNum">    2099 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2100 </span>            : //   }
<span class="lineNum">    2101 </span>            :   //Current drift velocity
<span class="lineNum">    2102 </span>            :   Float_t vdrift=2.61301900000000000e+06;//fParam-&gt;GetDriftV();
<span class="lineNum">    2103 </span>            : //   cout&lt;&lt;&quot;vdrift=&quot;&lt;&lt;vdrift&lt;&lt;endl;
<span class="lineNum">    2104 </span>            : 
<span class="lineNum">    2105 </span><span class="lineNoCov">          0 :   AliDebug(5,Form(&quot;Timestamp %f - default drift velocity %f&quot;,timestamp,vdrift));</span>
<span class="lineNum">    2106 </span>            :   //loop over all entries in the histogram
<span class="lineNum">    2107 </span><span class="lineNoCov">          0 :   Int_t coord[5];</span>
<span class="lineNum">    2108 </span><span class="lineNoCov">          0 :   for(Long64_t ichunk=0;ichunk&lt;hProj-&gt;GetNbins();ichunk++){</span>
<span class="lineNum">    2109 </span>            :     //get entry position and content
<span class="lineNum">    2110 </span><span class="lineNoCov">          0 :     Double_t adc=hProj-&gt;GetBinContent(ichunk,coord);</span>
<span class="lineNum">    2111 </span>            : 
<span class="lineNum">    2112 </span>            : 
<span class="lineNum">    2113 </span><span class="lineNoCov">          0 :     Int_t sector = coord[0]-1;</span>
<span class="lineNum">    2114 </span><span class="lineNoCov">          0 :     Int_t row    = coord[1]-1;</span>
<span class="lineNum">    2115 </span><span class="lineNoCov">          0 :     Int_t pad    = coord[2]-1;</span>
<span class="lineNum">    2116 </span><span class="lineNoCov">          0 :     Int_t timeBin= coord[3]-1;</span>
<span class="lineNum">    2117 </span><span class="lineNoCov">          0 :     Double_t time   = fHnDrift-&gt;GetAxis(4)-&gt;GetBinCenter(coord[4]);</span>
<span class="lineNum">    2118 </span><span class="lineNoCov">          0 :     Int_t side   = (sector/18)%2;</span>
<span class="lineNum">    2119 </span>            : //     return;
<span class="lineNum">    2120 </span>            : //     fPeaks[4]=(UInt_t)posCE[sector/18];
<span class="lineNum">    2121 </span>            : //     fPeakWidths[4]=(UInt_t)widthCE[sector/18];
<span class="lineNum">    2122 </span>            : 
<span class="lineNum">    2123 </span>            :     //cuts
<span class="lineNum">    2124 </span><span class="lineNoCov">          0 :     if (time&lt;timestamp-120||time&gt;timestamp+120) continue; //window of +- 2min</span>
<span class="lineNum">    2125 </span><span class="lineNoCov">          0 :     if (adc &lt; 5 ) continue;</span>
<span class="lineNum">    2126 </span><span class="lineNoCov">          0 :     if (IsEdgePad(sector,row,pad)) continue;</span>
<span class="lineNum">    2127 </span>            : //     if (!IsPeakInRange(timeBin)) continue;
<span class="lineNum">    2128 </span>            : //     if (isCE&amp;&amp;((row%2)||(row%2)||(sector%2))) continue;
<span class="lineNum">    2129 </span>            : //     if (isCE&amp;&amp;(sector!=0)) continue;
<span class="lineNum">    2130 </span>            : 
<span class="lineNum">    2131 </span>            :     Int_t padmin=-2, padmax=2;
<span class="lineNum">    2132 </span>            :     Int_t timemin=-2, timemax=2;
<span class="lineNum">    2133 </span>            :     Int_t minsumperpad=2;
<span class="lineNum">    2134 </span>            :     //CE or laser tracks
<span class="lineNum">    2135 </span>            :     Bool_t isCE=kFALSE;
<span class="lineNum">    2136 </span><span class="lineNoCov">          0 :     if (TMath::Abs((Short_t)timeBin-(Short_t)posCE[sector/18])&lt;(Short_t)widthCE[sector/18]) {</span>
<span class="lineNum">    2137 </span>            :       isCE=kTRUE;
<span class="lineNum">    2138 </span>            :       padmin=0;
<span class="lineNum">    2139 </span>            :       padmax=0;
<span class="lineNum">    2140 </span>            :       timemin=-3;
<span class="lineNum">    2141 </span>            :       timemax=7;
<span class="lineNum">    2142 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2143 </span>            : 
<span class="lineNum">    2144 </span>            :     //
<span class="lineNum">    2145 </span>            :     // Find local maximum and cogs
<span class="lineNum">    2146 </span>            :     //
<span class="lineNum">    2147 </span>            :     Bool_t isMaximum=kTRUE;
<span class="lineNum">    2148 </span><span class="lineNoCov">          0 :     Float_t totalmass=0, tbcm=0, padcm=0, rmstb=0, rmspad=0;</span>
<span class="lineNum">    2149 </span><span class="lineNoCov">          0 :     Double_t cogY=0, rmsY=0;</span>
<span class="lineNum">    2150 </span><span class="lineNoCov">          0 :     Int_t npart=0;</span>
<span class="lineNum">    2151 </span>            : 
<span class="lineNum">    2152 </span>            :     // for position calculation use
<span class="lineNum">    2153 </span><span class="lineNoCov">          0 :     for(Int_t ipad=padmin;ipad&lt;=padmax;++ipad){</span>
<span class="lineNum">    2154 </span><span class="lineNoCov">          0 :       Float_t lxyz[3];</span>
<span class="lineNum">    2155 </span><span class="lineNoCov">          0 :       fROC-&gt;GetPositionLocal(sector,row,pad+ipad,lxyz);</span>
<span class="lineNum">    2156 </span>            : 
<span class="lineNum">    2157 </span><span class="lineNoCov">          0 :       for(Int_t itime=timemin;itime&lt;=timemax;++itime){</span>
<span class="lineNum">    2158 </span>            : 
<span class="lineNum">    2159 </span><span class="lineNoCov">          0 :         Int_t a[5]={coord[0],coord[1],coord[2]+ipad,coord[3]+itime,coord[4]};</span>
<span class="lineNum">    2160 </span><span class="lineNoCov">          0 :         Double_t val=hProj-&gt;GetBinContent(a);</span>
<span class="lineNum">    2161 </span><span class="lineNoCov">          0 :         totalmass+=val;</span>
<span class="lineNum">    2162 </span>            : 
<span class="lineNum">    2163 </span><span class="lineNoCov">          0 :         tbcm +=(timeBin+itime)*val;</span>
<span class="lineNum">    2164 </span><span class="lineNoCov">          0 :         padcm+=(pad+ipad)*val;</span>
<span class="lineNum">    2165 </span><span class="lineNoCov">          0 :         cogY +=lxyz[1]*val;</span>
<span class="lineNum">    2166 </span>            : 
<span class="lineNum">    2167 </span><span class="lineNoCov">          0 :         rmstb +=(timeBin+itime)*(timeBin+itime)*val;</span>
<span class="lineNum">    2168 </span><span class="lineNoCov">          0 :         rmspad+=(pad+ipad)*(pad+ipad)*val;</span>
<span class="lineNum">    2169 </span><span class="lineNoCov">          0 :         rmsY  +=lxyz[1]*lxyz[1]*val;</span>
<span class="lineNum">    2170 </span>            : 
<span class="lineNum">    2171 </span><span class="lineNoCov">          0 :         if (val&gt;0) ++npart;</span>
<span class="lineNum">    2172 </span><span class="lineNoCov">          0 :         if (val&gt;adc) {</span>
<span class="lineNum">    2173 </span>            :           isMaximum=kFALSE;
<span class="lineNum">    2174 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2175 </span>            :         }
<span class="lineNum">    2176 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    2177 </span><span class="lineNoCov">          0 :       if (!isMaximum)  break;</span>
<span class="lineNum">    2178 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2179 </span>            : 
<span class="lineNum">    2180 </span><span class="lineNoCov">          0 :     if (!isMaximum||!npart)  continue;</span>
<span class="lineNum">    2181 </span><span class="lineNoCov">          0 :     if (totalmass&lt;npart*minsumperpad) continue;</span>
<span class="lineNum">    2182 </span><span class="lineNoCov">          0 :     if (!isCE&amp;&amp;rmspad&lt;.1) continue; //most probably noise, since signal only in one pad,</span>
<span class="lineNum">    2183 </span>            :                                     //for CE we want only one pad by construction
<span class="lineNum">    2184 </span>            : 
<span class="lineNum">    2185 </span><span class="lineNoCov">          0 :     tbcm/=totalmass;</span>
<span class="lineNum">    2186 </span><span class="lineNoCov">          0 :     padcm/=totalmass;</span>
<span class="lineNum">    2187 </span><span class="lineNoCov">          0 :     cogY/=totalmass;</span>
<span class="lineNum">    2188 </span>            : 
<span class="lineNum">    2189 </span><span class="lineNoCov">          0 :     rmstb/=totalmass;</span>
<span class="lineNum">    2190 </span><span class="lineNoCov">          0 :     rmspad/=totalmass;</span>
<span class="lineNum">    2191 </span><span class="lineNoCov">          0 :     rmsY/=totalmass;</span>
<span class="lineNum">    2192 </span>            : 
<span class="lineNum">    2193 </span><span class="lineNoCov">          0 :     rmstb=TMath::Sqrt(TMath::Abs(tbcm*tbcm-rmstb));</span>
<span class="lineNum">    2194 </span><span class="lineNoCov">          0 :     rmspad=TMath::Sqrt(TMath::Abs(padcm*padcm-rmspad));</span>
<span class="lineNum">    2195 </span><span class="lineNoCov">          0 :     rmsY=TMath::Sqrt(TMath::Abs(cogY*cogY-rmsY));</span>
<span class="lineNum">    2196 </span>            : 
<span class="lineNum">    2197 </span><span class="lineNoCov">          0 :     Int_t cog=TMath::Nint(padcm);</span>
<span class="lineNum">    2198 </span>            : 
<span class="lineNum">    2199 </span>            :     // timebin --&gt; z position
<span class="lineNum">    2200 </span><span class="lineNoCov">          0 :     Float_t zlength=fParam-&gt;GetZLength(side);</span>
<span class="lineNum">    2201 </span>            : //     Float_t timePos=tbcm+(1000-fPeaks[4])
<span class="lineNum">    2202 </span>            :     // drift velocity is in m/s we would like to have cm/100ns, so 100cm/(10^7*100ns)
<span class="lineNum">    2203 </span><span class="lineNoCov">          0 :     Double_t gz=(zlength-(tbcm*vdrift*1.e-7))*TMath::Power(-1,side);</span>
<span class="lineNum">    2204 </span>            : 
<span class="lineNum">    2205 </span>            :     // local to global transformation--&gt; x and y positions
<span class="lineNum">    2206 </span><span class="lineNoCov">          0 :     Float_t padlxyz[3];</span>
<span class="lineNum">    2207 </span><span class="lineNoCov">          0 :     fROC-&gt;GetPositionLocal(sector,row,pad,padlxyz);</span>
<span class="lineNum">    2208 </span>            : 
<span class="lineNum">    2209 </span><span class="lineNoCov">          0 :     Double_t gxyz[3]={padlxyz[0],cogY,gz};</span>
<span class="lineNum">    2210 </span><span class="lineNoCov">          0 :     Double_t lxyz[3]={padlxyz[0],cogY,gz};</span>
<span class="lineNum">    2211 </span><span class="lineNoCov">          0 :     Double_t igxyz[3]={0,0,0};</span>
<span class="lineNum">    2212 </span><span class="lineNoCov">          0 :     AliTPCTransform t1;</span>
<span class="lineNum">    2213 </span><span class="lineNoCov">          0 :     t1.RotatedGlobal2Global(sector,gxyz);</span>
<span class="lineNum">    2214 </span>            : 
<span class="lineNum">    2215 </span><span class="lineNoCov">          0 :     Double_t mindist=0;</span>
<span class="lineNum">    2216 </span><span class="lineNoCov">          0 :     Int_t trackID=-1;</span>
<span class="lineNum">    2217 </span><span class="lineNoCov">          0 :     Int_t trackID2=-1;</span>
<span class="lineNum">    2218 </span>            : 
<span class="lineNum">    2219 </span>            :     //find track id and index of the position in the track (row)
<span class="lineNum">    2220 </span><span class="lineNoCov">          0 :     Int_t index=0;</span>
<span class="lineNum">    2221 </span><span class="lineNoCov">          0 :     if (!isCE){</span>
<span class="lineNum">    2222 </span><span class="lineNoCov">          0 :       index=row+(sector&gt;35)*fROC-&gt;GetNRows(0);</span>
<span class="lineNum">    2223 </span><span class="lineNoCov">          0 :       trackID=FindLaserTrackID(sector,index,gxyz,mindist,lxyz,trackID2);</span>
<span class="lineNum">    2224 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">    2225 </span><span class="lineNoCov">          0 :       trackID=336+((sector/18)%2);</span>
<span class="lineNum">    2226 </span><span class="lineNoCov">          0 :       index= fROC-&gt;GetRowIndexes(sector)[row]+pad; //  global pad position in sector</span>
<span class="lineNum">    2227 </span><span class="lineNoCov">          0 :       if (sector&lt;36) {</span>
<span class="lineNum">    2228 </span><span class="lineNoCov">          0 :         index+=(sector%18)*fROC-&gt;GetNChannels(sector);</span>
<span class="lineNum">    2229 </span><span class="lineNoCov">          0 :       } else {</span>
<span class="lineNum">    2230 </span><span class="lineNoCov">          0 :         index+=18*fROC-&gt;GetNChannels(0);</span>
<span class="lineNum">    2231 </span><span class="lineNoCov">          0 :         index+=(sector%18)*fROC-&gt;GetNChannels(sector);</span>
<span class="lineNum">    2232 </span>            :       }
<span class="lineNum">    2233 </span>            :       //TODO: find out about the multiple peaks in the CE
<span class="lineNum">    2234 </span>            : //       mindist=TMath::Abs(fPeaks[4]-tbcm);
<span class="lineNum">    2235 </span><span class="lineNoCov">          0 :       mindist=1.;</span>
<span class="lineNum">    2236 </span>            :     }
<span class="lineNum">    2237 </span>            : 
<span class="lineNum">    2238 </span>            :     // fill track vectors
<span class="lineNum">    2239 </span><span class="lineNoCov">          0 :     if (trackID&gt;0){</span>
<span class="lineNum">    2240 </span><span class="lineNoCov">          0 :       AliTPCLaserTrack *ltr=(AliTPCLaserTrack*)arrObj-&gt;UncheckedAt(trackID);</span>
<span class="lineNum">    2241 </span><span class="lineNoCov">          0 :       Double_t oldMinDist=ltr-&gt;fVecPhi-&gt;GetMatrixArray()[index];</span>
<span class="lineNum">    2242 </span>            : 
<span class="lineNum">    2243 </span>            : 
<span class="lineNum">    2244 </span>            : //      travel time effect of light includes
<span class="lineNum">    2245 </span>            : 
<span class="lineNum">    2246 </span><span class="lineNoCov">          0 :       Double_t raylength=ltr-&gt;GetRayLength();</span>
<span class="lineNum">    2247 </span><span class="lineNoCov">          0 :       Double_t globmir[3]={ltr-&gt;Xv(),ltr-&gt;Yv(),ltr-&gt;Zv()};</span>
<span class="lineNum">    2248 </span><span class="lineNoCov">          0 :       ltr-&gt;GetXYZ(globmir);</span>
<span class="lineNum">    2249 </span><span class="lineNoCov">          0 :       if(trackID&lt;336){</span>
<span class="lineNum">    2250 </span>            :         if(side==0){
<span class="lineNum">    2251 </span><span class="lineNoCov">          0 :           gxyz[2]=gxyz[2]-(TMath::Sqrt((gxyz[0]-globmir[0])*(gxyz[0]-globmir[0])</span>
<span class="lineNum">    2252 </span><span class="lineNoCov">          0 :                                        +(gxyz[1]-globmir[1])*(gxyz[1]-globmir[1])</span>
<span class="lineNum">    2253 </span><span class="lineNoCov">          0 :                                        +(gxyz[2]-globmir[2])*(gxyz[2]-globmir[2])+raylength))*vdrift*TMath::Power(10.,-6.)/30000;</span>
<span class="lineNum">    2254 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2255 </span>            :         else {
<span class="lineNum">    2256 </span>            :           gxyz[2]=gxyz[2]-(TMath::Sqrt((gxyz[0]-globmir[0])*(gxyz[0]-globmir[0])
<span class="lineNum">    2257 </span>            :                                        +(gxyz[1]-globmir[1])*(gxyz[1]-globmir[1])
<span class="lineNum">    2258 </span>            :                                        +(gxyz[2]-globmir[2])*(gxyz[2]-globmir[2])+raylength))*vdrift*TMath::Power(10.,-6.)/30000;
<span class="lineNum">    2259 </span>            :         }
<span class="lineNum">    2260 </span>            :       }
<span class="lineNum">    2261 </span>            : 
<span class="lineNum">    2262 </span><span class="lineNoCov">          0 :       if (TMath::Abs(oldMinDist)&lt;1.e-20||oldMinDist&gt;mindist){</span>
<span class="lineNum">    2263 </span><span class="lineNoCov">          0 :         ltr-&gt;fVecSec-&gt;GetMatrixArray()[index]=sector;</span>
<span class="lineNum">    2264 </span><span class="lineNoCov">          0 :         ltr-&gt;fVecP2-&gt;GetMatrixArray()[index]=0;</span>
<span class="lineNum">    2265 </span><span class="lineNoCov">          0 :         ltr-&gt;fVecPhi-&gt;GetMatrixArray()[index]=mindist;</span>
<span class="lineNum">    2266 </span><span class="lineNoCov">          0 :         ltr-&gt;fVecGX-&gt;GetMatrixArray()[index]=gxyz[0];</span>
<span class="lineNum">    2267 </span><span class="lineNoCov">          0 :         ltr-&gt;fVecGY-&gt;GetMatrixArray()[index]=gxyz[1];</span>
<span class="lineNum">    2268 </span><span class="lineNoCov">          0 :         ltr-&gt;fVecGZ-&gt;GetMatrixArray()[index]=gxyz[2];</span>
<span class="lineNum">    2269 </span><span class="lineNoCov">          0 :         ltr-&gt;fVecLX-&gt;GetMatrixArray()[index]=lxyz[0];</span>
<span class="lineNum">    2270 </span><span class="lineNoCov">          0 :         ltr-&gt;fVecLY-&gt;GetMatrixArray()[index]=lxyz[1];</span>
<span class="lineNum">    2271 </span><span class="lineNoCov">          0 :         ltr-&gt;fVecLZ-&gt;GetMatrixArray()[index]=lxyz[2];</span>
<span class="lineNum">    2272 </span>            : //         ltr-&gt;SetUniqueID((UInt_t)(mindist*10000)); //distance in um
<span class="lineNum">    2273 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    2274 </span><span class="lineNoCov">          0 :       TObjArray *arr=AliTPCLaserTrack::GetTracks();</span>
<span class="lineNum">    2275 </span><span class="lineNoCov">          0 :       ltr=(AliTPCLaserTrack*)arr-&gt;UncheckedAt(trackID);</span>
<span class="lineNum">    2276 </span><span class="lineNoCov">          0 :       igxyz[0]=ltr-&gt;fVecGX-&gt;GetMatrixArray()[row];</span>
<span class="lineNum">    2277 </span><span class="lineNoCov">          0 :       igxyz[1]=ltr-&gt;fVecGY-&gt;GetMatrixArray()[row];</span>
<span class="lineNum">    2278 </span><span class="lineNoCov">          0 :       igxyz[2]=ltr-&gt;fVecGZ-&gt;GetMatrixArray()[row];</span>
<span class="lineNum">    2279 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2280 </span>            : 
<span class="lineNum">    2281 </span>            : 
<span class="lineNum">    2282 </span><span class="lineNoCov">          0 :     if (fStreamLevel&gt;4){</span>
<span class="lineNum">    2283 </span><span class="lineNoCov">          0 :       (*GetDebugStreamer()) &lt;&lt; &quot;clusters&quot; &lt;&lt;</span>
<span class="lineNum">    2284 </span><span class="lineNoCov">          0 :         &quot;run=&quot;   &lt;&lt; fRunNumber &lt;&lt;</span>
<span class="lineNum">    2285 </span><span class="lineNoCov">          0 :         &quot;timestamp=&quot; &lt;&lt; timestamp &lt;&lt;</span>
<span class="lineNum">    2286 </span><span class="lineNoCov">          0 :         &quot;burst=&quot;     &lt;&lt; burst     &lt;&lt;</span>
<span class="lineNum">    2287 </span><span class="lineNoCov">          0 :         &quot;side=&quot;      &lt;&lt; side      &lt;&lt;</span>
<span class="lineNum">    2288 </span><span class="lineNoCov">          0 :         &quot;sec=&quot;       &lt;&lt; sector    &lt;&lt;</span>
<span class="lineNum">    2289 </span><span class="lineNoCov">          0 :         &quot;row=&quot;       &lt;&lt; row       &lt;&lt;</span>
<span class="lineNum">    2290 </span><span class="lineNoCov">          0 :         &quot;pad=&quot;       &lt;&lt; pad       &lt;&lt;</span>
<span class="lineNum">    2291 </span><span class="lineNoCov">          0 :         &quot;padCog=&quot;    &lt;&lt; cog       &lt;&lt;</span>
<span class="lineNum">    2292 </span><span class="lineNoCov">          0 :         &quot;timebin=&quot;   &lt;&lt; timeBin   &lt;&lt;</span>
<span class="lineNum">    2293 </span><span class="lineNoCov">          0 :         &quot;cogCE=&quot;     &lt;&lt; posCE[sector/18] &lt;&lt;</span>
<span class="lineNum">    2294 </span><span class="lineNoCov">          0 :         &quot;withCE=&quot;    &lt;&lt; widthCE[sector/18] &lt;&lt;</span>
<span class="lineNum">    2295 </span><span class="lineNoCov">          0 :         &quot;index=&quot;     &lt;&lt; index     &lt;&lt;</span>
<span class="lineNum">    2296 </span>            : 
<span class="lineNum">    2297 </span><span class="lineNoCov">          0 :         &quot;padcm=&quot;     &lt;&lt; padcm     &lt;&lt;</span>
<span class="lineNum">    2298 </span><span class="lineNoCov">          0 :         &quot;rmspad=&quot;    &lt;&lt; rmspad    &lt;&lt;</span>
<span class="lineNum">    2299 </span>            : 
<span class="lineNum">    2300 </span><span class="lineNoCov">          0 :         &quot;cogtb=&quot;     &lt;&lt; tbcm      &lt;&lt;</span>
<span class="lineNum">    2301 </span><span class="lineNoCov">          0 :         &quot;rmstb=&quot;     &lt;&lt; rmstb     &lt;&lt;</span>
<span class="lineNum">    2302 </span>            : 
<span class="lineNum">    2303 </span><span class="lineNoCov">          0 :         &quot;npad=&quot;      &lt;&lt; npart     &lt;&lt;</span>
<span class="lineNum">    2304 </span>            : 
<span class="lineNum">    2305 </span><span class="lineNoCov">          0 :         &quot;lx=&quot;        &lt;&lt; padlxyz[0]&lt;&lt;</span>
<span class="lineNum">    2306 </span><span class="lineNoCov">          0 :         &quot;ly=&quot;        &lt;&lt; cogY      &lt;&lt;</span>
<span class="lineNum">    2307 </span><span class="lineNoCov">          0 :         &quot;lypad=&quot;     &lt;&lt; padlxyz[1]&lt;&lt;</span>
<span class="lineNum">    2308 </span><span class="lineNoCov">          0 :         &quot;rmsY=&quot;      &lt;&lt; rmsY      &lt;&lt;</span>
<span class="lineNum">    2309 </span>            : 
<span class="lineNum">    2310 </span><span class="lineNoCov">          0 :         &quot;gx=&quot;        &lt;&lt; gxyz[0]   &lt;&lt;</span>
<span class="lineNum">    2311 </span><span class="lineNoCov">          0 :         &quot;gy=&quot;        &lt;&lt; gxyz[1]   &lt;&lt;</span>
<span class="lineNum">    2312 </span><span class="lineNoCov">          0 :         &quot;gz=&quot;        &lt;&lt; gxyz[2]   &lt;&lt;</span>
<span class="lineNum">    2313 </span>            : 
<span class="lineNum">    2314 </span><span class="lineNoCov">          0 :         &quot;igx=&quot;        &lt;&lt; igxyz[0] &lt;&lt;</span>
<span class="lineNum">    2315 </span><span class="lineNoCov">          0 :         &quot;igy=&quot;        &lt;&lt; igxyz[1] &lt;&lt;</span>
<span class="lineNum">    2316 </span><span class="lineNoCov">          0 :         &quot;igz=&quot;        &lt;&lt; igxyz[2] &lt;&lt;</span>
<span class="lineNum">    2317 </span>            : 
<span class="lineNum">    2318 </span><span class="lineNoCov">          0 :         &quot;mind=&quot;      &lt;&lt; mindist   &lt;&lt;</span>
<span class="lineNum">    2319 </span><span class="lineNoCov">          0 :         &quot;max=&quot;       &lt;&lt; adc       &lt;&lt;</span>
<span class="lineNum">    2320 </span><span class="lineNoCov">          0 :         &quot;trackid=&quot;   &lt;&lt; trackID   &lt;&lt;</span>
<span class="lineNum">    2321 </span><span class="lineNoCov">          0 :         &quot;trackid2=&quot;   &lt;&lt; trackID2   &lt;&lt;</span>
<span class="lineNum">    2322 </span><span class="lineNoCov">          0 :         &quot;npart=&quot;     &lt;&lt; npart     &lt;&lt;</span>
<span class="lineNum">    2323 </span>            :         &quot;\n&quot;;
<span class="lineNum">    2324 </span>            :     } // end stream levelmgz.fElements
<span class="lineNum">    2325 </span>            : 
<span class="lineNum">    2326 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2327 </span>            : 
<span class="lineNum">    2328 </span><span class="lineNoCov">          0 : }</span>
<a name="2329"><span class="lineNum">    2329 </span>            : </a>
<span class="lineNum">    2330 </span>            : //_____________________________________________________________________
<span class="lineNum">    2331 </span>            : void AliTPCCalibCE::AnalyseTrack()
<span class="lineNum">    2332 </span>            : {
<span class="lineNum">    2333 </span>            :   ///  Analyse the tracks
<span class="lineNum">    2334 </span>            : 
<span class="lineNum">    2335 </span>            : 
<span class="lineNum">    2336 </span><span class="lineNoCov">          0 :   AliTPCLaserTrack::LoadTracks();</span>
<span class="lineNum">    2337 </span>            : //   AliTPCParam *param=0x0;
<span class="lineNum">    2338 </span>            : //   //cdb run number
<span class="lineNum">    2339 </span>            : //   AliCDBManager *man=AliCDBManager::Instance();
<span class="lineNum">    2340 </span>            : //   if (man-&gt;GetDefaultStorage()){
<span class="lineNum">    2341 </span>            : //     AliCDBEntry *entry=man-&gt;Get(&quot;TPC/Calib/Parameters&quot;,fRunNumber);
<span class="lineNum">    2342 </span>            : //     if (entry){
<span class="lineNum">    2343 </span>            : //       entry-&gt;SetOwner(kTRUE);
<span class="lineNum">    2344 </span>            : //       param = (AliTPCParam*)(entry-&gt;GetObject()-&gt;Clone());
<span class="lineNum">    2345 </span>            : //     }
<span class="lineNum">    2346 </span>            : //   }
<span class="lineNum">    2347 </span>            : //   if (param){
<span class="lineNum">    2348 </span>            : //     if (fParam) delete fParam;
<span class="lineNum">    2349 </span>            : //     fParam=param;
<span class="lineNum">    2350 </span>            : //   } else {
<span class="lineNum">    2351 </span>            : //     AliError(&quot;Could not get updated AliTPCParam from OCDB!!!&quot;);
<span class="lineNum">    2352 </span>            : //   }
<span class="lineNum">    2353 </span>            : 
<span class="lineNum">    2354 </span>            :   //Measured and ideal laser tracks
<span class="lineNum">    2355 </span><span class="lineNoCov">          0 :   TObjArray* arrMeasured = SetupMeasured();</span>
<span class="lineNum">    2356 </span><span class="lineNoCov">          0 :   TObjArray* arrIdeal    = AliTPCLaserTrack::GetTracks();</span>
<span class="lineNum">    2357 </span><span class="lineNoCov">          0 :   AddCEtoIdeal(arrIdeal);</span>
<span class="lineNum">    2358 </span>            : 
<span class="lineNum">    2359 </span>            :   //find bursts and loop over them
<span class="lineNum">    2360 </span><span class="lineNoCov">          0 :   for (Int_t iburst=0; iburst&lt;fArrHnDrift.GetEntries();++iburst){</span>
<span class="lineNum">    2361 </span><span class="lineNoCov">          0 :     Double_t timestamp=fTimeBursts[iburst];</span>
<span class="lineNum">    2362 </span><span class="lineNoCov">          0 :     AliDebug(5,Form(&quot;Burst: %d (%f)&quot;,iburst,timestamp));</span>
<span class="lineNum">    2363 </span><span class="lineNoCov">          0 :     fHnDrift=(THnSparseI*)fArrHnDrift.UncheckedAt(iburst);</span>
<span class="lineNum">    2364 </span><span class="lineNoCov">          0 :     if (!fHnDrift) continue;</span>
<span class="lineNum">    2365 </span><span class="lineNoCov">          0 :     UInt_t entries=(UInt_t)fHnDrift-&gt;GetEntries();</span>
<span class="lineNum">    2366 </span><span class="lineNoCov">          0 :     if (fBinsLastAna[iburst]&gt;=entries) continue; //already analysed!!!</span>
<span class="lineNum">    2367 </span><span class="lineNoCov">          0 :     fBinsLastAna[iburst]=entries;</span>
<span class="lineNum">    2368 </span>            : 
<span class="lineNum">    2369 </span><span class="lineNoCov">          0 :     for (Int_t iDim=0; iDim&lt;fHnDrift-&gt;GetNdimensions(); ++iDim) fHnDrift-&gt;GetAxis(iDim)-&gt;SetRange(0,0);</span>
<span class="lineNum">    2370 </span>            : //     if (iburst==0) FindLaserLayers();
<span class="lineNum">    2371 </span>            : 
<span class="lineNum">    2372 </span>            :     //reset laser tracks
<span class="lineNum">    2373 </span><span class="lineNoCov">          0 :     ResetMeasured(arrMeasured);</span>
<span class="lineNum">    2374 </span>            : 
<span class="lineNum">    2375 </span>            :     //find clusters and associate to the tracks
<span class="lineNum">    2376 </span><span class="lineNoCov">          0 :     FindLocalMaxima(arrMeasured, timestamp, iburst);</span>
<span class="lineNum">    2377 </span>            : 
<span class="lineNum">    2378 </span>            :     //calculate drift velocity
<span class="lineNum">    2379 </span><span class="lineNoCov">          0 :     CalculateDV(arrIdeal,arrMeasured,iburst);</span>
<span class="lineNum">    2380 </span>            : 
<span class="lineNum">    2381 </span>            :     //Dump information to file if requested
<span class="lineNum">    2382 </span><span class="lineNoCov">          0 :     if (fStreamLevel&gt;2){</span>
<span class="lineNum">    2383 </span>            :       //printf(&quot;make tree\n&quot;);
<span class="lineNum">    2384 </span>            :       //laser track information
<span class="lineNum">    2385 </span>            : 
<span class="lineNum">    2386 </span><span class="lineNoCov">          0 :       for (Int_t itrack=0; itrack&lt;338; ++itrack){</span>
<span class="lineNum">    2387 </span><span class="lineNoCov">          0 :         TObject *iltr=arrIdeal-&gt;UncheckedAt(itrack);</span>
<span class="lineNum">    2388 </span><span class="lineNoCov">          0 :         TObject *mltr=arrMeasured-&gt;UncheckedAt(itrack);</span>
<span class="lineNum">    2389 </span><span class="lineNoCov">          0 :         (*GetDebugStreamer()) &lt;&lt; &quot;tracks&quot; &lt;&lt;</span>
<span class="lineNum">    2390 </span><span class="lineNoCov">          0 :           &quot;run=&quot;   &lt;&lt; fRunNumber &lt;&lt;</span>
<span class="lineNum">    2391 </span><span class="lineNoCov">          0 :           &quot;time=&quot; &lt;&lt; timestamp &lt;&lt;</span>
<span class="lineNum">    2392 </span><span class="lineNoCov">          0 :           &quot;burst=&quot;&lt;&lt; iburst &lt;&lt;</span>
<span class="lineNum">    2393 </span><span class="lineNoCov">          0 :           &quot;iltr.=&quot; &lt;&lt; iltr &lt;&lt;</span>
<span class="lineNum">    2394 </span><span class="lineNoCov">          0 :           &quot;mltr.=&quot; &lt;&lt; mltr &lt;&lt;</span>
<span class="lineNum">    2395 </span>            :           &quot;\n&quot;;
<span class="lineNum">    2396 </span>            :       }
<span class="lineNum">    2397 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2398 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2399 </span><span class="lineNoCov">          0 :   if (fStreamLevel&gt;0) GetDebugStreamer()-&gt;GetFile()-&gt;Write();</span>
<span class="lineNum">    2400 </span><span class="lineNoCov">          0 : }</span>
<a name="2401"><span class="lineNum">    2401 </span>            : </a>
<span class="lineNum">    2402 </span>            : //_____________________________________________________________________
<span class="lineNum">    2403 </span>            : Int_t AliTPCCalibCE::FindLaserTrackID(Int_t sector,Int_t row, const Double_t *peakpos,Double_t &amp;mindist,
<span class="lineNum">    2404 </span>            :                                       const Double_t *peakposloc, Int_t &amp;itrackMin2)
<span class="lineNum">    2405 </span>            : {
<span class="lineNum">    2406 </span>            :   ///  Find the tracks, which are closest to the ideal tracks, from clusters closest to the ideal tracks
<span class="lineNum">    2407 </span>            : 
<span class="lineNum">    2408 </span>            : 
<span class="lineNum">    2409 </span><span class="lineNoCov">          0 :   TObjArray *arr=AliTPCLaserTrack::GetTracks();</span>
<span class="lineNum">    2410 </span><span class="lineNoCov">          0 :   TVector3 vP(peakpos[0],peakpos[1],peakpos[2]);</span>
<span class="lineNum">    2411 </span><span class="lineNoCov">          0 :   TVector3 vDir;</span>
<span class="lineNum">    2412 </span><span class="lineNoCov">          0 :   TVector3 vSt;</span>
<span class="lineNum">    2413 </span>            : 
<span class="lineNum">    2414 </span>            :   Int_t firstbeam=0;
<span class="lineNum">    2415 </span>            :   Int_t lastbeam=336/2;
<span class="lineNum">    2416 </span><span class="lineNoCov">          0 :   if ( (sector/18)%2 ) {</span>
<span class="lineNum">    2417 </span>            :     firstbeam=336/2;
<span class="lineNum">    2418 </span>            :     lastbeam=336;
<span class="lineNum">    2419 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2420 </span>            : 
<span class="lineNum">    2421 </span><span class="lineNoCov">          0 :   mindist=1000000;</span>
<span class="lineNum">    2422 </span>            :   Int_t itrackMin=-1;
<span class="lineNum">    2423 </span><span class="lineNoCov">          0 :   for (Int_t itrack=firstbeam; itrack&lt;lastbeam; ++itrack){</span>
<span class="lineNum">    2424 </span><span class="lineNoCov">          0 :     AliTPCLaserTrack *ltr=(AliTPCLaserTrack*)arr-&gt;At(itrack);  //get the track</span>
<span class="lineNum">    2425 </span>            : //     if (ltr-&gt;GetVecSec()-&gt;GetMatrixArray()[row]!=sector) continue;
<span class="lineNum">    2426 </span><span class="lineNoCov">          0 :     vSt.SetXYZ(ltr-&gt;GetX(),ltr-&gt;GetY(),ltr-&gt;GetZ());</span>
<span class="lineNum">    2427 </span><span class="lineNoCov">          0 :     Double_t deltaZ=ltr-&gt;GetZ()-peakpos[2];</span>
<span class="lineNum">    2428 </span><span class="lineNoCov">          0 :     if (TMath::Abs(deltaZ)&gt;40) continue;</span>
<span class="lineNum">    2429 </span><span class="lineNoCov">          0 :     vDir.SetMagThetaPhi(1,ltr-&gt;Theta(),TMath::ASin(ltr-&gt;GetSnp()));</span>
<span class="lineNum">    2430 </span><span class="lineNoCov">          0 :     vSt.RotateZ(ltr-&gt;GetAlpha());</span>
<span class="lineNum">    2431 </span><span class="lineNoCov">          0 :     vDir.RotateZ(ltr-&gt;GetAlpha());</span>
<span class="lineNum">    2432 </span>            : 
<span class="lineNum">    2433 </span><span class="lineNoCov">          0 :     Double_t dist=(vDir.Cross(vSt-vP)).Mag()/vDir.Mag();</span>
<span class="lineNum">    2434 </span>            : 
<span class="lineNum">    2435 </span><span class="lineNoCov">          0 :     if (dist&lt;mindist){</span>
<span class="lineNum">    2436 </span><span class="lineNoCov">          0 :       mindist=dist;</span>
<span class="lineNum">    2437 </span>            :       itrackMin=itrack;
<span class="lineNum">    2438 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2439 </span>            : 
<span class="lineNum">    2440 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2441 </span><span class="lineNoCov">          0 :   itrackMin2=-1;</span>
<span class="lineNum">    2442 </span>            :   Float_t mindist2=10;
<span class="lineNum">    2443 </span><span class="lineNoCov">          0 :   for (Int_t itrack=firstbeam; itrack&lt;lastbeam; ++itrack){</span>
<span class="lineNum">    2444 </span><span class="lineNoCov">          0 :     AliTPCLaserTrack *ltr=(AliTPCLaserTrack*)arr-&gt;At(itrack);  //get the track</span>
<span class="lineNum">    2445 </span><span class="lineNoCov">          0 :     if ((ltr-&gt;fVecSec-&gt;GetMatrixArray())[row]!=sector) continue;</span>
<span class="lineNum">    2446 </span>            : 
<span class="lineNum">    2447 </span><span class="lineNoCov">          0 :     Double_t deltaZ=ltr-&gt;GetZ()-peakpos[2];</span>
<span class="lineNum">    2448 </span><span class="lineNoCov">          0 :     if (TMath::Abs(deltaZ)&gt;40) continue;</span>
<span class="lineNum">    2449 </span>            : 
<span class="lineNum">    2450 </span><span class="lineNoCov">          0 :     Double_t dist=TMath::Abs((ltr-&gt;fVecLY-&gt;GetMatrixArray())[row]-peakposloc[1]);</span>
<span class="lineNum">    2451 </span><span class="lineNoCov">          0 :     if (dist&gt;1) continue;</span>
<span class="lineNum">    2452 </span>            : 
<span class="lineNum">    2453 </span><span class="lineNoCov">          0 :     if (dist&lt;mindist2){</span>
<span class="lineNum">    2454 </span><span class="lineNoCov">          0 :       mindist2=dist;</span>
<span class="lineNum">    2455 </span><span class="lineNoCov">          0 :       itrackMin2=itrack;</span>
<span class="lineNum">    2456 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2457 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2458 </span><span class="lineNoCov">          0 :   mindist=mindist2;</span>
<span class="lineNum">    2459 </span><span class="lineNoCov">          0 :   return itrackMin2;</span>
<span class="lineNum">    2460 </span>            : 
<span class="lineNum">    2461 </span><span class="lineNoCov">          0 : }</span>
<a name="2462"><span class="lineNum">    2462 </span>            : </a>
<span class="lineNum">    2463 </span>            : //_____________________________________________________________________
<span class="lineNum">    2464 </span>            : Bool_t AliTPCCalibCE::IsEdgePad(Int_t sector, Int_t row, Int_t pad) const
<span class="lineNum">    2465 </span>            : {
<span class="lineNum">    2466 </span>            :   /// return true if pad is on the edge of a row
<span class="lineNum">    2467 </span>            : 
<span class="lineNum">    2468 </span>            :   Int_t edge1   = 0;
<span class="lineNum">    2469 </span><span class="lineNoCov">          0 :   if ( pad == edge1 ) return kTRUE;</span>
<span class="lineNum">    2470 </span><span class="lineNoCov">          0 :   Int_t edge2   = fROC-&gt;GetNPads(sector,row)-1;</span>
<span class="lineNum">    2471 </span><span class="lineNoCov">          0 :   if ( pad == edge2 ) return kTRUE;</span>
<span class="lineNum">    2472 </span>            : 
<span class="lineNum">    2473 </span><span class="lineNoCov">          0 :   return kFALSE;</span>
<span class="lineNum">    2474 </span><span class="lineNoCov">          0 : }</span>
<a name="2475"><span class="lineNum">    2475 </span>            : </a>
<span class="lineNum">    2476 </span>            : //_____________________________________________________________________
<span class="lineNum">    2477 </span>            : TObjArray* AliTPCCalibCE::SetupMeasured()
<span class="lineNum">    2478 </span>            : {
<span class="lineNum">    2479 </span>            :   /// setup array of measured laser tracks and CE
<span class="lineNum">    2480 </span>            : 
<span class="lineNum">    2481 </span><span class="lineNoCov">          0 :   TObjArray *arrIdeal    = AliTPCLaserTrack::GetTracks();</span>
<span class="lineNum">    2482 </span><span class="lineNoCov">          0 :   TObjArray *arrMeasured = new TObjArray(338);</span>
<span class="lineNum">    2483 </span><span class="lineNoCov">          0 :   arrMeasured-&gt;SetOwner();</span>
<span class="lineNum">    2484 </span><span class="lineNoCov">          0 :   for(Int_t itrack=0;itrack&lt;336;itrack++){</span>
<span class="lineNum">    2485 </span><span class="lineNoCov">          0 :     arrMeasured-&gt;AddAt(new AliTPCLaserTrack(*((AliTPCLaserTrack*)arrIdeal-&gt;At(itrack))),itrack);</span>
<span class="lineNum">    2486 </span>            :   }
<span class="lineNum">    2487 </span>            : 
<span class="lineNum">    2488 </span>            :   //&quot;tracks&quot; for CE
<span class="lineNum">    2489 </span><span class="lineNoCov">          0 :   AliTPCLaserTrack *ltrce=new AliTPCLaserTrack;</span>
<span class="lineNum">    2490 </span><span class="lineNoCov">          0 :   ltrce-&gt;SetId(336);</span>
<span class="lineNum">    2491 </span><span class="lineNoCov">          0 :   ltrce-&gt;SetSide(0);</span>
<span class="lineNum">    2492 </span><span class="lineNoCov">          0 :   ltrce-&gt;fVecSec=new TVectorD(557568/2);</span>
<span class="lineNum">    2493 </span><span class="lineNoCov">          0 :   ltrce-&gt;fVecP2=new TVectorD(557568/2);</span>
<span class="lineNum">    2494 </span><span class="lineNoCov">          0 :   ltrce-&gt;fVecPhi=new TVectorD(557568/2);</span>
<span class="lineNum">    2495 </span><span class="lineNoCov">          0 :   ltrce-&gt;fVecGX=new TVectorD(557568/2);</span>
<span class="lineNum">    2496 </span><span class="lineNoCov">          0 :   ltrce-&gt;fVecGY=new TVectorD(557568/2);</span>
<span class="lineNum">    2497 </span><span class="lineNoCov">          0 :   ltrce-&gt;fVecGZ=new TVectorD(557568/2);</span>
<span class="lineNum">    2498 </span><span class="lineNoCov">          0 :   ltrce-&gt;fVecLX=new TVectorD(557568/2);</span>
<span class="lineNum">    2499 </span><span class="lineNoCov">          0 :   ltrce-&gt;fVecLY=new TVectorD(557568/2);</span>
<span class="lineNum">    2500 </span><span class="lineNoCov">          0 :   ltrce-&gt;fVecLZ=new TVectorD(557568/2);</span>
<span class="lineNum">    2501 </span>            : 
<span class="lineNum">    2502 </span><span class="lineNoCov">          0 :   arrMeasured-&gt;AddAt(ltrce,336); //CE A-Side</span>
<span class="lineNum">    2503 </span>            : 
<span class="lineNum">    2504 </span><span class="lineNoCov">          0 :   ltrce=new AliTPCLaserTrack;</span>
<span class="lineNum">    2505 </span><span class="lineNoCov">          0 :   ltrce-&gt;SetId(337);</span>
<span class="lineNum">    2506 </span><span class="lineNoCov">          0 :   ltrce-&gt;SetSide(1);</span>
<span class="lineNum">    2507 </span><span class="lineNoCov">          0 :   ltrce-&gt;fVecSec=new TVectorD(557568/2);</span>
<span class="lineNum">    2508 </span><span class="lineNoCov">          0 :   ltrce-&gt;fVecP2=new TVectorD(557568/2);</span>
<span class="lineNum">    2509 </span><span class="lineNoCov">          0 :   ltrce-&gt;fVecPhi=new TVectorD(557568/2);</span>
<span class="lineNum">    2510 </span><span class="lineNoCov">          0 :   ltrce-&gt;fVecGX=new TVectorD(557568/2);</span>
<span class="lineNum">    2511 </span><span class="lineNoCov">          0 :   ltrce-&gt;fVecGY=new TVectorD(557568/2);</span>
<span class="lineNum">    2512 </span><span class="lineNoCov">          0 :   ltrce-&gt;fVecGZ=new TVectorD(557568/2);</span>
<span class="lineNum">    2513 </span><span class="lineNoCov">          0 :   ltrce-&gt;fVecLX=new TVectorD(557568/2);</span>
<span class="lineNum">    2514 </span><span class="lineNoCov">          0 :   ltrce-&gt;fVecLY=new TVectorD(557568/2);</span>
<span class="lineNum">    2515 </span><span class="lineNoCov">          0 :   ltrce-&gt;fVecLZ=new TVectorD(557568/2);</span>
<span class="lineNum">    2516 </span><span class="lineNoCov">          0 :   arrMeasured-&gt;AddAt(ltrce,337); //CE C-Side</span>
<span class="lineNum">    2517 </span>            : 
<span class="lineNum">    2518 </span><span class="lineNoCov">          0 :   return arrMeasured;</span>
<span class="lineNum">    2519 </span><span class="lineNoCov">          0 : }</span>
<a name="2520"><span class="lineNum">    2520 </span>            : </a>
<span class="lineNum">    2521 </span>            : //_____________________________________________________________________
<span class="lineNum">    2522 </span>            : void AliTPCCalibCE::ResetMeasured(TObjArray * const arr)
<span class="lineNum">    2523 </span>            : {
<span class="lineNum">    2524 </span>            :   /// reset array of measured laser tracks and CE
<span class="lineNum">    2525 </span>            : 
<span class="lineNum">    2526 </span><span class="lineNoCov">          0 :   for(Int_t itrack=0;itrack&lt;338;itrack++){</span>
<span class="lineNum">    2527 </span><span class="lineNoCov">          0 :     AliTPCLaserTrack *ltr=(AliTPCLaserTrack*)arr-&gt;UncheckedAt(itrack);</span>
<span class="lineNum">    2528 </span><span class="lineNoCov">          0 :     ltr-&gt;fVecSec-&gt;Zero();</span>
<span class="lineNum">    2529 </span><span class="lineNoCov">          0 :     ltr-&gt;fVecP2-&gt;Zero();</span>
<span class="lineNum">    2530 </span><span class="lineNoCov">          0 :     ltr-&gt;fVecPhi-&gt;Zero();</span>
<span class="lineNum">    2531 </span><span class="lineNoCov">          0 :     ltr-&gt;fVecGX-&gt;Zero();</span>
<span class="lineNum">    2532 </span><span class="lineNoCov">          0 :     ltr-&gt;fVecGY-&gt;Zero();</span>
<span class="lineNum">    2533 </span><span class="lineNoCov">          0 :     ltr-&gt;fVecGZ-&gt;Zero();</span>
<span class="lineNum">    2534 </span><span class="lineNoCov">          0 :     ltr-&gt;fVecLX-&gt;Zero();</span>
<span class="lineNum">    2535 </span><span class="lineNoCov">          0 :     ltr-&gt;fVecLY-&gt;Zero();</span>
<span class="lineNum">    2536 </span><span class="lineNoCov">          0 :     ltr-&gt;fVecLZ-&gt;Zero();</span>
<span class="lineNum">    2537 </span>            :   }
<span class="lineNum">    2538 </span><span class="lineNoCov">          0 : }</span>
<a name="2539"><span class="lineNum">    2539 </span>            : </a>
<span class="lineNum">    2540 </span>            : //_____________________________________________________________________
<span class="lineNum">    2541 </span>            : void AliTPCCalibCE::AddCEtoIdeal(TObjArray *arr)
<span class="lineNum">    2542 </span>            : {
<span class="lineNum">    2543 </span>            :   /// Add ideal CE positions to the ideal track data
<span class="lineNum">    2544 </span>            : 
<span class="lineNum">    2545 </span><span class="lineNoCov">          0 :   arr-&gt;Expand(338);</span>
<span class="lineNum">    2546 </span>            :   //&quot;tracks&quot; for CE
<span class="lineNum">    2547 </span><span class="lineNoCov">          0 :   AliTPCLaserTrack *ltrceA=new AliTPCLaserTrack;</span>
<span class="lineNum">    2548 </span><span class="lineNoCov">          0 :   ltrceA-&gt;SetId(336);</span>
<span class="lineNum">    2549 </span><span class="lineNoCov">          0 :   ltrceA-&gt;SetSide(0);</span>
<span class="lineNum">    2550 </span><span class="lineNoCov">          0 :   ltrceA-&gt;fVecSec=new TVectorD(557568/2);</span>
<span class="lineNum">    2551 </span><span class="lineNoCov">          0 :   ltrceA-&gt;fVecP2=new TVectorD(557568/2);</span>
<span class="lineNum">    2552 </span><span class="lineNoCov">          0 :   ltrceA-&gt;fVecPhi=new TVectorD(557568/2);</span>
<span class="lineNum">    2553 </span><span class="lineNoCov">          0 :   ltrceA-&gt;fVecGX=new TVectorD(557568/2);</span>
<span class="lineNum">    2554 </span><span class="lineNoCov">          0 :   ltrceA-&gt;fVecGY=new TVectorD(557568/2);</span>
<span class="lineNum">    2555 </span><span class="lineNoCov">          0 :   ltrceA-&gt;fVecGZ=new TVectorD(557568/2);</span>
<span class="lineNum">    2556 </span><span class="lineNoCov">          0 :   ltrceA-&gt;fVecLX=new TVectorD(557568/2);</span>
<span class="lineNum">    2557 </span><span class="lineNoCov">          0 :   ltrceA-&gt;fVecLY=new TVectorD(557568/2);</span>
<span class="lineNum">    2558 </span><span class="lineNoCov">          0 :   ltrceA-&gt;fVecLZ=new TVectorD(557568/2);</span>
<span class="lineNum">    2559 </span><span class="lineNoCov">          0 :   arr-&gt;AddAt(ltrceA,336); //CE A-Side</span>
<span class="lineNum">    2560 </span>            : 
<span class="lineNum">    2561 </span><span class="lineNoCov">          0 :   AliTPCLaserTrack *ltrceC=new AliTPCLaserTrack;</span>
<span class="lineNum">    2562 </span><span class="lineNoCov">          0 :   ltrceC-&gt;SetId(337);</span>
<span class="lineNum">    2563 </span><span class="lineNoCov">          0 :   ltrceC-&gt;SetSide(1);</span>
<span class="lineNum">    2564 </span><span class="lineNoCov">          0 :   ltrceC-&gt;fVecSec=new TVectorD(557568/2);</span>
<span class="lineNum">    2565 </span><span class="lineNoCov">          0 :   ltrceC-&gt;fVecP2=new TVectorD(557568/2);</span>
<span class="lineNum">    2566 </span><span class="lineNoCov">          0 :   ltrceC-&gt;fVecPhi=new TVectorD(557568/2);</span>
<span class="lineNum">    2567 </span><span class="lineNoCov">          0 :   ltrceC-&gt;fVecGX=new TVectorD(557568/2);</span>
<span class="lineNum">    2568 </span><span class="lineNoCov">          0 :   ltrceC-&gt;fVecGY=new TVectorD(557568/2);</span>
<span class="lineNum">    2569 </span><span class="lineNoCov">          0 :   ltrceC-&gt;fVecGZ=new TVectorD(557568/2);</span>
<span class="lineNum">    2570 </span><span class="lineNoCov">          0 :   ltrceC-&gt;fVecLX=new TVectorD(557568/2);</span>
<span class="lineNum">    2571 </span><span class="lineNoCov">          0 :   ltrceC-&gt;fVecLY=new TVectorD(557568/2);</span>
<span class="lineNum">    2572 </span><span class="lineNoCov">          0 :   ltrceC-&gt;fVecLZ=new TVectorD(557568/2);</span>
<span class="lineNum">    2573 </span><span class="lineNoCov">          0 :   arr-&gt;AddAt(ltrceC,337); //CE C-Side</span>
<span class="lineNum">    2574 </span>            : 
<span class="lineNum">    2575 </span>            :   //Calculate ideal positoins
<span class="lineNum">    2576 </span><span class="lineNoCov">          0 :   Float_t gxyz[3];</span>
<span class="lineNum">    2577 </span><span class="lineNoCov">          0 :   Float_t lxyz[3];</span>
<span class="lineNum">    2578 </span>            :   Int_t channelSideA=0;
<span class="lineNum">    2579 </span>            :   Int_t channelSideC=0;
<span class="lineNum">    2580 </span>            :   Int_t channelSide=0;
<span class="lineNum">    2581 </span>            :   AliTPCLaserTrack *ltrce=0x0;
<span class="lineNum">    2582 </span>            : 
<span class="lineNum">    2583 </span><span class="lineNoCov">          0 :   for (Int_t isector=0; isector&lt;72; ++isector){</span>
<span class="lineNum">    2584 </span><span class="lineNoCov">          0 :     Int_t side=((isector/18)%2);</span>
<span class="lineNum">    2585 </span><span class="lineNoCov">          0 :     for (UInt_t irow=0;irow&lt;fROC-&gt;GetNRows(isector);++irow){</span>
<span class="lineNum">    2586 </span><span class="lineNoCov">          0 :       for (UInt_t ipad=0;ipad&lt;fROC-&gt;GetNPads(isector,irow);++ipad){</span>
<span class="lineNum">    2587 </span><span class="lineNoCov">          0 :         fROC-&gt;GetPositionGlobal(isector,irow,ipad,gxyz);</span>
<span class="lineNum">    2588 </span><span class="lineNoCov">          0 :         fROC-&gt;GetPositionLocal(isector,irow,ipad,lxyz);</span>
<span class="lineNum">    2589 </span><span class="lineNoCov">          0 :         if (side==0) {</span>
<span class="lineNum">    2590 </span>            :           ltrce=ltrceA;
<span class="lineNum">    2591 </span>            :           channelSide=channelSideA;
<span class="lineNum">    2592 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">    2593 </span>            :           ltrce=ltrceC;
<span class="lineNum">    2594 </span>            :           channelSide=channelSideC;
<span class="lineNum">    2595 </span>            :         }
<span class="lineNum">    2596 </span>            : 
<span class="lineNum">    2597 </span><span class="lineNoCov">          0 :         ltrce-&gt;fVecSec-&gt;GetMatrixArray()[channelSide]=isector;</span>
<span class="lineNum">    2598 </span><span class="lineNoCov">          0 :         ltrce-&gt;fVecP2-&gt;GetMatrixArray()[channelSide]=0;</span>
<span class="lineNum">    2599 </span><span class="lineNoCov">          0 :         ltrce-&gt;fVecPhi-&gt;GetMatrixArray()[channelSide]=0;</span>
<span class="lineNum">    2600 </span><span class="lineNoCov">          0 :         ltrce-&gt;fVecGX-&gt;GetMatrixArray()[channelSide]=gxyz[0];</span>
<span class="lineNum">    2601 </span><span class="lineNoCov">          0 :         ltrce-&gt;fVecGY-&gt;GetMatrixArray()[channelSide]=gxyz[1];</span>
<span class="lineNum">    2602 </span>            : //         ltrce-&gt;fVecGZ-&gt;GetMatrixArray()[channelSide]=-1;
<span class="lineNum">    2603 </span><span class="lineNoCov">          0 :         ltrce-&gt;fVecLX-&gt;GetMatrixArray()[channelSide]=lxyz[0];</span>
<span class="lineNum">    2604 </span><span class="lineNoCov">          0 :         ltrce-&gt;fVecLY-&gt;GetMatrixArray()[channelSide]=lxyz[1];</span>
<span class="lineNum">    2605 </span>            : //         ltrce-&gt;fVecLZ-&gt;GetMatrixArray()[channelSide]=-1;
<span class="lineNum">    2606 </span>            : 
<span class="lineNum">    2607 </span><span class="lineNoCov">          0 :         if (side==0){</span>
<span class="lineNum">    2608 </span><span class="lineNoCov">          0 :           ltrce-&gt;fVecGZ-&gt;GetMatrixArray()[channelSide]=-0.335;</span>
<span class="lineNum">    2609 </span><span class="lineNoCov">          0 :           ltrce-&gt;fVecLZ-&gt;GetMatrixArray()[channelSide]=-0.335;</span>
<span class="lineNum">    2610 </span><span class="lineNoCov">          0 :           ++channelSideA;</span>
<span class="lineNum">    2611 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2612 </span>            :         else {
<span class="lineNum">    2613 </span><span class="lineNoCov">          0 :           ltrce-&gt;fVecGZ-&gt;GetMatrixArray()[channelSide]=0.15;</span>
<span class="lineNum">    2614 </span><span class="lineNoCov">          0 :           ltrce-&gt;fVecLZ-&gt;GetMatrixArray()[channelSide]=0.15;</span>
<span class="lineNum">    2615 </span><span class="lineNoCov">          0 :           ++channelSideC;</span>
<span class="lineNum">    2616 </span>            :         }
<span class="lineNum">    2617 </span>            :       }
<span class="lineNum">    2618 </span>            :     }
<span class="lineNum">    2619 </span>            :   }
<span class="lineNum">    2620 </span>            : 
<span class="lineNum">    2621 </span>            : 
<span class="lineNum">    2622 </span><span class="lineNoCov">          0 : }</span>
<a name="2623"><span class="lineNum">    2623 </span>            : </a>
<span class="lineNum">    2624 </span>            : //_____________________________________________________________________
<span class="lineNum">    2625 </span>            : void AliTPCCalibCE::CalculateDV(TObjArray * const arrIdeal, TObjArray * const arrMeasured, Int_t burst)
<span class="lineNum">    2626 </span>            : {
<span class="lineNum">    2627 </span>            :   /// calculate the drift velocity from the reconstructed clusters associated
<span class="lineNum">    2628 </span>            :   /// to the ideal laser tracks
<span class="lineNum">    2629 </span>            :   /// use two different fit scenarios: Separate fit for A- and C-Side
<span class="lineNum">    2630 </span>            :   ///                                  Common fit for A- and C-Side
<span class="lineNum">    2631 </span>            : 
<span class="lineNum">    2632 </span><span class="lineNoCov">          0 :   if (!fArrFitGraphs){</span>
<span class="lineNum">    2633 </span><span class="lineNoCov">          0 :     fArrFitGraphs=new TObjArray;</span>
<span class="lineNum">    2634 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2635 </span>            : 
<span class="lineNum">    2636 </span>            : //   static TLinearFitter fdriftA(5,&quot;hyp4&quot;);
<span class="lineNum">    2637 </span>            : //   static TLinearFitter fdriftC(5,&quot;hyp4&quot;);
<span class="lineNum">    2638 </span>            : //   static TLinearFitter fdriftAC(6,&quot;hyp5&quot;);
<span class="lineNum">    2639 </span><span class="lineNoCov">          0 :   Double_t timestamp=fTimeBursts[burst];</span>
<span class="lineNum">    2640 </span>            : 
<span class="lineNum">    2641 </span><span class="lineNoCov">          0 :   static TLinearFitter fdriftA(4,&quot;hyp3&quot;);</span>
<span class="lineNum">    2642 </span><span class="lineNoCov">          0 :   static TLinearFitter fdriftC(4,&quot;hyp3&quot;);</span>
<span class="lineNum">    2643 </span><span class="lineNoCov">          0 :   static TLinearFitter fdriftAC(5,&quot;hyp4&quot;);</span>
<span class="lineNum">    2644 </span><span class="lineNoCov">          0 :   TVectorD fitA(7),fitC(7),fitAC(8); //fit values+chi2+npoints</span>
<span class="lineNum">    2645 </span>            : 
<span class="lineNum">    2646 </span>            :   Float_t chi2A = 10;
<span class="lineNum">    2647 </span>            :   Float_t chi2C = 10;
<span class="lineNum">    2648 </span>            :   Float_t chi2AC = 10;
<span class="lineNum">    2649 </span>            :   Int_t npointsA=0;
<span class="lineNum">    2650 </span>            :   Int_t npointsC=0;
<span class="lineNum">    2651 </span>            :   Int_t npointsAC=0;
<span class="lineNum">    2652 </span>            : 
<span class="lineNum">    2653 </span><span class="lineNoCov">          0 :   Double_t minres[3]={20.,1,0.8};</span>
<span class="lineNum">    2654 </span>            :   //----
<span class="lineNum">    2655 </span><span class="lineNoCov">          0 :   for(Int_t i=0;i&lt;3;i++){</span>
<span class="lineNum">    2656 </span>            : 
<span class="lineNum">    2657 </span><span class="lineNoCov">          0 :     fdriftA.ClearPoints();</span>
<span class="lineNum">    2658 </span><span class="lineNoCov">          0 :     fdriftC.ClearPoints();</span>
<span class="lineNum">    2659 </span><span class="lineNoCov">          0 :     fdriftAC.ClearPoints();</span>
<span class="lineNum">    2660 </span>            : 
<span class="lineNum">    2661 </span>            :     chi2A = 10;
<span class="lineNum">    2662 </span>            :     chi2C = 10;
<span class="lineNum">    2663 </span>            :     chi2AC = 10;
<span class="lineNum">    2664 </span>            :     npointsA=0;
<span class="lineNum">    2665 </span>            :     npointsC=0;
<span class="lineNum">    2666 </span>            :     npointsAC=0;
<span class="lineNum">    2667 </span>            : 
<span class="lineNum">    2668 </span><span class="lineNoCov">          0 :     for (Int_t itrack=0; itrack&lt;338; ++itrack){</span>
<span class="lineNum">    2669 </span><span class="lineNoCov">          0 :       AliTPCLaserTrack *iltr=(AliTPCLaserTrack*)arrIdeal-&gt;UncheckedAt(itrack);</span>
<span class="lineNum">    2670 </span><span class="lineNoCov">          0 :       AliTPCLaserTrack *mltr=(AliTPCLaserTrack*)arrMeasured-&gt;UncheckedAt(itrack);</span>
<span class="lineNum">    2671 </span>            : 
<span class="lineNum">    2672 </span>            :       //-- Exclude the tracks which has the biggest inclanation angle
<span class="lineNum">    2673 </span><span class="lineNoCov">          0 :       if ((itrack%7==0||itrack%7==6)&amp;&amp;itrack&lt;336) continue;</span>
<span class="lineNum">    2674 </span>            :       Int_t clustercounter=0;
<span class="lineNum">    2675 </span>            :       Int_t indexMax=159;
<span class="lineNum">    2676 </span>            : 
<span class="lineNum">    2677 </span>            :       //-- exclude the low intensity tracks
<span class="lineNum">    2678 </span>            : 
<span class="lineNum">    2679 </span><span class="lineNoCov">          0 :       for (Int_t index=0; index&lt;indexMax; ++index){</span>
<span class="lineNum">    2680 </span>            : 
<span class="lineNum">    2681 </span><span class="lineNoCov">          0 :         Double_t mGx=mltr-&gt;fVecGX-&gt;GetMatrixArray()[index];</span>
<span class="lineNum">    2682 </span><span class="lineNoCov">          0 :         Double_t mGy=mltr-&gt;fVecGY-&gt;GetMatrixArray()[index];</span>
<span class="lineNum">    2683 </span><span class="lineNoCov">          0 :         Double_t mGz=mltr-&gt;fVecGZ-&gt;GetMatrixArray()[index];</span>
<span class="lineNum">    2684 </span>            : 
<span class="lineNum">    2685 </span><span class="lineNoCov">          0 :         if (TMath::Abs(mGz)&lt;1e-20 &amp;&amp; TMath::Abs(mGy)&lt;1e-20 &amp;&amp; TMath::Abs(mGx)&lt;1e-20) clustercounter++;</span>
<span class="lineNum">    2686 </span>            :       }
<span class="lineNum">    2687 </span><span class="lineNoCov">          0 :       if (clustercounter&gt;130&amp;&amp;itrack&lt;336) continue; // don't accept tracks with &lt;= 159-130=29 clusters</span>
<span class="lineNum">    2688 </span>            :       clustercounter=0;
<span class="lineNum">    2689 </span>            : 
<span class="lineNum">    2690 </span>            : 
<span class="lineNum">    2691 </span>            :       //-- drift length
<span class="lineNum">    2692 </span><span class="lineNoCov">          0 :       Double_t zlength = (iltr-&gt;GetSide()==0)? fParam-&gt;GetZLength(36): fParam-&gt;GetZLength(71);</span>
<span class="lineNum">    2693 </span>            : 
<span class="lineNum">    2694 </span><span class="lineNoCov">          0 :       if (itrack&gt;335) indexMax=557568/2;</span>
<span class="lineNum">    2695 </span><span class="lineNoCov">          0 :       for (Int_t index=0; index&lt;indexMax; ++index){</span>
<span class="lineNum">    2696 </span><span class="lineNoCov">          0 :         Double_t iGx=iltr-&gt;fVecGX-&gt;GetMatrixArray()[index];</span>
<span class="lineNum">    2697 </span><span class="lineNoCov">          0 :         Double_t iGy=iltr-&gt;fVecGY-&gt;GetMatrixArray()[index];</span>
<span class="lineNum">    2698 </span><span class="lineNoCov">          0 :         Double_t iGz=iltr-&gt;fVecGZ-&gt;GetMatrixArray()[index];</span>
<span class="lineNum">    2699 </span><span class="lineNoCov">          0 :         Double_t iR=TMath::Sqrt(iGx*iGx+iGy*iGy);</span>
<span class="lineNum">    2700 </span>            : 
<span class="lineNum">    2701 </span><span class="lineNoCov">          0 :         Double_t mGx=mltr-&gt;fVecGX-&gt;GetMatrixArray()[index];</span>
<span class="lineNum">    2702 </span><span class="lineNoCov">          0 :         Double_t mGy=mltr-&gt;fVecGY-&gt;GetMatrixArray()[index];</span>
<span class="lineNum">    2703 </span><span class="lineNoCov">          0 :         Double_t mGz=mltr-&gt;fVecGZ-&gt;GetMatrixArray()[index];</span>
<span class="lineNum">    2704 </span><span class="lineNoCov">          0 :         Double_t mR=TMath::Sqrt(mGx*mGx+mGy*mGy);</span>
<span class="lineNum">    2705 </span>            : 
<span class="lineNum">    2706 </span>            :       //cut if no track info available
<span class="lineNum">    2707 </span><span class="lineNoCov">          0 :         if (iltr-&gt;GetBundle()==0) continue;</span>
<span class="lineNum">    2708 </span><span class="lineNoCov">          0 :         if (iR&lt;133||mR&lt;133) continue;</span>
<span class="lineNum">    2709 </span><span class="lineNoCov">          0 :         if(TMath::Abs(mltr-&gt;fVecP2-&gt;GetMatrixArray()[index])&gt;minres[i]) continue;</span>
<span class="lineNum">    2710 </span>            : 
<span class="lineNum">    2711 </span><span class="lineNoCov">          0 :         Double_t ldrift  = (iltr-&gt;GetSide()==0)?zlength-iGz:iGz+zlength;</span>
<span class="lineNum">    2712 </span><span class="lineNoCov">          0 :         Double_t mdrift  = (iltr-&gt;GetSide()==0)?zlength-mGz:mGz+zlength;</span>
<span class="lineNum">    2713 </span>            : 
<span class="lineNum">    2714 </span>            :         //Double_t xxx[4] = {ldrift,iGy*ldrift/(zlength*250.), 250.-mR, iltr-&gt;fVecSec-&gt;GetMatrixArray()[index]&gt;35};
<span class="lineNum">    2715 </span><span class="lineNoCov">          0 :         Double_t xxx[3] = {ldrift,iGy*ldrift/(zlength*250.), 250.-mR};</span>
<span class="lineNum">    2716 </span>            : 
<span class="lineNum">    2717 </span><span class="lineNoCov">          0 :         if (iltr-&gt;GetSide()==0){</span>
<span class="lineNum">    2718 </span><span class="lineNoCov">          0 :           fdriftA.AddPoint(xxx,mdrift,1);</span>
<span class="lineNum">    2719 </span>            :         }else{
<span class="lineNum">    2720 </span><span class="lineNoCov">          0 :           fdriftC.AddPoint(xxx,mdrift,1);</span>
<span class="lineNum">    2721 </span>            :         }
<span class="lineNum">    2722 </span>            : //         Double_t xxx2[4] = { ldrift,iGy*ldrift/(zlength*250.), 250.-mR, iltr-&gt;fVecSec-&gt;GetMatrixArray()[index]&gt;35, iltr-&gt;GetSide()};
<span class="lineNum">    2723 </span><span class="lineNoCov">          0 :         Double_t xxx2[4] = { ldrift,iGy*ldrift/(zlength*250.), 250.-mR, static_cast&lt;Double_t&gt;(iltr-&gt;GetSide())};</span>
<span class="lineNum">    2724 </span><span class="lineNoCov">          0 :         fdriftAC.AddPoint(xxx2,mdrift,1);</span>
<span class="lineNum">    2725 </span>            : 
<span class="lineNum">    2726 </span><span class="lineNoCov">          0 :       }//end index loop</span>
<span class="lineNum">    2727 </span><span class="lineNoCov">          0 :     }//end laser track loop</span>
<span class="lineNum">    2728 </span>            : 
<span class="lineNum">    2729 </span>            :   //perform fit
<span class="lineNum">    2730 </span><span class="lineNoCov">          0 :     fdriftA.Eval();</span>
<span class="lineNum">    2731 </span><span class="lineNoCov">          0 :     fdriftC.Eval();</span>
<span class="lineNum">    2732 </span><span class="lineNoCov">          0 :     fdriftAC.Eval();</span>
<span class="lineNum">    2733 </span>            : 
<span class="lineNum">    2734 </span>            : 
<span class="lineNum">    2735 </span>            : 
<span class="lineNum">    2736 </span>            :   //get fit values
<span class="lineNum">    2737 </span><span class="lineNoCov">          0 :     fdriftA.GetParameters(fitA);</span>
<span class="lineNum">    2738 </span><span class="lineNoCov">          0 :     fdriftC.GetParameters(fitC);</span>
<span class="lineNum">    2739 </span><span class="lineNoCov">          0 :     fdriftAC.GetParameters(fitAC);</span>
<span class="lineNum">    2740 </span>            : 
<span class="lineNum">    2741 </span>            :   //Parameters:  0 linear offset
<span class="lineNum">    2742 </span>            :   //             1 mean drift velocity correction factor
<span class="lineNum">    2743 </span>            :   //             2 relative global y gradient
<span class="lineNum">    2744 </span>            :   //             3 radial deformation
<span class="lineNum">    2745 </span>            :   //             4 IROC/OROC offset
<span class="lineNum">    2746 </span>            : 
<span class="lineNum">    2747 </span>            : //      FindResiduals(arrMeasured,arrIdeal,fitA,fitC);
<span class="lineNum">    2748 </span>            : 
<span class="lineNum">    2749 </span><span class="lineNoCov">          0 :     for (Int_t itrack=0; itrack&lt;338; ++itrack){</span>
<span class="lineNum">    2750 </span><span class="lineNoCov">          0 :       AliTPCLaserTrack *iltr=(AliTPCLaserTrack*)arrIdeal-&gt;UncheckedAt(itrack);</span>
<span class="lineNum">    2751 </span><span class="lineNoCov">          0 :       AliTPCLaserTrack *mltr=(AliTPCLaserTrack*)arrMeasured-&gt;UncheckedAt(itrack);</span>
<span class="lineNum">    2752 </span>            : 
<span class="lineNum">    2753 </span>            :       //-- Exclude the tracks which has the biggest inclanation angle
<span class="lineNum">    2754 </span><span class="lineNoCov">          0 :       if ((itrack%7==0||itrack%7==6)&amp;&amp;itrack&lt;336) continue;</span>
<span class="lineNum">    2755 </span>            :       Int_t clustercounter=0;
<span class="lineNum">    2756 </span>            :       Int_t indexMax=159;
<span class="lineNum">    2757 </span>            : 
<span class="lineNum">    2758 </span>            :       //-- exclude the low intensity tracks
<span class="lineNum">    2759 </span>            : 
<span class="lineNum">    2760 </span><span class="lineNoCov">          0 :       for (Int_t index=0; index&lt;indexMax; ++index){</span>
<span class="lineNum">    2761 </span><span class="lineNoCov">          0 :         Double_t mGx=mltr-&gt;fVecGX-&gt;GetMatrixArray()[index];</span>
<span class="lineNum">    2762 </span><span class="lineNoCov">          0 :         Double_t mGy=mltr-&gt;fVecGY-&gt;GetMatrixArray()[index];</span>
<span class="lineNum">    2763 </span><span class="lineNoCov">          0 :         Double_t mGz=mltr-&gt;fVecGZ-&gt;GetMatrixArray()[index];</span>
<span class="lineNum">    2764 </span><span class="lineNoCov">          0 :         if (TMath::Abs(mGz)&lt;1e-20 &amp;&amp; TMath::Abs(mGy)&lt;1e-20 &amp;&amp; TMath::Abs(mGx)&lt;1e-20) clustercounter++;</span>
<span class="lineNum">    2765 </span>            :       }
<span class="lineNum">    2766 </span><span class="lineNoCov">          0 :       if (clustercounter&gt;130&amp;&amp;itrack&lt;336) continue; // don't accept tracks with &lt;= 159-130=29 clusters</span>
<span class="lineNum">    2767 </span>            :       clustercounter=0;
<span class="lineNum">    2768 </span>            : 
<span class="lineNum">    2769 </span>            :       //-- drift length
<span class="lineNum">    2770 </span><span class="lineNoCov">          0 :       Double_t zlength = (iltr-&gt;GetSide()==0)? fParam-&gt;GetZLength(36): fParam-&gt;GetZLength(71);</span>
<span class="lineNum">    2771 </span>            : 
<span class="lineNum">    2772 </span><span class="lineNoCov">          0 :       if (itrack&gt;335) indexMax=557568/2;</span>
<span class="lineNum">    2773 </span><span class="lineNoCov">          0 :       for (Int_t index=0; index&lt;indexMax; ++index){</span>
<span class="lineNum">    2774 </span><span class="lineNoCov">          0 :         Double_t iGx=iltr-&gt;fVecGX-&gt;GetMatrixArray()[index];</span>
<span class="lineNum">    2775 </span><span class="lineNoCov">          0 :         Double_t iGy=iltr-&gt;fVecGY-&gt;GetMatrixArray()[index];</span>
<span class="lineNum">    2776 </span><span class="lineNoCov">          0 :         Double_t iGz=iltr-&gt;fVecGZ-&gt;GetMatrixArray()[index];</span>
<span class="lineNum">    2777 </span><span class="lineNoCov">          0 :         Double_t iR=TMath::Sqrt(iGx*iGx+iGy*iGy);</span>
<span class="lineNum">    2778 </span>            : 
<span class="lineNum">    2779 </span><span class="lineNoCov">          0 :         Double_t mGx=mltr-&gt;fVecGX-&gt;GetMatrixArray()[index];</span>
<span class="lineNum">    2780 </span><span class="lineNoCov">          0 :         Double_t mGy=mltr-&gt;fVecGY-&gt;GetMatrixArray()[index];</span>
<span class="lineNum">    2781 </span><span class="lineNoCov">          0 :         Double_t mGz=mltr-&gt;fVecGZ-&gt;GetMatrixArray()[index];</span>
<span class="lineNum">    2782 </span><span class="lineNoCov">          0 :         Double_t mR=TMath::Sqrt(mGx*mGx+mGy*mGy);</span>
<span class="lineNum">    2783 </span>            : 
<span class="lineNum">    2784 </span>            :       //cut if no track info available
<span class="lineNum">    2785 </span><span class="lineNoCov">          0 :         if (iR&lt;60||mR&lt;60) continue;</span>
<span class="lineNum">    2786 </span>            : 
<span class="lineNum">    2787 </span><span class="lineNoCov">          0 :         Double_t ldrift  = (iltr-&gt;GetSide()==0)?zlength-iGz:iGz+zlength;</span>
<span class="lineNum">    2788 </span><span class="lineNoCov">          0 :         Double_t mdrift  = (iltr-&gt;GetSide()==0)?zlength-mGz:mGz+zlength;</span>
<span class="lineNum">    2789 </span>            : 
<span class="lineNum">    2790 </span>            :         TVectorD *v=&amp;fitA;
<span class="lineNum">    2791 </span><span class="lineNoCov">          0 :         if (iltr-&gt;GetSide()==1) v=&amp;fitC;</span>
<span class="lineNum">    2792 </span>            : //         Double_t iCorr=(*v)[0]+(*v)[1]*ldrift+(*v)[2]*iGy*ldrift/(zlength*250.)+(*v)[3]*(250.-mR)+(*v)[4]*( iltr-&gt;fVecSec-&gt;GetMatrixArray()[index]&gt;35);
<span class="lineNum">    2793 </span><span class="lineNoCov">          0 :         Double_t iCorr=(*v)[0]+(*v)[1]*ldrift+(*v)[2]*iGy*ldrift/(zlength*250.)+(*v)[3]*(250.-mR);</span>
<span class="lineNum">    2794 </span>            : 
<span class="lineNum">    2795 </span><span class="lineNoCov">          0 :         mltr-&gt;fVecP2-&gt;GetMatrixArray()[index]=mdrift-iCorr;</span>
<span class="lineNum">    2796 </span>            : 
<span class="lineNum">    2797 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    2798 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2799 </span>            : 
<span class="lineNum">    2800 </span><span class="lineNoCov">          0 :     fitA.ResizeTo(7);</span>
<span class="lineNum">    2801 </span><span class="lineNoCov">          0 :     fitC.ResizeTo(7);</span>
<span class="lineNum">    2802 </span><span class="lineNoCov">          0 :     fitAC.ResizeTo(8);</span>
<span class="lineNum">    2803 </span>            : 
<span class="lineNum">    2804 </span>            : //set statistics values
<span class="lineNum">    2805 </span>            : 
<span class="lineNum">    2806 </span><span class="lineNoCov">          0 :     npointsA= fdriftA.GetNpoints();</span>
<span class="lineNum">    2807 </span><span class="lineNoCov">          0 :     if (npointsA&gt;0) chi2A = fdriftA.GetChisquare()/fdriftA.GetNpoints();</span>
<span class="lineNum">    2808 </span><span class="lineNoCov">          0 :     fitA[5]=npointsA;</span>
<span class="lineNum">    2809 </span><span class="lineNoCov">          0 :     fitA[6]=chi2A;</span>
<span class="lineNum">    2810 </span>            : 
<span class="lineNum">    2811 </span><span class="lineNoCov">          0 :     npointsC= fdriftC.GetNpoints();</span>
<span class="lineNum">    2812 </span><span class="lineNoCov">          0 :     if (npointsC&gt;0) chi2C = fdriftC.GetChisquare()/fdriftC.GetNpoints();</span>
<span class="lineNum">    2813 </span><span class="lineNoCov">          0 :     fitC[5]=npointsC;</span>
<span class="lineNum">    2814 </span><span class="lineNoCov">          0 :     fitC[6]=chi2C;</span>
<span class="lineNum">    2815 </span>            : 
<span class="lineNum">    2816 </span><span class="lineNoCov">          0 :     npointsAC= fdriftAC.GetNpoints();</span>
<span class="lineNum">    2817 </span><span class="lineNoCov">          0 :     if (npointsAC&gt;0) chi2AC = fdriftAC.GetChisquare()/fdriftAC.GetNpoints();</span>
<span class="lineNum">    2818 </span><span class="lineNoCov">          0 :     fitAC[5]=npointsAC;</span>
<span class="lineNum">    2819 </span><span class="lineNoCov">          0 :     fitAC[6]=chi2AC;</span>
<span class="lineNum">    2820 </span>            : 
<span class="lineNum">    2821 </span><span class="lineNoCov">          0 :     if (fStreamLevel&gt;2){</span>
<span class="lineNum">    2822 </span>            :     //laser track information
<span class="lineNum">    2823 </span><span class="lineNoCov">          0 :       (*GetDebugStreamer()) &lt;&lt; &quot;DriftV&quot; &lt;&lt;</span>
<span class="lineNum">    2824 </span><span class="lineNoCov">          0 :         &quot;iter=&quot;   &lt;&lt; i &lt;&lt;</span>
<span class="lineNum">    2825 </span><span class="lineNoCov">          0 :         &quot;run=&quot;    &lt;&lt; fRunNumber &lt;&lt;</span>
<span class="lineNum">    2826 </span><span class="lineNoCov">          0 :         &quot;time=&quot;   &lt;&lt; timestamp &lt;&lt;</span>
<span class="lineNum">    2827 </span><span class="lineNoCov">          0 :         &quot;fitA.=&quot;  &lt;&lt; &amp;fitA &lt;&lt;</span>
<span class="lineNum">    2828 </span><span class="lineNoCov">          0 :         &quot;fitC.=&quot;  &lt;&lt; &amp;fitC &lt;&lt;</span>
<span class="lineNum">    2829 </span><span class="lineNoCov">          0 :         &quot;fitAC.=&quot; &lt;&lt; &amp;fitAC &lt;&lt;</span>
<span class="lineNum">    2830 </span>            :         &quot;\n&quot;;
<span class="lineNum">    2831 </span>            : 
<span class="lineNum">    2832 </span>            : 
<span class="lineNum">    2833 </span>            :     }
<span class="lineNum">    2834 </span>            : 
<span class="lineNum">    2835 </span>            :   }
<span class="lineNum">    2836 </span>            : //-----
<span class="lineNum">    2837 </span>            : 
<span class="lineNum">    2838 </span>            : 
<span class="lineNum">    2839 </span>            :   //Parameters:  0 linear offset (global)
<span class="lineNum">    2840 </span>            :   //             1 mean drift velocity correction factor
<span class="lineNum">    2841 </span>            :   //             2 relative global y gradient
<span class="lineNum">    2842 </span>            :   //             3 radial deformation
<span class="lineNum">    2843 </span>            :   //             4 IROC/OROC offset
<span class="lineNum">    2844 </span>            :   //             5 linear offset relative A-C
<span class="lineNum">    2845 </span>            : 
<span class="lineNum">    2846 </span>            :   //get graphs
<span class="lineNum">    2847 </span><span class="lineNoCov">          0 :   TGraphErrors *grA[7];</span>
<span class="lineNum">    2848 </span><span class="lineNoCov">          0 :   TGraphErrors *grC[7];</span>
<span class="lineNum">    2849 </span><span class="lineNoCov">          0 :   TGraphErrors *grAC[8];</span>
<span class="lineNum">    2850 </span><span class="lineNoCov">          0 :   TString names(&quot;GRAPH_MEAN_DELAY_LASER_ALL_;GRAPH_MEAN_DRIFT_LASER_ALL_;GRAPH_MEAN_GLOBALYGRADIENT_LASER_ALL_;GRAPH_MEAN_RGRADIENT_LASER_ALL_;GRAPH_MEAN_IROCOROCOFFSET_LASER_ALL_;GRAPH_MEAN_NPOINTS_LASER_ALL_;GRAPH_MEAN_CHI2_LASER_ALL_&quot;);</span>
<span class="lineNum">    2851 </span><span class="lineNoCov">          0 :   TString namesAC(&quot;GRAPH_MEAN_DELAY_LASER_ALL_;GRAPH_MEAN_DRIFT_LASER_ALL_;GRAPH_MEAN_GLOBALYGRADIENT_LASER_ALL_;GRAPH_MEAN_RGRADIENT_LASER_ALL_;GRAPH_MEAN_IROCOROCOFFSET_LASER_ALL_;GRAPH_MEAN_NPOINTS_LASER_ALL_;GRAPH_MEAN_CHI2_LASER_ALL_;GRAPH_MEAN_DELAYC_LASER_ALL_&quot;);</span>
<span class="lineNum">    2852 </span>            : 
<span class="lineNum">    2853 </span><span class="lineNoCov">          0 :   TObjArray *arrNames=names.Tokenize(&quot;;&quot;);</span>
<span class="lineNum">    2854 </span><span class="lineNoCov">          0 :   TObjArray *arrNamesAC=namesAC.Tokenize(&quot;;&quot;);</span>
<span class="lineNum">    2855 </span>            : 
<span class="lineNum">    2856 </span>            :   //A-Side graphs
<span class="lineNum">    2857 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;7; ++i){</span>
<span class="lineNum">    2858 </span><span class="lineNoCov">          0 :     TString grName=arrNames-&gt;UncheckedAt(i)-&gt;GetName();</span>
<span class="lineNum">    2859 </span><span class="lineNoCov">          0 :     grName+=&quot;A&quot;;</span>
<span class="lineNum">    2860 </span><span class="lineNoCov">          0 :     grA[i]=(TGraphErrors*)fArrFitGraphs-&gt;FindObject(grName.Data());</span>
<span class="lineNum">    2861 </span><span class="lineNoCov">          0 :     if (!grA[i]){</span>
<span class="lineNum">    2862 </span><span class="lineNoCov">          0 :       grA[i]=new TGraphErrors;</span>
<span class="lineNum">    2863 </span><span class="lineNoCov">          0 :       grA[i]-&gt;SetName(grName.Data());</span>
<span class="lineNum">    2864 </span><span class="lineNoCov">          0 :       grA[i]-&gt;SetTitle(grName.ReplaceAll(&quot;_&quot;,&quot; &quot;).Data());</span>
<span class="lineNum">    2865 </span><span class="lineNoCov">          0 :       fArrFitGraphs-&gt;Add(grA[i]);</span>
<span class="lineNum">    2866 </span>            :     }
<span class="lineNum">    2867 </span>            : //     Int_t ipoint=grA[i]-&gt;GetN();
<span class="lineNum">    2868 </span>            :     Int_t ipoint=burst;
<span class="lineNum">    2869 </span><span class="lineNoCov">          0 :     grA[i]-&gt;SetPoint(ipoint,timestamp,fitA(i));</span>
<span class="lineNum">    2870 </span><span class="lineNoCov">          0 :     grA[i]-&gt;SetPointError(ipoint,60,.0001);</span>
<span class="lineNum">    2871 </span><span class="lineNoCov">          0 :     if (i&lt;4) grA[i]-&gt;SetPointError(ipoint,60,fdriftA.GetCovarianceMatrixElement(i,i));</span>
<span class="lineNum">    2872 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2873 </span>            : 
<span class="lineNum">    2874 </span>            :   //C-Side graphs
<span class="lineNum">    2875 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;7; ++i){</span>
<span class="lineNum">    2876 </span><span class="lineNoCov">          0 :     TString grName=arrNames-&gt;UncheckedAt(i)-&gt;GetName();</span>
<span class="lineNum">    2877 </span><span class="lineNoCov">          0 :     grName+=&quot;C&quot;;</span>
<span class="lineNum">    2878 </span><span class="lineNoCov">          0 :     grC[i]=(TGraphErrors*)fArrFitGraphs-&gt;FindObject(grName.Data());</span>
<span class="lineNum">    2879 </span><span class="lineNoCov">          0 :     if (!grC[i]){</span>
<span class="lineNum">    2880 </span><span class="lineNoCov">          0 :       grC[i]=new TGraphErrors;</span>
<span class="lineNum">    2881 </span><span class="lineNoCov">          0 :       grC[i]-&gt;SetName(grName.Data());</span>
<span class="lineNum">    2882 </span><span class="lineNoCov">          0 :       grC[i]-&gt;SetTitle(grName.ReplaceAll(&quot;_&quot;,&quot; &quot;).Data());</span>
<span class="lineNum">    2883 </span><span class="lineNoCov">          0 :       fArrFitGraphs-&gt;Add(grC[i]);</span>
<span class="lineNum">    2884 </span>            :     }
<span class="lineNum">    2885 </span>            : //     Int_t ipoint=grC[i]-&gt;GetN();
<span class="lineNum">    2886 </span>            :     Int_t ipoint=burst;
<span class="lineNum">    2887 </span><span class="lineNoCov">          0 :     grC[i]-&gt;SetPoint(ipoint,timestamp,fitC(i));</span>
<span class="lineNum">    2888 </span><span class="lineNoCov">          0 :     grC[i]-&gt;SetPointError(ipoint,60,.0001);</span>
<span class="lineNum">    2889 </span><span class="lineNoCov">          0 :     if (i&lt;4) grC[i]-&gt;SetPointError(ipoint,60,fdriftC.GetCovarianceMatrixElement(i,i));</span>
<span class="lineNum">    2890 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2891 </span>            : 
<span class="lineNum">    2892 </span>            :   //AC-Side graphs
<span class="lineNum">    2893 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;8; ++i){</span>
<span class="lineNum">    2894 </span><span class="lineNoCov">          0 :     TString grName=arrNamesAC-&gt;UncheckedAt(i)-&gt;GetName();</span>
<span class="lineNum">    2895 </span><span class="lineNoCov">          0 :     grName+=&quot;AC&quot;;</span>
<span class="lineNum">    2896 </span><span class="lineNoCov">          0 :     grAC[i]=(TGraphErrors*)fArrFitGraphs-&gt;FindObject(grName.Data());</span>
<span class="lineNum">    2897 </span><span class="lineNoCov">          0 :     if (!grAC[i]){</span>
<span class="lineNum">    2898 </span><span class="lineNoCov">          0 :       grAC[i]=new TGraphErrors;</span>
<span class="lineNum">    2899 </span><span class="lineNoCov">          0 :       grAC[i]-&gt;SetName(grName.Data());</span>
<span class="lineNum">    2900 </span><span class="lineNoCov">          0 :       grAC[i]-&gt;SetTitle(grName.ReplaceAll(&quot;_&quot;,&quot; &quot;).Data());</span>
<span class="lineNum">    2901 </span><span class="lineNoCov">          0 :       fArrFitGraphs-&gt;Add(grAC[i]);</span>
<span class="lineNum">    2902 </span>            :     }
<span class="lineNum">    2903 </span>            : //     Int_t ipoint=grAC[i]-&gt;GetN();
<span class="lineNum">    2904 </span>            :     Int_t ipoint=burst;
<span class="lineNum">    2905 </span><span class="lineNoCov">          0 :     grAC[i]-&gt;SetPoint(ipoint,timestamp,fitAC(i));</span>
<span class="lineNum">    2906 </span><span class="lineNoCov">          0 :     grAC[i]-&gt;SetPointError(ipoint,60,.0001);</span>
<span class="lineNum">    2907 </span><span class="lineNoCov">          0 :     if (i&lt;5) grAC[i]-&gt;SetPointError(ipoint,60,fdriftAC.GetCovarianceMatrixElement(i,i));</span>
<span class="lineNum">    2908 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2909 </span>            : 
<span class="lineNum">    2910 </span><span class="lineNoCov">          0 :   if (fDebugLevel&gt;10){</span>
<span class="lineNum">    2911 </span><span class="lineNoCov">          0 :     printf(&quot;A side fit parameters:\n&quot;);</span>
<span class="lineNum">    2912 </span><span class="lineNoCov">          0 :     fitA.Print();</span>
<span class="lineNum">    2913 </span><span class="lineNoCov">          0 :     printf(&quot;\nC side fit parameters:\n&quot;);</span>
<span class="lineNum">    2914 </span><span class="lineNoCov">          0 :     fitC.Print();</span>
<span class="lineNum">    2915 </span><span class="lineNoCov">          0 :     printf(&quot;\nAC side fit parameters:\n&quot;);</span>
<span class="lineNum">    2916 </span><span class="lineNoCov">          0 :     fitAC.Print();</span>
<span class="lineNum">    2917 </span>            :   }
<span class="lineNum">    2918 </span><span class="lineNoCov">          0 :   delete arrNames;</span>
<span class="lineNum">    2919 </span><span class="lineNoCov">          0 :   delete arrNamesAC;</span>
<span class="lineNum">    2920 </span><span class="lineNoCov">          0 : }</span>
<a name="2921"><span class="lineNum">    2921 </span>            : </a>
<span class="lineNum">    2922 </span>            : //_____________________________________________________________________
<span class="lineNum">    2923 </span>            : Double_t AliTPCCalibCE::SetBurstHnDrift()
<span class="lineNum">    2924 </span>            : {
<span class="lineNum">    2925 </span>            :   /// Create a new THnSparse for the current burst
<span class="lineNum">    2926 </span>            :   /// return the time of the current burst
<span class="lineNum">    2927 </span>            : 
<span class="lineNum">    2928 </span>            :   Int_t i=0;
<span class="lineNum">    2929 </span><span class="lineNoCov">          0 :   for(i=0; i&lt;fTimeBursts.GetNrows(); ++i){</span>
<span class="lineNum">    2930 </span><span class="lineNoCov">          0 :     if(fTimeBursts.GetMatrixArray()[i]&lt;1.e-20) break;</span>
<span class="lineNum">    2931 </span><span class="lineNoCov">          0 :     if(TMath::Abs(fTimeBursts.GetMatrixArray()[i]-fTimeStamp)&lt;300){</span>
<span class="lineNum">    2932 </span><span class="lineNoCov">          0 :       fHnDrift=(THnSparseI*)fArrHnDrift.UncheckedAt(i);</span>
<span class="lineNum">    2933 </span><span class="lineNoCov">          0 :       return fTimeBursts(i);</span>
<span class="lineNum">    2934 </span>            :     }
<span class="lineNum">    2935 </span>            :   }
<span class="lineNum">    2936 </span>            : 
<span class="lineNum">    2937 </span><span class="lineNoCov">          0 :   CreateDVhist();</span>
<span class="lineNum">    2938 </span><span class="lineNoCov">          0 :   fArrHnDrift.AddAt(fHnDrift,i);</span>
<span class="lineNum">    2939 </span><span class="lineNoCov">          0 :   fTimeBursts.GetMatrixArray()[i]=fTimeStamp;</span>
<span class="lineNum">    2940 </span><span class="lineNoCov">          0 :   for (i=0;i&lt;14;++i){</span>
<span class="lineNum">    2941 </span><span class="lineNoCov">          0 :     fPeaks[i]=0;</span>
<span class="lineNum">    2942 </span><span class="lineNoCov">          0 :     fPeakWidths[i]=0;</span>
<span class="lineNum">    2943 </span>            :   }
<span class="lineNum">    2944 </span><span class="lineNoCov">          0 :   fEventInBunch=0;</span>
<span class="lineNum">    2945 </span><span class="lineNoCov">          0 :   return fTimeStamp;</span>
<span class="lineNum">    2946 </span><span class="lineNoCov">          0 : }</span>
<a name="2947"><span class="lineNum">    2947 </span>            : </a>
<span class="lineNum">    2948 </span>            : //_____________________________________________________________________
<span class="lineNum">    2949 </span>            : void AliTPCCalibCE::DumpToFile(const Char_t *filename, const Char_t *dir, Bool_t /*append*/)
<span class="lineNum">    2950 </span>            : {
<span class="lineNum">    2951 </span>            :   ///  Write class to file
<span class="lineNum">    2952 </span>            :   ///  option can be specified in the dir option:
<span class="lineNum">    2953 </span>            :   ///  options:
<span class="lineNum">    2954 </span>            :   ///    name=&lt;objname&gt;: the name of the calibration object in file will be &lt;objname&gt;
<span class="lineNum">    2955 </span>            :   ///    type=&lt;type&gt;:    the saving type:
<span class="lineNum">    2956 </span>            :   ///                    0 - write the complte object
<span class="lineNum">    2957 </span>            :   ///                    1 - Store the histogram arrays separately to make the streamed object smaller, Analyse to be called
<span class="lineNum">    2958 </span>            :   ///                    2 - like 2, but in addition delete objects that will most probably not be used for calibration
<span class="lineNum">    2959 </span>            :   ///                    3 - store only calibration output, don't store the reference histograms
<span class="lineNum">    2960 </span>            :   ///                        and THnSparse (requires Analyse called before)
<span class="lineNum">    2961 </span>            :   ///
<span class="lineNum">    2962 </span>            :   ///  NOTE: to read the object back, the ReadFromFile function should be used
<span class="lineNum">    2963 </span>            : 
<span class="lineNum">    2964 </span><span class="lineNoCov">          0 :   TString sDir(dir);</span>
<span class="lineNum">    2965 </span><span class="lineNoCov">          0 :   TString objName=GetName();</span>
<span class="lineNum">    2966 </span>            :   Int_t type=0;
<span class="lineNum">    2967 </span>            : 
<span class="lineNum">    2968 </span>            :   //get options
<span class="lineNum">    2969 </span><span class="lineNoCov">          0 :   TObjArray *arr=sDir.Tokenize(&quot;,&quot;);</span>
<span class="lineNum">    2970 </span><span class="lineNoCov">          0 :   TIter next(arr);</span>
<span class="lineNum">    2971 </span>            :   TObjString *s;
<span class="lineNum">    2972 </span><span class="lineNoCov">          0 :   while ( (s=(TObjString*)next()) ){</span>
<span class="lineNum">    2973 </span><span class="lineNoCov">          0 :     TString optString=s-&gt;GetString();</span>
<span class="lineNum">    2974 </span><span class="lineNoCov">          0 :     optString.Remove(TString::kBoth,' ');</span>
<span class="lineNum">    2975 </span><span class="lineNoCov">          0 :     if (optString.BeginsWith(&quot;name=&quot;)){</span>
<span class="lineNum">    2976 </span><span class="lineNoCov">          0 :       objName=optString.ReplaceAll(&quot;name=&quot;,&quot;&quot;);</span>
<span class="lineNum">    2977 </span>            :     }
<span class="lineNum">    2978 </span><span class="lineNoCov">          0 :     if (optString.BeginsWith(&quot;type=&quot;)){</span>
<span class="lineNum">    2979 </span><span class="lineNoCov">          0 :       optString.ReplaceAll(&quot;type=&quot;,&quot;&quot;);</span>
<span class="lineNum">    2980 </span><span class="lineNoCov">          0 :       type=optString.Atoi();</span>
<span class="lineNum">    2981 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2982 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2983 </span><span class="lineNoCov">          0 :   delete arr;</span>
<span class="lineNum">    2984 </span>            : 
<span class="lineNum">    2985 </span><span class="lineNoCov">          0 :   if ( type==4 ){</span>
<span class="lineNum">    2986 </span>            :     // only for the new algorithm
<span class="lineNum">    2987 </span><span class="lineNoCov">          0 :     AliTPCCalibCE ce;</span>
<span class="lineNum">    2988 </span><span class="lineNoCov">          0 :     ce.fArrFitGraphs=fArrFitGraphs;</span>
<span class="lineNum">    2989 </span><span class="lineNoCov">          0 :     ce.fNevents=fNevents;</span>
<span class="lineNum">    2990 </span><span class="lineNoCov">          0 :     ce.fTimeBursts.ResizeTo(fTimeBursts.GetNrows());</span>
<span class="lineNum">    2991 </span><span class="lineNoCov">          0 :     ce.fTimeBursts=fTimeBursts;</span>
<span class="lineNum">    2992 </span><span class="lineNoCov">          0 :     ce.fProcessNew=kTRUE;</span>
<span class="lineNum">    2993 </span><span class="lineNoCov">          0 :     TFile f(filename,&quot;recreate&quot;);</span>
<span class="lineNum">    2994 </span><span class="lineNoCov">          0 :     ce.Write(objName.Data());</span>
<span class="lineNum">    2995 </span><span class="lineNoCov">          0 :     fArrHnDrift.Write(&quot;arrHnDrift&quot;,TObject::kSingleKey);</span>
<span class="lineNum">    2996 </span><span class="lineNoCov">          0 :     f.Close();</span>
<span class="lineNum">    2997 </span><span class="lineNoCov">          0 :     ce.fArrFitGraphs=0x0;</span>
<span class="lineNum">    2998 </span>            :     return;
<span class="lineNum">    2999 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3000 </span>            : 
<span class="lineNum">    3001 </span>            : 
<span class="lineNum">    3002 </span><span class="lineNoCov">          0 :   if (type==1||type==2) {</span>
<span class="lineNum">    3003 </span>            :     //delete most probably not needed stuff
<span class="lineNum">    3004 </span>            :     //This requires Analyse to be called after reading the object from file
<span class="lineNum">    3005 </span><span class="lineNoCov">          0 :     fCalRocArrayT0.Delete();</span>
<span class="lineNum">    3006 </span><span class="lineNoCov">          0 :     fCalRocArrayT0Err.Delete();</span>
<span class="lineNum">    3007 </span><span class="lineNoCov">          0 :     fCalRocArrayQ.Delete();</span>
<span class="lineNum">    3008 </span><span class="lineNoCov">          0 :     fCalRocArrayRMS.Delete();</span>
<span class="lineNum">    3009 </span><span class="lineNoCov">          0 :     fCalRocArrayOutliers.Delete();</span>
<span class="lineNum">    3010 </span>            :   }
<span class="lineNum">    3011 </span><span class="lineNoCov">          0 :   if (type==2||type==3){</span>
<span class="lineNum">    3012 </span><span class="lineNoCov">          0 :     fParamArrayEventPol1.Delete();</span>
<span class="lineNum">    3013 </span><span class="lineNoCov">          0 :     fParamArrayEventPol2.Delete();</span>
<span class="lineNum">    3014 </span>            :   }
<span class="lineNum">    3015 </span>            : 
<span class="lineNum">    3016 </span><span class="lineNoCov">          0 :   TObjArray histoQArray(72);</span>
<span class="lineNum">    3017 </span><span class="lineNoCov">          0 :   TObjArray histoT0Array(72);</span>
<span class="lineNum">    3018 </span><span class="lineNoCov">          0 :   TObjArray histoRMSArray(72);</span>
<span class="lineNum">    3019 </span><span class="lineNoCov">          0 :   TObjArray arrHnDrift(fArrHnDrift.GetEntries());</span>
<span class="lineNum">    3020 </span>            : 
<span class="lineNum">    3021 </span>            :   //save all large 2D histograms in separte pointers
<span class="lineNum">    3022 </span>            :   //to have a smaller memory print when saving the object
<span class="lineNum">    3023 </span><span class="lineNoCov">          0 :   if (type==1||type==2||type==3){</span>
<span class="lineNum">    3024 </span><span class="lineNoCov">          0 :     for (Int_t i=0; i&lt;72; ++i){</span>
<span class="lineNum">    3025 </span><span class="lineNoCov">          0 :       histoQArray.AddAt(fHistoQArray.UncheckedAt(i),i);</span>
<span class="lineNum">    3026 </span><span class="lineNoCov">          0 :       histoT0Array.AddAt(fHistoT0Array.UncheckedAt(i),i);</span>
<span class="lineNum">    3027 </span><span class="lineNoCov">          0 :       histoRMSArray.AddAt(fHistoRMSArray.UncheckedAt(i),i);</span>
<span class="lineNum">    3028 </span>            :     }
<span class="lineNum">    3029 </span><span class="lineNoCov">          0 :     fHistoQArray.SetOwner(kFALSE);</span>
<span class="lineNum">    3030 </span><span class="lineNoCov">          0 :     fHistoT0Array.SetOwner(kFALSE);</span>
<span class="lineNum">    3031 </span><span class="lineNoCov">          0 :     fHistoRMSArray.SetOwner(kFALSE);</span>
<span class="lineNum">    3032 </span><span class="lineNoCov">          0 :     fHistoQArray.Clear();</span>
<span class="lineNum">    3033 </span><span class="lineNoCov">          0 :     fHistoT0Array.Clear();</span>
<span class="lineNum">    3034 </span><span class="lineNoCov">          0 :     fHistoRMSArray.Clear();</span>
<span class="lineNum">    3035 </span>            : 
<span class="lineNum">    3036 </span><span class="lineNoCov">          0 :     for (Int_t i=0;i&lt;fArrHnDrift.GetEntries();++i){</span>
<span class="lineNum">    3037 </span><span class="lineNoCov">          0 :       arrHnDrift.AddAt(fArrHnDrift.UncheckedAt(i),i);</span>
<span class="lineNum">    3038 </span>            :     }
<span class="lineNum">    3039 </span><span class="lineNoCov">          0 :     fArrHnDrift.SetOwner(kFALSE);</span>
<span class="lineNum">    3040 </span><span class="lineNoCov">          0 :     fArrHnDrift.Clear();</span>
<span class="lineNum">    3041 </span>            :   }
<span class="lineNum">    3042 </span>            : 
<span class="lineNum">    3043 </span>            : 
<span class="lineNum">    3044 </span><span class="lineNoCov">          0 :   TDirectory *backup = gDirectory;</span>
<span class="lineNum">    3045 </span>            : 
<span class="lineNum">    3046 </span><span class="lineNoCov">          0 :   TFile f(filename,&quot;recreate&quot;);</span>
<span class="lineNum">    3047 </span><span class="lineNoCov">          0 :   Write(objName.Data());</span>
<span class="lineNum">    3048 </span><span class="lineNoCov">          0 :   if (type==1||type==2) {</span>
<span class="lineNum">    3049 </span><span class="lineNoCov">          0 :     histoQArray.Write(&quot;histoQArray&quot;,TObject::kSingleKey);</span>
<span class="lineNum">    3050 </span><span class="lineNoCov">          0 :     histoT0Array.Write(&quot;histoT0Array&quot;,TObject::kSingleKey);</span>
<span class="lineNum">    3051 </span><span class="lineNoCov">          0 :     histoRMSArray.Write(&quot;histoRMSArray&quot;,TObject::kSingleKey);</span>
<span class="lineNum">    3052 </span><span class="lineNoCov">          0 :     arrHnDrift.Write(&quot;arrHnDrift&quot;,TObject::kSingleKey);</span>
<span class="lineNum">    3053 </span>            :   }
<span class="lineNum">    3054 </span>            : 
<span class="lineNum">    3055 </span><span class="lineNoCov">          0 :   f.Save();</span>
<span class="lineNum">    3056 </span><span class="lineNoCov">          0 :   f.Close();</span>
<span class="lineNum">    3057 </span>            : 
<span class="lineNum">    3058 </span>            :   //move histograms back to the object
<span class="lineNum">    3059 </span><span class="lineNoCov">          0 :   if (type==1||type==2){</span>
<span class="lineNum">    3060 </span><span class="lineNoCov">          0 :     for (Int_t i=0; i&lt;72; ++i){</span>
<span class="lineNum">    3061 </span><span class="lineNoCov">          0 :       fHistoQArray.AddAt(histoQArray.UncheckedAt(i),i);</span>
<span class="lineNum">    3062 </span><span class="lineNoCov">          0 :       fHistoT0Array.AddAt(histoT0Array.UncheckedAt(i),i);</span>
<span class="lineNum">    3063 </span><span class="lineNoCov">          0 :       fHistoRMSArray.AddAt(histoRMSArray.UncheckedAt(i),i);</span>
<span class="lineNum">    3064 </span>            :     }
<span class="lineNum">    3065 </span><span class="lineNoCov">          0 :     fHistoQArray.SetOwner(kTRUE);</span>
<span class="lineNum">    3066 </span><span class="lineNoCov">          0 :     fHistoT0Array.SetOwner(kTRUE);</span>
<span class="lineNum">    3067 </span><span class="lineNoCov">          0 :     fHistoRMSArray.SetOwner(kTRUE);</span>
<span class="lineNum">    3068 </span>            : 
<span class="lineNum">    3069 </span><span class="lineNoCov">          0 :     for (Int_t i=0;i&lt;arrHnDrift.GetEntries();++i){</span>
<span class="lineNum">    3070 </span><span class="lineNoCov">          0 :       fArrHnDrift.AddAt(arrHnDrift.UncheckedAt(i),i);</span>
<span class="lineNum">    3071 </span>            :     }
<span class="lineNum">    3072 </span><span class="lineNoCov">          0 :     fArrHnDrift.SetOwner(kTRUE);</span>
<span class="lineNum">    3073 </span>            :   }
<span class="lineNum">    3074 </span>            : 
<span class="lineNum">    3075 </span><span class="lineNoCov">          0 :   if ( backup ) backup-&gt;cd();</span>
<a name="3076"><span class="lineNum">    3076 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    3077 </span>            : //_____________________________________________________________________
<span class="lineNum">    3078 </span>            : AliTPCCalibCE* AliTPCCalibCE::ReadFromFile(const Char_t *filename)
<span class="lineNum">    3079 </span>            : {
<span class="lineNum">    3080 </span>            :   /// Read object from file
<span class="lineNum">    3081 </span>            :   /// Handle properly if the histogram arrays were stored separately
<span class="lineNum">    3082 </span>            :   /// call Analyse to make sure to have the calibration relevant information in the object
<span class="lineNum">    3083 </span>            : 
<span class="lineNum">    3084 </span><span class="lineNoCov">          0 :   TFile f(filename);</span>
<span class="lineNum">    3085 </span><span class="lineNoCov">          0 :   if (!f.IsOpen() || f.IsZombie() ) return 0x0;</span>
<span class="lineNum">    3086 </span><span class="lineNoCov">          0 :   TList *l=f.GetListOfKeys();</span>
<span class="lineNum">    3087 </span><span class="lineNoCov">          0 :   TIter next(l);</span>
<span class="lineNum">    3088 </span>            :   TKey *key=0x0;
<span class="lineNum">    3089 </span>            :   TObject *o=0x0;
<span class="lineNum">    3090 </span>            : 
<span class="lineNum">    3091 </span>            :   AliTPCCalibCE *ce=0x0;
<span class="lineNum">    3092 </span>            :   TObjArray *histoQArray=0x0;
<span class="lineNum">    3093 </span>            :   TObjArray *histoT0Array=0x0;
<span class="lineNum">    3094 </span>            :   TObjArray *histoRMSArray=0x0;
<span class="lineNum">    3095 </span>            :   TObjArray *arrHnDrift=0x0;
<span class="lineNum">    3096 </span>            : 
<span class="lineNum">    3097 </span><span class="lineNoCov">          0 :   while ( (key=(TKey*)next()) ){</span>
<span class="lineNum">    3098 </span><span class="lineNoCov">          0 :     o=key-&gt;ReadObj();</span>
<span class="lineNum">    3099 </span><span class="lineNoCov">          0 :     if ( o-&gt;IsA()==AliTPCCalibCE::Class() ){</span>
<span class="lineNum">    3100 </span><span class="lineNoCov">          0 :       ce=(AliTPCCalibCE*)o;</span>
<span class="lineNum">    3101 </span><span class="lineNoCov">          0 :     } else if ( o-&gt;IsA()==TObjArray::Class() ){</span>
<span class="lineNum">    3102 </span><span class="lineNoCov">          0 :       TString name=key-&gt;GetName();</span>
<span class="lineNum">    3103 </span><span class="lineNoCov">          0 :       if ( name==&quot;histoQArray&quot;) histoQArray=(TObjArray*)o;</span>
<span class="lineNum">    3104 </span><span class="lineNoCov">          0 :       if ( name==&quot;histoT0Array&quot;) histoT0Array=(TObjArray*)o;</span>
<span class="lineNum">    3105 </span><span class="lineNoCov">          0 :       if ( name==&quot;histoRMSArray&quot;) histoRMSArray=(TObjArray*)o;</span>
<span class="lineNum">    3106 </span><span class="lineNoCov">          0 :       if ( name==&quot;arrHnDrift&quot;) arrHnDrift=(TObjArray*)o;</span>
<span class="lineNum">    3107 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    3108 </span>            :   }
<span class="lineNum">    3109 </span>            : 
<span class="lineNum">    3110 </span><span class="lineNoCov">          0 :   if (ce){</span>
<span class="lineNum">    3111 </span>            :   //move histograms back to the object
<span class="lineNum">    3112 </span>            :     TH1* hist=0x0;
<span class="lineNum">    3113 </span><span class="lineNoCov">          0 :     if (histoQArray){</span>
<span class="lineNum">    3114 </span><span class="lineNoCov">          0 :       for (Int_t i=0; i&lt;72; ++i){</span>
<span class="lineNum">    3115 </span><span class="lineNoCov">          0 :         hist=(TH1*)histoQArray-&gt;UncheckedAt(i);</span>
<span class="lineNum">    3116 </span><span class="lineNoCov">          0 :         if (hist) hist-&gt;SetDirectory(0x0);</span>
<span class="lineNum">    3117 </span><span class="lineNoCov">          0 :         ce-&gt;fHistoQArray.AddAt(hist,i);</span>
<span class="lineNum">    3118 </span>            :       }
<span class="lineNum">    3119 </span><span class="lineNoCov">          0 :       ce-&gt;fHistoQArray.SetOwner(kTRUE);</span>
<span class="lineNum">    3120 </span>            :     }
<span class="lineNum">    3121 </span>            : 
<span class="lineNum">    3122 </span><span class="lineNoCov">          0 :     if (histoT0Array) {</span>
<span class="lineNum">    3123 </span><span class="lineNoCov">          0 :       for (Int_t i=0; i&lt;72; ++i){</span>
<span class="lineNum">    3124 </span><span class="lineNoCov">          0 :         hist=(TH1*)histoT0Array-&gt;UncheckedAt(i);</span>
<span class="lineNum">    3125 </span><span class="lineNoCov">          0 :         if (hist) hist-&gt;SetDirectory(0x0);</span>
<span class="lineNum">    3126 </span><span class="lineNoCov">          0 :         ce-&gt;fHistoT0Array.AddAt(hist,i);</span>
<span class="lineNum">    3127 </span>            :       }
<span class="lineNum">    3128 </span><span class="lineNoCov">          0 :       ce-&gt;fHistoT0Array.SetOwner(kTRUE);</span>
<span class="lineNum">    3129 </span>            :     }
<span class="lineNum">    3130 </span>            : 
<span class="lineNum">    3131 </span><span class="lineNoCov">          0 :     if (histoRMSArray){</span>
<span class="lineNum">    3132 </span><span class="lineNoCov">          0 :       for (Int_t i=0; i&lt;72; ++i){</span>
<span class="lineNum">    3133 </span><span class="lineNoCov">          0 :         hist=(TH1*)histoRMSArray-&gt;UncheckedAt(i);</span>
<span class="lineNum">    3134 </span><span class="lineNoCov">          0 :         if (hist) hist-&gt;SetDirectory(0x0);</span>
<span class="lineNum">    3135 </span><span class="lineNoCov">          0 :         ce-&gt;fHistoRMSArray.AddAt(hist,i);</span>
<span class="lineNum">    3136 </span>            :       }
<span class="lineNum">    3137 </span><span class="lineNoCov">          0 :       ce-&gt;fHistoRMSArray.SetOwner(kTRUE);</span>
<span class="lineNum">    3138 </span>            :     }
<span class="lineNum">    3139 </span>            : 
<span class="lineNum">    3140 </span><span class="lineNoCov">          0 :     if (arrHnDrift){</span>
<span class="lineNum">    3141 </span><span class="lineNoCov">          0 :       for (Int_t i=0; i&lt;arrHnDrift-&gt;GetEntries(); ++i){</span>
<span class="lineNum">    3142 </span><span class="lineNoCov">          0 :         THnSparseI *hSparse=(THnSparseI*)arrHnDrift-&gt;UncheckedAt(i);</span>
<span class="lineNum">    3143 </span><span class="lineNoCov">          0 :         ce-&gt;fArrHnDrift.AddAt(hSparse,i);</span>
<span class="lineNum">    3144 </span>            :       }
<span class="lineNum">    3145 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    3146 </span>            : 
<span class="lineNum">    3147 </span><span class="lineNoCov">          0 :     ce-&gt;Analyse();</span>
<span class="lineNum">    3148 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3149 </span><span class="lineNoCov">          0 :   f.Close();</span>
<span class="lineNum">    3150 </span>            : 
<span class="lineNum">    3151 </span>            :   return ce;
<span class="lineNum">    3152 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
