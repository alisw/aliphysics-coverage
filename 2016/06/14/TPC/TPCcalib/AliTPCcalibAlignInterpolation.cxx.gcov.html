<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - TPC/TPCcalib/AliTPCcalibAlignInterpolation.cxx</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">TPC/TPCcalib</a> - AliTPCcalibAlignInterpolation.cxx<span style="font-size: 80%;"> (source / <a href="AliTPCcalibAlignInterpolation.cxx.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">2132</td>
            <td class="headerCovTableEntryLo">0.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">34</td>
            <td class="headerCovTableEntryLo">2.9 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**************************************************************************</a>
<span class="lineNum">       2 </span>            :  * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
<span class="lineNum">       3 </span>            :  *                                                                        *
<span class="lineNum">       4 </span>            :  * Author: The ALICE Off-line Project.                                    *
<span class="lineNum">       5 </span>            :  * Contributors are mentioned in the code where appropriate.              *
<span class="lineNum">       6 </span>            :  *                                                                        *
<span class="lineNum">       7 </span>            :  * Permission to use, copy, modify and distribute this software and its   *
<span class="lineNum">       8 </span>            :  * documentation strictly for non-commercial purposes is hereby granted   *
<span class="lineNum">       9 </span>            :  * without fee, provided that the above copyright notice appears in all   *
<span class="lineNum">      10 </span>            :  * copies and that both the copyright notice and this permission notice   *
<span class="lineNum">      11 </span>            :  * appear in the supporting documentation. The authors make no claims     *
<span class="lineNum">      12 </span>            :  * about the suitability of this software for any purpose. It is          *
<span class="lineNum">      13 </span>            :  * provided &quot;as is&quot; without express or implied warranty.                  *
<span class="lineNum">      14 </span>            :  **************************************************************************/
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : /// \class AliTPCcalibAlignInterpolation
<span class="lineNum">      18 </span>            : /// Class to produce TPC time dependent space point distortion maps using the ITS, TRD and TOF 
<span class="lineNum">      19 </span>            : /// as a reference detector
<span class="lineNum">      20 </span>            : ///  
<span class="lineNum">      21 </span>            : /// Related to task https://alice.its.cern.ch/jira/browse/ATO-108
<span class="lineNum">      22 </span>            : ///  - code created addopting compiled macro for open gating grid analysis form TPC git:
<span class="lineNum">      23 </span>            : ///    $NOTES/SpaceChargeDistortion/code/spaceChargeDistortions.C
<span class="lineNum">      24 </span>            : /// 
<span class="lineNum">      25 </span>            : /// \author Marian Ivanov,  marian.ivanov@cern.ch
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : #include &quot;TROOT.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;TMath.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;TFile.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;TTree.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;AliESDEvent.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;AliESDfriend.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;TTreeStream.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;AliESDfriendTrack.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;AliExternalTrackParam.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;AliTrackPointArray.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;TChain.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;AliXRDPROOFtoolkit.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;AliTrackerBase.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;AliGeomManager.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;TVectorF.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;TVectorD.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;TStopwatch.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;TProfile.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;TGraphErrors.h&quot;
<span class="lineNum">      46 </span>            : //#include &quot;THnBase.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;THn.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;AliSysInfo.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;TMatrixD.h&quot;
<span class="lineNum">      50 </span>            :  #include &quot;TF1.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;TDatabasePDG.h&quot;
<span class="lineNum">      52 </span>            : #include &quot;TTreeStream.h&quot;
<span class="lineNum">      53 </span>            : #include &quot;TStatToolkit.h&quot;
<span class="lineNum">      54 </span>            : #include &quot;AliTPCclusterMI.h&quot;
<span class="lineNum">      55 </span>            : #include &quot;AliTPCseed.h&quot;
<span class="lineNum">      56 </span>            : #include &quot;AliTPCcalibDB.h&quot;
<span class="lineNum">      57 </span>            : #include &quot;AliTPCTransform.h&quot;
<span class="lineNum">      58 </span>            : #include &quot;AliTPCRecoParam.h&quot;
<span class="lineNum">      59 </span>            : #include &quot;AliTPCreco.h&quot;
<span class="lineNum">      60 </span>            : #include &quot;AliTPCcalibAlignInterpolation.h&quot;
<span class="lineNum">      61 </span>            : #include &quot;AliPID.h&quot;
<span class="lineNum">      62 </span>            : #include &quot;AliCDBManager.h&quot;
<span class="lineNum">      63 </span>            : #include &quot;AliMagF.h&quot;
<span class="lineNum">      64 </span>            : #include &quot;AliGRPManager.h&quot;
<span class="lineNum">      65 </span>            : #include &lt;TGeoGlobalMagField.h&gt;
<span class="lineNum">      66 </span>            : #include &quot;TSystem.h&quot;
<span class="lineNum">      67 </span>            : #include &quot;TGrid.h&quot;
<span class="lineNum">      68 </span>            : #include &quot;TCut.h&quot;
<span class="lineNum">      69 </span>            : #include &quot;AliNDLocalRegression.h&quot;
<span class="lineNum">      70 </span>            : #include &quot;AliMathBase.h&quot;
<span class="lineNum">      71 </span>            : #include &quot;TStyle.h&quot;
<span class="lineNum">      72 </span>            : #include &quot;TCanvas.h&quot;
<span class="lineNum">      73 </span>            : #include &quot;AliCDBStorage.h&quot;
<span class="lineNum">      74 </span>            : #include &quot;AliCDBEntry.h&quot;
<span class="lineNum">      75 </span>            : #include &quot;AliCDBId.h&quot;
<span class="lineNum">      76 </span>            : #include &quot;AliTPCParam.h&quot;
<span class="lineNum">      77 </span>            : #include &quot;AliTPCClusterParam.h&quot;
<span class="lineNum">      78 </span>            : #include &quot;AliDAQ.h&quot;
<span class="lineNum">      79 </span>            : #include &quot;AliGRPObject.h&quot;
<span class="lineNum">      80 </span>            : 
<a name="81"><span class="lineNum">      81 </span>            : const Int_t AliTPCcalibAlignInterpolation_kMaxPoints=500;</a>
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span><span class="lineCov">          6 : ClassImp(AliTPCcalibAlignInterpolation)</span>
<a name="84"><span class="lineNum">      84 </span>            : </a>
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span>            : AliTPCcalibAlignInterpolation::AliTPCcalibAlignInterpolation() : 
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :   AliTPCcalibBase(),</span>
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :   fOnTheFlyFill(0),  // flag - on the fly filling of histograms</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :   fHisITSDRPhi(0),      // TPC-ITS residual histograms</span>
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :   fHisITSTRDDRPhi(0),   // TPC-ITS+TRD residual histograms</span>
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :   fHisITSTOFDRPhi(0),   // TPC-ITS_TOF residual histograms</span>
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :   fHisITSDZ(0),      // TPC-ITS residual histograms</span>
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :   fHisITSTRDDZ(0),   // TPC-ITS+TRD residual histograms</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :   fHisITSTOFDZ(0),   // TPC-ITS_TOF residual histograms</span>
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :   fRhoTPC(0.9e-3),</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :   fX0TPC(28.94),</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :   fStreamer(0),         // calibration streamer </span>
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :   fStreamLevelTrack(0),      // stream level - In mode 0 only basic information needed for calibration  stored (see EStream</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :   fSyswatchStep(100),      // dump system resource information after  fSyswatchStep tracks</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :   fTrackCounter(0)           // processed track counter</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 : {</span>
<a name="102"><span class="lineNum">     102 </span>            :   </a>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 : }   </span>
<span class="lineNum">     104 </span>            : AliTPCcalibAlignInterpolation::AliTPCcalibAlignInterpolation(const Text_t *name, const Text_t *title, Bool_t onTheFlyFill):
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :   AliTPCcalibBase(),</span>
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :   fOnTheFlyFill(onTheFlyFill),  // flag - on the fly filling of histograms</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :   fHisITSDRPhi(0),      // TPC-ITS residual histograms</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :   fHisITSTRDDRPhi(0),   // TPC-ITS+TRD residual histograms</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :   fHisITSTOFDRPhi(0),   // TPC-ITS_TOF residual histograms  </span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :   fHisITSDZ(0),      // TPC-ITS residual histograms</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :   fHisITSTRDDZ(0),   // TPC-ITS+TRD residual histograms</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :   fHisITSTOFDZ(0),   // TPC-ITS_TOF residual histograms</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :   fRhoTPC(0.9e-3),</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :   fX0TPC(28.94),</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :   fStreamer(0),         // calibration streamer </span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :   fStreamLevelTrack(0),      // stream level - In mode 0 only basic information needed for calibration  stored (see EStream</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :   fSyswatchStep(100),      // dump system resource information after  fSyswatchStep tracks  </span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :   fTrackCounter(0)           // processed track counter</span>
<span class="lineNum">     119 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">     120 </span>            :   // create output histograms
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :   SetName(name);</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :   SetTitle(title);</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :   if (onTheFlyFill) CreateResidualHistosInterpolation();</span>
<a name="124"><span class="lineNum">     124 </span><span class="lineNoCov">          0 : }   </span></a>
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span><span class="lineNoCov">          0 : AliTPCcalibAlignInterpolation::~AliTPCcalibAlignInterpolation(){</span>
<span class="lineNum">     127 </span>            :   //
<span class="lineNum">     128 </span>            :   //
<span class="lineNum">     129 </span>            :   //
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :   if (fStreamer){</span>
<span class="lineNum">     131 </span>            :     // fStreamer-&gt;GetFile()-&gt;Close();
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :     fStreamer-&gt;GetFile()-&gt;cd();</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :     if (fHisITSDRPhi) fHisITSDRPhi-&gt;Write();</span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :     if (fHisITSTRDDRPhi) fHisITSTRDDRPhi-&gt;Write();</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :     if (fHisITSTOFDRPhi) fHisITSTOFDRPhi-&gt;Write();</span>
<span class="lineNum">     136 </span>            :   }
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :   delete fStreamer;</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :   fStreamer=0;</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :   delete fHisITSDRPhi;</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :   delete fHisITSTRDDRPhi;</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :   delete fHisITSTOFDRPhi;</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 : }</span>
<a name="143"><span class="lineNum">     143 </span>            : </a>
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            : void AliTPCcalibAlignInterpolation::Terminate(){
<span class="lineNum">     146 </span>            :   //
<span class="lineNum">     147 </span>            :   // Terminate function
<span class="lineNum">     148 </span>            :   // call base terminate + Eval of fitters
<span class="lineNum">     149 </span>            :   //
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :   Info(&quot;AliTPCcalibAlignInterpolation&quot;,&quot;Terminate&quot;);</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :   if (fStreamer){</span>
<span class="lineNum">     152 </span>            :     // fStreamer-&gt;GetFile()-&gt;Close();
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :     fStreamer-&gt;GetFile()-&gt;cd();</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :     if (fHisITSDRPhi) fHisITSDRPhi-&gt;Write();</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :     if (fHisITSTRDDRPhi) fHisITSTRDDRPhi-&gt;Write();</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :     if (fHisITSTOFDRPhi) fHisITSTOFDRPhi-&gt;Write();</span>
<span class="lineNum">     157 </span>            :   }
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :   delete fStreamer;</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :   fStreamer=0;</span>
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :   AliTPCcalibBase::Terminate();</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 : }</span>
<a name="163"><span class="lineNum">     163 </span>            : </a>
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span>            : Bool_t  AliTPCcalibAlignInterpolation::RefitITStrack(AliESDfriendTrack *friendTrack, Double_t mass, AliExternalTrackParam &amp;trackITS, 
<span class="lineNum">     166 </span>            :                                                      Double_t &amp;chi2, Double_t &amp;npoints, int* sortInd){
<span class="lineNum">     167 </span>            :   //
<span class="lineNum">     168 </span>            :   // Makes a refit of the ITS track
<span class="lineNum">     169 </span>            :   // Input: AliESDfriendTrack, particle mass, outer ITS TrackParam 
<span class="lineNum">     170 </span>            :   // Output: AliExternalTrackParam of the ITS track refit at the last layer of ITS
<span class="lineNum">     171 </span>            :   //
<span class="lineNum">     172 </span>            :   const Double_t sigma2[6][3] = {
<span class="lineNum">     173 </span>            :     {0.002*0.002, 0,  0.013*0.013},
<span class="lineNum">     174 </span>            :     {0.002*0.002, 0,  0.013*0.013},
<span class="lineNum">     175 </span>            :     {0.050*0.050, 0,  0.050*0.050},
<span class="lineNum">     176 </span>            :     {0.050*0.050, 0,  0.050*0.050},
<span class="lineNum">     177 </span>            :     {0.003*0.003, 0,  0.100*0.100},
<span class="lineNum">     178 </span>            :     {0.003*0.003, 0,  0.100*0.100},
<span class="lineNum">     179 </span>            :   };    // ITS intrincsic resolution in (y,z)  - error from the points can be used SD layer 2-3 sighnificantly bigger error
<span class="lineNum">     180 </span>            :   // !!!! We should set ITS error parameterization form outside !!!!
<span class="lineNum">     181 </span>            :   const Double_t kMaxRadius=50;
<span class="lineNum">     182 </span>            :   static Int_t sortedIndexLoc[AliTPCcalibAlignInterpolation_kMaxPoints]={0};
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :   chi2=0;</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :   npoints=0; </span>
<span class="lineNum">     185 </span>            :   //
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :   if (friendTrack-&gt;GetITSOut()==NULL) return kFALSE;  </span>
<span class="lineNum">     187 </span>            :   //
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :   trackITS = *((AliExternalTrackParam*)friendTrack-&gt;GetITSOut());</span>
<span class="lineNum">     189 </span>            :   // Reset track to the vertex
<span class="lineNum">     190 </span>            :   //if (!AliTrackerBase::PropagateTrackToBxByBz(&amp;trackITS,0,mass,1,kFALSE)) return kFALSE;
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :   if (!AliTrackerBase::PropagateTrackParamOnlyTo(&amp;trackITS,0.,5,kFALSE)) return kFALSE;</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :   trackITS.ResetCovariance(1000.);</span>
<span class="lineNum">     193 </span>            :   
<span class="lineNum">     194 </span>            :   // Get space points
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :   AliTrackPointArray *pointarray = (AliTrackPointArray*)friendTrack-&gt;GetTrackPointArray();</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :   if (!pointarray){</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :     printf(&quot;Space points are not stored in the friendTrack!\n&quot;);</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">     199 </span>            :   };
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :   Int_t nPoints = pointarray-&gt;GetNPoints();  // # space points of all available detectors                                            </span>
<span class="lineNum">     201 </span>            :                                              // Sort space points first
<span class="lineNum">     202 </span>            :   int *sortedIndex = sortInd;
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :   if (!sortedIndex) {</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :     SortPointArray(pointarray, sortedIndexLoc);  // space point indices sorted by radius in increasing order</span>
<span class="lineNum">     205 </span>            :     sortedIndex = sortedIndexLoc;
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     207 </span>            :   //
<span class="lineNum">     208 </span>            :   // Propagate track through ITS space points
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :   AliTrackPoint spacepoint;</span>
<span class="lineNum">     210 </span>            :   Int_t volId=0,modId=0,layerId=0;
<span class="lineNum">     211 </span>            :   
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :   for (Int_t iPoint=0;iPoint&lt;nPoints;iPoint++){</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :     pointarray-&gt;GetPoint(spacepoint,sortedIndex[iPoint]);</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :     int lr = AliGeomManager::VolUIDToLayer(spacepoint.GetVolumeID())-1;</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :     if (lr&lt;0||lr&gt;=6) continue;</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :     Double_t xyz[3] = {(Double_t)spacepoint.GetX(),(Double_t)spacepoint.GetY(),(Double_t)spacepoint.GetZ()};</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :     Double_t alpha = TMath::ATan2(xyz[1],xyz[0]);</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :     trackITS.Global2LocalPosition(xyz,alpha);</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :     if (xyz[0]&gt;kMaxRadius) break;  // use only ITS points - maybe we should indexes of elements</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :     if (!trackITS.Rotate(alpha)) return kFALSE;</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :     if (!AliTrackerBase::PropagateTrackToBxByBz(&amp;trackITS,xyz[0],mass,1,kFALSE)) return kFALSE;</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :     Double_t pos[2] = {xyz[1], xyz[2]};</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :     const Double_t* cov = sigma2[lr];</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :     volId = spacepoint.GetVolumeID();</span>
<span class="lineNum">     225 </span>            :     //    layerId = AliGeomManager::VolUIDToLayer(volId,modId);
<span class="lineNum">     226 </span>            :     //     if (layerId ==AliGeomManager::kSDD1 || layerId ==AliGeomManager::kSDD2) cov[0]*=16.; cov[2]*=16.;}      
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :     double chi2cl = trackITS.GetPredictedChi2(pos,cov);</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :     chi2 += chi2cl;</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :     npoints++;</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     if (!trackITS.Update(pos,cov)) return kFALSE;</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :   return npoints&gt;0;</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 : }</span>
<a name="234"><span class="lineNum">     234 </span>            : </a>
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            : Bool_t AliTPCcalibAlignInterpolation::RefitTRDtrack(AliESDfriendTrack *friendTrack, Double_t mass, AliExternalTrackParam &amp;trackTRD, 
<span class="lineNum">     237 </span>            :                                                     Double_t &amp;chi2, Double_t &amp;npoints, Int_t* sortInd){
<span class="lineNum">     238 </span>            :   //
<span class="lineNum">     239 </span>            :   // Makes a refit of the TRD track using TOF and TRD points
<span class="lineNum">     240 </span>            :   // Input: AliESDfriendTrack, particle mass, inner TRD TrackParam 
<span class="lineNum">     241 </span>            :   // Output: AliExternalTrackParam of the TRD track refit - in the first layer of TRD
<span class="lineNum">     242 </span>            :   // Here we forgot about the tiliting pads of TRD - we assume delta Z and delta y are uncorelated
<span class="lineNum">     243 </span>            :   //      given approximation is in average tru - in case avearaging of significantly bigger than pad length
<span class="lineNum">     244 </span>            :   //  
<span class="lineNum">     245 </span>            :   const Double_t sigmaTRD2[2] = {0.04*0.04, 5*5};
<span class="lineNum">     246 </span>            :   const Double_t sigmaTOF2[2] = {1, 1};
<span class="lineNum">     247 </span>            :   static Int_t sortedIndexLoc[AliTPCcalibAlignInterpolation_kMaxPoints]={0};
<span class="lineNum">     248 </span>            :   const Double_t kMaxRadius=390;
<span class="lineNum">     249 </span>            :   const Double_t kMinRadius=280;
<span class="lineNum">     250 </span>            :   //
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :   chi2=0; </span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :   npoints=0;  </span>
<span class="lineNum">     253 </span>            :   //
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :   if (friendTrack-&gt;GetTRDIn() == NULL) return kFALSE;</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :   trackTRD = *((AliExternalTrackParam*)friendTrack-&gt;GetTRDIn());</span>
<span class="lineNum">     256 </span>            :   
<span class="lineNum">     257 </span>            :   
<span class="lineNum">     258 </span>            :   // Reset track outside TRD
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :   if (!AliTrackerBase::PropagateTrackParamOnlyTo(&amp;trackTRD,kMaxRadius,5,kFALSE)) return kFALSE;</span>
<span class="lineNum">     260 </span>            :   //if (!AliTrackerBase::PropagateTrackToBxByBz(&amp;trackTRD,kMaxRadius,mass,1,kFALSE)) return kFALSE;
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :   trackTRD.ResetCovariance(1000.);</span>
<span class="lineNum">     262 </span>            :       
<span class="lineNum">     263 </span>            :   // Get space points
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :   AliTrackPointArray *pointarray = (AliTrackPointArray*)friendTrack-&gt;GetTrackPointArray();</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :   if (!pointarray){</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :     printf(&quot;Space points are not stored in the friendTrack!\n&quot;);</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">     268 </span>            :   };
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :   Int_t nPoints = pointarray-&gt;GetNPoints();  // # space points of all available detectors</span>
<span class="lineNum">     270 </span>            :                                              // Sort space points first
<span class="lineNum">     271 </span>            :   int *sortedIndex = sortInd;
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :   if (!sortedIndex) {</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :     SortPointArray(pointarray, sortedIndexLoc);  // space point indices sorted by radius in increasing order</span>
<span class="lineNum">     274 </span>            :     sortedIndex = sortedIndexLoc;
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     276 </span>            :   
<span class="lineNum">     277 </span>            :   // Propagate track through TRD space points
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :   AliTrackPoint spacepoint;</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :   Int_t volId,modId,layerId, npfit=0;</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :   for (Int_t iPoint=nPoints;iPoint--;) {</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :     pointarray-&gt;GetPoint(spacepoint,sortedIndex[iPoint]);</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :     volId = spacepoint.GetVolumeID();</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :     layerId = AliGeomManager::VolUIDToLayer(volId,modId);</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :     if (layerId &lt;AliGeomManager::kTRD1) break;</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :     if (layerId&gt;AliGeomManager::kTOF) continue;</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :     Double_t xyz[3] = {(Double_t)spacepoint.GetX(),(Double_t)spacepoint.GetY(),(Double_t)spacepoint.GetZ()};</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :     Double_t alpha = TMath::ATan2(xyz[1],xyz[0]);</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :     trackTRD.Global2LocalPosition(xyz,alpha);</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :     if (xyz[0]&lt;kMinRadius) break;  // use only TRD points</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :     if (!trackTRD.Rotate(alpha)) return kFALSE;</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :     if (!AliTrackerBase::PropagateTrackToBxByBz(&amp;trackTRD,xyz[0],mass,1,kFALSE)) return kFALSE;</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :     Double_t pos[2] = {xyz[1], xyz[2]};</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :     Double_t cov[3] = {sigmaTRD2[0],0,sigmaTRD2[1]};</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :     if (layerId==AliGeomManager::kTOF) {cov[0]=sigmaTOF2[0]; cov[2]=sigmaTOF2[1];};</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :     double chi2cl = trackTRD.GetPredictedChi2(pos,cov);</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :     chi2 += chi2cl;</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :     if (!trackTRD.Update(pos,cov)) return kFALSE;</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :     npfit++;</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :   npoints = npfit;</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :   return npoints&gt;0;</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 : }</span>
<a name="303"><span class="lineNum">     303 </span>            : </a>
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span>            : Bool_t  AliTPCcalibAlignInterpolation::RefitTOFtrack(AliESDfriendTrack *friendTrack, Double_t mass, AliExternalTrackParam &amp;trackTOF, 
<span class="lineNum">     306 </span>            :                                                      Double_t &amp;chi2, Double_t &amp;npoints, Int_t* sortInd){
<span class="lineNum">     307 </span>            :   //
<span class="lineNum">     308 </span>            :   // Makes a refit of the TRD track
<span class="lineNum">     309 </span>            :   // Input: AliESDfriendTrack, particle mass, OUTER ITS track - propagated to the TOF point and updated by TOF point 
<span class="lineNum">     310 </span>            :   // Output: AliExternalTrackParam of the TOF track refit - at the TOF point
<span class="lineNum">     311 </span>            :   Double_t sigma2[2] = {1., 1.};      // should be parameterized
<span class="lineNum">     312 </span>            :   const Double_t kTOFRadius = 370;
<span class="lineNum">     313 </span>            :   //
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :   chi2=0; </span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :   npoints=0;</span>
<span class="lineNum">     316 </span>            :   //
<span class="lineNum">     317 </span>            :   static Int_t sortedIndexLoc[AliTPCcalibAlignInterpolation_kMaxPoints]={0};
<span class="lineNum">     318 </span>            :   //  if (!AliTrackerBase::PropagateTrackParamOnlyTo(&amp;trackTOF,kTOFRadius,15,kTRUE)) return kFALSE;
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :   if (!AliTrackerBase::PropagateTrackToBxByBz(&amp;trackTOF,kTOFRadius,mass,10,kTRUE)) return kFALSE;</span>
<span class="lineNum">     320 </span>            :   // RS why don't we reset the cov. matrix here?
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :   Int_t volId,modId,layerId;</span>
<span class="lineNum">     322 </span>            :       
<span class="lineNum">     323 </span>            :   // Get space points
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :   AliTrackPointArray *pointarray = (AliTrackPointArray*)friendTrack-&gt;GetTrackPointArray();</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :   if (!pointarray){</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :     printf(&quot;Space points are not stored in the friendTrack!\n&quot;);</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">     328 </span>            :   };
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :   Int_t nPoints = pointarray-&gt;GetNPoints();  // # space points of all available detectors</span>
<span class="lineNum">     330 </span>            :                                              // Sort space points first
<span class="lineNum">     331 </span>            :   int *sortedIndex = sortInd;
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :   if (!sortedIndex) {</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :     SortPointArray(pointarray, sortedIndexLoc);  // space point indices sorted by radius in increasing order</span>
<span class="lineNum">     334 </span>            :     sortedIndex = sortedIndexLoc;
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            :   // Propagate track through TRD space points
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :   AliTrackPoint spacepoint;</span>
<span class="lineNum">     339 </span>            :   int npfit = 0;
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :   for (Int_t iPoint=nPoints;iPoint--;){  </span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :     pointarray-&gt;GetPoint(spacepoint,sortedIndex[iPoint]);</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :     volId = spacepoint.GetVolumeID();</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :     layerId = AliGeomManager::VolUIDToLayer(volId,modId);</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :     if (layerId !=AliGeomManager::kTOF) continue;</span>
<span class="lineNum">     345 </span>            :     
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :     Double_t xyz[3] = {(Double_t)spacepoint.GetX(),(Double_t)spacepoint.GetY(),(Double_t)spacepoint.GetZ()};</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :     Double_t alpha = TMath::ATan2(xyz[1],xyz[0]);</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :     trackTOF.Global2LocalPosition(xyz,alpha);</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :     if (!trackTOF.Rotate(alpha)) return kFALSE;</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :     if (!AliTrackerBase::PropagateTrackToBxByBz(&amp;trackTOF,xyz[0],mass,1,kFALSE)) return kFALSE;</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :     Double_t pos[2] = {xyz[1], xyz[2]};</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :     Double_t cov[3] = {sigma2[0],0,sigma2[1]};</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :     double chi2cl = trackTOF.GetPredictedChi2(pos,cov);</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :     chi2 += chi2cl;</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :     if (!trackTOF.Update(pos,cov)) return kFALSE;</span>
<span class="lineNum">     356 </span>            :     npfit++;
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :     break; // there is just 1 TOF poitn</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :   npoints = npfit;</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :   return npoints&gt;0;</span>
<a name="361"><span class="lineNum">     361 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span>            : Bool_t  AliTPCcalibAlignInterpolation::SortPointArray(AliTrackPointArray *pointarray, Int_t * sortedIndex){
<span class="lineNum">     364 </span>            :   //
<span class="lineNum">     365 </span>            :   // Fill array of indexes to the pointArray (array sorted in increasing order)
<span class="lineNum">     366 </span>            :   //
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :   if (sortedIndex==NULL) return kFALSE;</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :   Int_t nPoints = pointarray-&gt;GetNPoints();</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :   if (!nPoints) return kFALSE;</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :   Double_t rp[nPoints];</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :   const float* x = pointarray-&gt;GetX();</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :   const float* y = pointarray-&gt;GetY();</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :   for (Int_t iPoint=nPoints;iPoint--;) rp[iPoint] = x[iPoint]*x[iPoint]+y[iPoint]*y[iPoint];</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :   TMath::Sort(nPoints,rp,sortedIndex,kFALSE);</span>
<span class="lineNum">     375 </span>            :   return kTRUE;
<span class="lineNum">     376 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     377 </span>            : 
<a name="378"><span class="lineNum">     378 </span>            : </a>
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span>            : void AliTPCcalibAlignInterpolation::ProcessStandalone(const char * inputList){
<span class="lineNum">     381 </span>            :   //
<span class="lineNum">     382 </span>            :   // Process ESD information standalone without full colibration train
<span class="lineNum">     383 </span>            :   // Input:
<span class="lineNum">     384 </span>            :   //   inputList - list of the input ESD files
<span class="lineNum">     385 </span>            :   //
<span class="lineNum">     386 </span>            :   // code from test macro to be set here
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     389 </span>            : 
<a name="390"><span class="lineNum">     390 </span>            : </a>
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span>            : void  AliTPCcalibAlignInterpolation::Process(AliESDEvent *esdEvent){
<span class="lineNum">     393 </span>            :   //
<span class="lineNum">     394 </span>            :   // Create distortion maps out of residual histograms of ITS-TRD interpolation and TPC space points
<span class="lineNum">     395 </span>            :   // JIRA ticket: https://alice.its.cern.ch/jira/browse/ATO-108
<span class="lineNum">     396 </span>            :   //
<span class="lineNum">     397 </span>            :   const Double_t kMaxChi2=10;         // max track/track chi2 
<span class="lineNum">     398 </span>            :   const Double_t kMaxAlignTolerance=0.1;   // max track/track chi2 
<span class="lineNum">     399 </span>            :   const Double_t kMaxSNP = 0.8; // max snp tolerated
<span class="lineNum">     400 </span>            :   //
<span class="lineNum">     401 </span>            :   static Bool_t firstCall = kTRUE;
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :   if (firstCall) {</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :     firstCall = kFALSE;</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :     ExtractTPCGasData();</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     406 </span>            :   //
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :   AliESDfriend *esdFriend=static_cast&lt;AliESDfriend*&gt;(esdEvent-&gt;FindListObject(&quot;AliESDfriend&quot;));</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :   if (!esdFriend) return;</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :   if (esdFriend-&gt;TestSkipBit()) return;</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :   Int_t nPrimTracks= (esdEvent-&gt;GetPrimaryVertex()!=NULL)? esdEvent-&gt;GetPrimaryVertex()-&gt;GetNContributors():0;</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :   Int_t nPrimTracksSPD= (esdEvent-&gt;GetPrimaryVertexSPD()!=NULL)? esdEvent-&gt;GetPrimaryVertexSPD()-&gt;GetNContributors():0;</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :   Int_t nTracks = esdEvent-&gt;GetNumberOfTracks();  // Get number of tracks in ESD</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :   Int_t nSPD=  esdEvent-&gt;GetMultiplicity()-&gt;GetNumberOfITSClusters(0,1);</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :   Int_t nSDD=  esdEvent-&gt;GetMultiplicity()-&gt;GetNumberOfITSClusters(2,3);</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :   Int_t nSSD=  esdEvent-&gt;GetMultiplicity()-&gt;GetNumberOfITSClusters(4,5);</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :   if (nTracks==0) return;</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :   if (!fStreamer) fStreamer = new TTreeSRedirector(&quot;ResidualHistos.root&quot;,&quot;recreate&quot;);</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :   AliTPCTransform *transform = AliTPCcalibDB::Instance()-&gt;GetTransform() ;</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :   TVectorF vecNClTPC(72);</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :   TVectorF vecNClTPCused(72);</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :   for (Int_t isec=0; isec&lt;72;isec++){</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :     vecNClTPC[isec]=esdFriend-&gt;GetNclustersTPC(isec);</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :     vecNClTPCused[isec]=esdFriend-&gt;GetNclustersTPCused(isec);</span>
<span class="lineNum">     424 </span>            :   }
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :   ULong64_t gid = esdEvent-&gt;GetHeader()-&gt;GetEventIdAsLong(); </span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :   Int_t timeStamp= esdEvent-&gt;GetTimeStamp();</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :   (*fStreamer)&lt;&lt;&quot;eventInfo&quot;&lt;&lt; // store event info - used to calculate per sector currents</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :     &quot;gid=&quot;&lt;&lt;gid&lt;&lt;</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :     &quot;timeStamp=&quot;&lt;&lt;timeStamp&lt;&lt;</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :     &quot;nSPD=&quot;&lt;&lt;nSPD&lt;&lt;</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :     &quot;nSDD=&quot;&lt;&lt;nSDD&lt;&lt;</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :     &quot;nSSD=&quot;&lt;&lt;nSSD&lt;&lt;</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :     &quot;nPrimTrack=&quot;&lt;&lt;nPrimTracks&lt;&lt;</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :     &quot;nPrimTrackSPD=&quot;&lt;&lt;nPrimTracksSPD&lt;&lt;</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :     &quot;nTracks=&quot;&lt;&lt;nTracks&lt;&lt;</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :     &quot;vecNClTPC.=&quot;&lt;&lt;&amp;vecNClTPC&lt;&lt;</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :     &quot;vecNClTPCused.=&quot;&lt;&lt;&amp;vecNClTPCused&lt;&lt;</span>
<span class="lineNum">     438 </span>            :     &quot;\n&quot;;
<span class="lineNum">     439 </span>            :   
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span>            :   //
<span class="lineNum">     442 </span>            :   const Int_t nPointsAlloc=AliTPCcalibAlignInterpolation_kMaxPoints; 
<span class="lineNum">     443 </span>            :   const Int_t kMaxLayer=kMaxRow;
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :   AliExternalTrackParam trackArrayITS[kMaxLayer];</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :   AliExternalTrackParam trackArrayTRD[kMaxLayer];</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :   AliExternalTrackParam trackArrayTOF[kMaxLayer];</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :   AliExternalTrackParam trackArrayITSTRD[kMaxLayer];</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :   AliExternalTrackParam trackArrayITSTOF[kMaxLayer];</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :   AliTPCclusterMI clusterArray[kMaxLayer];</span>
<span class="lineNum">     450 </span>            :   //
<span class="lineNum">     451 </span>            :   //MakeResidualHistosInterpolation();
<span class="lineNum">     452 </span>            :   //
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :   Int_t sortedIndex[AliTPCcalibAlignInterpolation_kMaxPoints];</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :   TVectorF deltaITS0(kMaxLayer), deltaITS1(kMaxLayer); </span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :   TVectorF deltaTRD0(kMaxLayer), deltaTRD1(kMaxLayer); </span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :   TVectorF deltaTOF0(kMaxLayer), deltaTOF1(kMaxLayer); </span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :   TVectorF vecR(kMaxLayer), vecPhi(kMaxLayer), vecZ(kMaxLayer), vecSec(kMaxLayer);</span>
<span class="lineNum">     458 </span>            :   static int evCnt=0;
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :   Bool_t backupUseComposedCorrection = transform-&gt;GetCurrentRecoParamNonConst()-&gt;GetUseComposedCorrection();</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :   transform-&gt;GetCurrentRecoParamNonConst()-&gt;SetUseComposedCorrection(kFALSE);</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :   Bool_t backupUseCorrectionMaps = transform-&gt;GetCurrentRecoParamNonConst()-&gt;GetUseCorrectionMap();</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :   transform-&gt;GetCurrentRecoParamNonConst()-&gt;SetUseCorrectionMap(kFALSE);</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :   Bool_t backupAccountDistortions = transform-&gt;GetCurrentRecoParamNonConst()-&gt;GetAccountDistortions();</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :   transform-&gt;GetCurrentRecoParamNonConst()-&gt;SetAccountDistortions(kFALSE);</span>
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :   for (Int_t iTrack=0;iTrack&lt;nTracks;iTrack++){ // Track loop</span>
<span class="lineNum">     467 </span>            :     // 0.) For each track in each event, get the AliESDfriendTrack
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :     AliESDtrack *esdTrack = esdEvent-&gt;GetTrack(iTrack);</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :     AliESDfriendTrack *friendTrack = (AliESDfriendTrack*)esdTrack-&gt;GetFriendTrack();</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :     if (!friendTrack) continue;      </span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :     if (esdTrack-&gt;GetITSNcls()&lt;4 || esdTrack-&gt;GetTPCNcls()&lt;15) continue;</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :     Double_t mass = esdTrack-&gt;GetMass();  // particle mass    </span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :     Double_t tofDiff=esdTrack-&gt;GetTOFExpTDiffSpec(AliPID::kPion);</span>
<span class="lineNum">     474 </span>            :     // Get TPC seed
<span class="lineNum">     475 </span>            :     TObject *calibObject=0;
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :     AliTPCseed *seed = (AliTPCseed*)friendTrack-&gt;GetTPCseed();</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :     if (!seed) continue;</span>
<span class="lineNum">     478 </span>            :     //
<span class="lineNum">     479 </span>            :     // 1.) Start with AliExternalTrackParam *ITSOut and *TRDIn 
<span class="lineNum">     480 </span>            :     //
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :     AliExternalTrackParam paramITS;</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :     Double_t itsChi2=0, itsNCl=0;</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :     AliExternalTrackParam paramTRD;</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :     Double_t trdChi2=0, trdNCl=0;</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :     AliExternalTrackParam paramTOF;</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :     Double_t tofChi2=0, tofNCl=0;            </span>
<span class="lineNum">     487 </span>            :     //
<span class="lineNum">     488 </span>            :     // prepare sorted points
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :     AliTrackPointArray *pointarray = (AliTrackPointArray*)friendTrack-&gt;GetTrackPointArray();</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :     if (!pointarray) continue;</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :     Int_t nPointsAll = pointarray-&gt;GetNPoints();  // # space points of all available detectors</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :     SortPointArray(pointarray, sortedIndex);  // space point indices sorted by radius in increasing order</span>
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span>            :     // 2.) ITS, TRD and ITS-TRD refits
<span class="lineNum">     495 </span>            :     //
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :     if (!RefitITStrack(friendTrack,mass,paramITS, itsChi2, itsNCl, sortedIndex)) continue;</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :     if (itsNCl&lt;4) continue; </span>
<span class="lineNum">     498 </span>            :     //
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :     RefitTRDtrack(friendTrack,mass,paramTRD, trdChi2, trdNCl, sortedIndex); </span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :     paramTOF=paramITS;</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :     RefitTOFtrack(friendTrack,mass,paramTOF, tofChi2, tofNCl, sortedIndex);</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :     if (fTrackCounter%fSyswatchStep==0) AliSysInfo::AddStamp(&quot;Refitting&quot;,fTrackCounter,1,0,0);</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :     if ((trdNCl+tofNCl+itsNCl)&lt;5) continue; // - use ITS only tracks also  -should it be option?</span>
<span class="lineNum">     504 </span>            :     //
<span class="lineNum">     505 </span>            :     // 3.) Propagate to TPC volume, histogram residuals to TPC clusters and dump all information to TTree
<span class="lineNum">     506 </span>            :     //
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :     AliTrackPoint spacepoint;  </span>
<span class="lineNum">     508 </span>            :     Int_t volId,modId,layerId;      
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :     fTrackCounter++; // increase total track number</span>
<span class="lineNum">     510 </span>            :     //
<span class="lineNum">     511 </span>            :     // 3.a) Make a local copy of clusters and apply transformation
<span class="lineNum">     512 </span>            :     //
<span class="lineNum">     513 </span>            :     //
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :     for (Int_t iPoint=kMaxLayer;iPoint--;){</span>
<span class="lineNum">     515 </span>            :       //
<span class="lineNum">     516 </span>            :       // reset track interpolation statuses
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :       trackArrayITS[iPoint].SetUniqueID(0);</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :       trackArrayTRD[iPoint].SetUniqueID(0);</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :       trackArrayITSTRD[iPoint].SetUniqueID(0);</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :       trackArrayTOF[iPoint].SetUniqueID(0);</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :       trackArrayITSTOF[iPoint].SetUniqueID(0);</span>
<span class="lineNum">     522 </span>            :       //
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :       const AliTPCclusterMI *cluster=seed-&gt;GetClusterPointer(iPoint);</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :       if (!cluster){</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :         clusterArray[iPoint].SetVolumeId(0);</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     527 </span>            :       }
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :       clusterArray[iPoint]=*cluster;</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :       Int_t i[1]={cluster-&gt;GetDetector()};</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :       Double_t x[3]={static_cast&lt;Double_t&gt;(cluster-&gt;GetRow()),cluster-&gt;GetPad(),cluster-&gt;GetTimeBin()};</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :       transform-&gt;Transform(x,i,0,1);</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :       clusterArray[iPoint].SetX(x[0]);</span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :       clusterArray[iPoint].SetY(x[1]);</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :       clusterArray[iPoint].SetZ(x[2]);</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     536 </span>            :     //
<span class="lineNum">     537 </span>            :     // 4.) Propagate  ITS tracks outward
<span class="lineNum">     538 </span>            :     // 
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :     Bool_t itsOK=kTRUE;</span>
<span class="lineNum">     540 </span>            :     int npUpdITS = 0;
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :     for (Int_t iPoint=0;iPoint&lt;kMaxLayer;iPoint++) {</span>
<span class="lineNum">     542 </span>            :       //trackArrayITS[iPoint].SetUniqueID(0);
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :       AliTPCclusterMI &amp;cluster=clusterArray[iPoint];</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :       if (cluster.GetVolumeId()==0) continue;</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :       double alpSect = ((cluster.GetDetector()%18)+0.5)*20*TMath::DegToRad();</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :       double xyz[3] = {cluster.GetX(),cluster.GetY(),cluster.GetZ()}; // sector tracking frame</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :       paramITS.Local2GlobalPosition(xyz,alpSect);       </span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :       Double_t alpha = TMath::ATan2(xyz[1],xyz[0]);</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :       paramITS.Global2LocalPosition(xyz,alpha);  // cluster frame</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :       if (!(itsOK=paramITS.Rotate(alpha))) break;</span>
<span class="lineNum">     551 </span>            :       // full material correction makes sense only when crossing the boundary of the TPC
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :       itsOK = (++npUpdITS)==1 ? </span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :         AliTrackerBase::PropagateTrackToBxByBz(&amp;paramITS,xyz[0],mass,1,kFALSE) :</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :         PropagateInTPCTo(&amp;paramITS,xyz[0],fRhoTPC,fX0TPC,mass) &amp;&amp;</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :         TMath::Abs(paramITS.GetSnp())&lt;kMaxSNP;</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :       if (itsOK){</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :         trackArrayITS[iPoint]=paramITS;</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :         trackArrayITS[iPoint].SetUniqueID(1);</span>
<span class="lineNum">     559 </span>            :       }
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :       else break; // no sense to propagate farther</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :     if (!itsOK) continue; // no point in continuing if ITS failed</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :     if (fTrackCounter%fSyswatchStep==0) AliSysInfo::AddStamp(&quot;ExtrapolateITS&quot;,fTrackCounter,2,0,0);  </span>
<span class="lineNum">     564 </span>            :     //
<span class="lineNum">     565 </span>            :     // 5.) Propagate  TRD/TOF tracks inwards
<span class="lineNum">     566 </span>            :     //
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :     Bool_t trdOK=(trdNCl&gt;0);</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :     Bool_t tofOK=(tofNCl&gt;0);</span>
<span class="lineNum">     569 </span>            :     int npUpdTRD = 0, npUpdTOF = 0;
<span class="lineNum">     570 </span>            :     //
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :     for (Int_t iPoint=kMaxLayer;iPoint--;){  </span>
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :       if (!trdOK &amp;&amp; !tofOK) break; // no sense to continue;</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :       AliTPCclusterMI &amp;cluster=clusterArray[iPoint];</span>
<span class="lineNum">     574 </span>            :       //      if (cluster==NULL) continue;
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :       if (cluster.GetVolumeId()==0) continue;</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :       double alpSect = ((cluster.GetDetector()%18)+0.5)*20*TMath::DegToRad();</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :       double xyz[3] = {cluster.GetX(),cluster.GetY(),cluster.GetZ()}; // sector tracking frame</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :       paramTRD.Local2GlobalPosition(xyz,alpSect);       </span>
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :       Double_t alpha = TMath::ATan2(xyz[1],xyz[0]);</span>
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :       paramTRD.Global2LocalPosition(xyz,alpha); // cluster frame</span>
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :       if (trdOK){</span>
<span class="lineNum">     583 </span>            :         // material correction makes sense only when crossing the boundary of the TPC
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :         trdOK = paramTRD.Rotate(alpha) &amp;&amp; ((++npUpdTRD)==1 ? </span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :                                            AliTrackerBase::PropagateTrackToBxByBz(&amp;paramTRD,xyz[0],mass,1,kFALSE) :</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :                                            PropagateInTPCTo(&amp;paramTRD,xyz[0],fRhoTPC,fX0TPC,mass)) </span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :           &amp;&amp;                               TMath::Abs(paramTRD.GetSnp())&lt;kMaxSNP;</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :         if (trdOK){</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :           trackArrayTRD[iPoint]=paramTRD;</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :           trackArrayTRD[iPoint].SetUniqueID(1);</span>
<span class="lineNum">     591 </span>            :           //
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :           trackArrayITSTRD[iPoint]=paramTRD;</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :           if (trackArrayITS[iPoint].GetUniqueID()) { // update by ITS only if the latter is OK</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :             AliTrackerBase::UpdateTrack(trackArrayITSTRD[iPoint], trackArrayITS[iPoint]);</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :             Double_t chi2=trackArrayITSTRD[iPoint].GetY()-trackArrayITS[iPoint].GetY();</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :             chi2*=chi2;</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :             chi2/=trackArrayITSTRD[iPoint].GetSigmaY2()+trackArrayITS[iPoint].GetSigmaY2()+kMaxAlignTolerance;</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :             if (chi2&lt;kMaxChi2) trackArrayITSTRD[iPoint].SetUniqueID(1);</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">     600 </span>            :         }
<span class="lineNum">     601 </span>            :       }
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :       if (tofOK){</span>
<span class="lineNum">     603 </span>            :         // material correction makes sense only when crossing the boundary of the TPC
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :         tofOK = paramTOF.Rotate(alpha) &amp;&amp; ((++npUpdTOF)==1 ?</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :                                            AliTrackerBase::PropagateTrackToBxByBz(&amp;paramTOF,xyz[0],mass,1,kFALSE) :</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :                                            PropagateInTPCTo(&amp;paramTOF,xyz[0],fRhoTPC,fX0TPC,mass))</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :           &amp;&amp;                               TMath::Abs(paramTOF.GetSnp())&lt;kMaxSNP;</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :         if (tofOK){</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :           trackArrayTOF[iPoint]=paramTOF;</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :           trackArrayTOF[iPoint].SetUniqueID(1);</span>
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :           trackArrayITSTOF[iPoint]=paramTOF;</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :           if (trackArrayITS[iPoint].GetUniqueID()) {  // update by ITS only if the latter is OK</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :             AliTrackerBase::UpdateTrack(trackArrayITSTOF[iPoint], trackArrayITS[iPoint]);</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :             Double_t chi2=trackArrayITSTOF[iPoint].GetY()-trackArrayITS[iPoint].GetY();</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :             chi2*=chi2;</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :             chi2/=trackArrayITSTOF[iPoint].GetSigmaY2()+trackArrayITS[iPoint].GetSigmaY2()+kMaxAlignTolerance;</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :             if (chi2&lt;kMaxChi2)  trackArrayITSTOF[iPoint].SetUniqueID(1);</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">     620 </span>            :         }
<span class="lineNum">     621 </span>            :       }
<span class="lineNum">     622 </span>            :       //
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :     if (fTrackCounter%fSyswatchStep==0) AliSysInfo::AddStamp(&quot;InterpolateTRD&quot;,fTrackCounter,3,0,0);  </span>
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :     if ( ((fStreamLevelTrack&amp;kStremInterpolation)&gt;0)&amp;&amp;(fTrackCounter%fSyswatchStep==0)){</span>
<span class="lineNum">     627 </span>            :       //if ((fTrackCounter%fSyswatchStep==0)){
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :       for (Int_t iPoint=0;iPoint&lt;kMaxLayer;iPoint++){</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :         AliTPCclusterMI &amp;cluster=clusterArray[iPoint];</span>
<span class="lineNum">     630 </span>            :         //if (cluster==NULL) continue;
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :         if (cluster.GetVolumeId()==0) continue;</span>
<span class="lineNum">     632 </span>            : 
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :         (*fStreamer)&lt;&lt;&quot;interpolation&quot;&lt;&lt;</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :           &quot;itrack=&quot;&lt;&lt;fTrackCounter&lt;&lt;  // total track #</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :           &quot;cluster.=&quot;&lt;&lt;&amp;cluster&lt;&lt;  // space points                                    //</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :           &quot;itsNCl=&quot;&lt;&lt;itsNCl&lt;&lt;</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :           &quot;trdNCl=&quot;&lt;&lt;trdNCl&lt;&lt;</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :           &quot;tofNCl=&quot;&lt;&lt;tofNCl&lt;&lt;</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :           &quot;itsOK=&quot;&lt;&lt;itsOK&lt;&lt;</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :           &quot;trdOK=&quot;&lt;&lt;trdOK&lt;&lt;</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :           &quot;tofOK=&quot;&lt;&lt;tofOK&lt;&lt;</span>
<span class="lineNum">     642 </span>            :           //
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :           &quot;itsChi2=&quot;&lt;&lt;itsChi2&lt;&lt;</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :           &quot;trdChi2=&quot;&lt;&lt;trdChi2&lt;&lt;</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :           &quot;tofChi2=&quot;&lt;&lt;tofChi2&lt;&lt;</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :           &quot;tofBC=&quot;&lt;&lt;tofDiff&lt;&lt;</span>
<span class="lineNum">     647 </span>            :           //
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :           &quot;trackITS.=&quot;&lt;&lt;&amp;trackArrayITS[iPoint]&lt;&lt;  // ITS fit</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :           &quot;trackTRD.=&quot;&lt;&lt;&amp;trackArrayTRD[iPoint]&lt;&lt;  // TRD fit</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :           &quot;trackTOF.=&quot;&lt;&lt;&amp;trackArrayTOF[iPoint]&lt;&lt;  // TOF fit</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :           &quot;trackITSTRD.=&quot;&lt;&lt;&amp;trackArrayITSTRD[iPoint]&lt;&lt;  // ITS-TRD fit</span>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :           &quot;trackITSTOF.=&quot;&lt;&lt;&amp;trackArrayITSTOF[iPoint]&lt;&lt;  // ITS-TOF fit</span>
<span class="lineNum">     653 </span>            :           &quot;\n&quot;;       
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :     UShort_t counter=0;</span>
<span class="lineNum">     657 </span>            :     Double_t rounding=200;
<span class="lineNum">     658 </span>            :     //    
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :     memset( deltaITS0.GetMatrixArray(), 0,kMaxLayer*sizeof(Float_t));</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :     memset( deltaITS1.GetMatrixArray(), 0,kMaxLayer*sizeof(Float_t));</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :     memset( deltaTRD0.GetMatrixArray(), 0,kMaxLayer*sizeof(Float_t));</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :     memset( deltaTRD1.GetMatrixArray(), 0,kMaxLayer*sizeof(Float_t));</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :     memset( deltaTOF0.GetMatrixArray(), 0,kMaxLayer*sizeof(Float_t));</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :     memset( deltaTOF1.GetMatrixArray(), 0,kMaxLayer*sizeof(Float_t));</span>
<span class="lineNum">     665 </span>            :     //
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :     memset( vecR.GetMatrixArray(), 0,kMaxLayer*sizeof(Float_t));</span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :     memset( vecPhi.GetMatrixArray(), 0,kMaxLayer*sizeof(Float_t));</span>
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :     memset( vecZ.GetMatrixArray(), 0,kMaxLayer*sizeof(Float_t));</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :     memset( vecSec.GetMatrixArray(), 0,kMaxLayer*sizeof(Float_t));</span>
<span class="lineNum">     670 </span>            :     //
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :     for (Int_t iPoint=0;iPoint&lt;kMaxLayer;iPoint++){      </span>
<span class="lineNum">     672 </span>            :       //
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :       deltaITS0[counter]=deltaITS1[counter]=deltaTRD0[counter]=deltaTRD1[counter]=deltaTOF0[counter]=deltaTOF1[counter]=-999;</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :       vecR[counter] = -999;</span>
<span class="lineNum">     675 </span>            :       //
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :       AliTPCclusterMI &amp;cluster=clusterArray[iPoint];</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :       if (cluster.GetVolumeId()==0) continue;</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :       Double_t   zsignSector=((cluster.GetDetector()%36)&lt;18) ? 1.:-1.;</span>
<span class="lineNum">     679 </span>            :       //if (zsignSector*cluster.GetZ()&lt;0.) continue;
<span class="lineNum">     680 </span>            :       //
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :       if (trackArrayITS[iPoint].GetUniqueID()&gt;0) { // deltas make sense only if ITS was ok</span>
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :         deltaITS0[counter]= TMath::Nint(trackArrayITS[iPoint].GetY()*rounding)/rounding;</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :         deltaITS1[counter]= TMath::Nint((trackArrayITS[iPoint].GetZ()-cluster.GetZ())*rounding)/rounding;</span>
<span class="lineNum">     684 </span>            :         //
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :         if (trackArrayITSTRD[iPoint].GetUniqueID()&gt;0){</span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :           deltaTRD0[counter]= TMath::Nint(trackArrayITSTRD[iPoint].GetY()*rounding)/rounding;</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :           deltaTRD1[counter]= TMath::Nint((trackArrayITSTRD[iPoint].GetZ()-cluster.GetZ())*rounding)/rounding;</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :         if (trackArrayITSTOF[iPoint].GetUniqueID()&gt;0){</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :           deltaTOF0[counter]= TMath::Nint(trackArrayITSTOF[iPoint].GetY()*rounding)/rounding;</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :           deltaTOF1[counter]= TMath::Nint((trackArrayITSTOF[iPoint].GetZ()-cluster.GetZ())*rounding)/rounding;</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     693 </span>            :         // vecR(kMaxLayer), vecPhi(kMaxLayer), vecZ(kMaxLayer);
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :         vecR[counter]=trackArrayITS[iPoint].GetX();</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :         vecPhi[counter]=trackArrayITS[iPoint].GetAlpha();</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :         vecZ[counter]=trackArrayITS[iPoint].GetZ();</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :         vecSec[counter]=cluster.GetDetector();</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :         counter++;</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :     AliExternalTrackParam * ip = (AliExternalTrackParam *)esdTrack-&gt;GetInnerParam();</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :     Bool_t saveBit = ip-&gt;TestBit(kAlignmentBugFixedBit);</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :     ip-&gt;SetBit(kAlignmentBugFixedBit,kTRUE);    // Flag that the alignment bug is fixed</span>
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :     Int_t timeStamp= esdEvent-&gt;GetTimeStamp();</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :     (*fStreamer)&lt;&lt;&quot;delta&quot;&lt;&lt;</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :       &quot;nTracks=&quot;&lt;&lt;nTracks&lt;&lt;               // number of tracks in event (pileup indicator)</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :       &quot;nPrimTracks=&quot;&lt;&lt;nPrimTracks&lt;&lt;       // number of tracks pointed to primary vertes of selected event</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :       &quot;timeStamp=&quot;&lt;&lt;timeStamp&lt;&lt;           // time stamp</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :       &quot;itrack=&quot;&lt;&lt;fTrackCounter&lt;&lt;          // total track #</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :       &quot;gid=&quot;&lt;&lt;gid&lt;&lt;                       // global ID of the event</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :       &quot;itsNCl=&quot;&lt;&lt;itsNCl&lt;&lt;</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :       &quot;trdNCl=&quot;&lt;&lt;trdNCl&lt;&lt;</span>
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :       &quot;tofNCl=&quot;&lt;&lt;tofNCl&lt;&lt;</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :       &quot;itsOK=&quot;&lt;&lt;itsOK&lt;&lt;</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :       &quot;trdOK=&quot;&lt;&lt;trdOK&lt;&lt;</span>
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :       &quot;tofOK=&quot;&lt;&lt;tofOK&lt;&lt;</span>
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :       &quot;itsChi2=&quot;&lt;&lt;itsChi2&lt;&lt;</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :       &quot;trdChi2=&quot;&lt;&lt;trdChi2&lt;&lt;</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :       &quot;tofChi2=&quot;&lt;&lt;tofChi2&lt;&lt;</span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :       &quot;tofBC=&quot;&lt;&lt;tofDiff&lt;&lt;</span>
<span class="lineNum">     721 </span>            :       //
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :       &quot;track.=&quot;&lt;&lt;ip&lt;&lt;                    // track parameters at inner wal of TPC</span>
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :       &quot;npValid=&quot;&lt;&lt;counter&lt;&lt;</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :       &quot;vecR.=&quot;&lt;&lt;&amp;vecR&lt;&lt;          </span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :       &quot;vecPhi.=&quot;&lt;&lt;&amp;vecPhi&lt;&lt;</span>
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :       &quot;vecSec.=&quot;&lt;&lt;&amp;vecSec&lt;&lt;              // sector number</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :       &quot;vecZ.=&quot;&lt;&lt;&amp;vecZ&lt;&lt;</span>
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :       &quot;its0.=&quot;&lt;&lt;&amp;deltaITS0&lt;&lt;</span>
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :       &quot;its1.=&quot;&lt;&lt;&amp;deltaITS1&lt;&lt;</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :       &quot;trd0.=&quot;&lt;&lt;&amp;deltaTRD0&lt;&lt;</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :       &quot;trd1.=&quot;&lt;&lt;&amp;deltaTRD1&lt;&lt;</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :       &quot;tof0.=&quot;&lt;&lt;&amp;deltaTOF0&lt;&lt;</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :       &quot;tof1.=&quot;&lt;&lt;&amp;deltaTOF1&lt;&lt;</span>
<span class="lineNum">     734 </span>            :       &quot;\n&quot;;    
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :     if (fTrackCounter%fSyswatchStep==0) AliSysInfo::AddStamp(&quot;FittTree&quot;,fTrackCounter,4,0,0);  </span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :     if (fTrackCounter%fSyswatchStep==0) AliSysInfo::AddStamp(&quot;FillHistos&quot;,fTrackCounter,5,0,0);  </span>
<span class="lineNum">     737 </span>            :     //
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :     ip-&gt;SetBit(kAlignmentBugFixedBit,saveBit);</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :   transform-&gt;GetCurrentRecoParamNonConst()-&gt;SetUseComposedCorrection( backupUseComposedCorrection);</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :   transform-&gt;GetCurrentRecoParamNonConst()-&gt;SetUseCorrectionMap(backupUseCorrectionMaps);</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :   transform-&gt;GetCurrentRecoParamNonConst()-&gt;SetAccountDistortions(backupAccountDistortions);</span>
<span class="lineNum">     743 </span>            : 
<span class="lineNum">     744 </span>            :   //
<span class="lineNum">     745 </span>            :  // end of track loop
<a name="746"><span class="lineNum">     746 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     747 </span>            : 
<span class="lineNum">     748 </span>            : void AliTPCcalibAlignInterpolation::CreateResidualHistosInterpolation(Double_t dy, Double_t dz, Int_t selHis){
<span class="lineNum">     749 </span>            :   //
<span class="lineNum">     750 </span>            :   // Make cluster residual histograms
<span class="lineNum">     751 </span>            :   //
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :   Double_t xminTrack[9], xmaxTrack[9];</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :   Double_t xminTrackITS[9], xmaxTrackITS[9];</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :   Int_t    binsTrack[9], binsTrackITS[9];</span>
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :   TString  axisName[9],axisTitle[9];</span>
<span class="lineNum">     756 </span>            :   //
<span class="lineNum">     757 </span>            :   // 0 - local   q/pt
<span class="lineNum">     758 </span>            :   // 1 - global  phi in sector number  as float
<span class="lineNum">     759 </span>            :   // 2 - local   r
<span class="lineNum">     760 </span>            :   // 3 - local   kz
<span class="lineNum">     761 </span>            :   // 4 - delta   of interest
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span>            :   // 
<span class="lineNum">     764 </span>            :   // gx,gy,gz - will be taken from the TPC
<span class="lineNum">     765 </span>            :   //
<span class="lineNum">     766 </span>            :   //
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :   axisName[kQ2PT]=&quot;qpt&quot;;     axisTitle[kQ2PT]=&quot;q/pt (c/GeV)&quot;;                         // to fill : track.GetSigned1Pt() </span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :   binsTrack[kQ2PT]=7;        xminTrack[kQ2PT]=-3;        xmaxTrack[kQ2PT]=3; </span>
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :   binsTrackITS[kQ2PT]=7;     xminTrackITS[kQ2PT]=-3;     xmaxTrackITS[kQ2PT]=3; </span>
<span class="lineNum">     770 </span>            :   //
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :   axisName[kSect]=&quot;sector&quot;;  axisTitle[kSect]=&quot;Sector Number&quot;;              // to fill:   9*atan2(gy,gx)/pi+ if (sector&gt;0) sector+18</span>
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :   binsTrack[kSect]=181;      xminTrack[kSect]=-0.05;           xmaxTrack[kSect]=18.05; </span>
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :   binsTrackITS[kSect]=181;   xminTrackITS[kSect]=-0.05;        xmaxTrackITS[kSect]=18.05; </span>
<span class="lineNum">     774 </span>            :   //
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :   axisName[kLocX]=&quot;R&quot;;       axisTitle[kLocX]=&quot;r (cm)&quot;;                          // to fill:    gr=sqrt(gy**2+gx**2)</span>
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :   binsTrack[kLocX]=53;       xminTrack[kLocX]=85.;         xmaxTrack[kLocX]=245.; </span>
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :   binsTrackITS[kLocX]=53;    xminTrackITS[kLocX]=85.;      xmaxTrackITS[kLocX]=245.; </span>
<span class="lineNum">     778 </span>            :   //
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :   axisName[kZ2X]=&quot;kZ&quot;;       axisTitle[kZ2X]=&quot;z/r&quot;;                          // to fill : gz/gr </span>
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :   binsTrack[kZ2X]=20;        xminTrack[kZ2X]=-1.0;         xmaxTrack[kZ2X]=1.0;  // +-1 for ITS+TRD and ITS+TOF </span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :   binsTrackITS[kZ2X]=20;     xminTrackITS[kZ2X]=-1.8;      xmaxTrackITS[kZ2X]=1.8;  // +-1.8 for the ITS </span>
<span class="lineNum">     782 </span>            :   //
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :   axisName[kDelt]=&quot;delta&quot;;   axisTitle[kDelt]=&quot;#Delta (cm)&quot;;                 // to fill    local(clusterY-track.y)</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :   binsTrack[kDelt]=100;      xminTrack[kDelt]=-dy;        xmaxTrack[kDelt]=dy; </span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :   binsTrackITS[kDelt]=100;   xminTrackITS[kDelt]=-dy;     xmaxTrackITS[kDelt]=dy; </span>
<span class="lineNum">     786 </span>            :   // 
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :   binsTrack[kDelt]=TMath::Min(Int_t(20.+2.*dy/0.05),100); // buffer should be smaller than 1 GBy</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :   if (selHis==0 ||selHis&lt;0) fHisITSDRPhi =    new THnF(&quot;deltaRPhiTPCITS&quot;,&quot;#Delta_{Y} (cm)&quot;, kNDim, binsTrackITS,xminTrackITS, xmaxTrackITS);</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :   if (selHis==1 ||selHis&lt;0) fHisITSTRDDRPhi = new THnF(&quot;deltaRPhiTPCITSTRD&quot;,&quot;#Delta_{Y} (cm) TPC-(ITS+TRD)&quot;, kNDim, binsTrack,xminTrack, xmaxTrack);</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :   if (selHis==2 ||selHis&lt;0) fHisITSTOFDRPhi = new THnF(&quot;deltaRPhiTPCITSTOF&quot;,&quot;#Delta_{Y} (cm) TPC-(ITS+TOF)&quot;, kNDim, binsTrack,xminTrack, xmaxTrack);</span>
<span class="lineNum">     791 </span>            :   //
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :   binsTrack[kDelt]=TMath::Min(Int_t(20.+2.*dz/0.05),100); // buffer should be smaller than 1 GBy</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :   xminTrack[kDelt]=-dz;        xmaxTrack[kDelt]=dz; </span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :   xminTrackITS[kDelt]=-dz;        xmaxTrackITS[kDelt]=dz; </span>
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :   if (selHis==3 ||selHis&lt;0) fHisITSDZ = new THnF(&quot;deltaZTPCITS&quot;,&quot;#Delta_{Z} (cm)&quot;, kNDim, binsTrackITS,xminTrackITS, xmaxTrackITS);</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :   if (selHis==4 ||selHis&lt;0) fHisITSTRDDZ = new THnF(&quot;deltaZTPCITSTRD&quot;,&quot;#Delta_{Z} (cm) TPC-(ITS+TRD)&quot;, kNDim, binsTrack,xminTrack, xmaxTrack);</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :   if (selHis==5 ||selHis&lt;0) fHisITSTOFDZ = new THnF(&quot;deltaZTPCITSTOF&quot;,&quot;#Delta_{Z} (cm) TPC-(ITS+TOF)&quot;, kNDim, binsTrack,xminTrack, xmaxTrack);</span>
<span class="lineNum">     798 </span>            :   //
<span class="lineNum">     799 </span>            :   //
<span class="lineNum">     800 </span>            :   //
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :   THn *hisToFill[6]={GetHisITSDRPhi(), GetHisITSTRDDRPhi(), GetHisITSTOFDRPhi(), GetHisITSDZ(), GetHisITSTRDDZ(), GetHisITSTOFDZ()};</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :   for (Int_t ihis=0; ihis&lt;6; ihis++){</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :     if (hisToFill[ihis]) for (Int_t ivar2=0;ivar2&lt;kNDim;ivar2++){ </span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :       hisToFill[ihis]-&gt;GetAxis(ivar2)-&gt;SetName(axisName[ivar2].Data());</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :       hisToFill[ihis]-&gt;GetAxis(ivar2)-&gt;SetTitle(axisName[ivar2].Data());      </span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     807 </span>            :   }
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     810 </span>            : 
<a name="811"><span class="lineNum">     811 </span>            : </a>
<span class="lineNum">     812 </span>            : 
<span class="lineNum">     813 </span>            : void  AliTPCcalibAlignInterpolation::CreateDistortionMapsFromFile(const char * inputFile, const char *outputFile){
<span class="lineNum">     814 </span>            :   //
<span class="lineNum">     815 </span>            :   // Create distortion maps from residual histograms
<span class="lineNum">     816 </span>            :   // TPC cluster to ITS, ITS-TRD and ITS-TOF track fits
<span class="lineNum">     817 </span>            :   //
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :   TFile *fHistos  = TFile::Open(inputFile);</span>
<span class="lineNum">     819 </span>            :   
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :   THnF *histoITS = (THnF*) fHistos-&gt;Get(&quot;deltaRPhiTPCITS&quot;);</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :   THnF *histoITSTRD= (THnF*) fHistos-&gt;Get(&quot;deltaRPhiTPCITSTRD&quot;);</span>
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :   THnF *histoITSTOF = (THnF*) fHistos-&gt;Get(&quot;deltaRPhiTPCITSTOF&quot;);</span>
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :   THnF *histoITSZ = (THnF*) fHistos-&gt;Get(&quot;deltaZTPCITS&quot;);</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :   THnF *histoITSTRDZ= (THnF*) fHistos-&gt;Get(&quot;deltaZTPCITSTRD&quot;);</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :   THnF *histoITSTOFZ = (THnF*) fHistos-&gt;Get(&quot;deltaZTPCITSTOF&quot;);</span>
<span class="lineNum">     826 </span>            :   
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :   TTreeSRedirector * pcstream = new TTreeSRedirector(outputFile,&quot;recreate&quot;);</span>
<span class="lineNum">     828 </span>            :   
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :   TMatrixD projectionInfo(5,5);</span>
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :   projectionInfo(0,0)=0;  projectionInfo(0,1)=0;  projectionInfo(0,2)=0;</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :   projectionInfo(1,0)=4;  projectionInfo(1,1)=0;  projectionInfo(1,2)=1; </span>
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :   projectionInfo(2,0)=3;  projectionInfo(2,1)=0;  projectionInfo(2,2)=1;</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :   projectionInfo(3,0)=2;  projectionInfo(3,1)=0;  projectionInfo(3,2)=1;</span>
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :   projectionInfo(4,0)=1;  projectionInfo(4,1)=0;  projectionInfo(4,2)=1;</span>
<span class="lineNum">     835 </span>            :   
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :   TStatToolkit::MakeDistortionMap(4, histoITS,    pcstream, projectionInfo); </span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :   TStatToolkit::MakeDistortionMap(4, histoITSTRD, pcstream, projectionInfo); </span>
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :   TStatToolkit::MakeDistortionMap(4, histoITSTOF, pcstream, projectionInfo); </span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :   TStatToolkit::MakeDistortionMap(4, histoITSZ,    pcstream, projectionInfo); </span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :   TStatToolkit::MakeDistortionMap(4, histoITSTRDZ, pcstream, projectionInfo); </span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :   TStatToolkit::MakeDistortionMap(4, histoITSTOFZ, pcstream, projectionInfo); </span>
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :   delete pcstream;</span>
<span class="lineNum">     843 </span>            :   //
<a name="844"><span class="lineNum">     844 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span>            : void    AliTPCcalibAlignInterpolation::FillHistogramsFromChain(const char * residualList, Double_t dy, Double_t dz, 
<span class="lineNum">     847 </span>            :                                                                Int_t startTime, Int_t stopTime, Int_t maxStat, 
<span class="lineNum">     848 </span>            :                                                                Int_t selHis,const char * residualInfoFile,
<span class="lineNum">     849 </span>            :                                                                Bool_t fixAlignmentBug){
<span class="lineNum">     850 </span>            :   /**
<span class="lineNum">     851 </span>            :    * Trees with point-track residuals to residual histogram
<span class="lineNum">     852 </span>            :    * @param residualList  text file with tree list
<span class="lineNum">     853 </span>            :    * Output - ResidualHistograms.root file with hitogram within AliTPCcalibAlignInterpolation object
<span class="lineNum">     854 </span>            :    */
<span class="lineNum">     855 </span>            :   //
<span class="lineNum">     856 </span>            :   //
<span class="lineNum">     857 </span>            :   // 
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :   ::Info(&quot; AliTPCcalibAlignInterpolation::FillHistogramsFromChain&quot;,&quot;Start %s\n&quot;, residualList);</span>
<span class="lineNum">     859 </span>            :   Int_t cacheSize= 200000000;
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :   if (gSystem-&gt;Getenv(&quot;treeCacheSize&quot;)) cacheSize=TString(gSystem-&gt;Getenv(&quot;treeCacheSize&quot;)).Atoi();</span>
<span class="lineNum">     861 </span>            :   Bool_t autoCache = kFALSE;
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :   if (gSystem-&gt;Getenv(&quot;autoCacheSize&quot;)) {</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :     autoCache = Bool_t(TString(gSystem-&gt;Getenv(&quot;autoCacheSize&quot;)).Atoi());</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     865 </span>            :   Int_t cacheLearnEntries = 1;
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :   if (gSystem-&gt;Getenv(&quot;cacheLearnEntriesProjection&quot;)) {</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :     cacheLearnEntries = TString(gSystem-&gt;Getenv(&quot;cacheLearnEntriesProjection&quot;)).Atoi();</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :   Printf(&quot;************* cacheSize = %d, autoCache = %d, cacheLearnEntries = %d&quot;, cacheSize, (Int_t)autoCache, cacheLearnEntries);</span>
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span>            :   const Int_t kNDim1 = kNDim-1;
<span class="lineNum">     872 </span>            :   const Double_t kernelSigma2I[4]={1./0.25,1./0.25,1./0.25,1./0.25};  // inverse kernel sigma in bin width units
<span class="lineNum">     873 </span>            :   const Double_t kFillGap=0.02  ;  // weight for the &quot;non primary distortion info&quot; - 
<span class="lineNum">     874 </span>            :   //                                used to fill the gap without measurement (PHOS hole)
<span class="lineNum">     875 </span>            :   const Double_t kFillGapITS=0.01;
<span class="lineNum">     876 </span>            :   // track and cluster quality cuts - see also AliTPCcalibAlignInterpolation::CalculateDistance
<span class="lineNum">     877 </span>            :   const Int_t   kMaxSkippedCluster=10;  // 10 cluster
<span class="lineNum">     878 </span>            :   const Float_t kMaxRMSTrackCut=2.0;    // maximal RMS (cm) between the tracks 
<span class="lineNum">     879 </span>            :   const Float_t kMaxRMSClusterCut=0.3;    // maximal RMS (cm) between the cluster and local mean
<span class="lineNum">     880 </span>            :   const Float_t kMaxDeltaClusterCut=0.5;    // maximal delta(cm) between the cluster and local mean
<span class="lineNum">     881 </span>            :   //
<span class="lineNum">     882 </span>            :   // gap weight is kFillGap + Exp(-dist): don't calculate exponent if dist is &gt;kMaxExpArg
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :   const Double_t kMaxExpArg = -TMath::Log(TMath::Max(kFillGap*0.1, 1e-3)); </span>
<span class="lineNum">     884 </span>            :   //
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :   Int_t runNumber=TString(gSystem-&gt;Getenv(&quot;runNumber&quot;)).Atoi();</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :   float bz = fixAlignmentBug ? InitForAlignmentBugFix(runNumber) : 0;</span>
<span class="lineNum">     887 </span>            : 
<span class="lineNum">     888 </span>            :   // 0.) Load current information file and bookd variables
<span class="lineNum">     889 </span>            :   // 
<span class="lineNum">     890 </span>            :   const Int_t nSec=81;         // 72 sector +5 sumarry info+ 4 medians +
<span class="lineNum">     891 </span>            :   const Double_t kMaxZSect[2]={2.49725e+02,2.49698e+02};
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :   TVectorF meanNcl(nSec);      // mean current estator ncl per sector</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :   TVectorF meanNclUsed(nSec);  // mean current estator ncl per sector</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :   Double_t meanTime=0, maxTime=startTime, minTime=stopTime;</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :   Int_t currentTrack=0;  </span>
<span class="lineNum">     896 </span>            : 
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :   TFile *finfo = TFile::Open(residualInfoFile);</span>
<span class="lineNum">     898 </span>            :   TTree *treeInfo=0;
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :   if (finfo) {</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :     treeInfo=(TTree*)finfo-&gt;Get(&quot;summaryTime&quot;); </span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :   }else{</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :     ::Fatal(&quot;AliTPCcalibAlignInterpolation::FillHistogramsFromChain&quot;,&quot;residualInfoFile %s does not exist&quot;,residualInfoFile);</span>
<span class="lineNum">     903 </span>            :   }  
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :   TGraphErrors * nclArray[nSec]={0};</span>
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :   TGraphErrors * nclArrayUsed[nSec]={0};</span>
<span class="lineNum">     906 </span>            :   
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :   if (treeInfo) {</span>
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :     for (Int_t iSec=0; iSec&lt;nSec; iSec++){</span>
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :       nclArray[iSec]=0;</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :       nclArrayUsed[iSec]=0;</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :       treeInfo-&gt;SetBranchAddress(TString::Format(&quot;grNcl%d.&quot;,iSec).Data(),&amp;nclArray[iSec]);</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :       treeInfo-&gt;SetBranchAddress(TString::Format(&quot;grNclUsed%d.&quot;,iSec).Data(),&amp;nclArrayUsed[iSec]);</span>
<span class="lineNum">     913 </span>            :     }
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :     treeInfo-&gt;GetEntry(0);</span>
<span class="lineNum">     915 </span>            :   }else{
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :     ::Fatal(&quot;AliTPCcalibAlignInterpolation::FillHistogramsFromChain&quot;,&quot;residualInfoFile %s does not contain tree summaryTime&quot;,residualInfoFile);</span>
<span class="lineNum">     917 </span>            :   }
<span class="lineNum">     918 </span>            :   //
<span class="lineNum">     919 </span>            :   // 0.a) Load drift velocity calibration in case availbel
<span class="lineNum">     920 </span>            :   //
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :   TVectorD     *vdriftParam=0;</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :   TGraphErrors *vdriftGraph=0;  </span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :   TFile *fdrift = TFile::Open(&quot;fitDrift.root&quot;); </span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :   AliSysInfo::AddStamp(&quot;FillHistogramsFromChain.LoadDriftBegin&quot;,1,0);</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :   if (fdrift){</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :     TTree * tree = (TTree*)fdrift-&gt;Get(&quot;fitTimeStat&quot;);</span>
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :     if (tree==NULL){</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :       ::Error(&quot;LoadDriftCalibration FAILED&quot;, &quot;tree fitTimeStat not avaliable in file fitDrift.root&quot;);</span>
<span class="lineNum">     929 </span>            :     }else{      
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :       tree-&gt;SetBranchAddress(&quot;grTRDReg.&quot;,&amp;vdriftGraph);</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :       tree-&gt;SetBranchAddress(&quot;paramRobust.&quot;,&amp;vdriftParam);</span>
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :       tree-&gt;GetEntry(0);</span>
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :       if (vdriftGraph==NULL || vdriftGraph-&gt;GetN()&lt;=0){</span>
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :         ::Info(&quot;LoadDriftCalibration FAILED&quot;, &quot;ITS/TRD drift calibration not availalble. Trying ITS/TOF&quot;);</span>
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :         tree-&gt;SetBranchAddress(&quot;grTOFReg.&quot;,&amp;vdriftGraph);</span>
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :         tree-&gt;GetEntry(0);</span>
<span class="lineNum">     937 </span>            :       }else{
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :         ::Info(&quot;LoadDriftCalibration&quot;, &quot;tree fitTimeStat loaded from the tree&quot;);</span>
<span class="lineNum">     939 </span>            :       }
<span class="lineNum">     940 </span>            :     }
<span class="lineNum">     941 </span>            :     
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :   }else{</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :     ::Error(&quot;LoadDriftCalibration FAILED&quot;, &quot;fitDrift.root not present&quot;);</span>
<span class="lineNum">     944 </span>            :   }
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :   AliSysInfo::AddStamp(&quot;FillHistogramsFromChain.LoadDriftEND&quot;,1,1);</span>
<span class="lineNum">     946 </span>            :   //
<span class="lineNum">     947 </span>            :   // 1.) Fill histograms and mean informations
<span class="lineNum">     948 </span>            :   //
<span class="lineNum">     949 </span>            :   const Int_t knPoints=kMaxRow;
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :   AliTPCcalibAlignInterpolation * calibInterpolation = new  AliTPCcalibAlignInterpolation(&quot;calibInterpolation&quot;,&quot;calibInterpolation&quot;,kFALSE);</span>
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :   calibInterpolation-&gt;CreateResidualHistosInterpolation(dy,dz,selHis);</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :   TString branches[6]={&quot;its0.&quot;,&quot;trd0.&quot;,&quot;tof0.&quot;, &quot;its1.&quot;,&quot;trd1.&quot;,&quot;tof1.&quot;};</span>
<span class="lineNum">     953 </span>            :   //
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :   TVectorF *vecDeltaOther= 0;</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :   TVectorF *vecDeltaOtherITS= 0;</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :   TVectorF *vecDelta= 0;</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :   TVectorF *vecDeltaITS= 0;</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :   TVectorF *vecR=0;</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :   TVectorF *vecSec=0;</span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :   TVectorF *vecPhi=0;</span>
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :   TVectorF *vecZ=0;</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :   TVectorF *vecLocalDelta = new TVectorF(knPoints);</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :   Int_t timeStamp=0;</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :   AliExternalTrackParam *param = 0;</span>
<span class="lineNum">     965 </span>            :   //
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :   TString  esdList0 = gSystem-&gt;GetFromPipe(TString::Format(&quot;cat %s&quot;,residualList).Data());</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :   TObjArray *esdArray= esdList0.Tokenize(&quot;\n&quot;);  </span>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :   Int_t nesd = esdArray-&gt;GetEntriesFast();  </span>
<span class="lineNum">     969 </span>            :   //
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :   THn *hisToFill[6]={calibInterpolation-&gt;GetHisITSDRPhi(), calibInterpolation-&gt;GetHisITSTRDDRPhi(),  calibInterpolation-&gt;GetHisITSTOFDRPhi(), calibInterpolation-&gt;GetHisITSDZ(), calibInterpolation-&gt;GetHisITSTRDDZ(),  calibInterpolation-&gt;GetHisITSTOFDZ()};</span>
<span class="lineNum">     971 </span>            :   TTreeSRedirector * fout = 0;
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :   if (selHis&lt;0)  {</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :     if (startTime&lt;=0) fout=new TTreeSRedirector(&quot;ResidualHistograms.root&quot;,&quot;recreate&quot;);</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :     if (startTime&gt;0) fout=new TTreeSRedirector(TString::Format(&quot;ResidualHistograms_Time%d.root&quot;,startTime).Data(),&quot;recreate&quot;);</span>
<span class="lineNum">     975 </span>            :   }
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :   if (selHis&gt;=0) {</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :     if (startTime&lt;=0)  fout=new TTreeSRedirector(TString::Format(&quot;ResidualHistograms_His%d.root&quot;,selHis).Data(),&quot;recreate&quot;);</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :     if (startTime&gt;0)   fout=new TTreeSRedirector(TString::Format(&quot;ResidualHistograms_His%d_Time%d.root&quot;,selHis,startTime).Data(),&quot;recreate&quot;);</span>
<span class="lineNum">     979 </span>            :   }
<span class="lineNum">     980 </span>            :   TH1 * hisTime=0;
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :   if (startTime&gt;0) hisTime=new TH1F(&quot;hisTrackTime&quot;,&quot;hisTrackTime&quot;,(stopTime-startTime)/20,startTime,stopTime);</span>
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :   TStopwatch timerAll;</span>
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :   UShort_t npValid=knPoints;</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :   Long64_t fillCounter=0;</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :   Long64_t clusterCounter=0;</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :   AliSysInfo::AddStamp(&quot;FillHistogramsFromChain.BEGIN&quot;,2,0);</span>
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :   for (Int_t ihis=0; ihis&lt;6; ihis++){    </span>
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :     if (selHis&gt;=0 &amp;&amp; ihis!=selHis) continue;</span>
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :     Double_t binWidth[4]={0};</span>
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :     for (Int_t idim=0; idim&lt;4; idim++) binWidth[idim]=hisToFill[ihis]-&gt;GetAxis(idim)-&gt;GetBinWidth(1);</span>
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :     for (Int_t iesd=0; iesd&lt;nesd; iesd++){</span>
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :       TStopwatch timerFile;</span>
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :       TString fileNameString(esdArray-&gt;At(iesd)-&gt;GetName());</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :       if (fileNameString.Contains(&quot;alien://&quot;) &amp;&amp; (!gGrid || (gGrid &amp;&amp; !gGrid-&gt;IsConnected()))) TGrid::Connect(&quot;alien://&quot;);</span>
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :       TFile *esdFile = TFile::Open(fileNameString.Data(),&quot;read&quot;);</span>
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :       if (!esdFile) continue;</span>
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :       TTree *tree = (TTree*)esdFile-&gt;Get(&quot;delta&quot;);</span>
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :       if (!autoCache) {</span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :         tree-&gt;SetCacheSize(cacheSize);</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :         tree-&gt;SetCacheLearnEntries(cacheLearnEntries);</span>
<span class="lineNum">    1001 </span>            :       }
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :       tree-&gt;SetBranchStatus(&quot;*&quot;,kFALSE);</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :       if (!tree) continue;</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :       ::Info(&quot; AliTPCcalibAlignInterpolation::FillHistogramsFromChain&quot;, &quot;Processing file \t %s\n&quot;,esdArray-&gt;At(iesd)-&gt;GetName());</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :       AliSysInfo::AddStamp(esdArray-&gt;At(iesd)-&gt;GetName(),ihis,iesd,currentTrack);</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :       tree-&gt;SetBranchStatus(&quot;timeStamp&quot;,kTRUE);</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :       TBranch *br = tree-&gt;GetBranch(&quot;timeStamp&quot;);</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :       tree-&gt;SetBranchStatus(&quot;vecR.&quot;,kTRUE);</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :       tree-&gt;SetBranchStatus(&quot;vecSec.&quot;,kTRUE);</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :       tree-&gt;SetBranchStatus(&quot;vecPhi.&quot;,kTRUE);</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :       tree-&gt;SetBranchStatus(&quot;vecZ.&quot;,kTRUE);</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :       tree-&gt;SetBranchStatus(&quot;track.*&quot;,kTRUE);      </span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :       tree-&gt;SetBranchAddress(&quot;vecR.&quot;,&amp;vecR);</span>
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :       tree-&gt;SetBranchAddress(&quot;vecSec.&quot;,&amp;vecSec);</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :       tree-&gt;SetBranchAddress(&quot;vecPhi.&quot;,&amp;vecPhi);</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :       tree-&gt;SetBranchAddress(&quot;vecZ.&quot;,&amp;vecZ);</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :       tree-&gt;SetBranchAddress(&quot;track.&quot;,&amp;param);</span>
<span class="lineNum">    1018 </span>            :       //
<span class="lineNum">    1019 </span>            :       // before doing anything else, check if alignment bug indeed must be fixed
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :       Bool_t fixAlignmentBugForFile = fixAlignmentBug;</span>
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :       if (fixAlignmentBugForFile) {</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :         TBranch *brParam = tree-&gt;GetBranch(&quot;track.&quot;);</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :         brParam-&gt;GetEntry(0);</span>
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :         if (param-&gt;TestBit(kAlignmentBugFixedBit)) {</span>
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :           ::Info(&quot; AliTPCcalibAlignInterpolation::FillHistogramsFromChain&quot;,</span>
<span class="lineNum">    1026 </span>            :                  &quot;AlignmentBugFix is requested but is not needed for this chunk\n&quot;);
<span class="lineNum">    1027 </span>            :           fixAlignmentBugForFile = kFALSE;
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1030 </span>            :       //
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :       br-&gt;SetAddress(&amp;timeStamp);</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :       if (tree-&gt;GetBranch(&quot;npValid&quot;)!=NULL) {</span>
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :         tree-&gt;SetBranchStatus(&quot;npValid&quot;,kTRUE);</span>
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :         tree-&gt;SetBranchAddress(&quot;npValid&quot;,&amp;npValid);</span>
<span class="lineNum">    1035 </span>            :       }
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :       tree-&gt;SetBranchStatus(branches[ihis],kTRUE);</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :       tree-&gt;SetBranchAddress(branches[ihis],&amp;vecDelta);</span>
<span class="lineNum">    1038 </span>            :       // 
<span class="lineNum">    1039 </span>            :       // if aligment bug fix is needed, we need also other delta
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :       if (fixAlignmentBugForFile) {</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :         int ihisOther = ihis&lt;=2 ? ihis+3 : ihis-3;</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :         tree-&gt;SetBranchStatus(branches[ihisOther],kTRUE);</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :         tree-&gt;SetBranchAddress(branches[ihisOther],&amp;vecDeltaOther);</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1045 </span>            : 
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :       if (ihis&lt;=2 &amp;&amp;ihis!=0){</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :         tree-&gt;SetBranchStatus(branches[0],kTRUE);</span>
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :         tree-&gt;SetBranchAddress(branches[0],&amp;vecDeltaITS);</span>
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :         if (fixAlignmentBugForFile) {</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :           tree-&gt;SetBranchStatus(branches[3],kTRUE);</span>
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :           tree-&gt;SetBranchAddress(branches[3],&amp;vecDeltaOtherITS);</span>
<span class="lineNum">    1052 </span>            :         }
<span class="lineNum">    1053 </span>            :       }
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :       else if (ihis&gt;2 &amp;&amp; ihis!=3){</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :         tree-&gt;SetBranchStatus(branches[3],kTRUE);</span>
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :         tree-&gt;SetBranchAddress(branches[3],&amp;vecDeltaITS);</span>
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :         if (fixAlignmentBugForFile) {</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :           tree-&gt;SetBranchStatus(branches[0],kTRUE);</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :           tree-&gt;SetBranchAddress(branches[0],&amp;vecDeltaOtherITS);</span>
<span class="lineNum">    1060 </span>            :         }
<span class="lineNum">    1061 </span>            :       }
<span class="lineNum">    1062 </span>            :       
<span class="lineNum">    1063 </span>            :       // prepare aux info for histo bin calculation
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :       Long64_t nBProd[kNDim] = {0};</span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :       int nBinDim[kNDim];</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :       double bsize[kNDim],bsizeI[kNDim],limMin[kNDim],limMax[kNDim];</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :       nBProd[kNDim1] = 1;</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :       THn* curHis = hisToFill[ihis];</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :       TNDArrayT&lt;float&gt;&amp; arrND = (TNDArrayT&lt;float&gt;&amp;)curHis-&gt;GetArray(); // for direct access</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :       for (int i=kNDim;i--;) {</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :         TAxis* ax = curHis-&gt;GetAxis(i);</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :         limMin[i] = ax-&gt;GetXmin();</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :         limMax[i] = ax-&gt;GetXmax();</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :         nBinDim[i] = ax-&gt;GetNbins();</span>
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :         bsize[i]  = (limMax[i]-limMin[i])/nBinDim[i];</span>
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :         bsizeI[i] = 1./bsize[i];</span>
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :         if (i&lt;kNDim1) nBProd[i] = nBProd[i+1]*(nBinDim[i+1]+2); // +2 to account for under/over-flows</span>
<span class="lineNum">    1078 </span>            :       }
<span class="lineNum">    1079 </span>            :       //
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :       Int_t ntracks=tree-&gt;GetEntries();</span>
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :       if (!autoCache) {</span>
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :         tree-&gt;SetCacheSize(0);</span>
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :         tree-&gt;SetCacheSize(cacheSize);</span>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :         tree-&gt;SetCacheLearnEntries(cacheLearnEntries);</span>
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :         tree-&gt;AddBranchToCache(&quot;*&quot;, kTRUE);</span>
<span class="lineNum">    1086 </span>            :       }
<span class="lineNum">    1087 </span>            :       //
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :       for (Int_t itrack=0; itrack&lt;ntracks; itrack++){</span>
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :         if (startTime&gt;0){</span>
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :           br-&gt;GetEntry(itrack);</span>
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :           if (timeStamp&lt;startTime  || timeStamp&gt;stopTime) continue;</span>
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :           hisTime-&gt;Fill(timeStamp);</span>
<span class="lineNum">    1093 </span>            :         }
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :         tree-&gt;GetEntry(itrack);</span>
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :         Double_t corrTime = (vdriftGraph!=NULL) ? vdriftGraph-&gt;Eval(timeStamp):0;</span>
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :         const Float_t *vSec= vecSec-&gt;GetMatrixArray();</span>
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :         const Float_t *vPhi= vecPhi-&gt;GetMatrixArray();</span>
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :         const Float_t *vR  = vecR-&gt;GetMatrixArray();</span>
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :         const Float_t *vZ  = vecZ-&gt;GetMatrixArray();</span>
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :         const Float_t *vDelta  = vecDelta-&gt;GetMatrixArray();</span>
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :         const Float_t *vDeltaITS  = (vecDeltaITS!=NULL) ? vecDeltaITS-&gt;GetMatrixArray():0;</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :         const Float_t *vDeltaOther = vecDeltaOther ? vecDeltaOther-&gt;GetMatrixArray():0;</span>
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :         const Float_t *vDeltaOtherITS = vecDeltaOtherITS ? vecDeltaOtherITS-&gt;GetMatrixArray():0;</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :         const Float_t *vLocalDelta=vecLocalDelta-&gt;GetMatrixArray();</span>
<span class="lineNum">    1105 </span>            :         //
<span class="lineNum">    1106 </span>            :         // calculate distance and aplly track and cluster quality cut
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :         Float_t rmsTrack=3, rmsCluster=1;</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :         Int_t nSkippedCluster=AliTPCcalibAlignInterpolation::CalculateDistance(*vecDelta,*vecDeltaITS, *vecSec, *vecLocalDelta, npValid, rmsTrack, rmsCluster,1.5);</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :         if (nSkippedCluster&gt;kMaxSkippedCluster) continue;</span>
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :         if (rmsTrack&gt;kMaxRMSTrackCut) continue;</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :         if (rmsCluster&gt;kMaxRMSClusterCut) continue;  </span>
<span class="lineNum">    1112 </span>            :         //
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :         currentTrack++;</span>
<span class="lineNum">    1114 </span>            : 
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :         if (timeStamp&lt;minTime) minTime=timeStamp;</span>
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :         if (timeStamp&gt;maxTime) maxTime=timeStamp;</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :         meanTime+=timeStamp;</span>
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :         if (treeInfo) for (Int_t iSec=0; iSec&lt;nSec; iSec++){</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :           meanNcl[iSec]+=nclArray[iSec]-&gt;Eval(timeStamp);</span>
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :           meanNclUsed[iSec]+=nclArrayUsed[iSec]-&gt;Eval(timeStamp);</span>
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1122 </span>            : 
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :         if (maxStat&gt;0 &amp;&amp;currentTrack&gt;maxStat) break;</span>
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :         double xxx[kNDim] = {0.};</span>
<span class="lineNum">    1125 </span>            :         //for (Int_t ipoint=0; ipoint&lt;knPoints; ipoint++){
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :         for (Int_t ipoint=0; ipoint&lt;npValid; ipoint++){</span>
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :           if (vR[ipoint]&lt;=0 || vDelta[ipoint]&lt;-990.) continue;</span>
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :           if (TMath::Abs(vDelta[ipoint])&lt;0.000001) continue; // RS Do we need this?</span>
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :           if (TMath::Abs(vLocalDelta[ipoint])&gt; kMaxDeltaClusterCut) continue;</span>
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :           float phiUse = vPhi[ipoint], rUse = vR[ipoint], zUse = vZ[ipoint];</span>
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :           float deltaITSUse = (vDeltaITS) ? vDeltaITS[ipoint]:0;</span>
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :           float deltaRefUse = vDelta[ipoint];</span>
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :           int rocID = TMath::Nint(vSec[ipoint]);</span>
<span class="lineNum">    1134 </span>            : 
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :           if (fixAlignmentBugForFile) { // was it produced w/o bug fix</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :             float dAux = vDeltaOther[ipoint];</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :             if (ihis&lt;3) FixAlignmentBug(rocID, param-&gt;GetParameter()[4], bz, phiUse, rUse, zUse, deltaRefUse, dAux);</span>
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :             else        FixAlignmentBug(rocID, param-&gt;GetParameter()[4], bz, phiUse, rUse, zUse, dAux, deltaRefUse);</span>
<span class="lineNum">    1139 </span>            :             //
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :             if (vDeltaITS) {</span>
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :               dAux = vDeltaOtherITS[ipoint];</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :               float phiAux = vPhi[ipoint], rAux = vR[ipoint], zAux = vZ[ipoint];</span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :               if (ihis&lt;3) FixAlignmentBug(rocID, param-&gt;GetParameter()[4], bz, phiAux, rAux, zAux, deltaITSUse, dAux);</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :               else        FixAlignmentBug(rocID, param-&gt;GetParameter()[4], bz, phiAux, rAux, zAux, dAux, deltaITSUse);</span>
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    1146 </span>            :             //
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    1148 </span>            :           //
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :           Double_t sector=9.*phiUse/TMath::Pi();</span>
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :           if (sector&lt;0) sector+=18;</span>
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :           Double_t deltaPhi=phiUse-TMath::Pi()*(Int_t(sector)+0.5)/9.;</span>
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :           Double_t localX = TMath::Cos(deltaPhi)*rUse;</span>
<span class="lineNum">    1153 </span>            : 
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :           xxx[kQ2PT] = param-&gt;GetParameter()[4];</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :           xxx[kSect] = sector;</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :           xxx[kLocX] = localX;</span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :           Double_t side=-1.+2.*((rocID%36)&lt;18);</span>
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :           double maxZ = kMaxZSect[side&lt;0];</span>
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :           xxx[kZ2X] = (zUse*side)&lt;-1 ? side*0.001 : zUse/localX; // do not mix z on A side and C side ?? RS</span>
<span class="lineNum">    1160 </span>            :           // apply drift velocity calibration if available
<span class="lineNum">    1161 </span>            :           
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :           if (ihis&gt;2){  // if z residuals and vdrift calibration existing</span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :             Double_t drift = (side&gt;0) ? maxZ-zUse : zUse+maxZ;</span>
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :             Double_t gy    = TMath::Sin(phiUse)*localX;</span>
<span class="lineNum">    1165 </span>            :             Double_t pvecFit[3];
<span class="lineNum">    1166 </span>            :             pvecFit[0]= side;             // z shift (cm)
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :             pvecFit[1]= drift*gy/maxZ;   // global y gradient</span>
<span class="lineNum">    1168 </span>            :             pvecFit[2]= drift;            // drift length
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :             Double_t expected = (vdriftParam!=NULL) ? (*vdriftParam)[0]+(*vdriftParam)[1]*pvecFit[0]+(*vdriftParam)[2]*pvecFit[1]+(*vdriftParam)[3]*pvecFit[2]:0;</span>
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :             deltaRefUse= side*(deltaRefUse*side-(expected+corrTime*drift));</span>
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :             deltaITSUse= side*(deltaITSUse*side-(expected+corrTime*drift));</span>
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :           xxx[kDelt] = deltaRefUse;</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :           clusterCounter++;</span>
<span class="lineNum">    1175 </span>            :           //
<span class="lineNum">    1176 </span>            :           // calculate axis bins and global bin
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :           Int_t binIndex[kNDim]={0};</span>
<span class="lineNum">    1178 </span>            :           //
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :           if (xxx[kNDim1]&lt;limMin[kNDim1]) binIndex[kNDim1] = 0; // underflow</span>
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :           else if (xxx[kNDim1]&lt;limMax[kNDim1]) binIndex[kNDim1] = 1+int((xxx[kNDim1] - limMin[kNDim1])*bsizeI[kNDim1]); // range</span>
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :           else binIndex[kNDim1] = nBinDim[kNDim1]+1; // oveflow</span>
<span class="lineNum">    1182 </span>            :           //
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :           ULong64_t binToFill = binIndex[kNDim1]; // global bin</span>
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :           for (int id=kNDim1;id--;) {</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :             if (xxx[id]&lt;limMin[id]) binIndex[id] = 0; // underflow</span>
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :             else if (xxx[id]&lt;limMax[id]) binIndex[id] = 1+int((xxx[id] - limMin[id])*bsizeI[id]); // range</span>
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :             else binIndex[id] = nBinDim[id]+1; // oveflow</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :             binToFill += binIndex[id]*nBProd[id];</span>
<span class="lineNum">    1189 </span>            :           }
<span class="lineNum">    1190 </span>            :           //
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :           if (vDeltaITS){</span>
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :             xxx[kDelt] = deltaITSUse;</span>
<span class="lineNum">    1193 </span>            :             int binDeltITS;
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :             if (deltaITSUse&lt;limMin[kDelt]) binDeltITS = 0; // underflow</span>
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :             else if (deltaITSUse&lt;limMax[kDelt]) binDeltITS = 1+int((deltaITSUse - limMin[kDelt])*bsizeI[kDelt]); // range</span>
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :             else binDeltITS = nBinDim[kDelt]+1; // oveflow</span>
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :             Long64_t binToFillITS = binToFill + (binDeltITS-binIndex[kDelt])*nBProd[kDelt]; // global bin for ITS</span>
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :             arrND.At(binToFillITS) += kFillGapITS;          // curHis-&gt;Fill(xxx,kFillGapITS);</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :             xxx[kDelt] = deltaRefUse;</span>
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :           arrND.At(binToFill) += 1.; // curHis-&gt;Fill(xxx,1.);</span>
<span class="lineNum">    1202 </span>            : 
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :           Double_t dbinCenter[kNDim];     </span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :           for (Int_t idim=kNDim;idim--;) {</span>
<span class="lineNum">    1205 </span>            :             // fractional distance to the center of the bin
<span class="lineNum">    1206 </span>            :             // double bincenter = limMin[idim]+bsize[idim]*(binIndex[idim]-0.5); // binindex=0 is underflow!
<span class="lineNum">    1207 </span>            :             // dbinCenter[idim] = (xxx[idim]-bincenter)*bsizeI[idim];
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :             dbinCenter[idim] = (xxx[idim]-limMin[idim])*bsize[idim] - (binIndex[idim]-0.5); // binindex=0 is underflow!</span>
<span class="lineNum">    1209 </span>            :           }
<span class="lineNum">    1210 </span>            :           // dbinCenter[kDelt] = 0;
<span class="lineNum">    1211 </span>            :           //
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :           for (Int_t iqpt=-1; iqpt&lt;=1; iqpt++){  //qpt</span>
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :             int qptBin = binIndex[kQ2PT]+iqpt;</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :             if (qptBin&lt;0||qptBin&gt;nBinDim[kQ2PT]) continue;</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :             double dqpt = dbinCenter[kQ2PT] + iqpt;</span>
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :             dqpt *= dqpt*kernelSigma2I[kQ2PT];</span>
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :             binToFill += iqpt*nBProd[kQ2PT];</span>
<span class="lineNum">    1218 </span>            :             //for (Int_t isec=0; isec&lt;=0; isec++){  //sector - (Not defined yet if we should make bin respone functio and unfold later) 
<span class="lineNum">    1219 </span>            :             //  int secBin = binIndex[kSect]+isec;
<span class="lineNum">    1220 </span>            :             //  if (secBin&lt;0||secBin&gt;nBinDim[kSect]) continue;
<span class="lineNum">    1221 </span>            :             //  double dsec = dbinCenter[kSect] + isec;
<span class="lineNum">    1222 </span>            :             //  dsec *= dsec*kernelSigma2I[kSect];
<span class="lineNum">    1223 </span>            :             //  binToFill += isec*nBProd[kSect];
<span class="lineNum">    1224 </span>            :             //  for (Int_t ilocx=0; ilocx&lt;=0; ilocx++){   //local X
<span class="lineNum">    1225 </span>            :             //    int locxBin = binIndex[kLocX]+ilocx;
<span class="lineNum">    1226 </span>            :             //    if (locxBin&lt;0||locxBin&gt;nBinDim[kLocX]) continue;
<span class="lineNum">    1227 </span>            :             //    double dlocx = dbinCenter[kLocX] + ilocx;
<span class="lineNum">    1228 </span>            :             //    dlocx *= dlocx*kernelSigma2I[kLocX];
<span class="lineNum">    1229 </span>            :             //    binToFill += ilocx*nBProd[kLocX];
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :             for (Int_t iz2x=-2; iz2x&lt;=2; iz2x++){ // Z/x</span>
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :               if ( xxx[kZ2X]*(xxx[kZ2X]+bsize[kZ2X]*iz2x) &lt; 0 ) continue; // do not mix a and C side</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :               int z2xBin = binIndex[kZ2X]+iz2x;</span>
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :               if (z2xBin&lt;0||z2xBin&gt;nBinDim[kZ2X]) continue; </span>
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :               double dz2x = dbinCenter[kZ2X] + iz2x;</span>
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :               dz2x *= dz2x*kernelSigma2I[kZ2X];</span>
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 :               binToFill += iz2x*nBProd[kZ2X];</span>
<span class="lineNum">    1237 </span>            :               //
<span class="lineNum">    1238 </span>            :               {
<span class="lineNum">    1239 </span>            :                 // Looping is over, fill histo
<span class="lineNum">    1240 </span><span class="lineNoCov">          0 :                 Double_t weightAll= 2.*(dz2x+dqpt); // 2.*(dz2x+dqpt+dsec+dlocx);</span>
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :                 weightAll = weightAll&gt;kMaxExpArg ? kFillGap : kFillGap+TMath::Exp(-weightAll);</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :                 arrND.At(binToFill) += weightAll; // curHis-&gt;Fill(...)</span>
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :                 if (fillCounter==0) printf(&quot;Start to Fill\n&quot;);</span>
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 :                 fillCounter++;</span>
<span class="lineNum">    1245 </span>            :               }
<span class="lineNum">    1246 </span>            :               //
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :               binToFill -= iz2x*nBProd[kZ2X];</span>
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :             } // z2x fill loop</span>
<span class="lineNum">    1249 </span>            :             //   binToFill -= ilocx*nBProd[kLocX];
<span class="lineNum">    1250 </span>            :             // }   // xloc fill loop          
<span class="lineNum">    1251 </span>            :             //    binToFill -= isec*nBProd[kSect];
<span class="lineNum">    1252 </span>            :             //  }     // sector fill loop 
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :             binToFill -= iqpt*nBProd[kQ2PT]; // restore</span>
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :           } // qpt fill loop</span>
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :       tree-&gt;PrintCacheStats();</span>
<span class="lineNum">    1258 </span>            : 
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :       timerFile.Print();</span>
<span class="lineNum">    1260 </span><span class="lineNoCov">          0 :       delete tree;</span>
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :       delete esdFile;</span>
<span class="lineNum">    1262 </span>            :       
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :     }    </span>
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :     fout-&gt;GetFile()-&gt;cd();</span>
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :     hisToFill[ihis]-&gt;Write();</span>
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :   AliSysInfo::AddStamp(&quot;FillHistogramsFromChain.END&quot;,2,1);</span>
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :   if (hisTime) hisTime-&gt;Write();</span>
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :   ::Info(&quot; AliTPCcalibAlignInterpolation::FillHistogramsFromChain&quot;,&quot;End of processing\n&quot;);</span>
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :   timerAll.Print();</span>
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :   printf(&quot;StatInfo.fillCounter:\t%lld\n&quot;,fillCounter);</span>
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :   printf(&quot;StatInfo.clusterCounter:\t%lld\n&quot;,clusterCounter);</span>
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :   printf(&quot;StatInfo.trackCounter:\t%d\n&quot;,currentTrack);</span>
<span class="lineNum">    1274 </span>            :   //
<span class="lineNum">    1275 </span>            :   // 2.) Fill metadata information
<span class="lineNum">    1276 </span>            :   //
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :   if (currentTrack&gt;0){</span>
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :     meanTime/=currentTrack;</span>
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :     if (treeInfo) for (Int_t iSec=0; iSec&lt;nSec; iSec++){</span>
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :       meanNcl[iSec]/=currentTrack;</span>
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :       meanNclUsed[iSec]/=currentTrack;</span>
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1283 </span>            :   }
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :   (*fout)&lt;&lt;&quot;metaData&quot;&lt;&lt;</span>
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :     &quot;runNumber=&quot;&lt;&lt;runNumber&lt;&lt;        // runNumber</span>
<span class="lineNum">    1286 </span><span class="lineNoCov">          0 :     &quot;selHis=&quot;&lt;&lt;selHis&lt;&lt;              // selected histogram type</span>
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 :     &quot;fillCounter=&quot;&lt;&lt;fillCounter&lt;&lt;    // number of histogram fills</span>
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :     &quot;clusterCounter=&quot;&lt;&lt;clusterCounter&lt;&lt;    // number of clusters used for fill</span>
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 :     &quot;startTime=&quot;&lt;&lt;startTime&lt;&lt;        // start time  as requested</span>
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :     &quot;stopTime=&quot;&lt;&lt;stopTime&lt;&lt;          // stop time as requested</span>
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :     &quot;meanTime=&quot;&lt;&lt;meanTime&lt;&lt;          // mean time </span>
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :     &quot;minTime=&quot;&lt;&lt;minTime&lt;&lt;            // minimal time stamp in data sample</span>
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :     &quot;maxTime=&quot;&lt;&lt;maxTime&lt;&lt;            // maximal time stamp in data sample</span>
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 :     &quot;ntracksUsed=&quot;&lt;&lt;currentTrack&lt;&lt;   // number of tracks acumulated in time interval</span>
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 :     &quot;meanNcl.=&quot;&lt;&lt;&amp;meanNcl&lt;&lt;          // current estimator - mean number of clusters</span>
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :     &quot;meanNclUsed.=&quot;&lt;&lt;&amp;meanNclUsed;   // current estimator - mean number of clusters</span>
<span class="lineNum">    1297 </span>            :   
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :   for (Int_t iSec=0; iSec&lt;nSec; iSec++){</span>
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 :     (*fout)&lt;&lt;&quot;metaData&quot;&lt;&lt;</span>
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :       TString::Format(&quot;grNcl%d.=&quot;,iSec).Data()&lt;&lt; nclArray[iSec]&lt;&lt;</span>
<span class="lineNum">    1301 </span><span class="lineNoCov">          0 :       TString::Format(&quot;grNclUsed%d.=&quot;,iSec).Data()&lt;&lt; nclArrayUsed[iSec];</span>
<span class="lineNum">    1302 </span>            :   }
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :   (*fout)&lt;&lt;&quot;metaData&quot;&lt;&lt;&quot;\n&quot;;</span>
<span class="lineNum">    1304 </span>            : 
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 :   delete fout;</span>
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 : }</span>
<a name="1307"><span class="lineNum">    1307 </span>            : </a>
<span class="lineNum">    1308 </span>            : 
<span class="lineNum">    1309 </span>            : void     AliTPCcalibAlignInterpolation::FillHistogramsFromStreamers(const char * residualList, Double_t dy, Double_t dz, Int_t downscale){
<span class="lineNum">    1310 </span>            :   /**
<span class="lineNum">    1311 </span>            :    * Input list of ErrParam trees as defined in the AliTPCtracker in debug mode 
<span class="lineNum">    1312 </span>            :    * @param residualList  text file with tree list
<span class="lineNum">    1313 </span>            :    * Output - ResidualHistograms.root file with hitogram within AliTPCcalibAlignInterpolation object
<span class="lineNum">    1314 </span>            :    residualList=&quot;residual.list&quot;
<span class="lineNum">    1315 </span>            :    dy=1; dz=1
<span class="lineNum">    1316 </span>            :    */
<span class="lineNum">    1317 </span>            :   //
<span class="lineNum">    1318 </span>            :   //
<span class="lineNum">    1319 </span>            :   // 
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :   AliTPCcalibAlignInterpolation * calibInterpolation = new  AliTPCcalibAlignInterpolation(&quot;calibInterpolation&quot;,&quot;calibInterpolation&quot;,kFALSE);</span>
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :   calibInterpolation-&gt;CreateResidualHistosInterpolation(dy,dz);</span>
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :   TString  esdList0 = gSystem-&gt;GetFromPipe(TString::Format(&quot;cat %s&quot;,residualList).Data());</span>
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :   TObjArray *esdArray= esdList0.Tokenize(&quot;\n&quot;);  </span>
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :   Int_t nesd = esdArray-&gt;GetEntriesFast();  </span>
<span class="lineNum">    1325 </span>            :   //
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :   THn *hisToFill[6]={calibInterpolation-&gt;GetHisITSDRPhi(), calibInterpolation-&gt;GetHisITSTRDDRPhi(),  calibInterpolation-&gt;GetHisITSTOFDRPhi(), calibInterpolation-&gt;GetHisITSDZ(), calibInterpolation-&gt;GetHisITSTRDDZ(),  calibInterpolation-&gt;GetHisITSTOFDZ()};</span>
<span class="lineNum">    1327 </span>            :   //
<span class="lineNum">    1328 </span>            :   //
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :   AliExternalTrackParam * param=0;</span>
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :   AliTPCclusterMI * cl=0;</span>
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :   Int_t iter=0;</span>
<span class="lineNum">    1332 </span>            :   Int_t currentCl=0;
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 :   for (Int_t iesd=0; iesd&lt;nesd; iesd++){</span>
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 :     TString fileNameString(esdArray-&gt;At(iesd)-&gt;GetName());</span>
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :     if (fileNameString.Contains(&quot;alien://&quot;) &amp;&amp; (!gGrid || (gGrid &amp;&amp; !gGrid-&gt;IsConnected()))) TGrid::Connect(&quot;alien://&quot;);</span>
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :     TFile *esdFile = TFile::Open(fileNameString.Data(),&quot;read&quot;);</span>
<span class="lineNum">    1337 </span><span class="lineNoCov">          0 :     if (!esdFile) continue;</span>
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :     TTree *tree = (TTree*)esdFile-&gt;Get(&quot;ErrParam&quot;); </span>
<span class="lineNum">    1339 </span><span class="lineNoCov">          0 :     if (!tree) continue;</span>
<span class="lineNum">    1340 </span><span class="lineNoCov">          0 :     tree-&gt;SetBranchAddress(&quot;Cl.&quot;,&amp;cl);</span>
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :     tree-&gt;SetBranchAddress(&quot;T.&quot;,&amp;param);    </span>
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :     tree-&gt;SetBranchAddress(&quot;iter&quot;,&amp;iter);    </span>
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :     Int_t nCl=tree-&gt;GetEntries();</span>
<span class="lineNum">    1344 </span><span class="lineNoCov">          0 :     for (Int_t iCl=0; iCl&lt;nCl; iCl+=downscale){</span>
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :       tree-&gt;GetEntry(iCl);</span>
<span class="lineNum">    1346 </span><span class="lineNoCov">          0 :       if (iCl%100000==0) printf(&quot;%d\n&quot;,iCl);</span>
<span class="lineNum">    1347 </span><span class="lineNoCov">          0 :       currentCl++;</span>
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 :       double alpSect = ((cl-&gt;GetDetector()%18)+0.5)*20*TMath::DegToRad();</span>
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :       double xyz[3] = {cl-&gt;GetX(),cl-&gt;GetY(),cl-&gt;GetZ()}; // sector tracking frame</span>
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :       param-&gt;Local2GlobalPosition(xyz,alpSect);      </span>
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :       Double_t phi = TMath::ATan2(xyz[1],xyz[0]);</span>
<span class="lineNum">    1352 </span><span class="lineNoCov">          0 :       Double_t radius=TMath::Sqrt(xyz[1]*xyz[1]+xyz[0]*xyz[0]);</span>
<span class="lineNum">    1353 </span><span class="lineNoCov">          0 :       param-&gt;Rotate(phi);</span>
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 :       param-&gt;PropagateTo(radius,0.); // for big distortion we should query field, for small deltas we are using straight approximtion </span>
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :       Double_t sector=9*phi/TMath::Pi();</span>
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 :       if (sector&lt;0) sector+=18;</span>
<span class="lineNum">    1357 </span><span class="lineNoCov">          0 :       Double_t deltaY=param-&gt;GetY();</span>
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 :       Double_t deltaZ=param-&gt;GetZ()-cl-&gt;GetZ();</span>
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :       Double_t localX = cl-&gt;GetX();</span>
<span class="lineNum">    1360 </span><span class="lineNoCov">          0 :       Double_t   zsignSector=((cl-&gt;GetDetector()%36)&lt;18) ? 1.:-1.;</span>
<span class="lineNum">    1361 </span><span class="lineNoCov">          0 :       if (zsignSector*cl-&gt;GetZ()&lt;0.) continue;</span>
<span class="lineNum">    1362 </span><span class="lineNoCov">          0 :       Double_t xxx[5]={ param-&gt;GetParameter()[4], sector, localX,   cl-&gt;GetZ()/cl-&gt;GetX(),  deltaY};</span>
<span class="lineNum">    1363 </span><span class="lineNoCov">          0 :       hisToFill[iter]-&gt;Fill(xxx);      </span>
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :       xxx[4]=deltaZ;</span>
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :       hisToFill[3+iter]-&gt;Fill(xxx);    </span>
<span class="lineNum">    1366 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1367 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :   TFile * fout = TFile::Open(&quot;ResidualHistograms.root&quot;,&quot;recreate&quot;);</span>
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :   calibInterpolation-&gt;GetHisITSDRPhi()-&gt;Write(&quot;deltaYIter0&quot;);</span>
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :   calibInterpolation-&gt;GetHisITSTRDDRPhi()-&gt;Write(&quot;deltaYIter1&quot;);</span>
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :   calibInterpolation-&gt;GetHisITSTOFDRPhi()-&gt;Write(&quot;deltaYIter2&quot;);</span>
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :   calibInterpolation-&gt;GetHisITSDZ()-&gt;Write(&quot;deltaZIter0&quot;);</span>
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 :   calibInterpolation-&gt;GetHisITSTRDDZ()-&gt;Write(&quot;deltaZIter1&quot;);</span>
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :   calibInterpolation-&gt;GetHisITSTOFDZ()-&gt;Write(&quot;deltaZIter2&quot;);</span>
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :   delete fout;</span>
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1377 </span>            : 
<span class="lineNum">    1378 </span>            : 
<a name="1379"><span class="lineNum">    1379 </span>            : </a>
<span class="lineNum">    1380 </span>            : 
<span class="lineNum">    1381 </span>            : TTree*  AliTPCcalibAlignInterpolation::AddFriendDistortionTree(TTree * tree, const char * fname,  const char *treeName, const char *friendAlias){
<span class="lineNum">    1382 </span>            :   //
<span class="lineNum">    1383 </span>            :   //
<span class="lineNum">    1384 </span>            :   //
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :   TFile * fin = TFile::Open(fname);</span>
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 :   if (fin==NULL) {</span>
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :     ::Error(&quot;AliTPCcalibAlignInterpolation::AddFriendDistortionTree&quot;, &quot;file %s not readable&quot;, fname);</span>
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1389 </span>            :   }
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :   TTree * treeFriend = (TTree*) fin-&gt;Get(treeName);</span>
<span class="lineNum">    1391 </span>            :   
<span class="lineNum">    1392 </span><span class="lineNoCov">          0 :   if (treeFriend==NULL){</span>
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :     ::Error(&quot;AliTPCcalibAlignInterpolation::AddFriendDistortionTree&quot;, &quot;file %s not readable&quot;, fname);</span>
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1395 </span>            :   }
<span class="lineNum">    1396 </span><span class="lineNoCov">          0 :   if (tree==NULL) {</span>
<span class="lineNum">    1397 </span>            :     tree = treeFriend;
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :     tree-&gt;SetName(&quot;Default&quot;);</span>
<span class="lineNum">    1399 </span><span class="lineNoCov">          0 :     tree-&gt;SetTitle(&quot;Default&quot;);</span>
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :     treeFriend = (TTree*) fin-&gt;Get(treeName);</span>
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1402 </span>            :   {
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :     tree-&gt;AddFriend(treeFriend,TString::Format(&quot;%s&quot;,friendAlias).Data());</span>
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 :     tree-&gt;SetAlias(TString::Format(&quot;%sOK&quot;,friendAlias).Data(),TString::Format(&quot;%s.rms&gt;0&amp;&amp;abs(%s.mean-%s.meanG)&lt;2&amp;&amp;%s.chi2G&gt;0&amp;&amp;%s.rmsG&lt;2&amp;&amp;%s.rmsG/%s.rms&lt;2&quot;,friendAlias,friendAlias,friendAlias,friendAlias,friendAlias,friendAlias,friendAlias).Data());</span>
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 :     tree-&gt;SetAlias(TString::Format(&quot;%sDrawOK&quot;,friendAlias).Data(),TString::Format(&quot;%s.rms&gt;0&amp;&amp;abs(%s.mean-%s.meanG)&lt;4&amp;&amp;%s.chi2G&gt;0&quot;,friendAlias,friendAlias,friendAlias,friendAlias).Data()); </span>
<span class="lineNum">    1406 </span>            :   }
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :   return tree;</span>
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 : }</span>
<a name="1409"><span class="lineNum">    1409 </span>            : </a>
<span class="lineNum">    1410 </span>            : //_____________________________________________________________________________
<span class="lineNum">    1411 </span>            : Bool_t AliTPCcalibAlignInterpolation::PropagateInTPCTo(AliExternalTrackParam* t, Double_t xk, Double_t rho,Double_t x0, Double_t mass) 
<span class="lineNum">    1412 </span>            : {
<span class="lineNum">    1413 </span>            :   //-----------------------------------------------------------------
<span class="lineNum">    1414 </span>            :   //  This function propagates a track to a reference plane x=xk.
<span class="lineNum">    1415 </span>            :   //  rho - density of the crossed matrial (g/cm^3)
<span class="lineNum">    1416 </span>            :   //  x0  - radiation length of the crossed material (g/cm^2) 
<span class="lineNum">    1417 </span>            :   //-----------------------------------------------------------------
<span class="lineNum">    1418 </span>            :   //
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :   Double_t old[3]={t-&gt;GetX(),t-&gt;GetY(),t-&gt;GetZ()};</span>
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :   Double_t b[3]; AliTrackerBase::GetBxByBz(old,b);</span>
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 :   if (!t-&gt;PropagateToBxByBz(xk,b)) return kFALSE;</span>
<span class="lineNum">    1422 </span>            : 
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :   Double_t d = TMath::Sqrt((t-&gt;GetX()-old[0])*(t-&gt;GetX()-old[0]) + </span>
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :                            (t-&gt;GetY()-old[1])*(t-&gt;GetY()-old[1]) + </span>
<span class="lineNum">    1425 </span><span class="lineNoCov">          0 :                            (t-&gt;GetZ()-old[2])*(t-&gt;GetZ()-old[2]));</span>
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 :   if (old[0] &lt; xk) d = -d;</span>
<span class="lineNum">    1427 </span><span class="lineNoCov">          0 :   if (!t-&gt;CorrectForMeanMaterial(d*rho/x0,d*rho,mass,</span>
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :                                  kFALSE,AliExternalTrackParam::BetheBlochGas)) return kFALSE;</span>
<span class="lineNum">    1429 </span>            : 
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :   return kTRUE;</span>
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 : }</span>
<a name="1432"><span class="lineNum">    1432 </span>            : </a>
<span class="lineNum">    1433 </span>            : //_____________________________________________________________________________
<span class="lineNum">    1434 </span>            : void AliTPCcalibAlignInterpolation::ExtractTPCGasData()
<span class="lineNum">    1435 </span>            : {
<span class="lineNum">    1436 </span>            :   // get TPC gas rho and X0
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :   double p0[3] = {90,1,45};</span>
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :   double p1[3] = {240,1,120};</span>
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :   double par[10];</span>
<span class="lineNum">    1440 </span><span class="lineNoCov">          0 :   AliTrackerBase::MeanMaterialBudget(p0,p1,par);</span>
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :   fRhoTPC = par[0]&gt;0 ? par[0] : 0.9e-3;</span>
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :   double l = par[4];</span>
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :   fX0TPC  = par[1]&gt;0 ? par[4]/par[1] : 28.94;</span>
<span class="lineNum">    1444 </span>            :   //
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :   AliInfoF(&quot;Propagation in TPC will use rho=%.2f X0=%.2f&quot;,fRhoTPC,fX0TPC);</span>
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 : }</span>
<a name="1447"><span class="lineNum">    1447 </span>            : </a>
<span class="lineNum">    1448 </span>            : 
<span class="lineNum">    1449 </span>            : void AliTPCcalibAlignInterpolation::MakeEventStatInfo(const char * inputList, Int_t timeInterval, Int_t id, Int_t skip){
<span class="lineNum">    1450 </span>            :   //
<span class="lineNum">    1451 </span>            :   /// Code to query statistical event information from the ResidualTrees.root file 
<span class="lineNum">    1452 </span>            :   /// output written to file residualInfo.root
<span class="lineNum">    1453 </span>            :   ///   \param const char * inputList - ascii file with input list
<span class="lineNum">    1454 </span>            :   ///   \param Int_t timeInterval     - length of time interval (beginning of time intervals rounded)
<span class="lineNum">    1455 </span>            :   ///   \param id                     - additional ID added to the tree
<span class="lineNum">    1456 </span>            :   ///   \param skip                   - parameter skip file
<span class="lineNum">    1457 </span>            :   /// Algorithm:
<span class="lineNum">    1458 </span>            :   ///   1.) Cache information per files - beginTime and endTime for file
<span class="lineNum">    1459 </span>            :   ///   2.) Cache information per time interval
<span class="lineNum">    1460 </span>            : 
<span class="lineNum">    1461 </span>            :   /*
<span class="lineNum">    1462 </span>            :     run=240204;
<span class="lineNum">    1463 </span>            :     GetResidualStatInfo(&quot;cat residual.list&quot;,300,run,1);
<span class="lineNum">    1464 </span>            :   */
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :   TObjArray *array = TString(gSystem-&gt;GetFromPipe(TString::Format(&quot;%s&quot;,inputList).Data())).Tokenize(&quot;\n&quot;);</span>
<span class="lineNum">    1466 </span><span class="lineNoCov">          0 :   Int_t nFiles=array-&gt;GetEntries();</span>
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 :   if (nFiles&lt;=0) {</span>
<span class="lineNum">    1468 </span><span class="lineNoCov">          0 :     ::Error(&quot;GetResidualStatInfo&quot;, &quot;Wrong input list %s&quot;, inputList);</span>
<span class="lineNum">    1469 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1470 </span>            :   }
<span class="lineNum">    1471 </span><span class="lineNoCov">          0 :   TStopwatch timer;</span>
<span class="lineNum">    1472 </span>            :   //
<span class="lineNum">    1473 </span>            :   // 1.) Cache information per files - beginTime and endTime for file
<span class="lineNum">    1474 </span>            :   //
<span class="lineNum">    1475 </span><span class="lineNoCov">          0 :   TStopwatch timer1;</span>
<span class="lineNum">    1476 </span><span class="lineNoCov">          0 :   TTreeSRedirector * pcstream = new TTreeSRedirector(&quot;residualInfo.root&quot;, &quot;recreate&quot;);</span>
<span class="lineNum">    1477 </span>            :   Int_t cacheSize=100000000; // 100 MBy cache
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :   if (gSystem-&gt;Getenv(&quot;treeCacheSize&quot;)) cacheSize=TString(gSystem-&gt;Getenv(&quot;treeCacheSize&quot;)).Atoi();</span>
<span class="lineNum">    1479 </span>            :   Bool_t autoCache = kFALSE;
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :   if (gSystem-&gt;Getenv(&quot;autoCacheSize&quot;)) autoCache = Bool_t(TString(gSystem-&gt;Getenv(&quot;autoCacheSize&quot;)).Atoi());</span>
<span class="lineNum">    1481 </span>            :   Int_t cacheLearnEntries = 1;
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 :   if (gSystem-&gt;Getenv(&quot;cacheLearnEntriesStatInfo&quot;)) {</span>
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 :     cacheLearnEntries = TString(gSystem-&gt;Getenv(&quot;cacheLearnEntriesStatInfo&quot;)).Atoi();</span>
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :   Printf(&quot;************* cacheSize = %d, autoCache = %d, cacheLearnEntries = %d&quot;, cacheSize, (Int_t)autoCache, cacheLearnEntries);</span>
<span class="lineNum">    1486 </span>            : 
<span class="lineNum">    1487 </span><span class="lineNoCov">          0 :   TChain * chainInfo  = AliXRDPROOFtoolkit::MakeChain(&quot;residual.list&quot;,&quot;eventInfo&quot;,0,-1);</span>
<span class="lineNum">    1488 </span><span class="lineNoCov">          0 :   if (!autoCache) {</span>
<span class="lineNum">    1489 </span><span class="lineNoCov">          0 :     chainInfo-&gt;SetCacheSize(cacheSize);</span>
<span class="lineNum">    1490 </span><span class="lineNoCov">          0 :     chainInfo-&gt;SetCacheLearnEntries(cacheLearnEntries);</span>
<span class="lineNum">    1491 </span>            :   }
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :   TChain * chainTracks  = AliXRDPROOFtoolkit::MakeChain(&quot;residual.list&quot;,&quot;delta&quot;,0,-1);</span>
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :   if (!autoCache) {</span>
<span class="lineNum">    1494 </span><span class="lineNoCov">          0 :     chainTracks-&gt;SetCacheSize(cacheSize);</span>
<span class="lineNum">    1495 </span><span class="lineNoCov">          0 :     chainTracks-&gt;SetCacheLearnEntries(cacheLearnEntries);</span>
<span class="lineNum">    1496 </span>            :   }
<span class="lineNum">    1497 </span>            :   //
<span class="lineNum">    1498 </span>            :   Int_t gidRounding=128;                        // git has to be rounded
<span class="lineNum">    1499 </span><span class="lineNoCov">          0 :   Int_t neventsAll=chainInfo-&gt;GetEntries();     // total amount of events</span>
<span class="lineNum">    1500 </span><span class="lineNoCov">          0 :   Int_t ntracksAll=chainTracks-&gt;GetEntries();   // total amount of tracks</span>
<span class="lineNum">    1501 </span>            : 
<span class="lineNum">    1502 </span>            :   //chainInfo-&gt;SetEstimate(-1);                 // using -1  make a problem - too much memory allocate with autimatic switch . crash in case of 4MBy limits in the next Draw 
<span class="lineNum">    1503 </span><span class="lineNoCov">          0 :   chainInfo-&gt;SetEstimate(neventsAll);   </span>
<span class="lineNum">    1504 </span><span class="lineNoCov">          0 :   chainInfo-&gt;Draw(&quot;timeStamp:gid/128&quot;,&quot;timeStamp&gt;0&quot;,&quot;goff&quot;);          </span>
<span class="lineNum">    1505 </span>            :   //
<span class="lineNum">    1506 </span>            :   //
<span class="lineNum">    1507 </span><span class="lineNoCov">          0 :   Long64_t minTime=0,maxTime=0;</span>
<span class="lineNum">    1508 </span><span class="lineNoCov">          0 :   double minGID=0,maxGID=0,meanGID=0,meanTime=0;</span>
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :   if (neventsAll) {</span>
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 :     double minTimeD=0,maxTimeD=0;</span>
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :     TStatToolkit::GetMinMaxMean(chainInfo-&gt;GetV1(),neventsAll,minTimeD,maxTimeD, meanTime);</span>
<span class="lineNum">    1512 </span><span class="lineNoCov">          0 :     minTime = minTimeD;</span>
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :     maxTime = maxTimeD;</span>
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 :     TStatToolkit::GetMinMaxMean(chainInfo-&gt;GetV2(),neventsAll,minGID,maxGID, meanGID);</span>
<span class="lineNum">    1515 </span><span class="lineNoCov">          0 :     minGID*=128;</span>
<span class="lineNum">    1516 </span><span class="lineNoCov">          0 :     maxGID*=128;</span>
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 :     meanGID*=128;</span>
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1519 </span><span class="lineNoCov">          0 :   (*pcstream)&lt;&lt;&quot;summary1&quot;&lt;&lt;</span>
<span class="lineNum">    1520 </span><span class="lineNoCov">          0 :     &quot;id=&quot;&lt;&lt;id&lt;&lt;                // chain id - usually should be run number</span>
<span class="lineNum">    1521 </span><span class="lineNoCov">          0 :     &quot;nevents=&quot;&lt;&lt;neventsAll&lt;&lt;   // total number of events</span>
<span class="lineNum">    1522 </span><span class="lineNoCov">          0 :     &quot;ntracks=&quot;&lt;&lt;ntracksAll&lt;&lt;   // total number of tracks</span>
<span class="lineNum">    1523 </span><span class="lineNoCov">          0 :     &quot;minTime=&quot;&lt;&lt;minTime&lt;&lt;      // minimal time stamp in sample</span>
<span class="lineNum">    1524 </span><span class="lineNoCov">          0 :     &quot;maxTime=&quot;&lt;&lt;maxTime&lt;&lt;      // max time stamp in sample</span>
<span class="lineNum">    1525 </span><span class="lineNoCov">          0 :     &quot;meanTime=&quot;&lt;&lt;meanTime&lt;&lt;    // mean time</span>
<span class="lineNum">    1526 </span><span class="lineNoCov">          0 :     &quot;minGID=&quot;&lt;&lt;minGID&lt;&lt;        // minimal event gid in sample (rounded to 128)</span>
<span class="lineNum">    1527 </span><span class="lineNoCov">          0 :     &quot;maxGID=&quot;&lt;&lt;maxGID&lt;&lt;        // max  event gid in sample (rounded to 128)</span>
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 :     &quot;meanGID=&quot;&lt;&lt;meanGID&lt;&lt;      // mean event gid in sample (rounded to 128)</span>
<span class="lineNum">    1529 </span>            :     &quot;\n&quot;;
<span class="lineNum">    1530 </span><span class="lineNoCov">          0 :   delete pcstream;</span>
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :   ::Info(&quot;GetResidualStatInfo&quot;,&quot;Total time&quot;);</span>
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :   timer1.Print();</span>
<span class="lineNum">    1533 </span>            :   //
<span class="lineNum">    1534 </span>            :   // 2.) Cache information per time interval
<span class="lineNum">    1535 </span>            :   //
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 :   TStopwatch timer2;</span>
<span class="lineNum">    1537 </span><span class="lineNoCov">          0 :   pcstream = new TTreeSRedirector(&quot;residualInfo.root&quot;, &quot;update&quot;);</span>
<span class="lineNum">    1538 </span>            :   //  Int_t entries = neventsAll;
<span class="lineNum">    1539 </span>            : 
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :   Long64_t minTimeQA = timeInterval*(minTime/timeInterval);</span>
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 :   Long64_t maxTimeQA = timeInterval*(1+(maxTime/timeInterval));</span>
<span class="lineNum">    1542 </span><span class="lineNoCov">          0 :   Int_t nIntervals=(maxTimeQA-minTimeQA)/timeInterval;</span>
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :   Int_t nIntervalsQA=(maxTimeQA-minTimeQA)/15;</span>
<span class="lineNum">    1544 </span>            :   //
<span class="lineNum">    1545 </span><span class="lineNoCov">          0 :   TH1F  * hisEvent= new TH1F(&quot;hisEvent&quot;,&quot;hisEvent&quot;,nIntervalsQA,minTimeQA,maxTimeQA);</span>
<span class="lineNum">    1546 </span>            :   const Int_t nSec=81; // 72 sector +5 sumarry info+ 4 medians
<span class="lineNum">    1547 </span><span class="lineNoCov">          0 :   TProfile * profArrayNcl[nSec]={0};</span>
<span class="lineNum">    1548 </span><span class="lineNoCov">          0 :   TProfile * profArrayNclUsed[nSec]={0};</span>
<span class="lineNum">    1549 </span><span class="lineNoCov">          0 :   TGraphErrors * grArrayNcl[nSec]={0};</span>
<span class="lineNum">    1550 </span><span class="lineNoCov">          0 :   TGraphErrors * grArrayNclUsed[nSec]={0};</span>
<span class="lineNum">    1551 </span><span class="lineNoCov">          0 :   TProfile * profArrayITSNcl[3]={0};</span>
<span class="lineNum">    1552 </span><span class="lineNoCov">          0 :   TGraphErrors * grArrayITSNcl[3]={0};</span>
<span class="lineNum">    1553 </span>            :   
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :   for (Int_t isec=0; isec&lt;nSec; isec++){</span>
<span class="lineNum">    1555 </span><span class="lineNoCov">          0 :     profArrayNcl[isec]=new TProfile(TString::Format(&quot;TPCnclSec%d&quot;,isec).Data(), TString::Format(&quot;TPCnclSec%d&quot;,isec).Data(), nIntervalsQA,minTimeQA,maxTimeQA);</span>
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 :     profArrayNclUsed[isec]=new TProfile(TString::Format(&quot;TPCnclUsedSec%d&quot;,isec).Data(), TString::Format(&quot;TPCnclUsedSec%d&quot;,isec).Data(), nIntervalsQA,minTimeQA,maxTimeQA);</span>
<span class="lineNum">    1557 </span>            :   }
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 :    for (Int_t iits=0; iits&lt;3; iits++){</span>
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :     profArrayITSNcl[iits]=new TProfile(TString::Format(&quot;ITSnclSec%d&quot;,iits).Data(), TString::Format(&quot;ITSnclSec%d&quot;,iits).Data(), nIntervalsQA,minTimeQA,maxTimeQA);    </span>
<span class="lineNum">    1560 </span>            :   }
<span class="lineNum">    1561 </span>            : 
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 :   TVectorF *vecNClTPC=0;</span>
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :   TVectorF *vecNClTPCused=0;</span>
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :   Int_t nITS[3]={0};</span>
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :   Int_t timeStamp=0;</span>
<span class="lineNum">    1566 </span><span class="lineNoCov">          0 :   for (Int_t iFile=0; iFile&lt;nFiles; iFile+=skip){</span>
<span class="lineNum">    1567 </span><span class="lineNoCov">          0 :     timer.Start();</span>
<span class="lineNum">    1568 </span><span class="lineNoCov">          0 :     TString fileName = array-&gt;At(iFile)-&gt;GetName();</span>
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :     if (fileName.Contains(&quot;alien://&quot;) &amp;&amp; (!gGrid || (gGrid &amp;&amp; !gGrid-&gt;IsConnected()))) TGrid::Connect(&quot;alien://&quot;);</span>
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :     printf(&quot;%d\t%s\n&quot;,iFile,fileName.Data());    </span>
<span class="lineNum">    1571 </span><span class="lineNoCov">          0 :     AliSysInfo::AddStamp(fileName.Data(),1,iFile);</span>
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :     TFile * f = TFile::Open(fileName.Data());</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :     if (f==NULL) continue;</span>
<span class="lineNum">    1574 </span><span class="lineNoCov">          0 :     TTree * treeInfo = (TTree*)f-&gt;Get(&quot;eventInfo&quot;); </span>
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :     if (treeInfo==NULL) continue;</span>
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 :     if (!autoCache) {</span>
<span class="lineNum">    1577 </span><span class="lineNoCov">          0 :       treeInfo-&gt;SetCacheSize(cacheSize);</span>
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 :       treeInfo-&gt;SetCacheLearnEntries(cacheLearnEntries);</span>
<span class="lineNum">    1579 </span>            :     }
<span class="lineNum">    1580 </span><span class="lineNoCov">          0 :     treeInfo-&gt;SetBranchAddress(&quot;vecNClTPC.&quot;,&amp;vecNClTPC);</span>
<span class="lineNum">    1581 </span><span class="lineNoCov">          0 :     treeInfo-&gt;SetBranchAddress(&quot;vecNClTPCused.&quot;,&amp;vecNClTPCused);</span>
<span class="lineNum">    1582 </span><span class="lineNoCov">          0 :     treeInfo-&gt;SetBranchAddress(&quot;nSPD&quot;,&amp;nITS[0]);</span>
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :     treeInfo-&gt;SetBranchAddress(&quot;nSDD&quot;,&amp;nITS[1]);</span>
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :     treeInfo-&gt;SetBranchAddress(&quot;nSSD&quot;,&amp;nITS[2]);</span>
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :     treeInfo-&gt;AddBranchToCache(treeInfo-&gt;GetBranch(&quot;vecNClTPC.&quot;), kTRUE);</span>
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :     treeInfo-&gt;AddBranchToCache(treeInfo-&gt;GetBranch(&quot;vecNClTPCused.&quot;), kTRUE);</span>
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :     treeInfo-&gt;AddBranchToCache(treeInfo-&gt;GetBranch(&quot;nSPD&quot;), kTRUE);</span>
<span class="lineNum">    1588 </span><span class="lineNoCov">          0 :     treeInfo-&gt;AddBranchToCache(treeInfo-&gt;GetBranch(&quot;nSDD&quot;), kTRUE);</span>
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :     treeInfo-&gt;AddBranchToCache(treeInfo-&gt;GetBranch(&quot;nSSD&quot;), kTRUE);</span>
<span class="lineNum">    1590 </span><span class="lineNoCov">          0 :     Bool_t hasTimeStamp=(treeInfo-&gt;GetBranch(&quot;timeStamp&quot;)!=NULL);</span>
<span class="lineNum">    1591 </span><span class="lineNoCov">          0 :     if (hasTimeStamp) treeInfo-&gt;SetBranchAddress(&quot;timeStamp&quot;,&amp;timeStamp);</span>
<span class="lineNum">    1592 </span><span class="lineNoCov">          0 :     if (!hasTimeStamp) ((TBranch*)(treeInfo-&gt;GetListOfBranches()-&gt;At(1)))-&gt;SetAddress(&amp;timeStamp);</span>
<span class="lineNum">    1593 </span><span class="lineNoCov">          0 :     treeInfo-&gt;AddBranchToCache(treeInfo-&gt;GetBranch(&quot;timeStamp&quot;), kTRUE);</span>
<span class="lineNum">    1594 </span><span class="lineNoCov">          0 :     Int_t treeEntries=treeInfo-&gt;GetEntries();</span>
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 :     for (Int_t iEntry=0; iEntry&lt;treeEntries; iEntry++){</span>
<span class="lineNum">    1596 </span><span class="lineNoCov">          0 :       treeInfo-&gt;GetEntry(iEntry);</span>
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :       hisEvent-&gt;Fill(timeStamp);</span>
<span class="lineNum">    1598 </span><span class="lineNoCov">          0 :       for (Int_t isec=0; isec&lt;72; isec++){</span>
<span class="lineNum">    1599 </span><span class="lineNoCov">          0 :         profArrayNcl[isec]-&gt;Fill(timeStamp, (*vecNClTPC)[isec]);</span>
<span class="lineNum">    1600 </span><span class="lineNoCov">          0 :         profArrayNclUsed[isec]-&gt;Fill(timeStamp, (*vecNClTPC)[isec]);</span>
<span class="lineNum">    1601 </span><span class="lineNoCov">          0 :         if (isec&lt;36){</span>
<span class="lineNum">    1602 </span><span class="lineNoCov">          0 :           if (isec&lt;18)       profArrayNcl[72]-&gt;Fill(timeStamp, (*vecNClTPC)[isec]);</span>
<span class="lineNum">    1603 </span><span class="lineNoCov">          0 :           if (isec&gt;=18) profArrayNcl[73]-&gt;Fill(timeStamp, (*vecNClTPC)[isec]);</span>
<span class="lineNum">    1604 </span><span class="lineNoCov">          0 :           if (isec&lt;18)       profArrayNclUsed[72]-&gt;Fill(timeStamp, (*vecNClTPCused)[isec]);</span>
<span class="lineNum">    1605 </span><span class="lineNoCov">          0 :           if (isec&gt;=18) profArrayNclUsed[73]-&gt;Fill(timeStamp, (*vecNClTPCused)[isec]);</span>
<span class="lineNum">    1606 </span>            :         }else{
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 :           if ((isec%36)&lt;18)  profArrayNcl[74]-&gt;Fill(timeStamp, (*vecNClTPC)[isec]);</span>
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 :           if ((isec%36)&gt;=18) profArrayNcl[75]-&gt;Fill(timeStamp, (*vecNClTPC)[isec]);</span>
<span class="lineNum">    1609 </span><span class="lineNoCov">          0 :           if ((isec%36)&lt;18)  profArrayNclUsed[74]-&gt;Fill(timeStamp, (*vecNClTPCused)[isec]);</span>
<span class="lineNum">    1610 </span><span class="lineNoCov">          0 :           if ((isec%36)&gt;=18) profArrayNclUsed[75]-&gt;Fill(timeStamp, (*vecNClTPCused)[isec]);</span>
<span class="lineNum">    1611 </span>            :         }
<span class="lineNum">    1612 </span><span class="lineNoCov">          0 :         profArrayNcl[76]-&gt;Fill(timeStamp, (*vecNClTPC)[isec]);</span>
<span class="lineNum">    1613 </span><span class="lineNoCov">          0 :         profArrayNclUsed[76]-&gt;Fill(timeStamp, (*vecNClTPCused)[isec]);</span>
<span class="lineNum">    1614 </span>            :       }
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :       profArrayNcl[77]-&gt;Fill(timeStamp, TMath::Median(18, &amp;((vecNClTPC-&gt;GetMatrixArray())[0])));</span>
<span class="lineNum">    1616 </span><span class="lineNoCov">          0 :       profArrayNcl[78]-&gt;Fill(timeStamp, TMath::Median(18, &amp;((vecNClTPC-&gt;GetMatrixArray())[18])));</span>
<span class="lineNum">    1617 </span><span class="lineNoCov">          0 :       profArrayNcl[79]-&gt;Fill(timeStamp, TMath::Median(18, &amp;((vecNClTPC-&gt;GetMatrixArray())[36])));</span>
<span class="lineNum">    1618 </span><span class="lineNoCov">          0 :       profArrayNcl[80]-&gt;Fill(timeStamp, TMath::Median(18, &amp;((vecNClTPC-&gt;GetMatrixArray())[54])));</span>
<span class="lineNum">    1619 </span>            :       //
<span class="lineNum">    1620 </span><span class="lineNoCov">          0 :       profArrayNclUsed[77]-&gt;Fill(timeStamp, TMath::Median(18, &amp;((vecNClTPCused-&gt;GetMatrixArray())[0])));</span>
<span class="lineNum">    1621 </span><span class="lineNoCov">          0 :       profArrayNclUsed[78]-&gt;Fill(timeStamp, TMath::Median(18, &amp;((vecNClTPCused-&gt;GetMatrixArray())[18])));</span>
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 :       profArrayNclUsed[79]-&gt;Fill(timeStamp, TMath::Median(18, &amp;((vecNClTPCused-&gt;GetMatrixArray())[36])));</span>
<span class="lineNum">    1623 </span><span class="lineNoCov">          0 :       profArrayNclUsed[80]-&gt;Fill(timeStamp, TMath::Median(18, &amp;((vecNClTPCused-&gt;GetMatrixArray())[54])));</span>
<span class="lineNum">    1624 </span><span class="lineNoCov">          0 :       for (Int_t iits=0; iits&lt;3; iits++){</span>
<span class="lineNum">    1625 </span><span class="lineNoCov">          0 :         profArrayITSNcl[iits]-&gt;Fill(timeStamp,nITS[iits]);</span>
<span class="lineNum">    1626 </span>            :       }
<span class="lineNum">    1627 </span>            :     }
<span class="lineNum">    1628 </span><span class="lineNoCov">          0 :     timer.Print();</span>
<span class="lineNum">    1629 </span><span class="lineNoCov">          0 :     treeInfo-&gt;PrintCacheStats();</span>
<span class="lineNum">    1630 </span><span class="lineNoCov">          0 :     AliSysInfo::AddStamp(fileName.Data(),2,iFile);</span>
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 :     delete treeInfo;</span>
<span class="lineNum">    1632 </span><span class="lineNoCov">          0 :     delete f;</span>
<span class="lineNum">    1633 </span><span class="lineNoCov">          0 :     AliSysInfo::AddStamp(fileName.Data(),3,iFile);</span>
<span class="lineNum">    1634 </span>            :     
<span class="lineNum">    1635 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :   timer2.Print();</span>
<span class="lineNum">    1637 </span><span class="lineNoCov">          0 :   TGraphErrors grEvent(hisEvent);</span>
<span class="lineNum">    1638 </span><span class="lineNoCov">          0 :   (*pcstream)&lt;&lt;&quot;summaryTime&quot;&lt;&lt;</span>
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 :     &quot;id=&quot;&lt;&lt;id&lt;&lt;</span>
<span class="lineNum">    1640 </span><span class="lineNoCov">          0 :     &quot;grEvent.=&quot;&lt;&lt;&amp;grEvent;</span>
<span class="lineNum">    1641 </span><span class="lineNoCov">          0 :   for (Int_t isec=0; isec&lt;nSec; isec++){</span>
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 :     grArrayNcl[isec] = new TGraphErrors((profArrayNcl[isec]));</span>
<span class="lineNum">    1643 </span><span class="lineNoCov">          0 :     grArrayNclUsed[isec] = new TGraphErrors((profArrayNclUsed[isec]));</span>
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :     (*pcstream)&lt;&lt;&quot;summaryTime&quot;&lt;&lt;</span>
<span class="lineNum">    1645 </span><span class="lineNoCov">          0 :       TString::Format(&quot;grNcl%d.=&quot;,isec).Data()&lt;&lt;grArrayNcl[isec]&lt;&lt;</span>
<span class="lineNum">    1646 </span><span class="lineNoCov">          0 :       TString::Format(&quot;grNclUsed%d.=&quot;,isec).Data()&lt;&lt;grArrayNclUsed[isec];</span>
<span class="lineNum">    1647 </span>            :   }
<span class="lineNum">    1648 </span><span class="lineNoCov">          0 :   for (Int_t iits=0; iits&lt;3; iits++){</span>
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 :     grArrayITSNcl[iits] = new TGraphErrors((profArrayITSNcl[iits]));</span>
<span class="lineNum">    1650 </span><span class="lineNoCov">          0 :     (*pcstream)&lt;&lt;&quot;summaryTime&quot;&lt;&lt;</span>
<span class="lineNum">    1651 </span><span class="lineNoCov">          0 :       TString::Format(&quot;grITSNcl%d.=&quot;,iits).Data()&lt;&lt;grArrayITSNcl[iits];</span>
<span class="lineNum">    1652 </span>            :   }
<span class="lineNum">    1653 </span>            :   
<span class="lineNum">    1654 </span>            :   
<span class="lineNum">    1655 </span><span class="lineNoCov">          0 :   (*pcstream)&lt;&lt;&quot;summaryTime&quot;&lt;&lt;&quot;\n&quot;;</span>
<span class="lineNum">    1656 </span><span class="lineNoCov">          0 :   for (Int_t isec=0; isec&lt;nSec; isec++){</span>
<span class="lineNum">    1657 </span><span class="lineNoCov">          0 :     delete      profArrayNcl[isec];</span>
<span class="lineNum">    1658 </span><span class="lineNoCov">          0 :     delete      profArrayNclUsed[isec];</span>
<span class="lineNum">    1659 </span><span class="lineNoCov">          0 :     delete      grArrayNcl[isec];</span>
<span class="lineNum">    1660 </span><span class="lineNoCov">          0 :     delete      grArrayNclUsed[isec];</span>
<span class="lineNum">    1661 </span>            :   }
<span class="lineNum">    1662 </span><span class="lineNoCov">          0 :   delete hisEvent;</span>
<span class="lineNum">    1663 </span><span class="lineNoCov">          0 :   delete pcstream;</span>
<span class="lineNum">    1664 </span>            : 
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :   printf(&quot;StatInfo.minTime\t%lld\n&quot;,minTime); //this formatting does not work on my Debian why it was changed ?</span>
<span class="lineNum">    1666 </span><span class="lineNoCov">          0 :   printf(&quot;StatInfo.maxTime\t%lld\n&quot;,maxTime);</span>
<span class="lineNum">    1667 </span>            :   //printf(&quot;StatInfo.minTime\t%f\n&quot;,Double_t(minTime)); //this formatting does not work on my Debian why it was changed ?
<span class="lineNum">    1668 </span>            :   //printf(&quot;StatInfo.maxTime\t%f\n&quot;,Double_t(maxTime));
<span class="lineNum">    1669 </span>            : 
<span class="lineNum">    1670 </span>            :   
<span class="lineNum">    1671 </span><span class="lineNoCov">          0 :   delete array;</span>
<span class="lineNum">    1672 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1673 </span>            : 
<a name="1674"><span class="lineNum">    1674 </span>            : </a>
<span class="lineNum">    1675 </span>            : 
<span class="lineNum">    1676 </span>            : Bool_t AliTPCcalibAlignInterpolation::FitDrift(double deltaT, double sigmaT, double time0, double_t time1,Bool_t fixAlignmentBug, Bool_t tofBCValidation){
<span class="lineNum">    1677 </span>            :   //
<span class="lineNum">    1678 </span>            :   //  Fit time dependence of the drift velocity for ITS-TRD and ITS-TOF scenario
<span class="lineNum">    1679 </span>            :   /*  Intput:
<span class="lineNum">    1680 </span>            :         &quot;residual.list&quot;   - ascii file with files assumed to be in working directory
<span class="lineNum">    1681 </span>            :         double deltaT     - time binning for drift velocity
<span class="lineNum">    1682 </span>            :         double sigmaT     - kernel width for time smoothing
<span class="lineNum">    1683 </span>            :         double time0      - starting time for drift velocity calculation
<span class="lineNum">    1684 </span>            :         double time1      - stop time for drift velocty calculation
<span class="lineNum">    1685 </span>            :         * in case time0 and time1 not specified - full time range in the selected sample used (time0=minTime, time1=maxTime)
<span class="lineNum">    1686 </span>            :       Output:
<span class="lineNum">    1687 </span>            :         &quot;fitDrift.root&quot;   - small file with the drift velocity calibration created  
<span class="lineNum">    1688 </span>            :          robustFit tree   - drift vlocity, time0, z shift and gy gradiend calibration using TLinearFitter::EvalRobust estimator
<span class="lineNum">    1689 </span>            :                           -   20 statistically independent values to QA procedure
<span class="lineNum">    1690 </span>            :                           -   resulting values choosen using robust median estimator
<span class="lineNum">    1691 </span>            :          fitTime          - set of graphs drift velocity as function of time
<span class="lineNum">    1692 </span>            :                           - n different graph values 
<span class="lineNum">    1693 </span>            :                           - resulting time dependent graph used as an logal regression with kernel sigmaT  per interval 
<span class="lineNum">    1694 </span>            :          fitTimeStat      - comparing median and local regression statistic 
<span class="lineNum">    1695 </span>            :   */  
<span class="lineNum">    1696 </span>            :   /*
<span class="lineNum">    1697 </span>            :     To do:
<span class="lineNum">    1698 </span>            :        - 1.) make version:
<span class="lineNum">    1699 </span>            :        - 1.a) with- without bunch 0 crossing 
<span class="lineNum">    1700 </span>            :        - 1.b) disentagle fit for the TRD and for the TOF
<span class="lineNum">    1701 </span>            :        - 2.) use time bin sigma estimate for the outlier rejection in the AliNDLocalFit fit 
<span class="lineNum">    1702 </span>            : 
<span class="lineNum">    1703 </span>            :    */
<span class="lineNum">    1704 </span>            :  
<span class="lineNum">    1705 </span>            :   /*
<span class="lineNum">    1706 </span>            :     fileList=&quot;residual.list&quot;
<span class="lineNum">    1707 </span>            :     time0=0; time1=0;
<span class="lineNum">    1708 </span>            :     deltaT=60; sigmaT=600
<span class="lineNum">    1709 </span>            :     fitDrift(60,00,0);
<span class="lineNum">    1710 </span>            :   */  
<span class="lineNum">    1711 </span>            :   const Double_t kMinEntries=1000;
<span class="lineNum">    1712 </span>            :   const Double_t kInvalidR = 70;
<span class="lineNum">    1713 </span>            :   const Double_t kInvalidRes = -900;
<span class="lineNum">    1714 </span>            :   const Double_t kMaxDist0=20;
<span class="lineNum">    1715 </span>            :   const Double_t kMaxDist1=5;
<span class="lineNum">    1716 </span>            :   const Double_t kDumpSample=0.01;
<span class="lineNum">    1717 </span>            :   const Double_t kBCcutMin=-5;
<span class="lineNum">    1718 </span>            :   const Double_t kBCcutMax=20;
<span class="lineNum">    1719 </span>            :   const Double_t robFraction=0.95;
<span class="lineNum">    1720 </span>            :   //const Double_t regRobust=0.0000000001;
<span class="lineNum">    1721 </span>            :   
<span class="lineNum">    1722 </span>            :   Int_t maxEntries=1000000;
<span class="lineNum">    1723 </span>            :   Int_t maxPointsRobust=4000000;
<span class="lineNum">    1724 </span>            :   //
<span class="lineNum">    1725 </span>            :   const Double_t kMaxZSect[2]={2.49725e+02,2.49698e+02};
<span class="lineNum">    1726 </span><span class="lineNoCov">          0 :   TCut  selection=&quot;&quot;;</span>
<span class="lineNum">    1727 </span>            :   Int_t entriesAll=0;
<span class="lineNum">    1728 </span><span class="lineNoCov">          0 :   Int_t runNumber=TString(gSystem-&gt;Getenv(&quot;runNumber&quot;)).Atoi();</span>
<span class="lineNum">    1729 </span>            : 
<span class="lineNum">    1730 </span>            :   Int_t cacheSize=100000000; // 100 MBy cache
<span class="lineNum">    1731 </span><span class="lineNoCov">          0 :   if (gSystem-&gt;Getenv(&quot;treeCacheSize&quot;)) cacheSize=TString(gSystem-&gt;Getenv(&quot;treeCacheSize&quot;)).Atoi();</span>
<span class="lineNum">    1732 </span>            :   Bool_t autoCache = kFALSE;
<span class="lineNum">    1733 </span><span class="lineNoCov">          0 :   if (gSystem-&gt;Getenv(&quot;autoCacheSize&quot;)) autoCache = Bool_t(TString(gSystem-&gt;Getenv(&quot;autoCacheSize&quot;)).Atoi());</span>
<span class="lineNum">    1734 </span>            :   Int_t cacheLearnEntries = 1;
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 :   if (gSystem-&gt;Getenv(&quot;cacheLearnEntriesVDrift&quot;)) {</span>
<span class="lineNum">    1736 </span><span class="lineNoCov">          0 :     cacheLearnEntries = TString(gSystem-&gt;Getenv(&quot;cacheLearnEntriesVDrift&quot;)).Atoi();</span>
<span class="lineNum">    1737 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1738 </span><span class="lineNoCov">          0 :   Printf(&quot;************* cacheSize = %d, autoCache = %d, cacheLearnEntries = %d&quot;, cacheSize, (Int_t)autoCache, cacheLearnEntries);</span>
<span class="lineNum">    1739 </span>            : 
<span class="lineNum">    1740 </span>            :   //
<span class="lineNum">    1741 </span>            :   //
<span class="lineNum">    1742 </span><span class="lineNoCov">          0 :   if (deltaT&lt;=0 || sigmaT&lt;=0){</span>
<span class="lineNum">    1743 </span><span class="lineNoCov">          0 :     ::Error(&quot;AliTPCcalibAlignInterpolation::FitDrift FAILED &quot;,&quot;Invalid parameter value for the deltaT %.1f and sigmaT %.1f&quot;, deltaT, sigmaT);</span>
<span class="lineNum">    1744 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">    1745 </span>            :   }
<span class="lineNum">    1746 </span><span class="lineNoCov">          0 :   if (TString(gSystem-&gt;GetFromPipe(&quot;cat residual.list | grep -c alien://&quot;)).Atoi()&gt;0) TGrid::Connect(&quot;alien&quot;);</span>
<span class="lineNum">    1747 </span>            : 
<span class="lineNum">    1748 </span><span class="lineNoCov">          0 :   TChain * chainDelta = AliXRDPROOFtoolkit::MakeChain(&quot;residual.list&quot;,&quot;delta&quot;,0,-1);</span>
<span class="lineNum">    1749 </span>            :   //
<span class="lineNum">    1750 </span>            :   // before doing anything else, check if alignment bug indeed must be fixed
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :   Bool_t fixAlignmentBugForFile = fixAlignmentBug;</span>
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :   AliExternalTrackParam* param = 0;</span>
<span class="lineNum">    1753 </span><span class="lineNoCov">          0 :   if (fixAlignmentBugForFile) {</span>
<span class="lineNum">    1754 </span><span class="lineNoCov">          0 :     TBranch *brParam = chainDelta-&gt;GetBranch(&quot;track.&quot;);</span>
<span class="lineNum">    1755 </span><span class="lineNoCov">          0 :     brParam-&gt;SetAddress(&amp;param);</span>
<span class="lineNum">    1756 </span><span class="lineNoCov">          0 :     brParam-&gt;GetEntry(0);</span>
<span class="lineNum">    1757 </span><span class="lineNoCov">          0 :     if (param-&gt;TestBit(kAlignmentBugFixedBit)) {</span>
<span class="lineNum">    1758 </span><span class="lineNoCov">          0 :       ::Info(&quot; AliTPCcalibAlignInterpolation::FitDrift&quot;,</span>
<span class="lineNum">    1759 </span>            :              &quot;AlignmentBugFix is requested but is not needed for this chunk\n&quot;);
<span class="lineNum">    1760 </span>            :       fixAlignmentBugForFile = kFALSE;
<span class="lineNum">    1761 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1762 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1763 </span>            :   //
<span class="lineNum">    1764 </span><span class="lineNoCov">          0 :   if (!autoCache) {</span>
<span class="lineNum">    1765 </span><span class="lineNoCov">          0 :     chainDelta-&gt;SetCacheSize(0);</span>
<span class="lineNum">    1766 </span><span class="lineNoCov">          0 :     chainDelta-&gt;SetCacheSize(cacheSize);</span>
<span class="lineNum">    1767 </span><span class="lineNoCov">          0 :     chainDelta-&gt;SetCacheLearnEntries(cacheLearnEntries);</span>
<span class="lineNum">    1768 </span>            :   }
<span class="lineNum">    1769 </span><span class="lineNoCov">          0 :   AliSysInfo::AddStamp(&quot;FitDrift.chainDeltaGetEntriesBegin&quot;,1,0,0);</span>
<span class="lineNum">    1770 </span><span class="lineNoCov">          0 :   entriesAll = chainDelta-&gt;GetEntries();</span>
<span class="lineNum">    1771 </span><span class="lineNoCov">          0 :   AliSysInfo::AddStamp(&quot;FitDrift.chainDeltaGetEntriesEnd&quot;,1,1,0);</span>
<span class="lineNum">    1772 </span>            : 
<span class="lineNum">    1773 </span><span class="lineNoCov">          0 :   if (entriesAll&lt;kMinEntries) {</span>
<span class="lineNum">    1774 </span><span class="lineNoCov">          0 :     ::Error(&quot;fitDrift FAILED&quot;,&quot;Not enough tracks in the chain.  Ntracks=%d&quot;,entriesAll); </span>
<span class="lineNum">    1775 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">    1776 </span>            :   }
<span class="lineNum">    1777 </span><span class="lineNoCov">          0 :   maxEntries=TMath::Min(maxEntries, entriesAll);</span>
<span class="lineNum">    1778 </span><span class="lineNoCov">          0 :   TTreeSRedirector *pcstream = new TTreeSRedirector(&quot;fitDrift.root&quot;,&quot;recreate&quot;);</span>
<span class="lineNum">    1779 </span><span class="lineNoCov">          0 :   if (time0==time1){ </span>
<span class="lineNum">    1780 </span><span class="lineNoCov">          0 :     AliSysInfo::AddStamp(&quot;FitDrift.chainInfoGetTimeBegin&quot;,2,0,0);</span>
<span class="lineNum">    1781 </span><span class="lineNoCov">          0 :     TChain * chainInfo=  AliXRDPROOFtoolkit::MakeChain(&quot;residual.list&quot;,&quot;eventInfo&quot;,0,-1); </span>
<span class="lineNum">    1782 </span><span class="lineNoCov">          0 :     if (!autoCache) {</span>
<span class="lineNum">    1783 </span><span class="lineNoCov">          0 :       chainInfo-&gt;SetCacheSize(cacheSize);</span>
<span class="lineNum">    1784 </span><span class="lineNoCov">          0 :       chainInfo-&gt;SetCacheLearnEntries(cacheLearnEntries);</span>
<span class="lineNum">    1785 </span>            :     }
<span class="lineNum">    1786 </span>            :     //    chainInfo-&gt;SetEstimate(-1); // i cashed here -1 does not work
<span class="lineNum">    1787 </span><span class="lineNoCov">          0 :     chainInfo-&gt;SetEstimate(maxEntries); // i cashed here -1 does not work</span>
<span class="lineNum">    1788 </span><span class="lineNoCov">          0 :     Int_t entries = chainInfo-&gt;Draw(&quot;timeStamp&quot;,&quot;&quot;,&quot;goff&quot;,maxEntries);</span>
<span class="lineNum">    1789 </span><span class="lineNoCov">          0 :     chainInfo-&gt;PrintCacheStats();</span>
<span class="lineNum">    1790 </span><span class="lineNoCov">          0 :     AliSysInfo::AddStamp(&quot;FitDrift.chainInfoGetTimeEND&quot;,2,1,0);</span>
<span class="lineNum">    1791 </span><span class="lineNoCov">          0 :     if (entries) TStatToolkit::GetMinMax(chainInfo-&gt;GetV1(),entries,time0,time1);</span>
<span class="lineNum">    1792 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1793 </span>            :   // 0.) Cache variables:  to be done using loop
<span class="lineNum">    1794 </span>            :   //     Variables to cache:
<span class="lineNum">    1795 </span>            :   //       tof1.fElements
<span class="lineNum">    1796 </span>            :   //       trd1.fElements
<span class="lineNum">    1797 </span>            :   //       vecZ.fElements
<span class="lineNum">    1798 </span>            :   //       vecR.fElements
<span class="lineNum">    1799 </span>            :   //       vecSec.fElements
<span class="lineNum">    1800 </span>            :   //       vecPhi.fElements
<span class="lineNum">    1801 </span>            :   //       timeStamp
<span class="lineNum">    1802 </span>            :   //       npValid
<span class="lineNum">    1803 </span>            :   //
<span class="lineNum">    1804 </span><span class="lineNoCov">          0 :   AliSysInfo::AddStamp(&quot;FitDrift.StartCache&quot;,3,0,0);</span>
<span class="lineNum">    1805 </span>            : 
<span class="lineNum">    1806 </span><span class="lineNoCov">          0 :   float bz = fixAlignmentBugForFile ? InitForAlignmentBugFix(runNumber) : 0;</span>
<span class="lineNum">    1807 </span>            : 
<span class="lineNum">    1808 </span>            :   // check if TOF was present
<span class="lineNum">    1809 </span>            :   const float tofBCMin = -25.f;
<span class="lineNum">    1810 </span>            :   const float tofBCMax = 50.f;
<span class="lineNum">    1811 </span>            :   //
<span class="lineNum">    1812 </span><span class="lineNoCov">          0 :   if (tofBCValidation) {</span>
<span class="lineNum">    1813 </span><span class="lineNoCov">          0 :     AliCDBManager* man = AliCDBManager::Instance();</span>
<span class="lineNum">    1814 </span><span class="lineNoCov">          0 :     if (!man-&gt;IsDefaultStorageSet()) man-&gt;SetDefaultStorage(&quot;raw://&quot;);</span>
<span class="lineNum">    1815 </span><span class="lineNoCov">          0 :     if (man-&gt;GetRun()&lt;0) man-&gt;SetRun(runNumber);  </span>
<span class="lineNum">    1816 </span><span class="lineNoCov">          0 :     AliGRPObject* grp = (AliGRPObject*)man-&gt;Get(AliCDBPath(&quot;GRP/GRP/Data&quot;))-&gt;GetObject();</span>
<span class="lineNum">    1817 </span><span class="lineNoCov">          0 :     Int_t activeDetectors = grp-&gt;GetDetectorMask();</span>
<span class="lineNum">    1818 </span><span class="lineNoCov">          0 :     if (!(activeDetectors&amp;AliDAQ::DetectorPattern(&quot;TOF&quot;))) {</span>
<span class="lineNum">    1819 </span><span class="lineNoCov">          0 :       AliWarningClass(&quot;Disabling TOF BC validation since TOF is not in the GRP&quot;);</span>
<span class="lineNum">    1820 </span>            :       tofBCValidation = kFALSE;
<span class="lineNum">    1821 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1822 </span>            :     else {
<span class="lineNum">    1823 </span><span class="lineNoCov">          0 :       AliInfoClassF(&quot;TOF BC validation is enabled with window %.2f : %.2f ns&quot;,tofBCMin,tofBCMax);</span>
<span class="lineNum">    1824 </span>            :     }
<span class="lineNum">    1825 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1826 </span>            :   //
<span class="lineNum">    1827 </span><span class="lineNoCov">          0 :   chainDelta-&gt;SetEstimate(maxEntries*160/5.);</span>
<span class="lineNum">    1828 </span><span class="lineNoCov">          0 :   TString toRead = &quot;tof1.fElements:trd1.fElements:vecZ.fElements:vecR.fElements:vecSec.fElements:vecPhi.fElements:timeStamp:tofBC:its1.fElements&quot;;</span>
<span class="lineNum">    1829 </span><span class="lineNoCov">          0 :   TString cutEv = &quot;Entry$%5==0 &amp;&amp; vecR.fElements&gt;10&quot;;</span>
<span class="lineNum">    1830 </span><span class="lineNoCov">          0 :   if (tofBCValidation) cutEv += Form(&quot; &amp;&amp; tofOK &amp;&amp; !(tofBC&lt;%.3f || tofBC&gt;%.3f)&quot;,tofBCMin,tofBCMax);</span>
<span class="lineNum">    1831 </span>            :   //
<span class="lineNum">    1832 </span><span class="lineNoCov">          0 :   if (fixAlignmentBugForFile) toRead += &quot;:tof0.fElements:trd0.fElements:track.fP[4]&quot;; // needed only in case we need to fix alignment bug</span>
<span class="lineNum">    1833 </span>            :   //
<span class="lineNum">    1834 </span><span class="lineNoCov">          0 :   Int_t entriesFit0 = chainDelta-&gt;Draw(toRead.Data(),cutEv.Data(),&quot;goffpara&quot;,maxEntries); </span>
<span class="lineNum">    1835 </span><span class="lineNoCov">          0 :   chainDelta-&gt;PrintCacheStats();</span>
<span class="lineNum">    1836 </span><span class="lineNoCov">          0 :   AliInfoClassF(&quot;Selected %d points from first %d entries&quot;,entriesFit0,maxEntries);</span>
<span class="lineNum">    1837 </span>            :   
<span class="lineNum">    1838 </span>            :   float lossFactorOK = 0.5f; // allowed loss factor
<span class="lineNum">    1839 </span><span class="lineNoCov">          0 :   float lossFactor = entriesFit0*5./160./maxEntries;</span>
<span class="lineNum">    1840 </span>            :   int prescaling = 10;
<span class="lineNum">    1841 </span><span class="lineNoCov">          0 :   if (lossFactor &lt; lossFactorOK) {</span>
<span class="lineNum">    1842 </span><span class="lineNoCov">          0 :     prescaling = TMath::Max(lossFactor/lossFactorOK,2.0f);</span>
<span class="lineNum">    1843 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1844 </span><span class="lineNoCov">          0 :   Int_t entriesFit=entriesFit0/prescaling;</span>
<span class="lineNum">    1845 </span><span class="lineNoCov">          0 :   AliInfoClassF(&quot;Selection loss factor: %f -&gt; random prescaling: %d -&gt; entriesFit: %d&quot;,lossFactor,prescaling,entriesFit);</span>
<span class="lineNum">    1846 </span>            : 
<span class="lineNum">    1847 </span><span class="lineNoCov">          0 :   AliSysInfo::AddStamp(&quot;FitDrift.EndCache&quot;,3,1,0);</span>
<span class="lineNum">    1848 </span>            : 
<span class="lineNum">    1849 </span><span class="lineNoCov">          0 :   AliSysInfo::AddStamp(&quot;FitDrift.BeginFill&quot;,4,1,0);</span>
<span class="lineNum">    1850 </span>            : 
<span class="lineNum">    1851 </span><span class="lineNoCov">          0 :   TVectorD * deltaZTOF  = new TVectorD(entriesFit); //</span>
<span class="lineNum">    1852 </span><span class="lineNoCov">          0 :   TVectorD * deltaZTRD  = new TVectorD(entriesFit); //</span>
<span class="lineNum">    1853 </span><span class="lineNoCov">          0 :   TVectorD * deltaYTOF  = new TVectorD(entriesFit); //</span>
<span class="lineNum">    1854 </span><span class="lineNoCov">          0 :   TVectorD * deltaYTRD  = new TVectorD(entriesFit); //</span>
<span class="lineNum">    1855 </span><span class="lineNoCov">          0 :   TVectorD * vecZ      = new TVectorD(entriesFit); //</span>
<span class="lineNum">    1856 </span><span class="lineNoCov">          0 :   TVectorD * vecR      = new TVectorD(entriesFit); //</span>
<span class="lineNum">    1857 </span><span class="lineNoCov">          0 :   TVectorD * vecSec    = new TVectorD(entriesFit); //</span>
<span class="lineNum">    1858 </span><span class="lineNoCov">          0 :   TVectorD * vecPhi    = new TVectorD(entriesFit); //</span>
<span class="lineNum">    1859 </span><span class="lineNoCov">          0 :   TVectorD * vecTime   = new TVectorD(entriesFit); //</span>
<span class="lineNum">    1860 </span><span class="lineNoCov">          0 :   TVectorD * vecTOFBC   = new TVectorD(entriesFit); //</span>
<span class="lineNum">    1861 </span><span class="lineNoCov">          0 :   TVectorD * deltaZITS  = new TVectorD(entriesFit); //</span>
<span class="lineNum">    1862 </span>            :   
<span class="lineNum">    1863 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;entriesFit; i++){</span>
<span class="lineNum">    1864 </span><span class="lineNoCov">          0 :     Int_t index=gRandom-&gt;Rndm()*entriesFit0;</span>
<span class="lineNum">    1865 </span><span class="lineNoCov">          0 :     (*deltaZTOF)[i]= chainDelta-&gt;GetVal(0)[index];</span>
<span class="lineNum">    1866 </span><span class="lineNoCov">          0 :     (*deltaZTRD)[i]= chainDelta-&gt;GetVal(1)[index];</span>
<span class="lineNum">    1867 </span><span class="lineNoCov">          0 :     (*vecZ)[i]= chainDelta-&gt;GetVal(2)[index];</span>
<span class="lineNum">    1868 </span><span class="lineNoCov">          0 :     (*vecR)[i]= chainDelta-&gt;GetVal(3)[index];</span>
<span class="lineNum">    1869 </span><span class="lineNoCov">          0 :     (*vecSec)[i]= chainDelta-&gt;GetVal(4)[index];</span>
<span class="lineNum">    1870 </span><span class="lineNoCov">          0 :     (*vecPhi)[i]= chainDelta-&gt;GetVal(5)[index];</span>
<span class="lineNum">    1871 </span><span class="lineNoCov">          0 :     (*vecTime)[i]= chainDelta-&gt;GetVal(6)[index];    </span>
<span class="lineNum">    1872 </span><span class="lineNoCov">          0 :     (*vecTOFBC)[i]= chainDelta-&gt;GetVal(7)[index];    </span>
<span class="lineNum">    1873 </span><span class="lineNoCov">          0 :     (*deltaZITS)[i]= chainDelta-&gt;GetVal(8)[index];</span>
<span class="lineNum">    1874 </span>            :     //
<span class="lineNum">    1875 </span><span class="lineNoCov">          0 :     if ( (*vecR)[i] &lt; kInvalidR ) continue; // there was no cluster at this point</span>
<span class="lineNum">    1876 </span>            :     // if needed, fix alignment bug 
<span class="lineNum">    1877 </span><span class="lineNoCov">          0 :     if (fixAlignmentBugForFile) {</span>
<span class="lineNum">    1878 </span><span class="lineNoCov">          0 :       float dyTOF = chainDelta-&gt;GetVal(9)[index];</span>
<span class="lineNum">    1879 </span><span class="lineNoCov">          0 :       float dyTRD = chainDelta-&gt;GetVal(10)[index];</span>
<span class="lineNum">    1880 </span><span class="lineNoCov">          0 :       float q2pt = chainDelta-&gt;GetVal(11)[index];</span>
<span class="lineNum">    1881 </span>            :       //
<span class="lineNum">    1882 </span><span class="lineNoCov">          0 :       float dzITS = (*deltaZITS)[i];</span>
<span class="lineNum">    1883 </span><span class="lineNoCov">          0 :       float dzTOF = (*deltaZTOF)[i];</span>
<span class="lineNum">    1884 </span><span class="lineNoCov">          0 :       float dzTRD = (*deltaZTRD)[i];</span>
<span class="lineNum">    1885 </span><span class="lineNoCov">          0 :       float rTOF  = (*vecR)[i], rTRD = rTOF;</span>
<span class="lineNum">    1886 </span><span class="lineNoCov">          0 :       float zTOF  = (*vecZ)[i] + dzTOF-dzITS , zTRD = (*vecZ)[i] + dzTRD-dzITS;</span>
<span class="lineNum">    1887 </span><span class="lineNoCov">          0 :       float phiTOF= (*vecPhi)[i], phiTRD = phiTOF;</span>
<span class="lineNum">    1888 </span>            :       
<span class="lineNum">    1889 </span><span class="lineNoCov">          0 :       int rocID = TMath::Nint((*vecSec)[i]);</span>
<span class="lineNum">    1890 </span>            : 
<span class="lineNum">    1891 </span><span class="lineNoCov">          0 :       if (dyTOF&gt;kInvalidRes) {</span>
<span class="lineNum">    1892 </span><span class="lineNoCov">          0 :         FixAlignmentBug(rocID, q2pt, bz, phiTOF, rTOF, zTOF, dyTOF, dzTOF);</span>
<span class="lineNum">    1893 </span><span class="lineNoCov">          0 :         (*deltaZTOF)[i] = dzTOF;</span>
<span class="lineNum">    1894 </span><span class="lineNoCov">          0 :         (*vecR)[i]      = rTOF;</span>
<span class="lineNum">    1895 </span><span class="lineNoCov">          0 :         (*vecZ)[i]      = zTOF;</span>
<span class="lineNum">    1896 </span><span class="lineNoCov">          0 :         (*vecPhi)[i]    = phiTOF;</span>
<span class="lineNum">    1897 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1898 </span><span class="lineNoCov">          0 :       if (dyTRD&gt;kInvalidRes) {</span>
<span class="lineNum">    1899 </span><span class="lineNoCov">          0 :         FixAlignmentBug(rocID, q2pt, bz, phiTRD, rTRD, zTRD, dyTRD, dzTRD);</span>
<span class="lineNum">    1900 </span>            :         //
<span class="lineNum">    1901 </span><span class="lineNoCov">          0 :         (*deltaZTRD)[i] = dzTRD;</span>
<span class="lineNum">    1902 </span><span class="lineNoCov">          0 :         (*vecR)[i]      = rTRD;</span>
<span class="lineNum">    1903 </span><span class="lineNoCov">          0 :         (*vecZ)[i]      = zTRD;</span>
<span class="lineNum">    1904 </span><span class="lineNoCov">          0 :         (*vecPhi)[i]    = phiTRD;</span>
<span class="lineNum">    1905 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1906 </span>            :       //
<span class="lineNum">    1907 </span><span class="lineNoCov">          0 :     }    </span>
<span class="lineNum">    1908 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1909 </span><span class="lineNoCov">          0 :   AliSysInfo::AddStamp(&quot;FitDrift.EndFill&quot;,4,1,0);</span>
<span class="lineNum">    1910 </span>            : 
<span class="lineNum">    1911 </span>            : 
<span class="lineNum">    1912 </span>            :   //
<span class="lineNum">    1913 </span>            :   // 1.) Make robust first estimate
<span class="lineNum">    1914 </span>            :   //
<span class="lineNum">    1915 </span><span class="lineNoCov">          0 :   TVectorD paramRobust(5);  </span>
<span class="lineNum">    1916 </span><span class="lineNoCov">          0 :   TVectorD paramTRD(5);  </span>
<span class="lineNum">    1917 </span><span class="lineNoCov">          0 :   TVectorD paramTOF(5);  </span>
<span class="lineNum">    1918 </span><span class="lineNoCov">          0 :   TVectorD paramRobustBC(5);  </span>
<span class="lineNum">    1919 </span><span class="lineNoCov">          0 :   TVectorD paramTRDBC(5);  </span>
<span class="lineNum">    1920 </span><span class="lineNoCov">          0 :   TVectorD paramTOFBC(5);</span>
<span class="lineNum">    1921 </span>            :   //  
<span class="lineNum">    1922 </span><span class="lineNoCov">          0 :   AliSysInfo::AddStamp(&quot;FitDrift.StartRobust&quot;,2,0,0);</span>
<span class="lineNum">    1923 </span><span class="lineNoCov">          0 :   TF1 * fpol1 = new TF1(&quot;f1&quot;,&quot;[0]+[1]*x&quot;,0,250);</span>
<span class="lineNum">    1924 </span>            :   //
<span class="lineNum">    1925 </span><span class="lineNoCov">          0 :   if (pcstream-&gt;GetFile()-&gt;Get(&quot;robustFit&quot;)==0){</span>
<span class="lineNum">    1926 </span><span class="lineNoCov">          0 :     for (Int_t iter=0; iter&lt;20; iter++){</span>
<span class="lineNum">    1927 </span><span class="lineNoCov">          0 :       AliSysInfo::AddStamp(&quot;FitDrift.RobustIter&quot;,3,iter,0);</span>
<span class="lineNum">    1928 </span><span class="lineNoCov">          0 :       TLinearFitter *fitterRobust= new TLinearFitter(4,TString::Format(&quot;hyp%d&quot;,3).Data());</span>
<span class="lineNum">    1929 </span><span class="lineNoCov">          0 :       TLinearFitter *fitterTRD= new TLinearFitter(4,TString::Format(&quot;hyp%d&quot;,3).Data());</span>
<span class="lineNum">    1930 </span><span class="lineNoCov">          0 :       TLinearFitter *fitterTOF= new TLinearFitter(4,TString::Format(&quot;hyp%d&quot;,3).Data());</span>
<span class="lineNum">    1931 </span><span class="lineNoCov">          0 :       TLinearFitter *fitterRobustBC= new TLinearFitter(4,TString::Format(&quot;hyp%d&quot;,3).Data());</span>
<span class="lineNum">    1932 </span><span class="lineNoCov">          0 :       TLinearFitter *fitterTRDBC= new TLinearFitter(4,TString::Format(&quot;hyp%d&quot;,3).Data());</span>
<span class="lineNum">    1933 </span><span class="lineNoCov">          0 :       TLinearFitter *fitterTOFBC= new TLinearFitter(4,TString::Format(&quot;hyp%d&quot;,3).Data());</span>
<span class="lineNum">    1934 </span><span class="lineNoCov">          0 :       TH2F * hisDeltaZ[12];</span>
<span class="lineNum">    1935 </span><span class="lineNoCov">          0 :       for (Int_t ihis=0; ihis&lt;12; ihis++) {</span>
<span class="lineNum">    1936 </span><span class="lineNoCov">          0 :         hisDeltaZ[ihis] = new TH2F(&quot;hisZ&quot;,&quot;hisZ&quot;,21,40,250,100,-5,5);</span>
<span class="lineNum">    1937 </span>            :       }
<span class="lineNum">    1938 </span>            : 
<span class="lineNum">    1939 </span><span class="lineNoCov">          0 :       Int_t maxPoints= TMath::Min(maxPointsRobust,entriesFit); </span>
<span class="lineNum">    1940 </span><span class="lineNoCov">          0 :       for (Int_t ipoint=0; ipoint&lt;maxPoints; ipoint++){</span>
<span class="lineNum">    1941 </span><span class="lineNoCov">          0 :         Double_t  radius= (*vecR)[ipoint];</span>
<span class="lineNum">    1942 </span>            :         
<span class="lineNum">    1943 </span><span class="lineNoCov">          0 :         if (radius&lt;kInvalidR) continue;   // bad point</span>
<span class="lineNum">    1944 </span>            : 
<span class="lineNum">    1945 </span><span class="lineNoCov">          0 :         Double_t pvecFit[10]={0};</span>
<span class="lineNum">    1946 </span><span class="lineNoCov">          0 :         if (gRandom-&gt;Rndm()&gt;0.1) continue;</span>
<span class="lineNum">    1947 </span><span class="lineNoCov">          0 :         Int_t sector   = TMath::Nint((*vecSec)[ipoint]);</span>
<span class="lineNum">    1948 </span><span class="lineNoCov">          0 :         Double_t side  = -1.+((sector%36)&lt;18)*2.;</span>
<span class="lineNum">    1949 </span><span class="lineNoCov">          0 :         Double_t z= (*vecZ)[ipoint];</span>
<span class="lineNum">    1950 </span><span class="lineNoCov">          0 :         double maxZ = kMaxZSect[side&lt;0];</span>
<span class="lineNum">    1951 </span><span class="lineNoCov">          0 :         Double_t drift = (side&gt;0) ? maxZ-(*vecZ)[ipoint] : (*vecZ)[ipoint]+maxZ;</span>
<span class="lineNum">    1952 </span><span class="lineNoCov">          0 :         if (drift&gt;maxZ) continue;</span>
<span class="lineNum">    1953 </span><span class="lineNoCov">          0 :         Double_t phi   = (*vecPhi)[ipoint];</span>
<span class="lineNum">    1954 </span><span class="lineNoCov">          0 :         Double_t gy    = TMath::Sin(phi)*radius;</span>
<span class="lineNum">    1955 </span><span class="lineNoCov">          0 :         Float_t tofBC=(*vecTOFBC)[ipoint];</span>
<span class="lineNum">    1956 </span><span class="lineNoCov">          0 :         pvecFit[0]= side;             // z shift (cm)</span>
<span class="lineNum">    1957 </span><span class="lineNoCov">          0 :         pvecFit[1]= drift*gy/maxZ;   // global y gradient</span>
<span class="lineNum">    1958 </span><span class="lineNoCov">          0 :         pvecFit[2]= drift;            // drift length</span>
<span class="lineNum">    1959 </span><span class="lineNoCov">          0 :         Double_t dZTOF=(*deltaZTOF)[ipoint];</span>
<span class="lineNum">    1960 </span><span class="lineNoCov">          0 :         Double_t dZTRD=(*deltaZTRD)[ipoint];</span>
<span class="lineNum">    1961 </span><span class="lineNoCov">          0 :         Int_t hisIndex=(((1-side)/2)*6);</span>
<span class="lineNum">    1962 </span>            : 
<span class="lineNum">    1963 </span><span class="lineNoCov">          0 :         if (iter==0){</span>
<span class="lineNum">    1964 </span><span class="lineNoCov">          0 :           if ( dZTOF&gt;kInvalidRes &amp;&amp;TMath::Abs(dZTOF)&lt;kMaxDist0) fitterRobust-&gt;AddPoint(pvecFit,dZTOF*side,1);</span>
<span class="lineNum">    1965 </span><span class="lineNoCov">          0 :           if ( dZTRD&gt;kInvalidRes &amp;&amp;TMath::Abs(dZTRD)&lt;kMaxDist0) fitterRobust-&gt;AddPoint(pvecFit,dZTRD*side,1);</span>
<span class="lineNum">    1966 </span>            :         }else{
<span class="lineNum">    1967 </span><span class="lineNoCov">          0 :           Double_t expected = paramRobust[0]+paramRobust[1]*pvecFit[0]+paramRobust[2]*pvecFit[1]+paramRobust[3]*pvecFit[2];</span>
<span class="lineNum">    1968 </span><span class="lineNoCov">          0 :           if ( dZTRD&gt;kInvalidRes &amp;&amp;TMath::Abs(dZTRD*side-expected)&lt;kMaxDist1) {</span>
<span class="lineNum">    1969 </span><span class="lineNoCov">          0 :             fitterRobust-&gt;AddPoint(pvecFit,dZTRD*side,1);    </span>
<span class="lineNum">    1970 </span><span class="lineNoCov">          0 :             fitterTRD-&gt;AddPoint(pvecFit,dZTRD*side,1);       </span>
<span class="lineNum">    1971 </span><span class="lineNoCov">          0 :             hisDeltaZ[hisIndex+0]-&gt;Fill(drift, dZTRD*side-expected);</span>
<span class="lineNum">    1972 </span><span class="lineNoCov">          0 :             hisDeltaZ[hisIndex+1]-&gt;Fill(drift, dZTRD*side-expected);</span>
<span class="lineNum">    1973 </span><span class="lineNoCov">          0 :             if (tofBC&gt;kBCcutMin&amp;&amp;tofBC&lt;kBCcutMax){</span>
<span class="lineNum">    1974 </span><span class="lineNoCov">          0 :               fitterRobustBC-&gt;AddPoint(pvecFit,dZTRD*side,1);        </span>
<span class="lineNum">    1975 </span><span class="lineNoCov">          0 :               fitterTRDBC-&gt;AddPoint(pvecFit,dZTRD*side,1);   </span>
<span class="lineNum">    1976 </span><span class="lineNoCov">          0 :               hisDeltaZ[hisIndex+3]-&gt;Fill(drift, dZTRD*side-expected);</span>
<span class="lineNum">    1977 </span><span class="lineNoCov">          0 :               hisDeltaZ[hisIndex+4]-&gt;Fill(drift, dZTRD*side-expected);</span>
<span class="lineNum">    1978 </span>            :             }
<span class="lineNum">    1979 </span>            :           }
<span class="lineNum">    1980 </span><span class="lineNoCov">          0 :           if ( dZTOF&gt;kInvalidRes &amp;&amp;TMath::Abs(dZTOF*side-expected)&lt;kMaxDist1) {</span>
<span class="lineNum">    1981 </span><span class="lineNoCov">          0 :             hisDeltaZ[hisIndex+0]-&gt;Fill(drift, dZTOF*side-expected);</span>
<span class="lineNum">    1982 </span><span class="lineNoCov">          0 :             hisDeltaZ[hisIndex+2]-&gt;Fill(drift, dZTOF*side-expected);</span>
<span class="lineNum">    1983 </span><span class="lineNoCov">          0 :             fitterRobust-&gt;AddPoint(pvecFit,dZTOF*side,1);</span>
<span class="lineNum">    1984 </span><span class="lineNoCov">          0 :             fitterTOF-&gt;AddPoint(pvecFit,dZTOF*side,1);</span>
<span class="lineNum">    1985 </span><span class="lineNoCov">          0 :             if (tofBC&gt;kBCcutMin&amp;&amp;tofBC&lt;kBCcutMax){</span>
<span class="lineNum">    1986 </span><span class="lineNoCov">          0 :               fitterRobustBC-&gt;AddPoint(pvecFit,dZTOF*side,1);</span>
<span class="lineNum">    1987 </span><span class="lineNoCov">          0 :               fitterTOFBC-&gt;AddPoint(pvecFit,dZTOF*side,1);</span>
<span class="lineNum">    1988 </span><span class="lineNoCov">          0 :               hisDeltaZ[hisIndex+3]-&gt;Fill(drift, dZTOF*side-expected);</span>
<span class="lineNum">    1989 </span><span class="lineNoCov">          0 :               hisDeltaZ[hisIndex+5]-&gt;Fill(drift, dZTOF*side-expected);</span>
<span class="lineNum">    1990 </span>            :             }
<span class="lineNum">    1991 </span>            :           }
<span class="lineNum">    1992 </span>            : 
<span class="lineNum">    1993 </span><span class="lineNoCov">          0 :           if (gRandom-&gt;Rndm()&lt;kDumpSample){</span>
<span class="lineNum">    1994 </span><span class="lineNoCov">          0 :             Double_t cTime = (*vecTime)[ipoint];</span>
<span class="lineNum">    1995 </span><span class="lineNoCov">          0 :             (*pcstream)&lt;&lt;&quot;dumpSample&quot;&lt;&lt;</span>
<span class="lineNum">    1996 </span><span class="lineNoCov">          0 :               &quot;iter=&quot;&lt;&lt;iter&lt;&lt;</span>
<span class="lineNum">    1997 </span><span class="lineNoCov">          0 :               &quot;run=&quot;&lt;&lt;runNumber&lt;&lt;</span>
<span class="lineNum">    1998 </span><span class="lineNoCov">          0 :               &quot;ctime=&quot;&lt;&lt;cTime&lt;&lt;</span>
<span class="lineNum">    1999 </span><span class="lineNoCov">          0 :               &quot;sector=&quot;&lt;&lt;sector&lt;&lt;</span>
<span class="lineNum">    2000 </span><span class="lineNoCov">          0 :               &quot;side=&quot;&lt;&lt;side&lt;&lt;</span>
<span class="lineNum">    2001 </span><span class="lineNoCov">          0 :               &quot;drift=&quot;&lt;&lt;drift&lt;&lt;</span>
<span class="lineNum">    2002 </span><span class="lineNoCov">          0 :               &quot;radius=&quot;&lt;&lt;radius&lt;&lt;</span>
<span class="lineNum">    2003 </span><span class="lineNoCov">          0 :               &quot;phi=&quot;&lt;&lt;phi&lt;&lt;</span>
<span class="lineNum">    2004 </span><span class="lineNoCov">          0 :               &quot;tofBC=&quot;&lt;&lt;tofBC&lt;&lt;</span>
<span class="lineNum">    2005 </span><span class="lineNoCov">          0 :               &quot;gy=&quot;&lt;&lt;gy&lt;&lt;</span>
<span class="lineNum">    2006 </span><span class="lineNoCov">          0 :               &quot;z=&quot;&lt;&lt;z&lt;&lt;</span>
<span class="lineNum">    2007 </span><span class="lineNoCov">          0 :               &quot;expected=&quot;&lt;&lt;expected&lt;&lt;</span>
<span class="lineNum">    2008 </span><span class="lineNoCov">          0 :               &quot;paramRobust.=&quot;&lt;&lt;&amp;paramRobust&lt;&lt;      //  drift fit using all tracks</span>
<span class="lineNum">    2009 </span><span class="lineNoCov">          0 :               &quot;dZTOF=&quot;&lt;&lt;dZTOF&lt;&lt;</span>
<span class="lineNum">    2010 </span><span class="lineNoCov">          0 :               &quot;dZTRD=&quot;&lt;&lt;dZTRD&lt;&lt;</span>
<span class="lineNum">    2011 </span>            :               &quot;\n&quot;;
<span class="lineNum">    2012 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    2013 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2014 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    2015 </span><span class="lineNoCov">          0 :       printf(&quot;iter=%d\n&quot;,iter);</span>
<span class="lineNum">    2016 </span><span class="lineNoCov">          0 :       if (fitterRobust-&gt;GetNpoints()&lt;kMinEntries*0.1){    </span>
<span class="lineNum">    2017 </span><span class="lineNoCov">          0 :         ::Error(&quot;fitDrift FAILED&quot;,&quot;Not enough points in the chain. Iter=%d\tN=%d&quot; , iter, fitterRobust-&gt;GetNpoints());</span>
<span class="lineNum">    2018 </span><span class="lineNoCov">          0 :         delete pcstream;</span>
<span class="lineNum">    2019 </span><span class="lineNoCov">          0 :         return kFALSE;</span>
<span class="lineNum">    2020 </span>            :       }
<span class="lineNum">    2021 </span>            :       //fitterRobust-&gt;EvalRobust(robFraction, regRobust);   // ROOT has to be patched to use regularization
<span class="lineNum">    2022 </span><span class="lineNoCov">          0 :       fitterRobust-&gt;EvalRobust(robFraction);</span>
<span class="lineNum">    2023 </span>            :       //fitterRobust-&gt;Eval(); // EvalRobust sometimes failed - looks like related to the random selection of subset of data - can be only one side 
<span class="lineNum">    2024 </span><span class="lineNoCov">          0 :       fitterRobust-&gt;GetParameters(paramRobust);</span>
<span class="lineNum">    2025 </span><span class="lineNoCov">          0 :       Double_t npoints= fitterRobust-&gt;GetNpoints();</span>
<span class="lineNum">    2026 </span><span class="lineNoCov">          0 :       Double_t chi2= TMath::Sqrt(fitterRobust-&gt;GetChisquare()/npoints);</span>
<span class="lineNum">    2027 </span><span class="lineNoCov">          0 :       paramRobust.Print();</span>
<span class="lineNum">    2028 </span>            : 
<span class="lineNum">    2029 </span><span class="lineNoCov">          0 :       Int_t nTRD = fitterTRD-&gt;GetNpoints();</span>
<span class="lineNum">    2030 </span><span class="lineNoCov">          0 :       Int_t nTOF = fitterTOF-&gt;GetNpoints();</span>
<span class="lineNum">    2031 </span><span class="lineNoCov">          0 :       Int_t nRobustBC = fitterRobustBC-&gt;GetNpoints();</span>
<span class="lineNum">    2032 </span><span class="lineNoCov">          0 :       Int_t nTRDBC = fitterTRDBC-&gt;GetNpoints();</span>
<span class="lineNum">    2033 </span><span class="lineNoCov">          0 :       Int_t nTOFBC = fitterTOFBC-&gt;GetNpoints();</span>
<span class="lineNum">    2034 </span>            : 
<span class="lineNum">    2035 </span><span class="lineNoCov">          0 :       if (nRobustBC&gt;kMinEntries*0.1){        fitterRobustBC-&gt;EvalRobust(robFraction);  fitterRobustBC-&gt;GetParameters(paramRobustBC);}</span>
<span class="lineNum">    2036 </span><span class="lineNoCov">          0 :       if (nTRD&gt;kMinEntries*0.1){     fitterTRD-&gt;EvalRobust(robFraction);     fitterTRD-&gt;GetParameters(paramTRD);}</span>
<span class="lineNum">    2037 </span><span class="lineNoCov">          0 :       if (nTOF&gt;kMinEntries*0.1){     fitterTOF-&gt;EvalRobust(robFraction);     fitterTOF-&gt;GetParameters(paramTOF);}</span>
<span class="lineNum">    2038 </span><span class="lineNoCov">          0 :       if (nTRDBC&gt;kMinEntries*0.1){   fitterTRDBC-&gt;EvalRobust(robFraction);           fitterTRDBC-&gt;GetParameters(paramTRDBC);}</span>
<span class="lineNum">    2039 </span><span class="lineNoCov">          0 :       if (nTOFBC&gt;kMinEntries*0.1){   fitterTOFBC-&gt;EvalRobust(robFraction);           fitterTOFBC-&gt;GetParameters(paramTOFBC); }</span>
<span class="lineNum">    2040 </span>            : 
<span class="lineNum">    2041 </span>            :    //    if (nRobustBC&gt;kMinEntries*0.1){     fitterRobustBC-&gt;EvalRobust(robFraction, regRobust);  fitterRobustBC-&gt;GetParameters(paramRobustBC);}
<span class="lineNum">    2042 </span>            : //       if (nTRD&gt;kMinEntries*0.1){  fitterTRD-&gt;EvalRobust(robFraction, regRobust);          fitterTRD-&gt;GetParameters(paramTRD);}
<span class="lineNum">    2043 </span>            : //       if (nTOF&gt;kMinEntries*0.1){  fitterTOF-&gt;EvalRobust(robFraction, regRobust);          fitterTOF-&gt;GetParameters(paramTOF);}
<span class="lineNum">    2044 </span>            : //       if (nTRDBC&gt;kMinEntries*0.1){        fitterTRDBC-&gt;EvalRobust(robFraction, regRobust);        fitterTRDBC-&gt;GetParameters(paramTRDBC);}
<span class="lineNum">    2045 </span>            : //       if (nTOFBC&gt;kMinEntries*0.1){        fitterTOFBC-&gt;EvalRobust(robFraction, regRobust);        fitterTOFBC-&gt;GetParameters(paramTOFBC); }
<span class="lineNum">    2046 </span>            :       //
<span class="lineNum">    2047 </span><span class="lineNoCov">          0 :       TGraphErrors * grDeltaZ[12] = {0};</span>
<span class="lineNum">    2048 </span><span class="lineNoCov">          0 :       TGraphErrors * grRMSZ[12] = {0};</span>
<span class="lineNum">    2049 </span><span class="lineNoCov">          0 :       TVectorD * fitDeltaZ[12] = {0};</span>
<span class="lineNum">    2050 </span><span class="lineNoCov">          0 :       TObjArray fitArray(3);</span>
<span class="lineNum">    2051 </span><span class="lineNoCov">          0 :       for (Int_t ihis=0; ihis&lt;12; ihis++){</span>
<span class="lineNum">    2052 </span><span class="lineNoCov">          0 :         hisDeltaZ[ihis]-&gt;FitSlicesY(0,0,-1,0,&quot;QNR&quot;,&amp;fitArray);</span>
<span class="lineNum">    2053 </span><span class="lineNoCov">          0 :         grDeltaZ[ihis] = new TGraphErrors(((TH1D*)fitArray.At(1)));</span>
<span class="lineNum">    2054 </span><span class="lineNoCov">          0 :         grRMSZ[ihis]   = new TGraphErrors(((TH1D*)fitArray.At(2)));</span>
<span class="lineNum">    2055 </span><span class="lineNoCov">          0 :         fitDeltaZ[ihis] = new TVectorD(2);</span>
<span class="lineNum">    2056 </span><span class="lineNoCov">          0 :         grDeltaZ[ihis]-&gt;Fit(fpol1,&quot;q&quot;,&quot;q&quot;);</span>
<span class="lineNum">    2057 </span><span class="lineNoCov">          0 :         fpol1-&gt;GetParameters(fitDeltaZ[ihis]-&gt;GetMatrixArray());</span>
<span class="lineNum">    2058 </span><span class="lineNoCov">          0 :         fitArray.Delete();</span>
<span class="lineNum">    2059 </span><span class="lineNoCov">          0 :         delete hisDeltaZ[ihis];</span>
<span class="lineNum">    2060 </span><span class="lineNoCov">          0 :         hisDeltaZ[ihis] = 0;</span>
<span class="lineNum">    2061 </span>            :       }
<span class="lineNum">    2062 </span>            : 
<span class="lineNum">    2063 </span><span class="lineNoCov">          0 :       delete fitterRobust;    </span>
<span class="lineNum">    2064 </span><span class="lineNoCov">          0 :       delete fitterTRD;    </span>
<span class="lineNum">    2065 </span><span class="lineNoCov">          0 :       delete fitterTOF;    </span>
<span class="lineNum">    2066 </span><span class="lineNoCov">          0 :       delete fitterRobustBC;    </span>
<span class="lineNum">    2067 </span><span class="lineNoCov">          0 :       delete fitterTRDBC;    </span>
<span class="lineNum">    2068 </span><span class="lineNoCov">          0 :       delete fitterTOFBC;    </span>
<span class="lineNum">    2069 </span>            : 
<span class="lineNum">    2070 </span><span class="lineNoCov">          0 :       (*pcstream)&lt;&lt;&quot;robustFit&quot;&lt;&lt;</span>
<span class="lineNum">    2071 </span><span class="lineNoCov">          0 :         &quot;iter=&quot;&lt;&lt;iter&lt;&lt;</span>
<span class="lineNum">    2072 </span><span class="lineNoCov">          0 :         &quot;time0=&quot;&lt;&lt;time0&lt;&lt;</span>
<span class="lineNum">    2073 </span><span class="lineNoCov">          0 :         &quot;time1=&quot;&lt;&lt;time1&lt;&lt;</span>
<span class="lineNum">    2074 </span><span class="lineNoCov">          0 :         &quot;run=&quot;&lt;&lt;runNumber&lt;&lt;</span>
<span class="lineNum">    2075 </span><span class="lineNoCov">          0 :         &quot;npoints=&quot;&lt;&lt;npoints&lt;&lt;</span>
<span class="lineNum">    2076 </span><span class="lineNoCov">          0 :         &quot;chi2=&quot;&lt;&lt;chi2&lt;&lt;                   </span>
<span class="lineNum">    2077 </span><span class="lineNoCov">          0 :         &quot;nTRD=&quot;&lt;&lt;nTRD&lt;&lt;                      // number of TRD points</span>
<span class="lineNum">    2078 </span><span class="lineNoCov">          0 :         &quot;nTOF=&quot;&lt;&lt;nTOF&lt;&lt;                      // number of TRD points</span>
<span class="lineNum">    2079 </span><span class="lineNoCov">          0 :         &quot;nTRDBC=&quot;&lt;&lt;nTRDBC&lt;&lt;                  // number of TRD points BC</span>
<span class="lineNum">    2080 </span><span class="lineNoCov">          0 :         &quot;nTOFBC=&quot;&lt;&lt;nTOFBC&lt;&lt;                  // number of TRD points BC</span>
<span class="lineNum">    2081 </span>            :         //
<span class="lineNum">    2082 </span><span class="lineNoCov">          0 :         &quot;paramRobust.=&quot;&lt;&lt;&amp;paramRobust&lt;&lt;      //  drift fit using all tracks</span>
<span class="lineNum">    2083 </span><span class="lineNoCov">          0 :         &quot;paramTRD.=&quot;&lt;&lt;&amp;paramTRD&lt;&lt;            //  drift fit using TRD tracks</span>
<span class="lineNum">    2084 </span><span class="lineNoCov">          0 :         &quot;paramTOF.=&quot;&lt;&lt;&amp;paramTOF&lt;&lt;          //  drift fit using TOF tracks</span>
<span class="lineNum">    2085 </span><span class="lineNoCov">          0 :         &quot;paramRobustBC.=&quot;&lt;&lt;&amp;paramRobustBC&lt;&lt;  //  drift fit using all tracks with BC</span>
<span class="lineNum">    2086 </span><span class="lineNoCov">          0 :         &quot;paramTRDBC.=&quot;&lt;&lt;&amp;paramTRDBC&lt;&lt;        //  drift fit using TRD tracks with BC</span>
<span class="lineNum">    2087 </span><span class="lineNoCov">          0 :         &quot;paramTOFBC.=&quot;&lt;&lt;&amp;paramTOFBC;         //  drift fit using TOF tracks with BC</span>
<span class="lineNum">    2088 </span>            :       
<span class="lineNum">    2089 </span><span class="lineNoCov">          0 :       for (Int_t ihis=0; ihis&lt;12; ihis++){</span>
<span class="lineNum">    2090 </span><span class="lineNoCov">          0 :         (*pcstream)&lt;&lt;&quot;robustFit&quot;&lt;&lt;</span>
<span class="lineNum">    2091 </span><span class="lineNoCov">          0 :           TString::Format(&quot;grDeltaZ%d.=&quot;,ihis).Data()&lt;&lt;grDeltaZ[ihis]&lt;&lt;     // residual histogram drift fit - mean </span>
<span class="lineNum">    2092 </span><span class="lineNoCov">          0 :           TString::Format(&quot;grRMSZ%d.=&quot;,ihis).Data()&lt;&lt;grDeltaZ[ihis]&lt;&lt;       //  residual histogram drift fit - rms</span>
<span class="lineNum">    2093 </span><span class="lineNoCov">          0 :           TString::Format(&quot;fitDeltaZ%d.=&quot;,ihis).Data()&lt;&lt;fitDeltaZ[ihis];     //  residual histogram drift fit - linear fit</span>
<span class="lineNum">    2094 </span>            :       }
<span class="lineNum">    2095 </span><span class="lineNoCov">          0 :       (*pcstream)&lt;&lt;&quot;robustFit&quot;&lt;&lt;  </span>
<span class="lineNum">    2096 </span>            :         &quot;\n&quot;;    
<span class="lineNum">    2097 </span><span class="lineNoCov">          0 :       for (Int_t ihis=0; ihis&lt;12; ihis++){</span>
<span class="lineNum">    2098 </span><span class="lineNoCov">          0 :         delete grDeltaZ[ihis];</span>
<span class="lineNum">    2099 </span><span class="lineNoCov">          0 :         delete grRMSZ[ihis];</span>
<span class="lineNum">    2100 </span><span class="lineNoCov">          0 :         delete fitDeltaZ[ihis]; </span>
<span class="lineNum">    2101 </span>            :       }
<span class="lineNum">    2102 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2103 </span>            :     // delete pcstream;  
<span class="lineNum">    2104 </span>            :     //pcstream = new TTreeSRedirector(&quot;fitDrift.root&quot;,&quot;update&quot;);
<span class="lineNum">    2105 </span>            :   }
<span class="lineNum">    2106 </span><span class="lineNoCov">          0 :   delete fpol1;</span>
<span class="lineNum">    2107 </span>            :   //
<span class="lineNum">    2108 </span><span class="lineNoCov">          0 :   TTree * treeRobust= (TTree*)(pcstream-&gt;GetFile()-&gt;Get(&quot;robustFit&quot;));  </span>
<span class="lineNum">    2109 </span><span class="lineNoCov">          0 :   Int_t entriesR= treeRobust-&gt;Draw(&quot;paramRobust.fElements[0]:paramRobust.fElements[1]:paramRobust.fElements[2]:paramRobust.fElements[3]&quot;,&quot;&quot;,&quot;goffPara&quot;);</span>
<span class="lineNum">    2110 </span><span class="lineNoCov">          0 :   for (Int_t ipar=0; ipar&lt;4; ipar++) {paramRobust[ipar]=TMath::Median(entriesR-5, &amp;(treeRobust-&gt;GetVal(ipar)[5]));}</span>
<span class="lineNum">    2111 </span>            :   //
<span class="lineNum">    2112 </span><span class="lineNoCov">          0 :   treeRobust-&gt;Draw(&quot;paramRobustBC.fElements[0]:paramRobustBC.fElements[1]:paramRobustBC.fElements[2]:paramRobustBC.fElements[3]&quot;,&quot;&quot;,&quot;goffPara&quot;);</span>
<span class="lineNum">    2113 </span><span class="lineNoCov">          0 :   for (Int_t ipar=0; ipar&lt;4; ipar++) {paramRobustBC[ipar]=TMath::Median(entriesR-5, &amp;(treeRobust-&gt;GetVal(ipar)[5]));}</span>
<span class="lineNum">    2114 </span><span class="lineNoCov">          0 :   treeRobust-&gt;Draw(&quot;paramTRD.fElements[0]:paramTRD.fElements[1]:paramTRD.fElements[2]:paramTRD.fElements[3]&quot;,&quot;&quot;,&quot;goffPara&quot;);</span>
<span class="lineNum">    2115 </span><span class="lineNoCov">          0 :   for (Int_t ipar=0; ipar&lt;4; ipar++) {paramTRD[ipar]=TMath::Median(entriesR-5, &amp;(treeRobust-&gt;GetVal(ipar)[5]));}</span>
<span class="lineNum">    2116 </span><span class="lineNoCov">          0 :   treeRobust-&gt;Draw(&quot;paramTOF.fElements[0]:paramTOF.fElements[1]:paramTOF.fElements[2]:paramTOF.fElements[3]&quot;,&quot;&quot;,&quot;goffPara&quot;);</span>
<span class="lineNum">    2117 </span><span class="lineNoCov">          0 :   for (Int_t ipar=0; ipar&lt;4; ipar++) {paramTOF[ipar]=TMath::Median(entriesR-5, &amp;(treeRobust-&gt;GetVal(ipar)[5]));}</span>
<span class="lineNum">    2118 </span><span class="lineNoCov">          0 :   treeRobust-&gt;Draw(&quot;paramTRDBC.fElements[0]:paramTRDBC.fElements[1]:paramTRDBC.fElements[2]:paramTRDBC.fElements[3]&quot;,&quot;&quot;,&quot;goffPara&quot;);</span>
<span class="lineNum">    2119 </span><span class="lineNoCov">          0 :   for (Int_t ipar=0; ipar&lt;4; ipar++) {paramTRDBC[ipar]=TMath::Median(entriesR-5, &amp;(treeRobust-&gt;GetVal(ipar)[5]));}</span>
<span class="lineNum">    2120 </span><span class="lineNoCov">          0 :   treeRobust-&gt;Draw(&quot;paramTOFBC.fElements[0]:paramTOFBC.fElements[1]:paramTOFBC.fElements[2]:paramTOFBC.fElements[3]&quot;,&quot;&quot;,&quot;goffPara&quot;);</span>
<span class="lineNum">    2121 </span><span class="lineNoCov">          0 :   for (Int_t ipar=0; ipar&lt;4; ipar++) {paramTOFBC[ipar]=TMath::Median(entriesR-5, &amp;(treeRobust-&gt;GetVal(ipar)[5]));}</span>
<span class="lineNum">    2122 </span><span class="lineNoCov">          0 :   paramRobust.Print();</span>
<span class="lineNum">    2123 </span>            :   //
<span class="lineNum">    2124 </span>            :   //
<span class="lineNum">    2125 </span>            :   // 3.) Make drift fit per time interval
<span class="lineNum">    2126 </span>            :   //
<span class="lineNum">    2127 </span><span class="lineNoCov">          0 :   Int_t nTimeBins= Int_t((time1-time0)/deltaT)+1;</span>
<span class="lineNum">    2128 </span><span class="lineNoCov">          0 :   Int_t nParam   = nTimeBins+1;</span>
<span class="lineNum">    2129 </span><span class="lineNoCov">          0 :   TVectorD vecFit(nParam);</span>
<span class="lineNum">    2130 </span><span class="lineNoCov">          0 :   Double_t *pvecFit=vecFit.GetMatrixArray();</span>
<span class="lineNum">    2131 </span>            :   //TLinearFitter *fitterTRD= new TLinearFitter(nParam,TString::Format(&quot;hyp%d&quot;,nParam+1).Data());
<span class="lineNum">    2132 </span>            :   //TLinearFitter *fitterTOF= new TLinearFitter(nParam,TString::Format(&quot;hyp%d&quot;,nParam+1).Data());
<span class="lineNum">    2133 </span>            :   //
<span class="lineNum">    2134 </span><span class="lineNoCov">          0 :   TObjArray arrayFit(3);</span>
<span class="lineNum">    2135 </span><span class="lineNoCov">          0 :   TH2F hisTRD(&quot;hisTRD&quot;,&quot;hisTRD&quot;,nTimeBins,time0,time1,100,-0.02,0.02);</span>
<span class="lineNum">    2136 </span><span class="lineNoCov">          0 :   TH2F hisTOF(&quot;hisTOF&quot;,&quot;hisTOF&quot;,nTimeBins,time0,time1,100,-0.02,0.02);</span>
<span class="lineNum">    2137 </span>            : 
<span class="lineNum">    2138 </span><span class="lineNoCov">          0 :   for (Int_t iter=0; iter&lt;10; iter++){</span>
<span class="lineNum">    2139 </span><span class="lineNoCov">          0 :     hisTRD.Reset();</span>
<span class="lineNum">    2140 </span><span class="lineNoCov">          0 :     hisTOF.Reset();</span>
<span class="lineNum">    2141 </span><span class="lineNoCov">          0 :     for (Int_t ipoint=0; ipoint&lt;entriesFit; ipoint++){</span>
<span class="lineNum">    2142 </span><span class="lineNoCov">          0 :       if (ipoint%10!=iter) continue;  // points correlated - can be skipped</span>
<span class="lineNum">    2143 </span><span class="lineNoCov">          0 :       Double_t  radius= (*vecR)[ipoint];</span>
<span class="lineNum">    2144 </span>            : 
<span class="lineNum">    2145 </span><span class="lineNoCov">          0 :       if (radius&lt;kInvalidR) continue;  // no cluster</span>
<span class="lineNum">    2146 </span>            : 
<span class="lineNum">    2147 </span><span class="lineNoCov">          0 :       Int_t sector   = TMath::Nint((*vecSec)[ipoint]);</span>
<span class="lineNum">    2148 </span><span class="lineNoCov">          0 :       Double_t side  = -1.+((sector%36)&lt;18)*2.;</span>
<span class="lineNum">    2149 </span><span class="lineNoCov">          0 :       Double_t z= (*vecZ)[ipoint];</span>
<span class="lineNum">    2150 </span><span class="lineNoCov">          0 :       double maxZ = kMaxZSect[side&lt;0];</span>
<span class="lineNum">    2151 </span><span class="lineNoCov">          0 :       Double_t drift = (side&gt;0) ? maxZ-(*vecZ)[ipoint] : (*vecZ)[ipoint]+maxZ;</span>
<span class="lineNum">    2152 </span><span class="lineNoCov">          0 :       if (drift&gt;maxZ) continue;</span>
<span class="lineNum">    2153 </span><span class="lineNoCov">          0 :       Double_t phi   = (*vecPhi)[ipoint];</span>
<span class="lineNum">    2154 </span><span class="lineNoCov">          0 :       Double_t gy    = TMath::Sin(phi)*radius;</span>
<span class="lineNum">    2155 </span><span class="lineNoCov">          0 :       pvecFit[0]= side;             // z shift (cm)</span>
<span class="lineNum">    2156 </span><span class="lineNoCov">          0 :       pvecFit[1]= drift*gy/maxZ;   // global y gradient</span>
<span class="lineNum">    2157 </span><span class="lineNoCov">          0 :       pvecFit[2]= drift;            // drift length</span>
<span class="lineNum">    2158 </span><span class="lineNoCov">          0 :       Double_t expected = paramRobust[0]+paramRobust[1]*pvecFit[0]+paramRobust[2]*pvecFit[1]+paramRobust[3]*pvecFit[2];</span>
<span class="lineNum">    2159 </span><span class="lineNoCov">          0 :       Int_t time=(*vecTime)[ipoint];</span>
<span class="lineNum">    2160 </span>            :       //
<span class="lineNum">    2161 </span><span class="lineNoCov">          0 :       Double_t dZTOF=(*deltaZTOF)[ipoint];</span>
<span class="lineNum">    2162 </span><span class="lineNoCov">          0 :       if (dZTOF&gt;kInvalidRes) {</span>
<span class="lineNum">    2163 </span><span class="lineNoCov">          0 :         if (TMath::Abs(dZTOF*side-expected)&lt;kMaxDist1) {</span>
<span class="lineNum">    2164 </span>            :           dZTOF *= side;
<span class="lineNum">    2165 </span>            :           //      fitterTOF-&gt;AddPoint(pvecFit,dZTOF,1);
<span class="lineNum">    2166 </span><span class="lineNoCov">          0 :           hisTOF.Fill(time,(dZTOF-expected)/drift,drift/maxZ); </span>
<span class="lineNum">    2167 </span>            :         }
<span class="lineNum">    2168 </span>            :       }
<span class="lineNum">    2169 </span><span class="lineNoCov">          0 :       Double_t dZTRD=(*deltaZTRD)[ipoint];</span>
<span class="lineNum">    2170 </span><span class="lineNoCov">          0 :       if ( dZTRD&gt;kInvalidRes) {</span>
<span class="lineNum">    2171 </span><span class="lineNoCov">          0 :         if (TMath::Abs(dZTRD*side-expected)&lt;kMaxDist1) {</span>
<span class="lineNum">    2172 </span>            :           dZTRD*=side;
<span class="lineNum">    2173 </span>            :           //fitterTOF-&gt;AddPoint(pvecFit,dZTRD,1);    
<span class="lineNum">    2174 </span><span class="lineNoCov">          0 :           hisTRD.Fill(time,(dZTRD-expected)/drift,drift/maxZ); </span>
<span class="lineNum">    2175 </span>            :         }
<span class="lineNum">    2176 </span>            :       }  
<span class="lineNum">    2177 </span>            : 
<span class="lineNum">    2178 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2179 </span><span class="lineNoCov">          0 :     printf(&quot;iter=%d\n&quot;,iter);</span>
<span class="lineNum">    2180 </span>            :     TGraphErrors *grTRD=NULL, *grTOF=NULL;
<span class="lineNum">    2181 </span>            :     TGraphErrors *grTRD2=NULL, *grTOF2=NULL;
<span class="lineNum">    2182 </span><span class="lineNoCov">          0 :     Int_t nclTRD=hisTRD.GetEntries();</span>
<span class="lineNum">    2183 </span><span class="lineNoCov">          0 :     Int_t nclTOF=hisTOF.GetEntries();</span>
<span class="lineNum">    2184 </span><span class="lineNoCov">          0 :     if (nclTRD&gt;kMinEntries){</span>
<span class="lineNum">    2185 </span><span class="lineNoCov">          0 :       hisTRD.FitSlicesY(0,0,-1,0,&quot;QNR&quot;,&amp;arrayFit);</span>
<span class="lineNum">    2186 </span><span class="lineNoCov">          0 :       grTRD = new TGraphErrors((TH1D*)arrayFit.At(1));</span>
<span class="lineNum">    2187 </span><span class="lineNoCov">          0 :       grTRD2 = new TGraphErrors((TH1D*)arrayFit.At(2));</span>
<span class="lineNum">    2188 </span><span class="lineNoCov">          0 :       arrayFit.Delete();</span>
<span class="lineNum">    2189 </span>            :     }
<span class="lineNum">    2190 </span><span class="lineNoCov">          0 :     if (nclTOF&gt;kMinEntries){</span>
<span class="lineNum">    2191 </span><span class="lineNoCov">          0 :       hisTOF.FitSlicesY(0,0,-1,0,&quot;QNR&quot;,&amp;arrayFit);</span>
<span class="lineNum">    2192 </span><span class="lineNoCov">          0 :       grTOF  = new TGraphErrors((TH1D*)arrayFit.At(1));</span>
<span class="lineNum">    2193 </span><span class="lineNoCov">          0 :       grTOF2 = new TGraphErrors((TH1D*)arrayFit.At(2));</span>
<span class="lineNum">    2194 </span><span class="lineNoCov">          0 :       arrayFit.Delete();</span>
<span class="lineNum">    2195 </span>            :     }
<span class="lineNum">    2196 </span><span class="lineNoCov">          0 :     if (grTRD==NULL) {</span>
<span class="lineNum">    2197 </span>            :       grTRD=grTOF; // we should have at minimum one of the histograms not empty
<span class="lineNum">    2198 </span>            :       grTRD2=grTOF2;
<span class="lineNum">    2199 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2200 </span><span class="lineNoCov">          0 :     if (grTOF==NULL) {</span>
<span class="lineNum">    2201 </span>            :       grTOF=grTRD;
<span class="lineNum">    2202 </span>            :       grTOF2=grTRD2;
<span class="lineNum">    2203 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2204 </span><span class="lineNoCov">          0 :     (*pcstream)&lt;&lt;&quot;fitTime&quot;&lt;&lt;</span>
<span class="lineNum">    2205 </span><span class="lineNoCov">          0 :       &quot;iter=&quot;&lt;&lt;iter&lt;&lt;      </span>
<span class="lineNum">    2206 </span><span class="lineNoCov">          0 :       &quot;nclTRD=&quot;&lt;&lt;nclTRD&lt;&lt;             // </span>
<span class="lineNum">    2207 </span><span class="lineNoCov">          0 :       &quot;nclTOF=&quot;&lt;&lt;nclTOF&lt;&lt;             // </span>
<span class="lineNum">    2208 </span><span class="lineNoCov">          0 :       &quot;grTRD.=&quot;&lt;&lt;grTRD&lt;&lt;              // time dependent drift correction TRD - mean in time bin</span>
<span class="lineNum">    2209 </span><span class="lineNoCov">          0 :       &quot;grTOF.=&quot;&lt;&lt;grTOF&lt;&lt;        // time dependent drift correction TOF - mean in time bin</span>
<span class="lineNum">    2210 </span><span class="lineNoCov">          0 :       &quot;grTRD2.=&quot;&lt;&lt;grTRD2&lt;&lt;            // time dependent drift correction TRD - sigma in time bin</span>
<span class="lineNum">    2211 </span><span class="lineNoCov">          0 :       &quot;grTOF2.=&quot;&lt;&lt;grTOF2&lt;&lt;              // time dependent drift correction TOF - sigma in time bin</span>
<span class="lineNum">    2212 </span><span class="lineNoCov">          0 :       &quot;time0=&quot;&lt;&lt;time0&lt;&lt;</span>
<span class="lineNum">    2213 </span><span class="lineNoCov">          0 :       &quot;time1=&quot;&lt;&lt;time1&lt;&lt;</span>
<span class="lineNum">    2214 </span><span class="lineNoCov">          0 :       &quot;run=&quot;&lt;&lt;runNumber&lt;&lt;</span>
<span class="lineNum">    2215 </span><span class="lineNoCov">          0 :       &quot;paramRobust.=&quot;&lt;&lt;&amp;paramRobust&lt;&lt; // time independent parameters</span>
<span class="lineNum">    2216 </span><span class="lineNoCov">          0 :       &quot;paramTRD.=&quot;&lt;&lt;&amp;paramTRD&lt;&lt;            //  drift fit using TRD tracks</span>
<span class="lineNum">    2217 </span><span class="lineNoCov">          0 :       &quot;paramTOF.=&quot;&lt;&lt;&amp;paramTOF&lt;&lt;            //  drift fit using TOF tracks</span>
<span class="lineNum">    2218 </span><span class="lineNoCov">          0 :       &quot;paramRobustBC.=&quot;&lt;&lt;&amp;paramRobustBC&lt;&lt;  //  drift fit using all tracks with BC</span>
<span class="lineNum">    2219 </span><span class="lineNoCov">          0 :       &quot;paramTRDBC.=&quot;&lt;&lt;&amp;paramTRDBC&lt;&lt;        //  drift fit using TRD tracks with BC</span>
<span class="lineNum">    2220 </span><span class="lineNoCov">          0 :       &quot;paramTOFBC.=&quot;&lt;&lt;&amp;paramTOFBC&lt;&lt;        //  drift fit using TOF tracks with BC      </span>
<span class="lineNum">    2221 </span>            :       &quot;\n&quot;;
<span class="lineNum">    2222 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2223 </span><span class="lineNoCov">          0 :   delete pcstream;</span>
<span class="lineNum">    2224 </span><span class="lineNoCov">          0 :   pcstream = new TTreeSRedirector(&quot;fitDrift.root&quot;,&quot;update&quot;); </span>
<span class="lineNum">    2225 </span>            :   //
<span class="lineNum">    2226 </span>            :   // 3.) Make local regression and median fit
<span class="lineNum">    2227 </span>            :   //
<span class="lineNum">    2228 </span><span class="lineNoCov">          0 :   TTree * treeFit= (TTree*)(pcstream-&gt;GetFile()-&gt;Get(&quot;fitTime&quot;));  </span>
<span class="lineNum">    2229 </span><span class="lineNoCov">          0 :   Int_t entriesGr = treeFit-&gt;Draw(&quot;grTRD.fY:grTOF.fY:grTRD.fX:Iteration$&quot;,&quot;1&quot;,&quot;goffpara&quot;);</span>
<span class="lineNum">    2230 </span><span class="lineNoCov">          0 :   Int_t nbins = TMath::MaxElement(entriesGr, treeFit-&gt;GetV4())+1;  </span>
<span class="lineNum">    2231 </span>            : 
<span class="lineNum">    2232 </span><span class="lineNoCov">          0 :   Double_t dtime0=0,dtime1=0;</span>
<span class="lineNum">    2233 </span><span class="lineNoCov">          0 :   if (entriesGr) TStatToolkit::GetMinMax(treeFit-&gt;GetV3(),entriesGr,dtime0,dtime1);</span>
<span class="lineNum">    2234 </span><span class="lineNoCov">          0 :   Int_t ngraphs =entriesGr/nbins;</span>
<span class="lineNum">    2235 </span>            :   //
<span class="lineNum">    2236 </span>            :   // 3.a) local regression fit
<span class="lineNum">    2237 </span>            :   //
<span class="lineNum">    2238 </span><span class="lineNoCov">          0 :   treeFit-&gt;Draw(&quot;grTRD.fY-grTRD.fY[Iteration$+1]:grTRD.fX&quot;,&quot;1&quot;,&quot;goff&quot;);</span>
<span class="lineNum">    2239 </span><span class="lineNoCov">          0 :   Double_t deltaRMS,deltaMean;</span>
<span class="lineNum">    2240 </span><span class="lineNoCov">          0 :   AliMathBase::EvaluateUni(entriesGr,treeFit-&gt;GetV1(),deltaMean, deltaRMS,entriesGr*0.8);</span>
<span class="lineNum">    2241 </span><span class="lineNoCov">          0 :   TCut cutTRD=TString::Format(&quot;abs(grTRD.fY-grTOF.fY)&lt;0.01&amp;&amp;abs(grTRD.fY-grTRD.fY[Iteration$+1]-%f)&lt;%f&quot;,deltaMean, 3*deltaRMS).Data();</span>
<span class="lineNum">    2242 </span><span class="lineNoCov">          0 :   TCut cutTOF=TString::Format(&quot;abs(grTRD.fY-grTOF.fY)&lt;0.01&amp;&amp;abs(grTOF.fY-grTOF.fY[Iteration$+1]-%f)&lt;%f&quot;,deltaMean, 3*deltaRMS).Data();</span>
<span class="lineNum">    2243 </span>            : 
<span class="lineNum">    2244 </span><span class="lineNoCov">          0 :   THnD *hN = new THnD(&quot;hN&quot;,&quot;hN&quot;, 1, &amp;nbins, &amp;dtime0, &amp;dtime1);</span>
<span class="lineNum">    2245 </span><span class="lineNoCov">          0 :   AliNDLocalRegression * pfitTRD = new  AliNDLocalRegression(&quot;pfitTRD&quot;,&quot;pfitTRD&quot;);</span>
<span class="lineNum">    2246 </span><span class="lineNoCov">          0 :   AliNDLocalRegression * pfitTOF = new  AliNDLocalRegression(&quot;pfitTOF&quot;,&quot;pfitTOF&quot;);</span>
<span class="lineNum">    2247 </span><span class="lineNoCov">          0 :   pfitTRD-&gt;SetHistogram((THn*)(hN-&gt;Clone()));</span>
<span class="lineNum">    2248 </span><span class="lineNoCov">          0 :   pfitTOF-&gt;SetHistogram((THn*)(hN-&gt;Clone()));</span>
<span class="lineNum">    2249 </span><span class="lineNoCov">          0 :   pfitTRD-&gt;MakeFit(treeFit, &quot;grTRD.fY:grTRD.fEY+0.01&quot;, &quot;grTRD.fX&quot;,cutTRD, TString::Format(&quot;(grTRD.fX/grTRD.fX)+%f&quot;,sigmaT),&quot;2:2&quot;,0.0001);</span>
<span class="lineNum">    2250 </span><span class="lineNoCov">          0 :   pfitTOF-&gt;MakeFit(treeFit, &quot;grTOF.fY:grTOF.fEY+0.01&quot;, &quot;grTOF.fX&quot;,cutTOF, TString::Format(&quot;(grTRD.fX/grTRD.fX)+%f&quot;,sigmaT),&quot;2:2&quot;,0.0001);</span>
<span class="lineNum">    2251 </span><span class="lineNoCov">          0 :   AliNDLocalRegression::AddVisualCorrection(pfitTRD,104);</span>
<span class="lineNum">    2252 </span><span class="lineNoCov">          0 :   AliNDLocalRegression::AddVisualCorrection(pfitTOF,204);  </span>
<span class="lineNum">    2253 </span>            :   //
<span class="lineNum">    2254 </span>            :   //
<span class="lineNum">    2255 </span><span class="lineNoCov">          0 :   TVectorD medianTRD(nbins);</span>
<span class="lineNum">    2256 </span><span class="lineNoCov">          0 :   TVectorD medianTOF(nbins);</span>
<span class="lineNum">    2257 </span><span class="lineNoCov">          0 :   TVectorD medianQA(nbins);</span>
<span class="lineNum">    2258 </span><span class="lineNoCov">          0 :   TVectorD regTRD(nbins);</span>
<span class="lineNum">    2259 </span><span class="lineNoCov">          0 :   TVectorD regTOF(nbins);</span>
<span class="lineNum">    2260 </span><span class="lineNoCov">          0 :   TVectorD regQA(nbins);</span>
<span class="lineNum">    2261 </span>            :   //
<span class="lineNum">    2262 </span><span class="lineNoCov">          0 :   TVectorD rmsTRD(nbins);</span>
<span class="lineNum">    2263 </span><span class="lineNoCov">          0 :   TVectorD rmsTOF(nbins);</span>
<span class="lineNum">    2264 </span><span class="lineNoCov">          0 :   TVectorD rmsQA(nbins);</span>
<span class="lineNum">    2265 </span><span class="lineNoCov">          0 :   TVectorD vecTimeg(nbins);</span>
<span class="lineNum">    2266 </span><span class="lineNoCov">          0 :   TVectorD vecWorking(entriesGr);</span>
<span class="lineNum">    2267 </span><span class="lineNoCov">          0 :   treeFit-&gt;Draw(&quot;grTRD.fY:grTOF.fY:grTRD.fX:Iteration$&quot;,&quot;1&quot;,&quot;goffpara&quot;);</span>
<span class="lineNum">    2268 </span><span class="lineNoCov">          0 :   for (Int_t itype=0; itype&lt;2; itype++){</span>
<span class="lineNum">    2269 </span><span class="lineNoCov">          0 :     for (Int_t itime=0; itime&lt;nbins; itime++){</span>
<span class="lineNum">    2270 </span><span class="lineNoCov">          0 :       for (Int_t igr=0; igr&lt;ngraphs; igr++){</span>
<span class="lineNum">    2271 </span><span class="lineNoCov">          0 :         Int_t index=igr*nbins+itime;</span>
<span class="lineNum">    2272 </span><span class="lineNoCov">          0 :         vecWorking[igr]=treeFit-&gt;GetVal(itype)[index];</span>
<span class="lineNum">    2273 </span>            :       }
<span class="lineNum">    2274 </span><span class="lineNoCov">          0 :       Double_t grtime = treeFit-&gt;GetVal(2)[itime];</span>
<span class="lineNum">    2275 </span><span class="lineNoCov">          0 :       vecTimeg[itime]=treeFit-&gt;GetVal(2)[itime];</span>
<span class="lineNum">    2276 </span><span class="lineNoCov">          0 :       if (itype==0) {</span>
<span class="lineNum">    2277 </span><span class="lineNoCov">          0 :         medianTRD[itime]=TMath::Median(ngraphs,vecWorking.GetMatrixArray()); </span>
<span class="lineNum">    2278 </span><span class="lineNoCov">          0 :         regTRD[itime]= pfitTRD-&gt;Eval(&amp;grtime);</span>
<span class="lineNum">    2279 </span><span class="lineNoCov">          0 :         rmsTRD[itime]=TMath::RMS(ngraphs,vecWorking.GetMatrixArray())/TMath::Sqrt(ngraphs); </span>
<span class="lineNum">    2280 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    2281 </span><span class="lineNoCov">          0 :       if (itype==1) {</span>
<span class="lineNum">    2282 </span><span class="lineNoCov">          0 :         medianTOF[itime]=TMath::Median(ngraphs,vecWorking.GetMatrixArray());       </span>
<span class="lineNum">    2283 </span><span class="lineNoCov">          0 :         regTOF[itime]= pfitTOF-&gt;Eval(&amp;grtime);</span>
<span class="lineNum">    2284 </span><span class="lineNoCov">          0 :         rmsTOF[itime]=TMath::RMS(ngraphs,vecWorking.GetMatrixArray())/TMath::Sqrt(ngraphs);       </span>
<span class="lineNum">    2285 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    2286 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2287 </span>            :   }
<span class="lineNum">    2288 </span><span class="lineNoCov">          0 :   for (Int_t itime=0; itime&lt;nbins; itime++){  </span>
<span class="lineNum">    2289 </span><span class="lineNoCov">          0 :     medianQA[itime]= medianTRD[itime]-medianTOF[itime];</span>
<span class="lineNum">    2290 </span><span class="lineNoCov">          0 :     regQA[itime]= regTRD[itime]-regTOF[itime];</span>
<span class="lineNum">    2291 </span><span class="lineNoCov">          0 :     rmsQA[itime]=TMath::Sqrt(rmsTRD[itime]*rmsTRD[itime]+rmsTOF[itime]*rmsTOF[itime]);</span>
<span class="lineNum">    2292 </span>            :   }
<span class="lineNum">    2293 </span><span class="lineNoCov">          0 :   TGraphErrors *grmedTRD = new TGraphErrors(nbins, vecTimeg.GetMatrixArray(), medianTRD.GetMatrixArray(),0, rmsTRD.GetMatrixArray());</span>
<span class="lineNum">    2294 </span><span class="lineNoCov">          0 :   TGraphErrors *grmedTOF =  new TGraphErrors(nbins, vecTimeg.GetMatrixArray(), medianTOF.GetMatrixArray(),0, rmsTOF.GetMatrixArray());</span>
<span class="lineNum">    2295 </span><span class="lineNoCov">          0 :   TGraphErrors *grmedQA =  new TGraphErrors(nbins, vecTimeg.GetMatrixArray(), medianQA.GetMatrixArray(),0, rmsQA.GetMatrixArray());</span>
<span class="lineNum">    2296 </span><span class="lineNoCov">          0 :   TGraphErrors *grregTRD = new TGraphErrors(nbins, vecTimeg.GetMatrixArray(), regTRD.GetMatrixArray(),0, rmsTRD.GetMatrixArray());</span>
<span class="lineNum">    2297 </span><span class="lineNoCov">          0 :   TGraphErrors *grregTOF =  new TGraphErrors(nbins, vecTimeg.GetMatrixArray(), regTOF.GetMatrixArray(),0, rmsTOF.GetMatrixArray());</span>
<span class="lineNum">    2298 </span><span class="lineNoCov">          0 :   TGraphErrors *grregQA =  new TGraphErrors(nbins, vecTimeg.GetMatrixArray(), regQA.GetMatrixArray(),0, rmsQA.GetMatrixArray());</span>
<span class="lineNum">    2299 </span>            :   //
<span class="lineNum">    2300 </span><span class="lineNoCov">          0 :   (*pcstream)&lt;&lt;&quot;fitTimeStat&quot;&lt;&lt;</span>
<span class="lineNum">    2301 </span><span class="lineNoCov">          0 :     &quot;grTRDReg.=&quot;&lt;&lt;grregTRD&lt;&lt;      // time dependent drift correction TRD - regression estimator</span>
<span class="lineNum">    2302 </span><span class="lineNoCov">          0 :     &quot;grTOFReg.=&quot;&lt;&lt;grregTOF&lt;&lt;      // time dependent drift correction TOF - regression estimator</span>
<span class="lineNum">    2303 </span><span class="lineNoCov">          0 :     &quot;grQAReg.=&quot;&lt;&lt;grregQA&lt;&lt;        // time dependent drift correction TOF - regression estimator</span>
<span class="lineNum">    2304 </span><span class="lineNoCov">          0 :     &quot;grTRDMed.=&quot;&lt;&lt;grmedTRD&lt;&lt;      // time dependent drift correction TRD - median estimator</span>
<span class="lineNum">    2305 </span><span class="lineNoCov">          0 :     &quot;grTOFMed.=&quot;&lt;&lt;grmedTOF&lt;&lt;      // time dependent drift correction TOF - median estimator</span>
<span class="lineNum">    2306 </span><span class="lineNoCov">          0 :     &quot;grQAMed.=&quot;&lt;&lt;grmedQA&lt;&lt;        // time dependent drift correction TOF - median estimator</span>
<span class="lineNum">    2307 </span><span class="lineNoCov">          0 :     &quot;time0=&quot;&lt;&lt;time0&lt;&lt;             </span>
<span class="lineNum">    2308 </span><span class="lineNoCov">          0 :     &quot;time1=&quot;&lt;&lt;time1&lt;&lt;</span>
<span class="lineNum">    2309 </span><span class="lineNoCov">          0 :     &quot;run=&quot;&lt;&lt;runNumber&lt;&lt;</span>
<span class="lineNum">    2310 </span><span class="lineNoCov">          0 :     &quot;paramRobust.=&quot;&lt;&lt;&amp;paramRobust&lt;&lt; // time independent parameters</span>
<span class="lineNum">    2311 </span>            :     &quot;\n&quot;;
<span class="lineNum">    2312 </span><span class="lineNoCov">          0 :   delete grmedTRD;</span>
<span class="lineNum">    2313 </span><span class="lineNoCov">          0 :   delete grmedTOF;</span>
<span class="lineNum">    2314 </span><span class="lineNoCov">          0 :   delete grmedQA;</span>
<span class="lineNum">    2315 </span><span class="lineNoCov">          0 :   delete grregTRD;</span>
<span class="lineNum">    2316 </span><span class="lineNoCov">          0 :   delete grregTOF;</span>
<span class="lineNum">    2317 </span><span class="lineNoCov">          0 :   delete grregQA;</span>
<span class="lineNum">    2318 </span>            :   
<span class="lineNum">    2319 </span><span class="lineNoCov">          0 :   delete deltaZTOF;</span>
<span class="lineNum">    2320 </span><span class="lineNoCov">          0 :   delete deltaZTRD;</span>
<span class="lineNum">    2321 </span><span class="lineNoCov">          0 :   delete vecZ;</span>
<span class="lineNum">    2322 </span><span class="lineNoCov">          0 :   delete vecR;</span>
<span class="lineNum">    2323 </span><span class="lineNoCov">          0 :   delete vecSec;</span>
<span class="lineNum">    2324 </span><span class="lineNoCov">          0 :   delete vecPhi;</span>
<span class="lineNum">    2325 </span><span class="lineNoCov">          0 :   delete vecTime;</span>
<span class="lineNum">    2326 </span><span class="lineNoCov">          0 :   delete vecTOFBC;</span>
<span class="lineNum">    2327 </span>            : 
<span class="lineNum">    2328 </span><span class="lineNoCov">          0 :   delete pcstream;   </span>
<span class="lineNum">    2329 </span>            :   return kTRUE;
<span class="lineNum">    2330 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2331 </span>            : 
<a name="2332"><span class="lineNum">    2332 </span>            : </a>
<span class="lineNum">    2333 </span>            : 
<span class="lineNum">    2334 </span>            : void  AliTPCcalibAlignInterpolation::MakeNDFit(const char * inputFile, const char * inputTree, Float_t sector0,  Float_t sector1,  Float_t theta0, Float_t theta1){
<span class="lineNum">    2335 </span>            :   //
<span class="lineNum">    2336 </span>            :   /// 
<span class="lineNum">    2337 </span>            :   /// Make ND local regression, QA  for later usage
<span class="lineNum">    2338 </span>            :   /// Parameters:
<span class="lineNum">    2339 </span>            : 
<span class="lineNum">    2340 </span>            :   // Algorithm:
<span class="lineNum">    2341 </span>            :   //  1.) Make NDLocal regression fits
<span class="lineNum">    2342 </span>            :   //  2.) Make regularization (smoothing)
<span class="lineNum">    2343 </span>            :   //  3.) Make QA trending variable
<span class="lineNum">    2344 </span>            :   //  4.) Make QA plots
<span class="lineNum">    2345 </span>            :   //  5.) Export QA trending variables into trending tree
<span class="lineNum">    2346 </span>            :   //
<span class="lineNum">    2347 </span>            :   /*
<span class="lineNum">    2348 </span>            :     Example usage:
<span class="lineNum">    2349 </span>            :     const char * inputFile=&quot;ResidualMapFull_1.root&quot;
<span class="lineNum">    2350 </span>            :     const char * inputTree=&quot;deltaRPhiTPCITSTRDDist&quot;
<span class="lineNum">    2351 </span>            :     Float_t sector0=3, sector1 =5;
<span class="lineNum">    2352 </span>            :     Float_t theta0=0, theta1=1;
<span class="lineNum">    2353 </span>            :     AliTPCcalibAlignInterpolation::MakeNDFit(inputFile,inputTree, sector0,sector1, theta0,theta1);
<span class="lineNum">    2354 </span>            :   */
<span class="lineNum">    2355 </span>            : 
<span class="lineNum">    2356 </span><span class="lineNoCov">          0 :   TTreeSRedirector * pcstream = new TTreeSRedirector(TString::Format(&quot;%sFit_sec%d_%d_theta%d_%d.root&quot;,inputTree,Int_t(sector0),Int_t(sector1),Int_t(theta0),Int_t(theta1)).Data(),&quot;recreate&quot;);</span>
<span class="lineNum">    2357 </span><span class="lineNoCov">          0 :   TTreeSRedirector * pcstreamFit = new TTreeSRedirector(TString::Format(&quot;fitTree_%sFit_sec%d_%d_theta%d_%d.root&quot;,inputTree,Int_t(sector0),Int_t(sector1),Int_t(theta0),Int_t(theta1)).Data(),&quot;recreate&quot;);</span>
<span class="lineNum">    2358 </span><span class="lineNoCov">          0 :   Int_t runNumber=TString(gSystem-&gt;Getenv(&quot;runNumber&quot;)).Atoi();</span>
<span class="lineNum">    2359 </span><span class="lineNoCov">          0 :   TFile * fdist = TFile::Open(inputFile);</span>
<span class="lineNum">    2360 </span><span class="lineNoCov">          0 :   if (!fdist){</span>
<span class="lineNum">    2361 </span><span class="lineNoCov">          0 :     ::Error(&quot;MakeNDFit&quot;,&quot;Intput file %s not accessible\n&quot;,inputFile);</span>
<span class="lineNum">    2362 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    2363 </span>            :   }
<span class="lineNum">    2364 </span><span class="lineNoCov">          0 :   TTree *treeDist = (TTree*)fdist-&gt;Get(inputTree);</span>
<span class="lineNum">    2365 </span><span class="lineNoCov">          0 :   if (!treeDist){</span>
<span class="lineNum">    2366 </span><span class="lineNoCov">          0 :     ::Error(&quot;MakeNDFit&quot;,&quot;Intput tree %s not accessible\n&quot;,inputTree);</span>
<span class="lineNum">    2367 </span><span class="lineNoCov">          0 :     return;    </span>
<span class="lineNum">    2368 </span>            :   }
<span class="lineNum">    2369 </span><span class="lineNoCov">          0 :   TTree *treeMeta = (TTree*)fdist-&gt;Get(&quot;metaData&quot;);</span>
<span class="lineNum">    2370 </span><span class="lineNoCov">          0 :   pcstream-&gt;GetFile()-&gt;cd();</span>
<span class="lineNum">    2371 </span><span class="lineNoCov">          0 :   TTree *treeMetaCopy =  treeMeta-&gt;CopyTree(&quot;1&quot;);</span>
<span class="lineNum">    2372 </span><span class="lineNoCov">          0 :   treeMetaCopy-&gt;Write(&quot;metaData&quot;);</span>
<span class="lineNum">    2373 </span><span class="lineNoCov">          0 :   delete treeMetaCopy;</span>
<span class="lineNum">    2374 </span>            :   //
<span class="lineNum">    2375 </span>            :   // 1.) Make NDLocal regression fits
<span class="lineNum">    2376 </span>            :   //
<span class="lineNum">    2377 </span>            :   const Double_t pxmin=8.48499984741210938e+01; //param.GetPadRowRadii(0,0)-param.GetPadPitchLength(0,0)/2
<span class="lineNum">    2378 </span>            :   const Double_t pxmax=2.46600006103515625e+02; //2.46600006103515625e+02param.GetPadRowRadii(36,param.GetNRow(36)-1)+param.GetPadPitchLength(36,param.GetNRow(36)-1)/2.
<span class="lineNum">    2379 </span>            :   Int_t     ndim=4;
<span class="lineNum">    2380 </span><span class="lineNoCov">          0 :   Int_t     nbins[4]= {30,  (Int_t)((sector1-sector0-0.1)*15),     int(abs(theta1-theta0)*10),        3};  // {radius, phi bin, }</span>
<span class="lineNum">    2381 </span><span class="lineNoCov">          0 :   Double_t  xmin[4] = {pxmin,  sector0+0.05,   theta0,                            -2.0};</span>
<span class="lineNum">    2382 </span><span class="lineNoCov">          0 :   Double_t  xmax[4] = {pxmax, sector1-0.05,   theta1,               2.0};</span>
<span class="lineNum">    2383 </span>            :   //
<span class="lineNum">    2384 </span>            : 
<span class="lineNum">    2385 </span><span class="lineNoCov">          0 :   THnF* hN= new THnF(&quot;exampleFit&quot;,&quot;exampleFit&quot;, ndim, nbins, xmin,xmax);</span>
<span class="lineNum">    2386 </span><span class="lineNoCov">          0 :   treeDist-&gt;SetAlias(&quot;isOK&quot;,&quot;rms&gt;0&amp;&amp;vecLTM.fElements[1]*binMedian&gt;0&quot;);</span>
<span class="lineNum">    2387 </span><span class="lineNoCov">          0 :   treeDist-&gt;SetAlias(&quot;delta&quot;,&quot;vecLTM.fElements[1]&quot;);</span>
<span class="lineNum">    2388 </span><span class="lineNoCov">          0 :   TCut cutFit=&quot;isOK&quot;;</span>
<span class="lineNum">    2389 </span><span class="lineNoCov">          0 :   TCut cutAcceptFit=TString::Format(&quot;sectorCenter&gt;%f&amp;&amp;sectorCenter&lt;%f&amp;&amp;kZCenter&gt;%f&amp;&amp;kZCenter&lt;%f&quot;, sector0-0.5,sector1+0.5,theta0,theta1).Data();</span>
<span class="lineNum">    2390 </span><span class="lineNoCov">          0 :   TCut cutAcceptDraw=TString::Format(&quot;sectorCenter&gt;%f&amp;&amp;sectorCenter&lt;%f&amp;&amp;kZCenter&gt;%f&amp;&amp;kZCenter&lt;%f&quot;, sector0,sector1,theta0,theta1).Data();</span>
<span class="lineNum">    2391 </span>            :   
<span class="lineNum">    2392 </span><span class="lineNoCov">          0 :   AliNDLocalRegression *fitCorrs[6]={0};</span>
<span class="lineNum">    2393 </span><span class="lineNoCov">          0 :   for (Int_t icorr=0; icorr&lt;1; icorr++){</span>
<span class="lineNum">    2394 </span><span class="lineNoCov">          0 :     fitCorrs[icorr]= new  AliNDLocalRegression();</span>
<span class="lineNum">    2395 </span><span class="lineNoCov">          0 :     fitCorrs[icorr]-&gt;SetName(TString::Format(&quot;%sFit%d_sec%d_%d_theta%d_%d&quot;,inputTree,icorr, Int_t(sector0),Int_t(sector1),Int_t(theta0),Int_t(theta1)).Data());  </span>
<span class="lineNum">    2396 </span><span class="lineNoCov">          0 :     Int_t hashIndex=fitCorrs[icorr]-&gt;GetVisualCorrectionIndex();</span>
<span class="lineNum">    2397 </span><span class="lineNoCov">          0 :     fitCorrs[icorr]-&gt;SetHistogram((THn*)(hN-&gt;Clone()));  </span>
<span class="lineNum">    2398 </span><span class="lineNoCov">          0 :     TStopwatch timer;</span>
<span class="lineNum">    2399 </span><span class="lineNoCov">          0 :     fitCorrs[0]-&gt;SetStreamer(pcstream);</span>
<span class="lineNum">    2400 </span><span class="lineNoCov">          0 :     if (icorr==0) fitCorrs[icorr]-&gt;MakeFit(treeDist,&quot;delta:(1+sqrt(abs(qptCenter)))/sqrt(entries)&quot;, &quot;RCenter:sectorCenter:kZCenter:qptCenter&quot;,cutFit+cutAcceptFit,&quot;3:0.05:0.1:18&quot;,&quot;2:2:2:2&quot;,0.0001);</span>
<span class="lineNum">    2401 </span><span class="lineNoCov">          0 :     timer.Print();</span>
<span class="lineNum">    2402 </span><span class="lineNoCov">          0 :     AliNDLocalRegression::AddVisualCorrection(fitCorrs[icorr]);</span>
<span class="lineNum">    2403 </span><span class="lineNoCov">          0 :     treeDist-&gt;SetAlias(TString::Format(&quot;delta_Fit%d&quot;,icorr).Data(),TString::Format(&quot;AliNDLocalRegression::GetCorrND(%d,RCenter,sectorCenter,kZCenter,qptCenter+0)&quot;,hashIndex).Data());</span>
<span class="lineNum">    2404 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2405 </span>            :   //
<span class="lineNum">    2406 </span>            :   // 2.) Make regularization (smoothing)
<span class="lineNum">    2407 </span>            :   //    
<span class="lineNum">    2408 </span>            :   Int_t nDims=4;
<span class="lineNum">    2409 </span><span class="lineNoCov">          0 :   Int_t indexes[4]={0,1,2,3};</span>
<span class="lineNum">    2410 </span><span class="lineNoCov">          0 :   Double_t relWeight0[12]={1,4,16,   1,4,16, 1,4,16, 1,4,16};</span>
<span class="lineNum">    2411 </span><span class="lineNoCov">          0 :   Double_t relWeightC[12]={0.5,4,16,   0.5,4,16, 0.5,4,16, 0.5,4,16};</span>
<span class="lineNum">    2412 </span><span class="lineNoCov">          0 :   fitCorrs[1]=(AliNDLocalRegression *)fitCorrs[0]-&gt;Clone();</span>
<span class="lineNum">    2413 </span><span class="lineNoCov">          0 :   fitCorrs[1]-&gt;AddWeekConstrainsAtBoundaries(nDims, indexes,relWeight0, 0);</span>
<span class="lineNum">    2414 </span><span class="lineNoCov">          0 :   fitCorrs[2]=(AliNDLocalRegression *)fitCorrs[1]-&gt;Clone();</span>
<span class="lineNum">    2415 </span><span class="lineNoCov">          0 :   fitCorrs[2]-&gt;AddWeekConstrainsAtBoundaries(nDims, indexes,relWeight0, 0);</span>
<span class="lineNum">    2416 </span><span class="lineNoCov">          0 :   fitCorrs[3]=(AliNDLocalRegression *)fitCorrs[1]-&gt;Clone();</span>
<span class="lineNum">    2417 </span><span class="lineNoCov">          0 :   fitCorrs[4]=(AliNDLocalRegression *)fitCorrs[2]-&gt;Clone();</span>
<span class="lineNum">    2418 </span><span class="lineNoCov">          0 :   fitCorrs[3]-&gt;AddWeekConstrainsAtBoundaries(nDims, indexes,relWeightC, 0, kTRUE);</span>
<span class="lineNum">    2419 </span><span class="lineNoCov">          0 :   fitCorrs[4]-&gt;AddWeekConstrainsAtBoundaries(nDims, indexes,relWeightC, 0, kTRUE);</span>
<span class="lineNum">    2420 </span>            :   //
<span class="lineNum">    2421 </span><span class="lineNoCov">          0 :   fitCorrs[1]-&gt;SetName(TString::Format(&quot;%s_Smooth1&quot;,fitCorrs[0]-&gt;GetName()).Data());</span>
<span class="lineNum">    2422 </span><span class="lineNoCov">          0 :   fitCorrs[2]-&gt;SetName(TString::Format(&quot;%s_Smooth2&quot;,fitCorrs[1]-&gt;GetName()).Data());</span>
<span class="lineNum">    2423 </span><span class="lineNoCov">          0 :   fitCorrs[3]-&gt;SetName(TString::Format(&quot;%s_SmoothConst1&quot;,fitCorrs[0]-&gt;GetName()).Data());</span>
<span class="lineNum">    2424 </span><span class="lineNoCov">          0 :   fitCorrs[4]-&gt;SetName(TString::Format(&quot;%s_SmoothConst2&quot;,fitCorrs[1]-&gt;GetName()).Data()); </span>
<span class="lineNum">    2425 </span><span class="lineNoCov">          0 :   for (Int_t icorr=1; icorr&lt;5; icorr++){</span>
<span class="lineNum">    2426 </span><span class="lineNoCov">          0 :     Int_t hashIndex=fitCorrs[icorr]-&gt;GetVisualCorrectionIndex();</span>
<span class="lineNum">    2427 </span><span class="lineNoCov">          0 :     AliNDLocalRegression::AddVisualCorrection(fitCorrs[icorr]);</span>
<span class="lineNum">    2428 </span><span class="lineNoCov">          0 :     treeDist-&gt;SetAlias(TString::Format(&quot;delta_Fit%d&quot;,icorr).Data(),TString::Format(&quot;AliNDLocalRegression::GetCorrND(%d,RCenter,sectorCenter,kZCenter,qptCenter+0)&quot;,hashIndex).Data());</span>
<span class="lineNum">    2429 </span>            :   }  
<span class="lineNum">    2430 </span>            :   //
<span class="lineNum">    2431 </span>            :   // 3.) Make QA variables and store fits
<span class="lineNum">    2432 </span>            :   //
<span class="lineNum">    2433 </span><span class="lineNoCov">          0 :   gStyle-&gt;SetOptFit(1);</span>
<span class="lineNum">    2434 </span><span class="lineNoCov">          0 :   treeDist-&gt;Draw(&quot;&gt;&gt;drawlist3&quot;,cutFit+cutAcceptDraw,&quot;entrylist&quot;);</span>
<span class="lineNum">    2435 </span><span class="lineNoCov">          0 :   TEntryList *elist = (TEntryList*)gDirectory-&gt;Get(&quot;drawlist3&quot;);</span>
<span class="lineNum">    2436 </span><span class="lineNoCov">          0 :   treeDist-&gt;SetEntryList(elist);</span>
<span class="lineNum">    2437 </span>            : 
<span class="lineNum">    2438 </span><span class="lineNoCov">          0 :   Double_t quantiles[10]={0.001,0.01,0.05,0.1,0.2, 0.8,0.9,0.99,0.999};</span>
<span class="lineNum">    2439 </span><span class="lineNoCov">          0 :   Double_t deltas[10]={0};  </span>
<span class="lineNum">    2440 </span><span class="lineNoCov">          0 :   const char * pchVar[9]={&quot;delta-delta_Fit0&quot;,</span>
<span class="lineNum">    2441 </span>            :                            &quot;delta-delta_Fit1&quot;,
<span class="lineNum">    2442 </span>            :                            &quot;delta-delta_Fit2&quot;,
<span class="lineNum">    2443 </span>            :                            &quot;delta-delta_Fit3&quot;,
<span class="lineNum">    2444 </span>            :                            &quot;delta-delta_Fit4&quot;,
<span class="lineNum">    2445 </span>            :                            &quot;delta_Fit0-delta_Fit1&quot;,
<span class="lineNum">    2446 </span>            :                            &quot;delta_Fit0-delta_Fit2&quot;,
<span class="lineNum">    2447 </span>            :                            &quot;delta_Fit0-delta_Fit3&quot;,
<span class="lineNum">    2448 </span>            :                            &quot;delta_Fit0-delta_Fit4&quot;};
<span class="lineNum">    2449 </span><span class="lineNoCov">          0 :   const char * pchTittle[9]={&quot;map-fit_{0} (cm)&quot;,</span>
<span class="lineNum">    2450 </span>            :                               &quot;map-fit_{0Reg1} (cm)&quot;,
<span class="lineNum">    2451 </span>            :                               &quot;map-fit_{0Reg2} (cm)&quot;,
<span class="lineNum">    2452 </span>            :                               &quot;map-fit_{0Reg1Const} (cm)&quot;,
<span class="lineNum">    2453 </span>            :                               &quot;map-fit_{0Reg2Const} (cm)&quot;,
<span class="lineNum">    2454 </span>            :                               &quot;fit_{O}-fit_{0Reg1} (cm)&quot;,
<span class="lineNum">    2455 </span>            :                               &quot;fit_{0}-fit_{0Reg2} (cm)&quot;,
<span class="lineNum">    2456 </span>            :                               &quot;fit_{0}-fit_{0Reg1Const} (cm)&quot;,
<span class="lineNum">    2457 </span>            :                               &quot;fit_{0}-fit_{0Reg2Const} (cm)&quot;};
<span class="lineNum">    2458 </span><span class="lineNoCov">          0 :   TGraph *    grQuantiles[18]={0};  </span>
<span class="lineNum">    2459 </span><span class="lineNoCov">          0 :   TVectorD    vecRMS1(18);</span>
<span class="lineNum">    2460 </span><span class="lineNoCov">          0 :   for (Int_t idiff=0; idiff&lt;18; idiff++){</span>
<span class="lineNum">    2461 </span>            :     Int_t chEntries=0;
<span class="lineNum">    2462 </span><span class="lineNoCov">          0 :     if (idiff&lt;9){</span>
<span class="lineNum">    2463 </span><span class="lineNoCov">          0 :       chEntries=treeDist-&gt;Draw(pchVar[idiff%9],&quot;1&quot;,&quot;goff&quot;);</span>
<span class="lineNum">    2464 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2465 </span><span class="lineNoCov">          0 :     if (idiff&gt;=9){</span>
<span class="lineNum">    2466 </span><span class="lineNoCov">          0 :       chEntries=treeDist-&gt;Draw(TString::Format(&quot;(%s)/(rms/sqrt(entries))&quot;,pchVar[idiff%9]).Data(),&quot;1&quot;,&quot;goff&quot;);</span>
<span class="lineNum">    2467 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2468 </span><span class="lineNoCov">          0 :     for (Int_t iq=0; iq&lt;10; iq++){</span>
<span class="lineNum">    2469 </span><span class="lineNoCov">          0 :       deltas[iq]=TMath::KOrdStat(chEntries,treeDist-&gt;GetV1(), Int_t(chEntries*quantiles[iq]));</span>
<span class="lineNum">    2470 </span>            :     }
<span class="lineNum">    2471 </span><span class="lineNoCov">          0 :     grQuantiles[idiff]=new TGraph(10,quantiles,deltas);</span>
<span class="lineNum">    2472 </span><span class="lineNoCov">          0 :     grQuantiles[idiff]-&gt;SetTitle(pchTittle[idiff%9]);</span>
<span class="lineNum">    2473 </span><span class="lineNoCov">          0 :     Double_t mean, rms=0;</span>
<span class="lineNum">    2474 </span><span class="lineNoCov">          0 :     AliMathBase::EvaluateUni(chEntries,treeDist-&gt;GetV1(),mean, rms,0.80*chEntries);</span>
<span class="lineNum">    2475 </span><span class="lineNoCov">          0 :     vecRMS1[idiff]=rms;</span>
<span class="lineNum">    2476 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2477 </span><span class="lineNoCov">          0 :   vecRMS1.Print();</span>
<span class="lineNum">    2478 </span>            :   TH1* his=0;
<span class="lineNum">    2479 </span><span class="lineNoCov">          0 :   TVectorD slopePols1(5);</span>
<span class="lineNum">    2480 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;5; i++){</span>
<span class="lineNum">    2481 </span><span class="lineNoCov">          0 :     treeDist-&gt;Draw(TString::Format(&quot;delta:delta_Fit%d&gt;&gt;hisQA2D%d&quot;,i,i).Data(),cutFit+cutAcceptDraw,&quot;colzgoff&quot;); </span>
<span class="lineNum">    2482 </span><span class="lineNoCov">          0 :     his=treeDist-&gt;GetHistogram();</span>
<span class="lineNum">    2483 </span><span class="lineNoCov">          0 :     his-&gt;Fit(&quot;pol1&quot;);</span>
<span class="lineNum">    2484 </span><span class="lineNoCov">          0 :     slopePols1[i]= his-&gt;GetFunction(&quot;pol1&quot;)-&gt;GetParameter(1);</span>
<span class="lineNum">    2485 </span>            :   }
<span class="lineNum">    2486 </span>            : 
<span class="lineNum">    2487 </span><span class="lineNoCov">          0 :   TFile * fout = pcstream-&gt;GetFile();</span>
<span class="lineNum">    2488 </span><span class="lineNoCov">          0 :   pcstream-&gt;GetFile()-&gt;cd();</span>
<span class="lineNum">    2489 </span><span class="lineNoCov">          0 :   for (Int_t iter=0; iter&lt;5; iter++){</span>
<span class="lineNum">    2490 </span><span class="lineNoCov">          0 :     if (TString(gSystem-&gt;Getenv(&quot;AliTPCcalibAlignInterpolation_MakeNDFit_KeepCovariance&quot;)).Atoi()==0){</span>
<span class="lineNum">    2491 </span><span class="lineNoCov">          0 :       if (iter!=0) fitCorrs[iter]-&gt;CleanCovariance();</span>
<span class="lineNum">    2492 </span>            :     }
<span class="lineNum">    2493 </span><span class="lineNoCov">          0 :     fitCorrs[iter]-&gt;Write();</span>
<span class="lineNum">    2494 </span><span class="lineNoCov">          0 :     if (TString(gSystem-&gt;Getenv(&quot;AliTPCcalibAlignInterpolation_MakeNDFit_DumpFitTree&quot;)).Atoi()&gt;0){</span>
<span class="lineNum">    2495 </span><span class="lineNoCov">          0 :       fitCorrs[iter]-&gt;DumpToTree(4, (*pcstreamFit)&lt;&lt;TString::Format(&quot;tree%s&quot;, fitCorrs[iter]-&gt;GetName()).Data());</span>
<span class="lineNum">    2496 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2497 </span>            :   }
<span class="lineNum">    2498 </span>            :   //
<span class="lineNum">    2499 </span>            :   // 4.) Make standard QA plot   
<span class="lineNum">    2500 </span>            :   //
<span class="lineNum">    2501 </span><span class="lineNoCov">          0 :   gStyle-&gt;SetLabelSize(0.06,&quot;XYZ&quot;);</span>
<span class="lineNum">    2502 </span><span class="lineNoCov">          0 :   gStyle-&gt;SetTitleSize(0.06,&quot;XYZ&quot;);</span>
<span class="lineNum">    2503 </span><span class="lineNoCov">          0 :   TCanvas *canvasQA = new TCanvas(&quot;canvasQA&quot;,&quot;canvasQA&quot;,1200,1000);</span>
<span class="lineNum">    2504 </span><span class="lineNoCov">          0 :   canvasQA-&gt;Divide(1,3);</span>
<span class="lineNum">    2505 </span>            :   //
<span class="lineNum">    2506 </span>            :   // 4.1) delta:fit correaltion
<span class="lineNum">    2507 </span><span class="lineNoCov">          0 :   canvasQA-&gt;cd(1)-&gt;SetLogz();</span>
<span class="lineNum">    2508 </span><span class="lineNoCov">          0 :   treeDist-&gt;Draw(&quot;delta:delta_Fit0&gt;&gt;hisQA2D&quot;,cutFit+cutAcceptDraw,&quot;colzgoff&quot;);</span>
<span class="lineNum">    2509 </span><span class="lineNoCov">          0 :   his=treeDist-&gt;GetHistogram();</span>
<span class="lineNum">    2510 </span><span class="lineNoCov">          0 :   his-&gt;GetXaxis()-&gt;SetTitle(&quot;#Delta_{fit} (cm)&quot;);</span>
<span class="lineNum">    2511 </span><span class="lineNoCov">          0 :   his-&gt;GetYaxis()-&gt;SetTitle(&quot;#Delta_{map} (cm)&quot;);</span>
<span class="lineNum">    2512 </span><span class="lineNoCov">          0 :   his-&gt;Fit(&quot;pol1&quot;);</span>
<span class="lineNum">    2513 </span><span class="lineNoCov">          0 :   Double_t slopePol1= his-&gt;GetFunction(&quot;pol1&quot;)-&gt;GetParameter(1);</span>
<span class="lineNum">    2514 </span><span class="lineNoCov">          0 :   his-&gt;Write(&quot;hisQA2D&quot;);</span>
<span class="lineNum">    2515 </span><span class="lineNoCov">          0 :   his-&gt;Draw(&quot;colz&quot;);</span>
<span class="lineNum">    2516 </span>            :   // 
<span class="lineNum">    2517 </span>            :   // 4.2) delta-fitReg0 and fitReg0-fitReg1
<span class="lineNum">    2518 </span><span class="lineNoCov">          0 :   canvasQA-&gt;cd(2)-&gt;SetLogy();</span>
<span class="lineNum">    2519 </span><span class="lineNoCov">          0 :   treeDist-&gt;SetLineColor(1); treeDist-&gt;SetMarkerColor(1);</span>
<span class="lineNum">    2520 </span><span class="lineNoCov">          0 :   treeDist-&gt;Draw(&quot;delta-delta_Fit0&gt;&gt;hisQA1D(300)&quot;,cutFit+cutAcceptDraw,&quot;goff&quot;);</span>
<span class="lineNum">    2521 </span><span class="lineNoCov">          0 :   his=treeDist-&gt;GetHistogram();  </span>
<span class="lineNum">    2522 </span><span class="lineNoCov">          0 :   his-&gt;GetXaxis()-&gt;SetTitle(&quot;#Delta_{map}-#Delta_{fit} (cm)&quot;);</span>
<span class="lineNum">    2523 </span><span class="lineNoCov">          0 :   his-&gt;Fit(&quot;gaus&quot;);</span>
<span class="lineNum">    2524 </span><span class="lineNoCov">          0 :   Double_t mean=his-&gt;GetMean();</span>
<span class="lineNum">    2525 </span><span class="lineNoCov">          0 :   Double_t rms=his-&gt;GetRMS();</span>
<span class="lineNum">    2526 </span><span class="lineNoCov">          0 :   Double_t rmsG= his-&gt;GetFunction(&quot;gaus&quot;)-&gt;GetParameter(2);</span>
<span class="lineNum">    2527 </span>            :   //
<span class="lineNum">    2528 </span><span class="lineNoCov">          0 :   treeDist-&gt;GetHistogram()-&gt;Write(&quot;hisQA1D&quot;);</span>
<span class="lineNum">    2529 </span><span class="lineNoCov">          0 :   treeDist-&gt;SetLineColor(2); treeDist-&gt;SetMarkerColor(2);</span>
<span class="lineNum">    2530 </span><span class="lineNoCov">          0 :   treeDist-&gt;Draw(&quot;delta_Fit0-delta_Fit1&gt;&gt;hisQA1DifFit(300)&quot;,cutFit+cutAcceptDraw,&quot;same&quot;);</span>
<span class="lineNum">    2531 </span><span class="lineNoCov">          0 :   his=treeDist-&gt;GetHistogram();</span>
<span class="lineNum">    2532 </span><span class="lineNoCov">          0 :   Double_t meanDiffFit=his-&gt;GetMean();</span>
<span class="lineNum">    2533 </span><span class="lineNoCov">          0 :   Double_t rmsDiffFit=his-&gt;GetRMS();</span>
<span class="lineNum">    2534 </span><span class="lineNoCov">          0 :   treeDist-&gt;GetHistogram()-&gt;Write(&quot;hisQA1DifFit&quot;);</span>
<span class="lineNum">    2535 </span>            :   //
<span class="lineNum">    2536 </span>            :   // 4.3) (delta-fitReg0) &quot;pull&quot; 
<span class="lineNum">    2537 </span><span class="lineNoCov">          0 :   treeDist-&gt;SetLineColor(1); treeDist-&gt;SetMarkerColor(1);</span>
<span class="lineNum">    2538 </span><span class="lineNoCov">          0 :   canvasQA-&gt;cd(3)-&gt;SetLogy();</span>
<span class="lineNum">    2539 </span><span class="lineNoCov">          0 :   treeDist-&gt;Draw(&quot;(delta_Fit0-delta)/(rms/sqrt(entries))&gt;&gt;hisQAPull&quot;,cutFit+cutAcceptDraw,&quot;goff&quot;);</span>
<span class="lineNum">    2540 </span><span class="lineNoCov">          0 :   his=treeDist-&gt;GetHistogram();</span>
<span class="lineNum">    2541 </span><span class="lineNoCov">          0 :   his-&gt;Fit(&quot;gaus&quot;);</span>
<span class="lineNum">    2542 </span><span class="lineNoCov">          0 :   Double_t meanPull=his-&gt;GetMean();</span>
<span class="lineNum">    2543 </span><span class="lineNoCov">          0 :   Double_t rmsPull=his-&gt;GetRMS();</span>
<span class="lineNum">    2544 </span><span class="lineNoCov">          0 :   Double_t rmsPullG= his-&gt;GetFunction(&quot;gaus&quot;)-&gt;GetParameter(2);</span>
<span class="lineNum">    2545 </span><span class="lineNoCov">          0 :   treeDist-&gt;GetHistogram()-&gt;Write(&quot;hisQAPull&quot;);</span>
<span class="lineNum">    2546 </span><span class="lineNoCov">          0 :   treeDist-&gt;SetLineColor(2); treeDist-&gt;SetMarkerColor(2);</span>
<span class="lineNum">    2547 </span><span class="lineNoCov">          0 :   treeDist-&gt;Draw(&quot;(delta_Fit0-delta_Fit1)/(rms/sqrt(entries))&gt;&gt;hisQAPullDifFit&quot;,cutFit+cutAcceptDraw,&quot;same&quot;);</span>
<span class="lineNum">    2548 </span><span class="lineNoCov">          0 :   his=treeDist-&gt;GetHistogram();</span>
<span class="lineNum">    2549 </span><span class="lineNoCov">          0 :   Double_t meanPullDiffFit=his-&gt;GetMean();</span>
<span class="lineNum">    2550 </span><span class="lineNoCov">          0 :   Double_t rmsPullDiffFit=his-&gt;GetRMS();</span>
<span class="lineNum">    2551 </span><span class="lineNoCov">          0 :   treeDist-&gt;GetHistogram()-&gt;Write(&quot;hisQAPullDiffFit&quot;);</span>
<span class="lineNum">    2552 </span>            : 
<span class="lineNum">    2553 </span><span class="lineNoCov">          0 :   canvasQA-&gt;SaveAs((TString::Format(&quot;%sFit_sec%d_%d_theta%d_%dQA.png&quot;,inputTree,Int_t(sector0),Int_t(sector1),Int_t(theta0),Int_t(theta1)).Data()));</span>
<span class="lineNum">    2554 </span>            : 
<span class="lineNum">    2555 </span><span class="lineNoCov">          0 :   TCanvas *canvasQAFit = new TCanvas(&quot;canvasQAFit&quot;,&quot;canvasQAFit&quot;,1200,1000); </span>
<span class="lineNum">    2556 </span><span class="lineNoCov">          0 :   canvasQAFit-&gt;SetRightMargin(0.01);</span>
<span class="lineNum">    2557 </span><span class="lineNoCov">          0 :   canvasQAFit-&gt;Divide(1,5,0,0); </span>
<span class="lineNum">    2558 </span><span class="lineNoCov">          0 :   treeDist-&gt;SetMarkerStyle(25);</span>
<span class="lineNum">    2559 </span><span class="lineNoCov">          0 :   treeDist-&gt;SetMarkerSize(0.5);</span>
<span class="lineNum">    2560 </span><span class="lineNoCov">          0 :   TCut defaultCut=&quot;abs(qptCenter)&lt;0.1&quot;;</span>
<span class="lineNum">    2561 </span>            :   //
<span class="lineNum">    2562 </span>            :   {
<span class="lineNum">    2563 </span><span class="lineNoCov">          0 :     canvasQAFit-&gt;cd(1)-&gt;SetRightMargin(0.1);</span>
<span class="lineNum">    2564 </span><span class="lineNoCov">          0 :     treeDist-&gt;Draw(&quot;delta:sectorCenter:RCenter&quot;,defaultCut+&quot;abs(abs(kZCenter)-0.1)&lt;0.06&quot;,&quot;colz&quot;);</span>
<span class="lineNum">    2565 </span><span class="lineNoCov">          0 :     canvasQAFit-&gt;cd(2)-&gt;SetRightMargin(0.1);</span>
<span class="lineNum">    2566 </span><span class="lineNoCov">          0 :     treeDist-&gt;Draw(&quot;delta-delta_Fit0:sectorCenter:RCenter&quot;,defaultCut+&quot;abs(abs(kZCenter)-0.1)&lt;0.06&quot;,&quot;colz&quot;);</span>
<span class="lineNum">    2567 </span><span class="lineNoCov">          0 :     canvasQAFit-&gt;cd(3)-&gt;SetRightMargin(0.1);</span>
<span class="lineNum">    2568 </span><span class="lineNoCov">          0 :     treeDist-&gt;Draw(&quot;delta-delta_Fit1:sectorCenter:RCenter&quot;,defaultCut+&quot;abs(abs(kZCenter)-0.1)&lt;0.06&quot;,&quot;colz&quot;);</span>
<span class="lineNum">    2569 </span><span class="lineNoCov">          0 :     canvasQAFit-&gt;cd(4)-&gt;SetRightMargin(0.1);</span>
<span class="lineNum">    2570 </span><span class="lineNoCov">          0 :     treeDist-&gt;Draw(&quot;delta-delta_Fit2:sectorCenter:RCenter&quot;,defaultCut+&quot;abs(abs(kZCenter)-0.1)&lt;0.06&quot;,&quot;colz&quot;);</span>
<span class="lineNum">    2571 </span><span class="lineNoCov">          0 :     canvasQAFit-&gt;cd(5)-&gt;SetRightMargin(0.1);</span>
<span class="lineNum">    2572 </span><span class="lineNoCov">          0 :     treeDist-&gt;Draw(&quot;delta_Fit0-delta_Fit2:sectorCenter:RCenter&quot;,defaultCut+&quot;abs(abs(kZCenter)-0.1)&lt;0.06&quot;,&quot;colz&quot;);</span>
<span class="lineNum">    2573 </span>            :   }
<span class="lineNum">    2574 </span><span class="lineNoCov">          0 :   canvasQAFit-&gt;SaveAs((TString::Format(&quot;%sFit_sec%d_%d_theta%d_%dQAFit.png&quot;,inputTree,Int_t(sector0),Int_t(sector1),Int_t(theta0),Int_t(theta1)).Data()));</span>
<span class="lineNum">    2575 </span><span class="lineNoCov">          0 :   TObjString input=inputTree;</span>
<span class="lineNum">    2576 </span>            :   //
<span class="lineNum">    2577 </span>            :   // 5.) Export trending variables - used for validation of the fit
<span class="lineNum">    2578 </span>            :   //
<span class="lineNum">    2579 </span><span class="lineNoCov">          0 :   treeMeta-&gt;Draw(&quot;runNumber:selHis:fillCounter:clusterCounter:meanTime:ntracksUsed:startTime:stopTime&quot;,&quot;1&quot;,&quot;goffpara&quot;);</span>
<span class="lineNum">    2580 </span><span class="lineNoCov">          0 :   (*pcstream)&lt;&lt;&quot;NDFitTrending&quot;&lt;&lt;               // cp of subset of info from meta data (rest accessible in the metadata tree also avaialble in file)</span>
<span class="lineNum">    2581 </span><span class="lineNoCov">          0 :     &quot;run=&quot;&lt;&lt;treeMeta-&gt;GetVal(0)[0]&lt;&lt;      </span>
<span class="lineNum">    2582 </span><span class="lineNoCov">          0 :     &quot;selHis=&quot;&lt;&lt;treeMeta-&gt;GetVal(1)[0]&lt;&lt;</span>
<span class="lineNum">    2583 </span><span class="lineNoCov">          0 :     &quot;fillCounter=&quot;&lt;&lt;treeMeta-&gt;GetVal(2)[0]&lt;&lt;</span>
<span class="lineNum">    2584 </span><span class="lineNoCov">          0 :     &quot;clusterCounter=&quot;&lt;&lt;treeMeta-&gt;GetVal(3)[0]&lt;&lt;</span>
<span class="lineNum">    2585 </span><span class="lineNoCov">          0 :     &quot;meanTime=&quot;&lt;&lt;treeMeta-&gt;GetVal(4)[0]&lt;&lt;</span>
<span class="lineNum">    2586 </span><span class="lineNoCov">          0 :     &quot;ntracksUsed=&quot;&lt;&lt;treeMeta-&gt;GetVal(5)[0]&lt;&lt;</span>
<span class="lineNum">    2587 </span><span class="lineNoCov">          0 :     &quot;startTime=&quot;&lt;&lt;treeMeta-&gt;GetVal(6)[0]&lt;&lt;</span>
<span class="lineNum">    2588 </span><span class="lineNoCov">          0 :     &quot;stopTime=&quot;&lt;&lt;treeMeta-&gt;GetVal(7)[0];</span>
<span class="lineNum">    2589 </span><span class="lineNoCov">          0 :   Int_t entriesCl= treeMeta-&gt;Draw(&quot;grNcl72.fY:grNcl73.fY:grNcl74.fY:grNcl75.fY&quot;,&quot;(grNcl72.fX&gt;startTime&amp;&amp;grNcl72.fX&lt;stopTime&amp;&amp;grNcl72.fY!=0)&quot;,&quot;goffpara&quot;);</span>
<span class="lineNum">    2590 </span><span class="lineNoCov">          0 :   TVectorF vecNcl(8);</span>
<span class="lineNum">    2591 </span><span class="lineNoCov">          0 :   if (entriesCl&gt;0) {</span>
<span class="lineNum">    2592 </span><span class="lineNoCov">          0 :     for (Int_t icl=0; icl&lt;4; icl++){</span>
<span class="lineNum">    2593 </span><span class="lineNoCov">          0 :       vecNcl[icl]=TMath::Median(entriesCl, treeMeta-&gt;GetVal(icl));</span>
<span class="lineNum">    2594 </span>            :     }
<span class="lineNum">    2595 </span><span class="lineNoCov">          0 :     entriesCl= treeMeta-&gt;Draw(&quot;grNclUsed72.fY:grNclUsed73.fY:grNclUsed74.fY:grNclUsed75.fY&quot;,&quot;(grNcl72.fX&gt;startTime&amp;&amp;grNcl72.fX&lt;stopTime&amp;&amp;grNcl72.fY!=0)&quot;,&quot;goffpara&quot;);</span>
<span class="lineNum">    2596 </span><span class="lineNoCov">          0 :     for (Int_t icl=0; icl&lt;4; icl++){</span>
<span class="lineNum">    2597 </span><span class="lineNoCov">          0 :       vecNcl[icl+4]=TMath::Median(entriesCl, treeMeta-&gt;GetVal(icl));</span>
<span class="lineNum">    2598 </span>            :     }
<span class="lineNum">    2599 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2600 </span><span class="lineNoCov">          0 :   (*pcstream)&lt;&lt;&quot;NDFitTrending&quot;&lt;&lt;               // cp of subset of info from meta data (rest accessible in the metadata tree also avaialble in file)</span>
<span class="lineNum">    2601 </span><span class="lineNoCov">          0 :     &quot;vecNclCounter.=&quot;&lt;&lt;&amp;vecNcl;</span>
<span class="lineNum">    2602 </span>            :   //
<span class="lineNum">    2603 </span><span class="lineNoCov">          0 :   (*pcstream)&lt;&lt;&quot;NDFitTrending&quot;&lt;&lt;</span>
<span class="lineNum">    2604 </span><span class="lineNoCov">          0 :     &quot;input.=&quot;&lt;&lt;&amp;input&lt;&lt;                // name of the input file</span>
<span class="lineNum">    2605 </span><span class="lineNoCov">          0 :     &quot;inputTree=&quot;&lt;&lt;inputTree&lt;&lt;          // name of the input tree</span>
<span class="lineNum">    2606 </span><span class="lineNoCov">          0 :     &quot;runNumber=&quot;&lt;&lt;runNumber&lt;&lt;          // run number ID</span>
<span class="lineNum">    2607 </span><span class="lineNoCov">          0 :     &quot;sec0=&quot;&lt;&lt;sector0&lt;&lt;                 // range: sector0 </span>
<span class="lineNum">    2608 </span><span class="lineNoCov">          0 :     &quot;sec1=&quot;&lt;&lt;sector1&lt;&lt;                 // range: sector1</span>
<span class="lineNum">    2609 </span><span class="lineNoCov">          0 :     &quot;theta0=&quot;&lt;&lt;theta0&lt;&lt;                // range: theta0</span>
<span class="lineNum">    2610 </span><span class="lineNoCov">          0 :     &quot;theta1=&quot;&lt;&lt;theta1&lt;&lt;                // range: theta1 </span>
<span class="lineNum">    2611 </span>            :     //                                 // QA plots statistical info
<span class="lineNum">    2612 </span><span class="lineNoCov">          0 :     &quot;slopePols1.=&quot;&lt;&lt;&amp;slopePols1&lt;&lt;      // data:fit - pol1 fit for differnt Regularization</span>
<span class="lineNum">    2613 </span><span class="lineNoCov">          0 :     &quot;slopePol1=&quot;&lt;&lt;slopePol1&lt;&lt;</span>
<span class="lineNum">    2614 </span>            :     //
<span class="lineNum">    2615 </span><span class="lineNoCov">          0 :     &quot;mean=&quot;&lt;&lt;mean&lt;&lt;                    // mean &lt;value-fitND0&gt;</span>
<span class="lineNum">    2616 </span><span class="lineNoCov">          0 :     &quot;rms=&quot;&lt;&lt;rms&lt;&lt;                      // rms  (value-fitND0&gt;</span>
<span class="lineNum">    2617 </span><span class="lineNoCov">          0 :     &quot;rmsG=&quot;&lt;&lt;rmsG&lt;&lt;                    // gaus fit rms  (value-fitND0&gt;</span>
<span class="lineNum">    2618 </span><span class="lineNoCov">          0 :     &quot;meanPull=&quot;&lt;&lt;meanPull&lt;&lt;            // normalized mean &lt;value-fitND0&gt;</span>
<span class="lineNum">    2619 </span><span class="lineNoCov">          0 :     &quot;rmsPull=&quot;&lt;&lt;rmsPull&lt;&lt;              // normalized error&lt;value-fitND0&gt;</span>
<span class="lineNum">    2620 </span><span class="lineNoCov">          0 :     &quot;rmsPullG=&quot;&lt;&lt;rmsPull&lt;&lt;             // gaus fit normalized error&lt;value-fitND0&gt;</span>
<span class="lineNum">    2621 </span><span class="lineNoCov">          0 :     &quot;meanDiffFit=&quot;&lt;&lt;meanDiffFit&lt;&lt;      //  </span>
<span class="lineNum">    2622 </span><span class="lineNoCov">          0 :     &quot;rmsDiffFit=&quot;&lt;&lt;rmsDiffFit&lt;&lt;</span>
<span class="lineNum">    2623 </span><span class="lineNoCov">          0 :     &quot;meanPullDiffFit=&quot;&lt;&lt;meanPullDiffFit&lt;&lt;</span>
<span class="lineNum">    2624 </span><span class="lineNoCov">          0 :     &quot;rmsPullDiffFit=&quot;&lt;&lt;rmsPullDiffFit&lt;&lt;</span>
<span class="lineNum">    2625 </span><span class="lineNoCov">          0 :     &quot;vecRMS1.=&quot;&lt;&lt;&amp;vecRMS1;  // rms of the diffs of different estimators (Kernles, Regularization)</span>
<span class="lineNum">    2626 </span><span class="lineNoCov">          0 :   for (Int_t iq=0; iq&lt;18; iq++){</span>
<span class="lineNum">    2627 </span><span class="lineNoCov">          0 :     (*pcstream)&lt;&lt;&quot;NDFitTrending&quot;&lt;&lt;</span>
<span class="lineNum">    2628 </span><span class="lineNoCov">          0 :       TString::Format(&quot;grQuantiles%d.=&quot;,iq).Data()&lt;&lt;grQuantiles[iq];</span>
<span class="lineNum">    2629 </span>            :   }
<span class="lineNum">    2630 </span><span class="lineNoCov">          0 :   (*pcstream)&lt;&lt;&quot;NDFitTrending&quot;&lt;&lt;&quot;\n&quot;;</span>
<span class="lineNum">    2631 </span><span class="lineNoCov">          0 :   delete treeMeta;</span>
<span class="lineNum">    2632 </span><span class="lineNoCov">          0 :   delete pcstream;</span>
<span class="lineNum">    2633 </span><span class="lineNoCov">          0 :   delete pcstreamFit;  </span>
<span class="lineNum">    2634 </span><span class="lineNoCov">          0 : }</span>
<a name="2635"><span class="lineNum">    2635 </span>            : </a>
<span class="lineNum">    2636 </span>            : 
<span class="lineNum">    2637 </span>            : TTree* AliTPCcalibAlignInterpolation::LoadDistortionTrees(const char * maplist, Int_t cacheSize, Int_t markerStyle, Float_t markerSize){
<span class="lineNum">    2638 </span>            :   //
<span class="lineNum">    2639 </span>            :   // Load distortion trees specified in the maplist 
<span class="lineNum">    2640 </span>            :   // Loading distortion maps as a friend trees used for
<span class="lineNum">    2641 </span>            :   //    - correction for reference distortions (e.g map at low IR)
<span class="lineNum">    2642 </span>            :   //    - distortion maps correlation studies
<span class="lineNum">    2643 </span>            :   //    - distortion maps scaling fitting
<span class="lineNum">    2644 </span>            :   // 
<span class="lineNum">    2645 </span>            :   // To obtain run number and TimeBin ID we assume naming convention as used in the calibration procedure. 
<span class="lineNum">    2646 </span>            :   // This naming convention is hardwired in the code. 
<span class="lineNum">    2647 </span>            :   //
<span class="lineNum">    2648 </span>            :   TTree * treeReturn=0;
<span class="lineNum">    2649 </span>            :   TTree * tree=0;
<span class="lineNum">    2650 </span><span class="lineNoCov">          0 :   TObjArray* array = TString(gSystem-&gt;GetFromPipe(TString::Format(&quot;cat %s&quot;,maplist).Data())).Tokenize(&quot;\n&quot;);  </span>
<span class="lineNum">    2651 </span><span class="lineNoCov">          0 :   TObjArray*arrayOK=new TObjArray(array-&gt;GetEntries());</span>
<span class="lineNum">    2652 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;array-&gt;GetEntries(); i++){</span>
<span class="lineNum">    2653 </span><span class="lineNoCov">          0 :     printf(&quot;%s\n&quot;,array-&gt;At(i)-&gt;GetName());</span>
<span class="lineNum">    2654 </span><span class="lineNoCov">          0 :     TString fname(array-&gt;At(i)-&gt;GetName());</span>
<span class="lineNum">    2655 </span><span class="lineNoCov">          0 :     Int_t index=fname.Index(&quot;/000&quot;);</span>
<span class="lineNum">    2656 </span><span class="lineNoCov">          0 :     TString runName(&amp;(fname[index+1]),9);</span>
<span class="lineNum">    2657 </span><span class="lineNoCov">          0 :     index=fname.Index(&quot;/Time&quot;);</span>
<span class="lineNum">    2658 </span><span class="lineNoCov">          0 :     TString timeString(&amp;(fname[index+9]),4);    </span>
<span class="lineNum">    2659 </span><span class="lineNoCov">          0 :     if (TString(array-&gt;At(i)-&gt;GetName()).Contains(&quot;_0.root&quot;)){</span>
<span class="lineNum">    2660 </span><span class="lineNoCov">          0 :       tree = AliTPCcalibAlignInterpolation::AddFriendDistortionTree(treeReturn,array-&gt;At(i)-&gt;GetName(),&quot;deltaRPhiTPCITSDist&quot;,runName+&quot;_&quot;+timeString+&quot;ITSY&quot;);</span>
<span class="lineNum">    2661 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2662 </span><span class="lineNoCov">          0 :     if (TString(array-&gt;At(i)-&gt;GetName()).Contains(&quot;_1.root&quot;)){</span>
<span class="lineNum">    2663 </span><span class="lineNoCov">          0 :       tree = AliTPCcalibAlignInterpolation::AddFriendDistortionTree(treeReturn,array-&gt;At(i)-&gt;GetName(),&quot;deltaRPhiTPCITSTRDDist&quot;,runName+&quot;_&quot;+timeString+&quot;TRDY&quot;);</span>
<span class="lineNum">    2664 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2665 </span><span class="lineNoCov">          0 :     if (TString(array-&gt;At(i)-&gt;GetName()).Contains(&quot;_2.root&quot;)){</span>
<span class="lineNum">    2666 </span><span class="lineNoCov">          0 :       tree = AliTPCcalibAlignInterpolation::AddFriendDistortionTree(treeReturn,array-&gt;At(i)-&gt;GetName(),&quot;deltaRPhiTPCITSTOFDist&quot;,runName+&quot;_&quot;+timeString+&quot;TOFY&quot;);</span>
<span class="lineNum">    2667 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2668 </span><span class="lineNoCov">          0 :     if (TString(array-&gt;At(i)-&gt;GetName()).Contains(&quot;_3.root&quot;)){</span>
<span class="lineNum">    2669 </span><span class="lineNoCov">          0 :       tree = AliTPCcalibAlignInterpolation::AddFriendDistortionTree(treeReturn,array-&gt;At(i)-&gt;GetName(),&quot;deltaZTPCITSDist&quot;,runName+&quot;_&quot;+timeString+&quot;ITSZ&quot;);</span>
<span class="lineNum">    2670 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2671 </span><span class="lineNoCov">          0 :     if (TString(array-&gt;At(i)-&gt;GetName()).Contains(&quot;_4.root&quot;)){</span>
<span class="lineNum">    2672 </span><span class="lineNoCov">          0 :       tree = AliTPCcalibAlignInterpolation::AddFriendDistortionTree(treeReturn,array-&gt;At(i)-&gt;GetName(),&quot;deltaZTPCITSTRDDist&quot;,runName+&quot;_&quot;+timeString+&quot;TRDZ&quot;);</span>
<span class="lineNum">    2673 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2674 </span><span class="lineNoCov">          0 :     if (TString(array-&gt;At(i)-&gt;GetName()).Contains(&quot;_5.root&quot;)){</span>
<span class="lineNum">    2675 </span><span class="lineNoCov">          0 :       tree = AliTPCcalibAlignInterpolation::AddFriendDistortionTree(treeReturn,array-&gt;At(i)-&gt;GetName(),&quot;deltaZTPCITSTOFDist&quot;,runName+&quot;_&quot;+timeString+&quot;TOFZ&quot;);</span>
<span class="lineNum">    2676 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2677 </span><span class="lineNoCov">          0 :     if (tree) {</span>
<span class="lineNum">    2678 </span><span class="lineNoCov">          0 :       arrayOK-&gt;AddLast(array-&gt;At(i));</span>
<span class="lineNum">    2679 </span>            :       treeReturn=tree;
<span class="lineNum">    2680 </span><span class="lineNoCov">          0 :     }    </span>
<span class="lineNum">    2681 </span><span class="lineNoCov">          0 :   } </span>
<span class="lineNum">    2682 </span><span class="lineNoCov">          0 :   treeReturn-&gt;SetCacheSize(cacheSize);</span>
<span class="lineNum">    2683 </span><span class="lineNoCov">          0 :   treeReturn-&gt;SetMarkerStyle(markerStyle); </span>
<span class="lineNum">    2684 </span><span class="lineNoCov">          0 :   treeReturn-&gt;SetMarkerSize(markerSize);</span>
<span class="lineNum">    2685 </span><span class="lineNoCov">          0 :   return treeReturn;</span>
<span class="lineNum">    2686 </span><span class="lineNoCov">          0 : }</span>
<a name="2687"><span class="lineNum">    2687 </span>            : </a>
<span class="lineNum">    2688 </span>            : 
<span class="lineNum">    2689 </span>            : Bool_t  AliTPCcalibAlignInterpolation::LoadNDLocalFit(TTree * tree, const char *chTree){
<span class="lineNum">    2690 </span>            :   ///
<span class="lineNum">    2691 </span>            :   ///  Load ND local fits. We assume data are organized in particular directory structure, in directories together with input maps
<span class="lineNum">    2692 </span>            :   ///  
<span class="lineNum">    2693 </span>            :   ///   
<span class="lineNum">    2694 </span>            :   /// Input:    
<span class="lineNum">    2695 </span>            :   ///   \param TTree * tree        - input tree with distortion maps and &quot;friend trees&quot; per time bins
<span class="lineNum">    2696 </span>            :   ///   \param const char *chTree  - name of the &quot;distortion branch&quot;
<span class="lineNum">    2697 </span>            : 
<span class="lineNum">    2698 </span><span class="lineNoCov">          0 :   if ( tree-&gt;GetListOfFriends()-&gt;FindObject(chTree)==NULL){</span>
<span class="lineNum">    2699 </span><span class="lineNoCov">          0 :     ::Error(&quot;AliTPCcalibAlignInterpolation::LoadNDLocal&quot;,&quot;Tree %s does not exist&quot;,chTree);</span>
<span class="lineNum">    2700 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">    2701 </span>            :   }
<span class="lineNum">    2702 </span><span class="lineNoCov">          0 :   TString floc = tree-&gt;GetListOfFriends()-&gt;FindObject(chTree)-&gt;GetTitle();</span>
<span class="lineNum">    2703 </span><span class="lineNoCov">          0 :   TString fdir = gSystem-&gt;DirName(floc);</span>
<span class="lineNum">    2704 </span>            :   //
<span class="lineNum">    2705 </span><span class="lineNoCov">          0 :   TObjArray *ndFileList = ( gSystem-&gt;GetFromPipe(TString::Format(&quot;ls %s/delta*root&quot;,fdir.Data()).Data())).Tokenize(&quot;\n&quot;);</span>
<span class="lineNum">    2706 </span>            :   
<span class="lineNum">    2707 </span><span class="lineNoCov">          0 :   if (ndFileList-&gt;GetEntries()==0){</span>
<span class="lineNum">    2708 </span><span class="lineNoCov">          0 :     ::Error(&quot; AliTPCcalibAlignInterpolation::LoadNDLocal&quot;,&quot;File with NDLocal %s&quot;,chTree);</span>
<span class="lineNum">    2709 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">    2710 </span>            :   }
<span class="lineNum">    2711 </span><span class="lineNoCov">          0 :   for (Int_t ind=0; ind&lt;ndFileList-&gt;GetEntries(); ind++){</span>
<span class="lineNum">    2712 </span>            :     //
<span class="lineNum">    2713 </span><span class="lineNoCov">          0 :     TString  fname=ndFileList-&gt;At(ind)-&gt;GetName();</span>
<span class="lineNum">    2714 </span><span class="lineNoCov">          0 :     TFile * f = TFile::Open(fname.Data());</span>
<span class="lineNum">    2715 </span><span class="lineNoCov">          0 :     TList * arrKey = f-&gt;GetListOfKeys();</span>
<span class="lineNum">    2716 </span><span class="lineNoCov">          0 :     for (Int_t ikey=0; ikey&lt;arrKey-&gt;GetEntries(); ikey++){</span>
<span class="lineNum">    2717 </span><span class="lineNoCov">          0 :       TString keyName=arrKey-&gt;At(ikey)-&gt;GetName();</span>
<span class="lineNum">    2718 </span><span class="lineNoCov">          0 :       if (keyName.Contains(&quot;delta&quot;)==0) continue;</span>
<span class="lineNum">    2719 </span><span class="lineNoCov">          0 :       TObject * o = f-&gt;Get(keyName);</span>
<span class="lineNum">    2720 </span><span class="lineNoCov">          0 :       AliNDLocalRegression * reg  = dynamic_cast&lt;AliNDLocalRegression*&gt;(o);</span>
<span class="lineNum">    2721 </span><span class="lineNoCov">          0 :       if (reg==NULL){</span>
<span class="lineNum">    2722 </span><span class="lineNoCov">          0 :         delete o;</span>
<span class="lineNum">    2723 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    2724 </span>            :       }
<span class="lineNum">    2725 </span><span class="lineNoCov">          0 :       TString aliasName = TString::Format(&quot;%s.%s&quot;,chTree,reg-&gt;GetName());</span>
<span class="lineNum">    2726 </span><span class="lineNoCov">          0 :       aliasName.ReplaceAll(&quot;-&quot;,&quot;Min&quot;);</span>
<span class="lineNum">    2727 </span><span class="lineNoCov">          0 :       ::Info(&quot;AliTPCcalibAlignInterpolation::LoadNDLocal&quot;,&quot;Loaded ND local regression %s/%s as alias %s&quot;, fname.Data(), reg-&gt;GetName(),aliasName.Data());</span>
<span class="lineNum">    2728 </span><span class="lineNoCov">          0 :       reg-&gt;SetName(aliasName);</span>
<span class="lineNum">    2729 </span><span class="lineNoCov">          0 :       Int_t hashIndex=reg-&gt;GetVisualCorrectionIndex();</span>
<span class="lineNum">    2730 </span><span class="lineNoCov">          0 :       reg-&gt;AddVisualCorrection(reg, hashIndex);      </span>
<span class="lineNum">    2731 </span><span class="lineNoCov">          0 :       tree-&gt;SetAlias(aliasName, TString::Format(&quot;AliNDLocalRegression::GetCorrND(%d,RCenter,sectorCenter,kZCenter,qptCenter+0)&quot;,hashIndex).Data());</span>
<span class="lineNum">    2732 </span><span class="lineNoCov">          0 :       tree-&gt;SetAlias(aliasName+&quot;L&quot;, TString::Format(&quot;AliNDLocalRegression::GetCorrND(%d,RCenter,sectorCenter,kZCenter,qptCenter+0)-(AliNDLocalRegression::GetCorrND(%d,RCenter,sectorCenter,kZCenter,qptCenter-2)+AliNDLocalRegression::GetCorrND(%d,RCenter,sectorCenter,kZCenter,qptCenter+2))*0.5&quot;,hashIndex,hashIndex,hashIndex).Data());</span>
<span class="lineNum">    2733 </span><span class="lineNoCov">          0 :       tree-&gt;SetAlias(aliasName+&quot;M&quot;, TString::Format(&quot;(AliNDLocalRegression::GetCorrND(%d,RCenter,sectorCenter,kZCenter,qptCenter-2)+AliNDLocalRegression::GetCorrND(%d,RCenter,sectorCenter,kZCenter,qptCenter+2))*0.5&quot;,hashIndex, hashIndex).Data());</span>
<span class="lineNum">    2734 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2735 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2736 </span><span class="lineNoCov">          0 :   return kTRUE;</span>
<span class="lineNum">    2737 </span>            : 
<span class="lineNum">    2738 </span><span class="lineNoCov">          0 : }</span>
<a name="2739"><span class="lineNum">    2739 </span>            : </a>
<span class="lineNum">    2740 </span>            : 
<span class="lineNum">    2741 </span>            : void  AliTPCcalibAlignInterpolation::DrawMapEstimatorComparison(TTree * tree, const char* chtree,  Float_t radius, Float_t kZ, TCut &amp;  selection, const char *figType){
<span class="lineNum">    2742 </span>            :   // Predefined plot: 
<span class="lineNum">    2743 </span>            :   //    Draw distortion map comparison
<span class="lineNum">    2744 </span>            :   //    Compare median and LTM estimator of the mean value of distortion in the bin
<span class="lineNum">    2745 </span>            :   //
<span class="lineNum">    2746 </span>            :   
<span class="lineNum">    2747 </span>            :   // Example usage:
<span class="lineNum">    2748 </span>            :   /* 
<span class="lineNum">    2749 </span>            :      const char* chtree=&quot;000244918_his1TRDY&quot;;    // Low IR one polarity
<span class="lineNum">    2750 </span>            :      const char* chtree=&quot;000246391_his1TRDY&quot;;    // Low IR another polarity
<span class="lineNum">    2751 </span>            :      Float_t radius=100;
<span class="lineNum">    2752 </span>            :      Float_t kZ=0.1;
<span class="lineNum">    2753 </span>            :      figType=&quot;png&quot;; 
<span class="lineNum">    2754 </span>            :      AliTPCcalibAlignInterpolation::DrawMapEstimatorComparison(tree, chtree, radius,kZ,&quot;abs(qptCenter)&lt;0.1&quot;,figType);
<span class="lineNum">    2755 </span>            :   */
<span class="lineNum">    2756 </span><span class="lineNoCov">          0 :   if (!tree) {</span>
<span class="lineNum">    2757 </span><span class="lineNoCov">          0 :     ::Error(&quot;DrawEstimatorComparison&quot;,&quot;Tree not available&quot;);</span>
<span class="lineNum">    2758 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    2759 </span>            :   }
<span class="lineNum">    2760 </span><span class="lineNoCov">          0 :   if (chtree &amp;&amp; tree-&gt;GetListOfFriends()-&gt;FindObject(chtree)==NULL){</span>
<span class="lineNum">    2761 </span><span class="lineNoCov">          0 :     ::Error(&quot;DrawEstimatorComparison&quot;,&quot;Ttree %s not available&quot;,chtree);</span>
<span class="lineNum">    2762 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    2763 </span>            :   }
<span class="lineNum">    2764 </span><span class="lineNoCov">          0 :   gStyle-&gt;SetLabelSize(0.07,&quot;XYZ&quot;);</span>
<span class="lineNum">    2765 </span><span class="lineNoCov">          0 :   gStyle-&gt;SetTitleSize(0.06,&quot;XYZ&quot;);</span>
<span class="lineNum">    2766 </span><span class="lineNoCov">          0 :   gStyle-&gt;SetTitleOffset(1.0,&quot;X&quot;);</span>
<span class="lineNum">    2767 </span><span class="lineNoCov">          0 :   gStyle-&gt;SetTitleOffset(0.6,&quot;Y&quot;);</span>
<span class="lineNum">    2768 </span><span class="lineNoCov">          0 :   gStyle-&gt;SetTitleOffset(0.4,&quot;Z&quot;);</span>
<span class="lineNum">    2769 </span><span class="lineNoCov">          0 :   gStyle-&gt;SetOptTitle(1);</span>
<span class="lineNum">    2770 </span>            : 
<span class="lineNum">    2771 </span>            : 
<span class="lineNum">    2772 </span><span class="lineNoCov">          0 :   TCanvas * canvasC = new TCanvas(&quot;canvasC&quot;,&quot;canvasC&quot;,1400,1000);</span>
<span class="lineNum">    2773 </span>            :   TPad * pad=0;
<span class="lineNum">    2774 </span><span class="lineNoCov">          0 :   TPad *pads[4]={0};</span>
<span class="lineNum">    2775 </span><span class="lineNoCov">          0 :   for (Int_t ipad=0; ipad&lt;4; ipad++){</span>
<span class="lineNum">    2776 </span><span class="lineNoCov">          0 :     pads[ipad] = new TPad(&quot;pad1&quot;,&quot;This is pad1&quot;,0.00,ipad/4.,  1,(ipad+1.)/4.);</span>
<span class="lineNum">    2777 </span><span class="lineNoCov">          0 :     pads[ipad]-&gt;SetBottomMargin(0);</span>
<span class="lineNum">    2778 </span><span class="lineNoCov">          0 :     pads[ipad]-&gt;SetTopMargin(0);</span>
<span class="lineNum">    2779 </span>            :   }
<span class="lineNum">    2780 </span><span class="lineNoCov">          0 :   pads[0]-&gt;SetBottomMargin(0.15);</span>
<span class="lineNum">    2781 </span><span class="lineNoCov">          0 :   pads[3]-&gt;SetTopMargin(0.05);</span>
<span class="lineNum">    2782 </span><span class="lineNoCov">          0 :   for (Int_t ipad=0; ipad&lt;4; ipad++){</span>
<span class="lineNum">    2783 </span><span class="lineNoCov">          0 :     pads[ipad]-&gt;Draw();</span>
<span class="lineNum">    2784 </span><span class="lineNoCov">          0 :     pads[ipad]-&gt;SetGrid(1,1);</span>
<span class="lineNum">    2785 </span>            :   }
<span class="lineNum">    2786 </span>            : 
<span class="lineNum">    2787 </span><span class="lineNoCov">          0 :   if (chtree){</span>
<span class="lineNum">    2788 </span><span class="lineNoCov">          0 :     pads[3]-&gt;cd();</span>
<span class="lineNum">    2789 </span><span class="lineNoCov">          0 :     tree-&gt;Draw(TString::Format(&quot;%s.binMedian:sectorCenter:RCenter&quot;,chtree).Data(),selection+TString::Format(&quot;abs(kZCenter+(%2.2f))&lt;0.06&amp;&amp;abs(RCenter-%2.2f)&lt;20&amp;&amp;%s.rms&gt;0&quot;,kZ,radius,chtree).Data(),&quot;colz&quot;);</span>
<span class="lineNum">    2790 </span><span class="lineNoCov">          0 :     pads[2]-&gt;cd();</span>
<span class="lineNum">    2791 </span><span class="lineNoCov">          0 :     tree-&gt;Draw(TString::Format(&quot;%s.vecLTM.fElements[1]:sectorCenter:RCenter&quot;,chtree).Data(),selection+TString::Format(&quot;abs(kZCenter+(%2.2f))&lt;0.06&amp;&amp;abs(RCenter-%2.2f)&lt;20&amp;&amp;%s.rms&gt;0&quot;,kZ,radius,chtree).Data(),&quot;colz&quot;);</span>
<span class="lineNum">    2792 </span><span class="lineNoCov">          0 :     pads[1]-&gt;cd();</span>
<span class="lineNum">    2793 </span><span class="lineNoCov">          0 :     tree-&gt;Draw(TString::Format(&quot;%s.meanG:sectorCenter:RCenter&quot;,chtree).Data(),selection+TString::Format(&quot;abs(kZCenter+(%2.2f))&lt;0.06&amp;&amp;abs(RCenter-%2.2f)&lt;20&amp;&amp;%s.rms&gt;0&amp;&amp;abs(%s.meanG-%s.binMedian)&lt;1&quot;,kZ,radius,chtree,chtree,chtree).Data(),&quot;colz&quot;);</span>
<span class="lineNum">    2794 </span><span class="lineNoCov">          0 :     pads[0]-&gt;cd();</span>
<span class="lineNum">    2795 </span><span class="lineNoCov">          0 :     tree-&gt;Draw(TString::Format(&quot;%s.vecLTM.fElements[1]-%s.binMedian:sectorCenter:RCenter&quot;,chtree,chtree).Data(),selection+TString::Format(&quot;abs(kZCenter+(%2.2f))&lt;0.06&amp;&amp;abs(RCenter-%2.2f)&lt;20&amp;&amp;%s.rms&gt;0&quot;,kZ,radius,chtree).Data(),&quot;colz&quot;);</span>
<span class="lineNum">    2796 </span><span class="lineNoCov">          0 :   }else{</span>
<span class="lineNum">    2797 </span>            :     pads[3]-&gt;cd();
<span class="lineNum">    2798 </span><span class="lineNoCov">          0 :     tree-&gt;Draw(&quot;binMedian:sectorCenter:RCenter&quot;,selection+TString::Format(&quot;abs(kZCenter+(%2.2f))&lt;0.06&amp;&amp;abs(RCenter-%2.2f)&lt;20&amp;&amp;rms&gt;0&quot;,kZ,radius).Data(),&quot;colz&quot;);</span>
<span class="lineNum">    2799 </span><span class="lineNoCov">          0 :     pads[2]-&gt;cd();</span>
<span class="lineNum">    2800 </span><span class="lineNoCov">          0 :     tree-&gt;Draw(&quot;vecLTM.fElements[1]:sectorCenter:RCenter&quot;,selection+TString::Format(&quot;abs(kZCenter+(%2.2f))&lt;0.06&amp;&amp;abs(RCenter-%2.2f)&lt;20&amp;&amp;rms&gt;0&quot;,kZ,radius).Data(),&quot;colz&quot;);</span>
<span class="lineNum">    2801 </span><span class="lineNoCov">          0 :     pads[1]-&gt;cd();</span>
<span class="lineNum">    2802 </span><span class="lineNoCov">          0 :     tree-&gt;Draw(&quot;meanG:sectorCenter:RCenter&quot;,selection+TString::Format(&quot;abs(kZCenter+(%2.2f))&lt;0.06&amp;&amp;abs(RCenter-%2.2f)&lt;20&amp;&amp;rms&gt;0&amp;&amp;abs(meanG-binMedian)&lt;1&quot;,kZ,radius).Data(),&quot;colz&quot;);</span>
<span class="lineNum">    2803 </span><span class="lineNoCov">          0 :     pads[0]-&gt;cd();</span>
<span class="lineNum">    2804 </span><span class="lineNoCov">          0 :     tree-&gt;Draw(&quot;binMedian-vecLTM.fElements[1]:sectorCenter:RCenter&quot;,selection+TString::Format(&quot;abs(kZCenter+(%2.2f))&lt;0.06&amp;&amp;abs(RCenter-%2.2f)&lt;20&amp;&amp;rms&gt;0&quot;,kZ,radius).Data(),&quot;colz&quot;);</span>
<span class="lineNum">    2805 </span>            :   }
<span class="lineNum">    2806 </span>            :   
<span class="lineNum">    2807 </span><span class="lineNoCov">          0 :   if (figType) canvasC-&gt;SaveAs(TString::Format(&quot;distortionMap_%s_R%2.0f_kZ%2.2f.%s&quot;,chtree,radius,kZ,figType).Data());</span>
<span class="lineNum">    2808 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2809 </span>            : 
<a name="2810"><span class="lineNum">    2810 </span>            : </a>
<span class="lineNum">    2811 </span>            : 
<span class="lineNum">    2812 </span>            : Bool_t  AliTPCcalibAlignInterpolation::DrawScalingComparison(TTree * tree, const char* chRef, const char *chBin0, const char *chBin1,  Float_t R0, Float_t R1, Float_t kZ, const char *figType){
<span class="lineNum">    2813 </span>            :   ///
<span class="lineNum">    2814 </span>            :   /// Make predefined plot: 
<span class="lineNum">    2815 </span>            :   ///    Draw distortion maps comparison and save figure (figType) in current working directory.
<span class="lineNum">    2816 </span>            :   ///       Fig 1.): Map run/timeBin chBin0 corrected for reference map (chRef)offset 
<span class="lineNum">    2817 </span>            :   ///       Fig 2.): Map run/timeBin chBin1 corrected for reference map (chRef)offset  
<span class="lineNum">    2818 </span>            :   ///       Fig 3.): Map (chBin1-chRef)-scale*(chBin0-chRef)
<span class="lineNum">    2819 </span>            :   /// 
<span class="lineNum">    2820 </span>            :   /// Input:    
<span class="lineNum">    2821 </span>            :   ///   \param TTree * tree - input tree with distortion maps and &quot;friend trees&quot; per time bins
<span class="lineNum">    2822 </span>            :   ///   \param chRef        - reference distortion map
<span class="lineNum">    2823 </span>            :   ///   \param chBin0       - run or time bin shown in firs row
<span class="lineNum">    2824 </span>            :   ///   \param chBin1       - run or time bin 
<span class="lineNum">    2825 </span>            :   /// \return kTRUE if comparison of distortion map possible and figure saved
<span class="lineNum">    2826 </span>            :   ///    TString::Format(&quot;distortionMapScaling_%s_%s_%s_R0%2.0f_R1%2.0f_kZ%2.2f.%s&quot;,chBin0,chBin1,chRef,R0,R1,kZ,figType).Data();
<span class="lineNum">    2827 </span>            :   /// Example usage:
<span class="lineNum">    2828 </span>            :   /// To be used for systematic studies of TPC distortion. 
<span class="lineNum">    2829 </span>            :   /// E.g:   
<span class="lineNum">    2830 </span>            :   /*
<span class="lineNum">    2831 </span>            :     TTree * tree = AliTPCcalibAlignInterpolation::LoadDistortionTrees(&quot;map.list&quot;);
<span class="lineNum">    2832 </span>            :     const char* chRef=&quot;000246391_his1TRDY&quot;;       // Low IR refernce run for given B-field polarity
<span class="lineNum">    2833 </span>            :     const char* chBin0=&quot;000246980_his1TRDY&quot;;      // time bin at the beginnig of the fill
<span class="lineNum">    2834 </span>            :     const char* chBin1=&quot;000246994_his1TRDY&quot;;      // time bin at the end of the fill
<span class="lineNum">    2835 </span>            :     AliTPCcalibAlignInterpolation::DrawScalingComparison(tree, chRef, chBin0, chBin1, 85, 130, 0.1, &quot;png&quot;);
<span class="lineNum">    2836 </span>            :   */
<span class="lineNum">    2837 </span>            :   //
<span class="lineNum">    2838 </span>            :   // 0.) Check variables
<span class="lineNum">    2839 </span>            :   //
<span class="lineNum">    2840 </span><span class="lineNoCov">          0 :   TCut defaultCut=&quot;abs(qptCenter)&lt;0.1&quot;;</span>
<span class="lineNum">    2841 </span><span class="lineNoCov">          0 :   if (tree==NULL) {</span>
<span class="lineNum">    2842 </span><span class="lineNoCov">          0 :     ::Error(&quot;AliTPCcalibAlignInterpolation::DrawScalingComparison&quot;,&quot;Tree not set&quot;);</span>
<span class="lineNum">    2843 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">    2844 </span>            :   }
<span class="lineNum">    2845 </span><span class="lineNoCov">          0 :   Int_t tentries[3]={0};</span>
<span class="lineNum">    2846 </span><span class="lineNoCov">          0 :   const char *vars[3]={chRef, chBin0, chBin1};</span>
<span class="lineNum">    2847 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;3;i++){</span>
<span class="lineNum">    2848 </span><span class="lineNoCov">          0 :     tentries[i]=tree-&gt;Draw(TString::Format(&quot;%s.binMedian&quot;,vars[i]),defaultCut,&quot;goff&quot;, 10000);</span>
<span class="lineNum">    2849 </span><span class="lineNoCov">          0 :     if (tentries[i]&lt;=0){</span>
<span class="lineNum">    2850 </span><span class="lineNoCov">          0 :       ::Error(&quot;AliTPCcalibAlignInterpolation::DrawScalingComparison&quot;,&quot;Expression %s  or tree %s not valid &quot;, vars[i], tree-&gt;GetName());</span>
<span class="lineNum">    2851 </span><span class="lineNoCov">          0 :       return kFALSE;</span>
<span class="lineNum">    2852 </span>            :     }
<span class="lineNum">    2853 </span>            :   }
<span class="lineNum">    2854 </span>            :   //
<span class="lineNum">    2855 </span>            :   // 1.) get scaling factor using A side scaling (OROC scaling on C side more problematic)
<span class="lineNum">    2856 </span>            :   //
<span class="lineNum">    2857 </span><span class="lineNoCov">          0 :   Int_t entries = tree-&gt;Draw(TString::Format(&quot;%s.binMedian-%s.binMedian:%s.binMedian-%s.binMedian&quot;, chBin0,chRef, chBin1,chRef).Data(),defaultCut+&quot;kZCenter&gt;0&quot;,&quot;goff&quot;);</span>
<span class="lineNum">    2858 </span><span class="lineNoCov">          0 :   TGraph * gr0 = new TGraph(entries,tree-&gt;GetV1(),tree-&gt;GetV2());</span>
<span class="lineNum">    2859 </span><span class="lineNoCov">          0 :   TGraph * gr1 = new TGraph(entries,tree-&gt;GetV2(),tree-&gt;GetV1());</span>
<span class="lineNum">    2860 </span><span class="lineNoCov">          0 :   gr0-&gt;Fit(&quot;pol1&quot;);</span>
<span class="lineNum">    2861 </span><span class="lineNoCov">          0 :   gr1-&gt;Fit(&quot;pol1&quot;);</span>
<span class="lineNum">    2862 </span><span class="lineNoCov">          0 :   Double_t slope=(gr0-&gt;GetFunction(&quot;pol1&quot;)-&gt;GetParameter(1)+ 1/gr1-&gt;GetFunction(&quot;pol1&quot;)-&gt;GetParameter(1))*0.5;  </span>
<span class="lineNum">    2863 </span><span class="lineNoCov">          0 :   tree-&gt;SetAlias(&quot;norm0&quot;,TString::Format(&quot;%f*(%s.binMedian-%s.binMedian)&quot;,slope,chBin0,chRef).Data());</span>
<span class="lineNum">    2864 </span>            :   //
<span class="lineNum">    2865 </span>            :   // 2. Make plots 
<span class="lineNum">    2866 </span>            :   //
<span class="lineNum">    2867 </span><span class="lineNoCov">          0 :   gStyle-&gt;SetLabelSize(0.07,&quot;XYZ&quot;);</span>
<span class="lineNum">    2868 </span><span class="lineNoCov">          0 :   gStyle-&gt;SetLabelSize(0.03,&quot;Y&quot;);</span>
<span class="lineNum">    2869 </span><span class="lineNoCov">          0 :   gStyle-&gt;SetTitleSize(0.06,&quot;XYZ&quot;);</span>
<span class="lineNum">    2870 </span><span class="lineNoCov">          0 :   gStyle-&gt;SetTitleSize(0.04,&quot;Y&quot;);</span>
<span class="lineNum">    2871 </span><span class="lineNoCov">          0 :   gStyle-&gt;SetTitleOffset(1.0,&quot;X&quot;);</span>
<span class="lineNum">    2872 </span><span class="lineNoCov">          0 :   gStyle-&gt;SetTitleOffset(0.5,&quot;Y&quot;);</span>
<span class="lineNum">    2873 </span><span class="lineNoCov">          0 :   gStyle-&gt;SetTitleOffset(0.4,&quot;Z&quot;);</span>
<span class="lineNum">    2874 </span><span class="lineNoCov">          0 :   gStyle-&gt;SetOptTitle(1);</span>
<span class="lineNum">    2875 </span>            :   //
<span class="lineNum">    2876 </span><span class="lineNoCov">          0 :   TCanvas * canvasC = new TCanvas(&quot;canvasC&quot;,&quot;canvasC&quot;,1400,1000);</span>
<span class="lineNum">    2877 </span>            :   TPad * pad=0;
<span class="lineNum">    2878 </span><span class="lineNoCov">          0 :   TPad *pad3 = new TPad(&quot;pad1&quot;,&quot;This is pad1&quot;,0.00,0.0,  1,0.33);</span>
<span class="lineNum">    2879 </span><span class="lineNoCov">          0 :   TPad *pad2 = new TPad(&quot;pad2&quot;,&quot;This is pad2&quot;,0.00,0.33, 1,0.66);</span>
<span class="lineNum">    2880 </span><span class="lineNoCov">          0 :   TPad *pad1 = new TPad(&quot;pad3&quot;,&quot;This is pad3&quot;,0.00,0.66, 1,1);</span>
<span class="lineNum">    2881 </span><span class="lineNoCov">          0 :   pad1-&gt;SetBottomMargin(0);</span>
<span class="lineNum">    2882 </span><span class="lineNoCov">          0 :   pad2-&gt;SetBottomMargin(0);</span>
<span class="lineNum">    2883 </span><span class="lineNoCov">          0 :   pad3-&gt;SetBottomMargin(0.15);</span>
<span class="lineNum">    2884 </span><span class="lineNoCov">          0 :   pad2-&gt;SetTopMargin(0);</span>
<span class="lineNum">    2885 </span><span class="lineNoCov">          0 :   pad3-&gt;SetTopMargin(0);</span>
<span class="lineNum">    2886 </span><span class="lineNoCov">          0 :   pad1-&gt;Draw();</span>
<span class="lineNum">    2887 </span><span class="lineNoCov">          0 :   pad2-&gt;Draw();</span>
<span class="lineNum">    2888 </span><span class="lineNoCov">          0 :   pad3-&gt;Draw();</span>
<span class="lineNum">    2889 </span><span class="lineNoCov">          0 :   pad1-&gt;SetGrid(1,1);</span>
<span class="lineNum">    2890 </span><span class="lineNoCov">          0 :   pad2-&gt;SetGrid(1,1);</span>
<span class="lineNum">    2891 </span><span class="lineNoCov">          0 :   pad3-&gt;SetGrid(1,1);</span>
<span class="lineNum">    2892 </span><span class="lineNoCov">          0 :   TCut cutAccept=defaultCut+TString::Format(&quot;abs(kZCenter+(%2.2f))&lt;0.06&amp;&amp;RCenter&gt;%2.0f&amp;&amp;RCenter&lt;%2.0f&amp;&amp;%s.rms&gt;0&quot;,kZ,R0,R1,chRef).Data();</span>
<span class="lineNum">    2893 </span>            :   Int_t isOK=0;
<span class="lineNum">    2894 </span>            :   const Int_t kMinEntries=100;
<span class="lineNum">    2895 </span>            :   {
<span class="lineNum">    2896 </span><span class="lineNoCov">          0 :     pad1-&gt;cd();</span>
<span class="lineNum">    2897 </span><span class="lineNoCov">          0 :     isOK+=tree-&gt;Draw(TString::Format(&quot;(%s.binMedian-%s.binMedian):sectorCenter:RCenter&quot;, chBin0,chRef),cutAccept,&quot;colz&quot;)&gt;kMinEntries;</span>
<span class="lineNum">    2898 </span><span class="lineNoCov">          0 :     pad2-&gt;cd();</span>
<span class="lineNum">    2899 </span><span class="lineNoCov">          0 :     isOK+=tree-&gt;Draw(TString::Format(&quot;(%s.binMedian-%s.binMedian):sectorCenter:RCenter&quot;, chBin1,chRef),cutAccept,&quot;colz&quot;)&gt;kMinEntries;</span>
<span class="lineNum">    2900 </span><span class="lineNoCov">          0 :     pad3-&gt;cd();</span>
<span class="lineNum">    2901 </span><span class="lineNoCov">          0 :     isOK+=tree-&gt;Draw(TString::Format(&quot;(%s.binMedian-%s.binMedian)-norm0:sectorCenter:RCenter&quot;, chBin1,chRef),cutAccept,&quot;colz&quot;)&gt;kMinEntries;</span>
<span class="lineNum">    2902 </span>            :   }
<span class="lineNum">    2903 </span><span class="lineNoCov">          0 :   if (isOK&lt;3){</span>
<span class="lineNum">    2904 </span><span class="lineNoCov">          0 :     ::Error(&quot;AliTPCcalibAlignInterpolation::DrawScalingComparison&quot;,&quot;Not enough points in selected region R&lt;%2.0f,%2.0f&gt;&quot;, R0,R1);</span>
<span class="lineNum">    2905 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">    2906 </span>            :   }
<span class="lineNum">    2907 </span><span class="lineNoCov">          0 :   if (figType) canvasC-&gt;SaveAs(TString::Format(&quot;distortionMapScaling_%s_%s_%s_R0%2.0f_R1%2.0f_kZ%2.2f.%s&quot;,chBin0,chBin1,chRef,R0,R1,kZ,figType).Data());</span>
<span class="lineNum">    2908 </span><span class="lineNoCov">          0 :   return kTRUE;</span>
<span class="lineNum">    2909 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2910 </span>            : 
<span class="lineNum">    2911 </span>            : 
<a name="2912"><span class="lineNum">    2912 </span>            : </a>
<span class="lineNum">    2913 </span>            : //_______________________________________________
<span class="lineNum">    2914 </span>            : double AliTPCcalibAlignInterpolation::GetTgPhi(double x, double y2x, double q2p, double b)
<span class="lineNum">    2915 </span>            : {
<span class="lineNum">    2916 </span>            :   // calculate tangent of primary track at any frame at given x,y
<span class="lineNum">    2917 </span><span class="lineNoCov">          0 :   double y = y2x*x;</span>
<span class="lineNum">    2918 </span><span class="lineNoCov">          0 :   double c = q2p*b*(-0.299792458e-3);</span>
<span class="lineNum">    2919 </span><span class="lineNoCov">          0 :   if (TMath::Abs(c)&lt;1e-9) return y2x;</span>
<span class="lineNum">    2920 </span><span class="lineNoCov">          0 :   double r2 = y*y+x*x;</span>
<span class="lineNum">    2921 </span><span class="lineNoCov">          0 :   double det = 4./r2 - c*c;</span>
<span class="lineNum">    2922 </span>            :   double snp;
<span class="lineNum">    2923 </span><span class="lineNoCov">          0 :   if (det&lt;0) {</span>
<span class="lineNum">    2924 </span><span class="lineNoCov">          0 :     snp = TMath::Sign(-0.8,c);</span>
<span class="lineNum">    2925 </span>            :     //printf(&quot;track of q2p=%f cannot reach x:%f y:%f, define snp as %f \n&quot;,q2p,x,y,snp);
<span class="lineNum">    2926 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2927 </span>            :   else {
<span class="lineNum">    2928 </span><span class="lineNoCov">          0 :     snp = 0.5*(y*TMath::Sqrt(det)-c*x); // snp at vertex</span>
<span class="lineNum">    2929 </span><span class="lineNoCov">          0 :     snp += x*c;  // snp at x,y</span>
<span class="lineNum">    2930 </span>            :   }
<span class="lineNum">    2931 </span><span class="lineNoCov">          0 :   return snp/TMath::Sqrt((1-snp)*(1+snp));</span>
<span class="lineNum">    2932 </span><span class="lineNoCov">          0 : }</span>
<a name="2933"><span class="lineNum">    2933 </span>            : </a>
<span class="lineNum">    2934 </span>            : //______________________________________________
<span class="lineNum">    2935 </span>            : void AliTPCcalibAlignInterpolation::FixAlignmentBug(int sect, float q2pt, float bz,
<span class="lineNum">    2936 </span>            :                                                     float&amp; alp, float&amp; x, float &amp;z, float &amp;deltaY, float &amp;deltaZ)
<span class="lineNum">    2937 </span>            : {
<span class="lineNum">    2938 </span>            :   // fix alignment bug: https://alice.its.cern.ch/jira/browse/ATO-339?focusedCommentId=170850&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-170850
<span class="lineNum">    2939 </span>            :   //
<span class="lineNum">    2940 </span>            :   // NOTE: deltaZ in the buggy code is calculated as Ztrack_with_bug - Zcluster_w/o_bug
<span class="lineNum">    2941 </span>            :   static TGeoHMatrix *mCache[72] = {0};
<span class="lineNum">    2942 </span><span class="lineNoCov">          0 :   if (sect&lt;0||sect&gt;=72) {</span>
<span class="lineNum">    2943 </span><span class="lineNoCov">          0 :     AliErrorClassF(&quot;Invalid sector %d&quot;,sect);</span>
<span class="lineNum">    2944 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    2945 </span>            :   }
<span class="lineNum">    2946 </span><span class="lineNoCov">          0 :   int lr = sect/36 ? (AliGeomManager::kTPC2) : (AliGeomManager::kTPC1);</span>
<span class="lineNum">    2947 </span><span class="lineNoCov">          0 :   TGeoHMatrix* mgt = mCache[sect];</span>
<span class="lineNum">    2948 </span><span class="lineNoCov">          0 :   if (!mgt) {</span>
<span class="lineNum">    2949 </span><span class="lineNoCov">          0 :     int volID = AliGeomManager::LayerToVolUIDSafe(lr,sect%36);</span>
<span class="lineNum">    2950 </span><span class="lineNoCov">          0 :     mgt = new TGeoHMatrix(*AliGeomManager::GetTracking2LocalMatrix(volID));</span>
<span class="lineNum">    2951 </span><span class="lineNoCov">          0 :     mgt-&gt;MultiplyLeft(AliGeomManager::GetMatrix(volID));</span>
<span class="lineNum">    2952 </span><span class="lineNoCov">          0 :     mCache[sect] = mgt;</span>
<span class="lineNum">    2953 </span><span class="lineNoCov">          0 :     printf(&quot;Caching matrix for sector %d\n&quot;,sect);</span>
<span class="lineNum">    2954 </span><span class="lineNoCov">          0 :   }  </span>
<span class="lineNum">    2955 </span><span class="lineNoCov">          0 :   double alpSect = ((sect%18)+0.5)*20.*TMath::DegToRad();</span>
<span class="lineNum">    2956 </span>            : 
<span class="lineNum">    2957 </span>            :   // cluster in its proper alpha frame with alignment bug
<span class="lineNum">    2958 </span><span class="lineNoCov">          0 :   double xyzClUse[3] = {x,0,z}; // this is what we read from the residual tree</span>
<span class="lineNum">    2959 </span><span class="lineNoCov">          0 :   double xyzTrUse[3] = {x, deltaY, z}; // track in bad cluster frame</span>
<span class="lineNum">    2960 </span>            :   //
<span class="lineNum">    2961 </span>            :   // recover cluster Z position by adding deltaZ
<span class="lineNum">    2962 </span><span class="lineNoCov">          0 :   double zClSave = xyzClUse[2] -= deltaZ;  // here the cluster is not affected by Z alignment component of the bug!</span>
<span class="lineNum">    2963 </span><span class="lineNoCov">          0 :   static AliExternalTrackParam trDummy;</span>
<span class="lineNum">    2964 </span><span class="lineNoCov">          0 :   trDummy.Local2GlobalPosition(xyzClUse,alp); // misaligned cluster in global frame</span>
<span class="lineNum">    2965 </span><span class="lineNoCov">          0 :   double xyz0[3]={xyzClUse[0],xyzClUse[1],xyzClUse[2]};</span>
<span class="lineNum">    2966 </span><span class="lineNoCov">          0 :   mgt-&gt;MasterToLocal(xyz0,xyzClUse);</span>
<span class="lineNum">    2967 </span>            :   // we got ideal cluster in the sector tracking frame,  but now the Z is wrong, since it was not affected by the bug!!!
<span class="lineNum">    2968 </span>            :   //
<span class="lineNum">    2969 </span><span class="lineNoCov">          0 :   xyzClUse[2] = zClSave;</span>
<span class="lineNum">    2970 </span>            : 
<span class="lineNum">    2971 </span>            :   // go to ideal cluster frame
<span class="lineNum">    2972 </span><span class="lineNoCov">          0 :   trDummy.Local2GlobalPosition(xyzClUse,alpSect); // ideal global</span>
<span class="lineNum">    2973 </span><span class="lineNoCov">          0 :   double alpFix = TMath::ATan2(xyzClUse[1],xyzClUse[0]);    // fixed cluster phi</span>
<span class="lineNum">    2974 </span><span class="lineNoCov">          0 :   trDummy.Global2LocalPosition(xyzClUse,alpFix);     // fixed cluster in in its frame</span>
<span class="lineNum">    2975 </span>            :   //
<span class="lineNum">    2976 </span><span class="lineNoCov">          0 :   trDummy.Local2GlobalPosition(xyzTrUse,alp); // track in global frame</span>
<span class="lineNum">    2977 </span><span class="lineNoCov">          0 :   trDummy.Global2LocalPosition(xyzTrUse,alpFix); // track in cluster frame</span>
<span class="lineNum">    2978 </span><span class="lineNoCov">          0 :   alp = alpFix;</span>
<span class="lineNum">    2979 </span>            :   //
<span class="lineNum">    2980 </span><span class="lineNoCov">          0 :   double dx = xyzTrUse[0] - xyzClUse[0]; // x might not be the same after alignment fix</span>
<span class="lineNum">    2981 </span>            :   // deduce track slopes assuming it comes from the vertex
<span class="lineNum">    2982 </span><span class="lineNoCov">          0 :   double tgphi = GetTgPhi(xyzClUse[0],xyzTrUse[1]/xyzClUse[0],q2pt,bz);</span>
<span class="lineNum">    2983 </span><span class="lineNoCov">          0 :   xyzTrUse[1] -= dx*tgphi;</span>
<span class="lineNum">    2984 </span><span class="lineNoCov">          0 :   xyzTrUse[2] -= dx*xyzClUse[2]/xyzClUse[0]; // z2x</span>
<span class="lineNum">    2985 </span>            :   //
<span class="lineNum">    2986 </span><span class="lineNoCov">          0 :   x = xyzClUse[0];</span>
<span class="lineNum">    2987 </span><span class="lineNoCov">          0 :   z = xyzTrUse[2]; // we still use track Z as a reference ...</span>
<span class="lineNum">    2988 </span><span class="lineNoCov">          0 :   deltaY = xyzTrUse[1]-xyzClUse[1];</span>
<span class="lineNum">    2989 </span><span class="lineNoCov">          0 :   deltaZ = xyzTrUse[2]-xyzClUse[2];</span>
<span class="lineNum">    2990 </span>            :   //
<span class="lineNum">    2991 </span><span class="lineNoCov">          0 : }</span>
<a name="2992"><span class="lineNum">    2992 </span>            : </a>
<span class="lineNum">    2993 </span>            : 
<span class="lineNum">    2994 </span>            : void  AliTPCcalibAlignInterpolation::MakeVDriftOCDB(const char *inputFile, Int_t run, TString  targetOCDBstorage, const char * testDiffCDB/*=0*/){
<span class="lineNum">    2995 </span>            :   ///
<span class="lineNum">    2996 </span>            :   /// Make OCDB entry using information using the vdrift calibration obtained in the  AliTPCcalibAlignInterpolation::FitDrift function (suing ResidualTrees.root)
<span class="lineNum">    2997 </span>            :   /// 
<span class="lineNum">    2998 </span>            :   ///
<span class="lineNum">    2999 </span>            :   /* 
<span class="lineNum">    3000 </span>            :      char * inputFile= &quot;fitDrift.root&quot;
<span class="lineNum">    3001 </span>            :      char * testDiffCDB=&quot;/cvmfs/alice.cern.ch/calibration/data/2015/OCDB/TPC/Calib/TimeDrift/Run244918_244918_v3_s0.root&quot;;
<span class="lineNum">    3002 </span>            :      Int_t  run=244918;
<span class="lineNum">    3003 </span>            : 
<span class="lineNum">    3004 </span>            :      .x  $ALICE_PHYSICS/PWGPP/CalibMacros/CPass0/ConfigCalibTrain.C(run,&quot;local:///cvmfs/alice.cern.ch/calibration/data/2015/OCDB/&quot;)
<span class="lineNum">    3005 </span>            :      AliTPCcalibAlignInterpolation::MakeVDriftOCDB( inputFile,run,&quot;&quot;, testDiffCDB)
<span class="lineNum">    3006 </span>            :   */
<span class="lineNum">    3007 </span>            : 
<span class="lineNum">    3008 </span>            :   /*
<span class="lineNum">    3009 </span>            :    The same calibration was done previoulsy using the AliTPCcalibTime class
<span class="lineNum">    3010 </span>            :    Many graphs in previously done RUN1 calibration used for monitoring purposes and do not have equivalent in the new calibration 
<span class="lineNum">    3011 </span>            :    using ResidualTrees  
<span class="lineNum">    3012 </span>            :    Old CPass0 calibration () - 114 graphs exported and monitored later using trending  (O (100 kBy) per run)
<span class="lineNum">    3013 </span>            :       * 108 graphs for Align+drift = 9 params x 3 detectors x 4 version ) 
<span class="lineNum">    3014 </span>            :       ** vdrift calibration (3 param)  and alingment graphs (6)
<span class="lineNum">    3015 </span>            :       ** each pair of detector ITS-&gt;TPC, TRD-&gt;TPC, TOF-&gt;TPC
<span class="lineNum">    3016 </span>            :       ** Kalman filter storted in 4 version
<span class="lineNum">    3017 </span>            :       *** raw input per time bin, kalman forward propagation, Kalaman back propagation, smoothed Kalman  
<span class="lineNum">    3018 </span>            :       ** usage 
<span class="lineNum">    3019 </span>            :       *** ITS-&gt;TPC smoothed version in case exist
<span class="lineNum">    3020 </span>            :       *** TOF-&gt;TPC smoothed in case ITS-&gt;TPC not availale
<span class="lineNum">    3021 </span>            :         
<span class="lineNum">    3022 </span>            :       * 6 graphs for the Laser CE backup graphs
<span class="lineNum">    3023 </span>            :       * backup of ClusterParam and RecoParam as it was used in the process of  calibration 
<span class="lineNum">    3024 </span>            :       ** calibration depends
<span class="lineNum">    3025 </span>            :   
<span class="lineNum">    3026 </span>            :    New calibration input data ( O(3 MBy) for 2 hours measurement):
<span class="lineNum">    3027 </span>            :    
<span class="lineNum">    3028 </span>            :    Export variables:
<span class="lineNum">    3029 </span>            :      only vdrift calibration graphs (_DELTAZ,DRIFTVD, TO and VDGY)  will  be exported
<span class="lineNum">    3030 </span>            :      smoothed version equivalent (grTRDReg) and raw calibration equivalent (grTRDmed)
<span class="lineNum">    3031 </span>            :      ITS  - mean (TRD+TOF)*0.5
<span class="lineNum">    3032 </span>            :      TRD  - TRD
<span class="lineNum">    3033 </span>            :      TOF  - TOF
<span class="lineNum">    3034 </span>            :   */  
<span class="lineNum">    3035 </span><span class="lineNoCov">          0 :   TObjArray * driftArray = new TObjArray();</span>
<span class="lineNum">    3036 </span>            : 
<span class="lineNum">    3037 </span>            :   //
<span class="lineNum">    3038 </span>            :   // 0. Initialize OCDB if not done before
<span class="lineNum">    3039 </span>            :   //
<span class="lineNum">    3040 </span>            :   AliTPCParam *param =0;
<span class="lineNum">    3041 </span><span class="lineNoCov">          0 :   if (AliCDBManager::Instance()-&gt;GetDefaultStorage()!=NULL){</span>
<span class="lineNum">    3042 </span>            :     //
<span class="lineNum">    3043 </span>            :     //
<span class="lineNum">    3044 </span><span class="lineNoCov">          0 :     AliTPCClusterParam *clParam =   AliTPCcalibDB::Instance()-&gt;GetClusterParam();</span>
<span class="lineNum">    3045 </span><span class="lineNoCov">          0 :     param= AliTPCcalibDB::Instance()-&gt;GetParameters();</span>
<span class="lineNum">    3046 </span><span class="lineNoCov">          0 :     TObjArray *recoParams = new TObjArray(4) ;</span>
<span class="lineNum">    3047 </span><span class="lineNoCov">          0 :     for (Int_t i=0;i&lt;4;i++) recoParams-&gt;AddAt(AliTPCcalibDB::Instance()-&gt;GetRecoParam(i),i);</span>
<span class="lineNum">    3048 </span><span class="lineNoCov">          0 :     driftArray-&gt;AddLast(clParam);</span>
<span class="lineNum">    3049 </span><span class="lineNoCov">          0 :     driftArray-&gt;AddLast(recoParams);    </span>
<span class="lineNum">    3050 </span><span class="lineNoCov">          0 :     ::Info(&quot;AliTPCcalibAlignInterpolation::MakeVDriftOCDB&quot;,&quot;Residual calibration used. We have to trust  - your OCDB is correct, as we can nt check.&quot;);</span>
<span class="lineNum">    3051 </span><span class="lineNoCov">          0 :   }else{</span>
<span class="lineNum">    3052 </span><span class="lineNoCov">          0 :     ::Fatal(&quot;AliTPCcalibAlignInterpolation::MakeVDriftOCDB&quot;,&quot;Im sorry. OCDB has to be intilaized before. We need to get Parameters objects, which were used in previous calibration. In ideal case the OCDB entry to be setup to the entries, indeed used to produce Residual trees ... But this we can not CHECK&quot;);</span>
<span class="lineNum">    3053 </span>            :   }
<span class="lineNum">    3054 </span>            : 
<span class="lineNum">    3055 </span>            :   //
<span class="lineNum">    3056 </span>            :   // 1. Read calibratio data from the tree
<span class="lineNum">    3057 </span>            :   //
<span class="lineNum">    3058 </span><span class="lineNoCov">          0 :   TVectorD     *vdriftParam=0;</span>
<span class="lineNum">    3059 </span><span class="lineNoCov">          0 :   TGraphErrors *grTRDReg=0;  </span>
<span class="lineNum">    3060 </span><span class="lineNoCov">          0 :   TGraphErrors *grTOFReg=0;  </span>
<span class="lineNum">    3061 </span><span class="lineNoCov">          0 :   TGraphErrors *grTRDMed=0;  </span>
<span class="lineNum">    3062 </span><span class="lineNoCov">          0 :   TGraphErrors *grTOFMed=0;  </span>
<span class="lineNum">    3063 </span><span class="lineNoCov">          0 :   TFile *fdrift = TFile::Open(inputFile);</span>
<span class="lineNum">    3064 </span><span class="lineNoCov">          0 :   if (fdrift){</span>
<span class="lineNum">    3065 </span><span class="lineNoCov">          0 :     TTree * tree = (TTree*)fdrift-&gt;Get(&quot;fitTimeStat&quot;);</span>
<span class="lineNum">    3066 </span><span class="lineNoCov">          0 :     if (tree==NULL){</span>
<span class="lineNum">    3067 </span><span class="lineNoCov">          0 :       ::Fatal(&quot;MakeVDriftOCDB.LoadDriftCalibration FAILED&quot;, &quot;tree fitTimeStat not avaliable in file fitDrift.root&quot;);</span>
<span class="lineNum">    3068 </span><span class="lineNoCov">          0 :     }else{</span>
<span class="lineNum">    3069 </span><span class="lineNoCov">          0 :       if (tree-&gt;GetBranch(&quot;grTRDReg.&quot;))  tree-&gt;SetBranchAddress(&quot;grTRDReg.&quot;,&amp;grTRDReg);</span>
<span class="lineNum">    3070 </span><span class="lineNoCov">          0 :       if (tree-&gt;GetBranch(&quot;grTOFReg.&quot;))  tree-&gt;SetBranchAddress(&quot;grTOFReg.&quot;,&amp;grTOFReg);</span>
<span class="lineNum">    3071 </span><span class="lineNoCov">          0 :       if (tree-&gt;GetBranch(&quot;grTRDMed.&quot;))  tree-&gt;SetBranchAddress(&quot;grTRDMed.&quot;,&amp;grTRDMed);</span>
<span class="lineNum">    3072 </span><span class="lineNoCov">          0 :       if (tree-&gt;GetBranch(&quot;grTOFMed.&quot;))  tree-&gt;SetBranchAddress(&quot;grTOFMed.&quot;,&amp;grTOFMed);</span>
<span class="lineNum">    3073 </span><span class="lineNoCov">          0 :       if (tree-&gt;GetBranch(&quot;paramRobust.&quot;)) tree-&gt;SetBranchAddress(&quot;paramRobust.&quot;,&amp;vdriftParam);</span>
<span class="lineNum">    3074 </span><span class="lineNoCov">          0 :       tree-&gt;GetEntry(0);</span>
<span class="lineNum">    3075 </span>            :     }    
<span class="lineNum">    3076 </span><span class="lineNoCov">          0 :   }else{</span>
<span class="lineNum">    3077 </span><span class="lineNoCov">          0 :     ::Fatal(&quot;MakeVDriftOCDB.LoadDriftCalibration FAILED&quot;, &quot;Input file %s not accesible&quot;, inputFile);</span>
<span class="lineNum">    3078 </span>            :   }  
<span class="lineNum">    3079 </span><span class="lineNoCov">          0 :   if (grTRDReg==NULL &amp;&amp; grTOFReg==NULL){</span>
<span class="lineNum">    3080 </span><span class="lineNoCov">          0 :     ::Fatal(&quot;MakeVDriftOCDB.LoadDriftCalibration FAILED&quot;, &quot;drift calibration enot present&quot;);</span>
<span class="lineNum">    3081 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3082 </span>            :   //
<span class="lineNum">    3083 </span>            :   // 2.)  Transform v drift calibration object into the format used in previous calibration
<span class="lineNum">    3084 </span>            :   //
<span class="lineNum">    3085 </span>            :   TGraphErrors   *graphDELTAZ=0;
<span class="lineNum">    3086 </span>            :   TGraphErrors   *graphT0=0;
<span class="lineNum">    3087 </span>            :   TGraphErrors   *graphVDGY=0;
<span class="lineNum">    3088 </span>            :   TGraphErrors   *graphDRIFTVD=0;
<span class="lineNum">    3089 </span>            :   TGraphErrors   *graph=0;
<span class="lineNum">    3090 </span>            : 
<span class="lineNum">    3091 </span><span class="lineNoCov">          0 :   const char *chDet[3]={&quot;ITS&quot;,&quot;TRD&quot;,&quot;TOF&quot;};</span>
<span class="lineNum">    3092 </span><span class="lineNoCov">          0 :   Double_t atime[2]={0,0};</span>
<span class="lineNum">    3093 </span><span class="lineNoCov">          0 :   Double_t deltaZ[2]={0,0};</span>
<span class="lineNum">    3094 </span><span class="lineNoCov">          0 :   Double_t t0[2]={0,0};</span>
<span class="lineNum">    3095 </span><span class="lineNoCov">          0 :   Double_t vdgy[2]={0,0};</span>
<span class="lineNum">    3096 </span><span class="lineNoCov">          0 :   graphDRIFTVD=(grTRDMed!=NULL) ? grTRDMed:grTOFMed;</span>
<span class="lineNum">    3097 </span>            :   //
<span class="lineNum">    3098 </span><span class="lineNoCov">          0 :   atime[0]=graphDRIFTVD-&gt;GetX()[0];</span>
<span class="lineNum">    3099 </span><span class="lineNoCov">          0 :   atime[1]=graphDRIFTVD-&gt;GetX()[graphDRIFTVD-&gt;GetN()-1];</span>
<span class="lineNum">    3100 </span><span class="lineNoCov">          0 :   for (Int_t ipoint=0; ipoint&lt;=1; ipoint++){</span>
<span class="lineNum">    3101 </span><span class="lineNoCov">          0 :     deltaZ[ipoint]=-(*vdriftParam)[1];  // unit OK</span>
<span class="lineNum">    3102 </span><span class="lineNoCov">          0 :     vdgy[ipoint]=-(*vdriftParam)[2];   // units OK</span>
<span class="lineNum">    3103 </span><span class="lineNoCov">          0 :     t0[ipoint]=-(*vdriftParam)[0]/(1+(*vdriftParam)[3]);       // t0 to be normalized to the ms</span>
<span class="lineNum">    3104 </span><span class="lineNoCov">          0 :     t0[ipoint]/=(param-&gt;GetDriftV()/1000000.); </span>
<span class="lineNum">    3105 </span>            :   }
<span class="lineNum">    3106 </span>            :   
<span class="lineNum">    3107 </span>            : 
<span class="lineNum">    3108 </span><span class="lineNoCov">          0 :   Double_t vdrifCorrRun=1./(1.+(*vdriftParam)[3]);</span>
<span class="lineNum">    3109 </span>            : 
<span class="lineNum">    3110 </span>            :   //
<span class="lineNum">    3111 </span><span class="lineNoCov">          0 :   for (Int_t idet=0; idet&lt;3; idet++){</span>
<span class="lineNum">    3112 </span><span class="lineNoCov">          0 :     for (Int_t itype=0; itype&lt;2; itype++){  //0. original version 1.)smoothed version</span>
<span class="lineNum">    3113 </span><span class="lineNoCov">          0 :       TString grPrefix=&quot;ALIGN_&quot;;</span>
<span class="lineNum">    3114 </span><span class="lineNoCov">          0 :       grPrefix+=chDet[idet];</span>
<span class="lineNum">    3115 </span><span class="lineNoCov">          0 :       if (itype==0) grPrefix+=&quot;_TPC_&quot;;</span>
<span class="lineNum">    3116 </span><span class="lineNoCov">          0 :       if (itype==1) grPrefix+=&quot;B_TPC_&quot;;</span>
<span class="lineNum">    3117 </span>            :       //
<span class="lineNum">    3118 </span><span class="lineNoCov">          0 :       graphDELTAZ=new TGraphErrors(2, atime, deltaZ);</span>
<span class="lineNum">    3119 </span><span class="lineNoCov">          0 :       graphDELTAZ-&gt;SetName(grPrefix+&quot;DELTAZ&quot;);</span>
<span class="lineNum">    3120 </span><span class="lineNoCov">          0 :       driftArray-&gt;AddLast(graphDELTAZ);</span>
<span class="lineNum">    3121 </span><span class="lineNoCov">          0 :       graphT0=new TGraphErrors(2, atime, t0);</span>
<span class="lineNum">    3122 </span><span class="lineNoCov">          0 :       graphT0-&gt;SetName(grPrefix+&quot;T0&quot;);</span>
<span class="lineNum">    3123 </span><span class="lineNoCov">          0 :       driftArray-&gt;AddLast(graphT0);</span>
<span class="lineNum">    3124 </span><span class="lineNoCov">          0 :       graphVDGY=new TGraphErrors(2, atime, vdgy);</span>
<span class="lineNum">    3125 </span><span class="lineNoCov">          0 :       graphVDGY-&gt;SetName(grPrefix+&quot;VDGY&quot;);</span>
<span class="lineNum">    3126 </span><span class="lineNoCov">          0 :       driftArray-&gt;AddLast(graphVDGY);</span>
<span class="lineNum">    3127 </span>            :       //
<span class="lineNum">    3128 </span>            :       // drift velocity
<span class="lineNum">    3129 </span>            :       //graph=(grTRDMed!=NULL) ? new TGraphErrors(*grTRDMed): new TGraphErrors(*grTOFMed); // normal constructor give us seg fault
<span class="lineNum">    3130 </span><span class="lineNoCov">          0 :       graph=(TGraphErrors*)((grTRDMed!=NULL) ? grTRDMed-&gt;Clone(): grTOFMed-&gt;Clone()); // normal constructor give us 0</span>
<span class="lineNum">    3131 </span><span class="lineNoCov">          0 :       Int_t npoints = graph-&gt;GetN();</span>
<span class="lineNum">    3132 </span><span class="lineNoCov">          0 :       for (Int_t ipoint=0; ipoint&lt;npoints; ipoint++){</span>
<span class="lineNum">    3133 </span><span class="lineNoCov">          0 :         graph-&gt;GetY()[ipoint]=-1;</span>
<span class="lineNum">    3134 </span><span class="lineNoCov">          0 :         if (idet==1 &amp;&amp; grTRDMed) { // TRD</span>
<span class="lineNum">    3135 </span><span class="lineNoCov">          0 :           if (itype==0) graph-&gt;GetY()[ipoint]=(vdrifCorrRun*(1-grTRDMed-&gt;GetY()[ipoint]))-1.;</span>
<span class="lineNum">    3136 </span><span class="lineNoCov">          0 :           if (itype==1) graph-&gt;GetY()[ipoint]=(vdrifCorrRun*(1-grTRDReg-&gt;GetY()[ipoint]))-1.;</span>
<span class="lineNum">    3137 </span>            :         }
<span class="lineNum">    3138 </span><span class="lineNoCov">          0 :         if (idet==2 &amp;&amp; grTOFMed) { // TOF</span>
<span class="lineNum">    3139 </span><span class="lineNoCov">          0 :           if (itype==0) graph-&gt;GetY()[ipoint]=(vdrifCorrRun*(1-grTOFMed-&gt;GetY()[ipoint]))-1.;</span>
<span class="lineNum">    3140 </span><span class="lineNoCov">          0 :           if (itype==1) graph-&gt;GetY()[ipoint]=(vdrifCorrRun*(1-grTOFReg-&gt;GetY()[ipoint]))-1.;</span>
<span class="lineNum">    3141 </span>            :         }
<span class="lineNum">    3142 </span><span class="lineNoCov">          0 :         if (idet==0 &amp;&amp;  (grTRDMed&amp;&amp;grTOFMed)) { // (TRD+TOF)*0.5</span>
<span class="lineNum">    3143 </span><span class="lineNoCov">          0 :           if (itype==0) graph-&gt;GetY()[ipoint]=(vdrifCorrRun*(1-(grTRDMed-&gt;GetY()[ipoint]+grTOFMed-&gt;GetY()[ipoint])*0.5))-1.;</span>
<span class="lineNum">    3144 </span><span class="lineNoCov">          0 :           if (itype==1) graph-&gt;GetY()[ipoint]=(vdrifCorrRun*(1-(grTRDReg-&gt;GetY()[ipoint]+grTOFReg-&gt;GetY()[ipoint])*0.5))-1.;</span>
<span class="lineNum">    3145 </span>            :         }
<span class="lineNum">    3146 </span>            :       }
<span class="lineNum">    3147 </span><span class="lineNoCov">          0 :       graph-&gt;SetName(grPrefix+&quot;DRIFTVD&quot;);</span>
<span class="lineNum">    3148 </span><span class="lineNoCov">          0 :       driftArray-&gt;AddLast(graph);</span>
<span class="lineNum">    3149 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    3150 </span>            :   }
<span class="lineNum">    3151 </span>            :   //
<span class="lineNum">    3152 </span>            :   // 3. Store selected graphs in OCDB
<span class="lineNum">    3153 </span>            :   //
<span class="lineNum">    3154 </span>            :   AliCDBStorage* targetStorage = 0x0;
<span class="lineNum">    3155 </span><span class="lineNoCov">          0 :   if (targetOCDBstorage.Length()==0) {</span>
<span class="lineNum">    3156 </span><span class="lineNoCov">          0 :     targetOCDBstorage+=&quot;local://&quot;+gSystem-&gt;GetFromPipe(&quot;pwd&quot;)+&quot;/OCDB&quot;;</span>
<span class="lineNum">    3157 </span><span class="lineNoCov">          0 :     targetStorage = AliCDBManager::Instance()-&gt;GetStorage(targetOCDBstorage.Data());</span>
<span class="lineNum">    3158 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3159 </span><span class="lineNoCov">          0 :   else if (targetOCDBstorage.CompareTo(&quot;same&quot;,TString::kIgnoreCase) == 0 ){</span>
<span class="lineNum">    3160 </span><span class="lineNoCov">          0 :     targetStorage = AliCDBManager::Instance()-&gt;GetDefaultStorage();</span>
<span class="lineNum">    3161 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3162 </span>            :   else {
<span class="lineNum">    3163 </span><span class="lineNoCov">          0 :     targetStorage = AliCDBManager::Instance()-&gt;GetStorage(targetOCDBstorage.Data());</span>
<span class="lineNum">    3164 </span>            :   }
<span class="lineNum">    3165 </span>            : 
<span class="lineNum">    3166 </span><span class="lineNoCov">          0 :   AliCDBMetaData* metaData = new AliCDBMetaData;</span>
<span class="lineNum">    3167 </span><span class="lineNoCov">          0 :   metaData-&gt;SetObjectClassName(&quot;TObjArray&quot;);</span>
<span class="lineNum">    3168 </span><span class="lineNoCov">          0 :   metaData-&gt;SetResponsible(&quot;Marian Ivanov&quot;);</span>
<span class="lineNum">    3169 </span><span class="lineNoCov">          0 :   metaData-&gt;SetBeamPeriod(1);</span>
<span class="lineNum">    3170 </span><span class="lineNoCov">          0 :   metaData-&gt;SetAliRootVersion(&quot;&gt;v5-07-20&quot;); //AliRoot version</span>
<span class="lineNum">    3171 </span><span class="lineNoCov">          0 :   metaData-&gt;SetComment(&quot;AliTPCcalibAlignInterpolation Calibration of the time dependence of the drift velocity using Residual trees&quot;);</span>
<span class="lineNum">    3172 </span><span class="lineNoCov">          0 :   AliCDBId id1(&quot;TPC/Calib/TimeDrift&quot;, run, run);</span>
<span class="lineNum">    3173 </span>            :   
<span class="lineNum">    3174 </span>            :   //now the entry owns the metadata, but NOT the data
<span class="lineNum">    3175 </span><span class="lineNoCov">          0 :   AliCDBEntry *driftCDBentry=new AliCDBEntry(driftArray,id1,metaData,kFALSE);</span>
<span class="lineNum">    3176 </span><span class="lineNoCov">          0 :   targetStorage-&gt;Put(driftCDBentry); </span>
<span class="lineNum">    3177 </span>            :   //
<span class="lineNum">    3178 </span>            :   //
<span class="lineNum">    3179 </span>            :   // 4. Make diff to reference CDB  if sepecfied
<span class="lineNum">    3180 </span>            :   // 
<span class="lineNum">    3181 </span><span class="lineNoCov">          0 :   if (testDiffCDB){    </span>
<span class="lineNum">    3182 </span><span class="lineNoCov">          0 :     TFile *f = TFile::Open(testDiffCDB);</span>
<span class="lineNum">    3183 </span><span class="lineNoCov">          0 :     AliCDBEntry * entry=(AliCDBEntry*)f-&gt;Get(&quot;AliCDBEntry&quot;);</span>
<span class="lineNum">    3184 </span><span class="lineNoCov">          0 :     TObjArray * array = (TObjArray*)entry-&gt;GetObject();</span>
<span class="lineNum">    3185 </span>            :     //array-&gt;ls();
<span class="lineNum">    3186 </span><span class="lineNoCov">          0 :     TGraphErrors * grRef= (TGraphErrors * )array-&gt;FindObject(&quot;ALIGN_TRDB_TPC_DRIFTVD&quot;);</span>
<span class="lineNum">    3187 </span><span class="lineNoCov">          0 :     TGraphErrors * gr= (TGraphErrors * )driftArray-&gt;FindObject(&quot;ALIGN_TRDB_TPC_DRIFTVD&quot;);</span>
<span class="lineNum">    3188 </span><span class="lineNoCov">          0 :     grRef-&gt;SetMarkerStyle(25);</span>
<span class="lineNum">    3189 </span><span class="lineNoCov">          0 :     gr-&gt;SetMarkerStyle(21);</span>
<span class="lineNum">    3190 </span><span class="lineNoCov">          0 :     Double_t minimum=TMath::Min(grRef-&gt;GetMinimum(), gr-&gt;GetMinimum());</span>
<span class="lineNum">    3191 </span><span class="lineNoCov">          0 :     Double_t maximum=TMath::Max(grRef-&gt;GetMaximum(), gr-&gt;GetMaximum());</span>
<span class="lineNum">    3192 </span><span class="lineNoCov">          0 :     grRef-&gt;SetMinimum(minimum);</span>
<span class="lineNum">    3193 </span><span class="lineNoCov">          0 :     grRef-&gt;SetMaximum(maximum);</span>
<span class="lineNum">    3194 </span>            : 
<span class="lineNum">    3195 </span><span class="lineNoCov">          0 :     grRef-&gt;Draw(&quot;ap&quot;);</span>
<span class="lineNum">    3196 </span><span class="lineNoCov">          0 :     gr-&gt;Draw(&quot;p&quot;);</span>
<span class="lineNum">    3197 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3198 </span>            : 
<span class="lineNum">    3199 </span><span class="lineNoCov">          0 :   delete driftCDBentry;</span>
<span class="lineNum">    3200 </span>            : 
<span class="lineNum">    3201 </span>            : 
<span class="lineNum">    3202 </span><span class="lineNoCov">          0 : }</span>
<a name="3203"><span class="lineNum">    3203 </span>            : </a>
<span class="lineNum">    3204 </span>            : 
<span class="lineNum">    3205 </span>            : Float_t  AliTPCcalibAlignInterpolation::CalculateDistance(const TVectorF &amp;track0, const TVectorF &amp;track1, const TVectorF &amp;vecSec, TVectorF &amp;vecDelta, Int_t npValid, Float_t &amp;rmsTrack,  Float_t &amp;rmsCluster, Float_t lpNorm){
<span class="lineNum">    3206 </span>            :   ///  Calculate track and cluster RMS distance. RMS distance is than used in toder to
<span class="lineNum">    3207 </span>            :   ///    1.) Calcute rms distance between the track0 and reference track1    
<span class="lineNum">    3208 </span>            :   ///    2.) Calculate rms distance between the cluster and local median cluster position in region +-2 padrows (wihing one sector)
<span class="lineNum">    3209 </span>            :   ///        and store delta in exported vecDelta array
<span class="lineNum">    3210 </span>            :   /// \param[in] track0             vector: cluster-track residuals for track of interest
<span class="lineNum">    3211 </span>            :   /// \param[in] track1             vector: cluster-track residuals for reference track
<span class="lineNum">    3212 </span>            :   /// \param[in] vecSec             vector: cluster sector index
<span class="lineNum">    3213 </span>            :   /// \param[in] lpNorm             the p value for the p-type norm (https://en.wikipedia.org/wiki/Norm_(mathematics))
<span class="lineNum">    3214 </span>            :   /// \param[out] rmsTrack          calculated 2 track distance (lpNorm)
<span class="lineNum">    3215 </span>            :   /// \param[out] rmsCluster        calculated cluster local mean distance (lpNorm)
<span class="lineNum">    3216 </span>            :   ///
<span class="lineNum">    3217 </span>            :   ///  Return value - number of the clusters with too big RMS
<span class="lineNum">    3218 </span>            :   /// 
<span class="lineNum">    3219 </span>            :   // In the following routine AliTPCcalibAlignInterpolation::FillHistogramsFromChain cut applied on quality of track and custer infromation
<span class="lineNum">    3220 </span>            :   // Suggested cuts (based on the resolution parametrrization studies)
<span class="lineNum">    3221 </span>            :   //    - nOut &lt;10 - less than 15 clusters rejected   - kMaxSkippedCluster=10;
<span class="lineNum">    3222 </span>            :   //    - rmsTrack&lt;2 cm    kMaxRMSTrackCut=2.0;
<span class="lineNum">    3223 </span>            :   //    - rmsCluster&lt;0.3 cm kMaxRMSClusterCut=0.3;  
<span class="lineNum">    3224 </span>            :   //    - |vecDelta|&lt;0.5 cm  kMaxDeltaClusterCut=0.5; 
<span class="lineNum">    3225 </span>            :   //
<span class="lineNum">    3226 </span>            :   // Parameters of algorithm for the moment set as a constant 
<span class="lineNum">    3227 </span>            :   const Int_t   kMinFractionPoints=0.5;
<span class="lineNum">    3228 </span>            :   const Float_t kMaxDist=20;
<span class="lineNum">    3229 </span>            :   const Float_t kMaxDistTrack=5;
<span class="lineNum">    3230 </span><span class="lineNoCov">          0 :   Float_t maxRMSTrack=rmsTrack;</span>
<span class="lineNum">    3231 </span><span class="lineNoCov">          0 :   Float_t maxRMSCluster=rmsCluster;</span>
<span class="lineNum">    3232 </span>            : 
<span class="lineNum">    3233 </span>            :   //
<span class="lineNum">    3234 </span>            :   Float_t distance2=0;
<span class="lineNum">    3235 </span>            :   Int_t npoints=0;
<span class="lineNum">    3236 </span>            :    // cache matrix pointers
<span class="lineNum">    3237 </span><span class="lineNoCov">          0 :   const Float_t *delta0=track0.GetMatrixArray();</span>
<span class="lineNum">    3238 </span><span class="lineNoCov">          0 :   const Float_t *delta1=track1.GetMatrixArray();</span>
<span class="lineNum">    3239 </span><span class="lineNoCov">          0 :   const Float_t *sec=vecSec.GetMatrixArray();</span>
<span class="lineNum">    3240 </span>            :   //
<span class="lineNum">    3241 </span>            :   // 1.) Calcute rms distance between the track0 and reference track1    
<span class="lineNum">    3242 </span>            :   //
<span class="lineNum">    3243 </span><span class="lineNoCov">          0 :   for (Int_t irow=0; irow&lt;npValid; irow++){</span>
<span class="lineNum">    3244 </span><span class="lineNoCov">          0 :     vecDelta[irow]=1000;</span>
<span class="lineNum">    3245 </span><span class="lineNoCov">          0 :     if (TMath::Abs(delta0[irow])==0) continue;  // </span>
<span class="lineNum">    3246 </span><span class="lineNoCov">          0 :     if (TMath::Abs(delta1[irow])==0) continue;  // </span>
<span class="lineNum">    3247 </span><span class="lineNoCov">          0 :     if (TMath::Abs(delta0[irow])&gt;kMaxDist) continue;  // </span>
<span class="lineNum">    3248 </span><span class="lineNoCov">          0 :     if (TMath::Abs(delta1[irow])&gt;kMaxDist) continue;  //</span>
<span class="lineNum">    3249 </span><span class="lineNoCov">          0 :     if (TMath::Abs(delta0[irow]-delta1[irow])&gt;kMaxDistTrack) continue;  //</span>
<span class="lineNum">    3250 </span><span class="lineNoCov">          0 :     npoints++;</span>
<span class="lineNum">    3251 </span><span class="lineNoCov">          0 :     distance2+=(delta0[irow]-delta1[irow])*(delta0[irow]-delta1[irow]);</span>
<span class="lineNum">    3252 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3253 </span><span class="lineNoCov">          0 :   if (npoints&lt;=80) return -1;</span>
<span class="lineNum">    3254 </span><span class="lineNoCov">          0 :   if (npoints&lt;npValid*kMinFractionPoints) return -1; // not enough points</span>
<span class="lineNum">    3255 </span><span class="lineNoCov">          0 :   rmsTrack = TMath::Sqrt(distance2/npoints);</span>
<span class="lineNum">    3256 </span><span class="lineNoCov">          0 :   if (rmsTrack&gt;maxRMSTrack) {</span>
<span class="lineNum">    3257 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">    3258 </span>            :   }
<span class="lineNum">    3259 </span>            :   //
<span class="lineNum">    3260 </span>            :   //    2.) Calculate rms distance between the cluster and local median cluster posotion in region +-2 padrows (wihing one sector)
<span class="lineNum">    3261 </span>            :   //         and store delta in exported vecDelta array
<span class="lineNum">    3262 </span>            :   Int_t nOutCounter=0;  // counter of clusters 
<span class="lineNum">    3263 </span><span class="lineNoCov">          0 :   rmsCluster=0;</span>
<span class="lineNum">    3264 </span>            :   Float_t rmsSum=0;
<span class="lineNum">    3265 </span><span class="lineNoCov">          0 :   Float_t deltaArray[10]={0};</span>
<span class="lineNum">    3266 </span><span class="lineNoCov">          0 :   for (Int_t irow=0; irow&lt;npValid; irow++){</span>
<span class="lineNum">    3267 </span>            :     Int_t idelta=1;
<span class="lineNum">    3268 </span><span class="lineNoCov">          0 :     vecDelta[irow]=1000;</span>
<span class="lineNum">    3269 </span><span class="lineNoCov">          0 :     if (TMath::Abs(delta0[irow])&gt;kMaxDist) continue;</span>
<span class="lineNum">    3270 </span><span class="lineNoCov">          0 :     deltaArray[0]=delta0[irow];</span>
<span class="lineNum">    3271 </span>            :     Int_t nforMedian=1;
<span class="lineNum">    3272 </span><span class="lineNoCov">          0 :     Int_t sector36=Int_t(sec[irow])%36;</span>
<span class="lineNum">    3273 </span><span class="lineNoCov">          0 :     for (idelta=1; idelta&lt;3; idelta++) {</span>
<span class="lineNum">    3274 </span><span class="lineNoCov">          0 :       if ((irow-idelta)&lt;0) break;</span>
<span class="lineNum">    3275 </span><span class="lineNoCov">          0 :       if ((irow+idelta)&gt;=npValid) break;</span>
<span class="lineNum">    3276 </span><span class="lineNoCov">          0 :       if (TMath::Abs(sec[irow-idelta])&gt;72) break;</span>
<span class="lineNum">    3277 </span><span class="lineNoCov">          0 :       if (TMath::Abs(sec[irow+idelta])&gt;72) break;</span>
<span class="lineNum">    3278 </span><span class="lineNoCov">          0 :       if (Int_t(sec[irow-idelta])%36!=sector36) break;  // sometimes looks like sector not initialized</span>
<span class="lineNum">    3279 </span><span class="lineNoCov">          0 :       if (Int_t(sec[irow+idelta])%36!=sector36) break;</span>
<span class="lineNum">    3280 </span><span class="lineNoCov">          0 :       if (TMath::Abs(delta0[irow-idelta])&lt;kMaxDist) deltaArray[nforMedian++]=delta0[irow-idelta];</span>
<span class="lineNum">    3281 </span><span class="lineNoCov">          0 :       if (TMath::Abs(delta0[irow+idelta])&lt;kMaxDist) deltaArray[nforMedian++]=delta0[irow+idelta];</span>
<span class="lineNum">    3282 </span>            :     }
<span class="lineNum">    3283 </span><span class="lineNoCov">          0 :     if (irow==0) vecDelta[irow]=delta0[0]-delta0[1];</span>
<span class="lineNum">    3284 </span><span class="lineNoCov">          0 :     if (irow==npValid-1) vecDelta[irow]=delta0[irow]-delta0[irow-1];</span>
<span class="lineNum">    3285 </span><span class="lineNoCov">          0 :     if (nforMedian&gt;1){</span>
<span class="lineNum">    3286 </span><span class="lineNoCov">          0 :       vecDelta[irow]=delta0[irow]-TMath::Mean(nforMedian, deltaArray);</span>
<span class="lineNum">    3287 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    3288 </span><span class="lineNoCov">          0 :     if (vecDelta[irow]&gt;maxRMSCluster){</span>
<span class="lineNum">    3289 </span><span class="lineNoCov">          0 :       nOutCounter++;</span>
<span class="lineNum">    3290 </span><span class="lineNoCov">          0 :     }else{</span>
<span class="lineNum">    3291 </span><span class="lineNoCov">          0 :       rmsCluster+=TMath::Power(TMath::Abs(vecDelta[irow]),lpNorm);</span>
<span class="lineNum">    3292 </span><span class="lineNoCov">          0 :       rmsSum++;</span>
<span class="lineNum">    3293 </span>            :     }
<span class="lineNum">    3294 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3295 </span><span class="lineNoCov">          0 :   if (rmsSum&lt;=0) return 0;</span>
<span class="lineNum">    3296 </span><span class="lineNoCov">          0 :   rmsCluster=TMath::Power(rmsCluster/rmsSum,1./lpNorm);</span>
<span class="lineNum">    3297 </span><span class="lineNoCov">          0 :   return nOutCounter;</span>
<span class="lineNum">    3298 </span><span class="lineNoCov">          0 : }</span>
<a name="3299"><span class="lineNum">    3299 </span>            : </a>
<span class="lineNum">    3300 </span>            : 
<span class="lineNum">    3301 </span>            : Float_t AliTPCcalibAlignInterpolation::InitForAlignmentBugFix(int run, const char* ocdb)
<span class="lineNum">    3302 </span>            : {
<span class="lineNum">    3303 </span><span class="lineNoCov">          0 :   ::Info(&quot; AliTPCcalibAlignInterpolation::InitForAlignmentBugFix&quot;,&quot;Alignment bug fix is requested\n&quot;);</span>
<span class="lineNum">    3304 </span>            :   //
<span class="lineNum">    3305 </span>            :   // this requires the field and the geometry ...
<span class="lineNum">    3306 </span><span class="lineNoCov">          0 :   if (run&lt;1) ::Fatal(&quot;tstw&quot;,&quot;InitForBugFix: Run number is not provided&quot;);</span>
<span class="lineNum">    3307 </span><span class="lineNoCov">          0 :   Bool_t geomOK = AliGeomManager::GetGeometry() != 0;</span>
<span class="lineNum">    3308 </span><span class="lineNoCov">          0 :   AliMagF* fld = (AliMagF*)TGeoGlobalMagField::Instance()-&gt;GetField();</span>
<span class="lineNum">    3309 </span><span class="lineNoCov">          0 :   if (!geomOK || !fld) { // need to setup ocdb?</span>
<span class="lineNum">    3310 </span><span class="lineNoCov">          0 :     AliCDBManager* man = AliCDBManager::Instance();</span>
<span class="lineNum">    3311 </span><span class="lineNoCov">          0 :     if (!man-&gt;IsDefaultStorageSet()) man-&gt;SetDefaultStorage(ocdb);</span>
<span class="lineNum">    3312 </span><span class="lineNoCov">          0 :     if (man-&gt;GetRun()!=run) man-&gt;SetRun(run);</span>
<span class="lineNum">    3313 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3314 </span><span class="lineNoCov">          0 :   if (!geomOK) {</span>
<span class="lineNum">    3315 </span><span class="lineNoCov">          0 :     AliGeomManager::LoadGeometry();</span>
<span class="lineNum">    3316 </span><span class="lineNoCov">          0 :     AliGeomManager::ApplyAlignObjsFromCDB(&quot;TPC&quot;);</span>
<span class="lineNum">    3317 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3318 </span><span class="lineNoCov">          0 :   if (!fld) {</span>
<span class="lineNum">    3319 </span><span class="lineNoCov">          0 :     AliGRPManager grpMan;</span>
<span class="lineNum">    3320 </span><span class="lineNoCov">          0 :     grpMan.ReadGRPEntry();</span>
<span class="lineNum">    3321 </span><span class="lineNoCov">          0 :     grpMan.SetMagField();</span>
<span class="lineNum">    3322 </span><span class="lineNoCov">          0 :     fld = (AliMagF*)TGeoGlobalMagField::Instance()-&gt;GetField();</span>
<span class="lineNum">    3323 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3324 </span><span class="lineNoCov">          0 :   return fld-&gt;SolenoidField();</span>
<span class="lineNum">    3325 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
