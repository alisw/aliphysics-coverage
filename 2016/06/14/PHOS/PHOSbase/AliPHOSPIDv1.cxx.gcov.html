<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - PHOS/PHOSbase/AliPHOSPIDv1.cxx</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">PHOS/PHOSbase</a> - AliPHOSPIDv1.cxx<span style="font-size: 80%;"> (source / <a href="AliPHOSPIDv1.cxx.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">455</td>
            <td class="headerCovTableEntry">717</td>
            <td class="headerCovTableEntryLo">63.5 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">23</td>
            <td class="headerCovTableEntry">44</td>
            <td class="headerCovTableEntryLo">52.3 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**************************************************************************</a>
<span class="lineNum">       2 </span>            :  * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
<span class="lineNum">       3 </span>            :  *                                                                        *
<span class="lineNum">       4 </span>            :  * Author: The ALICE Off-line Project.                                    *
<span class="lineNum">       5 </span>            :  * Contributors are mentioned in the code where appropriate.              *
<span class="lineNum">       6 </span>            :  *                                                                        *
<span class="lineNum">       7 </span>            :  * Permission to use, copy, modify and distribute this software and its   *
<span class="lineNum">       8 </span>            :  * documentation strictly for non-commercial purposes is hereby granted   *
<span class="lineNum">       9 </span>            :  * without fee, provided that the above copyright notice appears in all   *
<span class="lineNum">      10 </span>            :  * copies and that both the copyright notice and this permission notice   *
<span class="lineNum">      11 </span>            :  * appear in the supporting documentation. The authors make no claims     *
<span class="lineNum">      12 </span>            :  * about the suitability of this software for any purpose. It is          *
<span class="lineNum">      13 </span>            :  * provided &quot;as is&quot; without express or implied warranty.                  *
<span class="lineNum">      14 </span>            :  **************************************************************************/
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : /* $Id$ */
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : /* History of cvs commits:
<span class="lineNum">      19 </span>            :  *
<span class="lineNum">      20 </span>            :  * $Log$
<span class="lineNum">      21 </span>            :  * Revision 1.113  2007/08/07 14:12:03  kharlov
<span class="lineNum">      22 </span>            :  * Quality assurance added (Yves Schutz)
<span class="lineNum">      23 </span>            :  *
<span class="lineNum">      24 </span>            :  * Revision 1.112  2007/07/11 13:43:30  hristov
<span class="lineNum">      25 </span>            :  * New class AliESDEvent, backward compatibility with the old AliESD (Christian)
<span class="lineNum">      26 </span>            :  *
<span class="lineNum">      27 </span>            :  * Revision 1.111  2007/05/04 14:49:29  policheh
<span class="lineNum">      28 </span>            :  * AliPHOSRecPoint inheritance from AliCluster
<span class="lineNum">      29 </span>            :  *
<span class="lineNum">      30 </span>            :  * Revision 1.110  2007/04/24 10:08:03  kharlov
<span class="lineNum">      31 </span>            :  * Vertex extraction from GenHeader
<span class="lineNum">      32 </span>            :  *
<span class="lineNum">      33 </span>            :  * Revision 1.109  2007/04/18 09:34:05  kharlov
<span class="lineNum">      34 </span>            :  * Geometry bug fixes
<span class="lineNum">      35 </span>            :  *
<span class="lineNum">      36 </span>            :  * Revision 1.108  2007/04/16 09:03:37  kharlov
<span class="lineNum">      37 </span>            :  * Incedent angle correction fixed
<span class="lineNum">      38 </span>            :  *
<span class="lineNum">      39 </span>            :  * Revision 1.107  2007/04/02 15:00:16  cvetan
<span class="lineNum">      40 </span>            :  * No more calls to gAlice in the reconstruction
<span class="lineNum">      41 </span>            :  *
<span class="lineNum">      42 </span>            :  * Revision 1.106  2007/04/01 15:40:15  kharlov
<span class="lineNum">      43 </span>            :  * Correction for actual vertex position implemented
<span class="lineNum">      44 </span>            :  *
<span class="lineNum">      45 </span>            :  * Revision 1.105  2007/03/06 06:57:46  kharlov
<span class="lineNum">      46 </span>            :  * DP:calculation of distance to CPV done in TSM
<span class="lineNum">      47 </span>            :  *
<span class="lineNum">      48 </span>            :  * Revision 1.104  2006/12/15 10:46:26  hristov
<span class="lineNum">      49 </span>            :  * Using TMath::Abs instead of fabs
<span class="lineNum">      50 </span>            :  *
<span class="lineNum">      51 </span>            :  * Revision 1.103  2006/09/07 18:31:08  kharlov
<span class="lineNum">      52 </span>            :  * Effective c++ corrections (T.Pocheptsov)
<span class="lineNum">      53 </span>            :  *
<span class="lineNum">      54 </span>            :  * Revision 1.102  2006/01/23 17:51:48  hristov
<span class="lineNum">      55 </span>            :  * Using the recommended way of forward declarations for TVector and TMatrix (see v5-08-00 release notes). Additional clean-up
<span class="lineNum">      56 </span>            :  *
<span class="lineNum">      57 </span>            :  * Revision 1.101  2005/05/28 14:19:04  schutz
<span class="lineNum">      58 </span>            :  * Compilation warnings fixed by T.P.
<span class="lineNum">      59 </span>            :  *
<span class="lineNum">      60 </span>            :  */
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            : //_________________________________________________________________________
<span class="lineNum">      63 </span>            : // Implementation version v1 of the PHOS particle identifier 
<span class="lineNum">      64 </span>            : // Particle identification based on the 
<span class="lineNum">      65 </span>            : //     - RCPV: distance from CPV recpoint to EMCA recpoint.
<span class="lineNum">      66 </span>            : //     - TOF 
<span class="lineNum">      67 </span>            : //     - PCA: Principal Components Analysis..
<span class="lineNum">      68 </span>            : // The identified particle has an identification number corresponding 
<span class="lineNum">      69 </span>            : // to a 9 bits number:
<span class="lineNum">      70 </span>            : //     -Bit 0 to 2: bit set if RCPV &gt; CpvEmcDistance (each bit corresponds
<span class="lineNum">      71 </span>            : //      to a different efficiency-purity point of the photon identification) 
<span class="lineNum">      72 </span>            : //     -Bit 3 to 5: bit set if TOF  &lt; TimeGate (each bit corresponds
<span class="lineNum">      73 </span>            : //      to a different efficiency-purity point of the photon identification) 
<span class="lineNum">      74 </span>            : //     -Bit 6 to 9: bit set if Principal Components are 
<span class="lineNum">      75 </span>            : //      inside an ellipse defined by the parameters a, b, c, x0 and y0.
<span class="lineNum">      76 </span>            : //      (each bit corresponds to a different efficiency-purity point of the 
<span class="lineNum">      77 </span>            : //      photon identification)
<span class="lineNum">      78 </span>            : //      The PCA (Principal components analysis) needs a file that contains
<span class="lineNum">      79 </span>            : //      a previous analysis of the correlations between the particles. This 
<span class="lineNum">      80 </span>            : //      file is $ALICE_ROOT/PHOS/PCA8pa15_0.5-100.root. Analysis done for 
<span class="lineNum">      81 </span>            : //      energies between 0.5 and 100 GeV.
<span class="lineNum">      82 </span>            : //      A calibrated energy is calculated. The energy of the reconstructed
<span class="lineNum">      83 </span>            : //      cluster is corrected with the formula A + B * E  + C * E^2, whose 
<span class="lineNum">      84 </span>            : //      parameters where obtained through the study of the reconstructed 
<span class="lineNum">      85 </span>            : //      energy distribution of monoenergetic photons. 
<span class="lineNum">      86 </span>            : //
<span class="lineNum">      87 </span>            : //      All the parameters (RCPV(2 rows-3 columns),TOF(1r-3c),PCA(5r-4c) 
<span class="lineNum">      88 </span>            : //      and calibration(1r-3c))are stored in a file called 
<span class="lineNum">      89 </span>            : //      $ALICE_ROOT/PHOS/Parameters.dat. Each time that AliPHOSPIDv1 is 
<span class="lineNum">      90 </span>            : //      initialized, this parameters are copied to a Matrix (9,4), a 
<span class="lineNum">      91 </span>            : //      TMatrixD object.  
<span class="lineNum">      92 </span>            : //
<span class="lineNum">      93 </span>            : // use case:
<span class="lineNum">      94 </span>            : //  root [0] AliPHOSPIDv1 * p = new AliPHOSPIDv1(&quot;galice1.root&quot;)
<span class="lineNum">      95 </span>            : //  Warning in &lt;TDatabasePDG::TDatabasePDG&gt;: object already instantiated
<span class="lineNum">      96 </span>            : //          // reading headers from file galice1.root and create  RecParticles 
<span class="lineNum">      97 </span>            :             // TrackSegments and RecPoints are used 
<span class="lineNum">      98 </span>            : //          // set file name for the branch RecParticles
<span class="lineNum">      99 </span>            : //  root [1] p-&gt;ExecuteTask(&quot;deb all time&quot;)
<span class="lineNum">     100 </span>            : //          // available options
<span class="lineNum">     101 </span>            : //          // &quot;deb&quot; - prints # of reconstructed particles
<span class="lineNum">     102 </span>            : //          // &quot;deb all&quot; -  prints # and list of RecParticles
<span class="lineNum">     103 </span>            : //          // &quot;time&quot; - prints benchmarking results
<span class="lineNum">     104 </span>            : //                  
<span class="lineNum">     105 </span>            : //  root [2] AliPHOSPIDv1 * p2 = new AliPHOSPIDv1(&quot;galice1.root&quot;,&quot;v1&quot;,kTRUE)
<span class="lineNum">     106 </span>            : //  Warning in &lt;TDatabasePDG::TDatabasePDG&gt;: object already instantiated
<span class="lineNum">     107 </span>            : //                //Split mode.  
<span class="lineNum">     108 </span>            : //  root [3] p2-&gt;ExecuteTask()
<span class="lineNum">     109 </span>            : //
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span>            : //*-- Author: Yves Schutz (SUBATECH)  &amp; Gines Martinez (SUBATECH) &amp; 
<span class="lineNum">     113 </span>            : //            Gustavo Conesa April 2002
<span class="lineNum">     114 </span>            : //            PCA redesigned by Gustavo Conesa October 2002:
<span class="lineNum">     115 </span>            : //            The way of using the PCA has changed. Instead of 2
<span class="lineNum">     116 </span>            : //            files with the PCA, each one with different energy ranges 
<span class="lineNum">     117 </span>            : //            of application, we use the wide one (0.5-100 GeV), and instead
<span class="lineNum">     118 </span>            : //            of fixing 3 ellipses for different ranges of energy, it has been
<span class="lineNum">     119 </span>            : //            studied the dependency of the ellipses parameters with the 
<span class="lineNum">     120 </span>            : //            energy, and they are implemented in the code as a funtion 
<span class="lineNum">     121 </span>            : //            of the energy. 
<span class="lineNum">     122 </span>            : //
<span class="lineNum">     123 </span>            : //
<span class="lineNum">     124 </span>            : //
<span class="lineNum">     125 </span>            : // --- ROOT system ---
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            : // --- Standard library ---
<span class="lineNum">     129 </span>            : #include &lt;TMatrixF.h&gt;
<span class="lineNum">     130 </span>            : #include &quot;TFormula.h&quot;
<span class="lineNum">     131 </span>            : #include &quot;TBenchmark.h&quot;
<span class="lineNum">     132 </span>            : #include &quot;TPrincipal.h&quot;
<span class="lineNum">     133 </span>            : #include &quot;TFile.h&quot; 
<span class="lineNum">     134 </span>            : #include &quot;TSystem.h&quot;
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span>            : // --- AliRoot header files ---
<span class="lineNum">     137 </span>            :               //#include &quot;AliLog.h&quot;
<span class="lineNum">     138 </span>            : #include &quot;AliPHOS.h&quot;
<span class="lineNum">     139 </span>            : #include &quot;AliPHOSPIDv1.h&quot;
<span class="lineNum">     140 </span>            : #include &quot;AliESDEvent.h&quot;
<span class="lineNum">     141 </span>            : #include &quot;AliESDVertex.h&quot;
<span class="lineNum">     142 </span>            : #include &quot;AliPHOSTrackSegment.h&quot;
<span class="lineNum">     143 </span>            : #include &quot;AliPHOSEmcRecPoint.h&quot;
<a name="144"><span class="lineNum">     144 </span>            : #include &quot;AliPHOSRecParticle.h&quot;</a>
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span><span class="lineCov">         22 : ClassImp( AliPHOSPIDv1) </span>
<a name="147"><span class="lineNum">     147 </span>            : </a>
<span class="lineNum">     148 </span>            : //____________________________________________________________________________
<span class="lineNum">     149 </span>            : AliPHOSPIDv1::AliPHOSPIDv1() :
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :   AliPHOSPID(),</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :   fBayesian(kFALSE),</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :   fDefaultInit(kFALSE),</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :   fWrite(kFALSE),</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :   fFileNamePrincipalPhoton(),</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :   fFileNamePrincipalPi0(),</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :   fFileNameParameters(),</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :   fPrincipalPhoton(0),</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :   fPrincipalPi0(0),</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :   fX(0),</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :   fPPhoton(0),</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :   fPPi0(0),</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :   fParameters(0),</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :   fVtx(0.,0.,0.), </span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :   fTFphoton(0),</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :   fTFpiong(0),</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :   fTFkaong(0),</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :   fTFkaonl(0),</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :   fTFhhadrong(0),</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :   fTFhhadronl(0),</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :   fDFmuon(0),</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :   fERecWeight(0),</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :   fChargedNeutralThreshold(0.),</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :   fTOFEnThreshold(0),</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :   fDispEnThreshold(0),</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :   fDispMultThreshold(0)</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 : { </span>
<span class="lineNum">     177 </span>            :   // default ctor
<span class="lineNum">     178 </span>            :  
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :   InitParameters() ; </span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :   fDefaultInit = kTRUE ; </span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 : }</span>
<a name="182"><span class="lineNum">     182 </span>            : </a>
<span class="lineNum">     183 </span>            : //____________________________________________________________________________
<span class="lineNum">     184 </span>            : AliPHOSPIDv1::AliPHOSPIDv1(const AliPHOSPIDv1 &amp; pid ) : 
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :   AliPHOSPID(pid),</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :   fBayesian(kFALSE),</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :   fDefaultInit(kFALSE),</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :   fWrite(kFALSE),</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :   fFileNamePrincipalPhoton(),</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :   fFileNamePrincipalPi0(),</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :   fFileNameParameters(),</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :   fPrincipalPhoton(0),</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :   fPrincipalPi0(0),</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :   fX(0),</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :   fPPhoton(0),</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :   fPPi0(0),</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :   fParameters(0),</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :   fVtx(0.,0.,0.), </span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :   fTFphoton(0),</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :   fTFpiong(0),</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :   fTFkaong(0),</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :   fTFkaonl(0),</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :   fTFhhadrong(0),</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :   fTFhhadronl(0),</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :   fDFmuon(0),</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :   fERecWeight(0),</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :   fChargedNeutralThreshold(0.),</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :   fTOFEnThreshold(0),</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :   fDispEnThreshold(0),</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :   fDispMultThreshold(0)</span>
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span><span class="lineNoCov">          0 : { </span>
<span class="lineNum">     213 </span>            :   // ctor
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :   InitParameters() ; </span>
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span><span class="lineNoCov">          0 : }</span>
<a name="217"><span class="lineNum">     217 </span>            : </a>
<span class="lineNum">     218 </span>            : //____________________________________________________________________________
<span class="lineNum">     219 </span>            : AliPHOSPIDv1::AliPHOSPIDv1(AliPHOSGeometry *geom):
<span class="lineNum">     220 </span><span class="lineCov">          2 :   AliPHOSPID(geom),</span>
<span class="lineNum">     221 </span><span class="lineCov">          2 :   fBayesian(kFALSE),</span>
<span class="lineNum">     222 </span><span class="lineCov">          2 :   fDefaultInit(kFALSE),</span>
<span class="lineNum">     223 </span><span class="lineCov">          2 :   fWrite(kFALSE),</span>
<span class="lineNum">     224 </span><span class="lineCov">          2 :   fFileNamePrincipalPhoton(),</span>
<span class="lineNum">     225 </span><span class="lineCov">          2 :   fFileNamePrincipalPi0(),</span>
<span class="lineNum">     226 </span><span class="lineCov">          2 :   fFileNameParameters(),</span>
<span class="lineNum">     227 </span><span class="lineCov">          2 :   fPrincipalPhoton(0),</span>
<span class="lineNum">     228 </span><span class="lineCov">          2 :   fPrincipalPi0(0),</span>
<span class="lineNum">     229 </span><span class="lineCov">          2 :   fX(0),</span>
<span class="lineNum">     230 </span><span class="lineCov">          2 :   fPPhoton(0),</span>
<span class="lineNum">     231 </span><span class="lineCov">          2 :   fPPi0(0),</span>
<span class="lineNum">     232 </span><span class="lineCov">          2 :   fParameters(0),</span>
<span class="lineNum">     233 </span><span class="lineCov">          2 :   fVtx(0.,0.,0.), </span>
<span class="lineNum">     234 </span><span class="lineCov">          2 :   fTFphoton(0),</span>
<span class="lineNum">     235 </span><span class="lineCov">          2 :   fTFpiong(0),</span>
<span class="lineNum">     236 </span><span class="lineCov">          2 :   fTFkaong(0),</span>
<span class="lineNum">     237 </span><span class="lineCov">          2 :   fTFkaonl(0),</span>
<span class="lineNum">     238 </span><span class="lineCov">          2 :   fTFhhadrong(0),</span>
<span class="lineNum">     239 </span><span class="lineCov">          2 :   fTFhhadronl(0),</span>
<span class="lineNum">     240 </span><span class="lineCov">          2 :   fDFmuon(0),</span>
<span class="lineNum">     241 </span><span class="lineCov">          2 :   fERecWeight(0),</span>
<span class="lineNum">     242 </span><span class="lineCov">          2 :   fChargedNeutralThreshold(0.),</span>
<span class="lineNum">     243 </span><span class="lineCov">          2 :   fTOFEnThreshold(0),</span>
<span class="lineNum">     244 </span><span class="lineCov">          2 :   fDispEnThreshold(0),</span>
<span class="lineNum">     245 </span><span class="lineCov">          2 :   fDispMultThreshold(0)</span>
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span><span class="lineCov">         10 : { </span>
<span class="lineNum">     248 </span>            :   //ctor with the indication on where to look for the track segments
<span class="lineNum">     249 </span>            :  
<span class="lineNum">     250 </span><span class="lineCov">          2 :   InitParameters() ; </span>
<span class="lineNum">     251 </span><span class="lineCov">          2 :   fDefaultInit = kFALSE ; </span>
<span class="lineNum">     252 </span><span class="lineCov">          4 : }</span>
<a name="253"><span class="lineNum">     253 </span>            : </a>
<span class="lineNum">     254 </span>            : //____________________________________________________________________________
<span class="lineNum">     255 </span>            : AliPHOSPIDv1::~AliPHOSPIDv1()
<span class="lineNum">     256 </span><span class="lineCov">         12 : { </span>
<span class="lineNum">     257 </span>            :   // dtor
<span class="lineNum">     258 </span><span class="lineCov">          2 :   fPrincipalPhoton = 0;</span>
<span class="lineNum">     259 </span><span class="lineCov">          2 :   fPrincipalPi0 = 0;</span>
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span><span class="lineCov">          4 :   delete [] fX ;       // Principal input </span>
<span class="lineNum">     262 </span><span class="lineCov">          4 :   delete [] fPPhoton ; // Photon Principal components</span>
<span class="lineNum">     263 </span><span class="lineCov">          4 :   delete [] fPPi0 ;    // Pi0 Principal components</span>
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span><span class="lineCov">          4 :   delete fParameters;</span>
<span class="lineNum">     266 </span><span class="lineCov">          4 :   delete fTFphoton;</span>
<span class="lineNum">     267 </span><span class="lineCov">          4 :   delete fTFpiong;</span>
<span class="lineNum">     268 </span><span class="lineCov">          4 :   delete fTFkaong;</span>
<span class="lineNum">     269 </span><span class="lineCov">          4 :   delete fTFkaonl;</span>
<span class="lineNum">     270 </span><span class="lineCov">          4 :   delete fTFhhadrong;</span>
<span class="lineNum">     271 </span><span class="lineCov">          4 :   delete fTFhhadronl;</span>
<span class="lineNum">     272 </span><span class="lineCov">          4 :   delete fDFmuon;</span>
<span class="lineNum">     273 </span><span class="lineCov">          6 : }</span>
<a name="274"><span class="lineNum">     274 </span>            :  </a>
<span class="lineNum">     275 </span>            : //____________________________________________________________________________
<span class="lineNum">     276 </span>            : void AliPHOSPIDv1::InitParameters()
<span class="lineNum">     277 </span>            : {
<span class="lineNum">     278 </span>            :   // Initialize PID parameters
<span class="lineNum">     279 </span><span class="lineCov">          4 :   fWrite                   = kTRUE ;</span>
<span class="lineNum">     280 </span><span class="lineCov">          2 :   fBayesian          = kTRUE ;</span>
<span class="lineNum">     281 </span><span class="lineCov">          2 :   SetParameters() ; // fill the parameters matrix from parameters file</span>
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            :   // initialisation of response function parameters
<span class="lineNum">     284 </span>            :   // Tof
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            : //   // Photons
<span class="lineNum">     287 </span>            : //   fTphoton[0] = 0.218    ;
<span class="lineNum">     288 </span>            : //   fTphoton[1] = 1.55E-8  ; 
<span class="lineNum">     289 </span>            : //   fTphoton[2] = 5.05E-10 ;
<span class="lineNum">     290 </span>            : //   fTFphoton = new TFormula(&quot;ToF response to photons&quot; , &quot;gaus&quot;) ; 
<span class="lineNum">     291 </span>            : //   fTFphoton-&gt;SetParameters( fTphoton[0], fTphoton[1], fTphoton[2]) ; 
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            : //   // Pions
<span class="lineNum">     294 </span>            : //   //Gaus (0 to max probability)
<span class="lineNum">     295 </span>            : //   fTpiong[0] = 0.0971    ; 
<span class="lineNum">     296 </span>            : //   fTpiong[1] = 1.58E-8  ; 
<span class="lineNum">     297 </span>            : //   fTpiong[2] = 5.69E-10 ;
<span class="lineNum">     298 </span>            : //   fTFpiong = new TFormula(&quot;ToF response to pions&quot; , &quot;gaus&quot;) ; 
<span class="lineNum">     299 </span>            : //   fTFpiong-&gt;SetParameters( fTpiong[0], fTpiong[1], fTpiong[2]) ; 
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            : //   // Kaons
<span class="lineNum">     302 </span>            : //   //Gaus (0 to max probability)
<span class="lineNum">     303 </span>            : //   fTkaong[0] = 0.0542  ; 
<span class="lineNum">     304 </span>            : //   fTkaong[1] = 1.64E-8 ; 
<span class="lineNum">     305 </span>            : //   fTkaong[2] = 6.07E-10 ;
<span class="lineNum">     306 </span>            : //   fTFkaong = new TFormula(&quot;ToF response to kaon&quot; , &quot;gaus&quot;) ; 
<span class="lineNum">     307 </span>            : //   fTFkaong-&gt;SetParameters( fTkaong[0], fTkaong[1], fTkaong[2]) ; 
<span class="lineNum">     308 </span>            : //   //Landau (max probability to inf) 
<span class="lineNum">     309 </span>            : //   fTkaonl[0] = 0.264   ;
<span class="lineNum">     310 </span>            : //   fTkaonl[1] = 1.68E-8  ; 
<span class="lineNum">     311 </span>            : //   fTkaonl[2] = 4.10E-10 ;
<span class="lineNum">     312 </span>            : //   fTFkaonl = new TFormula(&quot;ToF response to kaon&quot; , &quot;landau&quot;) ; 
<span class="lineNum">     313 </span>            : //   fTFkaonl-&gt;SetParameters( fTkaonl[0], fTkaonl[1], fTkaonl[2]) ; 
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span>            : //   //Heavy Hadrons
<span class="lineNum">     316 </span>            : //   //Gaus (0 to max probability)
<span class="lineNum">     317 </span>            : //   fThhadrong[0] = 0.0302   ;  
<span class="lineNum">     318 </span>            : //   fThhadrong[1] = 1.73E-8  ; 
<span class="lineNum">     319 </span>            : //   fThhadrong[2] = 9.52E-10 ;
<span class="lineNum">     320 </span>            : //   fTFhhadrong = new TFormula(&quot;ToF response to heavy hadrons&quot; , &quot;gaus&quot;) ; 
<span class="lineNum">     321 </span>            : //   fTFhhadrong-&gt;SetParameters( fThhadrong[0], fThhadrong[1], fThhadrong[2]) ; 
<span class="lineNum">     322 </span>            : //   //Landau (max probability to inf) 
<span class="lineNum">     323 </span>            : //   fThhadronl[0] = 0.139    ;  
<span class="lineNum">     324 </span>            : //   fThhadronl[1] = 1.745E-8  ; 
<span class="lineNum">     325 </span>            : //   fThhadronl[2] = 1.00E-9  ;
<span class="lineNum">     326 </span>            : //   fTFhhadronl = new TFormula(&quot;ToF response to heavy hadrons&quot; , &quot;landau&quot;) ; 
<span class="lineNum">     327 </span>            : //   fTFhhadronl-&gt;SetParameters( fThhadronl[0], fThhadronl[1], fThhadronl[2]) ; 
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            :   // Photons
<span class="lineNum">     330 </span><span class="lineCov">          2 :   fTphoton[0] = 7.83E8   ;</span>
<span class="lineNum">     331 </span><span class="lineCov">          2 :   fTphoton[1] = 1.55E-8  ; </span>
<span class="lineNum">     332 </span><span class="lineCov">          2 :   fTphoton[2] = 5.09E-10 ;</span>
<span class="lineNum">     333 </span><span class="lineCov">          4 :   fTFphoton = new TFormula(&quot;ToF response to photons&quot; , &quot;gaus&quot;) ; </span>
<span class="lineNum">     334 </span><span class="lineCov">          2 :   fTFphoton-&gt;SetParameters( fTphoton[0], fTphoton[1], fTphoton[2]) ; </span>
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            :   // Pions
<span class="lineNum">     337 </span>            :   //Gaus (0 to max probability)
<span class="lineNum">     338 </span><span class="lineCov">          2 :   fTpiong[0] = 6.73E8    ; </span>
<span class="lineNum">     339 </span><span class="lineCov">          2 :   fTpiong[1] = 1.58E-8  ; </span>
<span class="lineNum">     340 </span><span class="lineCov">          2 :   fTpiong[2] = 5.87E-10 ;</span>
<span class="lineNum">     341 </span><span class="lineCov">          4 :   fTFpiong = new TFormula(&quot;ToF response to pions&quot; , &quot;gaus&quot;) ; </span>
<span class="lineNum">     342 </span><span class="lineCov">          2 :   fTFpiong-&gt;SetParameters( fTpiong[0], fTpiong[1], fTpiong[2]) ; </span>
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span>            :   // Kaons
<span class="lineNum">     345 </span>            :   //Gaus (0 to max probability)
<span class="lineNum">     346 </span><span class="lineCov">          2 :   fTkaong[0] = 3.93E8  ; </span>
<span class="lineNum">     347 </span><span class="lineCov">          2 :   fTkaong[1] = 1.64E-8 ; </span>
<span class="lineNum">     348 </span><span class="lineCov">          2 :   fTkaong[2] = 6.07E-10 ;</span>
<span class="lineNum">     349 </span><span class="lineCov">          4 :   fTFkaong = new TFormula(&quot;ToF response to kaon&quot; , &quot;gaus&quot;) ; </span>
<span class="lineNum">     350 </span><span class="lineCov">          2 :   fTFkaong-&gt;SetParameters( fTkaong[0], fTkaong[1], fTkaong[2]) ; </span>
<span class="lineNum">     351 </span>            :   //Landau (max probability to inf) 
<span class="lineNum">     352 </span><span class="lineCov">          2 :   fTkaonl[0] = 2.0E9    ;</span>
<span class="lineNum">     353 </span><span class="lineCov">          2 :   fTkaonl[1] = 1.68E-8  ; </span>
<span class="lineNum">     354 </span><span class="lineCov">          2 :   fTkaonl[2] = 4.10E-10 ;</span>
<span class="lineNum">     355 </span><span class="lineCov">          4 :   fTFkaonl = new TFormula(&quot;ToF response to kaon&quot; , &quot;landau&quot;) ; </span>
<span class="lineNum">     356 </span><span class="lineCov">          2 :   fTFkaonl-&gt;SetParameters( fTkaonl[0], fTkaonl[1], fTkaonl[2]) ; </span>
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span>            :   //Heavy Hadrons
<span class="lineNum">     359 </span>            :   //Gaus (0 to max probability)
<span class="lineNum">     360 </span><span class="lineCov">          2 :   fThhadrong[0] = 2.02E8   ;  </span>
<span class="lineNum">     361 </span><span class="lineCov">          2 :   fThhadrong[1] = 1.73E-8  ; </span>
<span class="lineNum">     362 </span><span class="lineCov">          2 :   fThhadrong[2] = 9.52E-10 ;</span>
<span class="lineNum">     363 </span><span class="lineCov">          4 :   fTFhhadrong = new TFormula(&quot;ToF response to heavy hadrons&quot; , &quot;gaus&quot;) ; </span>
<span class="lineNum">     364 </span><span class="lineCov">          2 :   fTFhhadrong-&gt;SetParameters( fThhadrong[0], fThhadrong[1], fThhadrong[2]) ; </span>
<span class="lineNum">     365 </span>            :   //Landau (max probability to inf) 
<span class="lineNum">     366 </span><span class="lineCov">          2 :   fThhadronl[0] = 1.10E9    ;  </span>
<span class="lineNum">     367 </span><span class="lineCov">          2 :   fThhadronl[1] = 1.74E-8   ; </span>
<span class="lineNum">     368 </span><span class="lineCov">          2 :   fThhadronl[2] = 1.00E-9   ;</span>
<span class="lineNum">     369 </span><span class="lineCov">          4 :   fTFhhadronl = new TFormula(&quot;ToF response to heavy hadrons&quot; , &quot;landau&quot;) ; </span>
<span class="lineNum">     370 </span><span class="lineCov">          2 :   fTFhhadronl-&gt;SetParameters( fThhadronl[0], fThhadronl[1], fThhadronl[2]) ; </span>
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            :   // Shower shape: dispersion gaussian parameters
<span class="lineNum">     375 </span>            :   // Photons
<span class="lineNum">     376 </span>            :   
<span class="lineNum">     377 </span>            : //   fDphoton[0] = 4.62e-2;  fDphoton[1] = 1.39e-2 ; fDphoton[2] = -3.80e-2;//constant
<span class="lineNum">     378 </span>            : //   fDphoton[3] = 1.53   ;  fDphoton[4] =-6.62e-2 ; fDphoton[5] = 0.339   ;//mean
<span class="lineNum">     379 </span>            : //   fDphoton[6] = 6.89e-2;  fDphoton[7] =-6.59e-2 ; fDphoton[8] = 0.194   ;//sigma
<span class="lineNum">     380 </span>            :   
<span class="lineNum">     381 </span>            : //   fDpi0[0] = 0.0586  ;  fDpi0[1] = 1.06E-3 ; fDpi0[2] = 0.      ;//constant
<span class="lineNum">     382 </span>            : //   fDpi0[3] = 2.67    ;  fDpi0[4] =-2.00E-2 ; fDpi0[5] = 9.37E-5 ;//mean
<span class="lineNum">     383 </span>            : //   fDpi0[6] = 0.153   ;  fDpi0[7] = 9.34E-4 ; fDpi0[8] =-1.49E-5 ;//sigma
<span class="lineNum">     384 </span>            :   
<span class="lineNum">     385 </span>            : //   fDhadron[0] = 1.61E-2 ;  fDhadron[1] = 3.03E-3 ; fDhadron[2] = 1.01E-2 ;//constant
<span class="lineNum">     386 </span>            : //   fDhadron[3] = 3.81    ;  fDhadron[4] = 0.232   ; fDhadron[5] =-1.25    ;//mean
<span class="lineNum">     387 </span>            : //   fDhadron[6] = 0.897   ;  fDhadron[7] = 0.0987  ; fDhadron[8] =-0.534   ;//sigma
<span class="lineNum">     388 </span>            :   
<span class="lineNum">     389 </span><span class="lineCov">          2 :   fDphoton[0] = 1.5    ;  fDphoton[1] = 0.49    ; fDphoton[2] =-1.7E-2 ;//constant</span>
<span class="lineNum">     390 </span><span class="lineCov">          2 :   fDphoton[3] = 1.5    ;  fDphoton[4] = 4.0E-2  ; fDphoton[5] = 0.21   ;//mean</span>
<span class="lineNum">     391 </span><span class="lineCov">          2 :   fDphoton[6] = 4.8E-2 ;  fDphoton[7] =-0.12    ; fDphoton[8] = 0.27   ;//sigma</span>
<span class="lineNum">     392 </span><span class="lineCov">          2 :   fDphoton[9] = 16.; //for E&gt;  fDphoton[9] parameters calculated at  fDphoton[9]</span>
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span><span class="lineCov">          2 :   fDpi0[0] = 0.25      ;  fDpi0[1] = 3.3E-2     ; fDpi0[2] =-1.0e-5    ;//constant</span>
<span class="lineNum">     395 </span><span class="lineCov">          2 :   fDpi0[3] = 1.50      ;  fDpi0[4] = 398.       ; fDpi0[5] = 12.       ;//mean</span>
<span class="lineNum">     396 </span><span class="lineCov">          2 :   fDpi0[6] =-7.0E-2    ;  fDpi0[7] =-524.       ; fDpi0[8] = 22.       ;//sigma</span>
<span class="lineNum">     397 </span><span class="lineCov">          2 :   fDpi0[9] = 110.; //for E&gt;  fDpi0[9] parameters calculated at  fDpi0[9]</span>
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span><span class="lineCov">          2 :   fDhadron[0] = 6.5    ;  fDhadron[1] =-5.3     ; fDhadron[2] = 1.5    ;//constant</span>
<span class="lineNum">     400 </span><span class="lineCov">          2 :   fDhadron[3] = 3.8    ;  fDhadron[4] = 0.23    ; fDhadron[5] =-1.2    ;//mean</span>
<span class="lineNum">     401 </span><span class="lineCov">          2 :   fDhadron[6] = 0.88   ;  fDhadron[7] = 9.3E-2  ; fDhadron[8] =-0.51   ;//sigma</span>
<span class="lineNum">     402 </span><span class="lineCov">          2 :   fDhadron[9] = 2.; //for E&gt;  fDhadron[9] parameters calculated at  fDhadron[9]</span>
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span><span class="lineCov">          2 :   fDmuon[0] = 0.0631 ;</span>
<span class="lineNum">     405 </span><span class="lineCov">          2 :   fDmuon[1] = 1.4    ; </span>
<span class="lineNum">     406 </span><span class="lineCov">          2 :   fDmuon[2] = 0.0557 ;</span>
<span class="lineNum">     407 </span><span class="lineCov">          4 :   fDFmuon = new TFormula(&quot;Shower shape response to muons&quot; , &quot;landau&quot;) ; </span>
<span class="lineNum">     408 </span><span class="lineCov">          2 :   fDFmuon-&gt;SetParameters( fDmuon[0], fDmuon[1], fDmuon[2]) ; </span>
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            :   // x(CPV-EMC) distance gaussian parameters
<span class="lineNum">     412 </span>            :   
<span class="lineNum">     413 </span>            : //   fXelectron[0] = 8.06e-2 ;  fXelectron[1] = 1.00e-2; fXelectron[2] =-5.14e-2;//constant
<span class="lineNum">     414 </span>            : //   fXelectron[3] = 0.202   ;  fXelectron[4] = 8.15e-3; fXelectron[5] = 4.55   ;//mean
<span class="lineNum">     415 </span>            : //   fXelectron[6] = 0.334   ;  fXelectron[7] = 0.186  ; fXelectron[8] = 4.32e-2;//sigma
<span class="lineNum">     416 </span>            :   
<span class="lineNum">     417 </span>            : //   //charged hadrons gaus
<span class="lineNum">     418 </span>            : //   fXcharged[0] = 6.43e-3 ;  fXcharged[1] =-4.19e-5; fXcharged[2] = 1.42e-3;//constant
<span class="lineNum">     419 </span>            : //   fXcharged[3] = 2.75    ;  fXcharged[4] =-0.40   ; fXcharged[5] = 1.68   ;//mean
<span class="lineNum">     420 </span>            : //   fXcharged[6] = 3.135   ;  fXcharged[7] =-9.41e-2; fXcharged[8] = 1.31e-2;//sigma
<span class="lineNum">     421 </span>            :   
<span class="lineNum">     422 </span>            : //   // z(CPV-EMC) distance gaussian parameters
<span class="lineNum">     423 </span>            :   
<span class="lineNum">     424 </span>            : //   fZelectron[0] = 8.22e-2 ;  fZelectron[1] = 5.11e-3; fZelectron[2] =-3.05e-2;//constant
<span class="lineNum">     425 </span>            : //   fZelectron[3] = 3.09e-2 ;  fZelectron[4] = 5.87e-2; fZelectron[5] =-9.49e-2;//mean
<span class="lineNum">     426 </span>            : //   fZelectron[6] = 0.263   ;  fZelectron[7] =-9.02e-3; fZelectron[8] = 0.151 ;//sigma
<span class="lineNum">     427 </span>            :   
<span class="lineNum">     428 </span>            : //   //charged hadrons gaus
<span class="lineNum">     429 </span>            :   
<span class="lineNum">     430 </span>            : //   fZcharged[0] = 1.00e-2 ;  fZcharged[1] = 2.82E-4 ; fZcharged[2] = 2.87E-3 ;//constant
<span class="lineNum">     431 </span>            : //   fZcharged[3] =-4.68e-2 ;  fZcharged[4] =-9.21e-3 ; fZcharged[5] = 4.91e-2 ;//mean
<span class="lineNum">     432 </span>            : //   fZcharged[6] = 1.425   ;  fZcharged[7] =-5.90e-2 ; fZcharged[8] = 5.07e-2 ;//sigma
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span><span class="lineCov">          2 :   fXelectron[0] =-1.6E-2 ;  fXelectron[1] = 0.77  ; fXelectron[2] =-0.15 ;//constant</span>
<span class="lineNum">     436 </span><span class="lineCov">          2 :   fXelectron[3] = 0.35   ;  fXelectron[4] = 0.25  ; fXelectron[5] = 4.12 ;//mean</span>
<span class="lineNum">     437 </span><span class="lineCov">          2 :   fXelectron[6] = 0.30   ;  fXelectron[7] = 0.11  ; fXelectron[8] = 0.16 ;//sigma</span>
<span class="lineNum">     438 </span><span class="lineCov">          2 :   fXelectron[9] = 3.; //for E&gt;  fXelectron[9] parameters calculated at  fXelectron[9]</span>
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span>            :   //charged hadrons gaus
<span class="lineNum">     441 </span><span class="lineCov">          2 :   fXcharged[0] = 0.14    ;  fXcharged[1] =-3.0E-2 ; fXcharged[2] = 0     ;//constant</span>
<span class="lineNum">     442 </span><span class="lineCov">          2 :   fXcharged[3] = 1.4     ;  fXcharged[4] =-9.3E-2 ; fXcharged[5] = 1.4   ;//mean</span>
<span class="lineNum">     443 </span><span class="lineCov">          2 :   fXcharged[6] = 5.7     ;  fXcharged[7] = 0.27   ; fXcharged[8] =-1.8   ;//sigma</span>
<span class="lineNum">     444 </span><span class="lineCov">          2 :   fXcharged[9] = 1.2; //for E&gt;  fXcharged[9] parameters calculated at  fXcharged[9]</span>
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            :   // z(CPV-EMC) distance gaussian parameters
<span class="lineNum">     447 </span>            :   
<span class="lineNum">     448 </span><span class="lineCov">          2 :   fZelectron[0] = 0.49   ;  fZelectron[1] = 0.53   ; fZelectron[2] =-9.8E-2 ;//constant</span>
<span class="lineNum">     449 </span><span class="lineCov">          2 :   fZelectron[3] = 2.8E-2 ;  fZelectron[4] = 5.0E-2 ; fZelectron[5] =-8.2E-2 ;//mean</span>
<span class="lineNum">     450 </span><span class="lineCov">          2 :   fZelectron[6] = 0.25   ;  fZelectron[7] =-1.7E-2 ; fZelectron[8] = 0.17   ;//sigma</span>
<span class="lineNum">     451 </span><span class="lineCov">          2 :   fZelectron[9] = 3.; //for E&gt;  fZelectron[9] parameters calculated at  fZelectron[9]</span>
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span>            :   //charged hadrons gaus
<span class="lineNum">     454 </span>            :   
<span class="lineNum">     455 </span><span class="lineCov">          2 :   fZcharged[0] = 0.46    ;  fZcharged[1] =-0.65    ; fZcharged[2] = 0.52    ;//constant</span>
<span class="lineNum">     456 </span><span class="lineCov">          2 :   fZcharged[3] = 1.1E-2  ;  fZcharged[4] = 0.      ; fZcharged[5] = 0.      ;//mean</span>
<span class="lineNum">     457 </span><span class="lineCov">          2 :   fZcharged[6] = 0.60    ;  fZcharged[7] =-8.2E-2  ; fZcharged[8] = 0.45    ;//sigma</span>
<span class="lineNum">     458 </span><span class="lineCov">          2 :   fZcharged[9] = 1.2; //for E&gt;  fXcharged[9] parameters calculated at  fXcharged[9]</span>
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span>            :   //Threshold to differentiate between charged and neutral
<span class="lineNum">     461 </span><span class="lineCov">          2 :   fChargedNeutralThreshold = 1e-5;</span>
<span class="lineNum">     462 </span><span class="lineCov">          2 :   fTOFEnThreshold          = 2;          //Maximum energy to use TOF</span>
<span class="lineNum">     463 </span><span class="lineCov">          2 :   fDispEnThreshold         = 0.5;       //Minimum energy to use shower shape</span>
<span class="lineNum">     464 </span><span class="lineCov">          2 :   fDispMultThreshold       = 3;       //Minimum multiplicity to use shower shape</span>
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span>            :   //Weight to hadrons recontructed energy
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span><span class="lineCov">          2 :   fERecWeightPar[0] = 0.32 ; </span>
<span class="lineNum">     469 </span><span class="lineCov">          2 :   fERecWeightPar[1] = 3.8  ;</span>
<span class="lineNum">     470 </span><span class="lineCov">          2 :   fERecWeightPar[2] = 5.4E-3 ; </span>
<span class="lineNum">     471 </span><span class="lineCov">          2 :   fERecWeightPar[3] = 5.6E-2 ;</span>
<span class="lineNum">     472 </span><span class="lineCov">          4 :   fERecWeight = new TFormula(&quot;Weight for hadrons&quot; , &quot;[0]*exp(-x*[1])+[2]*exp(-x*[3])&quot;) ; </span>
<span class="lineNum">     473 </span><span class="lineCov">          2 :   fERecWeight -&gt;SetParameters(fERecWeightPar[0],fERecWeightPar[1] ,fERecWeightPar[2] ,fERecWeightPar[3]) ; </span>
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span>            : 
<span class="lineNum">     476 </span><span class="lineCov">         60 :   for (Int_t i =0; i&lt;  AliPID::kSPECIESCN ; i++)</span>
<span class="lineNum">     477 </span><span class="lineCov">         28 :     fInitPID[i] = 1.;</span>
<span class="lineNum">     478 </span>            :  
<span class="lineNum">     479 </span><span class="lineCov">          2 : }</span>
<a name="480"><span class="lineNum">     480 </span>            : </a>
<span class="lineNum">     481 </span>            : //________________________________________________________________________
<span class="lineNum">     482 </span>            : void  AliPHOSPIDv1::TrackSegments2RecParticles(Option_t *option)
<span class="lineNum">     483 </span>            : {
<span class="lineNum">     484 </span>            :   // Steering method to perform particle reconstruction and identification
<span class="lineNum">     485 </span>            :   // for the event range from fFirstEvent to fLastEvent.
<span class="lineNum">     486 </span>            :   
<span class="lineNum">     487 </span><span class="lineCov">         16 :   if(strstr(option,&quot;tim&quot;))</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :     gBenchmark-&gt;Start(&quot;PHOSPID&quot;);</span>
<span class="lineNum">     489 </span>            :   
<span class="lineNum">     490 </span><span class="lineCov">          8 :   if(strstr(option,&quot;print&quot;)) {</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :     Print() ; </span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :     return ; </span>
<span class="lineNum">     493 </span>            :   }
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span><span class="lineCov">         16 :   if(fTrackSegments &amp;&amp; //Skip events, where no track segments made</span>
<span class="lineNum">     496 </span><span class="lineCov">          8 :      fTrackSegments-&gt;GetEntriesFast()) {</span>
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span><span class="lineCov">          8 :     GetVertex() ;</span>
<span class="lineNum">     499 </span><span class="lineCov">          8 :     MakeRecParticles() ;</span>
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span><span class="lineCov">          8 :     if(fBayesian)</span>
<span class="lineNum">     502 </span><span class="lineCov">          8 :       MakePID() ; </span>
<span class="lineNum">     503 </span>            :       
<span class="lineNum">     504 </span><span class="lineCov">          8 :     if(strstr(option,&quot;deb&quot;))</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :       PrintRecParticles(option) ;    </span>
<span class="lineNum">     506 </span>            :   }
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span><span class="lineCov">          8 :   if(strstr(option,&quot;deb&quot;))</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :       PrintRecParticles(option);</span>
<span class="lineNum">     510 </span><span class="lineCov">          8 :   if(strstr(option,&quot;tim&quot;)){</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :     gBenchmark-&gt;Stop(&quot;PHOSPID&quot;);</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :     AliInfo(Form(&quot;took %f seconds for PID&quot;, </span>
<span class="lineNum">     513 </span>            :                  gBenchmark-&gt;GetCpuTime(&quot;PHOSPID&quot;)));  
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     515 </span><span class="lineCov">          8 : }</span>
<a name="516"><span class="lineNum">     516 </span>            : </a>
<span class="lineNum">     517 </span>            : //________________________________________________________________________
<span class="lineNum">     518 </span>            : Double_t  AliPHOSPIDv1::GausF(Double_t  x, Double_t  y, Double_t * par)
<span class="lineNum">     519 </span>            : {
<span class="lineNum">     520 </span>            :   //Given the energy x and the parameter y (tof, shower dispersion or cpv-emc distance), 
<span class="lineNum">     521 </span>            :   //this method returns a density probability of this parameter, given by a gaussian 
<span class="lineNum">     522 </span>            :   //function whose parameters depend with the energy  with a function: a/(x*x)+b/x+b
<span class="lineNum">     523 </span>            :   //Float_t xorg = x;
<span class="lineNum">     524 </span><span class="lineCov">        140 :   if (x &gt; par[9]) x = par[9];</span>
<span class="lineNum">     525 </span>            :   
<span class="lineNum">     526 </span>            :   //Double_t cnt    = par[1] / (x*x) + par[2] / x + par[0] ;
<span class="lineNum">     527 </span><span class="lineCov">         50 :   Double_t cnt    = par[0] + par[1] * x + par[2] * x * x ;</span>
<span class="lineNum">     528 </span><span class="lineCov">         50 :   Double_t mean   = par[4] / (x*x) + par[5] / x + par[3] ;</span>
<span class="lineNum">     529 </span><span class="lineCov">         50 :   Double_t sigma  = par[7] / (x*x) + par[8] / x + par[6] ;</span>
<span class="lineNum">     530 </span>            :  
<span class="lineNum">     531 </span>            : //   if(xorg &gt; 30)
<span class="lineNum">     532 </span>            : //     cout&lt;&lt;&quot;En_in = &quot;&lt;&lt;xorg&lt;&lt;&quot;; En_out = &quot;&lt;&lt;x&lt;&lt;&quot;; cnt = &quot;&lt;&lt;cnt
<span class="lineNum">     533 </span>            : //      &lt;&lt;&quot;; mean = &quot;&lt;&lt;mean&lt;&lt;&quot;; sigma = &quot;&lt;&lt;sigma&lt;&lt;endl;
<span class="lineNum">     534 </span>            :       
<span class="lineNum">     535 </span>            :   //  Double_t arg    = - (y-mean) * (y-mean) / (2*sigma*sigma) ;
<span class="lineNum">     536 </span>            :   //  return cnt * TMath::Exp(arg) ;
<span class="lineNum">     537 </span><span class="lineCov">         50 :   if(TMath::Abs(sigma) &gt; 1.e-10){</span>
<span class="lineNum">     538 </span><span class="lineCov">         50 :     return cnt*TMath::Gaus(y,mean,sigma);</span>
<span class="lineNum">     539 </span>            :   }
<span class="lineNum">     540 </span>            :   else
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :     return 0.;</span>
<span class="lineNum">     542 </span>            :  
<a name="543"><span class="lineNum">     543 </span><span class="lineCov">         50 : }</span></a>
<span class="lineNum">     544 </span>            : //________________________________________________________________________
<span class="lineNum">     545 </span>            : Double_t  AliPHOSPIDv1::GausPol2(Double_t  x, Double_t y, Double_t * par)
<span class="lineNum">     546 </span>            : {
<span class="lineNum">     547 </span>            :   //Given the energy x and the parameter y (tof, shower dispersion or cpv-emc distance), 
<span class="lineNum">     548 </span>            :   //this method returns a density probability of this parameter, given by a gaussian 
<span class="lineNum">     549 </span>            :   //function whose parameters depend with the energy like second order polinomial
<span class="lineNum">     550 </span>            : 
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :   Double_t cnt    = par[0] + par[1] * x + par[2] * x * x ;</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :   Double_t mean   = par[3] + par[4] * x + par[5] * x * x ;</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :   Double_t sigma  = par[6] + par[7] * x + par[8] * x * x ;</span>
<span class="lineNum">     554 </span>            : 
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :   if(TMath::Abs(sigma) &gt; 1.e-10){</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :     return cnt*TMath::Gaus(y,mean,sigma);</span>
<span class="lineNum">     557 </span>            :   }
<span class="lineNum">     558 </span>            :   else
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :     return 0.;</span>
<span class="lineNum">     560 </span>            :  
<span class="lineNum">     561 </span>            : 
<span class="lineNum">     562 </span>            : 
<span class="lineNum">     563 </span><span class="lineNoCov">          0 : }</span>
<a name="564"><span class="lineNum">     564 </span>            : </a>
<span class="lineNum">     565 </span>            : //____________________________________________________________________________
<span class="lineNum">     566 </span>            : const TString AliPHOSPIDv1::GetFileNamePrincipal(TString particle) const
<span class="lineNum">     567 </span>            : {
<span class="lineNum">     568 </span>            :   //Get file name that contains the PCA for a particle (&quot;photon or pi0&quot;)
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :   particle.ToLower();</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :   TString name;</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :   if      (particle==&quot;photon&quot;) </span>
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :     name = fFileNamePrincipalPhoton ;</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :   else if (particle==&quot;pi0&quot;   ) </span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :     name = fFileNamePrincipalPi0    ;</span>
<span class="lineNum">     575 </span>            :   else    
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :     AliError(Form(&quot;Wrong particle name: %s (choose from pi0/photon)\n&quot;,</span>
<span class="lineNum">     577 </span>            :                   particle.Data()));
<span class="lineNum">     578 </span>            :   return name;
<span class="lineNum">     579 </span><span class="lineNoCov">          0 : }</span>
<a name="580"><span class="lineNum">     580 </span>            : </a>
<span class="lineNum">     581 </span>            : //____________________________________________________________________________
<span class="lineNum">     582 </span>            : Float_t  AliPHOSPIDv1::GetParameterCalibration(Int_t i) const 
<span class="lineNum">     583 </span>            : {
<span class="lineNum">     584 </span>            :   // Get the i-th parameter &quot;Calibration&quot;
<span class="lineNum">     585 </span>            :   Float_t param = 0.;
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :   if (i&gt;2 || i&lt;0) { </span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :     AliError(Form(&quot;Invalid parameter number: %d&quot;,i));</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :   } else</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :     param = (*fParameters)(0,i);</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :   return param;</span>
<span class="lineNum">     591 </span>            : }
<a name="592"><span class="lineNum">     592 </span>            : </a>
<span class="lineNum">     593 </span>            : //____________________________________________________________________________
<span class="lineNum">     594 </span>            : Float_t  AliPHOSPIDv1::GetParameterCpv2Emc(Int_t i, TString axis) const 
<span class="lineNum">     595 </span>            : {
<span class="lineNum">     596 </span>            :   // Get the i-th parameter &quot;CPV-EMC distance&quot; for the specified axis
<span class="lineNum">     597 </span>            :   Float_t param = 0.;
<span class="lineNum">     598 </span><span class="lineCov">        360 :   if(i&gt;2 || i&lt;0) {</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :     AliError(Form(&quot;Invalid parameter number: %d&quot;,i));</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">     601 </span><span class="lineCov">        180 :     axis.ToLower();</span>
<span class="lineNum">     602 </span><span class="lineCov">        180 :     if      (axis == &quot;x&quot;) </span>
<span class="lineNum">     603 </span><span class="lineCov">         90 :       param = (*fParameters)(1,i);</span>
<span class="lineNum">     604 </span><span class="lineCov">         90 :     else if (axis == &quot;z&quot;) </span>
<span class="lineNum">     605 </span><span class="lineCov">         90 :       param = (*fParameters)(2,i);</span>
<span class="lineNum">     606 </span>            :     else { 
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :       AliError(Form(&quot;Invalid axis name: %s&quot;,axis.Data()));</span>
<span class="lineNum">     608 </span>            :     }
<span class="lineNum">     609 </span>            :   }
<span class="lineNum">     610 </span><span class="lineCov">        180 :   return  param;</span>
<span class="lineNum">     611 </span>            : }
<a name="612"><span class="lineNum">     612 </span>            : </a>
<span class="lineNum">     613 </span>            : //____________________________________________________________________________
<span class="lineNum">     614 </span>            : Float_t  AliPHOSPIDv1::GetCpv2EmcDistanceCut(TString axis, Float_t e) const
<span class="lineNum">     615 </span>            : {
<span class="lineNum">     616 </span>            :   // Get CpvtoEmcDistance Cut depending on the cluster energy, axis and 
<span class="lineNum">     617 </span>            :   // Purity-Efficiency point 
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span><span class="lineCov">        120 :   axis.ToLower();</span>
<span class="lineNum">     620 </span><span class="lineCov">         60 :   Float_t p[]={0.,0.,0.};</span>
<span class="lineNum">     621 </span><span class="lineCov">        660 :   for (Int_t i=0; i&lt;3; i++) p[i] = GetParameterCpv2Emc(i,axis);</span>
<span class="lineNum">     622 </span><span class="lineCov">         60 :   Float_t sig = p[0] + TMath::Exp(p[1] - p[2]*e);</span>
<span class="lineNum">     623 </span><span class="lineCov">         60 :   return sig;</span>
<span class="lineNum">     624 </span><span class="lineCov">         60 : }</span>
<a name="625"><span class="lineNum">     625 </span>            : </a>
<span class="lineNum">     626 </span>            : //____________________________________________________________________________
<span class="lineNum">     627 </span>            : Float_t  AliPHOSPIDv1::GetEllipseParameter(TString particle, TString param, Float_t e) const 
<span class="lineNum">     628 </span>            : {
<span class="lineNum">     629 </span>            :   // Calculates the parameter param of the ellipse
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span><span class="lineCov">        600 :   particle.ToLower();</span>
<span class="lineNum">     632 </span><span class="lineCov">        300 :   param.   ToLower();</span>
<span class="lineNum">     633 </span><span class="lineCov">        300 :   Float_t p[4]={0.,0.,0.,0.};</span>
<span class="lineNum">     634 </span>            :   Float_t value = 0.0;
<span class="lineNum">     635 </span><span class="lineCov">       5400 :   for (Int_t i=0; i&lt;4; i++) p[i] = GetParameterToCalculateEllipse(particle,param,i);</span>
<span class="lineNum">     636 </span><span class="lineCov">        300 :   if (particle == &quot;photon&quot;) {</span>
<span class="lineNum">     637 </span><span class="lineCov">        180 :     if      (param.Contains(&quot;a&quot;))  e = TMath::Min((Double_t)e,70.);</span>
<span class="lineNum">     638 </span><span class="lineCov">        150 :     else if (param.Contains(&quot;b&quot;))  e = TMath::Min((Double_t)e,70.);</span>
<span class="lineNum">     639 </span><span class="lineCov">        120 :     else if (param.Contains(&quot;x0&quot;)) e = TMath::Max((Double_t)e,1.1);</span>
<span class="lineNum">     640 </span>            :   }
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span><span class="lineCov">        300 :  if (particle == &quot;photon&quot;)</span>
<span class="lineNum">     643 </span><span class="lineCov">        150 :     value = p[0]/TMath::Sqrt(e) + p[1]*e + p[2]*e*e + p[3];</span>
<span class="lineNum">     644 </span><span class="lineCov">        150 :   else if (particle == &quot;pi0&quot;)</span>
<span class="lineNum">     645 </span><span class="lineCov">        150 :     value = p[0] + p[1]*e + p[2]*e*e;</span>
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span><span class="lineCov">        300 :   return value;</span>
<span class="lineNum">     648 </span><span class="lineCov">        300 : }</span>
<a name="649"><span class="lineNum">     649 </span>            : </a>
<span class="lineNum">     650 </span>            : //_____________________________________________________________________________
<span class="lineNum">     651 </span>            : Float_t  AliPHOSPIDv1::GetParameterPhotonBoundary (Int_t i) const
<span class="lineNum">     652 </span>            : { 
<span class="lineNum">     653 </span>            :   // Get the parameter &quot;i&quot; to calculate the boundary on the moment M2x
<span class="lineNum">     654 </span>            :   // for photons at high p_T
<span class="lineNum">     655 </span>            :   Float_t param = 0;
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :   if (i&gt;3 || i&lt;0) {</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :     AliError(Form(&quot;Wrong parameter number: %d\n&quot;,i));</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :   } else</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :     param = (*fParameters)(14,i) ;</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :   return param;</span>
<span class="lineNum">     661 </span>            : }
<a name="662"><span class="lineNum">     662 </span>            : </a>
<span class="lineNum">     663 </span>            : //____________________________________________________________________________
<span class="lineNum">     664 </span>            : Float_t  AliPHOSPIDv1::GetParameterPi0Boundary (Int_t i) const
<span class="lineNum">     665 </span>            : { 
<span class="lineNum">     666 </span>            :   // Get the parameter &quot;i&quot; to calculate the boundary on the moment M2x
<span class="lineNum">     667 </span>            :   // for pi0 at high p_T
<span class="lineNum">     668 </span>            :   Float_t param = 0;
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :   if (i&gt;2 || i&lt;0) {</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :     AliError(Form(&quot;Wrong parameter number: %d\n&quot;,i));</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :   } else</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :     param = (*fParameters)(15,i) ;</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :   return param;</span>
<span class="lineNum">     674 </span>            : }
<a name="675"><span class="lineNum">     675 </span>            : </a>
<span class="lineNum">     676 </span>            : //____________________________________________________________________________
<span class="lineNum">     677 </span>            : Float_t  AliPHOSPIDv1::GetParameterTimeGate(Int_t i) const
<span class="lineNum">     678 </span>            : {
<span class="lineNum">     679 </span>            :   // Get TimeGate parameter depending on Purity-Efficiency i:
<span class="lineNum">     680 </span>            :   // i=0 - Low purity, i=1 - Medium purity, i=2 - High purity
<span class="lineNum">     681 </span>            :   Float_t param = 0.;
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :   if(i&gt;2 || i&lt;0) {</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :     AliError(Form(&quot;Invalid Efficiency-Purity choice %d&quot;,i));</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :   } else</span>
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :     param = (*fParameters)(3,i) ; </span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :   return param;</span>
<span class="lineNum">     687 </span>            : }
<a name="688"><span class="lineNum">     688 </span>            : </a>
<span class="lineNum">     689 </span>            : //_____________________________________________________________________________
<span class="lineNum">     690 </span>            : Float_t  AliPHOSPIDv1::GetParameterToCalculateEllipse(TString particle, TString param, Int_t i) const
<span class="lineNum">     691 </span>            : { 
<span class="lineNum">     692 </span>            :   // Get the parameter &quot;i&quot; that is needed to calculate the ellipse 
<span class="lineNum">     693 </span>            :   // parameter &quot;param&quot; for the particle &quot;particle&quot; (&quot;photon&quot; or &quot;pi0&quot;)
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span><span class="lineCov">       2400 :   particle.ToLower();</span>
<span class="lineNum">     696 </span><span class="lineCov">       1200 :   param.   ToLower();</span>
<span class="lineNum">     697 </span>            :   Int_t offset = -1;
<span class="lineNum">     698 </span><span class="lineCov">       1200 :   if      (particle == &quot;photon&quot;) </span>
<span class="lineNum">     699 </span><span class="lineCov">        600 :     offset=0;</span>
<span class="lineNum">     700 </span><span class="lineCov">        600 :   else if (particle == &quot;pi0&quot;)    </span>
<span class="lineNum">     701 </span><span class="lineCov">        600 :     offset=5;</span>
<span class="lineNum">     702 </span>            :   else
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :     AliError(Form(&quot;Wrong particle name: %s (choose from pi0/photon)\n&quot;,</span>
<span class="lineNum">     704 </span>            :                   particle.Data()));
<span class="lineNum">     705 </span>            : 
<span class="lineNum">     706 </span>            :   Int_t p= -1;
<span class="lineNum">     707 </span>            :   Float_t par = 0;
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span><span class="lineCov">       1440 :   if     (param.Contains(&quot;a&quot;)) p=4+offset; </span>
<span class="lineNum">     710 </span><span class="lineCov">       1200 :   else if(param.Contains(&quot;b&quot;)) p=5+offset; </span>
<span class="lineNum">     711 </span><span class="lineCov">        960 :   else if(param.Contains(&quot;c&quot;)) p=6+offset; </span>
<span class="lineNum">     712 </span><span class="lineCov">        720 :   else if(param.Contains(&quot;x0&quot;))p=7+offset; </span>
<span class="lineNum">     713 </span><span class="lineCov">        480 :   else if(param.Contains(&quot;y0&quot;))p=8+offset;</span>
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span><span class="lineCov">       1200 :   if      (i&gt;4 || i&lt;0) {</span>
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :     AliError(Form(&quot;No parameter with index %d&quot;, i)) ; </span>
<span class="lineNum">     717 </span><span class="lineCov">       1200 :   } else if (p==-1) {</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :     AliError(Form(&quot;No parameter with name %s&quot;, param.Data() )) ; </span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :   } else</span>
<span class="lineNum">     720 </span><span class="lineCov">       1200 :     par = (*fParameters)(p,i) ;</span>
<span class="lineNum">     721 </span>            :   
<span class="lineNum">     722 </span><span class="lineCov">       1200 :   return par;</span>
<a name="723"><span class="lineNum">     723 </span>            : }</a>
<span class="lineNum">     724 </span>            : //____________________________________________________________________________
<span class="lineNum">     725 </span>            : Int_t  AliPHOSPIDv1::GetCPVBit(AliPHOSTrackSegment * ts, Int_t effPur, Float_t e) const
<span class="lineNum">     726 </span>            : {
<span class="lineNum">     727 </span>            :   //Calculates the pid bit for the CPV selection per each purity.
<span class="lineNum">     728 </span><span class="lineCov">         60 :   if(effPur&gt;2 || effPur&lt;0)</span>
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :     AliError(Form(&quot;Invalid Efficiency-Purity choice %d&quot;,effPur));</span>
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span>            : //DP  if(ts-&gt;GetCpvIndex()&lt;0)
<span class="lineNum">     732 </span>            : //DP    return 1 ; //no CPV cluster
<span class="lineNum">     733 </span>            :   
<span class="lineNum">     734 </span><span class="lineCov">         60 :   Float_t sigX = GetCpv2EmcDistanceCut(&quot;X&quot;,e);</span>
<span class="lineNum">     735 </span><span class="lineCov">         60 :   Float_t sigZ = GetCpv2EmcDistanceCut(&quot;Z&quot;,e);</span>
<span class="lineNum">     736 </span>            :   
<span class="lineNum">     737 </span><span class="lineCov">         30 :   Float_t deltaX = TMath::Abs(ts-&gt;GetCpvDistance(&quot;X&quot;));</span>
<span class="lineNum">     738 </span><span class="lineCov">         30 :   Float_t deltaZ = TMath::Abs(ts-&gt;GetCpvDistance(&quot;Z&quot;));</span>
<span class="lineNum">     739 </span>            : //  Info(&quot;GetCPVBit&quot;,&quot; xdist %f, sigx %f, zdist %f, sigz %f&quot;,deltaX, sigX, deltaZ,sigZ) ;
<span class="lineNum">     740 </span>            :  
<span class="lineNum">     741 </span>            :   //if(deltaX&gt;sigX*(effPur+1))
<span class="lineNum">     742 </span>            :   //if((deltaX&gt;sigX*(effPur+1)) || (deltaZ&gt;sigZ*(effPur+1)))
<span class="lineNum">     743 </span><span class="lineCov">         50 :   if((deltaX&gt;sigX*(effPur+1)) &amp;&amp; (deltaZ&gt;sigZ*(effPur+1)))</span>
<span class="lineNum">     744 </span><span class="lineCov">         18 :     return 1;//Neutral</span>
<span class="lineNum">     745 </span>            :   else
<span class="lineNum">     746 </span><span class="lineCov">         12 :     return 0;//Charged</span>
<span class="lineNum">     747 </span><span class="lineCov">         30 : }</span>
<a name="748"><span class="lineNum">     748 </span>            : </a>
<span class="lineNum">     749 </span>            : //____________________________________________________________________________
<span class="lineNum">     750 </span>            : Int_t  AliPHOSPIDv1::GetPrincipalBit(TString particle, const Double_t* p, Int_t effPur, Float_t e)const
<span class="lineNum">     751 </span>            : {
<span class="lineNum">     752 </span>            :   //Is the particle inside de PCA ellipse?
<span class="lineNum">     753 </span>            :   
<span class="lineNum">     754 </span><span class="lineCov">        120 :   particle.ToLower();</span>
<span class="lineNum">     755 </span>            :   Int_t    prinbit  = 0 ;
<span class="lineNum">     756 </span><span class="lineCov">        180 :   Float_t a  = GetEllipseParameter(particle,&quot;a&quot; , e); </span>
<span class="lineNum">     757 </span><span class="lineCov">        180 :   Float_t b  = GetEllipseParameter(particle,&quot;b&quot; , e);</span>
<span class="lineNum">     758 </span><span class="lineCov">        180 :   Float_t c  = GetEllipseParameter(particle,&quot;c&quot; , e);</span>
<span class="lineNum">     759 </span><span class="lineCov">        180 :   Float_t x0 = GetEllipseParameter(particle,&quot;x0&quot;, e); </span>
<span class="lineNum">     760 </span><span class="lineCov">        180 :   Float_t y0 = GetEllipseParameter(particle,&quot;y0&quot;, e);</span>
<span class="lineNum">     761 </span>            :   
<span class="lineNum">     762 </span><span class="lineCov">        180 :   Float_t r = TMath::Power((p[0] - x0)/a,2) + </span>
<span class="lineNum">     763 </span><span class="lineCov">        120 :               TMath::Power((p[1] - y0)/b,2) +</span>
<span class="lineNum">     764 </span><span class="lineCov">         60 :             c*(p[0] -  x0)*(p[1] - y0)/(a*b) ;</span>
<span class="lineNum">     765 </span>            :   //3 different ellipses defined
<span class="lineNum">     766 </span><span class="lineCov">         88 :   if((effPur==2) &amp;&amp; (r&lt;1./2.)) prinbit= 1;</span>
<span class="lineNum">     767 </span><span class="lineCov">         90 :   if((effPur==1) &amp;&amp; (r&lt;2.   )) prinbit= 1;</span>
<span class="lineNum">     768 </span><span class="lineCov">         90 :   if((effPur==0) &amp;&amp; (r&lt;9./2.)) prinbit= 1;</span>
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span><span class="lineCov">         60 :   if(r&lt;0)</span>
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :     AliError(&quot;Negative square?&quot;) ;</span>
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span><span class="lineCov">         60 :   return prinbit;</span>
<span class="lineNum">     774 </span>            : 
<a name="775"><span class="lineNum">     775 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     776 </span>            : //____________________________________________________________________________
<span class="lineNum">     777 </span>            : Int_t  AliPHOSPIDv1::GetHardPhotonBit(AliPHOSEmcRecPoint * emc) const
<span class="lineNum">     778 </span>            : {
<span class="lineNum">     779 </span>            :   // Set bit for identified hard photons (E &gt; 30 GeV)
<span class="lineNum">     780 </span>            :   // if the second moment M2x is below the boundary
<span class="lineNum">     781 </span>            : 
<span class="lineNum">     782 </span><span class="lineCov">         20 :   Float_t e   = emc-&gt;GetEnergy();</span>
<span class="lineNum">     783 </span><span class="lineCov">         20 :   if (e &lt; 30.0) return 0;</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :   Float_t m2x = emc-&gt;GetM2x();</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :   Float_t m2xBoundary = GetParameterPhotonBoundary(0) *</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :     TMath::Exp(-TMath::Power(e-GetParameterPhotonBoundary(1),2)/2.0/</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :                 TMath::Power(GetParameterPhotonBoundary(2),2)) +</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :     GetParameterPhotonBoundary(3);</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :   AliDebug(1, Form(&quot;E=%f, m2x=%f, boundary=%f&quot;, e,m2x,m2xBoundary));</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :   if (m2x &lt; m2xBoundary)</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :     return 1;// A hard photon</span>
<span class="lineNum">     792 </span>            :   else
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :     return 0;// Not a hard photon</span>
<span class="lineNum">     794 </span><span class="lineCov">         10 : }</span>
<a name="795"><span class="lineNum">     795 </span>            : </a>
<span class="lineNum">     796 </span>            : //____________________________________________________________________________
<span class="lineNum">     797 </span>            : Int_t  AliPHOSPIDv1::GetHardPi0Bit(AliPHOSEmcRecPoint * emc) const
<span class="lineNum">     798 </span>            : {
<span class="lineNum">     799 </span>            :   // Set bit for identified hard pi0  (E &gt; 30 GeV)
<span class="lineNum">     800 </span>            :   // if the second moment M2x is above the boundary
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span><span class="lineCov">         20 :   Float_t e   = emc-&gt;GetEnergy();</span>
<span class="lineNum">     803 </span><span class="lineCov">         20 :   if (e &lt; 30.0) return 0;</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :   Float_t m2x = emc-&gt;GetM2x();</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :   Float_t m2xBoundary = GetParameterPi0Boundary(0) +</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :                     e * GetParameterPi0Boundary(1);</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :   AliDebug(1,Form(&quot;E=%f, m2x=%f, boundary=%f&quot;,e,m2x,m2xBoundary));</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :   if (m2x &gt; m2xBoundary)</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :     return 1;// A hard pi0</span>
<span class="lineNum">     810 </span>            :   else
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :     return 0;// Not a hard pi0</span>
<span class="lineNum">     812 </span><span class="lineCov">         10 : }</span>
<a name="813"><span class="lineNum">     813 </span>            : </a>
<span class="lineNum">     814 </span>            : //____________________________________________________________________________
<span class="lineNum">     815 </span>            : TVector3 AliPHOSPIDv1::GetMomentumDirection(AliPHOSEmcRecPoint * emc, AliPHOSCpvRecPoint * )const 
<span class="lineNum">     816 </span>            : { 
<span class="lineNum">     817 </span>            :   // Calculates the momentum direction:
<span class="lineNum">     818 </span>            :   //   1. if only a EMC RecPoint, direction is given by IP and this RecPoint
<span class="lineNum">     819 </span>            :   //   2. if a EMC RecPoint and CPV RecPoint, direction is given by the line through the 2 recpoints 
<span class="lineNum">     820 </span>            :   //  However because of the poor position resolution of PPSD the direction is always taken as if we were 
<span class="lineNum">     821 </span>            :   //  in case 1.
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span><span class="lineCov">         20 :   TVector3 local ; </span>
<span class="lineNum">     824 </span><span class="lineCov">         10 :   emc-&gt;GetLocalPosition(local) ;</span>
<span class="lineNum">     825 </span>            : 
<span class="lineNum">     826 </span><span class="lineCov">         10 :   AliPHOSGeometry * phosgeom = AliPHOSGeometry::GetInstance() ;</span>
<span class="lineNum">     827 </span>            :   //Correct for the non-perpendicular incidence
<span class="lineNum">     828 </span>            :   // Correction for the depth of the shower starting point (TDR p 127)
<span class="lineNum">     829 </span>            :   Float_t para = 0.925 ;
<span class="lineNum">     830 </span>            :   Float_t parb = 6.52 ;
<span class="lineNum">     831 </span>            :  
<span class="lineNum">     832 </span>            :   //Remove Old correction (vertex at 0,0,0)
<span class="lineNum">     833 </span><span class="lineCov">         10 :   TVector3 vtxOld(0.,0.,0.) ;</span>
<span class="lineNum">     834 </span><span class="lineCov">         10 :   TVector3 vInc ;</span>
<span class="lineNum">     835 </span><span class="lineCov">         10 :   Float_t x=local.X() ;</span>
<span class="lineNum">     836 </span><span class="lineCov">         10 :   Float_t z=local.Z() ;</span>
<span class="lineNum">     837 </span><span class="lineCov">         20 :   phosgeom-&gt;GetIncidentVector(vtxOld,emc-&gt;GetPHOSMod(),x,z,vInc) ;</span>
<span class="lineNum">     838 </span>            :   Float_t depthxOld = 0.;
<span class="lineNum">     839 </span>            :   Float_t depthzOld = 0.;
<span class="lineNum">     840 </span><span class="lineCov">         10 :   Float_t energy = emc-&gt;GetEnergy() ;</span>
<span class="lineNum">     841 </span><span class="lineCov">         20 :   if (energy &gt; 0 &amp;&amp; vInc.Y()!=0.) {</span>
<span class="lineNum">     842 </span><span class="lineCov">         10 :     depthxOld = ( para * TMath::Log(energy) + parb ) * vInc.X()/TMath::Abs(vInc.Y()) ;</span>
<span class="lineNum">     843 </span><span class="lineCov">         10 :     depthzOld = ( para * TMath::Log(energy) + parb ) * vInc.Z()/TMath::Abs(vInc.Y()) ;</span>
<span class="lineNum">     844 </span><span class="lineCov">         10 :   }</span>
<span class="lineNum">     845 </span>            :   else{
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :     AliError(&quot;Cluster with zero energy \n&quot;);</span>
<span class="lineNum">     847 </span>            :   }
<span class="lineNum">     848 </span>            :   //Apply Real vertex
<span class="lineNum">     849 </span><span class="lineCov">         20 :   phosgeom-&gt;GetIncidentVector(fVtx,emc-&gt;GetPHOSMod(),x,z,vInc) ;</span>
<span class="lineNum">     850 </span>            :   Float_t depthx = 0.;
<span class="lineNum">     851 </span>            :   Float_t depthz = 0.;
<span class="lineNum">     852 </span><span class="lineCov">         20 :   if (energy &gt; 0 &amp;&amp; vInc.Y()!=0.) {</span>
<span class="lineNum">     853 </span><span class="lineCov">         10 :     depthx = ( para * TMath::Log(energy) + parb ) * vInc.X()/TMath::Abs(vInc.Y()) ;</span>
<span class="lineNum">     854 </span><span class="lineCov">         10 :     depthz = ( para * TMath::Log(energy) + parb ) * vInc.Z()/TMath::Abs(vInc.Y()) ;</span>
<span class="lineNum">     855 </span><span class="lineCov">         10 :   }</span>
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span>            :   //Correct for the vertex position and shower depth
<span class="lineNum">     858 </span><span class="lineCov">         10 :   Double_t xd=x+(depthxOld-depthx) ;</span>
<span class="lineNum">     859 </span><span class="lineCov">         10 :   Double_t zd=z+(depthzOld-depthz) ; </span>
<span class="lineNum">     860 </span><span class="lineCov">         10 :   TVector3 dir(0,0,0) ; </span>
<span class="lineNum">     861 </span><span class="lineCov">         20 :   phosgeom-&gt;Local2Global(emc-&gt;GetPHOSMod(),xd,zd,dir) ;</span>
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span><span class="lineCov">         10 :   dir-=fVtx ;</span>
<span class="lineNum">     864 </span><span class="lineCov">         10 :   dir.SetMag(1.) ;</span>
<span class="lineNum">     865 </span>            : 
<span class="lineNum">     866 </span>            :   return dir ;  
<span class="lineNum">     867 </span><span class="lineCov">         20 : }</span>
<a name="868"><span class="lineNum">     868 </span>            : </a>
<span class="lineNum">     869 </span>            : //________________________________________________________________________
<span class="lineNum">     870 </span>            : Double_t  AliPHOSPIDv1::LandauF(Double_t  x, Double_t y, Double_t * par)
<span class="lineNum">     871 </span>            : {
<span class="lineNum">     872 </span>            :   //Given the energy x and the parameter y (tof, shower dispersion or cpv-emc distance), 
<span class="lineNum">     873 </span>            :   //this method returns a density probability of this parameter, given by a landau 
<span class="lineNum">     874 </span>            :   //function whose parameters depend with the energy  with a function: a/(x*x)+b/x+b
<span class="lineNum">     875 </span>            : 
<span class="lineNum">     876 </span><span class="lineCov">         30 :   if (x &gt; par[9]) x = par[9];</span>
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span>            :   //Double_t cnt    = par[1] / (x*x) + par[2] / x + par[0] ;
<span class="lineNum">     879 </span><span class="lineCov">         10 :   Double_t cnt    = par[0] + par[1] * x + par[2] * x * x ;</span>
<span class="lineNum">     880 </span><span class="lineCov">         10 :   Double_t mean   = par[4] / (x*x) + par[5] / x + par[3] ;</span>
<span class="lineNum">     881 </span><span class="lineCov">         10 :   Double_t sigma  = par[7] / (x*x) + par[8] / x + par[6] ;</span>
<span class="lineNum">     882 </span>            : 
<span class="lineNum">     883 </span><span class="lineCov">         10 :   if(TMath::Abs(sigma) &gt; 1.e-10){</span>
<span class="lineNum">     884 </span><span class="lineCov">         10 :     return cnt*TMath::Landau(y,mean,sigma);</span>
<span class="lineNum">     885 </span>            :   }
<span class="lineNum">     886 </span>            :   else
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :     return 0.;</span>
<span class="lineNum">     888 </span>            : 
<a name="889"><span class="lineNum">     889 </span><span class="lineCov">         10 : }</span></a>
<span class="lineNum">     890 </span>            : //________________________________________________________________________
<span class="lineNum">     891 </span>            : Double_t  AliPHOSPIDv1::LandauPol2(Double_t  x, Double_t y, Double_t * par)
<span class="lineNum">     892 </span>            : {
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span>            :   //Given the energy x and the parameter y (tof, shower dispersion or cpv-emc distance), 
<span class="lineNum">     895 </span>            :   //this method returns a density probability of this parameter, given by a landau 
<span class="lineNum">     896 </span>            :   //function whose parameters depend with the energy like second order polinomial
<span class="lineNum">     897 </span>            : 
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :   Double_t cnt    = par[2] * (x*x) + par[1] * x + par[0] ;</span>
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :   Double_t mean   = par[5] * (x*x) + par[4] * x + par[3] ;</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :   Double_t sigma  = par[8] * (x*x) + par[7] * x + par[6] ;</span>
<span class="lineNum">     901 </span>            : 
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :    if(TMath::Abs(sigma) &gt; 1.e-10){</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :     return cnt*TMath::Landau(y,mean,sigma);</span>
<span class="lineNum">     904 </span>            :   }
<span class="lineNum">     905 </span>            :   else
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :     return 0.;</span>
<span class="lineNum">     907 </span>            : 
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     910 </span>            : // //________________________________________________________________________
<span class="lineNum">     911 </span>            : // Double_t  AliPHOSPIDv1::ChargedHadronDistProb(Double_t  x, Double_t y, Double_t * parg, Double_t * parl)
<span class="lineNum">     912 </span>            : // {
<span class="lineNum">     913 </span>            : //   Double_t cnt   = 0.0 ;
<span class="lineNum">     914 </span>            : //   Double_t mean  = 0.0 ;
<span class="lineNum">     915 </span>            : //   Double_t sigma = 0.0 ;
<span class="lineNum">     916 </span>            : //   Double_t arg   = 0.0 ;
<span class="lineNum">     917 </span>            : //   if (y &lt; parl[4] / (x*x) + parl[5] / x + parl[3]){
<span class="lineNum">     918 </span>            : //     cnt    = parg[1] / (x*x) + parg[2] / x + parg[0] ;
<span class="lineNum">     919 </span>            : //     mean   = parg[4] / (x*x) + parg[5] / x + parg[3] ;
<span class="lineNum">     920 </span>            : //     sigma  = parg[7] / (x*x) + parg[8] / x + parg[6] ;
<span class="lineNum">     921 </span>            : //     TF1 * f = new TF1(&quot;gaus&quot;,&quot;gaus&quot;,0.,100.);
<span class="lineNum">     922 </span>            : //     f-&gt;SetParameters(cnt,mean,sigma);
<span class="lineNum">     923 </span>            : //     arg  = f-&gt;Eval(y) ;
<span class="lineNum">     924 </span>            : //   }
<span class="lineNum">     925 </span>            : //   else{
<span class="lineNum">     926 </span>            : //     cnt    = parl[1] / (x*x) + parl[2] / x + parl[0] ;
<span class="lineNum">     927 </span>            : //     mean   = parl[4] / (x*x) + parl[5] / x + parl[3] ;
<span class="lineNum">     928 </span>            : //     sigma  = parl[7] / (x*x) + parl[8] / x + parl[6] ;
<span class="lineNum">     929 </span>            : //     TF1 * f = new TF1(&quot;landau&quot;,&quot;landau&quot;,0.,100.);
<span class="lineNum">     930 </span>            : //     f-&gt;SetParameters(cnt,mean,sigma);
<span class="lineNum">     931 </span>            : //     arg  = f-&gt;Eval(y) ;
<span class="lineNum">     932 </span>            : //   }
<span class="lineNum">     933 </span>            : //   //  Double_t mean   = par[3] + par[4] * x + par[5] * x * x ;
<span class="lineNum">     934 </span>            : //   //   Double_t sigma  = par[6] + par[7] * x + par[8] * x * x ;
<span class="lineNum">     935 </span>            :   
<span class="lineNum">     936 </span>            : //   //Double_t arg    = -(y-mean)*(y-mean)/(2*sigma*sigma) ;
<span class="lineNum">     937 </span>            : //   //return cnt * TMath::Exp(arg) ;
<span class="lineNum">     938 </span>            :   
<span class="lineNum">     939 </span>            : //   return arg;
<span class="lineNum">     940 </span>            :   
<a name="941"><span class="lineNum">     941 </span>            : // }</a>
<span class="lineNum">     942 </span>            : //____________________________________________________________________________
<span class="lineNum">     943 </span>            : void  AliPHOSPIDv1::MakePID()
<span class="lineNum">     944 </span>            : {
<span class="lineNum">     945 </span>            :   // construct the PID weight from a Bayesian Method
<span class="lineNum">     946 </span>            :   
<span class="lineNum">     947 </span>            :   const Int_t kSPECIES = AliPID::kSPECIESCN ;
<span class="lineNum">     948 </span>            :  
<span class="lineNum">     949 </span><span class="lineCov">         16 :   Int_t nparticles = fRecParticles-&gt;GetEntriesFast() ;</span>
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span><span class="lineCov">         24 :   if ( !fEMCRecPoints || !fCPVRecPoints || !fTrackSegments ) {</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :     AliFatal(&quot;RecPoints or TrackSegments not found !&quot;) ;  </span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     954 </span>            : 
<span class="lineNum">     955 </span><span class="lineCov">          8 :   Double_t * stof[kSPECIES] ;</span>
<span class="lineNum">     956 </span><span class="lineCov">          8 :   Double_t * sdp [kSPECIES]  ;</span>
<span class="lineNum">     957 </span><span class="lineCov">          8 :   Double_t * scpv[kSPECIES] ;</span>
<span class="lineNum">     958 </span><span class="lineCov">          8 :   Double_t * sw  [kSPECIES] ;</span>
<span class="lineNum">     959 </span>            :   //Info(&quot;MakePID&quot;,&quot;Begin MakePID&quot;); 
<span class="lineNum">     960 </span>            :   
<span class="lineNum">     961 </span><span class="lineCov">        240 :           for (Int_t i =0; i&lt; kSPECIES; i++){</span>
<span class="lineNum">     962 </span><span class="lineCov">        112 :             stof[i] = new Double_t[nparticles] ;</span>
<span class="lineNum">     963 </span><span class="lineCov">        112 :     sdp [i] = new Double_t[nparticles] ;</span>
<span class="lineNum">     964 </span><span class="lineCov">        112 :     scpv[i] = new Double_t[nparticles] ;</span>
<span class="lineNum">     965 </span><span class="lineCov">        112 :     sw  [i] = new Double_t[nparticles] ;</span>
<span class="lineNum">     966 </span>            :   }
<span class="lineNum">     967 </span>            :   
<span class="lineNum">     968 </span><span class="lineCov">         36 :   for(Int_t index = 0 ; index &lt; nparticles ; index ++) {</span>
<span class="lineNum">     969 </span>            : 
<span class="lineNum">     970 </span><span class="lineCov">         10 :     AliPHOSTrackSegment * ts = (AliPHOSTrackSegment *)fTrackSegments-&gt;At(index);</span>
<span class="lineNum">     971 </span>            :     
<span class="lineNum">     972 </span>            :     //cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;&gt;&gt; Bayesian Index &quot;&lt;&lt;index&lt;&lt;endl;
<span class="lineNum">     973 </span><span class="lineCov">         10 :     if(ts-&gt;GetEmcIndex()&lt;0)</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :       continue ; //Do not analyze CPV TS</span>
<span class="lineNum">     975 </span>            : 
<span class="lineNum">     976 </span><span class="lineCov">         10 :     AliPHOSEmcRecPoint * emc = (AliPHOSEmcRecPoint *) fEMCRecPoints-&gt;At(ts-&gt;GetEmcIndex()) ;</span>
<span class="lineNum">     977 </span>            :     
<span class="lineNum">     978 </span>            : //    AliPHOSCpvRecPoint * cpv = 0 ;
<span class="lineNum">     979 </span>            : //    if(ts-&gt;GetCpvIndex()&gt;=0)
<span class="lineNum">     980 </span>            : //      cpv = (AliPHOSCpvRecPoint *) cpvRecPoints-&gt;At(ts-&gt;GetCpvIndex()) ;
<span class="lineNum">     981 </span>            : //    
<span class="lineNum">     982 </span>            : ////     Int_t track = 0 ; 
<span class="lineNum">     983 </span>            : ////     track = ts-&gt;GetTrackIndex() ; //TPC tracks ?
<span class="lineNum">     984 </span>            :     
<span class="lineNum">     985 </span><span class="lineCov">         10 :     if (!emc) {</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :       AliFatal(Form(&quot;-&gt; emc(%d)&quot;, ts-&gt;GetEmcIndex())) ;</span>
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     988 </span>            : 
<span class="lineNum">     989 </span>            : 
<span class="lineNum">     990 </span>            :     // ############Tof#############################
<span class="lineNum">     991 </span>            : 
<span class="lineNum">     992 </span>            :     //    Info(&quot;MakePID&quot;, &quot;TOF&quot;);
<span class="lineNum">     993 </span><span class="lineCov">         10 :     Float_t  en   = emc-&gt;GetEnergy();    </span>
<span class="lineNum">     994 </span><span class="lineCov">         10 :     Double_t time = emc-&gt;GetTime() ;</span>
<span class="lineNum">     995 </span>            :     //      cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Energy &quot;&lt;&lt;en&lt;&lt;&quot;Time &quot;&lt;&lt;time&lt;&lt;endl;
<span class="lineNum">     996 </span>            :    
<span class="lineNum">     997 </span>            :     // now get the signals probability
<span class="lineNum">     998 </span>            :     // s(pid) in the Bayesian formulation
<span class="lineNum">     999 </span>            : 
<span class="lineNum">    1000 </span>            :     //Initialize anused species
<span class="lineNum">    1001 </span><span class="lineCov">        300 :     for(Int_t iii=0; iii&lt;kSPECIES; iii++)stof[iii][index]=0. ;</span>
<span class="lineNum">    1002 </span>            :     
<span class="lineNum">    1003 </span><span class="lineCov">         10 :     stof[AliPID::kPhoton][index]   = 1.; </span>
<span class="lineNum">    1004 </span><span class="lineCov">         10 :     stof[AliPID::kElectron][index] = 1.;</span>
<span class="lineNum">    1005 </span><span class="lineCov">         10 :     stof[AliPID::kEleCon][index]   = 1.;</span>
<span class="lineNum">    1006 </span>            :     //We assing the same prob to charged hadrons, sum is 1
<span class="lineNum">    1007 </span><span class="lineCov">         10 :     stof[AliPID::kPion][index]     = 1./3.; </span>
<span class="lineNum">    1008 </span><span class="lineCov">         10 :     stof[AliPID::kKaon][index]     = 1./3.; </span>
<span class="lineNum">    1009 </span><span class="lineCov">         10 :     stof[AliPID::kProton][index]   = 1./3.;</span>
<span class="lineNum">    1010 </span>            :     //We assing the same prob to neutral hadrons, sum is 1
<span class="lineNum">    1011 </span><span class="lineCov">         10 :     stof[AliPID::kNeutron][index]  = 1./2.;</span>
<span class="lineNum">    1012 </span><span class="lineCov">         10 :     stof[AliPID::kKaon0][index]    = 1./2.;</span>
<span class="lineNum">    1013 </span><span class="lineCov">         10 :     stof[AliPID::kMuon][index]     = 1.; </span>
<span class="lineNum">    1014 </span>            :  
<span class="lineNum">    1015 </span><span class="lineCov">         10 :     if(en &lt;  fTOFEnThreshold) {</span>
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :       Double_t pTofPion = fTFpiong -&gt;Eval(time) ; //gaus distribution</span>
<span class="lineNum">    1018 </span>            :       Double_t pTofKaon = 0;
<span class="lineNum">    1019 </span>            : 
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :       if(time &lt; fTkaonl[1])</span>
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :         pTofKaon = fTFkaong  -&gt;Eval(time) ; //gaus distribution</span>
<span class="lineNum">    1022 </span>            :       else 
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :         pTofKaon = fTFkaonl  -&gt;Eval(time) ; //landau distribution</span>
<span class="lineNum">    1024 </span>            : 
<span class="lineNum">    1025 </span>            :       Double_t pTofNucleon = 0;
<span class="lineNum">    1026 </span>            : 
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :       if(time &lt; fThhadronl[1])</span>
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :         pTofNucleon = fTFhhadrong   -&gt;Eval(time) ; //gaus distribution</span>
<span class="lineNum">    1029 </span>            :       else
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :         pTofNucleon = fTFhhadronl   -&gt;Eval(time) ; //landau distribution</span>
<span class="lineNum">    1031 </span>            :       //We assing the same prob to neutral hadrons, sum is the average prob
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :       Double_t pTofNeHadron =  (pTofKaon + pTofNucleon)/2. ;</span>
<span class="lineNum">    1033 </span>            :       //We assing the same prob to charged hadrons, sum is the average prob
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :       Double_t pTofChHadron =  (pTofPion + pTofKaon + pTofNucleon)/3. ;</span>
<span class="lineNum">    1035 </span>            : 
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :       stof[AliPID::kPhoton][index]   = fTFphoton     -&gt;Eval(time) ; </span>
<span class="lineNum">    1037 </span>            :       //gaus distribution
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :       stof[AliPID::kEleCon][index]   = stof[AliPID::kPhoton][index] ; </span>
<span class="lineNum">    1039 </span>            :       //a conversion electron has the photon ToF
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :       stof[AliPID::kMuon][index]     = stof[AliPID::kPhoton][index] ;</span>
<span class="lineNum">    1041 </span>            :  
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :       stof[AliPID::kElectron][index] = pTofPion  ;                             </span>
<span class="lineNum">    1043 </span>            : 
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :       stof[AliPID::kPion][index]     =  pTofChHadron ; </span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :       stof[AliPID::kKaon][index]     =  pTofChHadron ;</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :       stof[AliPID::kProton][index]   =  pTofChHadron ;</span>
<span class="lineNum">    1047 </span>            : 
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :       stof[AliPID::kKaon0][index]    =  pTofNeHadron ;     </span>
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :       stof[AliPID::kNeutron][index]  =  pTofNeHadron ;            </span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :     } </span>
<span class="lineNum">    1051 </span>            :     
<span class="lineNum">    1052 </span>            :     //    Info(&quot;MakePID&quot;, &quot;Dispersion&quot;);
<span class="lineNum">    1053 </span>            :     
<span class="lineNum">    1054 </span>            :     // ###########Shower shape: Dispersion####################
<span class="lineNum">    1055 </span><span class="lineCov">         10 :     Float_t dispersion = emc-&gt;GetDispersion();</span>
<span class="lineNum">    1056 </span>            :     //DP: Correct for non-perpendicular incidence
<span class="lineNum">    1057 </span>            :     //DP: still to be done 
<span class="lineNum">    1058 </span>            : 
<span class="lineNum">    1059 </span>            :     //dispersion is not well defined if the cluster is only in few crystals
<span class="lineNum">    1060 </span>            :     //Initialize anused species
<span class="lineNum">    1061 </span><span class="lineCov">        300 :     for(Int_t iii=0; iii&lt;kSPECIES; iii++)sdp[iii][index]=0. ;</span>
<span class="lineNum">    1062 </span>            :     
<span class="lineNum">    1063 </span><span class="lineCov">         10 :     sdp[AliPID::kPhoton][index]   = 1. ;</span>
<span class="lineNum">    1064 </span><span class="lineCov">         10 :     sdp[AliPID::kElectron][index] = 1. ;</span>
<span class="lineNum">    1065 </span><span class="lineCov">         10 :     sdp[AliPID::kPion][index]     = 1. ; </span>
<span class="lineNum">    1066 </span><span class="lineCov">         10 :     sdp[AliPID::kKaon][index]     = 1. ; </span>
<span class="lineNum">    1067 </span><span class="lineCov">         10 :     sdp[AliPID::kProton][index]   = 1. ;</span>
<span class="lineNum">    1068 </span><span class="lineCov">         10 :     sdp[AliPID::kNeutron][index]  = 1. ;</span>
<span class="lineNum">    1069 </span><span class="lineCov">         10 :     sdp[AliPID::kEleCon][index]   = 1. ; </span>
<span class="lineNum">    1070 </span><span class="lineCov">         10 :     sdp[AliPID::kKaon0][index]    = 1. ; </span>
<span class="lineNum">    1071 </span><span class="lineCov">         10 :     sdp[AliPID::kMuon][index]     = 1. ; </span>
<span class="lineNum">    1072 </span>            :     
<span class="lineNum">    1073 </span><span class="lineCov">         20 :     if(en &gt; fDispEnThreshold &amp;&amp; emc-&gt;GetMultiplicity() &gt;  fDispMultThreshold){</span>
<span class="lineNum">    1074 </span><span class="lineCov">         10 :       sdp[AliPID::kPhoton][index]   = GausF(en , dispersion, fDphoton) ;</span>
<span class="lineNum">    1075 </span><span class="lineCov">         10 :       sdp[AliPID::kElectron][index] = sdp[AliPID::kPhoton][index] ;</span>
<span class="lineNum">    1076 </span><span class="lineCov">         10 :       sdp[AliPID::kPion][index]     = LandauF(en , dispersion, fDhadron ) ; </span>
<span class="lineNum">    1077 </span><span class="lineCov">         10 :       sdp[AliPID::kKaon][index]     = sdp[AliPID::kPion][index]  ; </span>
<span class="lineNum">    1078 </span><span class="lineCov">         10 :       sdp[AliPID::kProton][index]   = sdp[AliPID::kPion][index]  ;</span>
<span class="lineNum">    1079 </span><span class="lineCov">         10 :       sdp[AliPID::kNeutron][index]  = sdp[AliPID::kPion][index]  ;</span>
<span class="lineNum">    1080 </span><span class="lineCov">         10 :       sdp[AliPID::kEleCon][index]   = sdp[AliPID::kPhoton][index]; </span>
<span class="lineNum">    1081 </span><span class="lineCov">         10 :       sdp[AliPID::kKaon0][index]    = sdp[AliPID::kPion][index]  ; </span>
<span class="lineNum">    1082 </span><span class="lineCov">         10 :       sdp[AliPID::kMuon][index]     = fDFmuon -&gt;Eval(dispersion) ; </span>
<span class="lineNum">    1083 </span>            :       //landau distribution
<span class="lineNum">    1084 </span><span class="lineCov">         10 :     }</span>
<span class="lineNum">    1085 </span>            :     
<span class="lineNum">    1086 </span>            : //      Info(&quot;MakePID&quot;,&quot;multiplicity %d, dispersion %f&quot;, emc-&gt;GetMultiplicity(), dispersion);
<span class="lineNum">    1087 </span>            : //      Info(&quot;MakePID&quot;,&quot;ss: photon %f, hadron %f &quot;,  sdp[AliPID::kPhoton][index],  sdp[AliPID::kPion][index]);
<span class="lineNum">    1088 </span>            : //       cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;&gt;multiplicity &quot;&lt;&lt;emc-&gt;GetMultiplicity()&lt;&lt;&quot;, dispersion &quot;&lt;&lt; dispersion&lt;&lt;endl ;
<span class="lineNum">    1089 </span>            : //       cout&lt;&lt;&quot;&lt;&lt;&lt;&lt;&lt;ss: photon   &quot;&lt;&lt;sdp[AliPID::kPhoton][index]&lt;&lt;&quot;, hadron    &quot;&lt;&lt;sdp[AliPID::kPion][index]&lt;&lt;endl;
<span class="lineNum">    1090 </span>            : 
<span class="lineNum">    1091 </span>            :     //########## CPV-EMC  Distance#######################
<span class="lineNum">    1092 </span>            :     //     Info(&quot;MakePID&quot;, &quot;Distance&quot;);
<span class="lineNum">    1093 </span>            : 
<span class="lineNum">    1094 </span><span class="lineCov">         10 :     Float_t x             = TMath::Abs(ts-&gt;GetCpvDistance(&quot;X&quot;)) ;</span>
<span class="lineNum">    1095 </span><span class="lineCov">         10 :     Float_t z             = ts-&gt;GetCpvDistance(&quot;Z&quot;) ;</span>
<span class="lineNum">    1096 </span>            :    
<span class="lineNum">    1097 </span>            :     Double_t pcpv         = 0 ;
<span class="lineNum">    1098 </span>            :     Double_t pcpvneutral  = 0. ;
<span class="lineNum">    1099 </span>            :    
<span class="lineNum">    1100 </span><span class="lineCov">         10 :     Double_t elprobx      = GausF(en , x, fXelectron) ;</span>
<span class="lineNum">    1101 </span><span class="lineCov">         10 :     Double_t elprobz      = GausF(en , z, fZelectron) ;</span>
<span class="lineNum">    1102 </span><span class="lineCov">         10 :     Double_t chprobx      = GausF(en , x, fXcharged)  ;</span>
<span class="lineNum">    1103 </span><span class="lineCov">         10 :     Double_t chprobz      = GausF(en , z, fZcharged)  ;</span>
<span class="lineNum">    1104 </span><span class="lineCov">         10 :     Double_t pcpvelectron = elprobx * elprobz;</span>
<span class="lineNum">    1105 </span><span class="lineCov">         10 :     Double_t pcpvcharged  = chprobx * chprobz;</span>
<span class="lineNum">    1106 </span>            :   
<span class="lineNum">    1107 </span>            : //     cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;energy &quot;&lt;&lt;en&lt;&lt;endl;
<span class="lineNum">    1108 </span>            : //     cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;electron : x &quot;&lt;&lt;x&lt;&lt;&quot; xprob &quot;&lt;&lt;elprobx&lt;&lt;&quot; z &quot;&lt;&lt;z&lt;&lt;&quot; zprob &quot;&lt;&lt;elprobz&lt;&lt;endl;
<span class="lineNum">    1109 </span>            : //     cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;hadron   : x &quot;&lt;&lt;x&lt;&lt;&quot; xprob &quot;&lt;&lt;chprobx&lt;&lt;&quot; z &quot;&lt;&lt;z&lt;&lt;&quot; zprob &quot;&lt;&lt;chprobz&lt;&lt;endl;
<span class="lineNum">    1110 </span>            : //     cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;electron : px*pz &quot;&lt;&lt;pcpvelectron &lt;&lt;&quot; hadron: px*pz &quot;&lt;&lt;pcpvcharged&lt;&lt;endl;  
<span class="lineNum">    1111 </span>            : 
<span class="lineNum">    1112 </span>            :     // Is neutral or charged?
<span class="lineNum">    1113 </span><span class="lineCov">         10 :     if(pcpvelectron &gt;= pcpvcharged)  </span>
<span class="lineNum">    1114 </span><span class="lineCov">          8 :       pcpv = pcpvelectron ;</span>
<span class="lineNum">    1115 </span>            :     else
<span class="lineNum">    1116 </span>            :       pcpv = pcpvcharged ;
<span class="lineNum">    1117 </span>            :     
<span class="lineNum">    1118 </span><span class="lineCov">         10 :     if(pcpv &lt; fChargedNeutralThreshold)</span>
<span class="lineNum">    1119 </span>            :       {
<span class="lineNum">    1120 </span>            :         pcpvneutral  = 1. ;
<span class="lineNum">    1121 </span>            :         pcpvcharged  = 0. ;
<span class="lineNum">    1122 </span>            :         pcpvelectron = 0. ;
<span class="lineNum">    1123 </span><span class="lineCov">          6 :       }</span>
<span class="lineNum">    1124 </span>            :     //    else
<span class="lineNum">    1125 </span>            :     //      cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;CHARGED&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;&lt;&lt;endl;
<span class="lineNum">    1126 </span>            :     //Initialize anused species
<span class="lineNum">    1127 </span><span class="lineCov">        300 :     for(Int_t iii=0; iii&lt;kSPECIES; iii++)scpv[iii][index]=0. ;</span>
<span class="lineNum">    1128 </span>            :     
<span class="lineNum">    1129 </span><span class="lineCov">         10 :     scpv[AliPID::kPion][index]     =  pcpvcharged  ; </span>
<span class="lineNum">    1130 </span><span class="lineCov">         10 :     scpv[AliPID::kKaon][index]     =  pcpvcharged  ; </span>
<span class="lineNum">    1131 </span><span class="lineCov">         10 :     scpv[AliPID::kProton][index]   =  pcpvcharged  ;</span>
<span class="lineNum">    1132 </span>            : 
<span class="lineNum">    1133 </span><span class="lineCov">         10 :     scpv[AliPID::kMuon][index]     =  pcpvelectron ; </span>
<span class="lineNum">    1134 </span><span class="lineCov">         10 :     scpv[AliPID::kElectron][index] =  pcpvelectron ;</span>
<span class="lineNum">    1135 </span><span class="lineCov">         10 :     scpv[AliPID::kEleCon][index]   =  pcpvelectron ; </span>
<span class="lineNum">    1136 </span>            : 
<span class="lineNum">    1137 </span><span class="lineCov">         10 :     scpv[AliPID::kPhoton][index]   =  pcpvneutral  ;</span>
<span class="lineNum">    1138 </span><span class="lineCov">         10 :     scpv[AliPID::kNeutron][index]  =  pcpvneutral  ; </span>
<span class="lineNum">    1139 </span><span class="lineCov">         10 :     scpv[AliPID::kKaon0][index]    =  pcpvneutral  ; </span>
<span class="lineNum">    1140 </span>            : 
<span class="lineNum">    1141 </span>            :     
<span class="lineNum">    1142 </span>            :     //   Info(&quot;MakePID&quot;, &quot;CPV passed&quot;);
<span class="lineNum">    1143 </span>            : 
<span class="lineNum">    1144 </span>            :     //############## Pi0 #############################
<span class="lineNum">    1145 </span><span class="lineCov">         10 :     stof[AliPID::kPi0][index]      = 0. ;  </span>
<span class="lineNum">    1146 </span><span class="lineCov">         10 :     scpv[AliPID::kPi0][index]      = 0. ;</span>
<span class="lineNum">    1147 </span><span class="lineCov">         10 :     sdp [AliPID::kPi0][index]      = 0. ;</span>
<span class="lineNum">    1148 </span>            : 
<span class="lineNum">    1149 </span><span class="lineCov">         10 :     if(en &gt; 30.){</span>
<span class="lineNum">    1150 </span>            :       // pi0 are detected via decay photon
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :       stof[AliPID::kPi0][index]  =   stof[AliPID::kPhoton][index];</span>
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :       scpv[AliPID::kPi0][index]  = pcpvneutral  ;</span>
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :       if(emc-&gt;GetMultiplicity() &gt;  fDispMultThreshold)</span>
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :         sdp [AliPID::kPi0][index]  = GausF(en , dispersion, fDpi0) ;</span>
<span class="lineNum">    1155 </span>            :         //sdp [AliPID::kPi0][index]  = GausPol2(en , dispersion, fDpi0) ;
<span class="lineNum">    1156 </span>            : //       cout&lt;&lt;&quot;E = &quot;&lt;&lt;en&lt;&lt;&quot; GeV; disp = &quot;&lt;&lt;dispersion&lt;&lt;&quot;; mult = &quot;
<span class="lineNum">    1157 </span>            : //        &lt;&lt;emc-&gt;GetMultiplicity()&lt;&lt;endl;
<span class="lineNum">    1158 </span>            : //       cout&lt;&lt;&quot;PDF: photon = &quot;&lt;&lt;sdp [AliPID::kPhoton][index]&lt;&lt;&quot;; pi0 = &quot;
<span class="lineNum">    1159 </span>            : //        &lt;&lt;sdp [AliPID::kPi0][index]&lt;&lt;endl;
<span class="lineNum">    1160 </span>            :     }
<span class="lineNum">    1161 </span>            :     
<span class="lineNum">    1162 </span>            :   
<span class="lineNum">    1163 </span>            : 
<span class="lineNum">    1164 </span>            :     
<span class="lineNum">    1165 </span>            :     //############## muon #############################
<span class="lineNum">    1166 </span>            : 
<span class="lineNum">    1167 </span><span class="lineCov">         10 :     if(en &gt; 0.5){</span>
<span class="lineNum">    1168 </span>            :       //Muons deposit few energy
<span class="lineNum">    1169 </span><span class="lineCov">         10 :       scpv[AliPID::kMuon][index]     =  0 ;</span>
<span class="lineNum">    1170 </span><span class="lineCov">         10 :       stof[AliPID::kMuon][index]     =  0 ;</span>
<span class="lineNum">    1171 </span><span class="lineCov">         10 :       sdp [AliPID::kMuon][index]     =  0 ;</span>
<span class="lineNum">    1172 </span><span class="lineCov">         10 :     }</span>
<span class="lineNum">    1173 </span>            : 
<span class="lineNum">    1174 </span>            :     //Weight to apply to hadrons due to energy reconstruction
<span class="lineNum">    1175 </span>            :     //Initialize anused species
<span class="lineNum">    1176 </span><span class="lineCov">        300 :     for(Int_t iii=0; iii&lt;kSPECIES; iii++)sw[iii][index]=1. ;</span>
<span class="lineNum">    1177 </span>            : 
<span class="lineNum">    1178 </span><span class="lineCov">         10 :     Float_t weight = fERecWeight -&gt;Eval(en) ;</span>
<span class="lineNum">    1179 </span>            :  
<span class="lineNum">    1180 </span><span class="lineCov">         10 :     sw[AliPID::kPhoton][index]   = 1. ;</span>
<span class="lineNum">    1181 </span><span class="lineCov">         10 :     sw[AliPID::kElectron][index] = 1. ;</span>
<span class="lineNum">    1182 </span><span class="lineCov">         10 :     sw[AliPID::kPion][index]     = weight ; </span>
<span class="lineNum">    1183 </span><span class="lineCov">         10 :     sw[AliPID::kKaon][index]     = weight ; </span>
<span class="lineNum">    1184 </span><span class="lineCov">         10 :     sw[AliPID::kProton][index]   = weight ;</span>
<span class="lineNum">    1185 </span><span class="lineCov">         10 :     sw[AliPID::kNeutron][index]  = weight ;</span>
<span class="lineNum">    1186 </span><span class="lineCov">         10 :     sw[AliPID::kEleCon][index]   = 1. ; </span>
<span class="lineNum">    1187 </span><span class="lineCov">         10 :     sw[AliPID::kKaon0][index]    = weight ; </span>
<span class="lineNum">    1188 </span><span class="lineCov">         10 :     sw[AliPID::kMuon][index]     = weight ; </span>
<span class="lineNum">    1189 </span><span class="lineCov">         10 :     sw[AliPID::kPi0][index]      = 1. ;</span>
<span class="lineNum">    1190 </span>            : 
<span class="lineNum">    1191 </span>            : //     if(en &gt; 0.5){
<span class="lineNum">    1192 </span>            : //       cout&lt;&lt;&quot;######################################################&quot;&lt;&lt;endl;
<span class="lineNum">    1193 </span>            : //       //cout&lt;&lt;&quot;MakePID: energy &quot;&lt;&lt;en&lt;&lt;&quot;, tof &quot;&lt;&lt;time&lt;&lt;&quot;, distance &quot;&lt;&lt;distance&lt;&lt;&quot;, dispersion &quot;&lt;&lt;dispersion&lt;&lt;endl ;
<span class="lineNum">    1194 </span>            : //       cout&lt;&lt;&quot;MakePID: energy &quot;&lt;&lt;en&lt;&lt;&quot;, tof &quot;&lt;&lt;time&lt;&lt;&quot;, dispersion &quot;&lt;&lt;dispersion&lt;&lt;&quot;, x &quot;&lt;&lt;x&lt;&lt;&quot;, z &quot;&lt;&lt;z&lt;&lt;endl ;
<span class="lineNum">    1195 </span>            : //       cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;&gt;multiplicity &quot;&lt;&lt;emc-&gt;GetMultiplicity()&lt;&lt;endl;
<span class="lineNum">    1196 </span>            : //       cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;electron : xprob &quot;&lt;&lt;elprobx&lt;&lt;&quot; zprob &quot;&lt;&lt;elprobz&lt;&lt;endl;
<span class="lineNum">    1197 </span>            : //       cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;hadron   : xprob &quot;&lt;&lt;chprobx&lt;&lt;&quot; zprob &quot;&lt;&lt;chprobz&lt;&lt;endl;
<span class="lineNum">    1198 </span>            : //       cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;electron : px*pz &quot;&lt;&lt;pcpvelectron &lt;&lt;&quot; hadron: px*pz &quot;&lt;&lt;pcpvcharged&lt;&lt;endl;  
<span class="lineNum">    1199 </span>            :       
<span class="lineNum">    1200 </span>            : //        cout&lt;&lt;&quot;Photon   , pid &quot;&lt;&lt; fInitPID[AliPID::kPhoton]&lt;&lt;&quot; tof &quot;&lt;&lt;stof[AliPID::kPhoton][index]
<span class="lineNum">    1201 </span>            : //        &lt;&lt;&quot;, cpv &quot;&lt;&lt;scpv[AliPID::kPhoton][index]&lt;&lt;&quot;, ss &quot;&lt;&lt;sdp[AliPID::kPhoton][index]&lt;&lt;endl;
<span class="lineNum">    1202 </span>            : //       cout&lt;&lt;&quot;EleCon   , pid &quot;&lt;&lt; fInitPID[AliPID::kEleCon]&lt;&lt;&quot;, tof &quot;&lt;&lt;stof[AliPID::kEleCon][index]
<span class="lineNum">    1203 </span>            : //        &lt;&lt;&quot;, cpv &quot;&lt;&lt;scpv[AliPID::kEleCon][index]&lt;&lt;&quot; ss &quot;&lt;&lt;sdp[AliPID::kEleCon][index]&lt;&lt;endl;
<span class="lineNum">    1204 </span>            : //       cout&lt;&lt;&quot;Electron , pid &quot;&lt;&lt; fInitPID[AliPID::kElectron]&lt;&lt;&quot;, tof &quot;&lt;&lt;stof[AliPID::kElectron][index]
<span class="lineNum">    1205 </span>            : //        &lt;&lt;&quot;, cpv &quot;&lt;&lt;scpv[AliPID::kElectron][index]&lt;&lt;&quot; ss &quot;&lt;&lt;sdp[AliPID::kElectron][index]&lt;&lt;endl;
<span class="lineNum">    1206 </span>            : //       cout&lt;&lt;&quot;Muon     , pid &quot;&lt;&lt; fInitPID[AliPID::kMuon]&lt;&lt;&quot;, tof &quot;&lt;&lt;stof[AliPID::kMuon][index]
<span class="lineNum">    1207 </span>            : //        &lt;&lt;&quot;, cpv &quot;&lt;&lt;scpv[AliPID::kMuon][index]&lt;&lt;&quot; ss &quot;&lt;&lt;sdp[AliPID::kMuon][index]&lt;&lt;endl;
<span class="lineNum">    1208 </span>            : //        cout&lt;&lt;&quot;Pi0      , pid &quot;&lt;&lt; fInitPID[AliPID::kPi0]&lt;&lt;&quot;, tof &quot;&lt;&lt;stof[AliPID::kPi0][index]
<span class="lineNum">    1209 </span>            : //        &lt;&lt;&quot;, cpv &quot;&lt;&lt;scpv[AliPID::kPi0][index]&lt;&lt;&quot; ss &quot;&lt;&lt;sdp[AliPID::kPi0][index]&lt;&lt;endl;
<span class="lineNum">    1210 </span>            : //       cout&lt;&lt;&quot;Pion     , pid &quot;&lt;&lt; fInitPID[AliPID::kPion]&lt;&lt;&quot;, tof &quot;&lt;&lt;stof[AliPID::kPion][index]
<span class="lineNum">    1211 </span>            : //        &lt;&lt;&quot;, cpv &quot;&lt;&lt;scpv[AliPID::kPion][index]&lt;&lt;&quot; ss &quot;&lt;&lt;sdp[AliPID::kPion][index]&lt;&lt;endl;
<span class="lineNum">    1212 </span>            : //       cout&lt;&lt;&quot;Kaon0    , pid &quot;&lt;&lt; fInitPID[AliPID::kKaon0]&lt;&lt;&quot;, tof &quot;&lt;&lt;stof[AliPID::kKaon0][index]
<span class="lineNum">    1213 </span>            : //        &lt;&lt;&quot;, cpv &quot;&lt;&lt;scpv[AliPID::kKaon0][index]&lt;&lt;&quot; ss &quot;&lt;&lt;sdp[AliPID::kKaon0][index]&lt;&lt;endl;
<span class="lineNum">    1214 </span>            : //       cout&lt;&lt;&quot;Kaon     , pid &quot;&lt;&lt; fInitPID[AliPID::kKaon]&lt;&lt;&quot;, tof &quot;&lt;&lt;stof[AliPID::kKaon][index]
<span class="lineNum">    1215 </span>            : //        &lt;&lt;&quot;, cpv &quot;&lt;&lt;scpv[AliPID::kKaon][index]&lt;&lt;&quot; ss &quot;&lt;&lt;sdp[AliPID::kKaon][index]&lt;&lt;endl;
<span class="lineNum">    1216 </span>            : //       cout&lt;&lt;&quot;Neutron  , pid &quot;&lt;&lt; fInitPID[AliPID::kNeutron]&lt;&lt;&quot;, tof &quot;&lt;&lt;stof[AliPID::kNeutron][index]
<span class="lineNum">    1217 </span>            : //        &lt;&lt;&quot;, cpv &quot;&lt;&lt;scpv[AliPID::kNeutron][index]&lt;&lt;&quot; ss &quot;&lt;&lt;sdp[AliPID::kNeutron][index]&lt;&lt;endl;
<span class="lineNum">    1218 </span>            : //       cout&lt;&lt;&quot;Proton   , pid &quot;&lt;&lt; fInitPID[AliPID::kProton]&lt;&lt;&quot;, tof &quot;&lt;&lt;stof[AliPID::kProton][index]
<span class="lineNum">    1219 </span>            : //        &lt;&lt;&quot;, cpv &quot;&lt;&lt;scpv[AliPID::kProton][index]&lt;&lt;&quot; ss &quot;&lt;&lt;sdp[AliPID::kProton][index]&lt;&lt;endl;
<span class="lineNum">    1220 </span>            : //       cout&lt;&lt;&quot;######################################################&quot;&lt;&lt;endl;
<span class="lineNum">    1221 </span>            : //     }
<span class="lineNum">    1222 </span><span class="lineCov">         10 :   }</span>
<span class="lineNum">    1223 </span>            :   
<span class="lineNum">    1224 </span>            :   
<span class="lineNum">    1225 </span><span class="lineCov">         36 :   for(Int_t index = 0 ; index &lt; nparticles ; index ++) {</span>
<span class="lineNum">    1226 </span>            :     
<span class="lineNum">    1227 </span><span class="lineCov">         10 :     AliPHOSRecParticle * recpar = static_cast&lt;AliPHOSRecParticle *&gt;(fRecParticles-&gt;At(index));</span>
<span class="lineNum">    1228 </span>            :     
<span class="lineNum">    1229 </span>            :     //Conversion electron?
<span class="lineNum">    1230 </span>            :     
<span class="lineNum">    1231 </span><span class="lineCov">         30 :     if(recpar-&gt;IsEleCon()){</span>
<span class="lineNum">    1232 </span><span class="lineCov">         10 :       fInitPID[AliPID::kEleCon]   = 1. ;</span>
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :       fInitPID[AliPID::kPhoton]   = 0. ;</span>
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :       fInitPID[AliPID::kElectron] = 0. ;</span>
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1236 </span>            :     else{
<span class="lineNum">    1237 </span><span class="lineCov">         10 :       fInitPID[AliPID::kEleCon]   = 0. ;</span>
<span class="lineNum">    1238 </span><span class="lineCov">         10 :       fInitPID[AliPID::kPhoton]   = 1. ;</span>
<span class="lineNum">    1239 </span><span class="lineCov">         10 :       fInitPID[AliPID::kElectron] = 1. ;</span>
<span class="lineNum">    1240 </span>            :     }
<span class="lineNum">    1241 </span>            :     //  fInitPID[AliPID::kEleCon]   = 0. ;
<span class="lineNum">    1242 </span>            :     
<span class="lineNum">    1243 </span>            :     
<span class="lineNum">    1244 </span>            :     // calculates the Bayesian weight
<span class="lineNum">    1245 </span>            :     
<span class="lineNum">    1246 </span>            :     Int_t jndex ;
<span class="lineNum">    1247 </span>            :     Double_t wn = 0.0 ; 
<span class="lineNum">    1248 </span><span class="lineCov">        300 :     for (jndex = 0 ; jndex &lt; kSPECIES ; jndex++) </span>
<span class="lineNum">    1249 </span><span class="lineCov">        420 :       wn += stof[jndex][index] * sdp[jndex][index]  * scpv[jndex][index] * </span>
<span class="lineNum">    1250 </span><span class="lineCov">        280 :         sw[jndex][index] * fInitPID[jndex] ;</span>
<span class="lineNum">    1251 </span>            :     
<span class="lineNum">    1252 </span>            :     //    cout&lt;&lt;&quot;*************wn &quot;&lt;&lt;wn&lt;&lt;endl;
<span class="lineNum">    1253 </span><span class="lineCov">         10 :     if (TMath::Abs(wn)&gt;0)</span>
<span class="lineNum">    1254 </span><span class="lineCov">        300 :       for (jndex = 0 ; jndex &lt; kSPECIES ; jndex++) {</span>
<span class="lineNum">    1255 </span>            :         //cout&lt;&lt;&quot;jndex &quot;&lt;&lt;jndex&lt;&lt;&quot; wn &quot;&lt;&lt;wn&lt;&lt;&quot; SetPID * wn&quot;
<span class="lineNum">    1256 </span>            :         //&lt;&lt;stof[jndex][index] * sdp[jndex][index] * pid[jndex]  &lt;&lt; endl;
<span class="lineNum">    1257 </span>            :         //cout&lt;&lt;&quot; tof &quot;&lt;&lt;stof[jndex][index] &lt;&lt; &quot; disp &quot; &lt;&lt;sdp[jndex][index] &lt;&lt; &quot; pid &quot;&lt;&lt; fInitPID[jndex] &lt;&lt; endl;
<span class="lineNum">    1258 </span>            :         //      if(jndex ==  AliPID::kPi0 || jndex ==  AliPID::kPhoton){
<span class="lineNum">    1259 </span>            :         //        cout&lt;&lt;&quot;Particle &quot;&lt;&lt;jndex&lt;&lt;&quot;  final prob * wn   &quot;
<span class="lineNum">    1260 </span>            :         //            &lt;&lt;stof[jndex][index] * sdp[jndex][index] * scpv[jndex][index] * 
<span class="lineNum">    1261 </span>            :         //          fInitPID[jndex] &lt;&lt;&quot;  wn  &quot;&lt;&lt; wn&lt;&lt;endl;
<span class="lineNum">    1262 </span>            :         //        cout&lt;&lt;&quot;pid &quot;&lt;&lt; fInitPID[jndex]&lt;&lt;&quot;, tof &quot;&lt;&lt;stof[jndex][index]
<span class="lineNum">    1263 </span>            :         //            &lt;&lt;&quot;, cpv &quot;&lt;&lt;scpv[jndex][index]&lt;&lt;&quot; ss &quot;&lt;&lt;sdp[jndex][index]&lt;&lt;endl;
<span class="lineNum">    1264 </span>            :         //      }
<span class="lineNum">    1265 </span><span class="lineCov">        420 :         recpar-&gt;SetPID(jndex, stof[jndex][index] * sdp[jndex][index] * </span>
<span class="lineNum">    1266 </span><span class="lineCov">        420 :                        sw[jndex][index] * scpv[jndex][index] * </span>
<span class="lineNum">    1267 </span><span class="lineCov">        280 :                        fInitPID[jndex] / wn) ; </span>
<span class="lineNum">    1268 </span>            :       }
<span class="lineNum">    1269 </span>            :   }
<span class="lineNum">    1270 </span>            :   //  Info(&quot;MakePID&quot;, &quot;Delete&quot;);
<span class="lineNum">    1271 </span>            :   
<span class="lineNum">    1272 </span><span class="lineCov">        240 :   for (Int_t i =0; i&lt; kSPECIES; i++){</span>
<span class="lineNum">    1273 </span><span class="lineCov">        224 :     delete [] stof[i];</span>
<span class="lineNum">    1274 </span><span class="lineCov">        224 :     delete [] sdp [i];</span>
<span class="lineNum">    1275 </span><span class="lineCov">        224 :     delete [] scpv[i];</span>
<span class="lineNum">    1276 </span><span class="lineCov">        224 :     delete [] sw  [i];</span>
<span class="lineNum">    1277 </span>            :   }
<span class="lineNum">    1278 </span>            :   //  Info(&quot;MakePID&quot;,&quot;End MakePID&quot;); 
<span class="lineNum">    1279 </span><span class="lineCov">          8 : }</span>
<a name="1280"><span class="lineNum">    1280 </span>            : </a>
<span class="lineNum">    1281 </span>            : //____________________________________________________________________________
<span class="lineNum">    1282 </span>            : void  AliPHOSPIDv1::MakeRecParticles()
<span class="lineNum">    1283 </span>            : {
<span class="lineNum">    1284 </span>            :   // Makes a RecParticle out of a TrackSegment
<span class="lineNum">    1285 </span>            :   
<span class="lineNum">    1286 </span><span class="lineCov">         32 :   if ( !fEMCRecPoints || !fCPVRecPoints || !fTrackSegments ) {</span>
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 :     AliFatal(&quot;RecPoints or TrackSegments not found !&quot;) ;  </span>
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1289 </span><span class="lineCov">          8 :   fRecParticles-&gt;Clear();</span>
<span class="lineNum">    1290 </span>            : 
<span class="lineNum">    1291 </span><span class="lineCov">          8 :   Int_t nEmcRP=fEMCRecPoints-&gt;GetEntriesFast() ;</span>
<span class="lineNum">    1292 </span><span class="lineCov">         36 :   for(Int_t index=0; index&lt;nEmcRP; index++){</span>
<span class="lineNum">    1293 </span><span class="lineCov">         10 :     AliPHOSRecParticle * rp = new( (*fRecParticles)[index] ) AliPHOSRecParticle() ;</span>
<span class="lineNum">    1294 </span><span class="lineCov">         10 :     rp-&gt;SetTrackSegment(index) ;</span>
<span class="lineNum">    1295 </span><span class="lineCov">         10 :     rp-&gt;SetIndexInList(index) ;</span>
<span class="lineNum">    1296 </span>            :         
<span class="lineNum">    1297 </span><span class="lineCov">         10 :     AliPHOSEmcRecPoint * emc = static_cast&lt;AliPHOSEmcRecPoint *&gt;(fEMCRecPoints-&gt;At(index)) ;</span>
<span class="lineNum">    1298 </span><span class="lineCov">         10 :     AliPHOSTrackSegment * ts = static_cast&lt;AliPHOSTrackSegment*&gt;(fTrackSegments-&gt;At(index)) ;</span>
<span class="lineNum">    1299 </span>            :     AliPHOSCpvRecPoint * cpv = 0 ;
<span class="lineNum">    1300 </span><span class="lineCov">         10 :     if(ts-&gt;GetCpvIndex()&gt;=0)</span>
<span class="lineNum">    1301 </span><span class="lineNoCov">          0 :       cpv = (AliPHOSCpvRecPoint*) fCPVRecPoints-&gt;At(ts-&gt;GetCpvIndex()) ;</span>
<span class="lineNum">    1302 </span>            :     
<span class="lineNum">    1303 </span><span class="lineCov">         10 :     Int_t track = ts-&gt;GetTrackIndex() ; </span>
<span class="lineNum">    1304 </span>            :           
<span class="lineNum">    1305 </span><span class="lineCov">         10 :     if (!emc) {</span>
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :       AliFatal(Form(&quot;-&gt; emc(%d)&quot;, ts-&gt;GetEmcIndex())) ;</span>
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1308 </span>            : 
<span class="lineNum">    1309 </span><span class="lineCov">         10 :     Float_t e = emc-&gt;GetEnergy() ;   </span>
<span class="lineNum">    1310 </span>            :     
<span class="lineNum">    1311 </span><span class="lineCov">         10 :     Float_t  lambda[2]={0.,0.} ;</span>
<span class="lineNum">    1312 </span><span class="lineCov">         10 :     emc-&gt;GetElipsAxis(lambda) ;</span>
<span class="lineNum">    1313 </span>            :  
<span class="lineNum">    1314 </span><span class="lineCov">         20 :     if((lambda[0]&gt;0.01) &amp;&amp; (lambda[1]&gt;0.01)){</span>
<span class="lineNum">    1315 </span>            :       // Looking PCA. Define and calculate the data (X),
<span class="lineNum">    1316 </span>            :       // introduce in the function X2P that gives the components (P).  
<span class="lineNum">    1317 </span>            : 
<span class="lineNum">    1318 </span>            :       Float_t  spher = 0. ;
<span class="lineNum">    1319 </span>            :       Float_t  emaxdtotal = 0. ; 
<span class="lineNum">    1320 </span>            :       
<span class="lineNum">    1321 </span><span class="lineCov">         10 :       if((lambda[0]+lambda[1])!=0) </span>
<span class="lineNum">    1322 </span><span class="lineCov">         10 :         spher=TMath::Abs(lambda[0]-lambda[1])/(lambda[0]+lambda[1]); </span>
<span class="lineNum">    1323 </span>            :       
<span class="lineNum">    1324 </span><span class="lineCov">         10 :       emaxdtotal=emc-&gt;GetMaximalEnergy()/emc-&gt;GetEnergy(); </span>
<span class="lineNum">    1325 </span>            :       
<span class="lineNum">    1326 </span><span class="lineCov">         10 :       fX[0] = lambda[0] ;  </span>
<span class="lineNum">    1327 </span><span class="lineCov">         10 :       fX[1] = lambda[1] ; </span>
<span class="lineNum">    1328 </span><span class="lineCov">         10 :       fX[2] = emc-&gt;GetDispersion() ; </span>
<span class="lineNum">    1329 </span><span class="lineCov">         10 :       fX[3] = spher ; </span>
<span class="lineNum">    1330 </span><span class="lineCov">         10 :       fX[4] = emc-&gt;GetMultiplicity() ;  </span>
<span class="lineNum">    1331 </span><span class="lineCov">         10 :       fX[5] = emaxdtotal ;  </span>
<span class="lineNum">    1332 </span><span class="lineCov">         10 :       fX[6] = emc-&gt;GetCoreEnergy() ;  </span>
<span class="lineNum">    1333 </span>            :       
<span class="lineNum">    1334 </span><span class="lineCov">         10 :       fPrincipalPhoton-&gt;X2P(fX,fPPhoton);</span>
<span class="lineNum">    1335 </span><span class="lineCov">         10 :       fPrincipalPi0   -&gt;X2P(fX,fPPi0);</span>
<span class="lineNum">    1336 </span>            : 
<span class="lineNum">    1337 </span><span class="lineCov">         10 :     }</span>
<span class="lineNum">    1338 </span>            :     else{
<span class="lineNum">    1339 </span><span class="lineNoCov">          0 :       fPPhoton[0]=-100.0;  //We do not accept clusters with </span>
<span class="lineNum">    1340 </span><span class="lineNoCov">          0 :       fPPhoton[1]=-100.0;  //one cell as a photon-like</span>
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :       fPPi0[0]   =-100.0;</span>
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :       fPPi0[1]   =-100.0;</span>
<span class="lineNum">    1343 </span>            :     }
<span class="lineNum">    1344 </span>            :     
<span class="lineNum">    1345 </span><span class="lineCov">         10 :     Float_t time = emc-&gt;GetTime() ;</span>
<span class="lineNum">    1346 </span><span class="lineCov">         10 :     rp-&gt;SetTof(time) ; </span>
<span class="lineNum">    1347 </span>            :     
<span class="lineNum">    1348 </span>            :     // Loop of Efficiency-Purity (the 3 points of purity or efficiency 
<span class="lineNum">    1349 </span>            :     // are taken into account to set the particle identification)
<span class="lineNum">    1350 </span><span class="lineCov">         80 :     for(Int_t effPur = 0; effPur &lt; 3 ; effPur++){</span>
<span class="lineNum">    1351 </span>            :       
<span class="lineNum">    1352 </span>            :       // Looking at the CPV detector. If RCPV greater than CpvEmcDistance, 
<span class="lineNum">    1353 </span>            :       // 1st,2nd or 3rd bit (depending on the efficiency-purity point )
<span class="lineNum">    1354 </span>            :       // is set to 1
<span class="lineNum">    1355 </span><span class="lineCov">         30 :       if(GetCPVBit(ts, effPur,e) == 1 ){  </span>
<span class="lineNum">    1356 </span><span class="lineCov">         18 :         rp-&gt;SetPIDBit(effPur) ;</span>
<span class="lineNum">    1357 </span>            :         //cout&lt;&lt;&quot;CPV bit &quot;&lt;&lt;effPur&lt;&lt;endl;
<span class="lineNum">    1358 </span><span class="lineCov">         18 :       }</span>
<span class="lineNum">    1359 </span>            :       // Looking the TOF. If TOF smaller than gate,  4th, 5th or 6th 
<span class="lineNum">    1360 </span>            :       // bit (depending on the efficiency-purity point )is set to 1             
<span class="lineNum">    1361 </span><span class="lineCov">         30 :       if(time&lt; (*fParameters)(3,effPur)) </span>
<span class="lineNum">    1362 </span><span class="lineCov">         30 :         rp-&gt;SetPIDBit(effPur+3) ;                </span>
<span class="lineNum">    1363 </span>            :   
<span class="lineNum">    1364 </span>            :       //Photon PCA
<span class="lineNum">    1365 </span>            :       //If we are inside the ellipse, 7th, 8th or 9th 
<span class="lineNum">    1366 </span>            :       // bit (depending on the efficiency-purity point )is set to 1 
<span class="lineNum">    1367 </span><span class="lineCov">         60 :       if(GetPrincipalBit(&quot;photon&quot;,fPPhoton,effPur,e) == 1) </span>
<span class="lineNum">    1368 </span><span class="lineCov">         28 :         rp-&gt;SetPIDBit(effPur+6) ;</span>
<span class="lineNum">    1369 </span>            : 
<span class="lineNum">    1370 </span>            :       //Pi0 PCA
<span class="lineNum">    1371 </span>            :       //If we are inside the ellipse, 10th, 11th or 12th 
<span class="lineNum">    1372 </span>            :       // bit (depending on the efficiency-purity point )is set to 1 
<span class="lineNum">    1373 </span><span class="lineCov">         60 :       if(GetPrincipalBit(&quot;pi0&quot;   ,fPPi0   ,effPur,e) == 1) </span>
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :         rp-&gt;SetPIDBit(effPur+9) ;</span>
<span class="lineNum">    1375 </span>            :     }
<span class="lineNum">    1376 </span><span class="lineCov">         10 :     if(GetHardPhotonBit(emc))</span>
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :       rp-&gt;SetPIDBit(12) ;</span>
<span class="lineNum">    1378 </span><span class="lineCov">         10 :     if(GetHardPi0Bit   (emc))</span>
<span class="lineNum">    1379 </span><span class="lineNoCov">          0 :       rp-&gt;SetPIDBit(13) ;</span>
<span class="lineNum">    1380 </span>            :     
<span class="lineNum">    1381 </span><span class="lineCov">         10 :     if(track &gt;= 0) </span>
<span class="lineNum">    1382 </span><span class="lineCov">          4 :       rp-&gt;SetPIDBit(14) ; </span>
<span class="lineNum">    1383 </span>            : 
<span class="lineNum">    1384 </span>            :     //Set momentum, energy and other parameters 
<span class="lineNum">    1385 </span><span class="lineCov">         10 :     TVector3 dir   = GetMomentumDirection(emc,cpv) ; </span>
<span class="lineNum">    1386 </span><span class="lineCov">         10 :     dir.SetMag(e) ;</span>
<span class="lineNum">    1387 </span><span class="lineCov">         10 :     rp-&gt;SetMomentum(dir.X(),dir.Y(),dir.Z(),e) ;</span>
<span class="lineNum">    1388 </span><span class="lineCov">         10 :     rp-&gt;SetCalcMass(0);</span>
<span class="lineNum">    1389 </span><span class="lineCov">         20 :     rp-&gt;Name(); //If photon sets the particle pdg name to gamma</span>
<span class="lineNum">    1390 </span><span class="lineCov">         10 :     rp-&gt;SetProductionVertex(fVtx.X(),fVtx.Y(),fVtx.Z(),0);</span>
<span class="lineNum">    1391 </span><span class="lineCov">         10 :     rp-&gt;SetFirstMother(-1);</span>
<span class="lineNum">    1392 </span><span class="lineCov">         10 :     rp-&gt;SetLastMother(-1);</span>
<span class="lineNum">    1393 </span><span class="lineCov">         10 :     rp-&gt;SetFirstDaughter(-1);</span>
<span class="lineNum">    1394 </span><span class="lineCov">         10 :     rp-&gt;SetLastDaughter(-1);</span>
<span class="lineNum">    1395 </span><span class="lineCov">         10 :     rp-&gt;SetPolarisation(0,0,0);</span>
<span class="lineNum">    1396 </span>            :     //Set the position in global coordinate system from the RecPoint
<span class="lineNum">    1397 </span><span class="lineCov">         10 :     TVector3 pos ; </span>
<span class="lineNum">    1398 </span><span class="lineCov">         10 :     fGeom-&gt;GetGlobalPHOS(emc, pos) ; </span>
<span class="lineNum">    1399 </span><span class="lineCov">         30 :     rp-&gt;SetPos(pos);</span>
<span class="lineNum">    1400 </span><span class="lineCov">         10 :   }</span>
<span class="lineNum">    1401 </span><span class="lineCov">          8 : }</span>
<a name="1402"><span class="lineNum">    1402 </span>            :   </a>
<span class="lineNum">    1403 </span>            : //____________________________________________________________________________
<span class="lineNum">    1404 </span>            : void  AliPHOSPIDv1::Print(const Option_t *) const
<span class="lineNum">    1405 </span>            : {
<span class="lineNum">    1406 </span>            :   // Print the parameters used for the particle type identification
<span class="lineNum">    1407 </span>            : 
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :     AliInfo(&quot;=============== AliPHOSPIDv1 ================&quot;) ;</span>
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 :     printf(&quot;Making PID\n&quot;) ;</span>
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :     printf(&quot;    Pricipal analysis file from 0.5 to 100 %s\n&quot;, fFileNamePrincipalPhoton.Data() )   ; </span>
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :     printf(&quot;    Name of parameters file     %s\n&quot;, fFileNameParameters.Data() )  ;</span>
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :     printf(&quot;    Matrix of Parameters: 14x4\n&quot;) ;</span>
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :     printf(&quot;        Energy Calibration  1x3 [3 parametres to calibrate energy: A + B* E + C * E^2]\n&quot;) ;</span>
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :     printf(&quot;        RCPV 2x3 rows x and z, columns function cut parameters\n&quot;) ;</span>
<span class="lineNum">    1415 </span><span class="lineNoCov">          0 :     printf(&quot;        TOF  1x3 [High Eff-Low Pur,Medium Eff-Pur, Low Eff-High Pur]\n&quot;) ;</span>
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :     printf(&quot;        PCA  5x4 [5 ellipse parametres and 4 parametres to calculate them: A/Sqrt(E) + B* E + C * E^2 + D]\n&quot;) ;</span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :     printf(&quot;    Pi0 PCA  5x3 [5 ellipse parametres and 3 parametres to calculate them: A + B* E + C * E^2]\n&quot;) ;</span>
<span class="lineNum">    1418 </span><span class="lineNoCov">          0 :     fParameters-&gt;Print() ;</span>
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1420 </span>            : 
<span class="lineNum">    1421 </span>            : 
<a name="1422"><span class="lineNum">    1422 </span>            : </a>
<span class="lineNum">    1423 </span>            : //____________________________________________________________________________
<span class="lineNum">    1424 </span>            : void AliPHOSPIDv1::PrintRecParticles(Option_t * option)
<span class="lineNum">    1425 </span>            : {
<span class="lineNum">    1426 </span>            :   // Print table of reconstructed particles
<span class="lineNum">    1427 </span>            : 
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :   TString message ; </span>
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 :   message  = &quot;       found &quot; ; </span>
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :   message += fRecParticles-&gt;GetEntriesFast(); </span>
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 :   message += &quot; RecParticles\n&quot; ; </span>
<span class="lineNum">    1432 </span>            : 
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :   if(strstr(option,&quot;all&quot;)) {  // printing found TS</span>
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :     message += &quot;\n  PARTICLE         Index    \n&quot; ; </span>
<span class="lineNum">    1435 </span>            :     
<span class="lineNum">    1436 </span>            :     Int_t index ;
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :     for (index = 0 ; index &lt; fRecParticles-&gt;GetEntries() ; index++) {</span>
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :       AliPHOSRecParticle * rp = (AliPHOSRecParticle * ) fRecParticles-&gt;At(index) ;       </span>
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :       message += &quot;\n&quot; ;</span>
<span class="lineNum">    1440 </span><span class="lineNoCov">          0 :       message += rp-&gt;Name().Data() ;  </span>
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :       message += &quot; &quot; ;</span>
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :       message += rp-&gt;GetIndexInList() ;  </span>
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :       message += &quot; &quot; ;</span>
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :       message += rp-&gt;GetType()  ;</span>
<span class="lineNum">    1445 </span>            :     }
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 :   AliInfo(message.Data() ) ; </span>
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 : }</span>
<a name="1449"><span class="lineNum">    1449 </span>            : </a>
<span class="lineNum">    1450 </span>            : //____________________________________________________________________________
<span class="lineNum">    1451 </span>            : void  AliPHOSPIDv1::SetParameters() 
<span class="lineNum">    1452 </span>            : {
<span class="lineNum">    1453 </span>            :   // PCA : To do the Principal Components Analysis it is necessary 
<span class="lineNum">    1454 </span>            :   // the Principal file, which is opened here
<span class="lineNum">    1455 </span><span class="lineCov">          4 :   fX       = new double[7]; // Data for the PCA </span>
<span class="lineNum">    1456 </span><span class="lineCov">          2 :   fPPhoton = new double[7]; // Eigenvalues of the PCA</span>
<span class="lineNum">    1457 </span><span class="lineCov">          2 :   fPPi0    = new double[7]; // Eigenvalues of the Pi0 PCA</span>
<span class="lineNum">    1458 </span>            : 
<span class="lineNum">    1459 </span>            :   // Read photon principals from the photon file
<span class="lineNum">    1460 </span>            :   
<span class="lineNum">    1461 </span><span class="lineCov">          2 :   fFileNamePrincipalPhoton = &quot;$ALICE_ROOT/PHOS/PCA8pa15_0.5-100.root&quot; ; </span>
<span class="lineNum">    1462 </span><span class="lineCov">          2 :   TFile f( fFileNamePrincipalPhoton.Data(), &quot;read&quot; ) ;</span>
<span class="lineNum">    1463 </span><span class="lineCov">          8 :   fPrincipalPhoton = dynamic_cast&lt;TPrincipal*&gt; (f.Get(&quot;principal&quot;)) ; </span>
<span class="lineNum">    1464 </span><span class="lineCov">          2 :   f.Close() ; </span>
<span class="lineNum">    1465 </span>            : 
<span class="lineNum">    1466 </span>            :   // Read pi0 principals from the pi0 file
<span class="lineNum">    1467 </span>            : 
<span class="lineNum">    1468 </span><span class="lineCov">          2 :   fFileNamePrincipalPi0    = &quot;$ALICE_ROOT/PHOS/PCA_pi0_40-120.root&quot; ;</span>
<span class="lineNum">    1469 </span><span class="lineCov">          4 :   TFile fPi0( fFileNamePrincipalPi0.Data(), &quot;read&quot; ) ;</span>
<span class="lineNum">    1470 </span><span class="lineCov">          8 :   fPrincipalPi0    = dynamic_cast&lt;TPrincipal*&gt; (fPi0.Get(&quot;principal&quot;)) ; </span>
<span class="lineNum">    1471 </span><span class="lineCov">          2 :   fPi0.Close() ;</span>
<span class="lineNum">    1472 </span>            : 
<span class="lineNum">    1473 </span>            :   // Open parameters file and initialization of the Parameters matrix. 
<span class="lineNum">    1474 </span>            :   // In the File Parameters.dat are all the parameters. These are introduced 
<span class="lineNum">    1475 </span>            :   // in a matrix of 16x4  
<span class="lineNum">    1476 </span>            :   // 
<span class="lineNum">    1477 </span>            :   // All the parameters defined in this file are, in order of row: 
<span class="lineNum">    1478 </span>            :   // line   0   : calibration 
<span class="lineNum">    1479 </span>            :   // lines  1,2 : CPV rectangular cat for X and Z
<span class="lineNum">    1480 </span>            :   // line   3   : TOF cut
<span class="lineNum">    1481 </span>            :   // lines  4-8 : parameters to calculate photon PCA ellipse
<span class="lineNum">    1482 </span>            :   // lines  9-13: parameters to calculate pi0 PCA ellipse
<span class="lineNum">    1483 </span>            :   // lines 14-15: parameters to calculate border for high-pt photons and pi0
<span class="lineNum">    1484 </span>            : 
<span class="lineNum">    1485 </span><span class="lineCov">          4 :   fFileNameParameters = gSystem-&gt;ExpandPathName(&quot;$ALICE_ROOT/PHOS/Parameters.dat&quot;);</span>
<span class="lineNum">    1486 </span><span class="lineCov">          6 :   fParameters = new TMatrixF(16,4) ;</span>
<span class="lineNum">    1487 </span>            :   const Int_t kMaxLeng=255;
<span class="lineNum">    1488 </span><span class="lineCov">          2 :   char string[kMaxLeng];</span>
<span class="lineNum">    1489 </span>            : 
<span class="lineNum">    1490 </span>            :   // Open a text file with PID parameters
<span class="lineNum">    1491 </span><span class="lineCov">          4 :   FILE *fd = fopen(fFileNameParameters.Data(),&quot;r&quot;);</span>
<span class="lineNum">    1492 </span><span class="lineCov">          2 :   if (!fd)</span>
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :     AliFatal(Form(&quot;File %s with a PID parameters cannot be opened\n&quot;,</span>
<span class="lineNum">    1494 </span>            :           fFileNameParameters.Data()));
<span class="lineNum">    1495 </span>            : 
<span class="lineNum">    1496 </span>            :   Int_t i=0;
<span class="lineNum">    1497 </span>            :   // Read parameter file line-by-line and skip empty line and comments
<span class="lineNum">    1498 </span><span class="lineCov">        158 :   while (fgets(string,kMaxLeng,fd) != NULL) {</span>
<span class="lineNum">    1499 </span><span class="lineCov">         76 :     if (string[0] == '\n' ) continue;</span>
<span class="lineNum">    1500 </span><span class="lineCov">         64 :     if (string[0] == '!'  ) continue;</span>
<span class="lineNum">    1501 </span><span class="lineCov">         32 :     sscanf(string, &quot;%f %f %f %f&quot;,</span>
<span class="lineNum">    1502 </span><span class="lineCov">         64 :            &amp;(*fParameters)(i,0), &amp;(*fParameters)(i,1), </span>
<span class="lineNum">    1503 </span><span class="lineCov">         64 :            &amp;(*fParameters)(i,2), &amp;(*fParameters)(i,3));</span>
<span class="lineNum">    1504 </span><span class="lineCov">         32 :     i++;</span>
<span class="lineNum">    1505 </span><span class="lineCov">        160 :     AliDebug(1, Form(&quot;Line %d: %s&quot;,i,string));</span>
<span class="lineNum">    1506 </span>            :   }
<span class="lineNum">    1507 </span><span class="lineCov">          2 :   fclose(fd);</span>
<span class="lineNum">    1508 </span><span class="lineCov">          2 : }</span>
<a name="1509"><span class="lineNum">    1509 </span>            : </a>
<span class="lineNum">    1510 </span>            : //____________________________________________________________________________
<span class="lineNum">    1511 </span>            : void  AliPHOSPIDv1::SetParameterCalibration(Int_t i,Float_t param) 
<span class="lineNum">    1512 </span>            : {
<span class="lineNum">    1513 </span>            :   // Set parameter &quot;Calibration&quot; i to a value param
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 :   if(i&gt;2 || i&lt;0) {</span>
<span class="lineNum">    1515 </span><span class="lineNoCov">          0 :     AliError(Form(&quot;Invalid parameter number: %d&quot;,i));</span>
<span class="lineNum">    1516 </span><span class="lineNoCov">          0 :   } else</span>
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 :     (*fParameters)(0,i) = param ;</span>
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 : }</span>
<a name="1519"><span class="lineNum">    1519 </span>            : </a>
<span class="lineNum">    1520 </span>            : //____________________________________________________________________________
<span class="lineNum">    1521 </span>            : void  AliPHOSPIDv1::SetParameterCpv2Emc(Int_t i, TString axis, Float_t cut) 
<span class="lineNum">    1522 </span>            : {
<span class="lineNum">    1523 </span>            :   // Set the parameters to calculate Cpv-to-Emc Distance Cut depending on 
<span class="lineNum">    1524 </span>            :   // Purity-Efficiency point i
<span class="lineNum">    1525 </span>            : 
<span class="lineNum">    1526 </span><span class="lineNoCov">          0 :   if(i&gt;2 || i&lt;0) {</span>
<span class="lineNum">    1527 </span><span class="lineNoCov">          0 :     AliError(Form(&quot;Invalid parameter number: %d&quot;,i));</span>
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 :     axis.ToLower();</span>
<span class="lineNum">    1530 </span><span class="lineNoCov">          0 :     if      (axis == &quot;x&quot;) (*fParameters)(1,i) = cut;</span>
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :     else if (axis == &quot;z&quot;) (*fParameters)(2,i) = cut;</span>
<span class="lineNum">    1532 </span>            :     else { 
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 :       AliError(Form(&quot;Invalid axis name: %s&quot;,axis.Data()));</span>
<span class="lineNum">    1534 </span>            :     }
<span class="lineNum">    1535 </span>            :   }
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 : }</span>
<a name="1537"><span class="lineNum">    1537 </span>            : </a>
<span class="lineNum">    1538 </span>            : //____________________________________________________________________________
<span class="lineNum">    1539 </span>            : void  AliPHOSPIDv1::SetParameterPhotonBoundary(Int_t i,Float_t param) 
<span class="lineNum">    1540 </span>            : {
<span class="lineNum">    1541 </span>            :   // Set parameter &quot;Hard photon boundary&quot; i to a value param
<span class="lineNum">    1542 </span><span class="lineNoCov">          0 :   if(i&gt;4 || i&lt;0) {</span>
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :     AliError(Form(&quot;Invalid parameter number: %d&quot;,i));</span>
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :   } else</span>
<span class="lineNum">    1545 </span><span class="lineNoCov">          0 :     (*fParameters)(14,i) = param ;</span>
<span class="lineNum">    1546 </span><span class="lineNoCov">          0 : }</span>
<a name="1547"><span class="lineNum">    1547 </span>            : </a>
<span class="lineNum">    1548 </span>            : //____________________________________________________________________________
<span class="lineNum">    1549 </span>            : void  AliPHOSPIDv1::SetParameterPi0Boundary(Int_t i,Float_t param) 
<span class="lineNum">    1550 </span>            : {
<span class="lineNum">    1551 </span>            :   // Set parameter &quot;Hard pi0 boundary&quot; i to a value param
<span class="lineNum">    1552 </span><span class="lineNoCov">          0 :   if(i&gt;1 || i&lt;0) {</span>
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :     AliError(Form(&quot;Invalid parameter number: %d&quot;,i));</span>
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :   } else</span>
<span class="lineNum">    1555 </span><span class="lineNoCov">          0 :     (*fParameters)(15,i) = param ;</span>
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 : }</span>
<a name="1557"><span class="lineNum">    1557 </span>            : </a>
<span class="lineNum">    1558 </span>            : //_____________________________________________________________________________
<span class="lineNum">    1559 </span>            : void  AliPHOSPIDv1::SetParameterTimeGate(Int_t i, Float_t gate) 
<span class="lineNum">    1560 </span>            : {
<span class="lineNum">    1561 </span>            :   // Set the parameter TimeGate depending on Purity-Efficiency point i 
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 :   if (i&gt;2 || i&lt;0) {</span>
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :     AliError(Form(&quot;Invalid Efficiency-Purity choice %d&quot;,i));</span>
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :   } else</span>
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :     (*fParameters)(3,i)= gate ; </span>
<span class="lineNum">    1566 </span><span class="lineNoCov">          0 : } </span>
<a name="1567"><span class="lineNum">    1567 </span>            : </a>
<span class="lineNum">    1568 </span>            : //_____________________________________________________________________________
<span class="lineNum">    1569 </span>            : void  AliPHOSPIDv1::SetParameterToCalculateEllipse(TString particle, TString param, Int_t i, Float_t par) 
<span class="lineNum">    1570 </span>            : {  
<span class="lineNum">    1571 </span>            :   // Set the parameter &quot;i&quot; that is needed to calculate the ellipse 
<span class="lineNum">    1572 </span>            :   // parameter &quot;param&quot; for a particle &quot;particle&quot;
<span class="lineNum">    1573 </span>            :   
<span class="lineNum">    1574 </span><span class="lineNoCov">          0 :   particle.ToLower();</span>
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :   param.   ToLower();</span>
<span class="lineNum">    1576 </span>            :   Int_t p= -1;
<span class="lineNum">    1577 </span>            :   Int_t offset=0;
<span class="lineNum">    1578 </span>            : 
<span class="lineNum">    1579 </span><span class="lineNoCov">          0 :   if      (particle == &quot;photon&quot;) offset=0;</span>
<span class="lineNum">    1580 </span><span class="lineNoCov">          0 :   else if (particle == &quot;pi0&quot;)    offset=5;</span>
<span class="lineNum">    1581 </span>            :   else
<span class="lineNum">    1582 </span><span class="lineNoCov">          0 :     AliError(Form(&quot;Wrong particle name: %s (choose from pi0/photon)\n&quot;,</span>
<span class="lineNum">    1583 </span>            :                   particle.Data()));
<span class="lineNum">    1584 </span>            : 
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :   if     (param.Contains(&quot;a&quot;)) p=4+offset; </span>
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :   else if(param.Contains(&quot;b&quot;)) p=5+offset; </span>
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :   else if(param.Contains(&quot;c&quot;)) p=6+offset; </span>
<span class="lineNum">    1588 </span><span class="lineNoCov">          0 :   else if(param.Contains(&quot;x0&quot;))p=7+offset; </span>
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :   else if(param.Contains(&quot;y0&quot;))p=8+offset;</span>
<span class="lineNum">    1590 </span><span class="lineNoCov">          0 :   if((i&gt;4)||(i&lt;0)) {</span>
<span class="lineNum">    1591 </span><span class="lineNoCov">          0 :     AliError(Form(&quot;No parameter with index %d&quot;, i)) ; </span>
<span class="lineNum">    1592 </span><span class="lineNoCov">          0 :   } else if(p==-1) {</span>
<span class="lineNum">    1593 </span><span class="lineNoCov">          0 :     AliError(Form(&quot;No parameter with name %s&quot;, param.Data() )) ; </span>
<span class="lineNum">    1594 </span><span class="lineNoCov">          0 :   } else</span>
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 :     (*fParameters)(p,i) = par ;</span>
<span class="lineNum">    1596 </span><span class="lineNoCov">          0 : } </span>
<a name="1597"><span class="lineNum">    1597 </span>            : </a>
<span class="lineNum">    1598 </span>            : //____________________________________________________________________________
<span class="lineNum">    1599 </span>            : void AliPHOSPIDv1::GetVertex(void)
<span class="lineNum">    1600 </span>            : { //extract vertex either using ESD or generator
<span class="lineNum">    1601 </span>            :  
<span class="lineNum">    1602 </span>            :   //Try to extract vertex from data
<span class="lineNum">    1603 </span><span class="lineCov">         16 :   if(fESD){</span>
<span class="lineNum">    1604 </span><span class="lineCov">          8 :     const AliESDVertex *esdVtx = fESD-&gt;GetVertex() ;</span>
<span class="lineNum">    1605 </span><span class="lineCov">         16 :     if(esdVtx &amp;&amp; esdVtx-&gt;GetChi2()!=0.){</span>
<span class="lineNum">    1606 </span><span class="lineCov">          8 :       fVtx.SetXYZ(esdVtx-&gt;GetX(),esdVtx-&gt;GetY(),esdVtx-&gt;GetZ()) ;</span>
<span class="lineNum">    1607 </span><span class="lineCov">          8 :       return ;</span>
<span class="lineNum">    1608 </span>            :     }
<span class="lineNum">    1609 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1610 </span>            : 
<span class="lineNum">    1611 </span>            :   // Use vertex diamond from CDB GRP folder if the one from ESD is missing
<span class="lineNum">    1612 </span>            :   // PLEASE FIX IT 
<span class="lineNum">    1613 </span>            : //  AliWarning(&quot;Can not read vertex from data, use fixed \n&quot;) ;
<span class="lineNum">    1614 </span><span class="lineNoCov">          0 :   fVtx.SetXYZ(0.,0.,0.) ;</span>
<span class="lineNum">    1615 </span>            :  
<a name="1616"><span class="lineNum">    1616 </span><span class="lineCov">          8 : }</span></a>
<span class="lineNum">    1617 </span>            : //_______________________________________________________________________
<span class="lineNum">    1618 </span>            : void AliPHOSPIDv1::SetInitPID(const Double_t *p) {
<span class="lineNum">    1619 </span>            :   // Sets values for the initial population of each particle type 
<span class="lineNum">    1620 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;AliPID::kSPECIESCN; i++) fInitPID[i] = p[i];</span>
<a name="1621"><span class="lineNum">    1621 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1622 </span>            : //_______________________________________________________________________
<span class="lineNum">    1623 </span>            : void AliPHOSPIDv1::GetInitPID(Double_t *p) const {
<span class="lineNum">    1624 </span>            :   // Gets values for the initial population of each particle type 
<span class="lineNum">    1625 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;AliPID::kSPECIESCN; i++) p[i] = fInitPID[i];</span>
<span class="lineNum">    1626 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
