<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - PHOS/PHOSbase/AliPHOSClusterizerv1.cxx</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">PHOS/PHOSbase</a> - AliPHOSClusterizerv1.cxx<span style="font-size: 80%;"> (source / <a href="AliPHOSClusterizerv1.cxx.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">192</td>
            <td class="headerCovTableEntry">528</td>
            <td class="headerCovTableEntryLo">36.4 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">19</td>
            <td class="headerCovTableEntry">27</td>
            <td class="headerCovTableEntryLo">70.4 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**************************************************************************</a>
<span class="lineNum">       2 </span>            :  * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
<span class="lineNum">       3 </span>            :  *                                                                        *
<span class="lineNum">       4 </span>            :  * Author: The ALICE Off-line Project.                                    *
<span class="lineNum">       5 </span>            :  * Contributors are mentioned in the code where appropriate.              *
<span class="lineNum">       6 </span>            :  *                                                                        *
<span class="lineNum">       7 </span>            :  * Permission to use, copy, modify and distribute this software and its   *
<span class="lineNum">       8 </span>            :  * documentation strictly for non-commercial purposes is hereby granted   *
<span class="lineNum">       9 </span>            :  * without fee, provided that the above copyright notice appears in all   *
<span class="lineNum">      10 </span>            :  * copies and that both the copyright notice and this permission notice   *
<span class="lineNum">      11 </span>            :  * appear in the supporting documentation. The authors make no claims     *
<span class="lineNum">      12 </span>            :  * about the suitability of this software for any purpose. It is          *
<span class="lineNum">      13 </span>            :  * provided &quot;as is&quot; without express or implied warranty.                  *
<span class="lineNum">      14 </span>            :  **************************************************************************/
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : /* $Id$ */
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : /* History of cvs commits:
<span class="lineNum">      19 </span>            :  *
<span class="lineNum">      20 </span>            :  * $Log: AliPHOSClusterizerv1.cxx,v $
<span class="lineNum">      21 </span>            :  * Revision 1.118  2007/12/11 21:23:26  kharlov
<span class="lineNum">      22 </span>            :  * Added possibility to swith off unfolding
<span class="lineNum">      23 </span>            :  *
<span class="lineNum">      24 </span>            :  * Revision 1.117  2007/10/18 08:42:05  kharlov
<span class="lineNum">      25 </span>            :  * Bad channels cleaned before clusterization
<span class="lineNum">      26 </span>            :  *
<span class="lineNum">      27 </span>            :  * Revision 1.116  2007/10/01 20:24:08  kharlov
<span class="lineNum">      28 </span>            :  * Memory leaks fixed
<span class="lineNum">      29 </span>            :  *
<span class="lineNum">      30 </span>            :  * Revision 1.115  2007/09/26 14:22:17  cvetan
<span class="lineNum">      31 </span>            :  * Important changes to the reconstructor classes. Complete elimination of the run-loaders, which are now steered only from AliReconstruction. Removal of the corresponding Reconstruct() and FillESD() methods.
<span class="lineNum">      32 </span>            :  *
<span class="lineNum">      33 </span>            :  * Revision 1.114  2007/09/06 16:06:44  kharlov
<span class="lineNum">      34 </span>            :  * Absence of sorting results in loose of all unfolded clusters
<span class="lineNum">      35 </span>            :  *
<span class="lineNum">      36 </span>            :  * Revision 1.113  2007/08/28 12:55:07  policheh
<span class="lineNum">      37 </span>            :  * Loaders removed from the reconstruction code (C.Cheshkov)
<span class="lineNum">      38 </span>            :  *
<span class="lineNum">      39 </span>            :  * Revision 1.112  2007/08/22 09:20:50  hristov
<span class="lineNum">      40 </span>            :  * Updated QA classes (Yves)
<span class="lineNum">      41 </span>            :  *
<span class="lineNum">      42 </span>            :  * Revision 1.111  2007/08/08 12:11:28  kharlov
<span class="lineNum">      43 </span>            :  * Protection against uninitialized fQADM
<span class="lineNum">      44 </span>            :  *
<span class="lineNum">      45 </span>            :  * Revision 1.110  2007/08/07 14:16:00  kharlov
<span class="lineNum">      46 </span>            :  * Quality assurance added (Yves Schutz)
<span class="lineNum">      47 </span>            :  *
<span class="lineNum">      48 </span>            :  * Revision 1.109  2007/07/24 17:20:35  policheh
<span class="lineNum">      49 </span>            :  * Usage of RecoParam objects instead of hardcoded parameters in reconstruction.
<span class="lineNum">      50 </span>            :  * (See $ALICE_ROOT/PHOS/macros/BeamTest2006/RawReconstruction.C).
<span class="lineNum">      51 </span>            :  *
<span class="lineNum">      52 </span>            :  * Revision 1.108  2007/06/18 07:00:51  kharlov
<span class="lineNum">      53 </span>            :  * Bug fix for attempt to use AliPHOSEmcRecPoint after its deletion
<span class="lineNum">      54 </span>            :  *
<span class="lineNum">      55 </span>            :  * Revision 1.107  2007/05/25 14:12:26  policheh
<span class="lineNum">      56 </span>            :  * Local to tracking CS transformation added for CPV rec. points
<span class="lineNum">      57 </span>            :  *
<span class="lineNum">      58 </span>            :  * Revision 1.106  2007/05/24 13:01:22  policheh
<span class="lineNum">      59 </span>            :  * Local to tracking CS transformation invoked for each EMC rec.point
<span class="lineNum">      60 </span>            :  *
<span class="lineNum">      61 </span>            :  * Revision 1.105  2007/05/02 13:41:22  kharlov
<span class="lineNum">      62 </span>            :  * Mode protection against absence of calib.data from AliPHOSCalibData to AliPHOSClusterizerv1::GetCalibrationParameters()
<span class="lineNum">      63 </span>            :  *
<span class="lineNum">      64 </span>            :  * Revision 1.104  2007/04/27 16:55:53  kharlov
<span class="lineNum">      65 </span>            :  * Calibration stops if PHOS CDB objects do not exist
<span class="lineNum">      66 </span>            :  *
<span class="lineNum">      67 </span>            :  * Revision 1.103  2007/04/11 11:55:45  policheh
<span class="lineNum">      68 </span>            :  * SetDistancesToBadChannels() added.
<span class="lineNum">      69 </span>            :  *
<span class="lineNum">      70 </span>            :  * Revision 1.102  2007/03/28 19:18:15  kharlov
<span class="lineNum">      71 </span>            :  * RecPoints recalculation in TSM removed
<span class="lineNum">      72 </span>            :  *
<span class="lineNum">      73 </span>            :  * Revision 1.101  2007/03/06 06:51:27  kharlov
<span class="lineNum">      74 </span>            :  * Calculation of cluster properties dep. on vertex posponed to TrackSegmentMaker
<span class="lineNum">      75 </span>            :  *
<span class="lineNum">      76 </span>            :  * Revision 1.100  2007/01/10 11:07:26  kharlov
<span class="lineNum">      77 </span>            :  * Raw digits writing to file (B.Polichtchouk)
<span class="lineNum">      78 </span>            :  *
<span class="lineNum">      79 </span>            :  * Revision 1.99  2006/11/07 16:49:51  kharlov
<span class="lineNum">      80 </span>            :  * Corrections for next event switch in case of raw data (B.Polichtchouk)
<span class="lineNum">      81 </span>            :  *
<span class="lineNum">      82 </span>            :  * Revision 1.98  2006/10/27 17:14:27  kharlov
<span class="lineNum">      83 </span>            :  * Introduce AliDebug and AliLog (B.Polichtchouk)
<span class="lineNum">      84 </span>            :  *
<span class="lineNum">      85 </span>            :  * Revision 1.97  2006/08/29 11:41:19  kharlov
<span class="lineNum">      86 </span>            :  * Missing implementation of ctors and = operator are added
<span class="lineNum">      87 </span>            :  *
<span class="lineNum">      88 </span>            :  * Revision 1.96  2006/08/25 16:56:30  kharlov
<span class="lineNum">      89 </span>            :  * Compliance with Effective C++
<span class="lineNum">      90 </span>            :  *
<span class="lineNum">      91 </span>            :  * Revision 1.95  2006/08/11 12:36:26  cvetan
<span class="lineNum">      92 </span>            :  * Update of the PHOS code needed in order to read and reconstruct the beam test raw data (i.e. without an existing galice.root)
<span class="lineNum">      93 </span>            :  *
<span class="lineNum">      94 </span>            :  * Revision 1.94  2006/08/07 12:27:49  hristov
<span class="lineNum">      95 </span>            :  * Removing obsolete code which affected the event numbering scheme
<span class="lineNum">      96 </span>            :  *
<span class="lineNum">      97 </span>            :  * Revision 1.93  2006/08/01 12:20:17  cvetan
<span class="lineNum">      98 </span>            :  * 1. Adding a possibility to read and reconstruct an old rcu formatted raw data. This is controlled by an option of AliReconstruction and AliPHOSReconstructor. 2. In case of raw data processing (without galice.root) create the default AliPHOSGeometry object. Most likely this should be moved to the CDB
<span class="lineNum">      99 </span>            :  *
<span class="lineNum">     100 </span>            :  * Revision 1.92  2006/04/29 20:26:46  hristov
<span class="lineNum">     101 </span>            :  * Separate EMC and CPV calibration (Yu.Kharlov)
<span class="lineNum">     102 </span>            :  *
<span class="lineNum">     103 </span>            :  * Revision 1.91  2006/04/22 10:30:17  hristov
<span class="lineNum">     104 </span>            :  * Add fEnergy to AliPHOSDigit and operate with EMC amplitude in energy units (Yu.Kharlov)
<span class="lineNum">     105 </span>            :  *
<span class="lineNum">     106 </span>            :  * Revision 1.90  2006/04/11 15:22:59  hristov
<span class="lineNum">     107 </span>            :  * run number in query set to -1: forces AliCDBManager to use its run number (A.Colla)
<span class="lineNum">     108 </span>            :  *
<span class="lineNum">     109 </span>            :  * Revision 1.89  2006/03/13 14:05:42  kharlov
<span class="lineNum">     110 </span>            :  * Calibration objects for EMC and CPV
<span class="lineNum">     111 </span>            :  *
<span class="lineNum">     112 </span>            :  * Revision 1.88  2006/01/11 08:54:52  hristov
<span class="lineNum">     113 </span>            :  * Additional protection in case no calibration entry was found
<span class="lineNum">     114 </span>            :  *
<span class="lineNum">     115 </span>            :  * Revision 1.87  2005/11/22 08:46:43  kharlov
<span class="lineNum">     116 </span>            :  * Updated to new CDB (Boris Polichtchouk)
<span class="lineNum">     117 </span>            :  *
<span class="lineNum">     118 </span>            :  * Revision 1.86  2005/11/14 21:52:43  hristov
<span class="lineNum">     119 </span>            :  * Coding conventions
<span class="lineNum">     120 </span>            :  *
<span class="lineNum">     121 </span>            :  * Revision 1.85  2005/09/27 16:08:08  hristov
<span class="lineNum">     122 </span>            :  * New version of CDB storage framework (A.Colla)
<span class="lineNum">     123 </span>            :  *
<span class="lineNum">     124 </span>            :  * Revision 1.84  2005/09/21 10:02:47  kharlov
<span class="lineNum">     125 </span>            :  * Reading calibration from CDB (Boris Polichtchouk)
<span class="lineNum">     126 </span>            :  *
<span class="lineNum">     127 </span>            :  * Revision 1.82  2005/09/02 15:43:13  kharlov
<span class="lineNum">     128 </span>            :  * Add comments in GetCalibrationParameters and Calibrate
<span class="lineNum">     129 </span>            :  *
<span class="lineNum">     130 </span>            :  * Revision 1.81  2005/09/02 14:32:07  kharlov
<span class="lineNum">     131 </span>            :  * Calibration of raw data
<span class="lineNum">     132 </span>            :  *
<span class="lineNum">     133 </span>            :  * Revision 1.80  2005/08/24 15:31:36  kharlov
<span class="lineNum">     134 </span>            :  * Setting raw digits flag
<span class="lineNum">     135 </span>            :  *
<span class="lineNum">     136 </span>            :  * Revision 1.79  2005/07/25 15:53:53  kharlov
<span class="lineNum">     137 </span>            :  * Read raw data
<span class="lineNum">     138 </span>            :  *
<span class="lineNum">     139 </span>            :  * Revision 1.78  2005/05/28 14:19:04  schutz
<span class="lineNum">     140 </span>            :  * Compilation warnings fixed by T.P.
<span class="lineNum">     141 </span>            :  *
<span class="lineNum">     142 </span>            :  */
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            : //*-- Author: Yves Schutz (SUBATECH)  &amp; Dmitri Peressounko (SUBATECH &amp; Kurchatov Institute)
<span class="lineNum">     145 </span>            : //////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     146 </span>            : //  Clusterization class. Performs clusterization (collects neighbouring active cells) and 
<span class="lineNum">     147 </span>            : //  unfolds the clusters having several local maxima.  
<span class="lineNum">     148 </span>            : //  Results are stored in TreeR#, branches PHOSEmcRP (EMC recPoints),
<span class="lineNum">     149 </span>            : //  PHOSCpvRP (CPV RecPoints) and AliPHOSClusterizer (Clusterizer with all 
<span class="lineNum">     150 </span>            : //  parameters including input digits branch title, thresholds etc.)
<span class="lineNum">     151 </span>            : //  This TTask is normally called from Reconstructioner, but can as well be used in 
<span class="lineNum">     152 </span>            : //  standalone mode.
<span class="lineNum">     153 </span>            : // Use Case:
<span class="lineNum">     154 </span>            : //  root [0] AliPHOSClusterizerv1 * cl = new AliPHOSClusterizerv1(&lt;pointer_to_phos_geometry_onject&gt;)  
<span class="lineNum">     155 </span>            : //  root [1] cl-&gt;Digits2Clusters(digitsTree,clusterTree)
<span class="lineNum">     156 </span>            : //               //finds RecPoints in the current event
<span class="lineNum">     157 </span>            : //  root [2] cl-&gt;SetDigitsBranch(&quot;digits2&quot;) 
<span class="lineNum">     158 </span>            : //               //sets another title for Digitis (input) branch
<span class="lineNum">     159 </span>            : //  root [3] cl-&gt;SetRecPointsBranch(&quot;recp2&quot;)  
<span class="lineNum">     160 </span>            : //               //sets another title four output branches
<span class="lineNum">     161 </span>            : //  root [4] cl-&gt;SetEmcLocalMaxCut(0.03)  
<span class="lineNum">     162 </span>            : //               //set clusterization parameters
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            : // --- ROOT system ---
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            : #include &quot;TMath.h&quot; 
<span class="lineNum">     167 </span>            : #include &quot;TMinuit.h&quot;
<span class="lineNum">     168 </span>            : #include &quot;TTree.h&quot; 
<span class="lineNum">     169 </span>            : #include &quot;TBenchmark.h&quot;
<span class="lineNum">     170 </span>            : #include &quot;TClonesArray.h&quot;
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            : // --- Standard library ---
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span>            : // --- AliRoot header files ---
<span class="lineNum">     175 </span>            : #include &quot;AliLog.h&quot;
<span class="lineNum">     176 </span>            : #include &quot;AliConfig.h&quot;
<span class="lineNum">     177 </span>            : #include &quot;AliPHOSGeometry.h&quot; 
<span class="lineNum">     178 </span>            : #include &quot;AliPHOSClusterizerv1.h&quot;
<span class="lineNum">     179 </span>            : #include &quot;AliPHOSEmcRecPoint.h&quot;
<span class="lineNum">     180 </span>            : #include &quot;AliPHOSCpvRecPoint.h&quot;
<span class="lineNum">     181 </span>            : #include &quot;AliPHOSDigit.h&quot;
<span class="lineNum">     182 </span>            : #include &quot;AliPHOSDigitizer.h&quot;
<span class="lineNum">     183 </span>            : #include &quot;AliCDBManager.h&quot;
<span class="lineNum">     184 </span>            : #include &quot;AliCDBStorage.h&quot;
<span class="lineNum">     185 </span>            : #include &quot;AliCDBEntry.h&quot;
<span class="lineNum">     186 </span>            : #include &quot;AliPHOSRecoParam.h&quot;
<span class="lineNum">     187 </span>            : #include &quot;AliPHOSReconstructor.h&quot;
<a name="188"><span class="lineNum">     188 </span>            : #include &quot;AliPHOSCalibData.h&quot;</a>
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span><span class="lineCov">         22 : ClassImp(AliPHOSClusterizerv1)</span>
<a name="191"><span class="lineNum">     191 </span>            :   </a>
<span class="lineNum">     192 </span>            : //____________________________________________________________________________
<span class="lineNum">     193 </span>            : AliPHOSClusterizerv1::AliPHOSClusterizerv1() :
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :   AliPHOSClusterizer(),</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :   fDefaultInit(0),            fEmcCrystals(0),          fToUnfold(0),  fToUnfoldCPV(0),</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :   fWrite(0),                  </span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :   fNumberOfEmcClusters(0),    fNumberOfCpvClusters(0),</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :   fEmcClusteringThreshold(0), fCpvClusteringThreshold(0), </span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :   fEmcLocMaxCut(0),           fW0(0),                   fCpvLocMaxCut(0),</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :   fW0CPV(0),                 </span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :   fTimeGateLowAmp(0.),        fTimeGateLow(0.),         fTimeGateHigh(0.),  </span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :   fEcoreRadius(0)</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">     204 </span>            :   // default ctor (to be used mainly by Streamer)
<span class="lineNum">     205 </span>            :   
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :   fDefaultInit = kTRUE ;</span>
<span class="lineNum">     207 </span>            :   
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :   for(Int_t i=0; i&lt;53760; i++){</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :     fDigitsUsed[i]=0 ;</span>
<span class="lineNum">     210 </span>            :   }
<span class="lineNum">     211 </span><span class="lineNoCov">          0 : }</span>
<a name="212"><span class="lineNum">     212 </span>            : </a>
<span class="lineNum">     213 </span>            : //____________________________________________________________________________
<span class="lineNum">     214 </span>            : AliPHOSClusterizerv1::AliPHOSClusterizerv1(AliPHOSGeometry *geom) :
<span class="lineNum">     215 </span><span class="lineCov">          2 :   AliPHOSClusterizer(geom),</span>
<span class="lineNum">     216 </span><span class="lineCov">          2 :   fDefaultInit(0),            fEmcCrystals(0),          fToUnfold(0),  fToUnfoldCPV(0),</span>
<span class="lineNum">     217 </span><span class="lineCov">          2 :   fWrite(0),                </span>
<span class="lineNum">     218 </span><span class="lineCov">          2 :   fNumberOfEmcClusters(0),    fNumberOfCpvClusters(0),</span>
<span class="lineNum">     219 </span><span class="lineCov">          2 :   fEmcClusteringThreshold(0), fCpvClusteringThreshold(0), </span>
<span class="lineNum">     220 </span><span class="lineCov">          2 :   fEmcLocMaxCut(0),           fW0(0),                   fCpvLocMaxCut(0),</span>
<span class="lineNum">     221 </span><span class="lineCov">          2 :   fW0CPV(0),                  </span>
<span class="lineNum">     222 </span><span class="lineCov">          2 :   fTimeGateLowAmp(0.),        fTimeGateLow(0.),         fTimeGateHigh(0.),  </span>
<span class="lineNum">     223 </span><span class="lineCov">          2 :   fEcoreRadius(0) </span>
<span class="lineNum">     224 </span><span class="lineCov">         10 : {</span>
<span class="lineNum">     225 </span>            :   // ctor with the indication of the file where header Tree and digits Tree are stored
<span class="lineNum">     226 </span>            :   
<span class="lineNum">     227 </span><span class="lineCov">     215044 :   for(Int_t i=0; i&lt;53760; i++){</span>
<span class="lineNum">     228 </span><span class="lineCov">     107520 :     fDigitsUsed[i]=0 ;</span>
<span class="lineNum">     229 </span>            :   }
<span class="lineNum">     230 </span>            :   
<span class="lineNum">     231 </span><span class="lineCov">          2 :   Init() ;</span>
<span class="lineNum">     232 </span><span class="lineCov">          2 :   fDefaultInit = kFALSE ; </span>
<span class="lineNum">     233 </span><span class="lineCov">          4 : }</span>
<a name="234"><span class="lineNum">     234 </span>            : </a>
<span class="lineNum">     235 </span>            : //____________________________________________________________________________
<span class="lineNum">     236 </span>            :   AliPHOSClusterizerv1::~AliPHOSClusterizerv1()
<span class="lineNum">     237 </span><span class="lineCov">          8 : {</span>
<span class="lineNum">     238 </span>            :   // dtor
<span class="lineNum">     239 </span>            : 
<a name="240"><span class="lineNum">     240 </span><span class="lineCov">          8 : }</span></a>
<span class="lineNum">     241 </span>            : //____________________________________________________________________________
<span class="lineNum">     242 </span>            : void AliPHOSClusterizerv1::Digits2Clusters(Option_t *option)
<span class="lineNum">     243 </span>            : {
<span class="lineNum">     244 </span>            :   // Steering method to perform clusterization for one event
<span class="lineNum">     245 </span>            :   // The input is the tree with digits.
<span class="lineNum">     246 </span>            :   // The output is the tree with clusters.
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span><span class="lineCov">         16 :   if(strstr(option,&quot;tim&quot;))</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :     gBenchmark-&gt;Start(&quot;PHOSClusterizer&quot;); </span>
<span class="lineNum">     250 </span>            :   
<span class="lineNum">     251 </span><span class="lineCov">          8 :   if(strstr(option,&quot;print&quot;)) {</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :     Print() ; </span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :     return ;</span>
<span class="lineNum">     254 </span>            :   }
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span><span class="lineCov">          8 :   MakeClusters() ;</span>
<span class="lineNum">     257 </span>            :     
<span class="lineNum">     258 </span><span class="lineCov">         24 :   AliDebug(2,Form(&quot;Number of EMC clusters: %d, CPV clusters: %d\n&quot;,</span>
<span class="lineNum">     259 </span>            :                   fEMCRecPoints-&gt;GetEntriesFast(), fCPVRecPoints-&gt;GetEntriesFast()));
<span class="lineNum">     260 </span><span class="lineCov">          8 :   if(AliLog::GetGlobalDebugLevel()&gt;1) {</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :     fEMCRecPoints-&gt;Print();</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :     fCPVRecPoints-&gt;Print();</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span><span class="lineCov">          8 :   MakeUnfolding();</span>
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span><span class="lineCov">          8 :   WriteRecPoints();</span>
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span><span class="lineCov">          8 :   if(strstr(option,&quot;deb&quot;))  </span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :     PrintRecPoints(option) ;</span>
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span><span class="lineCov">          8 :   if(strstr(option,&quot;tim&quot;)){</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :     gBenchmark-&gt;Stop(&quot;PHOSClusterizer&quot;);</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :     AliInfo(Form(&quot;took %f seconds for Clusterizing\n&quot;,</span>
<span class="lineNum">     275 </span>            :                  gBenchmark-&gt;GetCpuTime(&quot;PHOSClusterizer&quot;))); 
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     277 </span><span class="lineCov">          8 :   fEMCRecPoints-&gt;Delete();</span>
<span class="lineNum">     278 </span><span class="lineCov">          8 :   fCPVRecPoints-&gt;Delete();</span>
<span class="lineNum">     279 </span><span class="lineCov">         16 : }</span>
<a name="280"><span class="lineNum">     280 </span>            : </a>
<span class="lineNum">     281 </span>            : //____________________________________________________________________________
<span class="lineNum">     282 </span>            : Bool_t AliPHOSClusterizerv1::FindFit(AliPHOSEmcRecPoint * emcRP, AliPHOSDigit ** maxAt, Float_t * maxAtEnergy,
<span class="lineNum">     283 </span>            :                                     Int_t nPar, Float_t * fitparameters) const
<span class="lineNum">     284 </span>            : { 
<span class="lineNum">     285 </span>            :   // Calls TMinuit to fit the energy distribution of a cluster with several maxima 
<span class="lineNum">     286 </span>            :   // The initial values for fitting procedure are set equal to the positions of local maxima.
<span class="lineNum">     287 </span>            :   // Cluster will be fitted as a superposition of nPar/3 electromagnetic showers
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            :   
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :   if(!gMinuit) //it was deleted by someone else</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :     gMinuit = new TMinuit(100) ;</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :   gMinuit-&gt;mncler();                     // Reset Minuit's list of paramters</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :   gMinuit-&gt;SetPrintLevel(-1) ;           // No Printout</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :   gMinuit-&gt;SetFCN(AliPHOSClusterizerv1::UnfoldingChiSquare) ;  </span>
<span class="lineNum">     295 </span>            :                                          // To set the address of the minimization function 
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :   TList * toMinuit = new TList();</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :   toMinuit-&gt;AddAt(emcRP,0) ;</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :   toMinuit-&gt;AddAt(fDigitsArr,1) ;</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :   toMinuit-&gt;AddAt(fGeom,2) ;</span>
<span class="lineNum">     301 </span>            :   
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :   gMinuit-&gt;SetObjectFit(toMinuit) ;         // To tranfer pointer to UnfoldingChiSquare</span>
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span>            :   // filling initial values for fit parameters
<span class="lineNum">     305 </span>            :   AliPHOSDigit * digit ;
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :   Int_t ierflg  = 0; </span>
<span class="lineNum">     308 </span>            :   Int_t index   = 0 ;
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :   Int_t nDigits = (Int_t) nPar / 3 ;</span>
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            :   Int_t iDigit ;
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :   for(iDigit = 0; iDigit &lt; nDigits; iDigit++){</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :     digit = maxAt[iDigit]; </span>
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :     Int_t relid[4] ;</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :     Float_t x = 0.;</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :     Float_t z = 0.;</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :     fGeom-&gt;AbsToRelNumbering(digit-&gt;GetId(), relid) ;</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :     fGeom-&gt;RelPosInModule(relid, x, z) ;</span>
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :     Float_t energy = maxAtEnergy[iDigit] ;</span>
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :     gMinuit-&gt;mnparm(index, &quot;x&quot;,  x, 0.1, 0, 0, ierflg) ;</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :     index++ ;   </span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :     if(ierflg != 0){ </span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :       Warning(&quot;FindFit&quot;, &quot;PHOS Unfolding unable to set initial value for fit procedure : x = %f\n&quot;, x ) ;</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :       return kFALSE;</span>
<span class="lineNum">     329 </span>            :     }
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :     gMinuit-&gt;mnparm(index, &quot;z&quot;,  z, 0.1, 0, 0, ierflg) ;</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :     index++ ;   </span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :     if(ierflg != 0){</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :        Warning(&quot;FindFit&quot;, &quot;PHOS Unfolding unable to set initial value for fit procedure : z =%f\n&quot;, z ) ;</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :       return kFALSE;</span>
<span class="lineNum">     335 </span>            :     }
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :     gMinuit-&gt;mnparm(index, &quot;Energy&quot;,  energy , 0.05*energy, 0., 4.*energy, ierflg) ;</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :     index++ ;   </span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :     if(ierflg != 0){</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :       Warning(&quot;FindFit&quot;, &quot;PHOS Unfolding unable to set initial value for fit procedure : energy = %f\n&quot;, energy ) ;      </span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :       return kFALSE;</span>
<span class="lineNum">     341 </span>            :     }
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :   Double_t p0 = 0.1 ; // &quot;Tolerance&quot; Evaluation stops when EDM = 0.0001*p0 ; The number of function call slightly</span>
<span class="lineNum">     345 </span>            :                       //  depends on it. 
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :   Double_t p1 = 1.0 ;</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :   Double_t p2 = 0.0 ;</span>
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :   gMinuit-&gt;mnexcm(&quot;SET STR&quot;, &amp;p2, 0, ierflg) ;   // force TMinuit to reduce function calls  </span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :   gMinuit-&gt;mnexcm(&quot;SET GRA&quot;, &amp;p1, 1, ierflg) ;   // force TMinuit to use my gradient  </span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :   gMinuit-&gt;SetMaxIterations(5);</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :   gMinuit-&gt;mnexcm(&quot;SET NOW&quot;, &amp;p2 , 0, ierflg) ;  // No Warnings</span>
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :   gMinuit-&gt;mnexcm(&quot;MIGRAD&quot;, &amp;p0, 0, ierflg) ;    // minimize </span>
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :   if(ierflg == 4){  // Minimum not found   </span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :     Warning(&quot;FindFit&quot;, &quot;PHOS Unfolding fit not converged, cluster abandoned\n&quot; );      </span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :     return kFALSE ;</span>
<span class="lineNum">     359 </span>            :   }            
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :   for(index = 0; index &lt; nPar; index++){</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :     Double_t err ;</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :     Double_t val ;</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :     gMinuit-&gt;GetParameter(index, val, err) ;    // Returns value and error of parameter index</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :     fitparameters[index] = val ;</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :    }</span>
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :   delete toMinuit ;</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :   return kTRUE;</span>
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     371 </span>            : 
<a name="372"><span class="lineNum">     372 </span>            : </a>
<span class="lineNum">     373 </span>            : //____________________________________________________________________________
<span class="lineNum">     374 </span>            : void AliPHOSClusterizerv1::Init()
<span class="lineNum">     375 </span>            : {
<span class="lineNum">     376 </span>            :   // Make all memory allocations which can not be done in default constructor.
<span class="lineNum">     377 </span>            :   // Attach the Clusterizer task to the list of PHOS tasks
<span class="lineNum">     378 </span>            :  
<span class="lineNum">     379 </span><span class="lineCov">          4 :   fEmcCrystals = fGeom-&gt;GetNModules() *  fGeom-&gt;GetNCristalsInModule() ;</span>
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span><span class="lineCov">          2 :   if(!gMinuit) </span>
<span class="lineNum">     382 </span><span class="lineCov">          4 :     gMinuit = new TMinuit(100);</span>
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span><span class="lineCov">          2 :   if (!fgCalibData) </span>
<span class="lineNum">     385 </span><span class="lineCov">          4 :     fgCalibData = new AliPHOSCalibData(-1); //use AliCDBManager's run number</span>
<span class="lineNum">     386 </span><span class="lineCov">          2 :   if (fgCalibData-&gt;GetCalibDataEmc() == 0)</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :     AliFatal(&quot;Calibration parameters for PHOS EMC not found. Stop reconstruction.\n&quot;);</span>
<span class="lineNum">     388 </span><span class="lineCov">          2 :   if (fgCalibData-&gt;GetCalibDataCpv() == 0)   </span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :     AliFatal(&quot;Calibration parameters for PHOS CPV not found. Stop reconstruction.\n&quot;);   </span>
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span><span class="lineCov">          2 : }</span>
<a name="392"><span class="lineNum">     392 </span>            : </a>
<span class="lineNum">     393 </span>            : //____________________________________________________________________________
<span class="lineNum">     394 </span>            : void AliPHOSClusterizerv1::InitParameters()
<span class="lineNum">     395 </span>            : {
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span><span class="lineCov">         16 :   fNumberOfCpvClusters     = 0 ; </span>
<span class="lineNum">     398 </span><span class="lineCov">          8 :   fNumberOfEmcClusters     = 0 ; </span>
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span><span class="lineCov">          8 :   const AliPHOSRecoParam* recoParam = AliPHOSReconstructor::GetRecoParam();</span>
<span class="lineNum">     401 </span><span class="lineCov">          8 :   if(!recoParam) AliFatal(&quot;Reconstruction parameters are not set!&quot;);</span>
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span><span class="lineCov">          8 :   recoParam-&gt;Print();</span>
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span><span class="lineCov">          8 :   fEmcClusteringThreshold  = recoParam-&gt;GetEMCClusteringThreshold();</span>
<span class="lineNum">     406 </span><span class="lineCov">          8 :   fCpvClusteringThreshold  = recoParam-&gt;GetCPVClusteringThreshold();</span>
<span class="lineNum">     407 </span>            :   
<span class="lineNum">     408 </span><span class="lineCov">          8 :   fEmcLocMaxCut            = recoParam-&gt;GetEMCLocalMaxCut();</span>
<span class="lineNum">     409 </span><span class="lineCov">          8 :   fCpvLocMaxCut            = recoParam-&gt;GetCPVLocalMaxCut();</span>
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span><span class="lineCov">          8 :   fW0                      = recoParam-&gt;GetEMCLogWeight();</span>
<span class="lineNum">     412 </span><span class="lineCov">          8 :   fW0CPV                   = recoParam-&gt;GetCPVLogWeight();</span>
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span><span class="lineCov">          8 :   fTimeGateLowAmp          = recoParam-&gt;GetTimeGateAmpThresh() ;</span>
<span class="lineNum">     415 </span><span class="lineCov">          8 :   fTimeGateLow             = recoParam-&gt;GetTimeGateLow() ;</span>
<span class="lineNum">     416 </span><span class="lineCov">          8 :   fTimeGateHigh            = recoParam-&gt;GetTimeGateHigh() ;</span>
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span><span class="lineCov">          8 :   fEcoreRadius             = recoParam-&gt;GetEMCEcoreRadius();</span>
<span class="lineNum">     419 </span>            :   
<span class="lineNum">     420 </span><span class="lineCov">          8 :   fToUnfold                = recoParam-&gt;EMCToUnfold() ;</span>
<span class="lineNum">     421 </span><span class="lineCov">          8 :   fToUnfoldCPV             = recoParam-&gt;CPVToUnfold() ;</span>
<span class="lineNum">     422 </span>            :     
<span class="lineNum">     423 </span><span class="lineCov">          8 :   fWrite                   = kTRUE ;</span>
<span class="lineNum">     424 </span><span class="lineCov">          8 : }</span>
<a name="425"><span class="lineNum">     425 </span>            : </a>
<span class="lineNum">     426 </span>            : //____________________________________________________________________________
<span class="lineNum">     427 </span>            : Int_t AliPHOSClusterizerv1::AreNeighbours(AliPHOSDigit * d1, AliPHOSDigit * d2)const
<span class="lineNum">     428 </span>            : {
<span class="lineNum">     429 </span>            :   // Gives the neighbourness of two digits = 0 are not neighbour but continue searching 
<span class="lineNum">     430 </span>            :   //                                       = 1 are neighbour
<span class="lineNum">     431 </span>            :   //                                       = 2 are not neighbour but do not continue searching
<span class="lineNum">     432 </span>            :   //                                       =-1 are not neighbour, continue searching, but do not look before d2 next time
<span class="lineNum">     433 </span>            :   // neighbours are defined as digits having at least a common vertex 
<span class="lineNum">     434 </span>            :   // The order of d1 and d2 is important: first (d1) should be a digit already in a cluster 
<span class="lineNum">     435 </span>            :   //                                      which is compared to a digit (d2)  not yet in a cluster  
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span><span class="lineCov">       2150 :   Int_t relid1[4] ; </span>
<span class="lineNum">     438 </span><span class="lineCov">       1075 :   fGeom-&gt;AbsToRelNumbering(d1-&gt;GetId(), relid1) ; </span>
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span><span class="lineCov">       1075 :   Int_t relid2[4] ; </span>
<span class="lineNum">     441 </span><span class="lineCov">       1075 :   fGeom-&gt;AbsToRelNumbering(d2-&gt;GetId(), relid2) ; </span>
<span class="lineNum">     442 </span>            :  
<span class="lineNum">     443 </span><span class="lineCov">       1963 :   if ( (relid1[0] == relid2[0]) &amp;&amp; (relid1[1]==relid2[1]) ) { // inside the same PHOS module </span>
<span class="lineNum">     444 </span><span class="lineCov">        888 :     Int_t rowdiff = TMath::Abs( relid1[2] - relid2[2] ) ;  </span>
<span class="lineNum">     445 </span><span class="lineCov">        888 :     Int_t coldiff = TMath::Abs( relid1[3] - relid2[3] ) ;  </span>
<span class="lineNum">     446 </span>            :     
<span class="lineNum">     447 </span><span class="lineCov">        888 :     if (( coldiff &lt;= 1 )  &amp;&amp; ( rowdiff &lt;= 1 )){   //At least common vertex</span>
<span class="lineNum">     448 </span>            :       //    if (( relid1[2]==relid2[2] &amp;&amp; coldiff &lt;= 1 )  || ( relid1[3]==relid2[3] &amp;&amp;  rowdiff &lt;= 1 )){ //common side
<span class="lineNum">     449 </span><span class="lineCov">        332 :       if((relid1[1] != 0) || CheckTimeGate(d1-&gt;GetTime(),d1-&gt;GetEnergy(),d2-&gt;GetTime(),d2-&gt;GetEnergy())) </span>
<span class="lineNum">     450 </span><span class="lineCov">        166 :       return 1 ; </span>
<span class="lineNum">     451 </span>            :     }
<span class="lineNum">     452 </span>            :     else {
<span class="lineNum">     453 </span><span class="lineCov">       1104 :       if((relid2[2] &gt; relid1[2]) &amp;&amp; (relid2[3] &gt; relid1[3]+1)) </span>
<span class="lineNum">     454 </span><span class="lineCov">        119 :         return 2; //  Difference in row numbers is too large to look further </span>
<span class="lineNum">     455 </span>            :     }
<span class="lineNum">     456 </span><span class="lineCov">        603 :     return 0 ;</span>
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span>            :   } 
<span class="lineNum">     459 </span>            :   else {
<span class="lineNum">     460 </span><span class="lineCov">        374 :     if(relid1[0] &gt; relid2[0] &amp;&amp; relid1[1]==relid2[1] ) //we switched to the next module</span>
<span class="lineNum">     461 </span><span class="lineCov">        187 :       return -1 ;</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :     if(relid1[1] &lt; relid2[1]) //we switched from EMC(0) to CPV(-1)</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :       return -1 ;</span>
<span class="lineNum">     464 </span>            :     
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :     return 2 ;</span>
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            :   }
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span>            :   return 0 ; 
<a name="470"><span class="lineNum">     470 </span><span class="lineCov">       1075 : }</span></a>
<span class="lineNum">     471 </span>            : //____________________________________________________________________________
<span class="lineNum">     472 </span>            : Bool_t AliPHOSClusterizerv1::CheckTimeGate(Float_t t1, Float_t amp1, Float_t t2, Float_t amp2)const{
<span class="lineNum">     473 </span>            :   //Check if two cells have reasonable time difference
<span class="lineNum">     474 </span>            :   //Note that at low amplitude time is defined up to 1 tick == 100 ns.
<span class="lineNum">     475 </span><span class="lineCov">        478 :   if(amp1&lt;fTimeGateLowAmp || amp2&lt;fTimeGateLowAmp){</span>
<span class="lineNum">     476 </span><span class="lineCov">         88 :    return (TMath::Abs(t1 - t2 ) &lt; fTimeGateLow) ;</span>
<span class="lineNum">     477 </span>            :   }
<span class="lineNum">     478 </span>            :   else{ //Time should be measured with good accuracy
<span class="lineNum">     479 </span><span class="lineCov">         78 :    return (TMath::Abs(t1 - t2 ) &lt; fTimeGateHigh) ;</span>
<span class="lineNum">     480 </span>            :   }
<span class="lineNum">     481 </span>            : 
<a name="482"><span class="lineNum">     482 </span><span class="lineCov">        166 : }</span></a>
<span class="lineNum">     483 </span>            : //____________________________________________________________________________
<span class="lineNum">     484 </span>            : Bool_t AliPHOSClusterizerv1::IsInEmc(AliPHOSDigit * digit) const
<span class="lineNum">     485 </span>            : {
<span class="lineNum">     486 </span>            :   // Tells if (true) or not (false) the digit is in a PHOS-EMC module
<span class="lineNum">     487 </span>            :  
<span class="lineNum">     488 </span>            :   Bool_t rv = kFALSE ; 
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span><span class="lineCov">        284 :   Int_t nEMC = fGeom-&gt;GetNModules()*fGeom-&gt;GetNPhi()*fGeom-&gt;GetNZ();  </span>
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span><span class="lineCov">        284 :   if(digit-&gt;GetId() &lt;= nEMC )   rv = kTRUE; </span>
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span><span class="lineCov">        142 :   return rv ; </span>
<span class="lineNum">     495 </span>            : }
<a name="496"><span class="lineNum">     496 </span>            : </a>
<span class="lineNum">     497 </span>            : //____________________________________________________________________________
<span class="lineNum">     498 </span>            : Bool_t AliPHOSClusterizerv1::IsInCpv(AliPHOSDigit * digit) const
<span class="lineNum">     499 </span>            : {
<span class="lineNum">     500 </span>            :   // Tells if (true) or not (false) the digit is in a PHOS-CPV module
<span class="lineNum">     501 </span>            :  
<span class="lineNum">     502 </span>            :   Bool_t rv = kFALSE ; 
<span class="lineNum">     503 </span>            :   
<span class="lineNum">     504 </span><span class="lineCov">        244 :   Int_t nEMC = fGeom-&gt;GetNModules()*fGeom-&gt;GetNPhi()*fGeom-&gt;GetNZ();</span>
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span><span class="lineCov">        122 :   if(digit-&gt;GetId() &gt; nEMC )   rv = kTRUE;</span>
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span><span class="lineCov">        122 :   return rv ; </span>
<span class="lineNum">     509 </span>            : }
<a name="510"><span class="lineNum">     510 </span>            : </a>
<span class="lineNum">     511 </span>            : //____________________________________________________________________________
<span class="lineNum">     512 </span>            : void AliPHOSClusterizerv1::WriteRecPoints()
<span class="lineNum">     513 </span>            : {
<span class="lineNum">     514 </span>            : 
<span class="lineNum">     515 </span>            :   // Creates new branches with given title
<span class="lineNum">     516 </span>            :   // fills and writes into TreeR.
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span>            :   Int_t index ;
<span class="lineNum">     519 </span>            :   //Evaluate position, dispersion and other RecPoint properties..
<span class="lineNum">     520 </span><span class="lineCov">         16 :   Int_t nEmc = fEMCRecPoints-&gt;GetEntriesFast();</span>
<span class="lineNum">     521 </span><span class="lineCov">          8 :   Float_t emcMinE= AliPHOSReconstructor::GetRecoParam()-&gt;GetEMCMinE(); //Minimal digit energy</span>
<span class="lineNum">     522 </span><span class="lineCov">          8 :   TVector3 fakeVtx(0.,0.,0.) ;</span>
<span class="lineNum">     523 </span><span class="lineCov">         36 :   for(index = 0; index &lt; nEmc; index++){</span>
<span class="lineNum">     524 </span>            :     AliPHOSEmcRecPoint * rp =
<span class="lineNum">     525 </span><span class="lineCov">         20 :       static_cast&lt;AliPHOSEmcRecPoint *&gt;( fEMCRecPoints-&gt;At(index) );</span>
<span class="lineNum">     526 </span><span class="lineCov">         10 :     rp-&gt;Purify(emcMinE,fDigitsArr) ;</span>
<span class="lineNum">     527 </span><span class="lineCov">         10 :     if(rp-&gt;GetMultiplicity()==0){</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :       fEMCRecPoints-&gt;RemoveAt(index) ;</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :       delete rp ;</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">     531 </span>            :     }
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span>            :     // No vertex is available now, calculate corrections in PID
<span class="lineNum">     534 </span><span class="lineCov">         10 :     rp-&gt;EvalAll(fDigitsArr) ;</span>
<span class="lineNum">     535 </span><span class="lineCov">         10 :     rp-&gt;EvalCoreEnergy(fW0,fEcoreRadius,fDigitsArr) ;</span>
<span class="lineNum">     536 </span><span class="lineCov">         10 :     rp-&gt;EvalAll(fW0,fakeVtx,fDigitsArr) ;</span>
<span class="lineNum">     537 </span><span class="lineCov">         10 :     rp-&gt;EvalLocal2TrackingCSTransform();</span>
<span class="lineNum">     538 </span><span class="lineCov">         10 :   }</span>
<span class="lineNum">     539 </span><span class="lineCov">          8 :   fEMCRecPoints-&gt;Compress() ;</span>
<span class="lineNum">     540 </span><span class="lineCov">          8 :   fEMCRecPoints-&gt;Sort() ; </span>
<span class="lineNum">     541 </span>            :   //  fEMCRecPoints-&gt;Expand(fEMCRecPoints-&gt;GetEntriesFast()) ;
<span class="lineNum">     542 </span><span class="lineCov">         54 :   for(index = 0; index &lt; fEMCRecPoints-&gt;GetEntries(); index++){</span>
<span class="lineNum">     543 </span><span class="lineCov">         20 :     static_cast&lt;AliPHOSEmcRecPoint *&gt;( fEMCRecPoints-&gt;At(index) )-&gt;SetIndexInList(index) ;</span>
<span class="lineNum">     544 </span>            :   }
<span class="lineNum">     545 </span>            :   
<span class="lineNum">     546 </span>            :   //For each rec.point set the distance to the nearest bad crystal (BVP)
<span class="lineNum">     547 </span><span class="lineCov">          8 :   SetDistancesToBadChannels();</span>
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span>            :   //Now the same for CPV
<span class="lineNum">     550 </span><span class="lineCov">         16 :   Float_t cpvMinE= AliPHOSReconstructor::GetRecoParam()-&gt;GetCPVMinE(); //Minimal digit energy</span>
<span class="lineNum">     551 </span><span class="lineCov">         24 :   for(index = 0; index &lt; fCPVRecPoints-&gt;GetEntries(); index++){</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :     AliPHOSCpvRecPoint * rp = static_cast&lt;AliPHOSCpvRecPoint *&gt;( fCPVRecPoints-&gt;At(index) );</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :     rp-&gt;Purify(cpvMinE,fDigitsArr) ;</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :     if(rp-&gt;GetMultiplicity()==0){</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :       fCPVRecPoints-&gt;RemoveAt(index) ;</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :       delete rp ;</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">     558 </span>            :     } 
<span class="lineNum">     559 </span>            :     
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :     rp-&gt;EvalAll(fDigitsArr) ;</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :     rp-&gt;EvalAll(fW0CPV,fakeVtx,fDigitsArr) ;</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :     rp-&gt;EvalLocal2TrackingCSTransform();</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     564 </span><span class="lineCov">          8 :   fCPVRecPoints-&gt;Sort() ;</span>
<span class="lineNum">     565 </span>            :   
<span class="lineNum">     566 </span><span class="lineCov">         32 :   for(index = 0; index &lt; fCPVRecPoints-&gt;GetEntries(); index++)</span>
<span class="lineNum">     567 </span><span class="lineCov">          8 :     static_cast&lt;AliPHOSCpvRecPoint *&gt;( fCPVRecPoints-&gt;At(index) )-&gt;SetIndexInList(index) ;</span>
<span class="lineNum">     568 </span>            :   
<span class="lineNum">     569 </span><span class="lineCov">         16 :   fCPVRecPoints-&gt;Expand(fCPVRecPoints-&gt;GetEntriesFast()) ;</span>
<span class="lineNum">     570 </span>            :   
<span class="lineNum">     571 </span><span class="lineCov">          8 :   if(fWrite){ //We write TreeR</span>
<span class="lineNum">     572 </span><span class="lineCov">          8 :     fTreeR-&gt;Fill();</span>
<span class="lineNum">     573 </span>            :   }
<span class="lineNum">     574 </span><span class="lineCov">          8 : }</span>
<a name="575"><span class="lineNum">     575 </span>            : </a>
<span class="lineNum">     576 </span>            : //____________________________________________________________________________
<span class="lineNum">     577 </span>            : void AliPHOSClusterizerv1::MakeClusters()
<span class="lineNum">     578 </span>            : {
<span class="lineNum">     579 </span>            :   // Steering method to construct the clusters stored in a list of Reconstructed Points
<span class="lineNum">     580 </span>            :   // A cluster is defined as a list of neighbour digits
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span><span class="lineCov">         16 :   fNumberOfCpvClusters     = 0 ;</span>
<span class="lineNum">     583 </span><span class="lineCov">          8 :   fNumberOfEmcClusters     = 0 ;</span>
<span class="lineNum">     584 </span>            : 
<span class="lineNum">     585 </span>            :   //Mark all digits as unused yet
<span class="lineNum">     586 </span>            :   const Int_t maxNDigits = 3584; // There is no clusters larger than PHOS module ;)
<span class="lineNum">     587 </span><span class="lineCov">          8 :   Int_t nDigits=fDigitsArr-&gt;GetEntriesFast() ;</span>
<span class="lineNum">     588 </span>            : 
<span class="lineNum">     589 </span><span class="lineCov">        480 :   for(Int_t i=0; i&lt;nDigits; i++){</span>
<span class="lineNum">     590 </span><span class="lineCov">        232 :     fDigitsUsed[i]=0 ;</span>
<span class="lineNum">     591 </span>            :   }
<span class="lineNum">     592 </span>            :   Int_t iFirst = 0 ; //first index of digit which potentially can be a part of cluster
<span class="lineNum">     593 </span>            :                      //e.g. first digit in this module, first CPV digit etc.
<span class="lineNum">     594 </span>            :   AliPHOSDigit * digit ; 
<span class="lineNum">     595 </span><span class="lineCov">          8 :   TArrayI clusterdigitslist(maxNDigits) ;   </span>
<span class="lineNum">     596 </span>            :   AliPHOSRecPoint * clu = 0 ; 
<span class="lineNum">     597 </span><span class="lineCov">        488 :   for(Int_t i=0; i&lt;nDigits; i++){</span>
<span class="lineNum">     598 </span><span class="lineCov">        232 :     if(fDigitsUsed[i])</span>
<span class="lineNum">     599 </span>            :       continue ;
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span><span class="lineCov">        264 :     digit=static_cast&lt;AliPHOSDigit*&gt;(fDigitsArr-&gt;At(i)) ;</span>
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span>            :     clu=0 ;
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span>            :     Int_t index ;
<span class="lineNum">     606 </span>            : 
<span class="lineNum">     607 </span>            :     //is this digit so energetic that start cluster?
<span class="lineNum">     608 </span><span class="lineCov">        660 :     AliDebug(2,Form(&quot;Digit %d, energy=%f, ID=%d&quot;,i,digit-&gt;GetEnergy(),digit-&gt;GetId()));</span>
<span class="lineNum">     609 </span><span class="lineCov">        528 :     if (( IsInEmc(digit) &amp;&amp;  Calibrate(digit-&gt;GetEnergy(),digit-&gt;GetId()) &gt; fEmcClusteringThreshold ) || </span>
<span class="lineNum">     610 </span><span class="lineCov">        244 :         ( IsInCpv(digit) &amp;&amp;  Calibrate(digit-&gt;GetEnergy(),digit-&gt;GetId()) &gt; fCpvClusteringThreshold ) ) {</span>
<span class="lineNum">     611 </span>            :       Int_t iDigitInCluster = 0 ; 
<span class="lineNum">     612 </span><span class="lineCov">         20 :       if  ( IsInEmc(digit) ) {   </span>
<span class="lineNum">     613 </span>            :         // start a new EMC RecPoint
<span class="lineNum">     614 </span><span class="lineCov">         20 :         if(fNumberOfEmcClusters &gt;= fEMCRecPoints-&gt;GetSize()) </span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :           fEMCRecPoints-&gt;Expand(2*fNumberOfEmcClusters+1) ;</span>
<span class="lineNum">     616 </span>            :           
<span class="lineNum">     617 </span><span class="lineCov">         30 :         fEMCRecPoints-&gt;AddAt(new  AliPHOSEmcRecPoint(&quot;&quot;), fNumberOfEmcClusters) ;</span>
<span class="lineNum">     618 </span><span class="lineCov">         20 :         clu = static_cast&lt;AliPHOSEmcRecPoint *&gt;( fEMCRecPoints-&gt;At(fNumberOfEmcClusters) ) ; </span>
<span class="lineNum">     619 </span><span class="lineCov">         10 :         fNumberOfEmcClusters++ ; </span>
<span class="lineNum">     620 </span><span class="lineCov">         30 :         clu-&gt;AddDigit(*digit, Calibrate(digit-&gt;GetEnergy(),digit-&gt;GetId()),CalibrateT(digit-&gt;GetTime(),digit-&gt;GetId(),digit-&gt;IsLG())) ;</span>
<span class="lineNum">     621 </span><span class="lineCov">         20 :         clusterdigitslist[iDigitInCluster] = digit-&gt;GetIndexInList() ;</span>
<span class="lineNum">     622 </span>            :         iDigitInCluster++ ;
<span class="lineNum">     623 </span><span class="lineCov">         10 :         fDigitsUsed[i]=kTRUE ; </span>
<span class="lineNum">     624 </span><span class="lineCov">         10 :       } else { </span>
<span class="lineNum">     625 </span>            :         // start a new CPV cluster
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :         if(fNumberOfCpvClusters &gt;= fCPVRecPoints-&gt;GetSize()) </span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :           fCPVRecPoints-&gt;Expand(2*fNumberOfCpvClusters+1);</span>
<span class="lineNum">     628 </span>            : 
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :         fCPVRecPoints-&gt;AddAt(new AliPHOSCpvRecPoint(&quot;&quot;), fNumberOfCpvClusters) ;</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :         clu =  static_cast&lt;AliPHOSCpvRecPoint *&gt;( fCPVRecPoints-&gt;At(fNumberOfCpvClusters) ) ;  </span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :         fNumberOfCpvClusters++ ; </span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :         clu-&gt;AddDigit(*digit,  Calibrate(digit-&gt;GetEnergy(),digit-&gt;GetId()),0.) ; // no timing information in CPV</span>
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :         clusterdigitslist[iDigitInCluster] = digit-&gt;GetIndexInList()  ;        </span>
<span class="lineNum">     634 </span>            :         iDigitInCluster++ ; 
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :         fDigitsUsed[i]=kTRUE ;</span>
<span class="lineNum">     636 </span>            :       } // else        
<span class="lineNum">     637 </span>            : 
<span class="lineNum">     638 </span>            :       //Now scan remaining digits in list to find neigbours of our seed
<span class="lineNum">     639 </span>            :  
<span class="lineNum">     640 </span>            :       AliPHOSDigit * digitN ; 
<span class="lineNum">     641 </span>            :       index = 0 ;
<span class="lineNum">     642 </span><span class="lineCov">        196 :       while (index &lt; iDigitInCluster){ // scan over digits already in cluster </span>
<span class="lineNum">     643 </span><span class="lineCov">        528 :         digit =  static_cast&lt;AliPHOSDigit*&gt;( fDigitsArr-&gt;At(clusterdigitslist[index]) )  ;      </span>
<span class="lineNum">     644 </span><span class="lineCov">        176 :         index++ ; </span>
<span class="lineNum">     645 </span><span class="lineCov">       8089 :         for(Int_t j=iFirst; j&lt;nDigits; j++){</span>
<span class="lineNum">     646 </span><span class="lineCov">       3959 :           if (iDigitInCluster &gt;= maxNDigits) {</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :             AliError(Form(&quot;The number of digits in cluster is more than %d, skip the rest of event&quot;,</span>
<span class="lineNum">     648 </span>            :                           maxNDigits));
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     650 </span>            :           }
<span class="lineNum">     651 </span><span class="lineCov">       3959 :           if(fDigitsUsed[j]) </span>
<span class="lineNum">     652 </span>            :             continue ;        //look through remaining digits
<span class="lineNum">     653 </span><span class="lineCov">       2150 :           digitN = static_cast&lt;AliPHOSDigit*&gt;( fDigitsArr-&gt;At(j) ) ;</span>
<span class="lineNum">     654 </span><span class="lineCov">       1075 :           Int_t ineb = AreNeighbours(digit, digitN);       // call (digit,digitN) in THAT oder !!!!!</span>
<span class="lineNum">     655 </span><span class="lineCov">       1262 :           switch (ineb ) {</span>
<span class="lineNum">     656 </span>            :           case -1:   //too early (e.g. previous module), do not look before j at subsequent passes
<span class="lineNum">     657 </span>            :             iFirst=j ;
<span class="lineNum">     658 </span><span class="lineCov">        187 :             break ;</span>
<span class="lineNum">     659 </span>            :           case 0 :   // not a neighbour
<span class="lineNum">     660 </span>            :             break ;
<span class="lineNum">     661 </span>            :           case 1 :   // are neighbours 
<span class="lineNum">     662 </span><span class="lineCov">        498 :             clu-&gt;AddDigit(*digitN, Calibrate(digitN-&gt;GetEnergy(),digitN-&gt;GetId()),CalibrateT(digitN-&gt;GetTime(),digitN-&gt;GetId(),digit-&gt;IsLG())) ;</span>
<span class="lineNum">     663 </span><span class="lineCov">        332 :             clusterdigitslist[iDigitInCluster] = j ; </span>
<span class="lineNum">     664 </span><span class="lineCov">        166 :             iDigitInCluster++ ; </span>
<span class="lineNum">     665 </span><span class="lineCov">        166 :             fDigitsUsed[j]=kTRUE ;</span>
<span class="lineNum">     666 </span><span class="lineCov">        166 :             break ;</span>
<span class="lineNum">     667 </span>            :           case 2 :   // too far from each other
<span class="lineNum">     668 </span><span class="lineCov">        119 :             goto endOfLoop;   </span>
<span class="lineNum">     669 </span>            :           } // switch
<span class="lineNum">     670 </span>            :           
<span class="lineNum">     671 </span><span class="lineCov">        956 :         }</span>
<span class="lineNum">     672 </span>            :         
<span class="lineNum">     673 </span>            :         endOfLoop: ; //scanned all possible neighbours for this digit
<span class="lineNum">     674 </span>            :         
<span class="lineNum">     675 </span>            :       } // loop over cluster     
<span class="lineNum">     676 </span><span class="lineCov">         10 :     } // energy theshold  </span>
<span class="lineNum">     677 </span><span class="lineCov">        132 :   }</span>
<span class="lineNum">     678 </span>            : 
<span class="lineNum">     679 </span><span class="lineCov">         16 : }</span>
<a name="680"><span class="lineNum">     680 </span>            : </a>
<span class="lineNum">     681 </span>            : //____________________________________________________________________________
<span class="lineNum">     682 </span>            : void AliPHOSClusterizerv1::MakeUnfolding()
<span class="lineNum">     683 </span>            : {
<span class="lineNum">     684 </span>            :   // Unfolds clusters using the shape of an ElectroMagnetic shower
<span class="lineNum">     685 </span>            :   // Performs unfolding of all EMC/CPV clusters
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span><span class="lineCov">         24 :   if(fToUnfold &amp;&amp; (fNumberOfEmcClusters &gt; 0)){ // Unfold first EMC clusters </span>
<span class="lineNum">     688 </span>            : 
<span class="lineNum">     689 </span><span class="lineCov">          8 :     Int_t nModulesToUnfold = fGeom-&gt;GetNModules() ; </span>
<span class="lineNum">     690 </span>            : 
<span class="lineNum">     691 </span><span class="lineCov">          8 :     Int_t numberofNotUnfolded = fNumberOfEmcClusters ; </span>
<span class="lineNum">     692 </span>            :     Int_t index ;   
<span class="lineNum">     693 </span><span class="lineCov">         36 :     for(index = 0 ; index &lt; numberofNotUnfolded ; index++){</span>
<span class="lineNum">     694 </span>            :       
<span class="lineNum">     695 </span><span class="lineCov">         10 :       AliPHOSEmcRecPoint * emcRecPoint = static_cast&lt;AliPHOSEmcRecPoint *&gt;( fEMCRecPoints-&gt;At(index) ) ;</span>
<span class="lineNum">     696 </span><span class="lineCov">         10 :       if(emcRecPoint-&gt;GetPHOSMod()&gt; nModulesToUnfold)</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :         break ;</span>
<span class="lineNum">     698 </span>            :       
<span class="lineNum">     699 </span><span class="lineCov">         10 :       Int_t nMultipl = emcRecPoint-&gt;GetMultiplicity() ; </span>
<span class="lineNum">     700 </span><span class="lineCov">         10 :       AliPHOSDigit ** maxAt = new AliPHOSDigit*[nMultipl] ;</span>
<span class="lineNum">     701 </span><span class="lineCov">         10 :       Float_t * maxAtEnergy = new Float_t[nMultipl] ;</span>
<span class="lineNum">     702 </span><span class="lineCov">         10 :       Int_t nMax = emcRecPoint-&gt;GetNumberOfLocalMax(maxAt, maxAtEnergy,fEmcLocMaxCut,fDigitsArr) ;</span>
<span class="lineNum">     703 </span>            :       
<span class="lineNum">     704 </span><span class="lineCov">         10 :       if( nMax &gt; 1 ) {     // if cluster is very flat (no pronounced maximum) then nMax = 0       </span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :         UnfoldCluster(emcRecPoint, nMax, maxAt, maxAtEnergy) ;</span>
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :         fEMCRecPoints-&gt;Remove(emcRecPoint); </span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :         fEMCRecPoints-&gt;Compress() ;</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :         index-- ;</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :         fNumberOfEmcClusters -- ;</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :         numberofNotUnfolded-- ;</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     713 </span>            :       else{
<span class="lineNum">     714 </span><span class="lineCov">         10 :         emcRecPoint-&gt;SetNExMax(1) ; //Only one local maximum</span>
<span class="lineNum">     715 </span>            :       }
<span class="lineNum">     716 </span>            :       
<span class="lineNum">     717 </span><span class="lineCov">         20 :       delete[] maxAt ; </span>
<span class="lineNum">     718 </span><span class="lineCov">         20 :       delete[] maxAtEnergy ; </span>
<span class="lineNum">     719 </span><span class="lineCov">         10 :     }</span>
<span class="lineNum">     720 </span><span class="lineCov">          8 :   } </span>
<span class="lineNum">     721 </span>            :   // Unfolding of EMC clusters finished
<span class="lineNum">     722 </span>            : 
<span class="lineNum">     723 </span>            : 
<span class="lineNum">     724 </span>            :   // Unfold now CPV clusters
<span class="lineNum">     725 </span><span class="lineCov">         16 :   if(fToUnfoldCPV &amp;&amp; (fNumberOfCpvClusters &gt; 0)){</span>
<span class="lineNum">     726 </span>            :     
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :     Int_t nModulesToUnfold = fGeom-&gt;GetNModules() ;</span>
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :     Int_t numberofCpvNotUnfolded = fNumberOfCpvClusters ;     </span>
<span class="lineNum">     730 </span>            :     Int_t index ;   
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :     for(index = 0 ; index &lt; numberofCpvNotUnfolded ; index++){</span>
<span class="lineNum">     732 </span>            :       
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :       AliPHOSRecPoint * recPoint = static_cast&lt;AliPHOSRecPoint *&gt;( fCPVRecPoints-&gt;At(index) ) ;</span>
<span class="lineNum">     734 </span>            : 
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :       if(recPoint-&gt;GetPHOSMod()&gt; nModulesToUnfold)</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :         break ;</span>
<span class="lineNum">     737 </span>            :       
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :       AliPHOSEmcRecPoint * emcRecPoint = static_cast&lt;AliPHOSEmcRecPoint*&gt;(recPoint) ; </span>
<span class="lineNum">     739 </span>            :       
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :       Int_t nMultipl = emcRecPoint-&gt;GetMultiplicity() ; </span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :       AliPHOSDigit ** maxAt = new AliPHOSDigit*[nMultipl] ;</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :       Float_t * maxAtEnergy = new Float_t[nMultipl] ;</span>
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :       Int_t nMax = emcRecPoint-&gt;GetNumberOfLocalMax(maxAt, maxAtEnergy,fCpvLocMaxCut,fDigitsArr) ;</span>
<span class="lineNum">     744 </span>            : 
<span class="lineNum">     745 </span>            :       //Number of points to fit should be larger than number of parameters
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :       if( nMax &gt; 1 &amp;&amp; emcRecPoint-&gt;GetMultiplicity()&gt;3*nMax ) {  // if cluster is very flat (no pronounced maximum) then nMax = 0       </span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :         UnfoldCluster(emcRecPoint, nMax, maxAt, maxAtEnergy) ;</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :         fCPVRecPoints-&gt;Remove(emcRecPoint); </span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :         fCPVRecPoints-&gt;Compress() ;</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :         index-- ;</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :         numberofCpvNotUnfolded-- ;</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :         fNumberOfCpvClusters-- ;</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     754 </span>            :       
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :       delete[] maxAt ; </span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :       delete[] maxAtEnergy ; </span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :     } </span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     759 </span>            :   //Unfolding of Cpv clusters finished
<span class="lineNum">     760 </span>            :   
<span class="lineNum">     761 </span><span class="lineCov">          8 : }</span>
<a name="762"><span class="lineNum">     762 </span>            : </a>
<span class="lineNum">     763 </span>            : //____________________________________________________________________________
<span class="lineNum">     764 </span>            : Double_t  AliPHOSClusterizerv1::ShowerShape(Double_t x, Double_t z)
<span class="lineNum">     765 </span>            : { 
<span class="lineNum">     766 </span>            :   // Shape of the shower (see PHOS TDR)
<span class="lineNum">     767 </span>            :   // If you change this function, change also the gradient evaluation in ChiSquare()
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span>            :   //for the moment we neglect dependence on the incident angle.  
<span class="lineNum">     770 </span>            : 
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :   Double_t r2    = x*x + z*z ;</span>
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :   Double_t r4    = r2*r2 ;</span>
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :   Double_t r295  = TMath::Power(r2, 2.95/2.) ;</span>
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :   Double_t shape = TMath::Exp( -r4 * (1. / (2.32 + 0.26 * r4) + 0.0316 / (1 + 0.0652 * r295) ) ) ;</span>
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :   return shape ;</span>
<span class="lineNum">     776 </span>            : }
<a name="777"><span class="lineNum">     777 </span>            : </a>
<span class="lineNum">     778 </span>            : //____________________________________________________________________________
<span class="lineNum">     779 </span>            : void  AliPHOSClusterizerv1::UnfoldCluster(AliPHOSEmcRecPoint * iniEmc, 
<span class="lineNum">     780 </span>            :                                           Int_t nMax, 
<span class="lineNum">     781 </span>            :                                           AliPHOSDigit ** maxAt, 
<span class="lineNum">     782 </span>            :                                           Float_t * maxAtEnergy)
<span class="lineNum">     783 </span>            : { 
<span class="lineNum">     784 </span>            :   // Performs the unfolding of a cluster with nMax overlapping showers 
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :   Int_t nPar = 3 * nMax ;</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :   Float_t * fitparameters = new Float_t[nPar] ;</span>
<span class="lineNum">     788 </span>            : 
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :   Bool_t rv = FindFit(iniEmc, maxAt, maxAtEnergy, nPar, fitparameters) ;</span>
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :   if( !rv ) {</span>
<span class="lineNum">     792 </span>            :     // Fit failed, return and remove cluster
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :     iniEmc-&gt;SetNExMax(-1) ;</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :     delete[] fitparameters ; </span>
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :     return ;</span>
<span class="lineNum">     796 </span>            :   }
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span>            :   // create ufolded rec points and fill them with new energy lists
<span class="lineNum">     799 </span>            :   // First calculate energy deposited in each sell in accordance with fit (without fluctuations): efit[]
<span class="lineNum">     800 </span>            :   // and later correct this number in acordance with actual energy deposition
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :   Int_t nDigits = iniEmc-&gt;GetMultiplicity() ;  </span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :   Float_t * efit = new Float_t[nDigits] ;</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :   Float_t xDigit=0.,zDigit=0. ;</span>
<span class="lineNum">     805 </span>            :   Float_t xpar=0.,zpar=0.,epar=0.  ;
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :   Int_t relid[4] ;</span>
<span class="lineNum">     807 </span>            :   AliPHOSDigit * digit = 0 ;
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :   Int_t * emcDigits = iniEmc-&gt;GetDigitsList() ;</span>
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :   TVector3 vIncid ;</span>
<span class="lineNum">     811 </span>            : 
<span class="lineNum">     812 </span>            :   Int_t iparam ;
<span class="lineNum">     813 </span>            :   Int_t iDigit ;
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :   for(iDigit = 0 ; iDigit &lt; nDigits ; iDigit ++){</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :     digit = static_cast&lt;AliPHOSDigit*&gt;( fDigitsArr-&gt;At(emcDigits[iDigit] ) ) ;   </span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :     fGeom-&gt;AbsToRelNumbering(digit-&gt;GetId(), relid) ;</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :     fGeom-&gt;RelPosInModule(relid, xDigit, zDigit) ;</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :     efit[iDigit] = 0;</span>
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span>            :     iparam = 0 ;    
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :     while(iparam &lt; nPar ){</span>
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :       xpar = fitparameters[iparam] ;</span>
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :       zpar = fitparameters[iparam+1] ;</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :       epar = fitparameters[iparam+2] ;</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :       iparam += 3 ;</span>
<span class="lineNum">     826 </span>            : //      fGeom-&gt;GetIncidentVector(fVtx,relid[0],xpar,zpar,vIncid) ;
<span class="lineNum">     827 </span>            : //      efit[iDigit] += epar * ShowerShape(xDigit - xpar,zDigit - zpar,vIncid) ;
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :       efit[iDigit] += epar * ShowerShape(xDigit - xpar,zDigit - zpar) ;</span>
<span class="lineNum">     829 </span>            :     }
<span class="lineNum">     830 </span>            :   }
<span class="lineNum">     831 </span>            :   
<span class="lineNum">     832 </span>            :   // Now create new RecPoints and fill energy lists with efit corrected to fluctuations
<span class="lineNum">     833 </span>            :   // so that energy deposited in each cell is distributed betwin new clusters proportionally
<span class="lineNum">     834 </span>            :   // to its contribution to efit
<span class="lineNum">     835 </span>            : 
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :   Float_t * emcEnergies = iniEmc-&gt;GetEnergiesList() ;</span>
<span class="lineNum">     837 </span>            :   Float_t ratio ;
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span>            :   iparam = 0 ;
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :   while(iparam &lt; nPar ){</span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :     xpar = fitparameters[iparam] ;</span>
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :     zpar = fitparameters[iparam+1] ;</span>
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :     epar = fitparameters[iparam+2] ;</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :     iparam += 3 ;    </span>
<span class="lineNum">     845 </span>            : //    fGeom-&gt;GetIncidentVector(fVtx,iniEmc-&gt;GetPHOSMod(),xpar,zpar,vIncid) ;
<span class="lineNum">     846 </span>            : 
<span class="lineNum">     847 </span>            :     AliPHOSEmcRecPoint * emcRP = 0 ;  
<span class="lineNum">     848 </span>            : 
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :     if(iniEmc-&gt;IsEmc()){ //create new entries in fEMCRecPoints...</span>
<span class="lineNum">     850 </span>            :       
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :       if(fNumberOfEmcClusters &gt;= fEMCRecPoints-&gt;GetSize())</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :         fEMCRecPoints-&gt;Expand(2*fNumberOfEmcClusters) ;</span>
<span class="lineNum">     853 </span>            :       
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :       (*fEMCRecPoints)[fNumberOfEmcClusters] = new AliPHOSEmcRecPoint(&quot;&quot;) ;</span>
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :       emcRP = static_cast&lt;AliPHOSEmcRecPoint *&gt;( fEMCRecPoints-&gt;At(fNumberOfEmcClusters) ) ;</span>
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :       fNumberOfEmcClusters++ ;</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :       emcRP-&gt;SetNExMax((Int_t)nPar/3) ;</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     859 </span>            :     else{//create new entries in fCPVRecPoints
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :       if(fNumberOfCpvClusters &gt;= fCPVRecPoints-&gt;GetSize())</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :         fCPVRecPoints-&gt;Expand(2*fNumberOfCpvClusters) ;</span>
<span class="lineNum">     862 </span>            :       
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :       (*fCPVRecPoints)[fNumberOfCpvClusters] = new AliPHOSCpvRecPoint(&quot;&quot;) ;</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :       emcRP = static_cast&lt;AliPHOSEmcRecPoint *&gt;( fCPVRecPoints-&gt;At(fNumberOfCpvClusters) ) ;</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :       fNumberOfCpvClusters++ ;</span>
<span class="lineNum">     866 </span>            :     }
<span class="lineNum">     867 </span>            :     
<span class="lineNum">     868 </span>            :     Float_t eDigit ;
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :     for(iDigit = 0 ; iDigit &lt; nDigits ; iDigit ++){</span>
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :       digit = static_cast&lt;AliPHOSDigit*&gt;( fDigitsArr-&gt;At( emcDigits[iDigit] ) ) ; </span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :       fGeom-&gt;AbsToRelNumbering(digit-&gt;GetId(), relid) ;</span>
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :       fGeom-&gt;RelPosInModule(relid, xDigit, zDigit) ;</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :       if(efit[iDigit]&gt;0){</span>
<span class="lineNum">     874 </span>            : //      ratio = epar * ShowerShape(xDigit - xpar,zDigit - zpar,vIncid) / efit[iDigit] ; 
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :         ratio = epar * ShowerShape(xDigit - xpar,zDigit - zpar) / efit[iDigit] ; </span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :         eDigit = emcEnergies[iDigit] * ratio ;</span>
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :         emcRP-&gt;AddDigit( *digit, eDigit,CalibrateT(digit-&gt;GetTime(),digit-&gt;GetId(),digit-&gt;IsLG()) ) ;</span>
<span class="lineNum">     878 </span>            :       }
<span class="lineNum">     879 </span>            :     } 
<span class="lineNum">     880 </span>            :   }
<span class="lineNum">     881 </span>            :  
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :   delete[] fitparameters ; </span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :   delete[] efit ; </span>
<span class="lineNum">     884 </span>            :   
<span class="lineNum">     885 </span><span class="lineNoCov">          0 : }</span>
<a name="886"><span class="lineNum">     886 </span>            : </a>
<span class="lineNum">     887 </span>            : //_____________________________________________________________________________
<span class="lineNum">     888 </span>            : void AliPHOSClusterizerv1::UnfoldingChiSquare(Int_t &amp; nPar, Double_t * Grad, Double_t &amp; fret, Double_t * x, Int_t iflag)
<span class="lineNum">     889 </span>            : {
<span class="lineNum">     890 </span>            :   // Calculates the Chi square for the cluster unfolding minimization
<span class="lineNum">     891 </span>            :   // Number of parameters, Gradient, Chi squared, parameters, what to do
<span class="lineNum">     892 </span>            : 
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :   TList * toMinuit = static_cast&lt;TList*&gt;( gMinuit-&gt;GetObjectFit() ) ;</span>
<span class="lineNum">     894 </span>            : 
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :   AliPHOSEmcRecPoint * emcRP = static_cast&lt;AliPHOSEmcRecPoint*&gt;( toMinuit-&gt;At(0) )  ;</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :   TClonesArray * digits = static_cast&lt;TClonesArray*&gt;( toMinuit-&gt;At(1) )  ;</span>
<span class="lineNum">     897 </span>            :   // A bit buggy way to get an access to the geometry
<span class="lineNum">     898 </span>            :   // To be revised!
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :   AliPHOSGeometry *geom = static_cast&lt;AliPHOSGeometry *&gt;(toMinuit-&gt;At(2));</span>
<span class="lineNum">     900 </span>            : 
<span class="lineNum">     901 </span>            : //  TVector3 * vtx = static_cast&lt;TVector3*&gt;(toMinuit-&gt;At(3)) ;  //Vertex position
<span class="lineNum">     902 </span>            :   
<span class="lineNum">     903 </span>            :   //  AliPHOSEmcRecPoint * emcRP = static_cast&lt;AliPHOSEmcRecPoint *&gt;( gMinuit-&gt;GetObjectFit() ) ; // EmcRecPoint to fit
<span class="lineNum">     904 </span>            : 
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :   Int_t * emcDigits     = emcRP-&gt;GetDigitsList() ;</span>
<span class="lineNum">     906 </span>            : 
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :   Int_t nOdigits = emcRP-&gt;GetDigitsMultiplicity() ; </span>
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :   Float_t * emcEnergies = emcRP-&gt;GetEnergiesList() ;</span>
<span class="lineNum">     910 </span>            :   
<span class="lineNum">     911 </span>            : //  TVector3 vInc ;
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :   fret = 0. ;     </span>
<span class="lineNum">     913 </span>            :   Int_t iparam ;
<span class="lineNum">     914 </span>            : 
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :   if(iflag == 2)</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :     for(iparam = 0 ; iparam &lt; nPar ; iparam++)    </span>
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :       Grad[iparam] = 0 ; // Will evaluate gradient</span>
<span class="lineNum">     918 </span>            :   
<span class="lineNum">     919 </span>            :   Double_t efit ;    
<span class="lineNum">     920 </span>            : 
<span class="lineNum">     921 </span>            :   AliPHOSDigit * digit ;
<span class="lineNum">     922 </span>            :   Int_t iDigit ;
<span class="lineNum">     923 </span>            : 
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :   for( iDigit = 0 ; iDigit &lt; nOdigits ; iDigit++) {</span>
<span class="lineNum">     925 </span>            : 
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :     digit = static_cast&lt;AliPHOSDigit*&gt;( digits-&gt;At( emcDigits[iDigit] ) ); </span>
<span class="lineNum">     927 </span>            : 
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :     Int_t relid[4] ;</span>
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :     Float_t xDigit ;</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :     Float_t zDigit ;</span>
<span class="lineNum">     931 </span>            : 
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :     geom-&gt;AbsToRelNumbering(digit-&gt;GetId(), relid) ;</span>
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :     geom-&gt;RelPosInModule(relid, xDigit, zDigit) ;</span>
<span class="lineNum">     935 </span>            : 
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :      if(iflag == 2){  // calculate gradient</span>
<span class="lineNum">     937 </span>            :        Int_t iParam = 0 ;
<span class="lineNum">     938 </span>            :        efit = 0 ;
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :        while(iParam &lt; nPar ){</span>
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :          Double_t dx = (xDigit - x[iParam]) ;</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :          iParam++ ; </span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :          Double_t dz = (zDigit - x[iParam]) ; </span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :          iParam++ ;          </span>
<span class="lineNum">     944 </span>            : //         fGeom-&gt;GetIncidentVector(*vtx,emcRP-&gt;GetPHOSMod(),x[iParam-2],x[iParam-1],vInc) ;
<span class="lineNum">     945 </span>            : //         efit += x[iParam] * ShowerShape(dx,dz,vInc) ;
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :          efit += x[iParam] * ShowerShape(dx,dz) ;</span>
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :          iParam++ ;</span>
<span class="lineNum">     948 </span>            :        }
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :        Double_t sum = 2. * (efit - emcEnergies[iDigit]) / emcEnergies[iDigit] ; // Here we assume, that sigma = sqrt(E) </span>
<span class="lineNum">     950 </span>            :        iParam = 0 ;
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :        while(iParam &lt; nPar ){</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :          Double_t xpar = x[iParam] ;</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :          Double_t zpar = x[iParam+1] ;</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :          Double_t epar = x[iParam+2] ;</span>
<span class="lineNum">     955 </span>            : //         fGeom-&gt;GetIncidentVector(*vtx,emcRP-&gt;GetPHOSMod(),xpar,zpar,vInc) ;
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :          Double_t dr = TMath::Sqrt( (xDigit - xpar) * (xDigit - xpar) + (zDigit - zpar) * (zDigit - zpar) );</span>
<span class="lineNum">     957 </span>            : //         Double_t shape = sum * ShowerShape(xDigit - xpar,zDigit - zpar,vInc) ;
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :          Double_t shape = sum * ShowerShape(xDigit - xpar,zDigit - zpar) ;</span>
<span class="lineNum">     959 </span>            : //DP: No incident angle dependence in gradient yet!!!!!!
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :          Double_t r4 = dr*dr*dr*dr ;</span>
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :          Double_t r295 = TMath::Power(dr,2.95) ;</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :          Double_t deriv =-4. * dr*dr * ( 2.32 / ( (2.32 + 0.26 * r4) * (2.32 + 0.26 * r4) ) +</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :                                          0.0316 * (1. + 0.0171 * r295) / ( ( 1. + 0.0652 * r295) * (1. + 0.0652 * r295) ) ) ;</span>
<span class="lineNum">     964 </span>            :          
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :          Grad[iParam] += epar * shape * deriv * (xpar - xDigit) ;  // Derivative over x    </span>
<span class="lineNum">     966 </span>            :          iParam++ ; 
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :          Grad[iParam] += epar * shape * deriv * (zpar - zDigit) ;  // Derivative over z         </span>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :          iParam++ ; </span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :          Grad[iParam] += shape ;                                  // Derivative over energy             </span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :          iParam++ ; </span>
<span class="lineNum">     971 </span>            :        }
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :      }</span>
<span class="lineNum">     973 </span>            :      efit = 0;
<span class="lineNum">     974 </span>            :      iparam = 0 ;
<span class="lineNum">     975 </span>            : 
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :      while(iparam &lt; nPar ){</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :        Double_t xpar = x[iparam] ;</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :        Double_t zpar = x[iparam+1] ;</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :        Double_t epar = x[iparam+2] ;</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :        iparam += 3 ;</span>
<span class="lineNum">     981 </span>            : //       fGeom-&gt;GetIncidentVector(*vtx,emcRP-&gt;GetPHOSMod(),xpar,zpar,vInc) ;
<span class="lineNum">     982 </span>            : //       efit += epar * ShowerShape(xDigit - xpar,zDigit - zpar,vInc) ;
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :        efit += epar * ShowerShape(xDigit - xpar,zDigit - zpar) ;</span>
<span class="lineNum">     984 </span>            :      }
<span class="lineNum">     985 </span>            : 
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :      fret += (efit-emcEnergies[iDigit])*(efit-emcEnergies[iDigit])/emcEnergies[iDigit] ; </span>
<span class="lineNum">     987 </span>            :      // Here we assume, that sigma = sqrt(E)
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     989 </span>            : 
<span class="lineNum">     990 </span><span class="lineNoCov">          0 : }</span>
<a name="991"><span class="lineNum">     991 </span>            : </a>
<span class="lineNum">     992 </span>            : //____________________________________________________________________________
<span class="lineNum">     993 </span>            : void AliPHOSClusterizerv1::Print(const Option_t *)const
<span class="lineNum">     994 </span>            : {
<span class="lineNum">     995 </span>            :   // Print clusterizer parameters
<span class="lineNum">     996 </span>            : 
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :   TString message ; </span>
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :   TString taskName(GetName()) ; </span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :   taskName.ReplaceAll(Version(), &quot;&quot;) ;</span>
<span class="lineNum">    1000 </span>            :   
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :   if( strcmp(GetName(), &quot;&quot;) !=0 ) {  </span>
<span class="lineNum">    1002 </span>            :     // Print parameters
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :     message  = &quot;\n--------------- %s %s -----------\n&quot; ; </span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :     message += &quot;Clusterizing digits from the file: %s\n&quot; ;</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :     message += &quot;                           Branch: %s\n&quot; ; </span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :     message += &quot;                       EMC Clustering threshold = %f\n&quot; ; </span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :     message += &quot;                       EMC Local Maximum cut    = %f\n&quot; ; </span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :     message += &quot;                       EMC Logarothmic weight   = %f\n&quot; ;</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :     message += &quot;                       CPV Clustering threshold = %f\n&quot; ;</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :     message += &quot;                       CPV Local Maximum cut    = %f\n&quot; ;</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :     message += &quot;                       CPV Logarothmic weight   = %f\n&quot; ;</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :     if(fToUnfold)</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :       message += &quot; Unfolding on\n&quot; ;</span>
<span class="lineNum">    1014 </span>            :     else
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :       message += &quot; Unfolding off\n&quot; ;</span>
<span class="lineNum">    1016 </span>            :     
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :     message += &quot;------------------------------------------------------------------&quot; ;</span>
<span class="lineNum">    1018 </span>            :   }
<span class="lineNum">    1019 </span>            :   else 
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :     message = &quot; AliPHOSClusterizerv1 not initialized &quot; ;</span>
<span class="lineNum">    1021 </span>            :   
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :   AliInfo(Form(&quot;%s, %s %s %s %s %f %f %f %f %f %f&quot;, message.Data(),  </span>
<span class="lineNum">    1023 </span>            :        taskName.Data(), 
<span class="lineNum">    1024 </span>            :        GetTitle(),
<span class="lineNum">    1025 </span>            :        taskName.Data(), 
<span class="lineNum">    1026 </span>            :        GetName(), 
<span class="lineNum">    1027 </span>            :        fEmcClusteringThreshold, 
<span class="lineNum">    1028 </span>            :        fEmcLocMaxCut, 
<span class="lineNum">    1029 </span>            :        fW0, 
<span class="lineNum">    1030 </span>            :        fCpvClusteringThreshold, 
<span class="lineNum">    1031 </span>            :        fCpvLocMaxCut, 
<span class="lineNum">    1032 </span>            :        fW0CPV )) ; 
<a name="1033"><span class="lineNum">    1033 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1034 </span>            : //____________________________________________________________________________
<span class="lineNum">    1035 </span>            : void AliPHOSClusterizerv1::PrintRecPoints(Option_t * option)
<span class="lineNum">    1036 </span>            : {
<span class="lineNum">    1037 </span>            :   // Prints list of RecPoints produced at the current pass of AliPHOSClusterizer
<span class="lineNum">    1038 </span>            : 
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :   AliInfo(Form(&quot;\nFound %d EMC RecPoints and %d CPV RecPoints&quot;, </span>
<span class="lineNum">    1040 </span>            :                fEMCRecPoints-&gt;GetEntriesFast(),
<span class="lineNum">    1041 </span>            :                fCPVRecPoints-&gt;GetEntriesFast() ))  ;
<span class="lineNum">    1042 </span>            :  
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :   if(strstr(option,&quot;all&quot;)) {</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :     printf(&quot;\n EMC clusters \n&quot;) ;</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :     printf(&quot;Index    Ene(MeV) Multi Module     X    Y   Z    Lambdas_1  Lambda_2  # of prim  Primaries list\n&quot;) ;      </span>
<span class="lineNum">    1046 </span>            :     Int_t index ;
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :     for (index = 0 ; index &lt; fEMCRecPoints-&gt;GetEntries() ; index++) {</span>
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :       AliPHOSEmcRecPoint * rp = (AliPHOSEmcRecPoint * )fEMCRecPoints-&gt;At(index) ; </span>
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :       TVector3  locpos;  </span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :       rp-&gt;GetLocalPosition(locpos);</span>
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :       Float_t lambda[2]; </span>
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :       rp-&gt;GetElipsAxis(lambda);</span>
<span class="lineNum">    1053 </span>            :       Int_t * primaries; 
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :       Int_t nprimaries;</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :       primaries = rp-&gt;GetPrimaries(nprimaries);</span>
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :       printf(&quot;\n%6d  %8.2f  %3d     %2d     %4.1f   %4.1f   %4.1f   %4f  %4f    %2d     : &quot;, </span>
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :               rp-&gt;GetIndexInList(), rp-&gt;GetEnergy(), rp-&gt;GetMultiplicity(), rp-&gt;GetPHOSMod(), </span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :               locpos.X(), locpos.Y(), locpos.Z(), lambda[0], lambda[1], nprimaries) ; </span>
<span class="lineNum">    1059 </span>            :       
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :       for (Int_t iprimary=0; iprimary&lt;nprimaries; iprimary++) {</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :         printf(&quot;%d &quot;, primaries[iprimary] ) ; </span>
<span class="lineNum">    1062 </span>            :       }
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :       printf(&quot;\n&quot;) ;</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1065 </span>            : 
<span class="lineNum">    1066 </span>            :     //Now plot CPV recPoints
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :     printf(&quot;\n CPV clusters \n&quot;) ;</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :     printf(&quot;Index    Ene(MeV) Module     X     Y    Z  \n&quot;) ;      </span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :     for (index = 0 ; index &lt; fCPVRecPoints-&gt;GetEntries() ; index++) {</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :       AliPHOSCpvRecPoint * rp = (AliPHOSCpvRecPoint * )fCPVRecPoints-&gt;At(index) ; </span>
<span class="lineNum">    1071 </span>            :       
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :       TVector3  locpos;  </span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :       rp-&gt;GetLocalPosition(locpos);</span>
<span class="lineNum">    1074 </span>            :       
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :       printf(&quot;\n%6d  %8.2f  %2d     %4.1f    %4.1f %4.1f \n&quot;, </span>
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :              rp-&gt;GetIndexInList(), rp-&gt;GetEnergy(), rp-&gt;GetPHOSMod(), </span>
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :              locpos.X(), locpos.Y(), locpos.Z()) ; </span>
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1081 </span>            : 
<a name="1082"><span class="lineNum">    1082 </span>            : </a>
<span class="lineNum">    1083 </span>            : //____________________________________________________________________________
<span class="lineNum">    1084 </span>            : void AliPHOSClusterizerv1::SetDistancesToBadChannels()
<span class="lineNum">    1085 </span>            : {
<span class="lineNum">    1086 </span>            :   //For each EMC rec. point set the distance to the nearest bad crystal.
<span class="lineNum">    1087 </span>            :   //Author: Boris Polichtchouk 
<span class="lineNum">    1088 </span>            : 
<span class="lineNum">    1089 </span><span class="lineCov">         16 :   if(!fgCalibData-&gt;GetNumOfEmcBadChannels()) return;</span>
<span class="lineNum">    1090 </span>            : 
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :   Int_t badIds[8000];</span>
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :   memset(badIds,0,8000*sizeof(Int_t));</span>
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :   fgCalibData-&gt;EmcBadChannelIds(badIds);</span>
<span class="lineNum">    1094 </span>            : 
<span class="lineNum">    1095 </span>            :   AliPHOSEmcRecPoint* rp;
<span class="lineNum">    1096 </span>            : 
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :   TMatrixF gmat;</span>
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :   TVector3 gposRecPoint; // global (in ALICE frame) position of rec. point</span>
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :   TVector3 gposBadChannel; // global position of bad crystal</span>
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :   TVector3 dR;</span>
<span class="lineNum">    1101 </span>            : 
<span class="lineNum">    1102 </span>            :   Float_t dist=0.,minDist=0.;
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :   Int_t relid[4]={0,0,0,0} ;</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :   TVector3 lpos ;</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :   for(Int_t iRP=0; iRP&lt;fEMCRecPoints-&gt;GetEntries(); iRP++){</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :     rp = (AliPHOSEmcRecPoint*)fEMCRecPoints-&gt;At(iRP);</span>
<span class="lineNum">    1107 </span>            :     //evaluate distance to border
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :     relid[0]=rp-&gt;GetPHOSMod() ;</span>
<span class="lineNum">    1109 </span>            :     Float_t xcorner=0,zcorner=0.;
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :     Float_t xmin,xmax,zmin,zmax ;</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :     fGeom-&gt;GetCrystalsEdges(rp-&gt;GetPHOSMod(),xmin, zmin, xmax, zmax) ;</span>
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :     rp-&gt;GetLocalPosition(lpos) ;</span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :     Float_t minDistX = 2.2+TMath::Min(lpos.X()-xmin,xmax-lpos.X()); //2.2 - crystal size</span>
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :     Float_t minDistZ = 2.2+TMath::Min(lpos.Z()-zmin,zmax-lpos.Z()); //2.2 - crystal size</span>
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :     minDist=TMath::Min(minDistX,minDistZ) ;</span>
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :     Int_t ixmin=32+Int_t(xmin/2.2) ;</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :     for(Int_t iBad=0; iBad&lt;fgCalibData-&gt;GetNumOfEmcBadChannels(); iBad++) {</span>
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :       fGeom-&gt;AbsToRelNumbering(badIds[iBad],relid)  ;</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :       if(relid[0]!=rp-&gt;GetPHOSMod()) //We can not evaluate global position directly since </span>
<span class="lineNum">    1120 </span>            :         continue ;                   //bad channels can be in the module which does not exist in simulations.
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :       if(relid[2]&lt;=ixmin) //non-existing part of mod 4</span>
<span class="lineNum">    1122 </span>            :         continue ;
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :       rp-&gt;GetGlobalPosition(gposRecPoint,gmat);</span>
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :       fGeom-&gt;RelPosInAlice(badIds[iBad],gposBadChannel);</span>
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :       AliDebug(2,Form(&quot;BC position:[%.3f,%.3f,%.3f], RP position:[%.3f,%.3f,%.3f]. E=%.3f\n&quot;,</span>
<span class="lineNum">    1126 </span>            :                       gposBadChannel.X(),gposBadChannel.Y(),gposBadChannel.Z(),
<span class="lineNum">    1127 </span>            :                       gposRecPoint.X(),gposRecPoint.Y(),gposRecPoint.Z(),rp-&gt;GetEnergy()));
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :       dR = gposBadChannel-gposRecPoint;</span>
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :       dist = dR.Mag();</span>
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :       if(dist&lt;minDist) minDist = dist;</span>
<span class="lineNum">    1131 </span>            :     }
<span class="lineNum">    1132 </span>            : 
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :     rp-&gt;SetDistanceToBadCrystal(minDist); </span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1135 </span>            : 
<a name="1136"><span class="lineNum">    1136 </span><span class="lineCov">          8 : }</span></a>
<span class="lineNum">    1137 </span>            : //==================================================================================
<span class="lineNum">    1138 </span>            : Float_t AliPHOSClusterizerv1::Calibrate(Float_t amp, Int_t absId) const{
<span class="lineNum">    1139 </span>            :   // Calibrate EMC digit, i.e. multiply its Amp by a factor read from CDB
<span class="lineNum">    1140 </span>            : 
<span class="lineNum">    1141 </span><span class="lineCov">        616 :   const AliPHOSGeometry *geom = AliPHOSGeometry::GetInstance() ;</span>
<span class="lineNum">    1142 </span>            : 
<span class="lineNum">    1143 </span>            :   //Determine rel.position of the cell absolute ID
<span class="lineNum">    1144 </span><span class="lineCov">        308 :   Int_t relId[4];</span>
<span class="lineNum">    1145 </span><span class="lineCov">        308 :   geom-&gt;AbsToRelNumbering(absId,relId);</span>
<span class="lineNum">    1146 </span><span class="lineCov">        308 :   Int_t module=relId[0];</span>
<span class="lineNum">    1147 </span><span class="lineCov">        308 :   Int_t row   =relId[2];</span>
<span class="lineNum">    1148 </span><span class="lineCov">        308 :   Int_t column=relId[3];</span>
<span class="lineNum">    1149 </span><span class="lineCov">        308 :   if(relId[1]){ //CPV</span>
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :     Float_t calibration = fgCalibData-&gt;GetADCchannelCpv(module,column,row);</span>
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :     return amp*calibration ;</span>
<span class="lineNum">    1152 </span>            :   }   
<span class="lineNum">    1153 </span>            :   else{ //EMC
<span class="lineNum">    1154 </span><span class="lineCov">        308 :     Float_t calibration = fgCalibData-&gt;GetADCchannelEmc(module,column,row);</span>
<span class="lineNum">    1155 </span><span class="lineCov">        308 :     return amp*calibration ;</span>
<span class="lineNum">    1156 </span>            :   }
<a name="1157"><span class="lineNum">    1157 </span><span class="lineCov">        308 : }</span></a>
<span class="lineNum">    1158 </span>            : //==================================================================================
<span class="lineNum">    1159 </span>            : Float_t AliPHOSClusterizerv1::CalibrateT(Float_t time, Int_t absId,Bool_t isLG)const{
<span class="lineNum">    1160 </span>            :   // Calibrate time in EMC digit
<span class="lineNum">    1161 </span>            : 
<span class="lineNum">    1162 </span><span class="lineCov">        176 :   const AliPHOSGeometry *geom = AliPHOSGeometry::GetInstance() ;</span>
<span class="lineNum">    1163 </span>            : 
<span class="lineNum">    1164 </span>            :   //Determine rel.position of the cell absolute ID
<span class="lineNum">    1165 </span><span class="lineCov">        176 :   Int_t relId[4];</span>
<span class="lineNum">    1166 </span><span class="lineCov">        176 :   geom-&gt;AbsToRelNumbering(absId,relId);</span>
<span class="lineNum">    1167 </span><span class="lineCov">        176 :   Int_t module=relId[0];</span>
<span class="lineNum">    1168 </span><span class="lineCov">        176 :   Int_t row   =relId[2];</span>
<span class="lineNum">    1169 </span><span class="lineCov">        176 :   Int_t column=relId[3];</span>
<span class="lineNum">    1170 </span><span class="lineCov">        176 :   if(relId[1]){ //CPV</span>
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :     return 0. ;</span>
<span class="lineNum">    1172 </span>            :   }
<span class="lineNum">    1173 </span>            :   else{ //EMC
<span class="lineNum">    1174 </span><span class="lineCov">        352 :     if(isLG)</span>
<span class="lineNum">    1175 </span><span class="lineCov">        194 :       time += fgCalibData-&gt;GetLGTimeShiftEmc(module,column,row);</span>
<span class="lineNum">    1176 </span>            :     else
<span class="lineNum">    1177 </span><span class="lineCov">        158 :       time += fgCalibData-&gt;GetTimeShiftEmc(module,column,row);</span>
<span class="lineNum">    1178 </span><span class="lineCov">        176 :     return time ;</span>
<span class="lineNum">    1179 </span>            :   }
<span class="lineNum">    1180 </span><span class="lineCov">        176 : }</span>
<span class="lineNum">    1181 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
