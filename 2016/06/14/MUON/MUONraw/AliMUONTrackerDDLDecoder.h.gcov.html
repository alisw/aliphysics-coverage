<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - MUON/MUONraw/AliMUONTrackerDDLDecoder.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">MUON/MUONraw</a> - AliMUONTrackerDDLDecoder.h<span style="font-size: 80%;"> (source / <a href="AliMUONTrackerDDLDecoder.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">115</td>
            <td class="headerCovTableEntry">336</td>
            <td class="headerCovTableEntryLo">34.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">27</td>
            <td class="headerCovTableEntry">82</td>
            <td class="headerCovTableEntryLo">32.9 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : #ifndef ALIMUONTRACKERDDLDECODER_H</a>
<span class="lineNum">       2 </span>            : #define ALIMUONTRACKERDDLDECODER_H
<span class="lineNum">       3 </span>            : /**************************************************************************
<span class="lineNum">       4 </span>            :  * This file is property of and copyright by the ALICE HLT Project        *
<span class="lineNum">       5 </span>            :  * All rights reserved.                                                   *
<span class="lineNum">       6 </span>            :  *                                                                        *
<span class="lineNum">       7 </span>            :  * Primary Authors:                                                       *
<span class="lineNum">       8 </span>            :  *   Artur Szostak &lt;artursz@iafrica.com&gt;                                  *
<span class="lineNum">       9 </span>            :  *                                                                        *
<span class="lineNum">      10 </span>            :  * Permission to use, copy, modify and distribute this software and its   *
<span class="lineNum">      11 </span>            :  * documentation strictly for non-commercial purposes is hereby granted   *
<span class="lineNum">      12 </span>            :  * without fee, provided that the above copyright notice appears in all   *
<span class="lineNum">      13 </span>            :  * copies and that both the copyright notice and this permission notice   *
<span class="lineNum">      14 </span>            :  * appear in the supporting documentation. The authors make no claims     *
<span class="lineNum">      15 </span>            :  * about the suitability of this software for any purpose. It is          *
<span class="lineNum">      16 </span>            :  * provided &quot;as is&quot; without express or implied warranty.                  *
<span class="lineNum">      17 </span>            :  **************************************************************************/
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : /* $Id$ */
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : ///
<span class="lineNum">      22 </span>            : /// \file   AliMUONTrackerDDLDecoder.h
<span class="lineNum">      23 </span>            : /// \author Artur Szostak &lt;artursz@iafrica.com&gt;
<span class="lineNum">      24 </span>            : /// \date   28-11-2007
<span class="lineNum">      25 </span>            : /// \brief  Implementation of a high performance DDL decoder for the muon tracking stations.
<span class="lineNum">      26 </span>            : ///
<span class="lineNum">      27 </span>            : /// This file implementes the AliMUONTrackerDDLDecoder class, which contains
<span class="lineNum">      28 </span>            : /// the core logic for decoding the payload in DDL streams coming from the muon
<span class="lineNum">      29 </span>            : /// spectrometer's tracking chambers in a very efficient manner.
<span class="lineNum">      30 </span>            : ///
<span class="lineNum">      31 </span>            : /// This implementation is derived from work done by Christian Finck for the
<span class="lineNum">      32 </span>            : /// AliMUONPayloadTracker.
<span class="lineNum">      33 </span>            : ///
<span class="lineNum">      34 </span>            : /// Note to maintainers: Please remember that this file is used by the online
<span class="lineNum">      35 </span>            : /// dHLT system. As an online system, the dHLT requires the fastest code possible
<span class="lineNum">      36 </span>            : /// in the decoders to satisfy its timing constraints. The performance impact
<span class="lineNum">      37 </span>            : /// must be checked before any proposed modification is made to this file.
<span class="lineNum">      38 </span>            : ///
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      41 </span>            : #include &quot;AliMUONTrackerDDLDecoderEventHandler.h&quot;
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : /// \ingroup raw
<span class="lineNum">      44 </span>            : /// \class AliMUONTrackerDDLDecoder
<span class="lineNum">      45 </span>            : /// \brief A high performance decoder class for MUON tracking DDL data.
<span class="lineNum">      46 </span>            : ///
<span class="lineNum">      47 </span>            : /// This class implements a high performance decoder for decoding DDL payload
<span class="lineNum">      48 </span>            : /// data coming from the muon spectrometers tracking chambers.
<span class="lineNum">      49 </span>            : /// It has been implemented using the event driven paradigm with templates,
<span class="lineNum">      50 </span>            : /// which allows us to minimise the number of method calls made in the inner
<span class="lineNum">      51 </span>            : /// loops of the algorithm and minimise the memory footprint. At least for
<span class="lineNum">      52 </span>            : /// optimised production compilations.
<span class="lineNum">      53 </span>            : /// The decoder class only contains the basic decoding and error checking logic.
<span class="lineNum">      54 </span>            : /// It calls methods such as OnNewBlock, OnNewBusPatch, OnData etc in
<span class="lineNum">      55 </span>            : /// the event handler during the decoding to return the decoded data.
<span class="lineNum">      56 </span>            : /// The event handler class is nothing more than a callback interface to deliver
<span class="lineNum">      57 </span>            : /// the next chunks of decoded data.
<span class="lineNum">      58 </span>            : /// To actually do something with the data, one needs to implement a custom
<span class="lineNum">      59 </span>            : /// event handler (callback) class by inheriting from AliMUONTrackerDDLDecoderEventHandler
<span class="lineNum">      60 </span>            : /// and overriding the callback methods like so:
<span class="lineNum">      61 </span>            : /// \code
<span class="lineNum">      62 </span>            : ///  class MyCustomHandler : public AliMUONTrackerDDLDecoderEventHandler
<span class="lineNum">      63 </span>            : ///  {
<span class="lineNum">      64 </span>            : ///  public:
<span class="lineNum">      65 </span>            : ///     void OnData(UInt_t data, bool parityError)
<span class="lineNum">      66 </span>            : ///     {
<span class="lineNum">      67 </span>            : ///       // I can do something with 'data' here and check if there was
<span class="lineNum">      68 </span>            : ///       // a parity error with 'parityError'.
<span class="lineNum">      69 </span>            : ///     }
<span class="lineNum">      70 </span>            : ///  };
<span class="lineNum">      71 </span>            : /// \endcode
<span class="lineNum">      72 </span>            : ///
<span class="lineNum">      73 </span>            : /// Once the custom handler is written then the decoder is instantiated as
<span class="lineNum">      74 </span>            : /// shown below, to use your new custom handler. Also to start decoding one needs
<span class="lineNum">      75 </span>            : /// to call the Decode() method of the decoder.
<span class="lineNum">      76 </span>            : /// \code
<span class="lineNum">      77 </span>            : ///  AliMUONTrackerDDLDecoder&lt;MyCustomHandler&gt; myDecoder;
<span class="lineNum">      78 </span>            : ///  muDecoder.Decoder(buffer, bufferSize);
<span class="lineNum">      79 </span>            : /// \endcode
<span class="lineNum">      80 </span>            : ///
<span class="lineNum">      81 </span>            : /// Note that this class was written as a template on purpose. To maximise the
<span class="lineNum">      82 </span>            : /// compilers chance to make optimisations and inline the code we must use a template.
<span class="lineNum">      83 </span>            : /// Depending on exactly what you do inside your handler, the decoder could be
<span class="lineNum">      84 </span>            : /// significantly slower if run time polymorphism was used, i.e. making the class
<span class="lineNum">      85 </span>            : /// AliMUONTrackerDDLDecoderEventHandler abstract and using virtual methods.
<span class="lineNum">      86 </span>            : ///
<span class="lineNum">      87 </span>            : /// There has been a change to the data format that the real detector generates.
<span class="lineNum">      88 </span>            : /// Two trailer words are added to the end of the DDL payload which indicated
<span class="lineNum">      89 </span>            : /// the end of data. The decoder is initialised by default to automatically
<span class="lineNum">      90 </span>            : /// check for these and deal with it correctly, if they exist or not.
<span class="lineNum">      91 </span>            : /// However, if you want to override this behaviour then set the flag
<span class="lineNum">      92 </span>            : /// fAutoDetectTrailer to false with AutoDetectTrailer(false). Then if you have
<span class="lineNum">      93 </span>            : /// data with the old data format you should set fCheckForTrailer to false with
<span class="lineNum">      94 </span>            : /// CheckForTrailer(false), otherwise for real data it should be
<span class="lineNum">      95 </span>            : /// fCheckForTrailer = true. Only when fAutoDetectTrailer is true will the
<span class="lineNum">      96 </span>            : /// fCheckForTrailer flag be ignored and no warnings will be generated for an
<span class="lineNum">      97 </span>            : /// incorrect data format.
<span class="lineNum">      98 </span>            : ///
<span class="lineNum">      99 </span>            : /// \author Artur Szostak &lt;artursz@iafrica.com&gt;
<a name="100"><span class="lineNum">     100 </span>            : </a>
<span class="lineNum">     101 </span>            : template &lt;class EventHandler&gt;
<span class="lineNum">     102 </span><span class="lineCov">         32 : class AliMUONTrackerDDLDecoder</span>
<span class="lineNum">     103 </span>            : {
<span class="lineNum">     104 </span>            : public:
<a name="105"><span class="lineNum">     105 </span>            : </a>
<span class="lineNum">     106 </span>            :         /// Default contructor.
<span class="lineNum">     107 </span>            :         AliMUONTrackerDDLDecoder() :
<span class="lineNum">     108 </span><span class="lineCov">         24 :                 fExitOnError(true), fTryRecover(false),</span>
<span class="lineNum">     109 </span><span class="lineCov">         12 :                 fSendDataOnParityError(false), fHadError(false),</span>
<span class="lineNum">     110 </span><span class="lineCov">         12 :                 fAutoDetectTrailer(true), fCheckForTrailer(true),</span>
<span class="lineNum">     111 </span><span class="lineCov">         12 :                 fMaxBlocks(2), fMaxDSPs(5), fMaxBusPatches(5), fHandler()</span>
<span class="lineNum">     112 </span><span class="lineCov">         36 :         {}</span>
<a name="113"><span class="lineNum">     113 </span>            :         </a>
<span class="lineNum">     114 </span>            :         /// Constant method to return the event handler instance.
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :         const EventHandler&amp; GetHandler() const { return fHandler; }</span>
<a name="116"><span class="lineNum">     116 </span>            :         </a>
<span class="lineNum">     117 </span>            :         /// Returns the event handler instance.
<span class="lineNum">     118 </span><span class="lineCov">      15204 :         EventHandler&amp; GetHandler() { return fHandler; }</span>
<span class="lineNum">     119 </span>            :         
<span class="lineNum">     120 </span>            :         /// Returns the &quot;exit on error&quot; flag.
<span class="lineNum">     121 </span>            :         /// i.e. should the decoder stop on the very first error found.
<span class="lineNum">     122 </span>            :         bool ExitOnError() const { return fExitOnError; }
<span class="lineNum">     123 </span>            :         
<a name="124"><span class="lineNum">     124 </span>            :         /// Sets the &quot;exit on error&quot; flag.</a>
<span class="lineNum">     125 </span>            :         /// i.e. should the decoder stop on the very first error found.
<span class="lineNum">     126 </span><span class="lineCov">         12 :         void ExitOnError(bool value) { fExitOnError = value; }</span>
<span class="lineNum">     127 </span>            :         
<span class="lineNum">     128 </span>            :         /// Returns the &quot;try to recover from errors&quot; flag.
<a name="129"><span class="lineNum">     129 </span>            :         /// i.e. should the decoder try to recover from errors found in the</a>
<span class="lineNum">     130 </span>            :         /// payload headers or trailers.
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :         bool TryRecover() const { return fTryRecover; }</span>
<span class="lineNum">     132 </span>            :         
<span class="lineNum">     133 </span>            :         /// Sets the &quot;try to recover from errors&quot; flag.
<a name="134"><span class="lineNum">     134 </span>            :         /// i.e. should the decoder try to recover from errors found in the</a>
<span class="lineNum">     135 </span>            :         /// payload headers or trailers.
<span class="lineNum">     136 </span><span class="lineCov">          4 :         void TryRecover(bool value) { fTryRecover = value; }</span>
<span class="lineNum">     137 </span>            :         
<span class="lineNum">     138 </span>            :         /// Returns the flag indicating if the raw data words in the bus patches
<span class="lineNum">     139 </span>            :         /// that failed their parity tests (i.e. parity error / bit flip in the
<span class="lineNum">     140 </span>            :         /// raw data word) will be sent to the event handler anyway through OnData.
<span class="lineNum">     141 </span>            :         bool SendDataOnParityError() const { return fSendDataOnParityError; }
<span class="lineNum">     142 </span>            :         
<span class="lineNum">     143 </span>            :         /// Sets the flag indicating if the raw data words in the bus patches
<a name="144"><span class="lineNum">     144 </span>            :         /// that failed their parity tests (i.e. parity error / bit flip in the</a>
<span class="lineNum">     145 </span>            :         /// raw data word) will be sent to the event handler anyway through OnData.
<span class="lineNum">     146 </span><span class="lineCov">         12 :         void SendDataOnParityError(bool value) { fSendDataOnParityError = value; }</span>
<a name="147"><span class="lineNum">     147 </span>            :         </a>
<span class="lineNum">     148 </span>            :         /// Returns the maximum block count expected in the DDL payload.
<span class="lineNum">     149 </span><span class="lineCov">         18 :         UInt_t MaxBlocks() const { return fMaxBlocks; }</span>
<a name="150"><span class="lineNum">     150 </span>            :         </a>
<span class="lineNum">     151 </span>            :         /// Sets the maximum block count expected in the DDL payload.
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :         void MaxBlocks(UInt_t n) { fMaxBlocks = n; }</span>
<span class="lineNum">     153 </span>            :         
<a name="154"><span class="lineNum">     154 </span>            :         /// Returns the maximum DSP header count expected in any given block</a>
<span class="lineNum">     155 </span>            :         /// structure within the DDL payload.
<span class="lineNum">     156 </span><span class="lineCov">         18 :         UInt_t MaxDSPs() const { return fMaxDSPs; }</span>
<span class="lineNum">     157 </span>            :         
<a name="158"><span class="lineNum">     158 </span>            :         /// Sets the maximum DSP header count expected in any given block structure</a>
<span class="lineNum">     159 </span>            :         /// within the DDL payload.
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :         void MaxDSPs(UInt_t n) { fMaxDSPs = n; }</span>
<span class="lineNum">     161 </span>            :         
<a name="162"><span class="lineNum">     162 </span>            :         /// Returns the maximum number of bus patches expected in any given DSP</a>
<span class="lineNum">     163 </span>            :         /// structure within the DDL payload.
<span class="lineNum">     164 </span><span class="lineCov">         18 :         UInt_t MaxBusPatches() const { return fMaxBusPatches; }</span>
<span class="lineNum">     165 </span>            :         
<a name="166"><span class="lineNum">     166 </span>            :         /// Sets the maximum number of bus patches expected in any given DSP</a>
<span class="lineNum">     167 </span>            :         /// structure within the DDL payload.
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :         void MaxBusPatches(UInt_t n) { fMaxBusPatches = n; }</span>
<a name="169"><span class="lineNum">     169 </span>            :         </a>
<span class="lineNum">     170 </span>            :         /// Returns the value of the auto-detect trailer flag.
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :         bool AutoDetectTrailer() const { return fAutoDetectTrailer; }</span>
<a name="172"><span class="lineNum">     172 </span>            :         </a>
<span class="lineNum">     173 </span>            :         /// Sets the value of the auto-detect trailer flag.
<span class="lineNum">     174 </span><span class="lineCov">          3 :         void AutoDetectTrailer(bool value) { fAutoDetectTrailer = value; }</span>
<a name="175"><span class="lineNum">     175 </span>            :         </a>
<span class="lineNum">     176 </span>            :         /// Returns the value of the flag to check for the end of DDL trailer.
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :         bool CheckForTrailer() const { return fCheckForTrailer; }</span>
<a name="178"><span class="lineNum">     178 </span>            :         </a>
<span class="lineNum">     179 </span>            :         /// Sets the value of the flag to check for the end of DDL trailer.
<span class="lineNum">     180 </span><span class="lineCov">          3 :         void CheckForTrailer(bool value) { fCheckForTrailer = value; }</span>
<span class="lineNum">     181 </span>            :         
<span class="lineNum">     182 </span>            :         /// This method decodes the DDL payload contained in the buffer.
<span class="lineNum">     183 </span>            :         bool Decode(const void* buffer, UInt_t bufferSize);
<span class="lineNum">     184 </span>            :         
<span class="lineNum">     185 </span>            :         /// First try fix data corruption and then decode the DDL payload.
<span class="lineNum">     186 </span>            :         bool Decode(void* buffer, UInt_t bufferSize);
<span class="lineNum">     187 </span>            :         
<span class="lineNum">     188 </span>            :         /// Returns the block marker key.
<span class="lineNum">     189 </span>            :         static UInt_t BlockDataKeyWord() { return fgkBlockDataKey; }
<span class="lineNum">     190 </span>            :         
<span class="lineNum">     191 </span>            :         /// Returns the DSP marker key.
<span class="lineNum">     192 </span>            :         static UInt_t DspDataKeyWord() { return fgkDSPDataKey; }
<span class="lineNum">     193 </span>            :         
<span class="lineNum">     194 </span>            :         /// Returns the bus patch marker key.
<span class="lineNum">     195 </span>            :         static UInt_t BusPatchDataKeyWord() { return fgkBusPatchDataKey; }
<span class="lineNum">     196 </span>            :         
<span class="lineNum">     197 </span>            :         /// Returns the expected padding word value.
<span class="lineNum">     198 </span>            :         static UInt_t PaddingWord() { return fgkPaddingWord; }
<span class="lineNum">     199 </span>            :         
<span class="lineNum">     200 </span>            :         /// Returns the expected end of DDL marker.
<span class="lineNum">     201 </span>            :         static UInt_t EndOfDDLWord() { return fgkEndOfDDL; }
<span class="lineNum">     202 </span>            :         
<span class="lineNum">     203 </span>            : private:
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span>            :         bool fExitOnError; ///&lt; Indicates if we should exit on the very first error.
<span class="lineNum">     206 </span>            :         bool fTryRecover; ///&lt; Indicates if we should try recover from a corrupt structure header or DDL trailer.
<span class="lineNum">     207 </span>            :         bool fSendDataOnParityError; ///&lt; If set to true then we issue a OnData() event even if the data word had a parity error.
<span class="lineNum">     208 </span>            :         bool fHadError; ///&lt; Indicates if we had an error decoding the data.
<span class="lineNum">     209 </span>            :         bool fAutoDetectTrailer; ///&lt; Indicates if we should automatically check for the end of DDL trailer (Default = true).
<span class="lineNum">     210 </span>            :         bool fCheckForTrailer; ///&lt; Indicates if we should check for the end of DDL trailer (Default = true). This flag is ignored if fAutoDetectTrailer is true.
<span class="lineNum">     211 </span>            :         UInt_t fMaxBlocks; ///&lt; Maximum number of block structures allowed in a DDL stream.
<span class="lineNum">     212 </span>            :         UInt_t fMaxDSPs; ///&lt; Maximum number of DSP structures allowed in a DDL stream.
<span class="lineNum">     213 </span>            :         UInt_t fMaxBusPatches; ///&lt; Maximum number of bus patch structures allowed in a DDL stream.
<span class="lineNum">     214 </span>            :         EventHandler fHandler; ///&lt; The event handler which deals with parsing events.
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span>            :         void DecodeBuffer(const UChar_t* start, const UChar_t* end);
<span class="lineNum">     217 </span>            :         
<span class="lineNum">     218 </span>            :         bool DecodeBlockData(
<span class="lineNum">     219 </span>            :                         const AliMUONBlockHeaderStruct* blockHeader,
<span class="lineNum">     220 </span>            :                         const UChar_t* start, const UChar_t* end
<span class="lineNum">     221 </span>            :                 );
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            :         bool DecodeDSPData(const UChar_t* start, const UChar_t* end);
<span class="lineNum">     224 </span>            :         
<span class="lineNum">     225 </span>            :         bool DecodeBusPatchData(const UChar_t* start, const UChar_t* end);
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            :         /// Possible results that can be returned by the TryRecoverStruct method.
<span class="lineNum">     228 </span>            :         enum RecoverResult
<span class="lineNum">     229 </span>            :         {
<span class="lineNum">     230 </span>            :                 kRecoverFailed,        ///&lt; The recovery failed. Cannot continue parsing.
<span class="lineNum">     231 </span>            :                 kStructRecovered,      ///&lt; Indicates that we recovered from a corrupt structure header and can continue processing the given structure.
<span class="lineNum">     232 </span>            :                 kContinueToNextStruct  ///&lt; Must continue parsing the next structure and ignore the current one.
<span class="lineNum">     233 </span>            :         };
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            :         RecoverResult TryRecoverStruct(
<span class="lineNum">     236 </span>            :                         UInt_t expectedKey,
<span class="lineNum">     237 </span>            :                         UInt_t headerSize,
<span class="lineNum">     238 </span>            :                         UInt_t totalLength,
<span class="lineNum">     239 </span>            :                         UInt_t length,
<span class="lineNum">     240 </span>            :                         const UChar_t* structStart,
<span class="lineNum">     241 </span>            :                         const UChar_t* bufferEnd,
<span class="lineNum">     242 </span>            :                         const UChar_t*&amp; dataEnd,
<span class="lineNum">     243 </span>            :                         const UChar_t*&amp; structEnd,
<span class="lineNum">     244 </span>            :                         const UChar_t*&amp; current
<span class="lineNum">     245 </span>            :                 );
<span class="lineNum">     246 </span>            :         
<span class="lineNum">     247 </span>            :         const UChar_t* FindKey(
<span class="lineNum">     248 </span>            :                         UInt_t key, const UChar_t* start, const UChar_t* end
<span class="lineNum">     249 </span>            :                 );
<span class="lineNum">     250 </span>            :         
<span class="lineNum">     251 </span>            :         bool ParityIsOk(UInt_t data);
<span class="lineNum">     252 </span>            :         
<span class="lineNum">     253 </span>            :         static const UInt_t fgkBlockDataKey;     ///&lt; The key word expected to identify block structure headers.
<span class="lineNum">     254 </span>            :         static const UInt_t fgkDSPDataKey;       ///&lt; The key word expected to identify DSP structure headers.
<span class="lineNum">     255 </span>            :         static const UInt_t fgkBusPatchDataKey;  ///&lt; The key word expected to identify bus patch headers.
<span class="lineNum">     256 </span>            :         static const UInt_t fgkPaddingWord;      ///&lt; The expected format of the padding word in the DDL payload.
<span class="lineNum">     257 </span>            :         static const UInt_t fgkEndOfDDL;         ///&lt; The end of DDL trailer word.
<span class="lineNum">     258 </span>            : };
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            : //_____________________________________________________________________________
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            : // The following are the structure header keys which are used to identify the kind
<span class="lineNum">     263 </span>            : // of structure header we are dealing with: block, DSP or bus patch header.
<span class="lineNum">     264 </span>            : template &lt;class EventHandler&gt;
<span class="lineNum">     265 </span>            : const UInt_t AliMUONTrackerDDLDecoder&lt;EventHandler&gt;::fgkBlockDataKey = 0xFC0000FC;
<span class="lineNum">     266 </span>            : template &lt;class EventHandler&gt;
<span class="lineNum">     267 </span>            : const UInt_t AliMUONTrackerDDLDecoder&lt;EventHandler&gt;::fgkDSPDataKey = 0xF000000F;
<span class="lineNum">     268 </span>            : template &lt;class EventHandler&gt;
<span class="lineNum">     269 </span>            : const UInt_t AliMUONTrackerDDLDecoder&lt;EventHandler&gt;::fgkBusPatchDataKey = 0xB000000B;
<span class="lineNum">     270 </span>            : template &lt;class EventHandler&gt;
<span class="lineNum">     271 </span>            : const UInt_t AliMUONTrackerDDLDecoder&lt;EventHandler&gt;::fgkPaddingWord = 0xBEEFFACE;
<span class="lineNum">     272 </span>            : template &lt;class EventHandler&gt;
<span class="lineNum">     273 </span>            : const UInt_t AliMUONTrackerDDLDecoder&lt;EventHandler&gt;::fgkEndOfDDL = 0xD000000D;
<span class="lineNum">     274 </span>            : 
<a name="275"><span class="lineNum">     275 </span>            : </a>
<span class="lineNum">     276 </span>            : template &lt;class EventHandler&gt;
<span class="lineNum">     277 </span>            : bool AliMUONTrackerDDLDecoder&lt;EventHandler&gt;::Decode(const void* buffer, UInt_t bufferSize)
<span class="lineNum">     278 </span>            : {
<span class="lineNum">     279 </span>            :         /// This method should be called to actually decode the DDL payload
<span class="lineNum">     280 </span>            :         /// contained in a memory buffer. The payload should be for a muon tracking
<span class="lineNum">     281 </span>            :         /// chamber DDL stream.
<span class="lineNum">     282 </span>            :         /// As the decoder progresses it will make method calls to the event handler
<span class="lineNum">     283 </span>            :         /// instance (which can be accessed with the GetHandler() method) to indicate
<span class="lineNum">     284 </span>            :         /// the start of the new block, DSP and bus patch headers. For every raw
<span class="lineNum">     285 </span>            :         /// data word the OnData method of the event handler is called.
<span class="lineNum">     286 </span>            :         ///
<span class="lineNum">     287 </span>            :         /// If an error occurs during the parse because the data is corrupt then
<span class="lineNum">     288 </span>            :         /// the OnError method is called indicating what the problem was.
<span class="lineNum">     289 </span>            :         /// Decoding will stop at this point unless the fExitOnError flag is set
<span class="lineNum">     290 </span>            :         /// to false. Also raw data words which contain a parity error are only
<span class="lineNum">     291 </span>            :         /// sent to the event handler with OnData if the fSendDataOnParityError
<span class="lineNum">     292 </span>            :         /// flag is set to true. There is also an optional flag fTryRecover which
<span class="lineNum">     293 </span>            :         /// can enable logic which will attempt to recover the header structures found
<span class="lineNum">     294 </span>            :         /// in the DDL payload if they are found to be inconsistent (assumed corrupt).
<span class="lineNum">     295 </span>            :         /// fTryRecover set to true will also enable recovery from a corrupt
<span class="lineNum">     296 </span>            :         /// DDL trailer marking the end of DDL payload.
<span class="lineNum">     297 </span>            :         ///
<span class="lineNum">     298 </span>            :         /// \param buffer  This is the pointer to the start of the memory buffer
<span class="lineNum">     299 </span>            :         ///     containing the DDL payload. Remember that this must be the start of
<span class="lineNum">     300 </span>            :         ///     the payload and not the DDL stream. That is, this pointer should be
<span class="lineNum">     301 </span>            :         ///     equal to: DDL start pointer + 8 * sizeof(UInt_t).
<span class="lineNum">     302 </span>            :         /// \param bufferSize  This is the pointer to the first byte just past the
<span class="lineNum">     303 </span>            :         ///     end of the block structure.
<span class="lineNum">     304 </span>            :         /// \return Returns false if there was any problem with decoding the data,
<span class="lineNum">     305 </span>            :         ///     and true otherwise. Note: the data may have been partially decoded
<span class="lineNum">     306 </span>            :         ///     even if false was returned, which would be indicated by at least one
<span class="lineNum">     307 </span>            :         ///     call to the event handlers OnData method.
<span class="lineNum">     308 </span>            :         
<span class="lineNum">     309 </span><span class="lineCov">        160 :         assert( buffer != NULL );</span>
<span class="lineNum">     310 </span>            :         
<span class="lineNum">     311 </span><span class="lineCov">         80 :         fHadError = false;</span>
<span class="lineNum">     312 </span>            :         
<span class="lineNum">     313 </span>            :         // We are basically implementing something like a recursive decent parser.
<span class="lineNum">     314 </span>            :         // So start by marking the start of buffer position and end of buffer.
<span class="lineNum">     315 </span>            :         const UChar_t* start = reinterpret_cast&lt;const UChar_t*&gt;(buffer);
<span class="lineNum">     316 </span><span class="lineCov">         80 :         const UChar_t* end = start + bufferSize;</span>
<span class="lineNum">     317 </span>            :         
<span class="lineNum">     318 </span><span class="lineCov">         80 :         fHandler.OnNewBuffer(buffer, bufferSize);</span>
<span class="lineNum">     319 </span><span class="lineCov">         80 :         DecodeBuffer(start, end);</span>
<span class="lineNum">     320 </span><span class="lineCov">         80 :         fHandler.OnEndOfBuffer(buffer, bufferSize);</span>
<span class="lineNum">     321 </span><span class="lineCov">         80 :         return not fHadError;</span>
<span class="lineNum">     322 </span>            : }
<span class="lineNum">     323 </span>            : 
<a name="324"><span class="lineNum">     324 </span>            : </a>
<span class="lineNum">     325 </span>            : template &lt;class EventHandler&gt;
<span class="lineNum">     326 </span>            : bool AliMUONTrackerDDLDecoder&lt;EventHandler&gt;::Decode(void* buffer, UInt_t bufferSize)
<span class="lineNum">     327 </span>            : {
<span class="lineNum">     328 </span>            :         /// This decoding method performs a special checks to see if the DDL
<span class="lineNum">     329 </span>            :         /// corruption is fixable and then fixes the buffer by modifying it directly.
<span class="lineNum">     330 </span>            :         /// The fixes only apply if the fTryRecover flag is enabled.
<span class="lineNum">     331 </span>            :         /// \note buffer might be modified.
<span class="lineNum">     332 </span>            :         
<span class="lineNum">     333 </span><span class="lineCov">        160 :         assert( buffer != NULL );</span>
<span class="lineNum">     334 </span><span class="lineCov">         80 :         if (fTryRecover)</span>
<span class="lineNum">     335 </span>            :         {
<span class="lineNum">     336 </span>            :                 ///////////////////////////////////////////////////////
<span class="lineNum">     337 </span>            :                 // Trick to recover B off data Runs : 119041, 119047, 119055, 119057
<span class="lineNum">     338 </span>            :                 // A. Baldisseri May 2010
<span class="lineNum">     339 </span>            :                 // Check if 16 32-bit words from a buspatch have been inserted
<span class="lineNum">     340 </span>            :                 // incorrectly immediately at the beginning of the DDL payload.
<span class="lineNum">     341 </span>            :                 UChar_t* bufferChar = reinterpret_cast&lt;UChar_t*&gt;(buffer);
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :                 UInt_t* bufferInt = reinterpret_cast&lt;UInt_t*&gt;(buffer);</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :                 if (bufferSize &gt; 18*4 // is the buffer large enough to check the header.</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :                     and bufferInt[0] != fgkBlockDataKey and bufferInt[16] == fgkBlockDataKey // was the header incorrectly moved.</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :                     and bufferSize &gt; bufferInt[17]*4 + sizeof(AliMUONBlockHeaderStruct) // is the buffer large enough for the second block header.</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :                     and bufferInt[bufferInt[17]] == fgkBlockDataKey  // Check that the second header is in the correct location.</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :                     and bufferInt[17] == bufferInt[18] + 8  // Make sure that both lengths are correct.</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :                     and (bufferInt[17] + bufferInt[bufferInt[17]+1]+2)*4 == bufferSize // Check that both blocks will have the correct size if we make the fix.</span>
<span class="lineNum">     349 </span>            :                    )
<span class="lineNum">     350 </span>            :                 {
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :                         UChar_t tmpbuf[16*4];</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :                         memcpy(tmpbuf, bufferChar, 16*4);</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :                         size_t sizeToMove = bufferInt[17]*4-16*4;</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :                         memmove(bufferChar, bufferChar+16*4, sizeToMove);</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :                         memcpy(bufferChar + sizeToMove, tmpbuf, 16*4);</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     358 </span><span class="lineCov">         80 :         return Decode(reinterpret_cast&lt;const void*&gt;(buffer), bufferSize);</span>
<span class="lineNum">     359 </span>            : }
<span class="lineNum">     360 </span>            : 
<a name="361"><span class="lineNum">     361 </span>            : </a>
<span class="lineNum">     362 </span>            : template &lt;class EventHandler&gt;
<span class="lineNum">     363 </span>            : void AliMUONTrackerDDLDecoder&lt;EventHandler&gt;::DecodeBuffer(
<span class="lineNum">     364 </span>            :                 const UChar_t* start, const UChar_t* end
<span class="lineNum">     365 </span>            :         )
<span class="lineNum">     366 </span>            : {
<span class="lineNum">     367 </span>            :         /// This method decodes the buffer's payload data. It unpacks the block
<span class="lineNum">     368 </span>            :         /// structures contained inside and then for each block it calls the
<span class="lineNum">     369 </span>            :         /// OnNewBlock method for the event handler to signal the start of each new
<span class="lineNum">     370 </span>            :         /// block structure. OnEndOfBlock is called once each block is processed.
<span class="lineNum">     371 </span>            :         /// \param start  This is the pointer to the start of the buffer.
<span class="lineNum">     372 </span>            :         /// \param end  This is the pointer to the first byte just past the
<span class="lineNum">     373 </span>            :         ///             end of the buffer.
<span class="lineNum">     374 </span>            :         /// fHadError is set to true if there were any errors decoding the buffer
<span class="lineNum">     375 </span>            :         /// and the OnError method of the callback event handler is called for
<span class="lineNum">     376 </span>            :         /// each error.
<span class="lineNum">     377 </span>            :         
<span class="lineNum">     378 </span><span class="lineCov">        160 :         const UChar_t* current = start;</span>
<span class="lineNum">     379 </span><span class="lineCov">         80 :         const UInt_t* bufferStart = reinterpret_cast&lt;const UInt_t*&gt;(start);</span>
<span class="lineNum">     380 </span><span class="lineCov">         80 :         const UInt_t* bufferEnd = reinterpret_cast&lt;const UInt_t*&gt;(end);</span>
<span class="lineNum">     381 </span>            :         bool problemWithTrailer = false;
<span class="lineNum">     382 </span>            :         
<span class="lineNum">     383 </span>            :         // The DDL payload normally has a 2 word trailer which contains the end of
<span class="lineNum">     384 </span>            :         // DDL markers 0xD000000D. But this is not the case for older simulated
<span class="lineNum">     385 </span>            :         // data so if we are auto-detecting the trailer then we need to carefully
<span class="lineNum">     386 </span>            :         // check if these words are there or not.
<span class="lineNum">     387 </span>            :         const UChar_t* endOfBlocks = end;
<span class="lineNum">     388 </span><span class="lineCov">         80 :         const UInt_t* trailerWords = reinterpret_cast&lt;const UInt_t*&gt;(end) - 2;</span>
<span class="lineNum">     389 </span><span class="lineCov">         80 :         if (fAutoDetectTrailer)</span>
<span class="lineNum">     390 </span>            :         {
<span class="lineNum">     391 </span><span class="lineCov">        160 :                 if (trailerWords &gt;= bufferStart and trailerWords &lt; bufferEnd</span>
<span class="lineNum">     392 </span><span class="lineCov">        240 :                     and *trailerWords == fgkEndOfDDL and *(trailerWords+1) == fgkEndOfDDL</span>
<span class="lineNum">     393 </span>            :                    )
<span class="lineNum">     394 </span>            :                 {
<span class="lineNum">     395 </span>            :                         // Found the trailer so reposition the end of blocks marker.
<span class="lineNum">     396 </span><span class="lineCov">         80 :                         endOfBlocks = reinterpret_cast&lt;const UChar_t*&gt;(trailerWords);</span>
<span class="lineNum">     397 </span><span class="lineCov">         80 :                 }</span>
<span class="lineNum">     398 </span>            :                 // else assume we are dealing with the older data format.
<span class="lineNum">     399 </span>            :         }
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :         else if (fCheckForTrailer)</span>
<span class="lineNum">     401 </span>            :         {
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :                 if (trailerWords &gt;= bufferStart and trailerWords &lt; bufferEnd</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :                     and *trailerWords == fgkEndOfDDL and *(trailerWords+1) == fgkEndOfDDL</span>
<span class="lineNum">     404 </span>            :                    )
<span class="lineNum">     405 </span>            :                 {
<span class="lineNum">     406 </span>            :                         // Found the trailer so reposition the end of blocks marker.
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :                         endOfBlocks = reinterpret_cast&lt;const UChar_t*&gt;(trailerWords);</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">     409 </span>            :                 else
<span class="lineNum">     410 </span>            :                 {
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :                         if (trailerWords+1 &gt;= bufferStart and trailerWords+1 &lt; bufferEnd and *(trailerWords+1) == fgkEndOfDDL)</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :                                 fHandler.OnError(EventHandler::kTooFewDDLTrailerWords, trailerWords+1);</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :                         else if (trailerWords &gt;= bufferStart and trailerWords &lt; bufferEnd and *(trailerWords) == fgkEndOfDDL)</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :                                 fHandler.OnError(EventHandler::kTooFewDDLTrailerWords, trailerWords);</span>
<span class="lineNum">     415 </span>            :                         else
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :                                 fHandler.OnError(EventHandler::kNoDDLTrailerWords, end);</span>
<span class="lineNum">     417 </span>            :         
<span class="lineNum">     418 </span>            :                         // Stop the decoding if so requested by the user, otherwise
<span class="lineNum">     419 </span>            :                         // remember about the error so that we return false from the
<span class="lineNum">     420 </span>            :                         // Decode() method and continue decoding.
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :                         fHadError = true;</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :                         if (fExitOnError) return;</span>
<span class="lineNum">     423 </span>            :                         
<span class="lineNum">     424 </span>            :                         // Mark that there was a problem with the trailer so that
<span class="lineNum">     425 </span>            :                         // for subsequent errors we try to deal with this better.
<span class="lineNum">     426 </span>            :                         problemWithTrailer = true;
<span class="lineNum">     427 </span>            :                         
<span class="lineNum">     428 </span>            :                         // We can also try figure out how many trailer words there
<span class="lineNum">     429 </span>            :                         // actually are and move the end of blocks marker back.
<span class="lineNum">     430 </span>            :                         
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :                         if (fTryRecover)</span>
<span class="lineNum">     432 </span>            :                         {
<span class="lineNum">     433 </span>            :                                 trailerWords = bufferEnd;
<span class="lineNum">     434 </span>            :                                 // There should only be a max of 2 trailer words.
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :                                 if (trailerWords-2 &gt;= bufferStart and trailerWords-2 &lt; bufferEnd and *(trailerWords-2) == fgkEndOfDDL)</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :                                         trailerWords -= 2;</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :                                 else if (trailerWords-1 &gt;= bufferStart and trailerWords-1 &lt; bufferEnd and *(trailerWords-1) == fgkEndOfDDL)</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :                                         trailerWords -= 1;</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :                                 endOfBlocks = reinterpret_cast&lt;const UChar_t*&gt;(trailerWords);</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :                         }</span>
<span class="lineNum">     441 </span>            :                 }
<span class="lineNum">     442 </span>            :         }
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            :         UInt_t blockCount = 0; // Indicates the number of blocks decoded.
<span class="lineNum">     445 </span><span class="lineCov">        320 :         while (current &lt; endOfBlocks)</span>
<span class="lineNum">     446 </span>            :         {
<span class="lineNum">     447 </span>            :                 // Mark the start of the block structure.
<span class="lineNum">     448 </span>            :                 const UChar_t* blockStart = current;
<span class="lineNum">     449 </span>            :                 
<span class="lineNum">     450 </span>            :                 // Get the block header, move the current pointer just past the end
<span class="lineNum">     451 </span>            :                 // of the header and check that we have not overflowed the buffer.
<span class="lineNum">     452 </span>            :                 const AliMUONBlockHeaderStruct* blockHeader
<span class="lineNum">     453 </span><span class="lineCov">        160 :                         = reinterpret_cast&lt;const AliMUONBlockHeaderStruct*&gt;(blockStart);</span>
<span class="lineNum">     454 </span><span class="lineCov">        160 :                 current += sizeof(AliMUONBlockHeaderStruct);</span>
<span class="lineNum">     455 </span><span class="lineCov">        320 :                 if (current &gt; endOfBlocks or current &lt; start)</span>
<span class="lineNum">     456 </span>            :                 {
<span class="lineNum">     457 </span>            :                         // If we overflowed the pointer and already had an error then
<span class="lineNum">     458 </span>            :                         // we are clearly lost so just stop decoding before we segfault.
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :                         if (current &lt; start and fHadError) return;</span>
<span class="lineNum">     460 </span>            :                         
<span class="lineNum">     461 </span>            :                         // We first check if we actually hit the end of DDL markers
<span class="lineNum">     462 </span>            :                         // If we did then either we did not/could not recover from
<span class="lineNum">     463 </span>            :                         // a corrupt trailer or we did not detect a correct trailer
<span class="lineNum">     464 </span>            :                         // in auto-detect mode.
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :                         trailerWords = reinterpret_cast&lt;const UInt_t*&gt;(blockHeader);</span>
<span class="lineNum">     466 </span>            :                         // The &quot;trailerWords+1 &lt;= bufferEnd&quot; checks that we are
<span class="lineNum">     467 </span>            :                         // not reading beyond the end of the buffer.
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :                         if (trailerWords+1 &lt;= bufferEnd and *trailerWords == fgkEndOfDDL)</span>
<span class="lineNum">     469 </span>            :                         {
<span class="lineNum">     470 </span>            :                                 // If we aready knew the trailer was corrupt then just
<span class="lineNum">     471 </span>            :                                 // return because the error was already announced.
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :                                 if (problemWithTrailer) return;</span>
<span class="lineNum">     473 </span>            :                                 
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :                                 if (fAutoDetectTrailer)</span>
<span class="lineNum">     475 </span>            :                                 {
<span class="lineNum">     476 </span>            :                                         // If we got here then there is at least one correct trailer
<span class="lineNum">     477 </span>            :                                         // word, but since we did not detect a correct trailer then
<span class="lineNum">     478 </span>            :                                         // there must be only one. Announce the error and exit.
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :                                         fHandler.OnError(EventHandler::kTooFewDDLTrailerWords, trailerWords);</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :                                         fHadError = true;</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :                                         return;</span>
<span class="lineNum">     482 </span>            :                                 }
<span class="lineNum">     483 </span>            :                         }
<span class="lineNum">     484 </span>            :                         
<span class="lineNum">     485 </span>            :                         // So we only got part of a block header at the very end
<span class="lineNum">     486 </span>            :                         // of the buffer. Nothing to do but report the error and exit.
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :                         if (blockCount == fMaxBlocks)</span>
<span class="lineNum">     488 </span>            :                                 // Special case where we got all the blocks we
<span class="lineNum">     489 </span>            :                                 // expected, so the remaining data must be rubbish.
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :                                 fHandler.OnError(EventHandler::kBufferTooBig, blockHeader);</span>
<span class="lineNum">     491 </span>            :                         else
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :                                 fHandler.OnError(EventHandler::kNoBlockHeader, blockHeader);</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :                         fHadError = true;</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :                         return;</span>
<span class="lineNum">     495 </span>            :                 }
<span class="lineNum">     496 </span>            :                 
<span class="lineNum">     497 </span>            :                 // The header fits the buffer so we can mark the data start and
<span class="lineNum">     498 </span>            :                 // read from the header to find the end of data and block pointers.
<span class="lineNum">     499 </span>            :                 const UChar_t* dataStart = current;
<span class="lineNum">     500 </span><span class="lineCov">        160 :                 current += blockHeader-&gt;fLength * sizeof(UInt_t);</span>
<span class="lineNum">     501 </span><span class="lineCov">        160 :                 const UChar_t* dataEnd = current;</span>
<span class="lineNum">     502 </span><span class="lineCov">        320 :                 const UChar_t* blockEnd = blockStart</span>
<span class="lineNum">     503 </span><span class="lineCov">        160 :                         + blockHeader-&gt;fTotalLength * sizeof(UInt_t);</span>
<span class="lineNum">     504 </span>            :                 
<span class="lineNum">     505 </span>            :                 // Now we need to check for the following things:
<span class="lineNum">     506 </span>            :                 // 1) Is the end of block or end of data pointer outside the buffer
<span class="lineNum">     507 </span>            :                 //    boundaries.
<span class="lineNum">     508 </span>            :                 // 2) Are the values for these pointers the same.
<span class="lineNum">     509 </span>            :                 // 3) Is the expected data key in the header present.
<span class="lineNum">     510 </span>            :                 // If any of the above fail then we know there is a problem with
<span class="lineNum">     511 </span>            :                 // the block header. It must be corrupted somehow.
<span class="lineNum">     512 </span><span class="lineCov">        320 :                 if (blockHeader-&gt;fDataKey != fgkBlockDataKey</span>
<span class="lineNum">     513 </span><span class="lineCov">        480 :                     or dataEnd &gt; endOfBlocks or dataEnd &lt; start</span>
<span class="lineNum">     514 </span><span class="lineCov">        480 :                     or blockEnd &gt; endOfBlocks or blockEnd &lt; start</span>
<span class="lineNum">     515 </span><span class="lineCov">        320 :                     or dataEnd != blockEnd)</span>
<span class="lineNum">     516 </span>            :                 {
<span class="lineNum">     517 </span>            :                         // So let us see what exactly is wrong and report this.
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :                         if (blockCount == fMaxBlocks)</span>
<span class="lineNum">     519 </span>            :                         {
<span class="lineNum">     520 </span>            :                                 // Special case where we got all the blocks we
<span class="lineNum">     521 </span>            :                                 // expected, so the remaining data must be rubbish.
<span class="lineNum">     522 </span>            :                                 // Don't even bother trying to recover the data.
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :                                 fHandler.OnError(EventHandler::kBufferTooBig, blockHeader);</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :                                 fHadError = true;</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :                                 return;</span>
<span class="lineNum">     526 </span>            :                         }
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :                         if (blockHeader-&gt;fDataKey != fgkBlockDataKey)</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :                                 fHandler.OnError(EventHandler::kBadBlockKey, &amp;blockHeader-&gt;fDataKey);</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :                         if (blockEnd &gt; endOfBlocks or blockEnd &lt; start)</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :                                 fHandler.OnError(EventHandler::kBadBlockLength, &amp;blockHeader-&gt;fLength);</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :                         if (dataEnd &gt; endOfBlocks or dataEnd &lt; start)</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :                                 fHandler.OnError(EventHandler::kBadBlockTotalLength, &amp;blockHeader-&gt;fTotalLength);</span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :                         if (dataEnd != blockEnd)</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :                                 fHandler.OnError(EventHandler::kBlockLengthMismatch, blockHeader);</span>
<span class="lineNum">     535 </span>            :                         
<span class="lineNum">     536 </span>            :                         // Stop the decoding if so requested by the user, otherwise
<span class="lineNum">     537 </span>            :                         // remember about the error so that we return false from the
<span class="lineNum">     538 </span>            :                         // Decode() method and continue decoding.
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :                         fHadError = true;</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :                         if (fExitOnError) return;</span>
<span class="lineNum">     541 </span>            :                         
<span class="lineNum">     542 </span>            :                         // Try to recover from the corrupt header.
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :                         RecoverResult result = TryRecoverStruct(</span>
<span class="lineNum">     544 </span>            :                                         fgkBlockDataKey, sizeof(AliMUONBlockHeaderStruct),
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :                                         blockHeader-&gt;fTotalLength, blockHeader-&gt;fLength,</span>
<span class="lineNum">     546 </span>            :                                         blockStart, endOfBlocks, dataEnd, blockEnd, current
<span class="lineNum">     547 </span>            :                                 );
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :                         if (result == kContinueToNextStruct)</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :                                 continue; // Try the next block at 'current'.</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :                         if (result == kRecoverFailed) return;</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">     552 </span>            :                 
<span class="lineNum">     553 </span>            :                 // At this point we certainly have a valid block header, so we
<span class="lineNum">     554 </span>            :                 // need to check if we have more blocks than we expected. If not
<span class="lineNum">     555 </span>            :                 // then we can indicate we have another block and decode its data.
<span class="lineNum">     556 </span><span class="lineCov">        320 :                 if (++blockCount &gt; fMaxBlocks)</span>
<span class="lineNum">     557 </span>            :                 {
<span class="lineNum">     558 </span><span class="lineCov">        160 :                         fHandler.OnError(EventHandler::kTooManyBlocks, current);</span>
<span class="lineNum">     559 </span>            :                         
<span class="lineNum">     560 </span>            :                         // In this case we stop the decoding because clearly
<span class="lineNum">     561 </span>            :                         // something is seriously wrong with the data if we are
<span class="lineNum">     562 </span>            :                         // getting more blocks than expected.
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :                         fHadError = true;</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :                         return;</span>
<span class="lineNum">     565 </span>            :                 }
<span class="lineNum">     566 </span>            :                 
<span class="lineNum">     567 </span><span class="lineCov">        160 :                 fHandler.OnNewBlock(blockHeader, dataStart);</span>
<span class="lineNum">     568 </span><span class="lineCov">        160 :                 if (not DecodeBlockData(blockHeader, dataStart, dataEnd))</span>
<span class="lineNum">     569 </span>            :                 {
<span class="lineNum">     570 </span>            :                         // At this point we had a problem decoding the block structure's
<span class="lineNum">     571 </span>            :                         // data. Thus we should stop further decoding if so requested by
<span class="lineNum">     572 </span>            :                         // the user. Note the fHadError flag is already marked inside
<span class="lineNum">     573 </span>            :                         // DecodeBlockData.
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :                         if (fExitOnError)</span>
<span class="lineNum">     575 </span>            :                         {
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :                                 fHandler.OnEndOfBlock(blockHeader, dataStart);</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :                                 return;</span>
<span class="lineNum">     578 </span>            :                         }
<span class="lineNum">     579 </span>            :                 }
<span class="lineNum">     580 </span><span class="lineCov">        160 :                 fHandler.OnEndOfBlock(blockHeader, dataStart);</span>
<span class="lineNum">     581 </span><span class="lineCov">        320 :         }</span>
<span class="lineNum">     582 </span><span class="lineCov">        160 : }</span>
<span class="lineNum">     583 </span>            : 
<a name="584"><span class="lineNum">     584 </span>            : </a>
<span class="lineNum">     585 </span>            : template &lt;class EventHandler&gt;
<span class="lineNum">     586 </span>            : bool AliMUONTrackerDDLDecoder&lt;EventHandler&gt;::DecodeBlockData(
<span class="lineNum">     587 </span>            :                 const AliMUONBlockHeaderStruct* blockHeader,
<span class="lineNum">     588 </span>            :                 const UChar_t* start, const UChar_t* end
<span class="lineNum">     589 </span>            :         )
<span class="lineNum">     590 </span>            : {
<span class="lineNum">     591 </span>            :         /// This method decodes a block structure's data payload. It unpacks the
<span class="lineNum">     592 </span>            :         /// DSP structures contained inside and then for each DSP it calls the
<span class="lineNum">     593 </span>            :         /// OnNewDSP method for the event handler to signal the start of each new
<span class="lineNum">     594 </span>            :         /// DSP structure.
<span class="lineNum">     595 </span>            :         /// \param blockHeader
<span class="lineNum">     596 </span>            :         /// \param start  This is the pointer to the start of the block
<span class="lineNum">     597 </span>            :         ///               structure's data.
<span class="lineNum">     598 </span>            :         /// \param end  This is the pointer to the first byte just past the
<span class="lineNum">     599 </span>            :         ///             end of the block structure.
<span class="lineNum">     600 </span>            :         /// \return If the block structure's data was decoded without errors
<span class="lineNum">     601 </span>            :         ///      or we could recover from the errors, then true is returned.
<span class="lineNum">     602 </span>            :         ///      False is returned otherwise.
<span class="lineNum">     603 </span>            :         
<span class="lineNum">     604 </span><span class="lineCov">        320 :         const UChar_t* current = start;</span>
<span class="lineNum">     605 </span>            :         
<span class="lineNum">     606 </span>            :         UInt_t dspCount = 0; // Indicates the number of DSPs decoded.
<span class="lineNum">     607 </span><span class="lineCov">       1056 :         while (current &lt; end)</span>
<span class="lineNum">     608 </span>            :         {
<span class="lineNum">     609 </span>            :                 // Mark the start of the DSP structure.
<span class="lineNum">     610 </span>            :                 const UChar_t* dspStart = current;
<span class="lineNum">     611 </span>            :                 
<span class="lineNum">     612 </span>            :                 // Get the DSP header, move the current pointer just past the end
<span class="lineNum">     613 </span>            :                 // of the header and check that we have not overflowed the buffer.
<span class="lineNum">     614 </span>            :                 const AliMUONDSPHeaderStruct* dspHeader
<span class="lineNum">     615 </span><span class="lineCov">        736 :                         = reinterpret_cast&lt;const AliMUONDSPHeaderStruct*&gt;(dspStart);</span>
<span class="lineNum">     616 </span><span class="lineCov">        736 :                 current += sizeof(AliMUONDSPHeaderStruct);</span>
<span class="lineNum">     617 </span><span class="lineCov">       1472 :                 if (current &gt; end or current &lt; start)</span>
<span class="lineNum">     618 </span>            :                 {
<span class="lineNum">     619 </span>            :                         // If we overflowed the pointer and already had an error then
<span class="lineNum">     620 </span>            :                         // we are clearly lost so just stop decoding before we segfault.
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :                         if (current &lt; start and fHadError) return false;</span>
<span class="lineNum">     622 </span>            :                         
<span class="lineNum">     623 </span>            :                         // So we only got part of a DSP header at the very end of
<span class="lineNum">     624 </span>            :                         // the block structure buffer. Nothing to do but report the
<span class="lineNum">     625 </span>            :                         // error and exit. Set fHadError in case of further decoding.
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :                         fHandler.OnError(EventHandler::kNoDSPHeader, dspHeader);</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :                         fHadError = true;</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :                         return false;</span>
<span class="lineNum">     629 </span>            :                 }
<span class="lineNum">     630 </span>            :                 
<span class="lineNum">     631 </span>            :                 // The header fits the buffer so we can mark the data start and
<span class="lineNum">     632 </span>            :                 // read from the header to find the end of data and DSP pointers.
<span class="lineNum">     633 </span>            :                 const UChar_t* dataStart = current;
<span class="lineNum">     634 </span><span class="lineCov">        736 :                 current += dspHeader-&gt;fLength * sizeof(UInt_t);</span>
<span class="lineNum">     635 </span><span class="lineCov">        736 :                 const UChar_t* dataEnd = current;</span>
<span class="lineNum">     636 </span><span class="lineCov">        736 :                 const UChar_t* dspEnd = dspStart + dspHeader-&gt;fTotalLength * sizeof(UInt_t);</span>
<span class="lineNum">     637 </span>            :                 
<span class="lineNum">     638 </span>            :                 // Now we need to check for the following things:
<span class="lineNum">     639 </span>            :                 // 1) Is the end of DSP or end of data pointer outside the buffer
<span class="lineNum">     640 </span>            :                 //    boundaries.
<span class="lineNum">     641 </span>            :                 // 2) Are the values for these pointers the same.
<span class="lineNum">     642 </span>            :                 // 3) Is the expected data key in the header present.
<span class="lineNum">     643 </span>            :                 // If any of the above fail then we know there is a problem with
<span class="lineNum">     644 </span>            :                 // the DSP header. It must be corrupted somehow.
<span class="lineNum">     645 </span><span class="lineCov">       1472 :                 if (dspHeader-&gt;fDataKey != fgkDSPDataKey</span>
<span class="lineNum">     646 </span><span class="lineCov">       2208 :                     or dataEnd &gt; end or dataEnd &lt; start</span>
<span class="lineNum">     647 </span><span class="lineCov">       2208 :                     or dspEnd &gt; end or dspEnd &lt; start</span>
<span class="lineNum">     648 </span><span class="lineCov">       1472 :                     or dataEnd != dspEnd)</span>
<span class="lineNum">     649 </span>            :                 {
<span class="lineNum">     650 </span>            :                         // So let us see what exactly is wrong and report this.
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :                         if (dspHeader-&gt;fDataKey != fgkDSPDataKey)</span>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :                                 fHandler.OnError(EventHandler::kBadDSPKey, &amp;dspHeader-&gt;fDataKey);</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :                         if (dspEnd &gt; end or dspEnd &lt; start)</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :                                 fHandler.OnError(EventHandler::kBadDSPLength, &amp;dspHeader-&gt;fLength);</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :                         if (dataEnd &gt; end or dataEnd &lt; start)</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :                                 fHandler.OnError(EventHandler::kBadDSPTotalLength, &amp;dspHeader-&gt;fTotalLength);</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :                         if (dataEnd != dspEnd)</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :                                 fHandler.OnError(EventHandler::kDSPLengthMismatch, dspHeader);</span>
<span class="lineNum">     659 </span>            :                         
<span class="lineNum">     660 </span>            :                         // Indicate we had and error and stop the decoding if so
<span class="lineNum">     661 </span>            :                         // requested by the user.
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :                         fHadError = true;</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :                         if (fExitOnError) return false;</span>
<span class="lineNum">     664 </span>            :                         
<span class="lineNum">     665 </span>            :                         // Try to recover from the corrupt header.
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :                         RecoverResult result = TryRecoverStruct(</span>
<span class="lineNum">     667 </span>            :                                         fgkDSPDataKey, sizeof(AliMUONDSPHeaderStruct),
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :                                         dspHeader-&gt;fTotalLength, dspHeader-&gt;fLength,</span>
<span class="lineNum">     669 </span>            :                                         dspStart, end, dataEnd, dspEnd, current
<span class="lineNum">     670 </span>            :                                 );
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :                         if (result == kContinueToNextStruct)</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :                                 continue; // Try the next DSP at 'current'.</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :                         if (result == kRecoverFailed) return false;</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">     675 </span>            :                 
<span class="lineNum">     676 </span>            :                 // At this point we certainly have a valid DSP header, so we
<span class="lineNum">     677 </span>            :                 // need to check if we have more DSPs than we expected. If not
<span class="lineNum">     678 </span>            :                 // then we can indicate we have another DSP and decode its data.
<span class="lineNum">     679 </span><span class="lineCov">       1472 :                 if (++dspCount &gt; fMaxDSPs)</span>
<span class="lineNum">     680 </span>            :                 {
<span class="lineNum">     681 </span><span class="lineCov">        736 :                         fHandler.OnError(EventHandler::kTooManyDSPs, current);</span>
<span class="lineNum">     682 </span>            :                         
<span class="lineNum">     683 </span>            :                         // In this case we stop further decoding of the block
<span class="lineNum">     684 </span>            :                         // structure data because clearly something is seriously
<span class="lineNum">     685 </span>            :                         // wrong if we are getting more DSPs than expected.
<span class="lineNum">     686 </span>            :                         // Indicate that we had an error so the Decode() method
<span class="lineNum">     687 </span>            :                         // returns false.
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :                         fHadError = true;</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :                         return false;</span>
<span class="lineNum">     690 </span>            :                 }
<span class="lineNum">     691 </span>            :                 
<span class="lineNum">     692 </span><span class="lineCov">        736 :                 fHandler.OnNewDSP(dspHeader, dataStart);</span>
<span class="lineNum">     693 </span>            :                 
<span class="lineNum">     694 </span>            :                 // Check the error word in the header.
<span class="lineNum">     695 </span><span class="lineCov">        736 :                 if (dspHeader-&gt;fErrorWord != 0x0)</span>
<span class="lineNum">     696 </span>            :                 {
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :                         if (dspHeader-&gt;fErrorWord == (0x000000B1 | blockHeader-&gt;fDSPId)</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :                             or dspHeader-&gt;fErrorWord == (0x00000091 | blockHeader-&gt;fDSPId)</span>
<span class="lineNum">     699 </span>            :                            )
<span class="lineNum">     700 </span>            :                         {
<span class="lineNum">     701 </span>            :                                 // An event with a glitch in the readout has been detected.
<span class="lineNum">     702 </span>            :                                 // It means that somewhere a 1 byte word has been randomly
<span class="lineNum">     703 </span>            :                                 // inserted and all the readout sequence is shifted until
<span class="lineNum">     704 </span>            :                                 // the next event.
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :                                 fHandler.OnError(EventHandler::kGlitchFound, &amp;dspHeader-&gt;fErrorWord);</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :                         }</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :                         else if ((dspHeader-&gt;fErrorWord &amp; 0x0000FFF0) == 0x220)</span>
<span class="lineNum">     708 </span>            :                         {
<span class="lineNum">     709 </span>            :                                 // Detected a TOKEN_LOST error which can affect the dead time in the DAQ.
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :                                 fHandler.OnError(EventHandler::kTokenLost, &amp;dspHeader-&gt;fErrorWord);</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :                         }</span>
<span class="lineNum">     712 </span>            :                         else
<span class="lineNum">     713 </span>            :                         {
<span class="lineNum">     714 </span>            :                                 // The DSP error code is non-zero but has an unknown code.
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :                                 fHandler.OnError(EventHandler::kUnknownDspError, &amp;dspHeader-&gt;fErrorWord);</span>
<span class="lineNum">     716 </span>            :                         }
<span class="lineNum">     717 </span>            :                         
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :                         fHadError = true;</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :                         if (fExitOnError)</span>
<span class="lineNum">     720 </span>            :                         {
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :                                 fHandler.OnEndOfDSP(dspHeader, dataStart);</span>
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :                                 return false;</span>
<span class="lineNum">     723 </span>            :                         }
<span class="lineNum">     724 </span>            :                         
<span class="lineNum">     725 </span>            :                         // Try recover by finding the very next DSP and continue
<span class="lineNum">     726 </span>            :                         // decoding from there. Note: to achieve this all we have to
<span class="lineNum">     727 </span>            :                         // do is continue to the next iteration, because the logic
<span class="lineNum">     728 </span>            :                         // will land up calling the FindKey method within the
<span class="lineNum">     729 </span>            :                         // TryRecoverStruct method above.
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :                         if (fTryRecover)</span>
<span class="lineNum">     731 </span>            :                         {
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :                                 fHandler.OnEndOfDSP(dspHeader, dataStart);</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :                                 continue;</span>
<span class="lineNum">     734 </span>            :                         }
<span class="lineNum">     735 </span>            :                 }
<span class="lineNum">     736 </span>            :                 
<span class="lineNum">     737 </span>            :                 // Check if we are padding. If we are, then the bus patch data is
<span class="lineNum">     738 </span>            :                 // actually 4 bytes smaller and the last word is a padding word.
<span class="lineNum">     739 </span><span class="lineCov">        736 :                 if (dspHeader-&gt;fPaddingWord == 1)</span>
<span class="lineNum">     740 </span>            :                 {
<span class="lineNum">     741 </span><span class="lineCov">         50 :                         dataEnd -= sizeof(UInt_t);</span>
<span class="lineNum">     742 </span>            :                         
<span class="lineNum">     743 </span>            :                         // Check the pad word is correct.
<span class="lineNum">     744 </span><span class="lineCov">         50 :                         const UInt_t* padWord = reinterpret_cast&lt;const UInt_t*&gt;(dataEnd);</span>
<span class="lineNum">     745 </span><span class="lineCov">         50 :                         if (*padWord != fgkPaddingWord)</span>
<span class="lineNum">     746 </span>            :                         {
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :                                 fHandler.OnError(EventHandler::kBadPaddingWord, padWord);</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :                                 fHadError = true;</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :                                 if (fExitOnError)</span>
<span class="lineNum">     750 </span>            :                                 {
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :                                         fHandler.OnEndOfDSP(dspHeader, dataStart);</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :                                         return false;</span>
<span class="lineNum">     753 </span>            :                                 }
<span class="lineNum">     754 </span>            :                         }
<span class="lineNum">     755 </span><span class="lineCov">         50 :                 }</span>
<span class="lineNum">     756 </span>            :                 
<span class="lineNum">     757 </span><span class="lineCov">        736 :                 if (not DecodeDSPData(dataStart, dataEnd))</span>
<span class="lineNum">     758 </span>            :                 {
<span class="lineNum">     759 </span>            :                         // At this point we had a problem decoding the DSP structure's
<span class="lineNum">     760 </span>            :                         // data, thus we should stop further decoding if so requested by
<span class="lineNum">     761 </span>            :                         // the user. Note the fHadError flag is already marked inside
<span class="lineNum">     762 </span>            :                         // DecodeDSPData.
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :                         if (fExitOnError)</span>
<span class="lineNum">     764 </span>            :                         {
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :                                 fHandler.OnEndOfDSP(dspHeader, dataStart);</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :                                 return false;</span>
<span class="lineNum">     767 </span>            :                         }
<span class="lineNum">     768 </span>            :                 }
<span class="lineNum">     769 </span><span class="lineCov">        736 :                 fHandler.OnEndOfDSP(dspHeader, dataStart);</span>
<span class="lineNum">     770 </span><span class="lineCov">       1472 :         }</span>
<span class="lineNum">     771 </span>            :         
<span class="lineNum">     772 </span><span class="lineCov">        160 :         return true;</span>
<span class="lineNum">     773 </span><span class="lineCov">        160 : }</span>
<span class="lineNum">     774 </span>            : 
<a name="775"><span class="lineNum">     775 </span>            : </a>
<span class="lineNum">     776 </span>            : template &lt;class EventHandler&gt;
<span class="lineNum">     777 </span>            : bool AliMUONTrackerDDLDecoder&lt;EventHandler&gt;::DecodeDSPData(
<span class="lineNum">     778 </span>            :                 const UChar_t* start, const UChar_t* end
<span class="lineNum">     779 </span>            :         )
<span class="lineNum">     780 </span>            : {
<span class="lineNum">     781 </span>            :         /// This method decodes a DSP structure's data payload. It finds all the
<span class="lineNum">     782 </span>            :         /// bus patches found inside and for each it calls the OnNewBusPatch method
<span class="lineNum">     783 </span>            :         /// for the event handler to signal the start of each new bus patch.
<span class="lineNum">     784 </span>            :         /// \param start  This is the pointer to the start of the DSP structure's data.
<span class="lineNum">     785 </span>            :         /// \param end  This is the pointer to the first byte just past the
<span class="lineNum">     786 </span>            :         ///             end of the DSP structure.
<span class="lineNum">     787 </span>            :         /// \return If the DSP structure's data was decoded without errors
<span class="lineNum">     788 </span>            :         ///      or we could recover from the errors, then true is returned.
<span class="lineNum">     789 </span>            :         ///      False is returned otherwise.
<span class="lineNum">     790 </span>            :         
<span class="lineNum">     791 </span><span class="lineCov">       1472 :         const UChar_t* current = start;</span>
<span class="lineNum">     792 </span>            :         
<span class="lineNum">     793 </span>            :         UInt_t busPatchCount = 0; // Indicates the number of bus patches decoded.
<span class="lineNum">     794 </span><span class="lineCov">       5024 :         while (current &lt; end)</span>
<span class="lineNum">     795 </span>            :         {
<span class="lineNum">     796 </span>            :                 // Mark the start of the bus patch structure.
<span class="lineNum">     797 </span>            :                 const UChar_t* busPatchStart = current;
<span class="lineNum">     798 </span>            :                 
<span class="lineNum">     799 </span>            :                 // Get the bus patch header, move the current pointer just past
<span class="lineNum">     800 </span>            :                 // the end of the header and check that we have not overflowed
<span class="lineNum">     801 </span>            :                 // the buffer.
<span class="lineNum">     802 </span>            :                 const AliMUONBusPatchHeaderStruct* busPatchHeader
<span class="lineNum">     803 </span><span class="lineCov">       3552 :                         = reinterpret_cast&lt;const AliMUONBusPatchHeaderStruct*&gt;(busPatchStart);</span>
<span class="lineNum">     804 </span><span class="lineCov">       3552 :                 current += sizeof(AliMUONBusPatchHeaderStruct);</span>
<span class="lineNum">     805 </span><span class="lineCov">       7104 :                 if (current &gt; end or current &lt; start)</span>
<span class="lineNum">     806 </span>            :                 {
<span class="lineNum">     807 </span>            :                         // If we overflowed the pointer and already had an error then
<span class="lineNum">     808 </span>            :                         // we are clearly lost so just stop decoding before we segfault.
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :                         if (current &lt; start and fHadError) return false;</span>
<span class="lineNum">     810 </span>            :                         
<span class="lineNum">     811 </span>            :                         // So we only got part of a bus patch header at the very
<span class="lineNum">     812 </span>            :                         // end of the DSP structure buffer. Nothing to do but
<span class="lineNum">     813 </span>            :                         // report the error and exit. Set fHadError in case of
<span class="lineNum">     814 </span>            :                         // further decoding.
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :                         fHandler.OnError(EventHandler::kNoBusPatchHeader, busPatchHeader);</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :                         fHadError = true;</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :                         return false;</span>
<span class="lineNum">     818 </span>            :                 }
<span class="lineNum">     819 </span>            :                 
<span class="lineNum">     820 </span>            :                 // The header fits the buffer so we can mark the data start and
<span class="lineNum">     821 </span>            :                 // read from the header to find the end of data and bus patch
<span class="lineNum">     822 </span>            :                 // structure pointers.
<span class="lineNum">     823 </span>            :                 const UChar_t* dataStart = current;
<span class="lineNum">     824 </span><span class="lineCov">       3552 :                 current += busPatchHeader-&gt;fLength * sizeof(UInt_t);</span>
<span class="lineNum">     825 </span><span class="lineCov">       3552 :                 const UChar_t* dataEnd = current;</span>
<span class="lineNum">     826 </span><span class="lineCov">       7104 :                 const UChar_t* busPatchEnd = busPatchStart</span>
<span class="lineNum">     827 </span><span class="lineCov">       3552 :                         + busPatchHeader-&gt;fTotalLength * sizeof(UInt_t);</span>
<span class="lineNum">     828 </span>            :                 
<span class="lineNum">     829 </span>            :                 // Now we need to check for the following things:
<span class="lineNum">     830 </span>            :                 // 1) Is the end of bus patch structure or end of data pointer
<span class="lineNum">     831 </span>            :                 //    outside the buffer boundaries.
<span class="lineNum">     832 </span>            :                 // 2) Are the values for these pointers the same.
<span class="lineNum">     833 </span>            :                 // 3) Is the expected data key in the header present.
<span class="lineNum">     834 </span>            :                 // If any of the above fail then we know there is a problem with
<span class="lineNum">     835 </span>            :                 // the bus patch header. It must be corrupted somehow.
<span class="lineNum">     836 </span><span class="lineCov">       7104 :                 if (busPatchHeader-&gt;fDataKey != fgkBusPatchDataKey</span>
<span class="lineNum">     837 </span><span class="lineCov">      10656 :                     or dataEnd &gt; end or dataEnd &lt; start</span>
<span class="lineNum">     838 </span><span class="lineCov">      10656 :                     or busPatchEnd &gt; end or busPatchEnd &lt; start</span>
<span class="lineNum">     839 </span><span class="lineCov">       7104 :                     or dataEnd != busPatchEnd)</span>
<span class="lineNum">     840 </span>            :                 {
<span class="lineNum">     841 </span>            :                         // So let us see what exactly is wrong and report this.
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :                         if (busPatchHeader-&gt;fDataKey != fgkBusPatchDataKey)</span>
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :                                 fHandler.OnError(EventHandler::kBadBusPatchKey, &amp;busPatchHeader-&gt;fDataKey);</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :                         if (busPatchEnd &gt; end or busPatchEnd &lt; start)</span>
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :                                 fHandler.OnError(EventHandler::kBadBusPatchLength, &amp;busPatchHeader-&gt;fLength);</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :                         if (dataEnd &gt; end or dataEnd &lt; start)</span>
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :                                 fHandler.OnError(EventHandler::kBadBusPatchTotalLength, &amp;busPatchHeader-&gt;fTotalLength);</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :                         if (dataEnd != busPatchEnd)</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :                                 fHandler.OnError(EventHandler::kBusPatchLengthMismatch, busPatchHeader);</span>
<span class="lineNum">     850 </span>            :                         
<span class="lineNum">     851 </span>            :                         // Indicate we had and error and stop the decoding if so
<span class="lineNum">     852 </span>            :                         // requested by the user.
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :                         fHadError = true;</span>
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :                         if (fExitOnError) return false;</span>
<span class="lineNum">     855 </span>            :                         
<span class="lineNum">     856 </span>            :                         // Try to recover from the corrupt header.
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :                         RecoverResult result = TryRecoverStruct(</span>
<span class="lineNum">     858 </span>            :                                         fgkBusPatchDataKey, sizeof(AliMUONBusPatchHeaderStruct),
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :                                         busPatchHeader-&gt;fTotalLength, busPatchHeader-&gt;fLength,</span>
<span class="lineNum">     860 </span>            :                                         busPatchStart, end, dataEnd, busPatchEnd, current
<span class="lineNum">     861 </span>            :                                 );
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :                         if (result == kContinueToNextStruct)</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :                                 continue; // Try the next bus patch at 'current'.</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :                         if (result == kRecoverFailed) return false;</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">     866 </span>            :                 
<span class="lineNum">     867 </span>            :                 // At this point we certainly have a valid bus patch header, so
<span class="lineNum">     868 </span>            :                 // we need to check if we have more bus patches than we expected.
<span class="lineNum">     869 </span>            :                 // If not then we can indicate we have another bus patch and
<span class="lineNum">     870 </span>            :                 // decode its data.
<span class="lineNum">     871 </span><span class="lineCov">       7104 :                 if (++busPatchCount &gt; fMaxBusPatches)</span>
<span class="lineNum">     872 </span>            :                 {
<span class="lineNum">     873 </span><span class="lineCov">       3552 :                         fHandler.OnError(EventHandler::kTooManyBusPatches, current);</span>
<span class="lineNum">     874 </span>            :                         
<span class="lineNum">     875 </span>            :                         // In this case we stop further decoding of the DSP
<span class="lineNum">     876 </span>            :                         // structure's data because clearly something is seriously
<span class="lineNum">     877 </span>            :                         // wrong if we are getting more bus patches than expected.
<span class="lineNum">     878 </span>            :                         // Indicate that we had an error so the Decode() method
<span class="lineNum">     879 </span>            :                         // returns false.
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :                         fHadError = true;</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :                         return false;</span>
<span class="lineNum">     882 </span>            :                 }
<span class="lineNum">     883 </span>            :                 
<span class="lineNum">     884 </span><span class="lineCov">       3552 :                 fHandler.OnNewBusPatch(busPatchHeader, dataStart);</span>
<span class="lineNum">     885 </span><span class="lineCov">       3552 :                 if (not DecodeBusPatchData(dataStart, dataEnd))</span>
<span class="lineNum">     886 </span>            :                 {
<span class="lineNum">     887 </span>            :                         // At this point we had a problem decoding the bus patch data,
<span class="lineNum">     888 </span>            :                         // thus we should stop further decoding if so requested by the
<span class="lineNum">     889 </span>            :                         // user. Note the fHadError flag is already marked inside
<span class="lineNum">     890 </span>            :                         // DecodeBusPatchData.
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :                         if (fExitOnError)</span>
<span class="lineNum">     892 </span>            :                         {
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :                                 fHandler.OnEndOfBusPatch(busPatchHeader, dataStart);</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :                                 return false;</span>
<span class="lineNum">     895 </span>            :                         }
<span class="lineNum">     896 </span>            :                 }
<span class="lineNum">     897 </span><span class="lineCov">       3552 :                 fHandler.OnEndOfBusPatch(busPatchHeader, dataStart);</span>
<span class="lineNum">     898 </span><span class="lineCov">       7104 :         }</span>
<span class="lineNum">     899 </span>            :         
<span class="lineNum">     900 </span><span class="lineCov">        736 :         return true;</span>
<span class="lineNum">     901 </span><span class="lineCov">        736 : }</span>
<span class="lineNum">     902 </span>            : 
<a name="903"><span class="lineNum">     903 </span>            : </a>
<span class="lineNum">     904 </span>            : template &lt;class EventHandler&gt;
<span class="lineNum">     905 </span>            : bool AliMUONTrackerDDLDecoder&lt;EventHandler&gt;::DecodeBusPatchData(
<span class="lineNum">     906 </span>            :                 const UChar_t* start, const UChar_t* end
<span class="lineNum">     907 </span>            :         )
<span class="lineNum">     908 </span>            : {
<span class="lineNum">     909 </span>            :         /// This method decodes a single bus patch's data payload.
<span class="lineNum">     910 </span>            :         /// It will check the parity of the raw data words and send them
<span class="lineNum">     911 </span>            :         /// to the event handler instance with calls to OnData.
<span class="lineNum">     912 </span>            :         /// \param start  This is the pointer to the start of the bus patch
<span class="lineNum">     913 </span>            :         ///               structure's data.
<span class="lineNum">     914 </span>            :         /// \param end  This is the pointer to the first byte just past the
<span class="lineNum">     915 </span>            :         ///             end of the bus patch structure.
<span class="lineNum">     916 </span>            :         /// \return If the bus patch's data was decoded without errors
<span class="lineNum">     917 </span>            :         ///      or we could recover from the errors, then true is returned.
<span class="lineNum">     918 </span>            :         ///      False is returned otherwise.
<span class="lineNum">     919 </span>            : 
<span class="lineNum">     920 </span>            :         // Assert that 'end' is always larger than start by n*sizeof(UInt_t)
<span class="lineNum">     921 </span>            :         // where n is a positive integer. This should be the case because we
<span class="lineNum">     922 </span>            :         // always add multiples of sizeof(UInt_t) to the 'current' pointer in
<span class="lineNum">     923 </span>            :         // all the DecodeXYZ methods.
<span class="lineNum">     924 </span><span class="lineCov">       7104 :         assert( UInt_t(end - start) % 4 == 0 );</span>
<span class="lineNum">     925 </span>            :         
<span class="lineNum">     926 </span>            :         // Now step through all the data words and issue OnData events.
<span class="lineNum">     927 </span>            :         // We also need to check parity and signal OnError if it is not valid
<span class="lineNum">     928 </span>            :         // for any of the data words.
<span class="lineNum">     929 </span><span class="lineCov">       3552 :         const UInt_t* data = reinterpret_cast&lt;const UInt_t*&gt;(start);</span>
<span class="lineNum">     930 </span><span class="lineCov">       3552 :         const UInt_t* dataEnd = reinterpret_cast&lt;const UInt_t*&gt;(end);</span>
<span class="lineNum">     931 </span><span class="lineCov">       8520 :         for (; data &lt; dataEnd; data++)</span>
<span class="lineNum">     932 </span>            :         {
<span class="lineNum">     933 </span><span class="lineCov">       1416 :                 if (ParityIsOk(*data))</span>
<span class="lineNum">     934 </span>            :                 {
<span class="lineNum">     935 </span><span class="lineCov">       1416 :                         fHandler.OnData(*data, false);</span>
<span class="lineNum">     936 </span><span class="lineCov">        708 :                 }</span>
<span class="lineNum">     937 </span>            :                 else
<span class="lineNum">     938 </span>            :                 {
<span class="lineNum">     939 </span>            :                         // Indicate we had a parity error and exit immediately
<span class="lineNum">     940 </span>            :                         // if the user so requested.
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :                         fHandler.OnError(EventHandler::kParityError, data);</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :                         fHadError = true;</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :                         if (fExitOnError) return false;</span>
<span class="lineNum">     944 </span>            :                         
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :                         if (fSendDataOnParityError)</span>
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :                                 fHandler.OnData(*data, true);</span>
<span class="lineNum">     947 </span>            :                 }
<span class="lineNum">     948 </span>            :         }
<span class="lineNum">     949 </span>            :         
<span class="lineNum">     950 </span><span class="lineCov">       3552 :         return true;</span>
<span class="lineNum">     951 </span><span class="lineCov">       3552 : }</span>
<span class="lineNum">     952 </span>            : 
<span class="lineNum">     953 </span>            : 
<a name="954"><span class="lineNum">     954 </span>            : template &lt;class EventHandler&gt;</a>
<span class="lineNum">     955 </span>            : typename AliMUONTrackerDDLDecoder&lt;EventHandler&gt;::RecoverResult
<span class="lineNum">     956 </span>            : AliMUONTrackerDDLDecoder&lt;EventHandler&gt;::TryRecoverStruct(
<span class="lineNum">     957 </span>            :                 UInt_t expectedKey,
<span class="lineNum">     958 </span>            :                 UInt_t headerSize,
<span class="lineNum">     959 </span>            :                 UInt_t totalLength,
<span class="lineNum">     960 </span>            :                 UInt_t length,
<span class="lineNum">     961 </span>            :                 const UChar_t* structStart,
<span class="lineNum">     962 </span>            :                 const UChar_t* bufferEnd,
<span class="lineNum">     963 </span>            :                 const UChar_t*&amp; dataEnd,
<span class="lineNum">     964 </span>            :                 const UChar_t*&amp; structEnd,
<span class="lineNum">     965 </span>            :                 const UChar_t*&amp; current
<span class="lineNum">     966 </span>            :         )
<span class="lineNum">     967 </span>            : {
<span class="lineNum">     968 </span>            :         /// This method attempts to recover from a corrupt structure header by
<span class="lineNum">     969 </span>            :         /// figuring out which of the structure size indicators is correct.
<span class="lineNum">     970 </span>            :         /// This is possible because each header has some redundant information.
<span class="lineNum">     971 </span>            :         /// The recovery procedure is only attempted if fTryRecover was set to
<span class="lineNum">     972 </span>            :         /// true. If the recovery procedure is successful then this method will
<span class="lineNum">     973 </span>            :         /// also update the pointers indicating the start of data, end of structure
<span class="lineNum">     974 </span>            :         /// and current parsing position with the correct values.
<span class="lineNum">     975 </span>            :         ///
<span class="lineNum">     976 </span>            :         /// [in]  \param expectedKey This is the expected block key for the header
<span class="lineNum">     977 </span>            :         ///           currently being processed.
<span class="lineNum">     978 </span>            :         /// [in]  \param headerSize  The expected header size as given by the sizeof
<span class="lineNum">     979 </span>            :         ///           operator for example.
<span class="lineNum">     980 </span>            :         /// [in]  \param totalLength The total length as given by the fTotalLength
<span class="lineNum">     981 </span>            :         ///           field in the current header being handled.
<span class="lineNum">     982 </span>            :         /// [in]  \param length  The data length as given by the fLength field
<span class="lineNum">     983 </span>            :         ///           in the current header being handled.
<span class="lineNum">     984 </span>            :         /// [in]  \param structStart A pointer to the start of the structure header.
<span class="lineNum">     985 </span>            :         /// [in]  \param bufferEnd A pointer to the first byte just past the end
<span class="lineNum">     986 </span>            :         ///           of the buffer. This could be the pointer to the first byte
<span class="lineNum">     987 </span>            :         ///           just past the end of the parent structure if we are dealing
<span class="lineNum">     988 </span>            :         ///           with a DSP structure or bus patch. The parent structure for
<span class="lineNum">     989 </span>            :         ///           the DSP is a block structure and for a bus patch it is a DSP.
<span class="lineNum">     990 </span>            :         /// [out] \param dataEnd This is the pointer to the first byte just past
<span class="lineNum">     991 </span>            :         ///           the end of the structure being processed. It should be equal to
<span class="lineNum">     992 </span>            :         ///           structStart + sizeof(structure header) + fLength, where fLength
<span class="lineNum">     993 </span>            :         ///           is the field found in the structure's header itself. This value
<span class="lineNum">     994 </span>            :         ///           will be corrected and updated if we could recover from the
<span class="lineNum">     995 </span>            :         ///           corruption in the header.
<span class="lineNum">     996 </span>            :         /// [out] \param structEnd A pointer to the first byte just past the end of
<span class="lineNum">     997 </span>            :         ///           the structure. This value should be set equal to
<span class="lineNum">     998 </span>            :         ///           structStart + fTotalLength * sizeof(UInt_t), where fTotalLength
<span class="lineNum">     999 </span>            :         ///           is the field found in the structure's header itself. This value
<span class="lineNum">    1000 </span>            :         ///           will be corrected and updated if we could recover from the
<span class="lineNum">    1001 </span>            :         ///           corruption in the header.
<span class="lineNum">    1002 </span>            :         /// [out] \param current This is the pointer to the current location in
<span class="lineNum">    1003 </span>            :         ///           the DDL payload being parsed. It should in principle point
<span class="lineNum">    1004 </span>            :         ///           to the start of the structures data. This value will be
<span class="lineNum">    1005 </span>            :         ///           corrected and updated if we could recover from the corruption
<span class="lineNum">    1006 </span>            :         ///           in the header.
<span class="lineNum">    1007 </span>            :         ///
<span class="lineNum">    1008 </span>            :         /// \return Returns the result of the recovery attempt, which can be one
<span class="lineNum">    1009 </span>            :         ///    of the following:
<span class="lineNum">    1010 </span>            :         ///      kRecoverFailed - The recovery failed completely so the caller
<span class="lineNum">    1011 </span>            :         ///           cannot continue parsing any more structures. If the failure
<span class="lineNum">    1012 </span>            :         ///           is within a DSP then one could still continue parsing
<span class="lineNum">    1013 </span>            :         ///           from the next block. Similarly for bus patches, parsing could
<span class="lineNum">    1014 </span>            :         ///           continue from the next DSP structure.
<span class="lineNum">    1015 </span>            :         ///      kStructRecovered - Indicates that we recovered from a corrupt
<span class="lineNum">    1016 </span>            :         ///           structure header and can continue processing the data of the
<span class="lineNum">    1017 </span>            :         ///           structure in question.
<span class="lineNum">    1018 </span>            :         ///      kContinueToNextStruct - Either fTryRecover was set to false or we
<span class="lineNum">    1019 </span>            :         ///           could not recover from the corrupt header but we did find the
<span class="lineNum">    1020 </span>            :         ///           start of another header matching the expected key so parsing
<span class="lineNum">    1021 </span>            :         ///           can continue from the updated current position.
<span class="lineNum">    1022 </span>            : 
<span class="lineNum">    1023 </span>            :         // Check if the user wants us to try and recover from a corrupt header.
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :         if (not fTryRecover) return kContinueToNextStruct;</span>
<span class="lineNum">    1025 </span>            :         
<span class="lineNum">    1026 </span>            :         // If the user wants us to try recover, then try to recover what the
<span class="lineNum">    1027 </span>            :         // correct values for dataEnd, structEnd and current were supposed to be.
<span class="lineNum">    1028 </span>            :         // The recovery procedure is as follows: We have 4 conditions for a correct
<span class="lineNum">    1029 </span>            :         // header:
<span class="lineNum">    1030 </span>            :         //   1) The header key is what we expect.
<span class="lineNum">    1031 </span>            :         //   2) The totalLength equals length + headerSize.
<span class="lineNum">    1032 </span>            :         //   3) The word at dataEnd contains a valid key. (implies length is
<span class="lineNum">    1033 </span>            :         //      correct.)
<span class="lineNum">    1034 </span>            :         //   4) The word at structEnd contains a valid key. (implies totalLength
<span class="lineNum">    1035 </span>            :         //      is correct.)
<span class="lineNum">    1036 </span>            :         // If any 2 of these conditions hold then we know that only one of the
<span class="lineNum">    1037 </span>            :         // header fields is corrupt and we have enough information to reconstruct
<span class="lineNum">    1038 </span>            :         // the third field. Note that if conditions 3 and 4 are true then this
<span class="lineNum">    1039 </span>            :         // implies 2 is also true. (not necessarily the other way around though.)
<span class="lineNum">    1040 </span>            :         // The valid key mentioned above at dataEnd and structEnd should be:
<span class="lineNum">    1041 </span>            :         //   a) A bus patch key, DSP key or end of buffer if expectedKey indicates
<span class="lineNum">    1042 </span>            :         //      a buspatch.
<span class="lineNum">    1043 </span>            :         //   b) A DSP key, block structure key or end of buffer if expectedKey
<span class="lineNum">    1044 </span>            :         //      indicates a DSP.
<span class="lineNum">    1045 </span>            :         //   c) A block structure key or end of buffer if expectedKey indicates
<span class="lineNum">    1046 </span>            :         //      a DSP.
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :         const UInt_t* headerKey = reinterpret_cast&lt;const UInt_t*&gt;(structStart);</span>
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :         bool headerKeyOk = (expectedKey == *headerKey);</span>
<span class="lineNum">    1049 </span>            :         
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :         bool lengthsMatch = (totalLength*4 == length*4 + headerSize);</span>
<span class="lineNum">    1051 </span>            :         
<span class="lineNum">    1052 </span>            :         bool lengthIsCorrect = false;
<span class="lineNum">    1053 </span>            :         bool totalLengthIsCorrect = false;
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :         const UInt_t* keyAtDataEnd = reinterpret_cast&lt;const UInt_t*&gt;(dataEnd);</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :         const UInt_t* keyAtStructEnd = reinterpret_cast&lt;const UInt_t*&gt;(structEnd);</span>
<span class="lineNum">    1056 </span>            :         
<span class="lineNum">    1057 </span>            : 
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :         if ( expectedKey == fgkBlockDataKey )</span>
<span class="lineNum">    1059 </span>            :         {
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :                 if (dataEnd == bufferEnd)</span>
<span class="lineNum">    1061 </span>            :                 {
<span class="lineNum">    1062 </span>            :                         // Are we at the end of the buffer?
<span class="lineNum">    1063 </span>            :                         lengthIsCorrect = true;
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">    1065 </span>            :                 else
<span class="lineNum">    1066 </span>            :                 {
<span class="lineNum">    1067 </span>            :                         // Must check that we can read another 4 bytes before
<span class="lineNum">    1068 </span>            :                         // checking the key at dataEnd.
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :                         if (dataEnd + sizeof(UInt_t) &lt;= bufferEnd and dataEnd + sizeof(UInt_t) &gt; structStart)</span>
<span class="lineNum">    1070 </span>            :                         {
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :                                 if (*keyAtDataEnd == fgkBlockDataKey)</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :                                         lengthIsCorrect = true;</span>
<span class="lineNum">    1073 </span>            :                         }
<span class="lineNum">    1074 </span>            :                 }
<span class="lineNum">    1075 </span>            :                 
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :                 if (structEnd == bufferEnd)</span>
<span class="lineNum">    1077 </span>            :                 {
<span class="lineNum">    1078 </span>            :                         // Are we at the end of the buffer?
<span class="lineNum">    1079 </span>            :                         totalLengthIsCorrect = true;
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">    1081 </span>            :                 else
<span class="lineNum">    1082 </span>            :                 {
<span class="lineNum">    1083 </span>            :                         // Must check that we can read another 4 bytes before
<span class="lineNum">    1084 </span>            :                         // checking the key at structEnd.
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :                         if (structEnd + sizeof(UInt_t) &lt;= bufferEnd and structEnd + sizeof(UInt_t) &gt; structStart)</span>
<span class="lineNum">    1086 </span>            :                         {
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :                                 if (*keyAtStructEnd == fgkBlockDataKey)</span>
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :                                         totalLengthIsCorrect = true;</span>
<span class="lineNum">    1089 </span>            :                         }
<span class="lineNum">    1090 </span>            :                 }
<span class="lineNum">    1091 </span>            :         }        
<span class="lineNum">    1092 </span>            :                         
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :         else if ( expectedKey == fgkDSPDataKey )</span>
<span class="lineNum">    1094 </span>            :         {
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :                 if (dataEnd == bufferEnd)</span>
<span class="lineNum">    1096 </span>            :                 {
<span class="lineNum">    1097 </span>            :                         // Are we at the end of the buffer?
<span class="lineNum">    1098 </span>            :                         lengthIsCorrect = true;
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">    1100 </span>            :                 else
<span class="lineNum">    1101 </span>            :                 {
<span class="lineNum">    1102 </span>            :                         // Must check that we can read another 4 bytes before
<span class="lineNum">    1103 </span>            :                         // checking the key at dataEnd.
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :                         if (dataEnd + sizeof(UInt_t) &lt;= bufferEnd and dataEnd + sizeof(UInt_t) &gt; structStart)</span>
<span class="lineNum">    1105 </span>            :                         {
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :                                 if (*keyAtDataEnd == fgkBlockDataKey</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :                                     or *keyAtDataEnd == fgkDSPDataKey)</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :                                         lengthIsCorrect = true;</span>
<span class="lineNum">    1109 </span>            :                         }
<span class="lineNum">    1110 </span>            :                 }
<span class="lineNum">    1111 </span>            :                 
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :                 if (structEnd == bufferEnd)</span>
<span class="lineNum">    1113 </span>            :                 {
<span class="lineNum">    1114 </span>            :                         // Are we at the end of the buffer?
<span class="lineNum">    1115 </span>            :                         totalLengthIsCorrect = true;
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">    1117 </span>            :                 else
<span class="lineNum">    1118 </span>            :                 {
<span class="lineNum">    1119 </span>            :                         // Must check that we can read another 4 bytes before
<span class="lineNum">    1120 </span>            :                         // checking the key at structEnd.
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :                         if (structEnd + sizeof(UInt_t) &lt;= bufferEnd and structEnd + sizeof(UInt_t) &gt; structStart)</span>
<span class="lineNum">    1122 </span>            :                         {
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :                                 if (*keyAtStructEnd == fgkBlockDataKey</span>
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :                                     or *keyAtStructEnd == fgkDSPDataKey)</span>
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :                                         totalLengthIsCorrect = true;</span>
<span class="lineNum">    1126 </span>            :                         }
<span class="lineNum">    1127 </span>            :                 }
<span class="lineNum">    1128 </span>            :         }        
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :         else if ( expectedKey == fgkBusPatchDataKey )</span>
<span class="lineNum">    1130 </span>            :         {
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :                 if (dataEnd == bufferEnd)</span>
<span class="lineNum">    1132 </span>            :                 {
<span class="lineNum">    1133 </span>            :                         // Are we at the end of the buffer?
<span class="lineNum">    1134 </span>            :                         lengthIsCorrect = true;
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">    1136 </span>            :                 else
<span class="lineNum">    1137 </span>            :                 {
<span class="lineNum">    1138 </span>            :                         // Must check that we can read another 4 bytes before
<span class="lineNum">    1139 </span>            :                         // checking the key at dataEnd.
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :                         if (dataEnd + sizeof(UInt_t) &lt;= bufferEnd and dataEnd + sizeof(UInt_t) &gt; structStart)</span>
<span class="lineNum">    1141 </span>            :                         {
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :                                 if (*keyAtDataEnd == fgkDSPDataKey</span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :                                     or *keyAtDataEnd == fgkBusPatchDataKey)</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :                                         lengthIsCorrect = true;</span>
<span class="lineNum">    1145 </span>            :                         }
<span class="lineNum">    1146 </span>            :                 }
<span class="lineNum">    1147 </span>            :                 
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :                 if (structEnd == bufferEnd)</span>
<span class="lineNum">    1149 </span>            :                 {
<span class="lineNum">    1150 </span>            :                         // Are we at the end of the buffer?
<span class="lineNum">    1151 </span>            :                         totalLengthIsCorrect = true;
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">    1153 </span>            :                 else
<span class="lineNum">    1154 </span>            :                 {
<span class="lineNum">    1155 </span>            :                         // Must check that we can read another 4 bytes before
<span class="lineNum">    1156 </span>            :                         // checking the key at structEnd.
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :                         if (structEnd + sizeof(UInt_t) &lt;= bufferEnd and structEnd + sizeof(UInt_t) &gt; structStart)</span>
<span class="lineNum">    1158 </span>            :                         {
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :                                 if (*keyAtStructEnd == fgkDSPDataKey</span>
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :                                     or *keyAtStructEnd == fgkBusPatchDataKey)</span>
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :                                         totalLengthIsCorrect = true;</span>
<span class="lineNum">    1162 </span>            :                         }
<span class="lineNum">    1163 </span>            :                 }
<span class="lineNum">    1164 </span>            :         }
<span class="lineNum">    1165 </span>            :         
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :         if (headerKeyOk and lengthIsCorrect)</span>
<span class="lineNum">    1167 </span>            :         {
<span class="lineNum">    1168 </span>            :                 // totalLength was wrong, dataEnd is correct.
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :                 structEnd = dataEnd;</span>
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :                 current = dataEnd;</span>
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :                 return kStructRecovered;</span>
<span class="lineNum">    1172 </span>            :         }
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :         if (headerKeyOk and totalLengthIsCorrect)</span>
<span class="lineNum">    1174 </span>            :         {
<span class="lineNum">    1175 </span>            :                 // Length was wrong, structEnd is correct.
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 :                 dataEnd = structEnd;</span>
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :                 current = structEnd;</span>
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :                 return kStructRecovered;</span>
<span class="lineNum">    1179 </span>            :         }
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :         if (lengthsMatch and lengthIsCorrect and totalLengthIsCorrect)</span>
<span class="lineNum">    1181 </span>            :         {
<span class="lineNum">    1182 </span>            :                 // The header's key was wrong but the lengths and pointers are OK.
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :                 return kStructRecovered;</span>
<span class="lineNum">    1184 </span>            :         }
<span class="lineNum">    1185 </span>            :         
<span class="lineNum">    1186 </span>            :         // Could not recover the header from the available information, so find
<span class="lineNum">    1187 </span>            :         // the next key in the stream that is the same as the currently expected
<span class="lineNum">    1188 </span>            :         // one and continue decoding from there.
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :         const UChar_t* location = FindKey(</span>
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :                         expectedKey, structStart + sizeof(UInt_t), bufferEnd</span>
<span class="lineNum">    1191 </span>            :                 );
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :         if (location != NULL)</span>
<span class="lineNum">    1193 </span>            :         {
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :                 current = location;</span>
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :                 return kContinueToNextStruct;</span>
<span class="lineNum">    1196 </span>            :         }
<span class="lineNum">    1197 </span>            : 
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :         return kRecoverFailed;</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1200 </span>            : 
<a name="1201"><span class="lineNum">    1201 </span>            : </a>
<span class="lineNum">    1202 </span>            : template &lt;class EventHandler&gt;
<span class="lineNum">    1203 </span>            : const UChar_t* AliMUONTrackerDDLDecoder&lt;EventHandler&gt;::FindKey(
<span class="lineNum">    1204 </span>            :                 UInt_t key, const UChar_t* start, const UChar_t* end
<span class="lineNum">    1205 </span>            :         )
<span class="lineNum">    1206 </span>            : {
<span class="lineNum">    1207 </span>            :         /// Searches for the first occurrence of the key value in the buffer marked by
<span class="lineNum">    1208 </span>            :         /// 'start' and 'end'. 'start' should point to the start of the buffer and 'end'
<span class="lineNum">    1209 </span>            :         /// should point to 'start + bufferSize', i.e. just past the last byte of the
<span class="lineNum">    1210 </span>            :         /// buffer. If the key was found then the pointer to that location is returned
<span class="lineNum">    1211 </span>            :         /// otherwise NULL is returned.
<span class="lineNum">    1212 </span>            :         
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :         if (end + sizeof(UInt_t) &lt; start) return NULL;  // check for pointer overflow.</span>
<span class="lineNum">    1214 </span>            :         const UChar_t* current = start;
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :         while (current + sizeof(UInt_t) &lt;= end)</span>
<span class="lineNum">    1216 </span>            :         {
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :                 UInt_t data = * reinterpret_cast&lt;const UInt_t*&gt;(current);</span>
<span class="lineNum">    1218 </span><span class="lineNoCov">          0 :                 if (data == key) return current;</span>
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :                 current++;</span>
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1223 </span>            : 
<a name="1224"><span class="lineNum">    1224 </span>            : </a>
<span class="lineNum">    1225 </span>            : template &lt;class EventHandler&gt;
<span class="lineNum">    1226 </span>            : bool AliMUONTrackerDDLDecoder&lt;EventHandler&gt;::ParityIsOk(UInt_t data)
<span class="lineNum">    1227 </span>            : {
<span class="lineNum">    1228 </span>            :         /// Optimised parity check addapted from:
<span class="lineNum">    1229 </span>            :         /// http://graphics.stanford.edu/~seander/bithacks.html#ParityParallel
<span class="lineNum">    1230 </span>            :         
<span class="lineNum">    1231 </span>            :         // parity of the 32 bits must be zero if the last bit is equal
<span class="lineNum">    1232 </span>            :         // to the parity of the first 31 bits.
<span class="lineNum">    1233 </span>            :         // Reason: the parity bit xor the parity of the first 31 bits must give
<span class="lineNum">    1234 </span>            :         // zero, unless there was a bit error.
<span class="lineNum">    1235 </span><span class="lineCov">       1416 :         data ^= data &gt;&gt; 16;</span>
<span class="lineNum">    1236 </span><span class="lineCov">        708 :         data ^= data &gt;&gt; 8;</span>
<span class="lineNum">    1237 </span><span class="lineCov">        708 :         data ^= data &gt;&gt; 4;</span>
<span class="lineNum">    1238 </span><span class="lineCov">        708 :         data &amp;= 0xf;</span>
<span class="lineNum">    1239 </span><span class="lineCov">        708 :         data = ((0x6996 &gt;&gt; data) &amp; 1);</span>
<span class="lineNum">    1240 </span><span class="lineCov">        708 :         return data == 0;</span>
<span class="lineNum">    1241 </span>            : }
<span class="lineNum">    1242 </span>            : 
<span class="lineNum">    1243 </span>            : #endif // ALIMUONTRACKERDDLDECODER_H
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
