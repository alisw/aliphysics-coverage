<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - MUON/MUONrec/AliMUONTrackExtrap.cxx</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">MUON/MUONrec</a> - AliMUONTrackExtrap.cxx<span style="font-size: 80%;"> (source / <a href="AliMUONTrackExtrap.cxx.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">460</td>
            <td class="headerCovTableEntry">706</td>
            <td class="headerCovTableEntryLo">65.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">26</td>
            <td class="headerCovTableEntry">33</td>
            <td class="headerCovTableEntryMed">78.8 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**************************************************************************</a>
<span class="lineNum">       2 </span>            :  * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
<span class="lineNum">       3 </span>            :  *                                                                        *
<span class="lineNum">       4 </span>            :  * Author: The ALICE Off-line Project.                                    *
<span class="lineNum">       5 </span>            :  * Contributors are mentioned in the code where appropriate.              *
<span class="lineNum">       6 </span>            :  *                                                                        *
<span class="lineNum">       7 </span>            :  * Permission to use, copy, modify and distribute this software and its   *
<span class="lineNum">       8 </span>            :  * documentation strictly for non-commercial purposes is hereby granted   *
<span class="lineNum">       9 </span>            :  * without fee, provided that the above copyright notice appears in all   *
<span class="lineNum">      10 </span>            :  * copies and that both the copyright notice and this permission notice   *
<span class="lineNum">      11 </span>            :  * appear in the supporting documentation. The authors make no claims     *
<span class="lineNum">      12 </span>            :  * about the suitability of this software for any purpose. It is          *
<span class="lineNum">      13 </span>            :  * provided &quot;as is&quot; without express or implied warranty.                  *
<span class="lineNum">      14 </span>            :  **************************************************************************/
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : /* $Id$ */
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : //-----------------------------------------------------------------------------
<span class="lineNum">      19 </span>            : // Class AliMUONTrackExtrap
<span class="lineNum">      20 </span>            : // ------------------------
<span class="lineNum">      21 </span>            : // Tools for track extrapolation in ALICE dimuon spectrometer
<span class="lineNum">      22 </span>            : // Author: Philippe Pillot
<span class="lineNum">      23 </span>            : //-----------------------------------------------------------------------------
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : #include &quot;AliMUONTrackExtrap.h&quot; 
<span class="lineNum">      26 </span>            : #include &quot;AliMUONTrackParam.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;AliMUONConstants.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;AliMUONReconstructor.h&quot;
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : #include &quot;AliMagF.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;AliExternalTrackParam.h&quot;
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : #include &lt;TGeoGlobalMagField.h&gt;
<span class="lineNum">      34 </span>            : #include &lt;TGeoManager.h&gt;
<span class="lineNum">      35 </span>            : #include &lt;TMath.h&gt;
<span class="lineNum">      36 </span>            : #include &lt;TDatabasePDG.h&gt;
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : #include &lt;Riostream.h&gt;
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : using std::endl;
<a name="41"><span class="lineNum">      41 </span>            : using std::cout;</a>
<span class="lineNum">      42 </span>            : /// \cond CLASSIMP
<span class="lineNum">      43 </span><span class="lineCov">         18 : ClassImp(AliMUONTrackExtrap) // Class implementation in ROOT context</span>
<a name="44"><span class="lineNum">      44 </span>            : /// \endcond</a>
<a name="45"><span class="lineNum">      45 </span>            : </a>
<span class="lineNum">      46 </span><span class="lineCov">         18 : const Double_t AliMUONTrackExtrap::fgkSimpleBPosition = 0.5 * (AliMUONConstants::CoilZ() + AliMUONConstants::YokeZ());</span>
<span class="lineNum">      47 </span><span class="lineCov">         18 : const Double_t AliMUONTrackExtrap::fgkSimpleBLength = 0.5 * (AliMUONConstants::CoilL() + AliMUONConstants::YokeL());</span>
<span class="lineNum">      48 </span>            :       Double_t AliMUONTrackExtrap::fgSimpleBValue = 0.;
<span class="lineNum">      49 </span>            :       Bool_t   AliMUONTrackExtrap::fgFieldON = kFALSE;
<span class="lineNum">      50 </span>            : const Bool_t   AliMUONTrackExtrap::fgkUseHelix = kFALSE;
<span class="lineNum">      51 </span>            : const Int_t    AliMUONTrackExtrap::fgkMaxStepNumber = 5000;
<span class="lineNum">      52 </span>            : const Double_t AliMUONTrackExtrap::fgkHelixStepLength = 6.;
<span class="lineNum">      53 </span>            : const Double_t AliMUONTrackExtrap::fgkRungeKuttaMaxResidue = 0.002;
<a name="54"><span class="lineNum">      54 </span>            : </a>
<span class="lineNum">      55 </span>            : //__________________________________________________________________________
<span class="lineNum">      56 </span>            : void AliMUONTrackExtrap::SetField()
<span class="lineNum">      57 </span>            : {
<span class="lineNum">      58 </span>            :   /// set field on/off flag;  
<span class="lineNum">      59 </span>            :   /// set field at the centre of the dipole
<span class="lineNum">      60 </span><span class="lineCov">          8 :   const Double_t x[3] = {50.,50.,fgkSimpleBPosition};</span>
<span class="lineNum">      61 </span><span class="lineCov">          4 :   Double_t b[3] = {0.,0.,0.};</span>
<span class="lineNum">      62 </span><span class="lineCov">          4 :   TGeoGlobalMagField::Instance()-&gt;Field(x,b);</span>
<span class="lineNum">      63 </span><span class="lineCov">          4 :   fgSimpleBValue = b[0];</span>
<span class="lineNum">      64 </span><span class="lineCov">          4 :   fgFieldON = (TMath::Abs(fgSimpleBValue) &gt; 1.e-10) ? kTRUE : kFALSE;</span>
<span class="lineNum">      65 </span>            :   
<span class="lineNum">      66 </span><span class="lineCov">          4 : }</span>
<a name="67"><span class="lineNum">      67 </span>            : </a>
<span class="lineNum">      68 </span>            : //__________________________________________________________________________
<span class="lineNum">      69 </span>            : Double_t AliMUONTrackExtrap::GetImpactParamFromBendingMomentum(Double_t bendingMomentum)
<span class="lineNum">      70 </span>            : {
<span class="lineNum">      71 </span>            :   /// Returns impact parameter at vertex in bending plane (cm),
<span class="lineNum">      72 </span>            :   /// from the signed bending momentum &quot;BendingMomentum&quot; in bending plane (GeV/c),
<span class="lineNum">      73 </span>            :   /// using simple values for dipole magnetic field.
<span class="lineNum">      74 </span>            :   /// The sign of &quot;BendingMomentum&quot; is the sign of the charge.
<span class="lineNum">      75 </span>            :   
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :   if (bendingMomentum == 0.) return 1.e10;</span>
<span class="lineNum">      77 </span>            :   
<span class="lineNum">      78 </span>            :   const Double_t kCorrectionFactor = 1.1; // impact parameter is 10% underestimated
<span class="lineNum">      79 </span>            :   
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :   return kCorrectionFactor * (-0.0003 * fgSimpleBValue * fgkSimpleBLength * fgkSimpleBPosition / bendingMomentum);</span>
<span class="lineNum">      81 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      82 </span>            : 
<a name="83"><span class="lineNum">      83 </span>            : //__________________________________________________________________________</a>
<span class="lineNum">      84 </span>            : Double_t 
<span class="lineNum">      85 </span>            : AliMUONTrackExtrap::GetBendingMomentumFromImpactParam(Double_t impactParam)
<span class="lineNum">      86 </span>            : {
<span class="lineNum">      87 </span>            :   /// Returns signed bending momentum in bending plane (GeV/c),
<span class="lineNum">      88 </span>            :   /// the sign being the sign of the charge for particles moving forward in Z,
<span class="lineNum">      89 </span>            :   /// from the impact parameter &quot;ImpactParam&quot; at vertex in bending plane (cm),
<span class="lineNum">      90 </span>            :   /// using simple values for dipole magnetic field.
<span class="lineNum">      91 </span>            :   
<span class="lineNum">      92 </span><span class="lineCov">        180 :   if (impactParam == 0.) return 1.e10;</span>
<span class="lineNum">      93 </span>            :   
<span class="lineNum">      94 </span>            :   const Double_t kCorrectionFactor = 1.1; // bending momentum is 10% underestimated
<span class="lineNum">      95 </span>            :   
<span class="lineNum">      96 </span><span class="lineCov">         90 :   if (fgFieldON) </span>
<span class="lineNum">      97 </span>            :   {
<span class="lineNum">      98 </span><span class="lineCov">         90 :     return kCorrectionFactor * (-0.0003 * fgSimpleBValue * fgkSimpleBLength * fgkSimpleBPosition / impactParam);</span>
<span class="lineNum">      99 </span>            :   }
<span class="lineNum">     100 </span>            :   else 
<span class="lineNum">     101 </span>            :   {
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :     return AliMUONConstants::GetMostProbBendingMomentum();</span>
<span class="lineNum">     103 </span>            :   }
<span class="lineNum">     104 </span><span class="lineCov">         90 : }</span>
<a name="105"><span class="lineNum">     105 </span>            : </a>
<span class="lineNum">     106 </span>            : //__________________________________________________________________________
<span class="lineNum">     107 </span>            : void AliMUONTrackExtrap::LinearExtrapToZ(AliMUONTrackParam* trackParam, Double_t zEnd)
<span class="lineNum">     108 </span>            : {
<span class="lineNum">     109 </span>            :   /// Track parameters linearly extrapolated to the plane at &quot;zEnd&quot;.
<span class="lineNum">     110 </span>            :   /// On return, results from the extrapolation are updated in trackParam.
<span class="lineNum">     111 </span>            :   
<span class="lineNum">     112 </span><span class="lineCov">        928 :   if (trackParam-&gt;GetZ() == zEnd) return; // nothing to be done if same z</span>
<span class="lineNum">     113 </span>            :   
<span class="lineNum">     114 </span>            :   // Compute track parameters
<span class="lineNum">     115 </span><span class="lineCov">        434 :   Double_t dZ = zEnd - trackParam-&gt;GetZ();</span>
<span class="lineNum">     116 </span><span class="lineCov">        434 :   trackParam-&gt;SetNonBendingCoor(trackParam-&gt;GetNonBendingCoor() + trackParam-&gt;GetNonBendingSlope() * dZ);</span>
<span class="lineNum">     117 </span><span class="lineCov">        434 :   trackParam-&gt;SetBendingCoor(trackParam-&gt;GetBendingCoor() + trackParam-&gt;GetBendingSlope() * dZ);</span>
<span class="lineNum">     118 </span><span class="lineCov">        434 :   trackParam-&gt;SetZ(zEnd);</span>
<span class="lineNum">     119 </span><span class="lineCov">        898 : }</span>
<a name="120"><span class="lineNum">     120 </span>            : </a>
<span class="lineNum">     121 </span>            : //__________________________________________________________________________
<span class="lineNum">     122 </span>            : void AliMUONTrackExtrap::LinearExtrapToZCov(AliMUONTrackParam* trackParam, Double_t zEnd, Bool_t updatePropagator)
<span class="lineNum">     123 </span>            : {
<span class="lineNum">     124 </span>            :   /// Track parameters and their covariances linearly extrapolated to the plane at &quot;zEnd&quot;.
<span class="lineNum">     125 </span>            :   /// On return, results from the extrapolation are updated in trackParam.
<span class="lineNum">     126 </span>            :   
<span class="lineNum">     127 </span><span class="lineCov">        418 :   if (trackParam-&gt;GetZ() == zEnd) return; // nothing to be done if same z</span>
<span class="lineNum">     128 </span>            :   
<span class="lineNum">     129 </span>            :   // No need to propagate the covariance matrix if it does not exist
<span class="lineNum">     130 </span><span class="lineCov">        384 :   if (!trackParam-&gt;CovariancesExist()) {</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :     cout&lt;&lt;&quot;W-AliMUONTrackExtrap::LinearExtrapToZCov: Covariance matrix does not exist&quot;&lt;&lt;endl;</span>
<span class="lineNum">     132 </span>            :     // Extrapolate linearly track parameters to &quot;zEnd&quot;
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :     LinearExtrapToZ(trackParam,zEnd);</span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     135 </span>            :   }
<span class="lineNum">     136 </span>            :   
<span class="lineNum">     137 </span>            :   // Compute track parameters
<span class="lineNum">     138 </span><span class="lineCov">        384 :   Double_t dZ = zEnd - trackParam-&gt;GetZ();</span>
<span class="lineNum">     139 </span><span class="lineCov">        384 :   trackParam-&gt;SetNonBendingCoor(trackParam-&gt;GetNonBendingCoor() + trackParam-&gt;GetNonBendingSlope() * dZ);</span>
<span class="lineNum">     140 </span><span class="lineCov">        384 :   trackParam-&gt;SetBendingCoor(trackParam-&gt;GetBendingCoor() + trackParam-&gt;GetBendingSlope() * dZ);</span>
<span class="lineNum">     141 </span><span class="lineCov">        384 :   trackParam-&gt;SetZ(zEnd);</span>
<span class="lineNum">     142 </span>            :   
<span class="lineNum">     143 </span>            :   // Calculate the jacobian related to the track parameters linear extrapolation to &quot;zEnd&quot;
<span class="lineNum">     144 </span><span class="lineCov">        384 :   TMatrixD jacob(5,5);</span>
<span class="lineNum">     145 </span><span class="lineCov">        384 :   jacob.UnitMatrix();</span>
<span class="lineNum">     146 </span><span class="lineCov">        768 :   jacob(0,1) = dZ;</span>
<span class="lineNum">     147 </span><span class="lineCov">        768 :   jacob(2,3) = dZ;</span>
<span class="lineNum">     148 </span>            :   
<span class="lineNum">     149 </span>            :   // Extrapolate track parameter covariances to &quot;zEnd&quot;
<span class="lineNum">     150 </span><span class="lineCov">        768 :   TMatrixD tmp(trackParam-&gt;GetCovariances(),TMatrixD::kMultTranspose,jacob);</span>
<span class="lineNum">     151 </span><span class="lineCov">        384 :   TMatrixD tmp2(jacob,TMatrixD::kMult,tmp);</span>
<span class="lineNum">     152 </span><span class="lineCov">        384 :   trackParam-&gt;SetCovariances(tmp2);</span>
<span class="lineNum">     153 </span>            :   
<span class="lineNum">     154 </span>            :   // Update the propagator if required
<span class="lineNum">     155 </span><span class="lineCov">        384 :   if (updatePropagator) trackParam-&gt;UpdatePropagator(jacob);</span>
<span class="lineNum">     156 </span><span class="lineCov">        802 : }</span>
<a name="157"><span class="lineNum">     157 </span>            : </a>
<span class="lineNum">     158 </span>            : //__________________________________________________________________________
<span class="lineNum">     159 </span>            : Bool_t AliMUONTrackExtrap::ExtrapToZ(AliMUONTrackParam* trackParam, Double_t zEnd)
<span class="lineNum">     160 </span>            : {
<span class="lineNum">     161 </span>            :   /// Interface to track parameter extrapolation to the plane at &quot;Z&quot; using Helix or Rungekutta algorithm.
<span class="lineNum">     162 </span>            :   /// On return, the track parameters resulting from the extrapolation are updated in trackParam.
<span class="lineNum">     163 </span><span class="lineCov">       8460 :   if (!fgFieldON) {</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :     AliMUONTrackExtrap::LinearExtrapToZ(trackParam,zEnd);</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :     return kTRUE;</span>
<span class="lineNum">     166 </span>            :   }
<span class="lineNum">     167 </span>            :   else if (fgkUseHelix) return AliMUONTrackExtrap::ExtrapToZHelix(trackParam,zEnd);
<span class="lineNum">     168 </span><span class="lineCov">       4230 :   else return AliMUONTrackExtrap::ExtrapToZRungekutta(trackParam,zEnd);</span>
<span class="lineNum">     169 </span><span class="lineCov">       4230 : }</span>
<a name="170"><span class="lineNum">     170 </span>            : </a>
<span class="lineNum">     171 </span>            : //__________________________________________________________________________
<span class="lineNum">     172 </span>            : Bool_t AliMUONTrackExtrap::ExtrapToZHelix(AliMUONTrackParam* trackParam, Double_t zEnd)
<span class="lineNum">     173 </span>            : {
<span class="lineNum">     174 </span>            :   /// Track parameter extrapolation to the plane at &quot;Z&quot; using Helix algorithm.
<span class="lineNum">     175 </span>            :   /// On return, the track parameters resulting from the extrapolation are updated in trackParam.
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :   if (trackParam-&gt;GetZ() == zEnd) return kTRUE; // nothing to be done if same Z</span>
<span class="lineNum">     177 </span>            :   Double_t forwardBackward; // +1 if forward, -1 if backward
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :   if (zEnd &lt; trackParam-&gt;GetZ()) forwardBackward = 1.0; // spectro. z&lt;0 </span>
<span class="lineNum">     179 </span>            :   else forwardBackward = -1.0;
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :   Double_t v3[7], v3New[7]; // 7 in parameter ????</span>
<span class="lineNum">     181 </span>            :   Int_t i3, stepNumber;
<span class="lineNum">     182 </span>            :   // For safety: return kTRUE or kFALSE ????
<span class="lineNum">     183 </span>            :   // Parameter vector for calling EXTRAP_ONESTEP
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :   ConvertTrackParamForExtrap(trackParam, forwardBackward, v3);</span>
<span class="lineNum">     185 </span>            :   // sign of charge (sign of fInverseBendingMomentum if forward motion)
<span class="lineNum">     186 </span>            :   // must be changed if backward extrapolation
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :   Double_t chargeExtrap = forwardBackward * TMath::Sign(Double_t(1.0), trackParam-&gt;GetInverseBendingMomentum());</span>
<span class="lineNum">     188 </span>            :   // Extrapolation loop
<span class="lineNum">     189 </span>            :   stepNumber = 0;
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :   while (((-forwardBackward * (v3[2] - zEnd)) &lt;= 0.0) &amp;&amp; (stepNumber &lt; fgkMaxStepNumber)) { // spectro. z&lt;0</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :     stepNumber++;</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :     ExtrapOneStepHelix(chargeExtrap, fgkHelixStepLength, v3, v3New);</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :     if ((-forwardBackward * (v3New[2] - zEnd)) &gt; 0.0) break; // one is beyond Z spectro. z&lt;0</span>
<span class="lineNum">     194 </span>            :                                                              // better use TArray ????
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :     for (i3 = 0; i3 &lt; 7; i3++) {v3[i3] = v3New[i3];}</span>
<span class="lineNum">     196 </span>            :   }
<span class="lineNum">     197 </span>            :   // check fgkMaxStepNumber ????
<span class="lineNum">     198 </span>            :   // Interpolation back to exact Z (2nd order)
<span class="lineNum">     199 </span>            :   // should be in function ???? using TArray ????
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :   Double_t dZ12 = v3New[2] - v3[2]; // 1-&gt;2</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :   if (TMath::Abs(dZ12) &gt; 0) {</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :     Double_t dZ1i = zEnd - v3[2]; // 1-i</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :     Double_t dZi2 = v3New[2] - zEnd; // i-&gt;2</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :     Double_t xPrime = (v3New[0] - v3[0]) / dZ12;</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :     Double_t xSecond = ((v3New[3] / v3New[5]) - (v3[3] / v3[5])) / dZ12;</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :     Double_t yPrime = (v3New[1] - v3[1]) / dZ12;</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :     Double_t ySecond = ((v3New[4] / v3New[5]) - (v3[4] / v3[5])) / dZ12;</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :     v3[0] = v3[0] + xPrime * dZ1i - 0.5 * xSecond * dZ1i * dZi2; // X</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :     v3[1] = v3[1] + yPrime * dZ1i - 0.5 * ySecond * dZ1i * dZi2; // Y</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :     v3[2] = zEnd; // Z</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :     Double_t xPrimeI = xPrime - 0.5 * xSecond * (dZi2 - dZ1i);</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :     Double_t yPrimeI = yPrime - 0.5 * ySecond * (dZi2 - dZ1i);</span>
<span class="lineNum">     213 </span>            :     // (PX, PY, PZ)/PTOT assuming forward motion
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :     v3[5] = 1.0 / TMath::Sqrt(1.0 + xPrimeI * xPrimeI + yPrimeI * yPrimeI); // PZ/PTOT</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :     v3[3] = xPrimeI * v3[5]; // PX/PTOT</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :     v3[4] = yPrimeI * v3[5]; // PY/PTOT</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :     cout&lt;&lt;&quot;W-AliMUONTrackExtrap::ExtrapToZHelix: Extrap. to Z not reached, Z = &quot;&lt;&lt;zEnd&lt;&lt;endl;</span>
<span class="lineNum">     219 </span>            :   }
<span class="lineNum">     220 </span>            :   // Recover track parameters (charge back for forward motion)
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :   RecoverTrackParam(v3, chargeExtrap * forwardBackward, trackParam);</span>
<span class="lineNum">     222 </span>            :   return kTRUE;
<span class="lineNum">     223 </span><span class="lineNoCov">          0 : }</span>
<a name="224"><span class="lineNum">     224 </span>            : </a>
<span class="lineNum">     225 </span>            : //__________________________________________________________________________
<span class="lineNum">     226 </span>            : Bool_t AliMUONTrackExtrap::ExtrapToZRungekutta(AliMUONTrackParam* trackParam, Double_t zEnd)
<span class="lineNum">     227 </span>            : {
<span class="lineNum">     228 </span>            :   /// Track parameter extrapolation to the plane at &quot;Z&quot; using Rungekutta algorithm.
<span class="lineNum">     229 </span>            :   /// On return, the track parameters resulting from the extrapolation are updated in trackParam.
<span class="lineNum">     230 </span><span class="lineCov">       8460 :   if (trackParam-&gt;GetZ() == zEnd) return kTRUE; // nothing to be done if same Z</span>
<span class="lineNum">     231 </span>            :   Double_t forwardBackward; // +1 if forward, -1 if backward
<span class="lineNum">     232 </span><span class="lineCov">       5350 :   if (zEnd &lt; trackParam-&gt;GetZ()) forwardBackward = 1.0; // spectro. z&lt;0 </span>
<span class="lineNum">     233 </span>            :   else forwardBackward = -1.0;
<span class="lineNum">     234 </span>            :   // sign of charge (sign of fInverseBendingMomentum if forward motion)
<span class="lineNum">     235 </span>            :   // must be changed if backward extrapolation
<span class="lineNum">     236 </span><span class="lineCov">       4230 :   Double_t chargeExtrap = forwardBackward * TMath::Sign(Double_t(1.0), trackParam-&gt;GetInverseBendingMomentum());</span>
<span class="lineNum">     237 </span><span class="lineCov">       4230 :   Double_t v3[7], v3New[7];</span>
<span class="lineNum">     238 </span>            :   Double_t dZ, step;
<span class="lineNum">     239 </span>            :   Int_t stepNumber = 0;
<span class="lineNum">     240 </span>            :   
<span class="lineNum">     241 </span>            :   // Extrapolation loop (until within tolerance or the track turn around)
<span class="lineNum">     242 </span><span class="lineCov">       4230 :   Double_t residue = zEnd - trackParam-&gt;GetZ();</span>
<span class="lineNum">     243 </span>            :   Bool_t uturn = kFALSE;
<span class="lineNum">     244 </span>            :   Bool_t trackingFailed = kFALSE;
<span class="lineNum">     245 </span>            :   Bool_t tooManyStep = kFALSE;
<span class="lineNum">     246 </span><span class="lineCov">      17644 :   while (TMath::Abs(residue) &gt; fgkRungeKuttaMaxResidue &amp;&amp; stepNumber &lt;= fgkMaxStepNumber) {</span>
<span class="lineNum">     247 </span>            :     
<span class="lineNum">     248 </span><span class="lineCov">       4592 :     dZ = zEnd - trackParam-&gt;GetZ();</span>
<span class="lineNum">     249 </span>            :     // step lenght assuming linear trajectory
<span class="lineNum">     250 </span><span class="lineCov">       9184 :     step = dZ * TMath::Sqrt(1.0 + trackParam-&gt;GetBendingSlope()*trackParam-&gt;GetBendingSlope() +</span>
<span class="lineNum">     251 </span><span class="lineCov">       4592 :                             trackParam-&gt;GetNonBendingSlope()*trackParam-&gt;GetNonBendingSlope());</span>
<span class="lineNum">     252 </span><span class="lineCov">       4592 :     ConvertTrackParamForExtrap(trackParam, forwardBackward, v3);</span>
<span class="lineNum">     253 </span>            :     
<span class="lineNum">     254 </span><span class="lineCov">       4592 :     do { // reduce step lenght while zEnd oversteped</span>
<span class="lineNum">     255 </span><span class="lineCov">       5018 :       if (stepNumber &gt; fgkMaxStepNumber) {</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :         cout&lt;&lt;&quot;W-AliMUONTrackExtrap::ExtrapToZRungekutta: Too many trials: &quot;&lt;&lt;stepNumber&lt;&lt;endl;</span>
<span class="lineNum">     257 </span>            :         tooManyStep = kTRUE;
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     259 </span>            :       }
<span class="lineNum">     260 </span><span class="lineCov">       5018 :       stepNumber ++;</span>
<span class="lineNum">     261 </span><span class="lineCov">       5018 :       step = TMath::Abs(step);</span>
<span class="lineNum">     262 </span><span class="lineCov">       5018 :       if (!AliMUONTrackExtrap::ExtrapOneStepRungekutta(chargeExtrap,step,v3,v3New)) {</span>
<span class="lineNum">     263 </span>            :         trackingFailed = kTRUE;
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     265 </span>            :       }
<span class="lineNum">     266 </span><span class="lineCov">       5018 :       residue = zEnd - v3New[2];</span>
<span class="lineNum">     267 </span><span class="lineCov">       5018 :       step *= dZ/(v3New[2]-trackParam-&gt;GetZ());</span>
<span class="lineNum">     268 </span><span class="lineCov">       6946 :     } while (residue*dZ &lt; 0 &amp;&amp; TMath::Abs(residue) &gt; fgkRungeKuttaMaxResidue);</span>
<span class="lineNum">     269 </span>            :     
<span class="lineNum">     270 </span><span class="lineCov">       4592 :     if (trackingFailed) break;</span>
<span class="lineNum">     271 </span><span class="lineCov">       4592 :     else if (v3New[5]*v3[5] &lt; 0) { // the track turned around</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :       cout&lt;&lt;&quot;W-AliMUONTrackExtrap::ExtrapToZRungekutta: The track turned around&quot;&lt;&lt;endl;</span>
<span class="lineNum">     273 </span>            :       uturn = kTRUE;
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     275 </span><span class="lineCov">       4592 :     } else RecoverTrackParam(v3New, chargeExtrap * forwardBackward, trackParam);</span>
<span class="lineNum">     276 </span>            :     
<span class="lineNum">     277 </span>            :   }
<span class="lineNum">     278 </span>            :   
<span class="lineNum">     279 </span>            :   // terminate the extropolation with a straight line up to the exact &quot;zEnd&quot; value
<span class="lineNum">     280 </span><span class="lineCov">       8460 :   if (trackingFailed || uturn) {</span>
<span class="lineNum">     281 </span>            :     
<span class="lineNum">     282 </span>            :     // track ends +-100 meters away in the bending direction
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :     dZ = zEnd - v3[2];</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :     Double_t bendingSlope = TMath::Sign(1.e4,-fgSimpleBValue*trackParam-&gt;GetInverseBendingMomentum()) / dZ;</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :     Double_t pZ = TMath::Abs(1. / trackParam-&gt;GetInverseBendingMomentum()) / TMath::Sqrt(1.0 + bendingSlope * bendingSlope);</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :     Double_t nonBendingSlope = TMath::Sign(TMath::Abs(v3[3]) * v3[6] / pZ, trackParam-&gt;GetNonBendingSlope());</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :     trackParam-&gt;SetNonBendingCoor(trackParam-&gt;GetNonBendingCoor() + dZ * nonBendingSlope);</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :     trackParam-&gt;SetNonBendingSlope(nonBendingSlope);</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :     trackParam-&gt;SetBendingCoor(trackParam-&gt;GetBendingCoor() + dZ * bendingSlope);</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :     trackParam-&gt;SetBendingSlope(bendingSlope);</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :     trackParam-&gt;SetZ(zEnd);</span>
<span class="lineNum">     292 </span>            :     
<span class="lineNum">     293 </span>            :     return kFALSE;
<span class="lineNum">     294 </span>            :     
<span class="lineNum">     295 </span>            :   } else {
<span class="lineNum">     296 </span>            :     
<span class="lineNum">     297 </span>            :     // track extrapolated normally
<span class="lineNum">     298 </span><span class="lineCov">       4230 :     trackParam-&gt;SetNonBendingCoor(trackParam-&gt;GetNonBendingCoor() + residue * trackParam-&gt;GetNonBendingSlope());</span>
<span class="lineNum">     299 </span><span class="lineCov">       4230 :     trackParam-&gt;SetBendingCoor(trackParam-&gt;GetBendingCoor() + residue * trackParam-&gt;GetBendingSlope());</span>
<span class="lineNum">     300 </span><span class="lineCov">       4230 :     trackParam-&gt;SetZ(zEnd);</span>
<span class="lineNum">     301 </span>            :     
<span class="lineNum">     302 </span><span class="lineCov">       4230 :     return !tooManyStep;</span>
<span class="lineNum">     303 </span>            :     
<span class="lineNum">     304 </span>            :   }
<span class="lineNum">     305 </span>            :   
<span class="lineNum">     306 </span><span class="lineCov">       8460 : }</span>
<a name="307"><span class="lineNum">     307 </span>            : </a>
<span class="lineNum">     308 </span>            : //__________________________________________________________________________
<span class="lineNum">     309 </span>            : void AliMUONTrackExtrap::ConvertTrackParamForExtrap(AliMUONTrackParam* trackParam, Double_t forwardBackward, Double_t *v3)
<span class="lineNum">     310 </span>            : {
<span class="lineNum">     311 </span>            :   /// Set vector of Geant3 parameters pointed to by &quot;v3&quot; from track parameters in trackParam.
<span class="lineNum">     312 </span>            :   /// Since AliMUONTrackParam is only geometry, one uses &quot;forwardBackward&quot;
<span class="lineNum">     313 </span>            :   /// to know whether the particle is going forward (+1) or backward (-1).
<span class="lineNum">     314 </span><span class="lineCov">       9184 :   v3[0] = trackParam-&gt;GetNonBendingCoor(); // X</span>
<span class="lineNum">     315 </span><span class="lineCov">       4592 :   v3[1] = trackParam-&gt;GetBendingCoor(); // Y</span>
<span class="lineNum">     316 </span><span class="lineCov">       4592 :   v3[2] = trackParam-&gt;GetZ(); // Z</span>
<span class="lineNum">     317 </span><span class="lineCov">       4592 :   Double_t pYZ = TMath::Abs(1.0 / trackParam-&gt;GetInverseBendingMomentum());</span>
<span class="lineNum">     318 </span><span class="lineCov">       4592 :   Double_t pZ = pYZ / TMath::Sqrt(1.0 + trackParam-&gt;GetBendingSlope() * trackParam-&gt;GetBendingSlope());</span>
<span class="lineNum">     319 </span><span class="lineCov">       4592 :   v3[6] = TMath::Sqrt(pYZ * pYZ + pZ * pZ * trackParam-&gt;GetNonBendingSlope() * trackParam-&gt;GetNonBendingSlope()); // PTOT</span>
<span class="lineNum">     320 </span><span class="lineCov">       4592 :   v3[5] = -forwardBackward * pZ / v3[6]; // PZ/PTOT spectro. z&lt;0</span>
<span class="lineNum">     321 </span><span class="lineCov">       4592 :   v3[3] = trackParam-&gt;GetNonBendingSlope() * v3[5]; // PX/PTOT</span>
<span class="lineNum">     322 </span><span class="lineCov">       4592 :   v3[4] = trackParam-&gt;GetBendingSlope() * v3[5]; // PY/PTOT</span>
<span class="lineNum">     323 </span><span class="lineCov">       4592 : }</span>
<a name="324"><span class="lineNum">     324 </span>            : </a>
<span class="lineNum">     325 </span>            : //__________________________________________________________________________
<span class="lineNum">     326 </span>            : void AliMUONTrackExtrap::RecoverTrackParam(Double_t *v3, Double_t charge, AliMUONTrackParam* trackParam)
<span class="lineNum">     327 </span>            : {
<span class="lineNum">     328 </span>            :   /// Set track parameters in trackParam from Geant3 parameters pointed to by &quot;v3&quot;,
<span class="lineNum">     329 </span>            :   /// assumed to be calculated for forward motion in Z.
<span class="lineNum">     330 </span>            :   /// &quot;InverseBendingMomentum&quot; is signed with &quot;charge&quot;.
<span class="lineNum">     331 </span><span class="lineCov">       9184 :   trackParam-&gt;SetNonBendingCoor(v3[0]); // X</span>
<span class="lineNum">     332 </span><span class="lineCov">       4592 :   trackParam-&gt;SetBendingCoor(v3[1]); // Y</span>
<span class="lineNum">     333 </span><span class="lineCov">       4592 :   trackParam-&gt;SetZ(v3[2]); // Z</span>
<span class="lineNum">     334 </span><span class="lineCov">       4592 :   Double_t pYZ = v3[6] * TMath::Sqrt((1.-v3[3])*(1.+v3[3]));</span>
<span class="lineNum">     335 </span><span class="lineCov">       4592 :   trackParam-&gt;SetInverseBendingMomentum(charge/pYZ);</span>
<span class="lineNum">     336 </span><span class="lineCov">       4592 :   trackParam-&gt;SetBendingSlope(v3[4]/v3[5]);</span>
<span class="lineNum">     337 </span><span class="lineCov">       4592 :   trackParam-&gt;SetNonBendingSlope(v3[3]/v3[5]);</span>
<span class="lineNum">     338 </span><span class="lineCov">       4592 : }</span>
<a name="339"><span class="lineNum">     339 </span>            : </a>
<span class="lineNum">     340 </span>            : //__________________________________________________________________________
<span class="lineNum">     341 </span>            : Bool_t AliMUONTrackExtrap::ExtrapToZCov(AliMUONTrackParam* trackParam, Double_t zEnd, Bool_t updatePropagator)
<span class="lineNum">     342 </span>            : {
<span class="lineNum">     343 </span>            :   /// Track parameters and their covariances extrapolated to the plane at &quot;zEnd&quot;.
<span class="lineNum">     344 </span>            :   /// On return, results from the extrapolation are updated in trackParam.
<span class="lineNum">     345 </span>            :   
<span class="lineNum">     346 </span><span class="lineCov">        684 :   if (trackParam-&gt;GetZ() == zEnd) return kTRUE; // nothing to be done if same z</span>
<span class="lineNum">     347 </span>            :   
<span class="lineNum">     348 </span><span class="lineCov">        684 :   if (!fgFieldON) { // linear extrapolation if no magnetic field</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :     AliMUONTrackExtrap::LinearExtrapToZCov(trackParam,zEnd,updatePropagator);</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :     return kTRUE;</span>
<span class="lineNum">     351 </span>            :   }
<span class="lineNum">     352 </span>            :   
<span class="lineNum">     353 </span>            :   // No need to propagate the covariance matrix if it does not exist
<span class="lineNum">     354 </span><span class="lineCov">        684 :   if (!trackParam-&gt;CovariancesExist()) {</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :     cout&lt;&lt;&quot;W-AliMUONTrackExtrap::ExtrapToZCov: Covariance matrix does not exist&quot;&lt;&lt;endl;</span>
<span class="lineNum">     356 </span>            :     // Extrapolate track parameters to &quot;zEnd&quot;
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :     return ExtrapToZ(trackParam,zEnd);</span>
<span class="lineNum">     358 </span>            :   }
<span class="lineNum">     359 </span>            :   
<span class="lineNum">     360 </span>            :   // Save the actual track parameters
<span class="lineNum">     361 </span><span class="lineCov">        684 :   AliMUONTrackParam trackParamSave(*trackParam);</span>
<span class="lineNum">     362 </span><span class="lineCov">        684 :   TMatrixD paramSave(trackParamSave.GetParameters());</span>
<span class="lineNum">     363 </span><span class="lineCov">        684 :   Double_t zBegin = trackParamSave.GetZ();</span>
<span class="lineNum">     364 </span>            :   
<span class="lineNum">     365 </span>            :   // Get reference to the parameter covariance matrix
<span class="lineNum">     366 </span><span class="lineCov">        684 :   const TMatrixD&amp; kParamCov = trackParam-&gt;GetCovariances();</span>
<span class="lineNum">     367 </span>            :         
<span class="lineNum">     368 </span>            :   // Extrapolate track parameters to &quot;zEnd&quot;
<span class="lineNum">     369 </span>            :   // Do not update the covariance matrix if the extrapolation failed
<span class="lineNum">     370 </span><span class="lineCov">       1368 :   if (!ExtrapToZ(trackParam,zEnd)) return kFALSE;</span>
<span class="lineNum">     371 </span>            :   
<span class="lineNum">     372 </span>            :   // Get reference to the extrapolated parameters
<span class="lineNum">     373 </span><span class="lineCov">        684 :   const TMatrixD&amp; extrapParam = trackParam-&gt;GetParameters();</span>
<span class="lineNum">     374 </span>            :   
<span class="lineNum">     375 </span>            :   // Calculate the jacobian related to the track parameters extrapolation to &quot;zEnd&quot;
<span class="lineNum">     376 </span>            :   Bool_t extrapStatus = kTRUE;
<span class="lineNum">     377 </span><span class="lineCov">        684 :   TMatrixD jacob(5,5);</span>
<span class="lineNum">     378 </span><span class="lineCov">        684 :   jacob.Zero();</span>
<span class="lineNum">     379 </span><span class="lineCov">        684 :   TMatrixD dParam(5,1);</span>
<span class="lineNum">     380 </span><span class="lineCov">        684 :   Double_t direction[5] = {-1.,-1.,1.,1.,-1.};</span>
<span class="lineNum">     381 </span><span class="lineCov">       8208 :   for (Int_t i=0; i&lt;5; i++) {</span>
<span class="lineNum">     382 </span>            :     // Skip jacobian calculation for parameters with no associated error
<span class="lineNum">     383 </span><span class="lineCov">       6840 :     if (kParamCov(i,i) &lt;= 0.) continue;</span>
<span class="lineNum">     384 </span>            :     
<span class="lineNum">     385 </span>            :     // Small variation of parameter i only
<span class="lineNum">     386 </span><span class="lineCov">      41040 :     for (Int_t j=0; j&lt;5; j++) {</span>
<span class="lineNum">     387 </span><span class="lineCov">      17100 :       if (j==i) {</span>
<span class="lineNum">     388 </span><span class="lineCov">      10260 :         dParam(j,0) = TMath::Sqrt(kParamCov(i,i));</span>
<span class="lineNum">     389 </span><span class="lineCov">      10260 :         dParam(j,0) *= TMath::Sign(1.,direction[j]*paramSave(j,0)); // variation always in the same direction</span>
<span class="lineNum">     390 </span><span class="lineCov">      30780 :       } else dParam(j,0) = 0.;</span>
<span class="lineNum">     391 </span>            :     }
<span class="lineNum">     392 </span>            :     
<span class="lineNum">     393 </span>            :     // Set new parameters
<span class="lineNum">     394 </span><span class="lineCov">       3420 :     trackParamSave.SetParameters(paramSave);</span>
<span class="lineNum">     395 </span><span class="lineCov">       3420 :     trackParamSave.AddParameters(dParam);</span>
<span class="lineNum">     396 </span><span class="lineCov">       3420 :     trackParamSave.SetZ(zBegin);</span>
<span class="lineNum">     397 </span>            :     
<span class="lineNum">     398 </span>            :     // Extrapolate new track parameters to &quot;zEnd&quot;
<span class="lineNum">     399 </span><span class="lineCov">       6840 :     if (!ExtrapToZ(&amp;trackParamSave,zEnd)) {</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :       cout&lt;&lt;&quot;W-AliMUONTrackExtrap::ExtrapToZCov: Bad covariance matrix&quot;&lt;&lt;endl;</span>
<span class="lineNum">     401 </span>            :       extrapStatus = kFALSE;
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     403 </span>            :     
<span class="lineNum">     404 </span>            :     // Calculate the jacobian
<span class="lineNum">     405 </span><span class="lineCov">       3420 :     TMatrixD jacobji(trackParamSave.GetParameters(),TMatrixD::kMinus,extrapParam);</span>
<span class="lineNum">     406 </span><span class="lineCov">       6840 :     jacobji *= 1. / dParam(i,0);</span>
<span class="lineNum">     407 </span><span class="lineCov">       3420 :     jacob.SetSub(0,i,jacobji);</span>
<span class="lineNum">     408 </span><span class="lineCov">       3420 :   }</span>
<span class="lineNum">     409 </span>            :   
<span class="lineNum">     410 </span>            :   // Extrapolate track parameter covariances to &quot;zEnd&quot;
<span class="lineNum">     411 </span><span class="lineCov">        684 :   TMatrixD tmp(kParamCov,TMatrixD::kMultTranspose,jacob);</span>
<span class="lineNum">     412 </span><span class="lineCov">        684 :   TMatrixD tmp2(jacob,TMatrixD::kMult,tmp);</span>
<span class="lineNum">     413 </span><span class="lineCov">        684 :   trackParam-&gt;SetCovariances(tmp2);</span>
<span class="lineNum">     414 </span>            :   
<span class="lineNum">     415 </span>            :   // Update the propagator if required
<span class="lineNum">     416 </span><span class="lineCov">       1248 :   if (updatePropagator) trackParam-&gt;UpdatePropagator(jacob);</span>
<span class="lineNum">     417 </span>            :   
<span class="lineNum">     418 </span><span class="lineCov">        684 :   return extrapStatus;</span>
<span class="lineNum">     419 </span><span class="lineCov">       2052 : }</span>
<a name="420"><span class="lineNum">     420 </span>            : </a>
<span class="lineNum">     421 </span>            : //__________________________________________________________________________
<span class="lineNum">     422 </span>            : void AliMUONTrackExtrap::AddMCSEffectInAbsorber(AliMUONTrackParam* param, Double_t signedPathLength, Double_t f0, Double_t f1, Double_t f2)
<span class="lineNum">     423 </span>            : {
<span class="lineNum">     424 </span>            :   /// Add to the track parameter covariances the effects of multiple Coulomb scattering
<span class="lineNum">     425 </span>            :   /// signedPathLength must have the sign of (zOut - zIn) where all other parameters are assumed to be given at zOut.
<span class="lineNum">     426 </span>            :   
<span class="lineNum">     427 </span>            :   // absorber related covariance parameters
<span class="lineNum">     428 </span><span class="lineCov">         64 :   Double_t bendingSlope = param-&gt;GetBendingSlope();</span>
<span class="lineNum">     429 </span><span class="lineCov">         32 :   Double_t nonBendingSlope = param-&gt;GetNonBendingSlope();</span>
<span class="lineNum">     430 </span><span class="lineCov">         32 :   Double_t inverseBendingMomentum = param-&gt;GetInverseBendingMomentum();</span>
<span class="lineNum">     431 </span><span class="lineCov">         64 :   Double_t alpha2 = 0.0136 * 0.0136 * inverseBendingMomentum * inverseBendingMomentum * (1.0 + bendingSlope * bendingSlope) /</span>
<span class="lineNum">     432 </span><span class="lineCov">         32 :                     (1.0 + bendingSlope *bendingSlope + nonBendingSlope * nonBendingSlope); // velocity = 1</span>
<span class="lineNum">     433 </span><span class="lineCov">         32 :   Double_t pathLength = TMath::Abs(signedPathLength);</span>
<span class="lineNum">     434 </span><span class="lineCov">         32 :   Double_t varCoor = alpha2 * (pathLength * pathLength * f0 - 2. * pathLength * f1 + f2);</span>
<span class="lineNum">     435 </span><span class="lineCov">         32 :   Double_t covCorrSlope = TMath::Sign(1.,signedPathLength) * alpha2 * (pathLength * f0 - f1);</span>
<span class="lineNum">     436 </span><span class="lineCov">         32 :   Double_t varSlop = alpha2 * f0;</span>
<span class="lineNum">     437 </span>            :   
<span class="lineNum">     438 </span>            :   // Set MCS covariance matrix
<span class="lineNum">     439 </span><span class="lineCov">         32 :   TMatrixD newParamCov(param-&gt;GetCovariances());</span>
<span class="lineNum">     440 </span>            :   // Non bending plane
<span class="lineNum">     441 </span><span class="lineCov">         96 :   newParamCov(0,0) += varCoor;       newParamCov(0,1) += covCorrSlope;</span>
<span class="lineNum">     442 </span><span class="lineCov">         96 :   newParamCov(1,0) += covCorrSlope;  newParamCov(1,1) += varSlop;</span>
<span class="lineNum">     443 </span>            :   // Bending plane
<span class="lineNum">     444 </span><span class="lineCov">         96 :   newParamCov(2,2) += varCoor;       newParamCov(2,3) += covCorrSlope;</span>
<span class="lineNum">     445 </span><span class="lineCov">         96 :   newParamCov(3,2) += covCorrSlope;  newParamCov(3,3) += varSlop;</span>
<span class="lineNum">     446 </span>            :   
<span class="lineNum">     447 </span>            :   // Set momentum related covariances if B!=0
<span class="lineNum">     448 </span><span class="lineCov">         32 :   if (fgFieldON) {</span>
<span class="lineNum">     449 </span>            :     // compute derivative d(q/Pxy) / dSlopeX and d(q/Pxy) / dSlopeY
<span class="lineNum">     450 </span><span class="lineCov">         32 :     Double_t dqPxydSlopeX = inverseBendingMomentum * nonBendingSlope / (1. + nonBendingSlope*nonBendingSlope + bendingSlope*bendingSlope);</span>
<span class="lineNum">     451 </span><span class="lineCov">         32 :     Double_t dqPxydSlopeY = - inverseBendingMomentum * nonBendingSlope*nonBendingSlope * bendingSlope /</span>
<span class="lineNum">     452 </span><span class="lineCov">         32 :                               (1. + bendingSlope*bendingSlope) / (1. + nonBendingSlope*nonBendingSlope + bendingSlope*bendingSlope);</span>
<span class="lineNum">     453 </span>            :     // Inverse bending momentum (due to dependences with bending and non bending slopes)
<span class="lineNum">     454 </span><span class="lineCov">         96 :     newParamCov(4,0) += dqPxydSlopeX * covCorrSlope; newParamCov(0,4) += dqPxydSlopeX * covCorrSlope;</span>
<span class="lineNum">     455 </span><span class="lineCov">         96 :     newParamCov(4,1) += dqPxydSlopeX * varSlop;      newParamCov(1,4) += dqPxydSlopeX * varSlop;</span>
<span class="lineNum">     456 </span><span class="lineCov">         96 :     newParamCov(4,2) += dqPxydSlopeY * covCorrSlope; newParamCov(2,4) += dqPxydSlopeY * covCorrSlope;</span>
<span class="lineNum">     457 </span><span class="lineCov">         96 :     newParamCov(4,3) += dqPxydSlopeY * varSlop;      newParamCov(3,4) += dqPxydSlopeY * varSlop;</span>
<span class="lineNum">     458 </span><span class="lineCov">         64 :     newParamCov(4,4) += (dqPxydSlopeX*dqPxydSlopeX + dqPxydSlopeY*dqPxydSlopeY) * varSlop;</span>
<span class="lineNum">     459 </span><span class="lineCov">         32 :   }</span>
<span class="lineNum">     460 </span>            :   
<span class="lineNum">     461 </span>            :   // Set new covariances
<span class="lineNum">     462 </span><span class="lineCov">         32 :   param-&gt;SetCovariances(newParamCov);</span>
<span class="lineNum">     463 </span><span class="lineCov">         32 : }</span>
<a name="464"><span class="lineNum">     464 </span>            : </a>
<span class="lineNum">     465 </span>            : //__________________________________________________________________________
<span class="lineNum">     466 </span>            : void AliMUONTrackExtrap::CorrectMCSEffectInAbsorber(AliMUONTrackParam* param,
<span class="lineNum">     467 </span>            :                                                     Double_t xVtx, Double_t yVtx, Double_t zVtx,
<span class="lineNum">     468 </span>            :                                                     Double_t errXVtx, Double_t errYVtx,
<span class="lineNum">     469 </span>            :                                                     Double_t absZBeg, Double_t pathLength, Double_t f0, Double_t f1, Double_t f2)
<span class="lineNum">     470 </span>            : {
<span class="lineNum">     471 </span>            :   /// Correct parameters and corresponding covariances using Branson correction
<span class="lineNum">     472 </span>            :   /// - input param are parameters and covariances at the end of absorber
<span class="lineNum">     473 </span>            :   /// - output param are parameters and covariances at vertex
<span class="lineNum">     474 </span>            :   /// Absorber correction parameters are supposed to be calculated at the current track z-position
<span class="lineNum">     475 </span>            :   
<span class="lineNum">     476 </span>            :   // Position of the Branson plane (spectro. (z&lt;0))
<span class="lineNum">     477 </span><span class="lineCov">         64 :   Double_t zB = (f1&gt;0.) ? absZBeg - f2/f1 : 0.;</span>
<span class="lineNum">     478 </span>            :   
<span class="lineNum">     479 </span>            :   // Add MCS effects to current parameter covariances (spectro. (z&lt;0))
<span class="lineNum">     480 </span><span class="lineCov">         16 :   AddMCSEffectInAbsorber(param, -pathLength, f0, f1, f2);</span>
<span class="lineNum">     481 </span>            :   
<span class="lineNum">     482 </span>            :   // Get track parameters and covariances in the Branson plane corrected for magnetic field effect
<span class="lineNum">     483 </span><span class="lineCov">         16 :   ExtrapToZCov(param,zVtx);</span>
<span class="lineNum">     484 </span><span class="lineCov">         16 :   LinearExtrapToZCov(param,zB);</span>
<span class="lineNum">     485 </span>            :   
<span class="lineNum">     486 </span>            :   // compute track parameters at vertex
<span class="lineNum">     487 </span><span class="lineCov">         16 :   TMatrixD newParam(5,1);</span>
<span class="lineNum">     488 </span><span class="lineCov">         32 :   newParam(0,0) = xVtx;</span>
<span class="lineNum">     489 </span><span class="lineCov">         48 :   newParam(1,0) = (param-&gt;GetNonBendingCoor() - xVtx) / (zB - zVtx);</span>
<span class="lineNum">     490 </span><span class="lineCov">         32 :   newParam(2,0) = yVtx;</span>
<span class="lineNum">     491 </span><span class="lineCov">         48 :   newParam(3,0) = (param-&gt;GetBendingCoor() - yVtx) / (zB - zVtx);</span>
<span class="lineNum">     492 </span><span class="lineCov">         96 :   newParam(4,0) = param-&gt;GetCharge() / param-&gt;P() *</span>
<span class="lineNum">     493 </span><span class="lineCov">         96 :                   TMath::Sqrt(1.0 + newParam(1,0)*newParam(1,0) + newParam(3,0)*newParam(3,0)) /</span>
<span class="lineNum">     494 </span><span class="lineCov">         48 :                   TMath::Sqrt(1.0 + newParam(3,0)*newParam(3,0));</span>
<span class="lineNum">     495 </span>            :   
<span class="lineNum">     496 </span>            :   // Get covariances in (X, SlopeX, Y, SlopeY, q*PTot) coordinate system
<span class="lineNum">     497 </span><span class="lineCov">         32 :   TMatrixD paramCovP(param-&gt;GetCovariances());</span>
<span class="lineNum">     498 </span><span class="lineCov">         16 :   Cov2CovP(param-&gt;GetParameters(),paramCovP);</span>
<span class="lineNum">     499 </span>            :   
<span class="lineNum">     500 </span>            :   // Get the covariance matrix in the (XVtx, X, YVtx, Y, q*PTot) coordinate system
<span class="lineNum">     501 </span><span class="lineCov">         16 :   TMatrixD paramCovVtx(5,5);</span>
<span class="lineNum">     502 </span><span class="lineCov">         16 :   paramCovVtx.Zero();</span>
<span class="lineNum">     503 </span><span class="lineCov">         32 :   paramCovVtx(0,0) = errXVtx * errXVtx;</span>
<span class="lineNum">     504 </span><span class="lineCov">         48 :   paramCovVtx(1,1) = paramCovP(0,0);</span>
<span class="lineNum">     505 </span><span class="lineCov">         32 :   paramCovVtx(2,2) = errYVtx * errYVtx;</span>
<span class="lineNum">     506 </span><span class="lineCov">         48 :   paramCovVtx(3,3) = paramCovP(2,2);</span>
<span class="lineNum">     507 </span><span class="lineCov">         48 :   paramCovVtx(4,4) = paramCovP(4,4);</span>
<span class="lineNum">     508 </span><span class="lineCov">         48 :   paramCovVtx(1,3) = paramCovP(0,2);</span>
<span class="lineNum">     509 </span><span class="lineCov">         48 :   paramCovVtx(3,1) = paramCovP(2,0);</span>
<span class="lineNum">     510 </span><span class="lineCov">         48 :   paramCovVtx(1,4) = paramCovP(0,4);</span>
<span class="lineNum">     511 </span><span class="lineCov">         48 :   paramCovVtx(4,1) = paramCovP(4,0);</span>
<span class="lineNum">     512 </span><span class="lineCov">         48 :   paramCovVtx(3,4) = paramCovP(2,4);</span>
<span class="lineNum">     513 </span><span class="lineCov">         48 :   paramCovVtx(4,3) = paramCovP(4,2);</span>
<span class="lineNum">     514 </span>            :   
<span class="lineNum">     515 </span>            :   // Jacobian of the transformation (XVtx, X, YVtx, Y, q*PTot) -&gt; (XVtx, SlopeXVtx, YVtx, SlopeYVtx, q*PTotVtx)
<span class="lineNum">     516 </span><span class="lineCov">         16 :   TMatrixD jacob(5,5);</span>
<span class="lineNum">     517 </span><span class="lineCov">         16 :   jacob.UnitMatrix();</span>
<span class="lineNum">     518 </span><span class="lineCov">         32 :   jacob(1,0) = - 1. / (zB - zVtx);</span>
<span class="lineNum">     519 </span><span class="lineCov">         32 :   jacob(1,1) = 1. / (zB - zVtx);</span>
<span class="lineNum">     520 </span><span class="lineCov">         32 :   jacob(3,2) = - 1. / (zB - zVtx);</span>
<span class="lineNum">     521 </span><span class="lineCov">         32 :   jacob(3,3) = 1. / (zB - zVtx);</span>
<span class="lineNum">     522 </span>            :   
<span class="lineNum">     523 </span>            :   // Compute covariances at vertex in the (XVtx, SlopeXVtx, YVtx, SlopeYVtx, q*PTotVtx) coordinate system
<span class="lineNum">     524 </span><span class="lineCov">         16 :   TMatrixD tmp(paramCovVtx,TMatrixD::kMultTranspose,jacob);</span>
<span class="lineNum">     525 </span><span class="lineCov">         16 :   TMatrixD newParamCov(jacob,TMatrixD::kMult,tmp);</span>
<span class="lineNum">     526 </span>            :   
<span class="lineNum">     527 </span>            :   // Compute covariances at vertex in the (XVtx, SlopeXVtx, YVtx, SlopeYVtx, q/PyzVtx) coordinate system
<span class="lineNum">     528 </span><span class="lineCov">         16 :   CovP2Cov(newParam,newParamCov);</span>
<span class="lineNum">     529 </span>            :   
<span class="lineNum">     530 </span>            :   // Set parameters and covariances at vertex
<span class="lineNum">     531 </span><span class="lineCov">         16 :   param-&gt;SetParameters(newParam);</span>
<span class="lineNum">     532 </span><span class="lineCov">         16 :   param-&gt;SetZ(zVtx);</span>
<span class="lineNum">     533 </span><span class="lineCov">         16 :   param-&gt;SetCovariances(newParamCov);</span>
<span class="lineNum">     534 </span><span class="lineCov">         16 : }</span>
<a name="535"><span class="lineNum">     535 </span>            : </a>
<span class="lineNum">     536 </span>            : //__________________________________________________________________________
<span class="lineNum">     537 </span>            : void AliMUONTrackExtrap::CorrectELossEffectInAbsorber(AliMUONTrackParam* param, Double_t eLoss, Double_t sigmaELoss2)
<span class="lineNum">     538 </span>            : {
<span class="lineNum">     539 </span>            :   /// Correct parameters for energy loss and add energy loss fluctuation effect to covariances
<span class="lineNum">     540 </span>            :   
<span class="lineNum">     541 </span>            :   // Get parameter covariances in (X, SlopeX, Y, SlopeY, q*PTot) coordinate system
<span class="lineNum">     542 </span><span class="lineCov">        128 :   TMatrixD newParamCov(param-&gt;GetCovariances());</span>
<span class="lineNum">     543 </span><span class="lineCov">         64 :   Cov2CovP(param-&gt;GetParameters(),newParamCov);</span>
<span class="lineNum">     544 </span>            :   
<span class="lineNum">     545 </span>            :   // Compute new parameters corrected for energy loss
<span class="lineNum">     546 </span><span class="lineCov">        192 :   Double_t muMass = TDatabasePDG::Instance()-&gt;GetParticle(&quot;mu-&quot;)-&gt;Mass(); // GeV</span>
<span class="lineNum">     547 </span><span class="lineCov">         64 :   Double_t p = param-&gt;P();</span>
<span class="lineNum">     548 </span><span class="lineCov">         64 :   Double_t e = TMath::Sqrt(p*p + muMass*muMass);</span>
<span class="lineNum">     549 </span><span class="lineCov">         64 :   Double_t eCorr = e + eLoss;</span>
<span class="lineNum">     550 </span><span class="lineCov">         64 :   Double_t pCorr = TMath::Sqrt(eCorr*eCorr - muMass*muMass);</span>
<span class="lineNum">     551 </span><span class="lineCov">         64 :   Double_t nonBendingSlope = param-&gt;GetNonBendingSlope();</span>
<span class="lineNum">     552 </span><span class="lineCov">         64 :   Double_t bendingSlope = param-&gt;GetBendingSlope();</span>
<span class="lineNum">     553 </span><span class="lineCov">        256 :   param-&gt;SetInverseBendingMomentum(param-&gt;GetCharge() / pCorr *</span>
<span class="lineNum">     554 </span><span class="lineCov">        128 :                                    TMath::Sqrt(1.0 + nonBendingSlope*nonBendingSlope + bendingSlope*bendingSlope) /</span>
<span class="lineNum">     555 </span><span class="lineCov">         64 :                                    TMath::Sqrt(1.0 + bendingSlope*bendingSlope));</span>
<span class="lineNum">     556 </span>            :   
<span class="lineNum">     557 </span>            :   // Add effects of energy loss fluctuation to covariances
<span class="lineNum">     558 </span><span class="lineCov">        128 :   newParamCov(4,4) += eCorr * eCorr / pCorr / pCorr * sigmaELoss2;</span>
<span class="lineNum">     559 </span>            :   
<span class="lineNum">     560 </span>            :   // Get new parameter covariances in (X, SlopeX, Y, SlopeY, q/Pyz) coordinate system
<span class="lineNum">     561 </span><span class="lineCov">         64 :   CovP2Cov(param-&gt;GetParameters(),newParamCov);</span>
<span class="lineNum">     562 </span>            :   
<span class="lineNum">     563 </span>            :   // Set new parameter covariances
<span class="lineNum">     564 </span><span class="lineCov">         64 :   param-&gt;SetCovariances(newParamCov);</span>
<span class="lineNum">     565 </span><span class="lineCov">         64 : }</span>
<a name="566"><span class="lineNum">     566 </span>            : </a>
<span class="lineNum">     567 </span>            : //__________________________________________________________________________
<span class="lineNum">     568 </span>            : Bool_t AliMUONTrackExtrap::GetAbsorberCorrectionParam(Double_t trackXYZIn[3], Double_t trackXYZOut[3], Double_t pTotal,
<span class="lineNum">     569 </span>            :                                                       Double_t &amp;pathLength, Double_t &amp;f0, Double_t &amp;f1, Double_t &amp;f2,
<span class="lineNum">     570 </span>            :                                                       Double_t &amp;meanRho, Double_t &amp;totalELoss, Double_t &amp;sigmaELoss2)
<span class="lineNum">     571 </span>            : {
<span class="lineNum">     572 </span>            :   /// Parameters used to correct for Multiple Coulomb Scattering and energy loss in absorber
<span class="lineNum">     573 </span>            :   /// Calculated assuming a linear propagation from trackXYZIn to trackXYZOut (order is important)
<span class="lineNum">     574 </span>            :   // pathLength: path length between trackXYZIn and trackXYZOut (cm)
<span class="lineNum">     575 </span>            :   // f0:         0th moment of z calculated with the inverse radiation-length distribution
<span class="lineNum">     576 </span>            :   // f1:         1st moment of z calculated with the inverse radiation-length distribution
<span class="lineNum">     577 </span>            :   // f2:         2nd moment of z calculated with the inverse radiation-length distribution
<span class="lineNum">     578 </span>            :   // meanRho:    average density of crossed material (g/cm3)
<span class="lineNum">     579 </span>            :   // totalELoss: total energy loss in absorber
<span class="lineNum">     580 </span>            :   
<span class="lineNum">     581 </span>            :   // Reset absorber's parameters
<span class="lineNum">     582 </span><span class="lineCov">         64 :   pathLength = 0.;</span>
<span class="lineNum">     583 </span><span class="lineCov">         32 :   f0 = 0.;</span>
<span class="lineNum">     584 </span><span class="lineCov">         32 :   f1 = 0.;</span>
<span class="lineNum">     585 </span><span class="lineCov">         32 :   f2 = 0.;</span>
<span class="lineNum">     586 </span><span class="lineCov">         32 :   meanRho = 0.;</span>
<span class="lineNum">     587 </span><span class="lineCov">         32 :   totalELoss = 0.;</span>
<span class="lineNum">     588 </span><span class="lineCov">         32 :   sigmaELoss2 = 0.;</span>
<span class="lineNum">     589 </span>            :   
<span class="lineNum">     590 </span>            :   // Check whether the geometry is available
<span class="lineNum">     591 </span><span class="lineCov">         32 :   if (!gGeoManager) {</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :     cout&lt;&lt;&quot;E-AliMUONTrackExtrap::GetAbsorberCorrectionParam: no TGeo&quot;&lt;&lt;endl;</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">     594 </span>            :   }
<span class="lineNum">     595 </span>            :   
<span class="lineNum">     596 </span>            :   // Initialize starting point and direction
<span class="lineNum">     597 </span><span class="lineCov">         96 :   pathLength = TMath::Sqrt((trackXYZOut[0] - trackXYZIn[0])*(trackXYZOut[0] - trackXYZIn[0])+</span>
<span class="lineNum">     598 </span><span class="lineCov">         64 :                            (trackXYZOut[1] - trackXYZIn[1])*(trackXYZOut[1] - trackXYZIn[1])+</span>
<span class="lineNum">     599 </span><span class="lineCov">         32 :                            (trackXYZOut[2] - trackXYZIn[2])*(trackXYZOut[2] - trackXYZIn[2]));</span>
<span class="lineNum">     600 </span><span class="lineCov">         32 :   if (pathLength &lt; TGeoShape::Tolerance()) return kFALSE;</span>
<span class="lineNum">     601 </span><span class="lineCov">         32 :   Double_t b[3];</span>
<span class="lineNum">     602 </span><span class="lineCov">         32 :   b[0] = (trackXYZOut[0] - trackXYZIn[0]) / pathLength;</span>
<span class="lineNum">     603 </span><span class="lineCov">         32 :   b[1] = (trackXYZOut[1] - trackXYZIn[1]) / pathLength;</span>
<span class="lineNum">     604 </span><span class="lineCov">         32 :   b[2] = (trackXYZOut[2] - trackXYZIn[2]) / pathLength;</span>
<span class="lineNum">     605 </span><span class="lineCov">         32 :   TGeoNode *currentnode = gGeoManager-&gt;InitTrack(trackXYZIn, b);</span>
<span class="lineNum">     606 </span><span class="lineCov">         32 :   if (!currentnode) {</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :     cout&lt;&lt;&quot;E-AliMUONTrackExtrap::GetAbsorberCorrectionParam: start point out of geometry&quot;&lt;&lt;endl;</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">     609 </span>            :   }
<span class="lineNum">     610 </span>            :   
<span class="lineNum">     611 </span>            :   // loop over absorber slices and calculate absorber's parameters
<span class="lineNum">     612 </span>            :   Double_t rho = 0.; // material density (g/cm3)
<span class="lineNum">     613 </span>            :   Double_t x0 = 0.;  // radiation-length (cm-1)
<span class="lineNum">     614 </span>            :   Double_t atomicA = 0.; // A of material
<span class="lineNum">     615 </span>            :   Double_t atomicZ = 0.; // Z of material
<span class="lineNum">     616 </span>            :   Double_t atomicZoverA = 0.; // Z/A of material
<span class="lineNum">     617 </span>            :   Double_t localPathLength = 0;
<span class="lineNum">     618 </span><span class="lineCov">         32 :   Double_t remainingPathLength = pathLength;</span>
<span class="lineNum">     619 </span>            :   Double_t sigmaELoss = 0.;
<span class="lineNum">     620 </span><span class="lineCov">         32 :   Double_t zB = trackXYZIn[2];</span>
<span class="lineNum">     621 </span>            :   Double_t zE, dzB, dzE;
<span class="lineNum">     622 </span><span class="lineCov">         32 :   do {</span>
<span class="lineNum">     623 </span>            :     // Get material properties
<span class="lineNum">     624 </span><span class="lineCov">        284 :     TGeoMaterial *material = currentnode-&gt;GetVolume()-&gt;GetMedium()-&gt;GetMaterial();</span>
<span class="lineNum">     625 </span><span class="lineCov">        284 :     rho = material-&gt;GetDensity();</span>
<span class="lineNum">     626 </span><span class="lineCov">        284 :     x0 = material-&gt;GetRadLen();</span>
<span class="lineNum">     627 </span><span class="lineCov">        284 :     atomicA = material-&gt;GetA();</span>
<span class="lineNum">     628 </span><span class="lineCov">        284 :     atomicZ = material-&gt;GetZ();</span>
<span class="lineNum">     629 </span><span class="lineCov">        284 :     if(material-&gt;IsMixture()){</span>
<span class="lineNum">     630 </span><span class="lineCov">        186 :       TGeoMixture * mixture = (TGeoMixture*)material;</span>
<span class="lineNum">     631 </span>            :       atomicZoverA = 0.;
<span class="lineNum">     632 </span>            :       Double_t sum = 0.;
<span class="lineNum">     633 </span><span class="lineCov">       2244 :       for (Int_t iel=0;iel&lt;mixture-&gt;GetNelements();iel++){</span>
<span class="lineNum">     634 </span><span class="lineCov">        936 :         sum  += mixture-&gt;GetWmixt()[iel];</span>
<span class="lineNum">     635 </span><span class="lineCov">        936 :         atomicZoverA += mixture-&gt;GetZmixt()[iel]*mixture-&gt;GetWmixt()[iel]/mixture-&gt;GetAmixt()[iel];</span>
<span class="lineNum">     636 </span>            :       }
<span class="lineNum">     637 </span><span class="lineCov">        186 :       atomicZoverA/=sum;</span>
<span class="lineNum">     638 </span><span class="lineCov">        186 :     }</span>
<span class="lineNum">     639 </span><span class="lineCov">         98 :     else atomicZoverA = atomicZ/atomicA;</span>
<span class="lineNum">     640 </span>            :     
<span class="lineNum">     641 </span>            :     // Get path length within this material
<span class="lineNum">     642 </span><span class="lineCov">        284 :     gGeoManager-&gt;FindNextBoundary(remainingPathLength);</span>
<span class="lineNum">     643 </span><span class="lineCov">        284 :     localPathLength = gGeoManager-&gt;GetStep() + 1.e-6;</span>
<span class="lineNum">     644 </span>            :     // Check if boundary within remaining path length. If so, make sure to cross the boundary to prepare the next step
<span class="lineNum">     645 </span><span class="lineCov">        316 :     if (localPathLength &gt;= remainingPathLength) localPathLength = remainingPathLength;</span>
<span class="lineNum">     646 </span>            :     else {
<span class="lineNum">     647 </span><span class="lineCov">        252 :       currentnode = gGeoManager-&gt;Step();</span>
<span class="lineNum">     648 </span><span class="lineCov">        252 :       if (!currentnode) {</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :         cout&lt;&lt;&quot;E-AliMUONTrackExtrap::GetAbsorberCorrectionParam: navigation failed&quot;&lt;&lt;endl;</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :         f0 = f1 = f2 = meanRho = totalELoss = sigmaELoss2 = 0.;</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :         return kFALSE;</span>
<span class="lineNum">     652 </span>            :       }
<span class="lineNum">     653 </span><span class="lineCov">        252 :       if (!gGeoManager-&gt;IsEntering()) {</span>
<span class="lineNum">     654 </span>            :         // make another small step to try to enter in new absorber slice
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :         gGeoManager-&gt;SetStep(0.001);</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :         currentnode = gGeoManager-&gt;Step();</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :         if (!gGeoManager-&gt;IsEntering() || !currentnode) {</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :           cout&lt;&lt;&quot;E-AliMUONTrackExtrap::GetAbsorberCorrectionParam: navigation failed&quot;&lt;&lt;endl;</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :           f0 = f1 = f2 = meanRho = totalELoss = sigmaELoss2 = 0.;</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :           return kFALSE;</span>
<span class="lineNum">     661 </span>            :         }
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :         localPathLength += 0.001;</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     664 </span>            :     }
<span class="lineNum">     665 </span>            :     
<span class="lineNum">     666 </span>            :     // calculate absorber's parameters
<span class="lineNum">     667 </span><span class="lineCov">        284 :     zE = b[2] * localPathLength + zB;</span>
<span class="lineNum">     668 </span><span class="lineCov">        284 :     dzB = zB - trackXYZIn[2];</span>
<span class="lineNum">     669 </span><span class="lineCov">        284 :     dzE = zE - trackXYZIn[2];</span>
<span class="lineNum">     670 </span><span class="lineCov">        284 :     f0 += localPathLength / x0;</span>
<span class="lineNum">     671 </span><span class="lineCov">        284 :     f1 += (dzE*dzE - dzB*dzB) / b[2] / b[2] / x0 / 2.;</span>
<span class="lineNum">     672 </span><span class="lineCov">        284 :     f2 += (dzE*dzE*dzE - dzB*dzB*dzB) / b[2] / b[2] / b[2] / x0 / 3.;</span>
<span class="lineNum">     673 </span><span class="lineCov">        284 :     meanRho += localPathLength * rho;</span>
<span class="lineNum">     674 </span><span class="lineCov">        284 :     totalELoss += BetheBloch(pTotal, localPathLength, rho, atomicZ, atomicZoverA);</span>
<span class="lineNum">     675 </span><span class="lineCov">        284 :     sigmaELoss += EnergyLossFluctuation(pTotal, localPathLength, rho, atomicZoverA);</span>
<span class="lineNum">     676 </span>            :     
<span class="lineNum">     677 </span>            :     // prepare next step
<span class="lineNum">     678 </span>            :     zB = zE;
<span class="lineNum">     679 </span><span class="lineCov">        284 :     remainingPathLength -= localPathLength;</span>
<span class="lineNum">     680 </span><span class="lineCov">        568 :   } while (remainingPathLength &gt; TGeoShape::Tolerance());</span>
<span class="lineNum">     681 </span>            :   
<span class="lineNum">     682 </span><span class="lineCov">         32 :   meanRho /= pathLength;</span>
<span class="lineNum">     683 </span><span class="lineCov">         32 :   sigmaELoss2 = sigmaELoss*sigmaELoss;</span>
<span class="lineNum">     684 </span>            :   
<span class="lineNum">     685 </span><span class="lineCov">         32 :   return kTRUE;</span>
<span class="lineNum">     686 </span><span class="lineCov">         64 : }</span>
<a name="687"><span class="lineNum">     687 </span>            : </a>
<span class="lineNum">     688 </span>            : //__________________________________________________________________________
<span class="lineNum">     689 </span>            : Double_t AliMUONTrackExtrap::GetMCSAngle2(const AliMUONTrackParam&amp; param, Double_t dZ, Double_t x0)
<span class="lineNum">     690 </span>            : {
<span class="lineNum">     691 </span>            :   /// Return the angular dispersion square due to multiple Coulomb scattering
<span class="lineNum">     692 </span>            :   /// through a material of thickness &quot;dZ&quot; and of radiation length &quot;x0&quot;
<span class="lineNum">     693 </span>            :   /// assuming linear propagation and using the small angle approximation.
<span class="lineNum">     694 </span>            :   
<span class="lineNum">     695 </span><span class="lineCov">        860 :   Double_t bendingSlope = param.GetBendingSlope();</span>
<span class="lineNum">     696 </span><span class="lineCov">        430 :   Double_t nonBendingSlope = param.GetNonBendingSlope();</span>
<span class="lineNum">     697 </span><span class="lineCov">        860 :   Double_t inverseTotalMomentum2 = param.GetInverseBendingMomentum() * param.GetInverseBendingMomentum() *</span>
<span class="lineNum">     698 </span><span class="lineCov">        860 :                                    (1.0 + bendingSlope * bendingSlope) /</span>
<span class="lineNum">     699 </span><span class="lineCov">        430 :                                    (1.0 + bendingSlope *bendingSlope + nonBendingSlope * nonBendingSlope); </span>
<span class="lineNum">     700 </span>            :   // Path length in the material
<span class="lineNum">     701 </span><span class="lineCov">        430 :   Double_t pathLength = TMath::Abs(dZ) * TMath::Sqrt(1.0 + bendingSlope*bendingSlope + nonBendingSlope*nonBendingSlope);</span>
<span class="lineNum">     702 </span>            :   // relativistic velocity
<span class="lineNum">     703 </span>            :   Double_t velo = 1.;
<span class="lineNum">     704 </span>            :   // Angular dispersion square of the track (variance) in a plane perpendicular to the trajectory
<span class="lineNum">     705 </span><span class="lineCov">        430 :   Double_t theta02 = 0.0136 / velo * (1 + 0.038 * TMath::Log(pathLength/x0));</span>
<span class="lineNum">     706 </span>            :   
<span class="lineNum">     707 </span><span class="lineCov">        430 :   return theta02 * theta02 * inverseTotalMomentum2 * pathLength / x0;</span>
<span class="lineNum">     708 </span>            : }
<a name="709"><span class="lineNum">     709 </span>            : </a>
<span class="lineNum">     710 </span>            : //__________________________________________________________________________
<span class="lineNum">     711 </span>            : void AliMUONTrackExtrap::AddMCSEffect(AliMUONTrackParam *param, Double_t dZ, Double_t x0)
<span class="lineNum">     712 </span>            : {
<span class="lineNum">     713 </span>            :   /// Add to the track parameter covariances the effects of multiple Coulomb scattering
<span class="lineNum">     714 </span>            :   /// through a material of thickness &quot;Abs(dZ)&quot; and of radiation length &quot;x0&quot;
<span class="lineNum">     715 </span>            :   /// assuming linear propagation and using the small angle approximation.
<span class="lineNum">     716 </span>            :   /// dZ = zOut - zIn (sign is important) and &quot;param&quot; is assumed to be given zOut.
<span class="lineNum">     717 </span>            :   /// If x0 &lt;= 0., assume dZ = pathLength/x0 and consider the material thickness as negligible.
<span class="lineNum">     718 </span>            :   
<span class="lineNum">     719 </span><span class="lineCov">        780 :   Double_t bendingSlope = param-&gt;GetBendingSlope();</span>
<span class="lineNum">     720 </span><span class="lineCov">        390 :   Double_t nonBendingSlope = param-&gt;GetNonBendingSlope();</span>
<span class="lineNum">     721 </span><span class="lineCov">        390 :   Double_t inverseBendingMomentum = param-&gt;GetInverseBendingMomentum();</span>
<span class="lineNum">     722 </span><span class="lineCov">        780 :   Double_t inverseTotalMomentum2 = inverseBendingMomentum * inverseBendingMomentum *</span>
<span class="lineNum">     723 </span><span class="lineCov">        780 :                                    (1.0 + bendingSlope * bendingSlope) /</span>
<span class="lineNum">     724 </span><span class="lineCov">        390 :                                    (1.0 + bendingSlope *bendingSlope + nonBendingSlope * nonBendingSlope); </span>
<span class="lineNum">     725 </span>            :   // Path length in the material
<span class="lineNum">     726 </span><span class="lineCov">        390 :   Double_t signedPathLength = dZ * TMath::Sqrt(1.0 + bendingSlope*bendingSlope + nonBendingSlope*nonBendingSlope);</span>
<span class="lineNum">     727 </span><span class="lineCov">        796 :   Double_t pathLengthOverX0 = (x0 &gt; 0.) ? TMath::Abs(signedPathLength) / x0 : TMath::Abs(signedPathLength);</span>
<span class="lineNum">     728 </span>            :   // relativistic velocity
<span class="lineNum">     729 </span>            :   Double_t velo = 1.;
<span class="lineNum">     730 </span>            :   // Angular dispersion square of the track (variance) in a plane perpendicular to the trajectory
<span class="lineNum">     731 </span><span class="lineCov">        390 :   Double_t theta02 = 0.0136 / velo * (1 + 0.038 * TMath::Log(pathLengthOverX0));</span>
<span class="lineNum">     732 </span><span class="lineCov">        390 :   theta02 *= theta02 * inverseTotalMomentum2 * pathLengthOverX0;</span>
<span class="lineNum">     733 </span>            :   
<span class="lineNum">     734 </span><span class="lineCov">        796 :   Double_t varCoor      = (x0 &gt; 0.) ? signedPathLength * signedPathLength * theta02 / 3. : 0.;</span>
<span class="lineNum">     735 </span>            :   Double_t varSlop      = theta02;
<span class="lineNum">     736 </span><span class="lineCov">        796 :   Double_t covCorrSlope = (x0 &gt; 0.) ? signedPathLength * theta02 / 2. : 0.;</span>
<span class="lineNum">     737 </span>            :   
<span class="lineNum">     738 </span>            :   // Set MCS covariance matrix
<span class="lineNum">     739 </span><span class="lineCov">        390 :   TMatrixD newParamCov(param-&gt;GetCovariances());</span>
<span class="lineNum">     740 </span>            :   // Non bending plane
<span class="lineNum">     741 </span><span class="lineCov">       1170 :   newParamCov(0,0) += varCoor;       newParamCov(0,1) += covCorrSlope;</span>
<span class="lineNum">     742 </span><span class="lineCov">       1170 :   newParamCov(1,0) += covCorrSlope;  newParamCov(1,1) += varSlop;</span>
<span class="lineNum">     743 </span>            :   // Bending plane
<span class="lineNum">     744 </span><span class="lineCov">       1170 :   newParamCov(2,2) += varCoor;       newParamCov(2,3) += covCorrSlope;</span>
<span class="lineNum">     745 </span><span class="lineCov">       1170 :   newParamCov(3,2) += covCorrSlope;  newParamCov(3,3) += varSlop;</span>
<span class="lineNum">     746 </span>            :   
<span class="lineNum">     747 </span>            :   // Set momentum related covariances if B!=0
<span class="lineNum">     748 </span><span class="lineCov">        390 :   if (fgFieldON) {</span>
<span class="lineNum">     749 </span>            :     // compute derivative d(q/Pxy) / dSlopeX and d(q/Pxy) / dSlopeY
<span class="lineNum">     750 </span><span class="lineCov">        390 :     Double_t dqPxydSlopeX = inverseBendingMomentum * nonBendingSlope / (1. + nonBendingSlope*nonBendingSlope + bendingSlope*bendingSlope);</span>
<span class="lineNum">     751 </span><span class="lineCov">        390 :     Double_t dqPxydSlopeY = - inverseBendingMomentum * nonBendingSlope*nonBendingSlope * bendingSlope /</span>
<span class="lineNum">     752 </span><span class="lineCov">        390 :                               (1. + bendingSlope*bendingSlope) / (1. + nonBendingSlope*nonBendingSlope + bendingSlope*bendingSlope);</span>
<span class="lineNum">     753 </span>            :     // Inverse bending momentum (due to dependences with bending and non bending slopes)
<span class="lineNum">     754 </span><span class="lineCov">       1170 :     newParamCov(4,0) += dqPxydSlopeX * covCorrSlope; newParamCov(0,4) += dqPxydSlopeX * covCorrSlope;</span>
<span class="lineNum">     755 </span><span class="lineCov">       1170 :     newParamCov(4,1) += dqPxydSlopeX * varSlop;      newParamCov(1,4) += dqPxydSlopeX * varSlop;</span>
<span class="lineNum">     756 </span><span class="lineCov">       1170 :     newParamCov(4,2) += dqPxydSlopeY * covCorrSlope; newParamCov(2,4) += dqPxydSlopeY * covCorrSlope;</span>
<span class="lineNum">     757 </span><span class="lineCov">       1170 :     newParamCov(4,3) += dqPxydSlopeY * varSlop;      newParamCov(3,4) += dqPxydSlopeY * varSlop;</span>
<span class="lineNum">     758 </span><span class="lineCov">        780 :     newParamCov(4,4) += (dqPxydSlopeX*dqPxydSlopeX + dqPxydSlopeY*dqPxydSlopeY) * varSlop;</span>
<span class="lineNum">     759 </span><span class="lineCov">        390 :   }</span>
<span class="lineNum">     760 </span>            :   
<span class="lineNum">     761 </span>            :   // Set new covariances
<span class="lineNum">     762 </span><span class="lineCov">        390 :   param-&gt;SetCovariances(newParamCov);</span>
<span class="lineNum">     763 </span><span class="lineCov">        390 : }</span>
<a name="764"><span class="lineNum">     764 </span>            : </a>
<span class="lineNum">     765 </span>            : //__________________________________________________________________________
<span class="lineNum">     766 </span>            : void AliMUONTrackExtrap::ExtrapToVertex(AliMUONTrackParam* trackParam,
<span class="lineNum">     767 </span>            :                                         Double_t xVtx, Double_t yVtx, Double_t zVtx,
<span class="lineNum">     768 </span>            :                                         Double_t errXVtx, Double_t errYVtx,
<span class="lineNum">     769 </span>            :                                         Bool_t correctForMCS, Bool_t correctForEnergyLoss)
<span class="lineNum">     770 </span>            : {
<span class="lineNum">     771 </span>            :   /// Main method for extrapolation to the vertex:
<span class="lineNum">     772 </span>            :   /// Returns the track parameters and covariances resulting from the extrapolation of the current trackParam
<span class="lineNum">     773 </span>            :   /// Changes parameters and covariances according to multiple scattering and energy loss corrections:
<span class="lineNum">     774 </span>            :   /// if correctForMCS=kTRUE:  compute parameters using Branson correction and add correction resolution to covariances
<span class="lineNum">     775 </span>            :   /// if correctForMCS=kFALSE: add parameter dispersion due to MCS in parameter covariances
<span class="lineNum">     776 </span>            :   /// if correctForEnergyLoss=kTRUE:  correct parameters for energy loss and add energy loss fluctuation to covariances
<span class="lineNum">     777 </span>            :   /// if correctForEnergyLoss=kFALSE: do nothing about energy loss
<span class="lineNum">     778 </span>            :   
<span class="lineNum">     779 </span><span class="lineCov">         32 :   if (trackParam-&gt;GetZ() == zVtx) return; // nothing to be done if already at vertex</span>
<span class="lineNum">     780 </span>            :   
<span class="lineNum">     781 </span><span class="lineCov">         32 :   if (trackParam-&gt;GetZ() &gt; zVtx) { // spectro. (z&lt;0)</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :     cout&lt;&lt;&quot;E-AliMUONTrackExtrap::ExtrapToVertex: Starting Z (&quot;&lt;&lt;trackParam-&gt;GetZ()</span>
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :         &lt;&lt;&quot;) upstream the vertex (zVtx = &quot;&lt;&lt;zVtx&lt;&lt;&quot;)&quot;&lt;&lt;endl;</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     785 </span>            :   }
<span class="lineNum">     786 </span>            :   
<span class="lineNum">     787 </span>            :   // Check the vertex position relatively to the absorber
<span class="lineNum">     788 </span><span class="lineCov">         32 :   if (zVtx &lt; AliMUONConstants::AbsZBeg() &amp;&amp; zVtx &gt; AliMUONConstants::AbsZEnd()) { // spectro. (z&lt;0)</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :     cout&lt;&lt;&quot;W-AliMUONTrackExtrap::ExtrapToVertex: Ending Z (&quot;&lt;&lt;zVtx</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :         &lt;&lt;&quot;) inside the front absorber (&quot;&lt;&lt;AliMUONConstants::AbsZBeg()&lt;&lt;&quot;,&quot;&lt;&lt;AliMUONConstants::AbsZEnd()&lt;&lt;&quot;)&quot;&lt;&lt;endl;</span>
<span class="lineNum">     791 </span><span class="lineCov">         32 :   } else if (zVtx &lt; AliMUONConstants::AbsZEnd() ) { // spectro. (z&lt;0)</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :     cout&lt;&lt;&quot;W-AliMUONTrackExtrap::ExtrapToVertex: Ending Z (&quot;&lt;&lt;zVtx</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :         &lt;&lt;&quot;) downstream the front absorber (zAbsorberEnd = &quot;&lt;&lt;AliMUONConstants::AbsZEnd()&lt;&lt;&quot;)&quot;&lt;&lt;endl;</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :     if (trackParam-&gt;CovariancesExist()) ExtrapToZCov(trackParam,zVtx);</span>
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :     else ExtrapToZ(trackParam,zVtx);</span>
<span class="lineNum">     796 </span>            :     return;
<span class="lineNum">     797 </span>            :   }
<span class="lineNum">     798 </span>            :   
<span class="lineNum">     799 </span>            :   // Check the track position relatively to the absorber and extrapolate track parameters to the end of the absorber if needed
<span class="lineNum">     800 </span><span class="lineCov">         32 :   if (trackParam-&gt;GetZ() &gt; AliMUONConstants::AbsZBeg()) { // spectro. (z&lt;0)</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :     cout&lt;&lt;&quot;W-AliMUONTrackExtrap::ExtrapToVertex: Starting Z (&quot;&lt;&lt;trackParam-&gt;GetZ()</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :         &lt;&lt;&quot;) upstream the front absorber (zAbsorberBegin = &quot;&lt;&lt;AliMUONConstants::AbsZBeg()&lt;&lt;&quot;)&quot;&lt;&lt;endl;</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :     if (trackParam-&gt;CovariancesExist()) ExtrapToZCov(trackParam,zVtx);</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :     else ExtrapToZ(trackParam,zVtx);</span>
<span class="lineNum">     805 </span>            :     return;
<span class="lineNum">     806 </span><span class="lineCov">         32 :   } else if (trackParam-&gt;GetZ() &gt; AliMUONConstants::AbsZEnd()) { // spectro. (z&lt;0)</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :     cout&lt;&lt;&quot;W-AliMUONTrackExtrap::ExtrapToVertex: Starting Z (&quot;&lt;&lt;trackParam-&gt;GetZ()</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :         &lt;&lt;&quot;) inside the front absorber (&quot;&lt;&lt;AliMUONConstants::AbsZBeg()&lt;&lt;&quot;,&quot;&lt;&lt;AliMUONConstants::AbsZEnd()&lt;&lt;&quot;)&quot;&lt;&lt;endl;</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">     810 </span><span class="lineCov">         64 :     if (trackParam-&gt;CovariancesExist()) ExtrapToZCov(trackParam,AliMUONConstants::AbsZEnd());</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :     else ExtrapToZ(trackParam,AliMUONConstants::AbsZEnd());</span>
<span class="lineNum">     812 </span>            :   }
<span class="lineNum">     813 </span>            :   
<span class="lineNum">     814 </span>            :   // Get absorber correction parameters assuming linear propagation in absorber
<span class="lineNum">     815 </span><span class="lineCov">         32 :   Double_t trackXYZOut[3];</span>
<span class="lineNum">     816 </span><span class="lineCov">         32 :   trackXYZOut[0] = trackParam-&gt;GetNonBendingCoor();</span>
<span class="lineNum">     817 </span><span class="lineCov">         32 :   trackXYZOut[1] = trackParam-&gt;GetBendingCoor();</span>
<span class="lineNum">     818 </span><span class="lineCov">         32 :   trackXYZOut[2] = trackParam-&gt;GetZ();</span>
<span class="lineNum">     819 </span><span class="lineCov">         32 :   Double_t trackXYZIn[3];</span>
<span class="lineNum">     820 </span><span class="lineCov">         32 :   if (correctForMCS) { // assume linear propagation until the vertex</span>
<span class="lineNum">     821 </span><span class="lineCov">         16 :     trackXYZIn[2] = TMath::Min(zVtx, AliMUONConstants::AbsZBeg()); // spectro. (z&lt;0)</span>
<span class="lineNum">     822 </span><span class="lineCov">         16 :     trackXYZIn[0] = trackXYZOut[0] + (xVtx - trackXYZOut[0]) / (zVtx - trackXYZOut[2]) * (trackXYZIn[2] - trackXYZOut[2]);</span>
<span class="lineNum">     823 </span><span class="lineCov">         16 :     trackXYZIn[1] = trackXYZOut[1] + (yVtx - trackXYZOut[1]) / (zVtx - trackXYZOut[2]) * (trackXYZIn[2] - trackXYZOut[2]);</span>
<span class="lineNum">     824 </span><span class="lineCov">         16 :   } else {</span>
<span class="lineNum">     825 </span><span class="lineCov">         16 :     AliMUONTrackParam trackParamIn(*trackParam);</span>
<span class="lineNum">     826 </span><span class="lineCov">         16 :     ExtrapToZ(&amp;trackParamIn, TMath::Min(zVtx, AliMUONConstants::AbsZBeg()));</span>
<span class="lineNum">     827 </span><span class="lineCov">         32 :     trackXYZIn[0] = trackParamIn.GetNonBendingCoor();</span>
<span class="lineNum">     828 </span><span class="lineCov">         32 :     trackXYZIn[1] = trackParamIn.GetBendingCoor();</span>
<span class="lineNum">     829 </span><span class="lineCov">         16 :     trackXYZIn[2] = trackParamIn.GetZ();</span>
<span class="lineNum">     830 </span><span class="lineCov">         16 :   }</span>
<span class="lineNum">     831 </span><span class="lineCov">         32 :   Double_t pTot = trackParam-&gt;P();</span>
<span class="lineNum">     832 </span><span class="lineCov">         32 :   Double_t pathLength, f0, f1, f2, meanRho, totalELoss, sigmaELoss2;</span>
<span class="lineNum">     833 </span><span class="lineCov">         32 :   if (!GetAbsorberCorrectionParam(trackXYZIn,trackXYZOut,pTot,pathLength,f0,f1,f2,meanRho,totalELoss,sigmaELoss2)) {</span>
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :     cout&lt;&lt;&quot;E-AliMUONTrackExtrap::ExtrapToVertex: Unable to take into account the absorber effects&quot;&lt;&lt;endl;</span>
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :     if (trackParam-&gt;CovariancesExist()) ExtrapToZCov(trackParam,zVtx);</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :     else ExtrapToZ(trackParam,zVtx);</span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     838 </span>            :   }
<span class="lineNum">     839 </span>            :   
<span class="lineNum">     840 </span>            :   // Compute track parameters and covariances at vertex according to correctForMCS and correctForEnergyLoss flags
<span class="lineNum">     841 </span><span class="lineCov">         32 :   if (correctForMCS) {</span>
<span class="lineNum">     842 </span>            :     
<span class="lineNum">     843 </span><span class="lineCov">         48 :     if (correctForEnergyLoss) {</span>
<span class="lineNum">     844 </span>            :       
<span class="lineNum">     845 </span>            :       // Correct for multiple scattering and energy loss
<span class="lineNum">     846 </span><span class="lineCov">         16 :       CorrectELossEffectInAbsorber(trackParam, 0.5*totalELoss, 0.5*sigmaELoss2);</span>
<span class="lineNum">     847 </span><span class="lineCov">         16 :       CorrectMCSEffectInAbsorber(trackParam, xVtx, yVtx, zVtx, errXVtx, errYVtx,</span>
<span class="lineNum">     848 </span><span class="lineCov">         16 :                                  trackXYZIn[2], pathLength, f0, f1, f2);</span>
<span class="lineNum">     849 </span><span class="lineCov">         16 :       CorrectELossEffectInAbsorber(trackParam, 0.5*totalELoss, 0.5*sigmaELoss2);</span>
<span class="lineNum">     850 </span>            :       
<span class="lineNum">     851 </span><span class="lineCov">         16 :     } else {</span>
<span class="lineNum">     852 </span>            :       
<span class="lineNum">     853 </span>            :       // Correct for multiple scattering
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :       CorrectMCSEffectInAbsorber(trackParam, xVtx, yVtx, zVtx, errXVtx, errYVtx,</span>
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :                                  trackXYZIn[2], pathLength, f0, f1, f2);</span>
<span class="lineNum">     856 </span>            :     }
<span class="lineNum">     857 </span>            :     
<span class="lineNum">     858 </span>            :   } else {
<span class="lineNum">     859 </span>            :     
<span class="lineNum">     860 </span><span class="lineCov">         16 :     if (correctForEnergyLoss) {</span>
<span class="lineNum">     861 </span>            :       
<span class="lineNum">     862 </span>            :       // Correct for energy loss add multiple scattering dispersion in covariance matrix
<span class="lineNum">     863 </span><span class="lineCov">         16 :       CorrectELossEffectInAbsorber(trackParam, 0.5*totalELoss, 0.5*sigmaELoss2);</span>
<span class="lineNum">     864 </span><span class="lineCov">         16 :       AddMCSEffectInAbsorber(trackParam, -pathLength, f0, f1, f2); // (spectro. (z&lt;0))</span>
<span class="lineNum">     865 </span><span class="lineCov">         16 :       ExtrapToZCov(trackParam, trackXYZIn[2]);</span>
<span class="lineNum">     866 </span><span class="lineCov">         16 :       CorrectELossEffectInAbsorber(trackParam, 0.5*totalELoss, 0.5*sigmaELoss2);</span>
<span class="lineNum">     867 </span><span class="lineCov">         16 :       ExtrapToZCov(trackParam, zVtx);</span>
<span class="lineNum">     868 </span>            :       
<span class="lineNum">     869 </span><span class="lineCov">         16 :     } else {</span>
<span class="lineNum">     870 </span>            :       
<span class="lineNum">     871 </span>            :       // add multiple scattering dispersion in covariance matrix
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :       AddMCSEffectInAbsorber(trackParam, -pathLength, f0, f1, f2); // (spectro. (z&lt;0))</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :       ExtrapToZCov(trackParam, zVtx);</span>
<span class="lineNum">     874 </span>            :       
<span class="lineNum">     875 </span>            :     }
<span class="lineNum">     876 </span>            :     
<span class="lineNum">     877 </span>            :   }
<span class="lineNum">     878 </span>            :   
<span class="lineNum">     879 </span><span class="lineCov">         96 : }</span>
<a name="880"><span class="lineNum">     880 </span>            : </a>
<span class="lineNum">     881 </span>            : //__________________________________________________________________________
<span class="lineNum">     882 </span>            : void AliMUONTrackExtrap::ExtrapToVertex(AliMUONTrackParam* trackParam,
<span class="lineNum">     883 </span>            :                                         Double_t xVtx, Double_t yVtx, Double_t zVtx,
<span class="lineNum">     884 </span>            :                                         Double_t errXVtx, Double_t errYVtx)
<span class="lineNum">     885 </span>            : {
<span class="lineNum">     886 </span>            :   /// Extrapolate track parameters to vertex, corrected for multiple scattering and energy loss effects
<span class="lineNum">     887 </span>            :   /// Add branson correction resolution and energy loss fluctuation to parameter covariances
<span class="lineNum">     888 </span><span class="lineCov">         32 :   ExtrapToVertex(trackParam, xVtx, yVtx, zVtx, errXVtx, errYVtx, kTRUE, kTRUE);</span>
<span class="lineNum">     889 </span><span class="lineCov">         16 : }</span>
<a name="890"><span class="lineNum">     890 </span>            : </a>
<span class="lineNum">     891 </span>            : //__________________________________________________________________________
<span class="lineNum">     892 </span>            : void AliMUONTrackExtrap::ExtrapToVertexWithoutELoss(AliMUONTrackParam* trackParam,
<span class="lineNum">     893 </span>            :                                                     Double_t xVtx, Double_t yVtx, Double_t zVtx,
<span class="lineNum">     894 </span>            :                                                     Double_t errXVtx, Double_t errYVtx)
<span class="lineNum">     895 </span>            : {
<span class="lineNum">     896 </span>            :   /// Extrapolate track parameters to vertex, corrected for multiple scattering effects only
<span class="lineNum">     897 </span>            :   /// Add branson correction resolution to parameter covariances
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :   ExtrapToVertex(trackParam, xVtx, yVtx, zVtx, errXVtx, errYVtx, kTRUE, kFALSE);</span>
<span class="lineNum">     899 </span><span class="lineNoCov">          0 : }</span>
<a name="900"><span class="lineNum">     900 </span>            : </a>
<span class="lineNum">     901 </span>            : //__________________________________________________________________________
<span class="lineNum">     902 </span>            : void AliMUONTrackExtrap::ExtrapToVertexWithoutBranson(AliMUONTrackParam* trackParam, Double_t zVtx)
<span class="lineNum">     903 </span>            : {
<span class="lineNum">     904 </span>            :   /// Extrapolate track parameters to vertex, corrected for energy loss effects only
<span class="lineNum">     905 </span>            :   /// Add dispersion due to multiple scattering and energy loss fluctuation to parameter covariances
<span class="lineNum">     906 </span><span class="lineCov">         32 :   ExtrapToVertex(trackParam, 0., 0., zVtx, 0., 0., kFALSE, kTRUE);</span>
<span class="lineNum">     907 </span><span class="lineCov">         16 : }</span>
<a name="908"><span class="lineNum">     908 </span>            : </a>
<span class="lineNum">     909 </span>            : //__________________________________________________________________________
<span class="lineNum">     910 </span>            : void AliMUONTrackExtrap::ExtrapToVertexUncorrected(AliMUONTrackParam* trackParam, Double_t zVtx)
<span class="lineNum">     911 </span>            : {
<span class="lineNum">     912 </span>            :   /// Extrapolate track parameters to vertex without multiple scattering and energy loss corrections
<span class="lineNum">     913 </span>            :   /// Add dispersion due to multiple scattering to parameter covariances
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :   ExtrapToVertex(trackParam, 0., 0., zVtx, 0., 0., kFALSE, kFALSE);</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 : }</span>
<a name="916"><span class="lineNum">     916 </span>            : </a>
<span class="lineNum">     917 </span>            : //__________________________________________________________________________
<span class="lineNum">     918 </span>            : Double_t AliMUONTrackExtrap::TotalMomentumEnergyLoss(AliMUONTrackParam* trackParam, Double_t xVtx, Double_t yVtx, Double_t zVtx)
<span class="lineNum">     919 </span>            : {
<span class="lineNum">     920 </span>            :   /// Calculate the total momentum energy loss in-between the track position and the vertex assuming a linear propagation
<span class="lineNum">     921 </span>            :   
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :   if (trackParam-&gt;GetZ() == zVtx) return 0.; // nothing to be done if already at vertex</span>
<span class="lineNum">     923 </span>            :   
<span class="lineNum">     924 </span>            :   // Check whether the geometry is available
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :   if (!gGeoManager) {</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :     cout&lt;&lt;&quot;E-AliMUONTrackExtrap::TotalMomentumEnergyLoss: no TGeo&quot;&lt;&lt;endl;</span>
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :     return 0.;</span>
<span class="lineNum">     928 </span>            :   }
<span class="lineNum">     929 </span>            :   
<span class="lineNum">     930 </span>            :   // Get encountered material correction parameters assuming linear propagation from vertex to the track position
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :   Double_t trackXYZOut[3];</span>
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :   trackXYZOut[0] = trackParam-&gt;GetNonBendingCoor();</span>
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :   trackXYZOut[1] = trackParam-&gt;GetBendingCoor();</span>
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :   trackXYZOut[2] = trackParam-&gt;GetZ();</span>
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :   Double_t trackXYZIn[3];</span>
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :   trackXYZIn[0] = xVtx;</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :   trackXYZIn[1] = yVtx;</span>
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :   trackXYZIn[2] = zVtx;</span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :   Double_t pTot = trackParam-&gt;P();</span>
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :   Double_t pathLength, f0, f1, f2, meanRho, totalELoss, sigmaELoss2;</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :   GetAbsorberCorrectionParam(trackXYZIn,trackXYZOut,pTot,pathLength,f0,f1,f2,meanRho,totalELoss,sigmaELoss2);</span>
<span class="lineNum">     942 </span>            :   
<span class="lineNum">     943 </span>            :   // total momentum corrected for energy loss
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :   Double_t muMass = TDatabasePDG::Instance()-&gt;GetParticle(&quot;mu-&quot;)-&gt;Mass(); // GeV</span>
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :   Double_t e = TMath::Sqrt(pTot*pTot + muMass*muMass);</span>
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :   Double_t eCorr = e + totalELoss;</span>
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :   Double_t pTotCorr = TMath::Sqrt(eCorr*eCorr - muMass*muMass);</span>
<span class="lineNum">     948 </span>            :   
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :   return pTotCorr - pTot;</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 : }</span>
<a name="951"><span class="lineNum">     951 </span>            : </a>
<span class="lineNum">     952 </span>            : //__________________________________________________________________________
<span class="lineNum">     953 </span>            : Double_t AliMUONTrackExtrap::BetheBloch(Double_t pTotal, Double_t pathLength, Double_t rho, Double_t atomicZ, Double_t atomicZoverA)
<span class="lineNum">     954 </span>            : {
<span class="lineNum">     955 </span>            :   /// Returns the mean total momentum energy loss of muon with total momentum='pTotal'
<span class="lineNum">     956 </span>            :   /// in the absorber layer of lenght='pathLength', density='rho', A='atomicA' and Z='atomicZ'
<span class="lineNum">     957 </span><span class="lineCov">        568 :   Double_t muMass = TDatabasePDG::Instance()-&gt;GetParticle(&quot;mu-&quot;)-&gt;Mass(); // GeV</span>
<span class="lineNum">     958 </span>            :   
<span class="lineNum">     959 </span>            :   // mean exitation energy (GeV)
<span class="lineNum">     960 </span>            :   Double_t i;
<span class="lineNum">     961 </span><span class="lineCov">        438 :   if (atomicZ &lt; 13) i = (12. * atomicZ + 7.) * 1.e-9;</span>
<span class="lineNum">     962 </span><span class="lineCov">        130 :   else i = (9.76 * atomicZ + 58.8 * TMath::Power(atomicZ,-0.19)) * 1.e-9;</span>
<span class="lineNum">     963 </span>            :   
<span class="lineNum">     964 </span><span class="lineCov">        284 :   return pathLength * rho * AliExternalTrackParam::BetheBlochGeant(pTotal/muMass, rho, 0.20, 3.00, i, atomicZoverA);</span>
<span class="lineNum">     965 </span>            : }
<a name="966"><span class="lineNum">     966 </span>            : </a>
<span class="lineNum">     967 </span>            : //__________________________________________________________________________
<span class="lineNum">     968 </span>            : Double_t AliMUONTrackExtrap::EnergyLossFluctuation(Double_t pTotal, Double_t pathLength, Double_t rho, Double_t atomicZoverA)
<span class="lineNum">     969 </span>            : {
<span class="lineNum">     970 </span>            :   /// Returns the total momentum energy loss fluctuation of muon with total momentum='pTotal'
<span class="lineNum">     971 </span>            :   /// in the absorber layer of lenght='pathLength', density='rho', A='atomicA' and Z='atomicZ'
<span class="lineNum">     972 </span><span class="lineCov">        568 :   Double_t muMass = TDatabasePDG::Instance()-&gt;GetParticle(&quot;mu-&quot;)-&gt;Mass(); // GeV</span>
<span class="lineNum">     973 </span>            :   //Double_t eMass = 0.510998918e-3; // GeV
<span class="lineNum">     974 </span>            :   Double_t k = 0.307075e-3; // GeV.g^-1.cm^2
<span class="lineNum">     975 </span><span class="lineCov">        284 :   Double_t p2=pTotal*pTotal;</span>
<span class="lineNum">     976 </span><span class="lineCov">        284 :   Double_t beta2=p2/(p2 + muMass*muMass);</span>
<span class="lineNum">     977 </span>            :   
<span class="lineNum">     978 </span><span class="lineCov">        284 :   Double_t fwhm = 2. * k * rho * pathLength * atomicZoverA / beta2; // FWHM of the energy loss Landau distribution</span>
<span class="lineNum">     979 </span><span class="lineCov">        284 :   Double_t sigma = fwhm / TMath::Sqrt(8.*log(2.)); // gaussian: fwmh = 2 * srqt(2*ln(2)) * sigma (i.e. fwmh = 2.35 * sigma)</span>
<span class="lineNum">     980 </span>            :   
<span class="lineNum">     981 </span>            :   //sigma2 = k * rho * pathLength * atomicZ / atomicA * eMass; // sigma2 of the energy loss gaussian distribution
<span class="lineNum">     982 </span>            :   
<span class="lineNum">     983 </span><span class="lineCov">        284 :   return sigma;</span>
<span class="lineNum">     984 </span>            : }
<a name="985"><span class="lineNum">     985 </span>            : </a>
<span class="lineNum">     986 </span>            : //__________________________________________________________________________
<span class="lineNum">     987 </span>            : void AliMUONTrackExtrap::Cov2CovP(const TMatrixD &amp;param, TMatrixD &amp;cov)
<span class="lineNum">     988 </span>            : {
<span class="lineNum">     989 </span>            :   /// change coordinate system: (X, SlopeX, Y, SlopeY, q/Pyz) -&gt; (X, SlopeX, Y, SlopeY, q*PTot)
<span class="lineNum">     990 </span>            :   /// parameters (param) are given in the (X, SlopeX, Y, SlopeY, q/Pyz) coordinate system
<span class="lineNum">     991 </span>            :   
<span class="lineNum">     992 </span>            :   // charge * total momentum
<span class="lineNum">     993 </span><span class="lineCov">        240 :   Double_t qPTot = TMath::Sqrt(1. + param(1,0)*param(1,0) + param(3,0)*param(3,0)) /</span>
<span class="lineNum">     994 </span><span class="lineCov">        160 :                    TMath::Sqrt(1. + param(3,0)*param(3,0)) / param(4,0);</span>
<span class="lineNum">     995 </span>            :   
<span class="lineNum">     996 </span>            :   // Jacobian of the opposite transformation
<span class="lineNum">     997 </span><span class="lineCov">         80 :   TMatrixD jacob(5,5);</span>
<span class="lineNum">     998 </span><span class="lineCov">         80 :   jacob.UnitMatrix();</span>
<span class="lineNum">     999 </span><span class="lineCov">        560 :   jacob(4,1) = qPTot * param(1,0) / (1. + param(1,0)*param(1,0) + param(3,0)*param(3,0));</span>
<span class="lineNum">    1000 </span><span class="lineCov">        560 :   jacob(4,3) = - qPTot * param(1,0) * param(1,0) * param(3,0) /</span>
<span class="lineNum">    1001 </span><span class="lineCov">        640 :                  (1. + param(3,0)*param(3,0)) / (1. + param(1,0)*param(1,0) + param(3,0)*param(3,0));</span>
<span class="lineNum">    1002 </span><span class="lineCov">        240 :   jacob(4,4) = - qPTot / param(4,0);</span>
<span class="lineNum">    1003 </span>            :   
<span class="lineNum">    1004 </span>            :   // compute covariances in new coordinate system
<span class="lineNum">    1005 </span><span class="lineCov">         80 :   TMatrixD tmp(cov,TMatrixD::kMultTranspose,jacob);</span>
<span class="lineNum">    1006 </span><span class="lineCov">         80 :   cov.Mult(jacob,tmp);</span>
<span class="lineNum">    1007 </span><span class="lineCov">         80 : }</span>
<a name="1008"><span class="lineNum">    1008 </span>            : </a>
<span class="lineNum">    1009 </span>            : //__________________________________________________________________________
<span class="lineNum">    1010 </span>            : void AliMUONTrackExtrap::CovP2Cov(const TMatrixD &amp;param, TMatrixD &amp;covP)
<span class="lineNum">    1011 </span>            : {
<span class="lineNum">    1012 </span>            :   /// change coordinate system: (X, SlopeX, Y, SlopeY, q*PTot) -&gt; (X, SlopeX, Y, SlopeY, q/Pyz)
<span class="lineNum">    1013 </span>            :   /// parameters (param) are given in the (X, SlopeX, Y, SlopeY, q/Pyz) coordinate system
<span class="lineNum">    1014 </span>            :   
<span class="lineNum">    1015 </span>            :   // charge * total momentum
<span class="lineNum">    1016 </span><span class="lineCov">        240 :   Double_t qPTot = TMath::Sqrt(1. + param(1,0)*param(1,0) + param(3,0)*param(3,0)) /</span>
<span class="lineNum">    1017 </span><span class="lineCov">        160 :                    TMath::Sqrt(1. + param(3,0)*param(3,0)) / param(4,0);</span>
<span class="lineNum">    1018 </span>            :   
<span class="lineNum">    1019 </span>            :   // Jacobian of the transformation
<span class="lineNum">    1020 </span><span class="lineCov">         80 :   TMatrixD jacob(5,5);</span>
<span class="lineNum">    1021 </span><span class="lineCov">         80 :   jacob.UnitMatrix();</span>
<span class="lineNum">    1022 </span><span class="lineCov">        640 :   jacob(4,1) = param(4,0) * param(1,0) / (1. + param(1,0)*param(1,0) + param(3,0)*param(3,0));</span>
<span class="lineNum">    1023 </span><span class="lineCov">        640 :   jacob(4,3) = - param(4,0) * param(1,0) * param(1,0) * param(3,0) /</span>
<span class="lineNum">    1024 </span><span class="lineCov">        640 :                  (1. + param(3,0)*param(3,0)) / (1. + param(1,0)*param(1,0) + param(3,0)*param(3,0));</span>
<span class="lineNum">    1025 </span><span class="lineCov">        240 :   jacob(4,4) = - param(4,0) / qPTot;</span>
<span class="lineNum">    1026 </span>            :   
<span class="lineNum">    1027 </span>            :   // compute covariances in new coordinate system
<span class="lineNum">    1028 </span><span class="lineCov">         80 :   TMatrixD tmp(covP,TMatrixD::kMultTranspose,jacob);</span>
<span class="lineNum">    1029 </span><span class="lineCov">         80 :   covP.Mult(jacob,tmp);</span>
<span class="lineNum">    1030 </span><span class="lineCov">         80 : }</span>
<a name="1031"><span class="lineNum">    1031 </span>            : </a>
<span class="lineNum">    1032 </span>            :  //__________________________________________________________________________
<span class="lineNum">    1033 </span>            : void AliMUONTrackExtrap::ExtrapOneStepHelix(Double_t charge, Double_t step, const Double_t *vect, Double_t *vout)
<span class="lineNum">    1034 </span>            : {
<span class="lineNum">    1035 </span>            : /// &lt;pre&gt;
<span class="lineNum">    1036 </span>            : ///    ******************************************************************
<span class="lineNum">    1037 </span>            : ///    *                                                                *
<span class="lineNum">    1038 </span>            : ///    *  Performs the tracking of one step in a magnetic field         *
<span class="lineNum">    1039 </span>            : ///    *  The trajectory is assumed to be a helix in a constant field   *
<span class="lineNum">    1040 </span>            : ///    *  taken at the mid point of the step.                           *
<span class="lineNum">    1041 </span>            : ///    *  Parameters:                                                   *
<span class="lineNum">    1042 </span>            : ///    *   input                                                        *
<span class="lineNum">    1043 </span>            : ///    *     STEP =arc length of the step asked                         *
<span class="lineNum">    1044 </span>            : ///    *     VECT =input vector (position,direction cos and momentum)   *
<span class="lineNum">    1045 </span>            : ///    *     CHARGE=  electric charge of the particle                   *
<span class="lineNum">    1046 </span>            : ///    *   output                                                       *
<span class="lineNum">    1047 </span>            : ///    *     VOUT = same as VECT after completion of the step           *
<span class="lineNum">    1048 </span>            : ///    *                                                                *
<span class="lineNum">    1049 </span>            : ///    *    ==&gt;Called by : USER, GUSWIM                               *
<span class="lineNum">    1050 </span>            : ///    *       Author    m.hansroul  *********                          *
<span class="lineNum">    1051 </span>            : ///    *       modified  s.egli, s.v.levonian                           *
<span class="lineNum">    1052 </span>            : ///    *       modified  v.perevoztchikov
<span class="lineNum">    1053 </span>            : ///    *                                                                *
<span class="lineNum">    1054 </span>            : ///    ******************************************************************
<span class="lineNum">    1055 </span>            : /// &lt;/pre&gt;
<span class="lineNum">    1056 </span>            : 
<span class="lineNum">    1057 </span>            : // modif: everything in double precision
<span class="lineNum">    1058 </span>            : 
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :     Double_t xyz[3], h[4], hxp[3];</span>
<span class="lineNum">    1060 </span>            :     Double_t h2xy, hp, rho, tet;
<span class="lineNum">    1061 </span>            :     Double_t sint, sintt, tsint, cos1t;
<span class="lineNum">    1062 </span>            :     Double_t f1, f2, f3, f4, f5, f6;
<span class="lineNum">    1063 </span>            : 
<span class="lineNum">    1064 </span>            :     const Int_t kix  = 0;
<span class="lineNum">    1065 </span>            :     const Int_t kiy  = 1;
<span class="lineNum">    1066 </span>            :     const Int_t kiz  = 2;
<span class="lineNum">    1067 </span>            :     const Int_t kipx = 3;
<span class="lineNum">    1068 </span>            :     const Int_t kipy = 4;
<span class="lineNum">    1069 </span>            :     const Int_t kipz = 5;
<span class="lineNum">    1070 </span>            :     const Int_t kipp = 6;
<span class="lineNum">    1071 </span>            : 
<span class="lineNum">    1072 </span>            :     const Double_t kec = 2.9979251e-4;
<span class="lineNum">    1073 </span>            :     //
<span class="lineNum">    1074 </span>            :     //    ------------------------------------------------------------------
<span class="lineNum">    1075 </span>            :     //
<span class="lineNum">    1076 </span>            :     //       units are kgauss,centimeters,gev/c
<span class="lineNum">    1077 </span>            :     //
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :     vout[kipp] = vect[kipp];</span>
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :     if (TMath::Abs(charge) &lt; 0.00001) {</span>
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :       for (Int_t i = 0; i &lt; 3; i++) {</span>
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :         vout[i] = vect[i] + step * vect[i+3];</span>
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :         vout[i+3] = vect[i+3];</span>
<span class="lineNum">    1083 </span>            :       }
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1085 </span>            :     }
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :     xyz[0]    = vect[kix] + 0.5 * step * vect[kipx];</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :     xyz[1]    = vect[kiy] + 0.5 * step * vect[kipy];</span>
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :     xyz[2]    = vect[kiz] + 0.5 * step * vect[kipz];</span>
<span class="lineNum">    1089 </span>            : 
<span class="lineNum">    1090 </span>            :     //cmodif: call gufld (xyz, h) changed into:
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :     TGeoGlobalMagField::Instance()-&gt;Field(xyz,h);</span>
<span class="lineNum">    1092 </span>            :  
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :     h2xy = h[0]*h[0] + h[1]*h[1];</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :     h[3] = h[2]*h[2]+ h2xy;</span>
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :     if (h[3] &lt; 1.e-12) {</span>
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :       for (Int_t i = 0; i &lt; 3; i++) {</span>
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :         vout[i] = vect[i] + step * vect[i+3];</span>
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :         vout[i+3] = vect[i+3];</span>
<span class="lineNum">    1099 </span>            :       }
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1101 </span>            :     }
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :     if (h2xy &lt; 1.e-12*h[3]) {</span>
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :       ExtrapOneStepHelix3(charge*h[2], step, vect, vout);</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1105 </span>            :     }
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :     h[3] = TMath::Sqrt(h[3]);</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :     h[0] /= h[3];</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :     h[1] /= h[3];</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :     h[2] /= h[3];</span>
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :     h[3] *= kec;</span>
<span class="lineNum">    1111 </span>            : 
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :     hxp[0] = h[1]*vect[kipz] - h[2]*vect[kipy];</span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :     hxp[1] = h[2]*vect[kipx] - h[0]*vect[kipz];</span>
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :     hxp[2] = h[0]*vect[kipy] - h[1]*vect[kipx];</span>
<span class="lineNum">    1115 </span>            :  
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :     hp = h[0]*vect[kipx] + h[1]*vect[kipy] + h[2]*vect[kipz];</span>
<span class="lineNum">    1117 </span>            : 
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :     rho = -charge*h[3]/vect[kipp];</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :     tet = rho * step;</span>
<span class="lineNum">    1120 </span>            : 
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :     if (TMath::Abs(tet) &gt; 0.15) {</span>
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :       sint = TMath::Sin(tet);</span>
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :       sintt = (sint/tet);</span>
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :       tsint = (tet-sint)/tet;</span>
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :       cos1t = 2.*(TMath::Sin(0.5*tet))*(TMath::Sin(0.5*tet))/tet;</span>
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :       tsint = tet*tet/36.;</span>
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :       sintt = (1. - tsint);</span>
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :       sint = tet*sintt;</span>
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :       cos1t = 0.5*tet;</span>
<span class="lineNum">    1131 </span>            :     }
<span class="lineNum">    1132 </span>            : 
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :     f1 = step * sintt;</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :     f2 = step * cos1t;</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :     f3 = step * tsint * hp;</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :     f4 = -tet*cos1t;</span>
<span class="lineNum">    1137 </span>            :     f5 = sint;
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :     f6 = tet * cos1t * hp;</span>
<span class="lineNum">    1139 </span>            :  
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :     vout[kix] = vect[kix] + f1*vect[kipx] + f2*hxp[0] + f3*h[0];</span>
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :     vout[kiy] = vect[kiy] + f1*vect[kipy] + f2*hxp[1] + f3*h[1];</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :     vout[kiz] = vect[kiz] + f1*vect[kipz] + f2*hxp[2] + f3*h[2];</span>
<span class="lineNum">    1143 </span>            :  
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :     vout[kipx] = vect[kipx] + f4*vect[kipx] + f5*hxp[0] + f6*h[0];</span>
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :     vout[kipy] = vect[kipy] + f4*vect[kipy] + f5*hxp[1] + f6*h[1];</span>
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :     vout[kipz] = vect[kipz] + f4*vect[kipz] + f5*hxp[2] + f6*h[2];</span>
<span class="lineNum">    1147 </span>            :  
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 : }</span>
<a name="1150"><span class="lineNum">    1150 </span>            : </a>
<span class="lineNum">    1151 </span>            :  //__________________________________________________________________________
<span class="lineNum">    1152 </span>            : void AliMUONTrackExtrap::ExtrapOneStepHelix3(Double_t field, Double_t step, const Double_t *vect, Double_t *vout)
<span class="lineNum">    1153 </span>            : {
<span class="lineNum">    1154 </span>            : /// &lt;pre&gt;
<span class="lineNum">    1155 </span>            : ///     ******************************************************************
<span class="lineNum">    1156 </span>            : ///     *                                                                *
<span class="lineNum">    1157 </span>            : ///     *       Tracking routine in a constant field oriented            *
<span class="lineNum">    1158 </span>            : ///     *       along axis 3                                             *
<span class="lineNum">    1159 </span>            : ///     *       Tracking is performed with a conventional                *
<span class="lineNum">    1160 </span>            : ///     *       helix step method                                        *
<span class="lineNum">    1161 </span>            : ///     *                                                                *
<span class="lineNum">    1162 </span>            : ///     *    ==&gt;Called by : USER, GUSWIM                              *
<span class="lineNum">    1163 </span>            : ///     *       Authors    R.Brun, M.Hansroul  *********                 *
<span class="lineNum">    1164 </span>            : ///     *       Rewritten  V.Perevoztchikov
<span class="lineNum">    1165 </span>            : ///     *                                                                *
<span class="lineNum">    1166 </span>            : ///     ******************************************************************
<span class="lineNum">    1167 </span>            : /// &lt;/pre&gt;
<span class="lineNum">    1168 </span>            : 
<span class="lineNum">    1169 </span>            :     Double_t hxp[3];
<span class="lineNum">    1170 </span>            :     Double_t h4, hp, rho, tet;
<span class="lineNum">    1171 </span>            :     Double_t sint, sintt, tsint, cos1t;
<span class="lineNum">    1172 </span>            :     Double_t f1, f2, f3, f4, f5, f6;
<span class="lineNum">    1173 </span>            : 
<span class="lineNum">    1174 </span>            :     const Int_t kix  = 0;
<span class="lineNum">    1175 </span>            :     const Int_t kiy  = 1;
<span class="lineNum">    1176 </span>            :     const Int_t kiz  = 2;
<span class="lineNum">    1177 </span>            :     const Int_t kipx = 3;
<span class="lineNum">    1178 </span>            :     const Int_t kipy = 4;
<span class="lineNum">    1179 </span>            :     const Int_t kipz = 5;
<span class="lineNum">    1180 </span>            :     const Int_t kipp = 6;
<span class="lineNum">    1181 </span>            : 
<span class="lineNum">    1182 </span>            :     const Double_t kec = 2.9979251e-4;
<span class="lineNum">    1183 </span>            : 
<span class="lineNum">    1184 </span>            : // 
<span class="lineNum">    1185 </span>            : //     ------------------------------------------------------------------
<span class="lineNum">    1186 </span>            : // 
<span class="lineNum">    1187 </span>            : //       units are kgauss,centimeters,gev/c
<span class="lineNum">    1188 </span>            : // 
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :     vout[kipp] = vect[kipp];</span>
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :     h4 = field * kec;</span>
<span class="lineNum">    1191 </span>            : 
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :     hxp[0] = - vect[kipy];</span>
<span class="lineNum">    1193 </span><span class="lineNoCov">          0 :     hxp[1] = + vect[kipx];</span>
<span class="lineNum">    1194 </span>            :  
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :     hp = vect[kipz];</span>
<span class="lineNum">    1196 </span>            : 
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :     rho = -h4/vect[kipp];</span>
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :     tet = rho * step;</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :     if (TMath::Abs(tet) &gt; 0.15) {</span>
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :       sint = TMath::Sin(tet);</span>
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :       sintt = (sint/tet);</span>
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :       tsint = (tet-sint)/tet;</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :       cos1t = 2.* TMath::Sin(0.5*tet) * TMath::Sin(0.5*tet)/tet;</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 :       tsint = tet*tet/36.;</span>
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :       sintt = (1. - tsint);</span>
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :       sint = tet*sintt;</span>
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :       cos1t = 0.5*tet;</span>
<span class="lineNum">    1209 </span>            :     }
<span class="lineNum">    1210 </span>            : 
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :     f1 = step * sintt;</span>
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :     f2 = step * cos1t;</span>
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :     f3 = step * tsint * hp;</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :     f4 = -tet*cos1t;</span>
<span class="lineNum">    1215 </span>            :     f5 = sint;
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :     f6 = tet * cos1t * hp;</span>
<span class="lineNum">    1217 </span>            :  
<span class="lineNum">    1218 </span><span class="lineNoCov">          0 :     vout[kix] = vect[kix] + f1*vect[kipx] + f2*hxp[0];</span>
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :     vout[kiy] = vect[kiy] + f1*vect[kipy] + f2*hxp[1];</span>
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 :     vout[kiz] = vect[kiz] + f1*vect[kipz] + f3;</span>
<span class="lineNum">    1221 </span>            :  
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :     vout[kipx] = vect[kipx] + f4*vect[kipx] + f5*hxp[0];</span>
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :     vout[kipy] = vect[kipy] + f4*vect[kipy] + f5*hxp[1];</span>
<span class="lineNum">    1224 </span><span class="lineNoCov">          0 :     vout[kipz] = vect[kipz] + f4*vect[kipz] + f6;</span>
<span class="lineNum">    1225 </span>            : 
<span class="lineNum">    1226 </span>            :     return;
<span class="lineNum">    1227 </span><span class="lineNoCov">          0 : }</span>
<a name="1228"><span class="lineNum">    1228 </span>            : </a>
<span class="lineNum">    1229 </span>            :  //__________________________________________________________________________
<span class="lineNum">    1230 </span>            : Bool_t AliMUONTrackExtrap::ExtrapOneStepRungekutta(Double_t charge, Double_t step, const Double_t* vect, Double_t* vout)
<span class="lineNum">    1231 </span>            : {
<span class="lineNum">    1232 </span>            : /// &lt;pre&gt;
<span class="lineNum">    1233 </span>            : ///     ******************************************************************
<span class="lineNum">    1234 </span>            : ///     *                                                                *
<span class="lineNum">    1235 </span>            : ///     *  Runge-Kutta method for tracking a particle through a magnetic *
<span class="lineNum">    1236 </span>            : ///     *  field. Uses Nystroem algorithm (See Handbook Nat. Bur. of     *
<span class="lineNum">    1237 </span>            : ///     *  Standards, procedure 25.5.20)                                 *
<span class="lineNum">    1238 </span>            : ///     *                                                                *
<span class="lineNum">    1239 </span>            : ///     *  Input parameters                                              *
<span class="lineNum">    1240 </span>            : ///     *       CHARGE    Particle charge                                *
<span class="lineNum">    1241 </span>            : ///     *       STEP      Step size                                      *
<span class="lineNum">    1242 </span>            : ///     *       VECT      Initial co-ords,direction cosines,momentum     *
<span class="lineNum">    1243 </span>            : ///     *  Output parameters                                             *
<span class="lineNum">    1244 </span>            : ///     *       VOUT      Output co-ords,direction cosines,momentum      *
<span class="lineNum">    1245 </span>            : ///     *  User routine called                                           *
<span class="lineNum">    1246 </span>            : ///     *       CALL GUFLD(X,F)                                          *
<span class="lineNum">    1247 </span>            : ///     *                                                                *
<span class="lineNum">    1248 </span>            : ///     *    ==&gt;Called by : USER, GUSWIM                              *
<span class="lineNum">    1249 </span>            : ///     *       Authors    R.Brun, M.Hansroul  *********                 *
<span class="lineNum">    1250 </span>            : ///     *                  V.Perevoztchikov (CUT STEP implementation)    *
<span class="lineNum">    1251 </span>            : ///     *                                                                *
<span class="lineNum">    1252 </span>            : ///     *                                                                *
<span class="lineNum">    1253 </span>            : ///     ******************************************************************
<span class="lineNum">    1254 </span>            : /// &lt;/pre&gt;
<span class="lineNum">    1255 </span>            : 
<span class="lineNum">    1256 </span><span class="lineCov">      10036 :     Double_t h2, h4, f[4];</span>
<span class="lineNum">    1257 </span><span class="lineCov">       5018 :     Double_t xyzt[3] = {FLT_MAX, FLT_MAX, FLT_MAX};</span>
<span class="lineNum">    1258 </span>            :     Double_t a, b, c, ph,ph2;
<span class="lineNum">    1259 </span>            :     Double_t secxs[4],secys[4],seczs[4],hxp[3];
<span class="lineNum">    1260 </span>            :     Double_t g1, g2, g3, g4, g5, g6, ang2, dxt, dyt, dzt;
<span class="lineNum">    1261 </span>            :     Double_t est, at, bt, ct, cba;
<span class="lineNum">    1262 </span>            :     Double_t f1, f2, f3, f4, rho, tet, hnorm, hp, rho1, sint, cost;
<span class="lineNum">    1263 </span>            :     
<span class="lineNum">    1264 </span>            :     Double_t x;
<span class="lineNum">    1265 </span>            :     Double_t y;
<span class="lineNum">    1266 </span>            :     Double_t z;
<span class="lineNum">    1267 </span>            :     
<span class="lineNum">    1268 </span>            :     Double_t xt;
<span class="lineNum">    1269 </span>            :     Double_t yt;
<span class="lineNum">    1270 </span>            :     Double_t zt;
<span class="lineNum">    1271 </span>            : 
<span class="lineNum">    1272 </span>            :     Double_t maxit = 1992;
<span class="lineNum">    1273 </span>            :     Double_t maxcut = 11;
<span class="lineNum">    1274 </span>            : 
<span class="lineNum">    1275 </span>            :     const Double_t kdlt   = 1e-4;
<span class="lineNum">    1276 </span>            :     const Double_t kdlt32 = kdlt/32.;
<span class="lineNum">    1277 </span>            :     const Double_t kthird = 1./3.;
<span class="lineNum">    1278 </span>            :     const Double_t khalf  = 0.5;
<span class="lineNum">    1279 </span>            :     const Double_t kec = 2.9979251e-4;
<span class="lineNum">    1280 </span>            : 
<span class="lineNum">    1281 </span>            :     const Double_t kpisqua = 9.86960440109;
<span class="lineNum">    1282 </span>            :     const Int_t kix  = 0;
<span class="lineNum">    1283 </span>            :     const Int_t kiy  = 1;
<span class="lineNum">    1284 </span>            :     const Int_t kiz  = 2;
<span class="lineNum">    1285 </span>            :     const Int_t kipx = 3;
<span class="lineNum">    1286 </span>            :     const Int_t kipy = 4;
<span class="lineNum">    1287 </span>            :     const Int_t kipz = 5;
<span class="lineNum">    1288 </span>            :   
<span class="lineNum">    1289 </span>            :     // *.
<span class="lineNum">    1290 </span>            :     // *.    ------------------------------------------------------------------
<span class="lineNum">    1291 </span>            :     // *.
<span class="lineNum">    1292 </span>            :     // *             this constant is for units cm,gev/c and kgauss
<span class="lineNum">    1293 </span>            :     // *
<span class="lineNum">    1294 </span>            :     Int_t iter = 0;
<span class="lineNum">    1295 </span>            :     Int_t ncut = 0;
<span class="lineNum">    1296 </span><span class="lineCov">      80288 :     for(Int_t j = 0; j &lt; 7; j++)</span>
<span class="lineNum">    1297 </span><span class="lineCov">      35126 :       vout[j] = vect[j];</span>
<span class="lineNum">    1298 </span>            : 
<span class="lineNum">    1299 </span><span class="lineCov">       5018 :     Double_t  pinv   = kec * charge / vect[6];</span>
<span class="lineNum">    1300 </span>            :     Double_t tl = 0.;
<span class="lineNum">    1301 </span>            :     Double_t h = step;
<span class="lineNum">    1302 </span>            :     Double_t rest;
<span class="lineNum">    1303 </span>            : 
<span class="lineNum">    1304 </span>            :  
<span class="lineNum">    1305 </span><span class="lineCov">       5018 :     do {</span>
<span class="lineNum">    1306 </span><span class="lineCov">      14316 :       rest  = step - tl;</span>
<span class="lineNum">    1307 </span><span class="lineCov">      14996 :       if (TMath::Abs(h) &gt; TMath::Abs(rest)) h = rest;</span>
<span class="lineNum">    1308 </span>            :       //cmodif: call gufld(vout,f) changed into:
<span class="lineNum">    1309 </span><span class="lineCov">      14316 :       TGeoGlobalMagField::Instance()-&gt;Field(vout,f);</span>
<span class="lineNum">    1310 </span>            : 
<span class="lineNum">    1311 </span>            :       // *
<span class="lineNum">    1312 </span>            :       // *             start of integration
<span class="lineNum">    1313 </span>            :       // *
<span class="lineNum">    1314 </span><span class="lineCov">      14316 :       x      = vout[0];</span>
<span class="lineNum">    1315 </span><span class="lineCov">      14316 :       y      = vout[1];</span>
<span class="lineNum">    1316 </span><span class="lineCov">      14316 :       z      = vout[2];</span>
<span class="lineNum">    1317 </span><span class="lineCov">      14316 :       a      = vout[3];</span>
<span class="lineNum">    1318 </span><span class="lineCov">      14316 :       b      = vout[4];</span>
<span class="lineNum">    1319 </span><span class="lineCov">      14316 :       c      = vout[5];</span>
<span class="lineNum">    1320 </span>            : 
<span class="lineNum">    1321 </span><span class="lineCov">      14316 :       h2     = khalf * h;</span>
<span class="lineNum">    1322 </span><span class="lineCov">      14316 :       h4     = khalf * h2;</span>
<span class="lineNum">    1323 </span><span class="lineCov">      14316 :       ph     = pinv * h;</span>
<span class="lineNum">    1324 </span><span class="lineCov">      14316 :       ph2    = khalf * ph;</span>
<span class="lineNum">    1325 </span><span class="lineCov">      14316 :       secxs[0] = (b * f[2] - c * f[1]) * ph2;</span>
<span class="lineNum">    1326 </span><span class="lineCov">      14316 :       secys[0] = (c * f[0] - a * f[2]) * ph2;</span>
<span class="lineNum">    1327 </span><span class="lineCov">      14316 :       seczs[0] = (a * f[1] - b * f[0]) * ph2;</span>
<span class="lineNum">    1328 </span><span class="lineCov">      14316 :       ang2 = (secxs[0]*secxs[0] + secys[0]*secys[0] + seczs[0]*seczs[0]);</span>
<span class="lineNum">    1329 </span><span class="lineCov">      14316 :       if (ang2 &gt; kpisqua) break;</span>
<span class="lineNum">    1330 </span>            : 
<span class="lineNum">    1331 </span><span class="lineCov">      14316 :       dxt    = h2 * a + h4 * secxs[0];</span>
<span class="lineNum">    1332 </span><span class="lineCov">      14316 :       dyt    = h2 * b + h4 * secys[0];</span>
<span class="lineNum">    1333 </span><span class="lineCov">      14316 :       dzt    = h2 * c + h4 * seczs[0];</span>
<span class="lineNum">    1334 </span><span class="lineCov">      14316 :       xt     = x + dxt;</span>
<span class="lineNum">    1335 </span><span class="lineCov">      14316 :       yt     = y + dyt;</span>
<span class="lineNum">    1336 </span><span class="lineCov">      14316 :       zt     = z + dzt;</span>
<span class="lineNum">    1337 </span>            :       // *
<span class="lineNum">    1338 </span>            :       // *              second intermediate point
<span class="lineNum">    1339 </span>            :       // *
<span class="lineNum">    1340 </span>            : 
<span class="lineNum">    1341 </span><span class="lineCov">      14316 :       est = TMath::Abs(dxt) + TMath::Abs(dyt) + TMath::Abs(dzt);</span>
<span class="lineNum">    1342 </span><span class="lineCov">      14316 :       if (est &gt; h) {</span>
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :         if (ncut++ &gt; maxcut) break;</span>
<span class="lineNum">    1344 </span>            :         h *= khalf;
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    1346 </span>            :       }
<span class="lineNum">    1347 </span>            :  
<span class="lineNum">    1348 </span><span class="lineCov">      14316 :       xyzt[0] = xt;</span>
<span class="lineNum">    1349 </span><span class="lineCov">      14316 :       xyzt[1] = yt;</span>
<span class="lineNum">    1350 </span><span class="lineCov">      14316 :       xyzt[2] = zt;</span>
<span class="lineNum">    1351 </span>            : 
<span class="lineNum">    1352 </span>            :       //cmodif: call gufld(xyzt,f) changed into:
<span class="lineNum">    1353 </span><span class="lineCov">      14316 :       TGeoGlobalMagField::Instance()-&gt;Field(xyzt,f);</span>
<span class="lineNum">    1354 </span>            : 
<span class="lineNum">    1355 </span><span class="lineCov">      14316 :       at     = a + secxs[0];</span>
<span class="lineNum">    1356 </span><span class="lineCov">      14316 :       bt     = b + secys[0];</span>
<span class="lineNum">    1357 </span><span class="lineCov">      14316 :       ct     = c + seczs[0];</span>
<span class="lineNum">    1358 </span>            : 
<span class="lineNum">    1359 </span><span class="lineCov">      14316 :       secxs[1] = (bt * f[2] - ct * f[1]) * ph2;</span>
<span class="lineNum">    1360 </span><span class="lineCov">      14316 :       secys[1] = (ct * f[0] - at * f[2]) * ph2;</span>
<span class="lineNum">    1361 </span><span class="lineCov">      14316 :       seczs[1] = (at * f[1] - bt * f[0]) * ph2;</span>
<span class="lineNum">    1362 </span><span class="lineCov">      14316 :       at     = a + secxs[1];</span>
<span class="lineNum">    1363 </span><span class="lineCov">      14316 :       bt     = b + secys[1];</span>
<span class="lineNum">    1364 </span><span class="lineCov">      14316 :       ct     = c + seczs[1];</span>
<span class="lineNum">    1365 </span><span class="lineCov">      14316 :       secxs[2] = (bt * f[2] - ct * f[1]) * ph2;</span>
<span class="lineNum">    1366 </span><span class="lineCov">      14316 :       secys[2] = (ct * f[0] - at * f[2]) * ph2;</span>
<span class="lineNum">    1367 </span><span class="lineCov">      14316 :       seczs[2] = (at * f[1] - bt * f[0]) * ph2;</span>
<span class="lineNum">    1368 </span><span class="lineCov">      14316 :       dxt    = h * (a + secxs[2]);</span>
<span class="lineNum">    1369 </span><span class="lineCov">      14316 :       dyt    = h * (b + secys[2]);</span>
<span class="lineNum">    1370 </span><span class="lineCov">      14316 :       dzt    = h * (c + seczs[2]);</span>
<span class="lineNum">    1371 </span><span class="lineCov">      14316 :       xt     = x + dxt;</span>
<span class="lineNum">    1372 </span><span class="lineCov">      14316 :       yt     = y + dyt;</span>
<span class="lineNum">    1373 </span><span class="lineCov">      14316 :       zt     = z + dzt;</span>
<span class="lineNum">    1374 </span><span class="lineCov">      14316 :       at     = a + 2.*secxs[2];</span>
<span class="lineNum">    1375 </span><span class="lineCov">      14316 :       bt     = b + 2.*secys[2];</span>
<span class="lineNum">    1376 </span><span class="lineCov">      14316 :       ct     = c + 2.*seczs[2];</span>
<span class="lineNum">    1377 </span>            : 
<span class="lineNum">    1378 </span><span class="lineCov">      14316 :       est = TMath::Abs(dxt)+TMath::Abs(dyt)+TMath::Abs(dzt);</span>
<span class="lineNum">    1379 </span><span class="lineCov">      14316 :       if (est &gt; 2.*TMath::Abs(h)) {</span>
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :         if (ncut++ &gt; maxcut) break;</span>
<span class="lineNum">    1381 </span>            :         h *= khalf;
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    1383 </span>            :       }
<span class="lineNum">    1384 </span>            :  
<span class="lineNum">    1385 </span><span class="lineCov">      14316 :       xyzt[0] = xt;</span>
<span class="lineNum">    1386 </span><span class="lineCov">      14316 :       xyzt[1] = yt;</span>
<span class="lineNum">    1387 </span><span class="lineCov">      14316 :       xyzt[2] = zt;</span>
<span class="lineNum">    1388 </span>            : 
<span class="lineNum">    1389 </span>            :       //cmodif: call gufld(xyzt,f) changed into:
<span class="lineNum">    1390 </span><span class="lineCov">      14316 :       TGeoGlobalMagField::Instance()-&gt;Field(xyzt,f);</span>
<span class="lineNum">    1391 </span>            : 
<span class="lineNum">    1392 </span><span class="lineCov">      14316 :       z      = z + (c + (seczs[0] + seczs[1] + seczs[2]) * kthird) * h;</span>
<span class="lineNum">    1393 </span><span class="lineCov">      14316 :       y      = y + (b + (secys[0] + secys[1] + secys[2]) * kthird) * h;</span>
<span class="lineNum">    1394 </span><span class="lineCov">      14316 :       x      = x + (a + (secxs[0] + secxs[1] + secxs[2]) * kthird) * h;</span>
<span class="lineNum">    1395 </span>            : 
<span class="lineNum">    1396 </span><span class="lineCov">      14316 :       secxs[3] = (bt*f[2] - ct*f[1])* ph2;</span>
<span class="lineNum">    1397 </span><span class="lineCov">      14316 :       secys[3] = (ct*f[0] - at*f[2])* ph2;</span>
<span class="lineNum">    1398 </span><span class="lineCov">      14316 :       seczs[3] = (at*f[1] - bt*f[0])* ph2;</span>
<span class="lineNum">    1399 </span><span class="lineCov">      14316 :       a      = a+(secxs[0]+secxs[3]+2. * (secxs[1]+secxs[2])) * kthird;</span>
<span class="lineNum">    1400 </span><span class="lineCov">      14316 :       b      = b+(secys[0]+secys[3]+2. * (secys[1]+secys[2])) * kthird;</span>
<span class="lineNum">    1401 </span><span class="lineCov">      14316 :       c      = c+(seczs[0]+seczs[3]+2. * (seczs[1]+seczs[2])) * kthird;</span>
<span class="lineNum">    1402 </span>            : 
<span class="lineNum">    1403 </span><span class="lineCov">      14316 :       est    = TMath::Abs(secxs[0]+secxs[3] - (secxs[1]+secxs[2]))</span>
<span class="lineNum">    1404 </span><span class="lineCov">      14316 :         + TMath::Abs(secys[0]+secys[3] - (secys[1]+secys[2]))</span>
<span class="lineNum">    1405 </span><span class="lineCov">      14316 :         + TMath::Abs(seczs[0]+seczs[3] - (seczs[1]+seczs[2]));</span>
<span class="lineNum">    1406 </span>            : 
<span class="lineNum">    1407 </span><span class="lineCov">      17908 :       if (est &gt; kdlt &amp;&amp; TMath::Abs(h) &gt; 1.e-4) {</span>
<span class="lineNum">    1408 </span><span class="lineCov">       3592 :         if (ncut++ &gt; maxcut) break;</span>
<span class="lineNum">    1409 </span>            :         h *= khalf;
<span class="lineNum">    1410 </span><span class="lineCov">       3592 :         continue;</span>
<span class="lineNum">    1411 </span>            :       }
<span class="lineNum">    1412 </span>            : 
<span class="lineNum">    1413 </span>            :       ncut = 0;
<span class="lineNum">    1414 </span>            :       // *               if too many iterations, go to helix
<span class="lineNum">    1415 </span><span class="lineCov">      10724 :       if (iter++ &gt; maxit) break;</span>
<span class="lineNum">    1416 </span>            : 
<span class="lineNum">    1417 </span><span class="lineCov">      10724 :       tl += h;</span>
<span class="lineNum">    1418 </span><span class="lineCov">      10724 :       if (est &lt; kdlt32) </span>
<span class="lineNum">    1419 </span><span class="lineCov">       4150 :         h *= 2.;</span>
<span class="lineNum">    1420 </span><span class="lineCov">      10724 :       cba    = 1./ TMath::Sqrt(a*a + b*b + c*c);</span>
<span class="lineNum">    1421 </span><span class="lineCov">      10724 :       vout[0] = x;</span>
<span class="lineNum">    1422 </span><span class="lineCov">      10724 :       vout[1] = y;</span>
<span class="lineNum">    1423 </span><span class="lineCov">      10724 :       vout[2] = z;</span>
<span class="lineNum">    1424 </span><span class="lineCov">      10724 :       vout[3] = cba*a;</span>
<span class="lineNum">    1425 </span><span class="lineCov">      10724 :       vout[4] = cba*b;</span>
<span class="lineNum">    1426 </span><span class="lineCov">      10724 :       vout[5] = cba*c;</span>
<span class="lineNum">    1427 </span><span class="lineCov">      10724 :       rest = step - tl;</span>
<span class="lineNum">    1428 </span><span class="lineCov">      10724 :       if (step &lt; 0.) rest = -rest;</span>
<span class="lineNum">    1429 </span><span class="lineCov">      15742 :       if (rest &lt; 1.e-5*TMath::Abs(step)) return kTRUE;</span>
<span class="lineNum">    1430 </span>            : 
<span class="lineNum">    1431 </span>            :     } while(1);
<span class="lineNum">    1432 </span>            : 
<span class="lineNum">    1433 </span>            :     // angle too big, use helix
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :     cout&lt;&lt;&quot;W-AliMUONTrackExtrap::ExtrapOneStepRungekutta: Ruge-Kutta failed: switch to helix&quot;&lt;&lt;endl;</span>
<span class="lineNum">    1435 </span>            : 
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :     f1  = f[0];</span>
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :     f2  = f[1];</span>
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :     f3  = f[2];</span>
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :     f4  = TMath::Sqrt(f1*f1+f2*f2+f3*f3);</span>
<span class="lineNum">    1440 </span><span class="lineNoCov">          0 :     if (f4 &lt; 1.e-10) {</span>
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :       cout&lt;&lt;&quot;E-AliMUONTrackExtrap::ExtrapOneStepRungekutta: magnetic field at (&quot;;</span>
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :       cout&lt;&lt;xyzt[0]&lt;&lt;&quot;, &quot;&lt;&lt;xyzt[1]&lt;&lt;&quot;, &quot;&lt;&lt;xyzt[2]&lt;&lt;&quot;) = &quot;&lt;&lt;f4&lt;&lt;&quot;: giving up&quot;&lt;&lt;endl;</span>
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :       return kFALSE;</span>
<span class="lineNum">    1444 </span>            :     }
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :     rho = -f4*pinv;</span>
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :     tet = rho * step;</span>
<span class="lineNum">    1447 </span>            :  
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :     hnorm = 1./f4;</span>
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :     f1 = f1*hnorm;</span>
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :     f2 = f2*hnorm;</span>
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :     f3 = f3*hnorm;</span>
<span class="lineNum">    1452 </span>            : 
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :     hxp[0] = f2*vect[kipz] - f3*vect[kipy];</span>
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :     hxp[1] = f3*vect[kipx] - f1*vect[kipz];</span>
<span class="lineNum">    1455 </span><span class="lineNoCov">          0 :     hxp[2] = f1*vect[kipy] - f2*vect[kipx];</span>
<span class="lineNum">    1456 </span>            :  
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :     hp = f1*vect[kipx] + f2*vect[kipy] + f3*vect[kipz];</span>
<span class="lineNum">    1458 </span>            : 
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 :     rho1 = 1./rho;</span>
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :     sint = TMath::Sin(tet);</span>
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :     cost = 2.*TMath::Sin(khalf*tet)*TMath::Sin(khalf*tet);</span>
<span class="lineNum">    1462 </span>            : 
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :     g1 = sint*rho1;</span>
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 :     g2 = cost*rho1;</span>
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :     g3 = (tet-sint) * hp*rho1;</span>
<span class="lineNum">    1466 </span><span class="lineNoCov">          0 :     g4 = -cost;</span>
<span class="lineNum">    1467 </span>            :     g5 = sint;
<span class="lineNum">    1468 </span><span class="lineNoCov">          0 :     g6 = cost * hp;</span>
<span class="lineNum">    1469 </span>            :  
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :     vout[kix] = vect[kix] + g1*vect[kipx] + g2*hxp[0] + g3*f1;</span>
<span class="lineNum">    1471 </span><span class="lineNoCov">          0 :     vout[kiy] = vect[kiy] + g1*vect[kipy] + g2*hxp[1] + g3*f2;</span>
<span class="lineNum">    1472 </span><span class="lineNoCov">          0 :     vout[kiz] = vect[kiz] + g1*vect[kipz] + g2*hxp[2] + g3*f3;</span>
<span class="lineNum">    1473 </span>            :  
<span class="lineNum">    1474 </span><span class="lineNoCov">          0 :     vout[kipx] = vect[kipx] + g4*vect[kipx] + g5*hxp[0] + g6*f1;</span>
<span class="lineNum">    1475 </span><span class="lineNoCov">          0 :     vout[kipy] = vect[kipy] + g4*vect[kipy] + g5*hxp[1] + g6*f2;</span>
<span class="lineNum">    1476 </span><span class="lineNoCov">          0 :     vout[kipz] = vect[kipz] + g4*vect[kipz] + g5*hxp[2] + g6*f3;</span>
<span class="lineNum">    1477 </span>            : 
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :     return kTRUE;</span>
<span class="lineNum">    1479 </span><span class="lineCov">       5018 : }</span>
<span class="lineNum">    1480 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
