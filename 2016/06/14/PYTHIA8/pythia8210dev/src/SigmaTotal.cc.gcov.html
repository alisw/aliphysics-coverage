<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - PYTHIA8/pythia8210dev/src/SigmaTotal.cc</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">PYTHIA8/pythia8210dev/src</a> - SigmaTotal.cc<span style="font-size: 80%;"> (source / <a href="SigmaTotal.cc.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">300</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">3</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // SigmaTotal.cc is a part of the PYTHIA event generator.</a>
<span class="lineNum">       2 </span>            : // Copyright (C) 2015 Torbjorn Sjostrand.
<span class="lineNum">       3 </span>            : // PYTHIA is licenced under the GNU GPL version 2, see COPYING for details.
<span class="lineNum">       4 </span>            : // Please respect the MCnet Guidelines, see GUIDELINES for details.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : // Function definitions (not found in the header) for the SigmaTotal class.
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : #include &quot;Pythia8/SigmaTotal.h&quot;
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : namespace Pythia8 {
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : //==========================================================================
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : // The SigmaTotal class.
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : // Formulae are taken from:
<span class="lineNum">      17 </span>            : // G.A. Schuler and T. Sjostrand, Phys. Rev. D49 (1994) 2257,
<span class="lineNum">      18 </span>            : //   Z. Phys. C73 (1997) 677
<span class="lineNum">      19 </span>            : // which borrows some total cross sections from
<span class="lineNum">      20 </span>            : // A. Donnachie and P.V. Landshoff, Phys. Lett. B296 (1992) 227.
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : // Implemented processes with their process number iProc:
<span class="lineNum">      23 </span>            : // =  0 : p + p;     =  1 : pbar + p;
<span class="lineNum">      24 </span>            : // =  2 : pi+ + p;   =  3 : pi- + p;     =  4 : pi0/rho0 + p;
<span class="lineNum">      25 </span>            : // =  5 : phi + p;   =  6 : J/psi + p;
<span class="lineNum">      26 </span>            : // =  7 : rho + rho; =  8 : rho + phi;   =  9 : rho + J/psi;
<span class="lineNum">      27 </span>            : // = 10 : phi + phi; = 11 : phi + J/psi; = 12 : J/psi + J/psi.
<span class="lineNum">      28 </span>            : // = 13 : Pom + p (preliminary).
<span class="lineNum">      29 </span>            : // For now a neutron is treated like a proton.
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : // Definitions of static variables.
<span class="lineNum">      34 </span>            : // Note that a lot of parameters are hardcoded as const here, rather
<span class="lineNum">      35 </span>            : // than being interfaced for public change, since any changes would
<span class="lineNum">      36 </span>            : // have to be done in a globally consistent manner. Which basically
<span class="lineNum">      37 </span>            : // means a rewrite/replacement of the whole class.
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : // Minimum threshold below which no cross sections will be defined.
<span class="lineNum">      40 </span>            : const double SigmaTotal::MMIN  = 2.;
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : // General constants in total cross section parametrization:
<span class="lineNum">      43 </span>            : // sigmaTot = X * s^epsilon + Y * s^eta (pomeron + reggeon).
<span class="lineNum">      44 </span>            : const double SigmaTotal::EPSILON = 0.0808;
<span class="lineNum">      45 </span>            : const double SigmaTotal::ETA     = -0.4525;
<span class="lineNum">      46 </span>            : const double SigmaTotal::X[] = { 21.70, 21.70, 13.63, 13.63, 13.63,
<span class="lineNum">      47 </span>            :   10.01, 0.970, 8.56, 6.29, 0.609, 4.62, 0.447, 0.0434};
<span class="lineNum">      48 </span>            : const double SigmaTotal::Y[] = { 56.08, 98.39, 27.56, 36.02, 31.79,
<span class="lineNum">      49 </span>            :   1.51, -0.146, 13.08, -0.62, -0.060, 0.030, -0.0028, 0.00028};
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : // Type of the two incoming hadrons as function of the process number:
<span class="lineNum">      52 </span>            : // = 0 : p/n ; = 1 : pi/rho/omega; = 2 : phi; = 3 : J/psi.
<span class="lineNum">      53 </span>            : const int SigmaTotal::IHADATABLE[] = { 0, 0, 1, 1, 1, 2, 3, 1, 1,
<span class="lineNum">      54 </span>            :   1, 2, 2, 3};
<span class="lineNum">      55 </span>            : const int SigmaTotal::IHADBTABLE[] = { 0, 0, 0, 0, 0, 0, 0, 1, 2,
<span class="lineNum">      56 </span>            :   3, 2, 3, 3};
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : // Hadron-Pomeron coupling beta(t) = beta(0) * exp(b*t).
<span class="lineNum">      59 </span>            : const double SigmaTotal::BETA0[] = { 4.658, 2.926, 2.149, 0.208};
<span class="lineNum">      60 </span>            : const double SigmaTotal::BHAD[]  = {   2.3,   1.4,   1.4,  0.23};
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            : // Pomeron trajectory alpha(t) = 1 + epsilon + alpha' * t
<span class="lineNum">      63 </span>            : const double SigmaTotal::ALPHAPRIME = 0.25;
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            : // Conversion coefficients = 1/(16pi) * (mb &lt;-&gt; GeV^2) * (G_3P)^n,
<span class="lineNum">      66 </span>            : // with n = 0 elastic, n = 1 single and n = 2 double diffractive.
<span class="lineNum">      67 </span>            : const double SigmaTotal::CONVERTEL = 0.0510925;
<span class="lineNum">      68 </span>            : const double SigmaTotal::CONVERTSD = 0.0336;
<span class="lineNum">      69 </span>            : const double SigmaTotal::CONVERTDD = 0.0084;
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span>            : // Diffractive mass spectrum starts at m + MMIN0 and has a low-mass
<span class="lineNum">      72 </span>            : // enhancement, factor cRes, up to around m + mRes0.
<span class="lineNum">      73 </span>            : const double SigmaTotal::MMIN0 = 0.28;
<span class="lineNum">      74 </span>            : const double SigmaTotal::CRES  = 2.0;
<span class="lineNum">      75 </span>            : const double SigmaTotal::MRES0 = 1.062;
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            : // Parameters and coefficients for single diffractive scattering.
<span class="lineNum">      78 </span>            : const int SigmaTotal::ISDTABLE[] = { 0, 0, 1, 1, 1, 2, 3, 4, 5,
<span class="lineNum">      79 </span>            :   6, 7, 8, 9};
<span class="lineNum">      80 </span>            : const double SigmaTotal::CSD[10][8] = {
<span class="lineNum">      81 </span>            :   { 0.213, 0.0, -0.47, 150., 0.213, 0.0, -0.47, 150., } ,
<span class="lineNum">      82 </span>            :   { 0.213, 0.0, -0.47, 150., 0.267, 0.0, -0.47, 100., } ,
<span class="lineNum">      83 </span>            :   { 0.213, 0.0, -0.47, 150., 0.232, 0.0, -0.47, 110., } ,
<span class="lineNum">      84 </span>            :   { 0.213, 7.0, -0.55, 800., 0.115, 0.0, -0.47, 110., } ,
<span class="lineNum">      85 </span>            :   { 0.267, 0.0, -0.46,  75., 0.267, 0.0, -0.46,  75., } ,
<span class="lineNum">      86 </span>            :   { 0.232, 0.0, -0.46,  85., 0.267, 0.0, -0.48, 100., } ,
<span class="lineNum">      87 </span>            :   { 0.115, 0.0, -0.50,  90., 0.267, 6.0, -0.56, 420., } ,
<span class="lineNum">      88 </span>            :   { 0.232, 0.0, -0.48, 110., 0.232, 0.0, -0.48, 110., } ,
<span class="lineNum">      89 </span>            :   { 0.115, 0.0, -0.52, 120., 0.232, 6.0, -0.56, 470., } ,
<span class="lineNum">      90 </span>            :   { 0.115, 5.5, -0.58, 570., 0.115, 5.5, -0.58, 570.  } };
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            : // Parameters and coefficients for double diffractive scattering.
<span class="lineNum">      93 </span>            : const int SigmaTotal::IDDTABLE[] = { 0, 0, 1, 1, 1, 2, 3, 4, 5,
<span class="lineNum">      94 </span>            :   6, 7, 8, 9};
<span class="lineNum">      95 </span>            : const double SigmaTotal::CDD[10][9] = {
<span class="lineNum">      96 </span>            :   { 3.11, -7.34,  9.71, 0.068, -0.42, 1.31, -1.37,  35.0,  118., } ,
<span class="lineNum">      97 </span>            :   { 3.11, -7.10,  10.6, 0.073, -0.41, 1.17, -1.41,  31.6,   95., } ,
<span class="lineNum">      98 </span>            :   { 3.12, -7.43,  9.21, 0.067, -0.44, 1.41, -1.35,  36.5,  132., } ,
<span class="lineNum">      99 </span>            :   { 3.13, -8.18, -4.20, 0.056, -0.71, 3.12, -1.12,  55.2, 1298., } ,
<span class="lineNum">     100 </span>            :   { 3.11, -6.90,  11.4, 0.078, -0.40, 1.05, -1.40,  28.4,   78., } ,
<span class="lineNum">     101 </span>            :   { 3.11, -7.13,  10.0, 0.071, -0.41, 1.23, -1.34,  33.1,  105., } ,
<span class="lineNum">     102 </span>            :   { 3.12, -7.90, -1.49, 0.054, -0.64, 2.72, -1.13,  53.1,  995., } ,
<span class="lineNum">     103 </span>            :   { 3.11, -7.39,  8.22, 0.065, -0.44, 1.45, -1.36,  38.1,  148., } ,
<span class="lineNum">     104 </span>            :   { 3.18, -8.95, -3.37, 0.057, -0.76, 3.32, -1.12,  55.6, 1472., } ,
<span class="lineNum">     105 </span>            :   { 4.18, -29.2,  56.2, 0.074, -1.36, 6.67, -1.14, 116.2, 6532.  } };
<span class="lineNum">     106 </span>            : const double SigmaTotal::SPROTON = 0.880;
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span>            : // MBR parameters. Integration of MBR cross section.
<span class="lineNum">     109 </span>            : const int    SigmaTotal::NINTEG = 1000;
<span class="lineNum">     110 </span>            : const int    SigmaTotal::NINTEG2 = 40;
<span class="lineNum">     111 </span>            : const double SigmaTotal::HBARC2 = 0.38938;
<span class="lineNum">     112 </span>            : // MBR: form factor appoximation with two exponents, [FFB1,FFB2] = GeV^-2.
<span class="lineNum">     113 </span>            : const double SigmaTotal::FFA1 = 0.9;
<span class="lineNum">     114 </span>            : const double SigmaTotal::FFA2 = 0.1;
<span class="lineNum">     115 </span>            : const double SigmaTotal::FFB1 = 4.6;
<span class="lineNum">     116 </span>            : const double SigmaTotal::FFB2 = 0.6;
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     119 </span>            : 
<a name="120"><span class="lineNum">     120 </span>            : // Store pointer to Info and initialize data members.</a>
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            : void SigmaTotal::init(Info* infoPtrIn, Settings&amp; settings,
<span class="lineNum">     123 </span>            :   ParticleData* particleDataPtrIn) {
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span>            :   // Store pointers.
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :   infoPtr         = infoPtrIn;</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :   particleDataPtr = particleDataPtrIn;</span>
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            :   // Normalization of central diffractive cross section.
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :   zeroAXB    = settings.flag(&quot;SigmaTotal:zeroAXB&quot;);</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :   sigAXB2TeV = settings.parm(&quot;SigmaTotal:sigmaAXB2TeV&quot;);</span>
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            :   // User-set values for cross sections.
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :   setTotal   = settings.flag(&quot;SigmaTotal:setOwn&quot;);</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :   sigTotOwn  = settings.parm(&quot;SigmaTotal:sigmaTot&quot;);</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :   sigElOwn   = settings.parm(&quot;SigmaTotal:sigmaEl&quot;);</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :   sigXBOwn   = settings.parm(&quot;SigmaTotal:sigmaXB&quot;);</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :   sigAXOwn   = settings.parm(&quot;SigmaTotal:sigmaAX&quot;);</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :   sigXXOwn   = settings.parm(&quot;SigmaTotal:sigmaXX&quot;);</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :   sigAXBOwn  = settings.parm(&quot;SigmaTotal:sigmaAXB&quot;);</span>
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            :   // User-set values to dampen diffractive cross sections.
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :   doDampen   = settings.flag(&quot;SigmaDiffractive:dampen&quot;);</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :   maxXBOwn   = settings.parm(&quot;SigmaDiffractive:maxXB&quot;);</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :   maxAXOwn   = settings.parm(&quot;SigmaDiffractive:maxAX&quot;);</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :   maxXXOwn   = settings.parm(&quot;SigmaDiffractive:maxXX&quot;);</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :   maxAXBOwn  = settings.parm(&quot;SigmaDiffractive:maxAXB&quot;);</span>
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            :   // User-set values for handling of elastic sacattering.
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :   setElastic = settings.flag(&quot;SigmaElastic:setOwn&quot;);</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :   bSlope     = settings.parm(&quot;SigmaElastic:bSlope&quot;);</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :   rho        = settings.parm(&quot;SigmaElastic:rho&quot;);</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :   lambda     = settings.parm(&quot;SigmaElastic:lambda&quot;);</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :   tAbsMin    = settings.parm(&quot;SigmaElastic:tAbsMin&quot;);</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :   alphaEM0   = settings.parm(&quot;StandardModel:alphaEM0&quot;);</span>
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            :   // Parameters for diffractive systems.
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :   sigmaPomP  = settings.parm(&quot;Diffraction:sigmaRefPomP&quot;);</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :   mPomP      = settings.parm(&quot;Diffraction:mRefPomP&quot;);</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :   pPomP      = settings.parm(&quot;Diffraction:mPowPomP&quot;);</span>
<span class="lineNum">     161 </span>            : 
<span class="lineNum">     162 </span>            :   // Parameters for MBR model.
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :   PomFlux     = settings.mode(&quot;Diffraction:PomFlux&quot;);</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :   MBReps      = settings.parm(&quot;Diffraction:MBRepsilon&quot;);</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :   MBRalpha    = settings.parm(&quot;Diffraction:MBRalpha&quot;);</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :   MBRbeta0    = settings.parm(&quot;Diffraction:MBRbeta0&quot;);</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :   MBRsigma0   = settings.parm(&quot;Diffraction:MBRsigma0&quot;);</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :   m2min       = settings.parm(&quot;Diffraction:MBRm2Min&quot;);</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :   dyminSDflux = settings.parm(&quot;Diffraction:MBRdyminSDflux&quot;);</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :   dyminDDflux = settings.parm(&quot;Diffraction:MBRdyminDDflux&quot;);</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :   dyminCDflux = settings.parm(&quot;Diffraction:MBRdyminCDflux&quot;);</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :   dyminSD     = settings.parm(&quot;Diffraction:MBRdyminSD&quot;);</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :   dyminDD     = settings.parm(&quot;Diffraction:MBRdyminDD&quot;);</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :   dyminCD     = settings.parm(&quot;Diffraction:MBRdyminCD&quot;);</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :   dyminSigSD  = settings.parm(&quot;Diffraction:MBRdyminSigSD&quot;);</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :   dyminSigDD  = settings.parm(&quot;Diffraction:MBRdyminSigDD&quot;);</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :   dyminSigCD  = settings.parm(&quot;Diffraction:MBRdyminSigCD&quot;);</span>
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     182 </span>            : 
<a name="183"><span class="lineNum">     183 </span>            : // Function that calculates the relevant properties.</a>
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            : bool SigmaTotal::calc( int idA, int idB, double eCM) {
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span>            :   // Derived quantities.
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :   alP2 = 2. * ALPHAPRIME;</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :   s0   = 1. / ALPHAPRIME;</span>
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span>            :   // Reset everything to zero to begin with.
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :   isCalc = false;</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :   sigTot = sigEl = sigXB = sigAX = sigXX = sigAXB = sigND = bEl = s</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :     = bA = bB = 0.;</span>
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span>            :   // Order flavour of incoming hadrons: idAbsA &lt; idAbsB (restore later).
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :   int idAbsA = abs(idA);</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :   int idAbsB = abs(idB);</span>
<span class="lineNum">     199 </span>            :   bool swapped = false;
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :   if (idAbsA &gt; idAbsB) {</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :     swap( idAbsA, idAbsB);</span>
<span class="lineNum">     202 </span>            :     swapped = true;
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :   double sameSign = (idA * idB &gt; 0);</span>
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            :   // Find process number.
<span class="lineNum">     207 </span>            :   int iProc                                       = -1;
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :   if (idAbsA &gt; 1000) {</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :     iProc                                         = (sameSign) ? 0 : 1;</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :   } else if (idAbsA &gt; 100 &amp;&amp; idAbsB &gt; 1000) {</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :     iProc                                         = (sameSign) ? 2 : 3;</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :     if (idAbsA/10 == 11 || idAbsA/10 == 22) iProc = 4;</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :     if (idAbsA &gt; 300) iProc                       = 5;</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :     if (idAbsA &gt; 400) iProc                       = 6;</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :     if (idAbsA &gt; 900) iProc                       = 13;</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :   } else if (idAbsA &gt; 100) {</span>
<span class="lineNum">     217 </span>            :     iProc                                         = 7;
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :     if (idAbsB &gt; 300) iProc                       = 8;</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :     if (idAbsB &gt; 400) iProc                       = 9;</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :     if (idAbsA &gt; 300) iProc                       = 10;</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :     if (idAbsA &gt; 300 &amp;&amp; idAbsB &gt; 400) iProc       = 11;</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :     if (idAbsA &gt; 400) iProc                       = 12;</span>
<span class="lineNum">     223 </span>            :   }
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :   if (iProc == -1) return false;</span>
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            :   // Primitive implementation of Pomeron + p.
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :   if (iProc == 13) {</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :     s      = eCM*eCM;</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :     sigTot = sigmaPomP * pow( eCM / mPomP, pPomP);</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     sigND  = sigTot;</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :     isCalc = true;</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     233 </span>            :   }
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            :   // Find hadron masses and check that energy is enough.
<span class="lineNum">     236 </span>            :   // For mesons use the corresponding vector meson masses.
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :   int idModA = (idAbsA &gt; 1000) ? idAbsA : 10 * (idAbsA/10) + 3;</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :   int idModB = (idAbsB &gt; 1000) ? idAbsB : 10 * (idAbsB/10) + 3;</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :   double mA  = particleDataPtr-&gt;m0(idModA);</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :   double mB  = particleDataPtr-&gt;m0(idModB);</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :   if (eCM &lt; mA + mB + MMIN) {</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :     infoPtr-&gt;errorMsg(&quot;Error in SigmaTotal::calc: too low energy&quot;);</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     244 </span>            :   }
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span>            :   // Evaluate the total cross section.
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :   s           = eCM*eCM;</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :   double sEps = pow( s, EPSILON);</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :   double sEta = pow( s, ETA);</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :   sigTot      = X[iProc] * sEps + Y[iProc] * sEta;</span>
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            :   // Slope of hadron form factors.
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :   int iHadA = IHADATABLE[iProc];</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :   int iHadB = IHADBTABLE[iProc];</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :   bA        = BHAD[iHadA];</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :   bB        = BHAD[iHadB];</span>
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            :   // Elastic slope parameter and cross section.
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :   bEl   = 2.*bA + 2.*bB + 4.*sEps - 4.2;</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :   sigEl = CONVERTEL * pow2(sigTot) / bEl;</span>
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            :   // Lookup coefficients for single and double diffraction.
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :   int iSD = ISDTABLE[iProc];</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :   int iDD = IDDTABLE[iProc];</span>
<span class="lineNum">     265 </span>            :   double sum1, sum2, sum3, sum4;
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            :   // Single diffractive scattering A + B -&gt; X + B cross section.
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :   mMinXBsave      = mA + MMIN0;</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :   double sMinXB   = pow2(mMinXBsave);</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :   mResXBsave      = mA + MRES0;</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :   double sResXB   = pow2(mResXBsave);</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :   double sRMavgXB = mResXBsave * mMinXBsave;</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :   double sRMlogXB = log(1. + sResXB/sMinXB);</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :   double sMaxXB   = CSD[iSD][0] * s + CSD[iSD][1];</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :   double BcorrXB  = CSD[iSD][2] + CSD[iSD][3] / s;</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :   sum1  = log( (2.*bB + alP2 * log(s/sMinXB))</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :     / (2.*bB + alP2 * log(s/sMaxXB)) ) / alP2;</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :   sum2  = CRES * sRMlogXB / (2.*bB + alP2 * log(s/sRMavgXB) + BcorrXB) ;</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :   sigXB = CONVERTSD * X[iProc] * BETA0[iHadB] * max( 0., sum1 + sum2);</span>
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span>            :   // Single diffractive scattering A + B -&gt; A + X cross section.
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :   mMinAXsave      = mB + MMIN0;</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :   double sMinAX   = pow2(mMinAXsave);</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :   mResAXsave      = mB + MRES0;</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :   double sResAX   = pow2(mResAXsave);</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :   double sRMavgAX = mResAXsave * mMinAXsave;</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :   double sRMlogAX = log(1. + sResAX/sMinAX);</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :   double sMaxAX   = CSD[iSD][4] * s + CSD[iSD][5];</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :   double BcorrAX  = CSD[iSD][6] + CSD[iSD][7] / s;</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :   sum1  = log( (2.*bA + alP2 * log(s/sMinAX))</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :     / (2.*bA + alP2 * log(s/sMaxAX)) ) / alP2;</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :   sum2  = CRES * sRMlogAX / (2.*bA + alP2 * log(s/sRMavgAX) + BcorrAX) ;</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :   sigAX = CONVERTSD * X[iProc] * BETA0[iHadA] * max( 0., sum1 + sum2);</span>
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span>            :   // Order single diffractive correctly.
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :   if (swapped) {</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :     swap( bB, bA);</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :     swap( sigXB, sigAX);</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :     swap( mMinXBsave, mMinAXsave);</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :     swap( mResXBsave, mResAXsave);</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :    }</span>
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span>            :   // Double diffractive scattering A + B -&gt; X1 + X2 cross section.
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :   double y0min = log( s * SPROTON / (sMinXB * sMinAX) ) ;</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :   double sLog  = log(s);</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :   double Delta0 = CDD[iDD][0] + CDD[iDD][1] / sLog</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :     + CDD[iDD][2] / pow2(sLog);</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :   sum1 = (y0min * (log( max( 1e-10, y0min/Delta0) ) - 1.) + Delta0)/ alP2;</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :   if (y0min &lt; 0.) sum1 = 0.;</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :   double sMaxXX = s * ( CDD[iDD][3] + CDD[iDD][4] / sLog</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :     + CDD[iDD][5] / pow2(sLog) );</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :   double sLogUp = log( max( 1.1, s * s0 / (sMinXB * sRMavgAX) ));</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :   double sLogDn = log( max( 1.1, s * s0 / (sMaxXX * sRMavgAX) ));</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :   sum2   = CRES * log( sLogUp / sLogDn ) * sRMlogAX / alP2;</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :   sLogUp = log( max( 1.1, s * s0 / (sMinAX * sRMavgXB) ));</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :   sLogDn = log( max( 1.1, s * s0 / (sMaxXX * sRMavgXB) ));</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :   sum3   = CRES * log(sLogUp / sLogDn) * sRMlogXB / alP2;</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :   double BcorrXX =  CDD[iDD][6] + CDD[iDD][7] / eCM + CDD[iDD][8] / s;</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :   sum4   = pow2(CRES) * sRMlogAX * sRMlogXB</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :     / max( 0.1, alP2 * log( s * s0 / (sRMavgAX * sRMavgXB) ) + BcorrXX);</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :   sigXX  = CONVERTDD * X[iProc] * max( 0., sum1 + sum2 + sum3 + sum4);</span>
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            :   // Central diffractive scattering A + B -&gt; A + X + B, only p and pbar.
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :   mMinAXBsave = 1.;</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :   if ( (idAbsA == 2212 || idAbsA == 2112)</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :     &amp;&amp; (idAbsB == 2212 || idAbsB == 2112) &amp;&amp; !zeroAXB) {</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :     double sMinAXB = pow2(mMinAXBsave);</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :     double sRefAXB = pow2(2000.);</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :     sigAXB = sigAXB2TeV * pow( log(0.06 * s / sMinAXB), 1.5 )</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :            / pow( log(0.06 * sRefAXB / sMinAXB), 1.5 );</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span>            :   // Option with user-requested damping of diffractive cross sections.
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :   if (doDampen) {</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :     sigXB  = sigXB  * maxXBOwn  / (sigXB  + maxXBOwn);</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :     sigAX  = sigAX  * maxAXOwn  / (sigAX  + maxAXOwn);</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :     sigXX  = sigXX  * maxXXOwn  / (sigXX  + maxXXOwn);</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :     sigAXB = sigAXB * maxAXBOwn / (sigAXB + maxAXBOwn);</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span>            :   // Calculate cross sections in MBR model.
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :   if (PomFlux == 5) calcMBRxsecs(idA, idB, eCM);</span>
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span>            :   // Option with user-set values for total and partial cross sections.
<span class="lineNum">     345 </span>            :   // (Is not done earlier since want diffractive slopes anyway.)
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :   double sigNDOwn = sigTotOwn - sigElOwn - sigXBOwn - sigAXOwn - sigXXOwn</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :                   - sigAXBOwn;</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :   double sigElMax = sigEl;</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :   if (setTotal &amp;&amp; sigNDOwn &gt; 0.) {</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :     sigTot   = sigTotOwn;</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :     sigEl    = sigElOwn;</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :     sigXB    = sigXBOwn;</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :     sigAX    = sigAXOwn;</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :     sigXX    = sigXXOwn;</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :     sigAXB   = sigAXBOwn;</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :     sigElMax = sigEl;</span>
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span>            :     // Sub-option to set elastic parameters, including Coulomb contribution.
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :     if (setElastic) {</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :       bEl      = bSlope;</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :       sigEl    = CONVERTEL * pow2(sigTot) * (1. + rho*rho) / bSlope;</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :       sigElMax = 2. * (sigEl * exp(-bSlope * tAbsMin)</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :                + alphaEM0 * alphaEM0 / (4. * CONVERTEL * tAbsMin) );</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     365 </span>            :   }
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span>            :   // Inelastic nondiffractive by unitarity.
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :   sigND = sigTot - sigEl - sigXB - sigAX - sigXX - sigAXB;</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :   if (sigND &lt; 0.) infoPtr-&gt;errorMsg(&quot;Error in SigmaTotal::init: &quot;</span>
<span class="lineNum">     370 </span>            :     &quot;sigND &lt; 0&quot;);
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :   else if (sigND &lt; 0.4 * sigTot) infoPtr-&gt;errorMsg(&quot;Warning in &quot;</span>
<span class="lineNum">     372 </span>            :     &quot;SigmaTotal::init: sigND suspiciously low&quot;);
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            :   // Upper estimate of elastic, including Coulomb term, where appropriate.
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :   sigEl = sigElMax;</span>
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span>            :   // Done.
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :   isCalc = true;</span>
<span class="lineNum">     379 </span>            :   return true;
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     384 </span>            : 
<a name="385"><span class="lineNum">     385 </span>            : // Calculate parameters in the MBR model.</a>
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span>            : bool SigmaTotal::calcMBRxsecs( int idA, int idB, double eCM) {
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span>            :   // Local variables.
<span class="lineNum">     390 </span>            :   double sigtot, sigel, sigsd, sigdd, sigdpe;
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span>            :   // MBR parameters locally.
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :   double eps       = MBReps;</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :   double alph      = MBRalpha;</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :   double beta0gev  = MBRbeta0;</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :   double beta0mb   = beta0gev * sqrt(HBARC2);</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :   double sigma0mb  = MBRsigma0;</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :   double sigma0gev = sigma0mb/HBARC2;</span>
<span class="lineNum">     399 </span>            :   double a1        = FFA1;
<span class="lineNum">     400 </span>            :   double a2        = FFA2;
<span class="lineNum">     401 </span>            :   double b1        = FFB1;
<span class="lineNum">     402 </span>            :   double b2        = FFB2;
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span>            :   // Calculate total and elastic cross sections.
<span class="lineNum">     405 </span>            :   double ratio;
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :   if (eCM &lt;= 1800.0) {</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :     double sign = (idA * idB &gt; 0);</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :     sigtot = 16.79 * pow(s, 0.104) + 60.81 * pow(s, -0.32)</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :            - sign * 31.68 * pow(s, -0.54);</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :     ratio  = 0.100 * pow(s, 0.06) + 0.421 * pow(s, -0.52)</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :            + sign * 0.160 * pow(s, -0.6);</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">     413 </span>            :     double sigCDF = 80.03;
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :     double sCDF   = pow2(1800.);</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :     double sF     = pow2(22.);</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :     sigtot = sigCDF + ( pow2( log(s / sF)) - pow2( log(sCDF / sF)) )</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :             * M_PI / (3.7 / HBARC2);</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :     ratio  = 0.066 + 0.0119 * log(s);</span>
<span class="lineNum">     419 </span>            :   }
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :   sigel=sigtot*ratio;</span>
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span>            :   // Integrate SD, DD and DPE(CD) cross sections.
<span class="lineNum">     423 </span>            :   // Each cross section is obtained from the ratio of two integrals:
<span class="lineNum">     424 </span>            :   // the Regge cross section and the renormalized flux.
<span class="lineNum">     425 </span>            :   double cflux, csig, c1, step, f;
<span class="lineNum">     426 </span>            :   double dymin0 = 0.;
<span class="lineNum">     427 </span>            : 
<span class="lineNum">     428 </span>            :   // Calculate SD cross section.
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :   double dymaxSD = log(s / m2min);</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :   cflux          = pow2(beta0gev) / (16. * M_PI);</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :   csig           = cflux * sigma0mb;</span>
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span>            :   // SD flux.
<span class="lineNum">     434 </span>            :   c1             = cflux;
<span class="lineNum">     435 </span>            :   double fluxsd  = 0.;
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :   step           = (dymaxSD - dyminSDflux) / NINTEG;</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; NINTEG; ++i) {</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :     double dy    = dyminSDflux + (i + 0.5) * step;</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :     f            = exp(2. * eps * dy) * ( (a1 / (b1 + 2. * alph * dy))</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :                  + (a2 / (b2 + 2. * alph * dy)) );</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :     f           *= 0.5 * (1. + erf( (dy - dyminSD) / dyminSigSD));</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :     fluxsd       = fluxsd + step * c1 * f;</span>
<span class="lineNum">     443 </span>            :   }
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :   if (fluxsd &lt; 1.) fluxsd = 1.;</span>
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            :   // Regge cross section.
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :   c1             = csig * pow(s, eps);</span>
<span class="lineNum">     448 </span>            :   sigsd          = 0.;
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :   sdpmax         = 0.;</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :   step           = (dymaxSD - dymin0) / NINTEG;</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; NINTEG; ++i) {</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :     double dy    = dymin0 + (i + 0.5) * step;</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :     f            = exp(eps * dy) * ( (a1 / (b1 + 2. * alph * dy))</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :                  + (a2 / (b2 + 2. * alph * dy)) );</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :     f           *= 0.5 * (1. + erf( (dy - dyminSD) / dyminSigSD));</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :     if (f &gt; sdpmax) sdpmax = f;</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :     sigsd        = sigsd + step * c1 * f;</span>
<span class="lineNum">     458 </span>            :   }
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :   sdpmax        *= 1.01;</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :   sigsd         /= fluxsd;</span>
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span>            :   // Calculate DD cross section.
<span class="lineNum">     463 </span>            :   // Note: dymaxDD = ln(s * s0 /mMin^4) with s0 = 1 GeV^2.
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :   double dymaxDD = log(s / pow2(m2min));</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :   cflux          = sigma0gev / (16. * M_PI);</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :   csig           = cflux * sigma0mb;</span>
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span>            :   // DD flux.
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :   c1             = cflux / (2. * alph);</span>
<span class="lineNum">     470 </span>            :   double fluxdd  = 0.;
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :   step           = (dymaxDD - dyminDDflux) / NINTEG;</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; NINTEG; ++i) {</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :     double dy    = dyminDDflux + (i + 0.5) * step;</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :     f            = (dymaxDD - dy) * exp(2. * eps * dy)</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :                  * ( exp(-2. * alph * dy * exp(-dy))</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :                  - exp(-2. * alph * dy * exp(dy)) ) / dy;</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :     f           *= 0.5 * (1. + erf( (dy - dyminDD) / dyminSigDD));</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :     fluxdd       = fluxdd + step * c1 * f;</span>
<span class="lineNum">     479 </span>            :   }
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :   if (fluxdd &lt; 1.) fluxdd = 1.;</span>
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span>            :   // Regge cross section.
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :   c1             = csig * pow(s, eps) / (2. * alph);</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :   ddpmax         = 0.;</span>
<span class="lineNum">     485 </span>            :   sigdd          = 0.;
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :   step           = (dymaxDD - dymin0) / NINTEG;</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; NINTEG; ++i) {</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :     double dy    = dymin0 + (i + 0.5) * step;</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :     f            = (dymaxDD - dy) * exp(eps * dy)</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :                  * ( exp(-2. * alph * dy * exp(-dy))</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :                  - exp(-2. * alph * dy * exp(dy)) ) / dy;</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :     f           *= 0.5 * (1. + erf( (dy - dyminDD) / dyminSigDD));</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :     if (f &gt; ddpmax) ddpmax = f;</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :     sigdd        = sigdd + step * c1 * f;</span>
<span class="lineNum">     495 </span>            :   }
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :   ddpmax        *= 1.01;</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :   sigdd         /= fluxdd;</span>
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span>            :   // Calculate DPE (CD) cross section.
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :   double dymaxCD = log(s / m2min);</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :   cflux          = pow4(beta0gev) / pow2(16. * M_PI);</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :   csig           = cflux * pow2(sigma0mb / beta0mb);</span>
<span class="lineNum">     503 </span>            :   double dy1, dy2, f1, f2, step2;
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span>            :   // DPE flux.
<span class="lineNum">     506 </span>            :   c1             = cflux;
<span class="lineNum">     507 </span>            :   double fluxdpe = 0.;
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :   step           = (dymaxCD - dyminCDflux) / NINTEG;</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; NINTEG; ++i) {</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :     double dy    = dyminCDflux + (i + 0.5) * step;</span>
<span class="lineNum">     511 </span>            :     f            = 0.;
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :     step2        = (dy - dyminCDflux) / NINTEG2;</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :     for (int j = 0; j &lt; NINTEG2; ++j) {</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :       double yc  = -0.5 * (dy - dyminCDflux) + (j + 0.5) * step2;</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :       dy1        = 0.5 * dy - yc;</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :       dy2        = 0.5 * dy + yc;</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :       f1         = exp(2. * eps * dy1) * ( (a1 / (b1 + 2. * alph * dy1))</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :                  + (a2 / (b2 + 2. * alph * dy1)) );</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :       f2         = exp(2. * eps * dy2) * ( (a1 / (b1 + 2. * alph * dy2))</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :                  + (a2 / (b2 + 2. * alph * dy2)) );</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :       f1        *= 0.5 * (1. + erf( (dy1 - 0.5 * dyminCD)</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :                  / (dyminSigCD / sqrt(2.))) );</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :       f2        *= 0.5 * (1. + erf( (dy2 - 0.5 *dyminCD)</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :                  / (dyminSigCD / sqrt(2.))) );</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :       f         += f1 * f2 * step2;</span>
<span class="lineNum">     526 </span>            :     }
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :     fluxdpe     += step * c1 * f;</span>
<span class="lineNum">     528 </span>            :   }
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :   if (fluxdpe &lt; 1.) fluxdpe = 1.;</span>
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span>            :   // Regge cross section.
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :   c1             = csig * pow(s, eps);</span>
<span class="lineNum">     533 </span>            :   sigdpe         = 0.;
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :   dpepmax        = 0;</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :   step           = (dymaxCD - dymin0) / NINTEG;</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; NINTEG; ++i) {</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :     double dy    = dymin0 + (i + 0.5) * step;</span>
<span class="lineNum">     538 </span>            :     f            = 0.;
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :     step2        = (dy - dymin0) / NINTEG2;</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :     for (int j = 0; j &lt; NINTEG2; ++j) {</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :       double yc  = -0.5 * (dy - dymin0) + (j + 0.5) * step2;</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :       dy1        = 0.5 * dy - yc;</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :       dy2        = 0.5 * dy + yc;</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :       f1         = exp(eps * dy1) * ( (a1 / (b1 + 2. * alph * dy1))</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :                  + (a2 / (b2 + 2. * alph * dy1)) );</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :       f2         = exp(eps * dy2) * ( (a1 / (b1 + 2. * alph * dy2))</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :                  + (a2 / (b2 + 2. * alph * dy2)) );</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :       f1        *= 0.5 * (1. + erf( (dy1 - 0.5 * dyminCD)</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :                  / (dyminSigCD / sqrt(2.))) );</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :       f2        *= 0.5 * (1. + erf( (dy2 - 0.5 * dyminCD)</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :                  /(dyminSigCD / sqrt(2.))) );</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :       f         += f1 * f2 * step2;</span>
<span class="lineNum">     553 </span>            :     }
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :     sigdpe      += step * c1 * f;</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :     if ( f &gt; dpepmax) dpepmax = f;</span>
<span class="lineNum">     556 </span>            :   }
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :   dpepmax       *= 1.01;</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :   sigdpe        /= fluxdpe;</span>
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span>            :   // Diffraction done. Now calculate total inelastic cross section.
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :   sigND  = sigtot - (2. * sigsd + sigdd + sigel + sigdpe);</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :   sigTot = sigtot;</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :   sigEl  = sigel;</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :   sigAX  = sigsd;</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :   sigXB  = sigsd;</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :   sigXX  = sigdd;</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :   sigAXB = sigdpe;</span>
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span>            : //==========================================================================
<span class="lineNum">     573 </span>            : 
<span class="lineNum">     574 </span>            : } // end namespace Pythia8
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
