<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - PYTHIA8/pythia8210dev/src/BeamRemnants.cc</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">PYTHIA8/pythia8210dev/src</a> - BeamRemnants.cc<span style="font-size: 80%;"> (source / <a href="BeamRemnants.cc.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">616</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">8</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // BeamRemnants.cc is a part of the PYTHIA event generator.</a>
<span class="lineNum">       2 </span>            : // Copyright (C) 2015 Torbjorn Sjostrand.
<span class="lineNum">       3 </span>            : // PYTHIA is licenced under the GNU GPL version 2, see COPYING for details.
<span class="lineNum">       4 </span>            : // Please respect the MCnet Guidelines, see GUIDELINES for details.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : // Function definitions (not found in the header) for the
<span class="lineNum">       7 </span>            : // BeamRemnants class.
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;Pythia8/BeamRemnants.h&quot;
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : namespace Pythia8 {
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : //==========================================================================
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : // The BeamRemnants class.
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : // Constants: could be changed here if desired, but normally should not.
<span class="lineNum">      20 </span>            : // These are of technical nature, as described for each.
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : // If same (anti)colour appears twice in final state, repair or reject.
<span class="lineNum">      23 </span>            : const bool   BeamRemnants::ALLOWCOLOURTWICE = true;
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : // Maximum number of tries to match colours and kinematics in the event.
<span class="lineNum">      26 </span>            : const int    BeamRemnants::NTRYCOLMATCH     = 10;
<span class="lineNum">      27 </span>            : const int    BeamRemnants::NTRYKINMATCH     = 10;
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : // Overall correction step for energy-momentum conservation; only
<span class="lineNum">      30 </span>            : // becomes relevant in rescattering scenarios when FSR dipole emissions
<span class="lineNum">      31 </span>            : // and primordial kT is added. Should hopefully not be needed.
<span class="lineNum">      32 </span>            : const bool   BeamRemnants::CORRECTMISMATCH  = false;
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      35 </span>            : 
<a name="36"><span class="lineNum">      36 </span>            : // Initialization.</a>
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : bool BeamRemnants::init( Info* infoPtrIn, Settings&amp; settings, Rndm* rndmPtrIn,
<span class="lineNum">      39 </span>            :   BeamParticle* beamAPtrIn, BeamParticle* beamBPtrIn,
<span class="lineNum">      40 </span>            :   PartonSystems* partonSystemsPtrIn, ParticleData* particleDataPtrIn,
<span class="lineNum">      41 </span>            :   ColourReconnection* colourReconnectionPtrIn) {
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            :   // Save pointers.
<span class="lineNum">      44 </span><span class="lineNoCov">          0 :   infoPtr               = infoPtrIn;</span>
<span class="lineNum">      45 </span><span class="lineNoCov">          0 :   rndmPtr               = rndmPtrIn;</span>
<span class="lineNum">      46 </span><span class="lineNoCov">          0 :   beamAPtr              = beamAPtrIn;</span>
<span class="lineNum">      47 </span><span class="lineNoCov">          0 :   beamBPtr              = beamBPtrIn;</span>
<span class="lineNum">      48 </span><span class="lineNoCov">          0 :   partonSystemsPtr      = partonSystemsPtrIn;</span>
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :   colourReconnectionPtr = colourReconnectionPtrIn;</span>
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            :   // Width of primordial kT distribution.
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :   doPrimordialKT      = settings.flag(&quot;BeamRemnants:primordialKT&quot;);</span>
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :   primordialKTsoft    = settings.parm(&quot;BeamRemnants:primordialKTsoft&quot;);</span>
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :   primordialKThard    = settings.parm(&quot;BeamRemnants:primordialKThard&quot;);</span>
<span class="lineNum">      55 </span><span class="lineNoCov">          0 :   primordialKTremnant = settings.parm(&quot;BeamRemnants:primordialKTremnant&quot;);</span>
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :   halfScaleForKT      = settings.parm(&quot;BeamRemnants:halfScaleForKT&quot;);</span>
<span class="lineNum">      57 </span><span class="lineNoCov">          0 :   halfMassForKT       = settings.parm(&quot;BeamRemnants:halfMassForKT&quot;);</span>
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :   reducedKTatHighY    = settings.parm(&quot;BeamRemnants:reducedKTatHighY&quot;);</span>
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            :   // Handling of rescattering kinematics uncertainties from primodial kT.
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :   allowRescatter     = settings.flag(&quot;MultipartonInteractions:allowRescatter&quot;);</span>
<span class="lineNum">      62 </span><span class="lineNoCov">          0 :   doRescatterRestoreY = settings.flag(&quot;BeamRemnants:rescatterRestoreY&quot;);</span>
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            :   // Choice of beam remnant and colour reconnection scenarios.
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :   remnantMode         = settings.mode(&quot;BeamRemnants:remnantMode&quot;);</span>
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :   doReconnect         = settings.flag(&quot;ColourReconnection:reconnect&quot;);</span>
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :   reconnectMode       = settings.mode(&quot;ColourReconnection:mode&quot;);</span>
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            :   // Check that remnant model and colour reconnection model work together.
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :   if (remnantMode == 1 &amp;&amp; reconnectMode == 0) {</span>
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :     infoPtr-&gt;errorMsg(&quot;Abort from BeamRemnants::init: The remnant model&quot;</span>
<span class="lineNum">      72 </span>            :       &quot; and colour reconnection model does not work together&quot;);
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">      74 </span>            :   }
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            :   // Total and squared CM energy at nominal energy.
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :   eCM                 = infoPtr-&gt;eCM();</span>
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :   sCM                 = eCM * eCM;</span>
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            :   // Initialize junction splitting class.
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :   junctionSplitting.init(infoPtr, settings, rndmPtr, particleDataPtrIn);</span>
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span>            :   // Done.
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            : // Select the flavours/kinematics/colours of the two beam remnants.
<span class="lineNum">      91 </span>            : // Notation: iPar = all partons, iSys = matched systems of two beams,
<a name="92"><span class="lineNum">      92 </span>            : //           iRem = additional partons in remnants.</a>
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            : bool BeamRemnants::add( Event&amp; event, int iFirst, bool doDiffCR) {
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span>            :   // Update to current CM energy.
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :   eCM     = infoPtr-&gt;eCM();</span>
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :   sCM     = eCM * eCM;</span>
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            :   // Check that flavour bookkept in event and in beam particles agree.
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; beamAPtr-&gt;size(); ++i) {</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :     int j = (*beamAPtr)[i].iPos();</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :     if ((*beamAPtr)[i].id() != event[j].id()) {</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :       infoPtr-&gt;errorMsg(&quot;Error in BeamRemnants::add: &quot;</span>
<span class="lineNum">     105 </span>            :         &quot;event and beam flavours do not match&quot;);
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     107 </span>            :     }
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; beamBPtr-&gt;size(); ++i) {</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :     int j =  (*beamBPtr)[i].iPos();</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :     if ((*beamBPtr)[i].id() != event[j].id()) {</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :       infoPtr-&gt;errorMsg(&quot;Error in BeamRemnants::add: &quot;</span>
<span class="lineNum">     113 </span>            :         &quot;event and beam flavours do not match&quot;);
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     115 </span>            :     }
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span>            :   // Deeply inelastic scattering needs special remnant handling.
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :   isDIS = (beamAPtr-&gt;isLepton() &amp;&amp; !beamBPtr-&gt;isLepton())</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :        || (beamBPtr-&gt;isLepton() &amp;&amp; !beamAPtr-&gt;isLepton());</span>
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            :   // Number of scattering subsystems. Size of event record before treatment.
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :   nSys    = partonSystemsPtr-&gt;sizeSys();</span>
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :   oldSize = event.size();</span>
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            :   // Store event as it was before adding anything.
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :   Event eventSave = event;</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :   BeamParticle beamAsave = (*beamAPtr);</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :   BeamParticle beamBsave = (*beamBPtr);</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :   PartonSystems partonSystemsSave = (*partonSystemsPtr);</span>
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            :   // Two different methods to add the beam remnants.
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :   if (remnantMode == 0) {</span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :     if (!addOld(event)) return false;</span>
<span class="lineNum">     135 </span>            :   } else
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :     if (!addNew(event)) return false;</span>
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :   if (isDIS) return true;</span>
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            :   // Store event before doing colour reconnections.
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :   Event eventTmpSave = event;</span>
<span class="lineNum">     142 </span>            :   bool colCorrect = false;
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; 10; ++i) {</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :     if (doReconnect &amp;&amp; doDiffCR</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :     &amp;&amp; (reconnectMode == 1 || reconnectMode == 2)) {</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :       colourReconnectionPtr-&gt;next(event, iFirst);</span>
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            :       // Check that the new colour structure is physical.
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :       if (!junctionSplitting.checkColours(event))</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :         event = eventTmpSave;</span>
<span class="lineNum">     151 </span>            :       else {
<span class="lineNum">     152 </span>            :         colCorrect = true;
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     154 </span>            :       }
<span class="lineNum">     155 </span>            :       // If no colour reconnection, just check the colour configuration once.
<span class="lineNum">     156 </span>            :     } else {
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :       if (junctionSplitting.checkColours(event))</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :         colCorrect = true;</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     160 </span>            :     }
<span class="lineNum">     161 </span>            :   }
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            :   // Restore event and return false if colour reconnection failed.
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :   if (!colCorrect) {</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :     event = eventSave;</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :     (*beamAPtr) = beamAsave;</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :     (*beamBPtr) = beamBsave;</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :     (*partonSystemsPtr) = partonSystemsSave;</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :     infoPtr-&gt;errorMsg(&quot;Error in BeamRemnants::Add: &quot;</span>
<span class="lineNum">     170 </span>            :       &quot;failed to find physical colour state after colour reconnection&quot;);
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     172 </span>            :   }
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span>            :   // Done.
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     179 </span>            : 
<a name="180"><span class="lineNum">     180 </span>            : // Old function for adding beam remnant.</a>
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            : bool BeamRemnants::addOld( Event&amp; event) {
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            :   // Add required extra remnant flavour content.
<span class="lineNum">     185 </span>            :   // Start all over if fails (in option where junctions not allowed).
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :   if ( !beamAPtr-&gt;remnantFlavours(event, isDIS)</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :     || !beamBPtr-&gt;remnantFlavours(event, isDIS) ) {</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :     infoPtr-&gt;errorMsg(&quot;Error in BeamRemnants::add:&quot;</span>
<span class="lineNum">     189 </span>            :       &quot; remnant flavour setup failed&quot;);
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     191 </span>            :   }
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            :   // Do the kinematics of the collision subsystems and two beam remnants.
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :   if (!setKinematics(event)) return false;</span>
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span>            :   // Allow colour reconnections.
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :   if (doReconnect &amp;&amp; reconnectMode == 0 &amp;&amp; !isDIS)</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :     colourReconnectionPtr-&gt;next(event, oldSize);</span>
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span>            :   // Save current modifiable colour configuration for fast restoration.
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :   vector&lt;int&gt; colSave;</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :   vector&lt;int&gt; acolSave;</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :   for (int i = oldSize; i &lt; event.size(); ++i) {</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :     colSave.push_back( event[i].col() );</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :     acolSave.push_back( event[i].acol() );</span>
<span class="lineNum">     206 </span>            :   }
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :   event.saveJunctionSize();</span>
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span>            :   // Allow several tries to match colours of initiators and remnants.
<span class="lineNum">     210 </span>            :   // Frequent &quot;failures&quot; since shortcutting colours separately on
<span class="lineNum">     211 </span>            :   // the two event sides may give &quot;colour singlet gluons&quot; etc.
<span class="lineNum">     212 </span>            :   bool physical = true;
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :   for (int iTry = 0; iTry &lt; NTRYCOLMATCH; ++iTry) {</span>
<span class="lineNum">     214 </span>            :     physical = true;
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span>            :     // Reset list of colour &quot;collapses&quot; (transformations).
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :     colFrom.resize(0);</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :     colTo.resize(0);</span>
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            :     // First process each set of beam colours on its own.
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :     if (!beamAPtr-&gt;remnantColours(event, colFrom, colTo))</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :       physical = false;</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :     if (!beamBPtr-&gt;remnantColours(event, colFrom, colTo))</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :       physical = false;</span>
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            :     // Then check that colours and anticolours are matched in whole event.
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :     if ( physical &amp;&amp; !checkColours(event) ) physical = false;</span>
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span>            :     // If no problems then done, else restore and loop.
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     if (physical) break;</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :     for (int i = oldSize; i &lt; event.size(); ++i)</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :       event[i].cols( colSave[i - oldSize], acolSave[i - oldSize] );</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :     event.restoreJunctionSize();</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :     infoPtr-&gt;errorMsg(&quot;Warning in BeamRemnants::add:&quot;</span>
<span class="lineNum">     235 </span>            :       &quot; colour tracing failed; will try again&quot;);
<span class="lineNum">     236 </span>            :   }
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span>            :   // If no solution after several tries then failed.
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :   if (!physical) {</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :     infoPtr-&gt;errorMsg(&quot;Error in BeamRemnants::add:&quot;</span>
<span class="lineNum">     241 </span>            :       &quot; colour tracing failed after several attempts&quot;);
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     243 </span>            :   }
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            :   // Done.
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     250 </span>            : 
<a name="251"><span class="lineNum">     251 </span>            : // New function for adding beam remnant.</a>
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span>            : bool BeamRemnants::addNew( Event&amp; event) {
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            :    // Start by saving a copy of the event, if the beam remnant fails.
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :   Event eventSave = event;</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :   BeamParticle beamAsave = (*beamAPtr);</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :   BeamParticle beamBsave = (*beamBPtr);</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :   PartonSystems partonSystemsSave = (*partonSystemsPtr);</span>
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span>            :   // Do several tries in case an unphysical colour contruction is made.
<span class="lineNum">     262 </span>            :   bool beamRemnantFound = false;
<span class="lineNum">     263 </span>            :   int nMaxTries = 10;
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :   for (int iTries = 0;iTries &lt; nMaxTries; ++iTries) {</span>
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            :     // Set the initial colours.
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :     beamAPtr-&gt;setInitialCol(event);</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :     beamBPtr-&gt;setInitialCol(event);</span>
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            :     // Find colour state of outgoing partons and reconnect colours to match it.
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :     beamAPtr-&gt;findColSetup(event);</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :     beamBPtr-&gt;updateCol(beamAPtr-&gt;getColUpdates());</span>
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :     beamBPtr-&gt;findColSetup(event);</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :     beamAPtr-&gt;updateCol(beamBPtr-&gt;getColUpdates());</span>
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span>            :     // Add beam remnants.
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :     beamAPtr-&gt;remnantFlavoursNew(event);</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :     beamBPtr-&gt;remnantFlavoursNew(event);</span>
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span>            :     // It is possible junctions were added, so update list.
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :     event.saveJunctionSize();</span>
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            :     // Do the kinematics of the collision subsystems and two beam remnants.
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :     if (!setKinematics(event)) {</span>
<span class="lineNum">     287 </span>            :       // If it does not work, try parton level again.
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :       event = eventSave;</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :       (*beamAPtr) = beamAsave;</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :       (*beamBPtr) = beamBsave;</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :       (*partonSystemsPtr) = partonSystemsSave;</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     293 </span>            :     }
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span>            :     // Update the colour changes for all final state particles.
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :     updateColEvent(event, beamAPtr-&gt;getColUpdates());</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :     updateColEvent(event, beamBPtr-&gt;getColUpdates());</span>
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            :     // Check whether the new colour structure can be accepted.
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :     if (junctionSplitting.checkColours(event)) {</span>
<span class="lineNum">     301 </span>            :       beamRemnantFound = true;
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     303 </span>            :     }
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span>            :     // If failed, restore earlier configuration and try to find new
<span class="lineNum">     306 </span>            :     // colour structure.
<span class="lineNum">     307 </span>            :     else {
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :       event = eventSave;</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :       (*beamAPtr) = beamAsave;</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :       (*beamBPtr) = beamBsave;</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :       (*partonSystemsPtr) = partonSystemsSave;</span>
<span class="lineNum">     312 </span>            :     }
<span class="lineNum">     313 </span>            :   }
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span>            :   // Return if it was not possible to find physical colour structure.
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :   if (!beamRemnantFound) {</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :     infoPtr-&gt;errorMsg(&quot;Error in BeamRemnants::add: &quot;</span>
<span class="lineNum">     318 </span>            :         &quot;failed to find physical colour structure&quot;);
<span class="lineNum">     319 </span>            :     // Restore event to previous state.
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :     event = eventSave;</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :     (*beamAPtr) = beamAsave;</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :     (*beamBPtr) = beamBsave;</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :     (*partonSystemsPtr) = partonSystemsSave;</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     325 </span>            :   }
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            :   // Done.
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span>            : // Set up trial transverse and longitudinal kinematics for each beam
<a name="334"><span class="lineNum">     334 </span>            : // separately. Final decisions involve comparing the two beams.</a>
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            : bool BeamRemnants::setKinematics( Event&amp; event) {
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span>            :   // References to beams to simplify indexing.
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :   BeamParticle&amp; beamA = *beamAPtr;</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :   BeamParticle&amp; beamB = *beamBPtr;</span>
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            :   // Nothing to do for lepton-lepton scattering with all energy already used.
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :   if ( beamA.isUnresolvedLepton() &amp;&amp; beamB.isUnresolvedLepton() )</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span>            :   // Check that has not already used up beams.
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :   if ( (!beamA.isLepton() &amp;&amp; beamA.xMax(-1) &lt;= 0.)</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :     || (!beamB.isLepton() &amp;&amp; beamB.xMax(-1) &lt;= 0.) ) {</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :     infoPtr-&gt;errorMsg(&quot;Error in BeamRemnants::setKinematics:&quot;</span>
<span class="lineNum">     350 </span>            :       &quot; no momentum left for beam remnants&quot;);
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     352 </span>            :   }
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            :   // Special kinematics setup for DIS.
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :   if (isDIS) return setDISKinematics(event);</span>
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span>            :   // Last beam-status particles. Offset relative to normal beam locations.
<span class="lineNum">     358 </span>            :   int nBeams   = 3;
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :   for (int i = 3; i &lt; event.size(); ++i)</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :     if (event[i].statusAbs() &lt; 20) nBeams = i + 1;</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :   int nOffset  = nBeams - 3;</span>
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span>            :   // Reserve space for extra information on the systems and beams.
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :   int nMaxBeam = max( beamA.size(), beamB.size() );</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :   vector&lt;double&gt; sHatSys(nMaxBeam);</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :   vector&lt;double&gt; kTwidth(nMaxBeam);</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :   vector&lt;double&gt; kTcomp(nMaxBeam);</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :   vector&lt;RotBstMatrix&gt; Msys(nSys);</span>
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            :   // Loop over all subsystems. Default values. Find invariant mass.
<span class="lineNum">     371 </span>            :   double kTcompSumA   = 0.;
<span class="lineNum">     372 </span>            :   double kTcompSumB   = 0.;
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :   for (int iSys = 0; iSys &lt; nSys; ++iSys) {</span>
<span class="lineNum">     374 </span>            :     double kTwidthNow = 0.;
<span class="lineNum">     375 </span>            :     double mHatDamp   = 1.;
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :     int iInA          = partonSystemsPtr-&gt;getInA(iSys);</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :     int iInB          = partonSystemsPtr-&gt;getInB(iSys);</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :     double sHatNow    = (event[iInA].p() + event[iInB].p()).m2Calc();</span>
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span>            :     // Allow primordial kT reduction for small-mass and small-pT systems
<span class="lineNum">     381 </span>            :     // (for hardest interaction pT -&gt; renormalization scale so also 2 -&gt; 1).
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     if (doPrimordialKT) {</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :       double mHat     = sqrt(sHatNow);</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :       double yDamp    = pow( (event[iInA].e() + event[iInB].e()) / mHat,</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :                         reducedKTatHighY );</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :       mHatDamp        = mHat / (mHat + halfMassForKT * yDamp);</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :       double scale    = (iSys == 0) ? infoPtr-&gt;QRen(iDS)</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :                       : partonSystemsPtr-&gt;getPTHat(iSys);</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :       kTwidthNow      = ( (halfScaleForKT * primordialKTsoft</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :       + scale * primordialKThard) / (halfScaleForKT + scale) ) * mHatDamp;</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span>            :     // Store properties of compensation systems and total compensation power.
<span class="lineNum">     394 </span>            :     // Rescattered partons do not compensate, but may be massive.
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :     sHatSys[iSys] = sHatNow;</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :     kTwidth[iSys] = kTwidthNow ;</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :     kTcomp[iSys]  = mHatDamp;</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :     if (beamA[iSys].isFromBeam()) kTcompSumA += mHatDamp;</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :     else beamA[iSys].m( event[iInA].m() );</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :     if (beamB[iSys].isFromBeam()) kTcompSumB += mHatDamp;</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :     else beamB[iSys].m( event[iInB].m() );</span>
<span class="lineNum">     402 </span>            :   }
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span>            :   // Primordial kT and compensation power among remnants.
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :   double kTwidthNow = (doPrimordialKT) ? primordialKTremnant : 0.;</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :   for (int iRem = nSys; iRem &lt; nMaxBeam; ++iRem) {</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :     sHatSys[iRem] = 0.;</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :     kTwidth[iRem] = kTwidthNow ;</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :     kTcomp[iRem]  = 1.;</span>
<span class="lineNum">     410 </span>            :   }
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :   kTcompSumA += beamA.size() - nSys;</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :   kTcompSumB += beamB.size() - nSys;</span>
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span>            :   // Allow ten tries to construct kinematics (but normally works first).
<span class="lineNum">     415 </span>            :   bool physical;
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :   double xSum[2], xInvM[2], w2Beam[2], wPosRem, wNegRem, w2Rem;</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :   for (int iTry = 0; iTry &lt; NTRYKINMATCH; ++iTry) {</span>
<span class="lineNum">     418 </span>            :     physical = true;
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span>            :     // Loop over the two beams.
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :     for (int iBeam = 0; iBeam &lt; 2; ++iBeam) {</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :       BeamParticle&amp; beam = (iBeam == 0) ? beamA : beamB;</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :       int nPar = beam.size();</span>
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span>            :       // Generate Gaussian pT for initiator partons inside hadrons.
<span class="lineNum">     426 </span>            :       // Store/restore rescattered parton momenta before primordial kT.
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :       if (beam.isHadron() &amp;&amp; doPrimordialKT) {</span>
<span class="lineNum">     428 </span>            :         double pxSum = 0.;
<span class="lineNum">     429 </span>            :         double pySum = 0.;
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :         for (int iPar = 0; iPar &lt; nPar; ++iPar) {</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :           if ( beam[iPar].isFromBeam() ) {</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :             pair&lt;double, double&gt; gauss2 = rndmPtr-&gt;gauss2();</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :             double px = kTwidth[iPar] * gauss2.first;</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :             double py = kTwidth[iPar] * gauss2.second;</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :             beam[iPar].px(px);</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :             beam[iPar].py(py);</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :             pxSum += px;</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :             pySum += py;</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :           } else {</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :             int iInAB = (iBeam == 0) ? partonSystemsPtr-&gt;getInA(iPar)</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :                                      : partonSystemsPtr-&gt;getInB(iPar);</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :             beam[iPar].p( event[iInAB].p() );</span>
<span class="lineNum">     443 </span>            :           }
<span class="lineNum">     444 </span>            :         }
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            :         // Share recoil between all initiator partons, rescatterers excluded.
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :         double kTcompSum = (iBeam == 0) ? kTcompSumA : kTcompSumB;</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :         for (int iPar = 0; iPar &lt; nPar; ++iPar)</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :         if (beam[iPar].isFromBeam() ) {</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :           beam[iPar].px( beam[iPar].px() - pxSum * kTcomp[iPar] / kTcompSum );</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :           beam[iPar].py( beam[iPar].py() - pySum * kTcomp[iPar] / kTcompSum );</span>
<span class="lineNum">     452 </span>            :         }
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            :       // Without primordial kT: still need to store rescattered partons.
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :       } else if (beam.isHadron()) {</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :         for (int iPar = 0; iPar &lt; nPar; ++iPar)</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :         if ( !beam[iPar].isFromBeam() ) {</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :           int iInAB = (iBeam == 0) ? partonSystemsPtr-&gt;getInA(iPar)</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :                                    : partonSystemsPtr-&gt;getInB(iPar);</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :           beam[iPar].p( event[iInAB].p() );</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span>            :       // Pick unrescaled x values for remnants. Sum up (unscaled) p+ and p-.
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :       xSum[iBeam]  = 0.;</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :       xInvM[iBeam] = 0.;</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :       for (int iRem = nSys; iRem &lt; nPar; ++iRem) {</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :         double xPrel = beam.xRemnant( iRem);</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :         beam[iRem].x(xPrel);</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :         xSum[iBeam]  += xPrel;</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :         xInvM[iBeam] += beam[iRem].mT2()/xPrel;</span>
<span class="lineNum">     472 </span>            :       }
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span>            :       // Squared transverse mass for each beam, using lightcone x.
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :       w2Beam[iBeam] = xSum[iBeam] * xInvM[iBeam];</span>
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span>            :     // End separate treatment of the two beams.
<span class="lineNum">     478 </span>            :     }
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            :     // Recalculate kinematics of initiator systems with primordial kT.
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :     wPosRem = eCM;</span>
<span class="lineNum">     482 </span>            :     wNegRem = eCM;
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :     for (int iSys = 0; iSys &lt; nSys; ++iSys) {</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :       int iA          = beamA[iSys].iPos();</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :       int iB          = beamB[iSys].iPos();</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :       double sHat     = sHatSys[iSys];</span>
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span>            :       // Classify system: rescattering on either or both sides?
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :       bool normalA    = beamA[iSys].isFromBeam();</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :       bool normalB    = beamB[iSys].isFromBeam();</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :       bool normalSys  = normalA &amp;&amp; normalB;</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :       bool doubleRes  = !normalA &amp;&amp; !normalB;</span>
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span>            :       // Check whether final-state system momentum matches initial-state one.
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :       if (allowRescatter &amp;&amp; CORRECTMISMATCH) {</span>
<span class="lineNum">     496 </span>            :         Vec4 pInitial = event[iA].p() + event[iB].p();
<span class="lineNum">     497 </span>            :         Vec4 pFinal;
<span class="lineNum">     498 </span>            :         for (int iMem = 0; iMem &lt; partonSystemsPtr-&gt;sizeOut(iSys); ++iMem) {
<span class="lineNum">     499 </span>            :           int iAB      = partonSystemsPtr-&gt;getOut(iSys, iMem);
<span class="lineNum">     500 </span>            :           if (event[iAB].isFinal()) pFinal += event[iAB].p();
<span class="lineNum">     501 </span>            :         }
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span>            :         // Scale down primordial kT from side A if p+ increased.
<span class="lineNum">     504 </span>            :         if (normalA &amp;&amp; pFinal.pPos() &gt; pInitial.pPos())
<span class="lineNum">     505 </span>            :           beamA[iSys].scalePT( pInitial.pPos() / pFinal.pPos() );
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span>            :         // Scale down primordial kT from side B if p- increased.
<span class="lineNum">     508 </span>            :         if (normalB &amp;&amp; pFinal.pNeg() &gt; pInitial.pNeg())
<span class="lineNum">     509 </span>            :           beamB[iSys].scalePT( pInitial.pNeg() / pFinal.pNeg() );
<span class="lineNum">     510 </span>            :       }
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span>            :       // Rescatter: possible change in sign of lightcone momentum of a
<span class="lineNum">     513 </span>            :       //            rescattered parton. If this happens, try to pick
<span class="lineNum">     514 </span>            :       //            new primordial kT values
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :       if (allowRescatter</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :          &amp;&amp; (event[iA].pPos() / beamA[iSys].pPos() &lt; 0</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :          ||  event[iB].pNeg() / beamB[iSys].pNeg() &lt; 0) ) {</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :         infoPtr-&gt;errorMsg(&quot;Warning in BeamRemnants::setKinematics:&quot;</span>
<span class="lineNum">     519 </span>            :           &quot; change in lightcone momentum sign; retrying kinematics&quot;);
<span class="lineNum">     520 </span>            :         physical = false;
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     522 </span>            :       }
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span>            :       // Begin kinematics of partons after primordial kT has been added.
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :       double sHatTAft = sHat + pow2( beamA[iSys].px() + beamB[iSys].px())</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :                              + pow2( beamA[iSys].py() + beamB[iSys].py());</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :       double w2A      = beamA[iSys].mT2();</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :       double w2B      = beamB[iSys].mT2();</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :       double w2Diff   = sHatTAft - w2A - w2B;</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :       double lambda   = pow2(w2Diff) - 4. * w2A * w2B;</span>
<span class="lineNum">     531 </span>            : 
<span class="lineNum">     532 </span>            :       // Too large transverse momenta means that kinematics will not work.
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :       if (lambda &lt;= 0.) {</span>
<span class="lineNum">     534 </span>            :         physical      = false;
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     536 </span>            :       }
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :       double lamRoot  = sqrtpos( lambda );</span>
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span>            :       // Mirror solution if the two incoming have reverse rapidity ordering.
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :       if (allowRescatter &amp;&amp; doubleRes &amp;&amp; (event[iA].pPos() * event[iB].pNeg()</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :         &lt; event[iA].pNeg() * event[iB].pPos()) ) lamRoot = -lamRoot;</span>
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span>            :       // Two procedures, which agree for normal scattering, separate here.
<span class="lineNum">     544 </span>            :       // First option keeps rapidity (and mass) of system unchanged by
<span class="lineNum">     545 </span>            :       // primordial kT, by modification of rescattered parton.
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :       if (normalSys || doRescatterRestoreY || doubleRes) {</span>
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span>            :         // Find kinematics of initial system: transverse mass, and
<span class="lineNum">     549 </span>            :         // longitudinal momentum carried by all or rescattered partons.
<span class="lineNum">     550 </span>            :         double sHatTBef = sHat;
<span class="lineNum">     551 </span>            :         double wPosBef, wNegBef, wPosBefRes, wNegBefRes;
<span class="lineNum">     552 </span>            :         // Normal scattering.
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :         if (normalSys) {</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :           wPosBef       = beamA[iSys].x() * eCM;</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :           wNegBef       = beamB[iSys].x() * eCM;</span>
<span class="lineNum">     556 </span>            :           wPosBefRes    = 0.;
<span class="lineNum">     557 </span>            :           wNegBefRes    = 0.;
<span class="lineNum">     558 </span>            :         // Rescattering on side A.
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :         } else if (normalB) {</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :           sHatTBef     += event[iA].pT2();</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :           wPosBef       = event[iA].pPos();</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :           wNegBef       = event[iA].pNeg() + beamB[iSys].x() * eCM;</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :           wPosBefRes    = beamA[iSys].pPos();</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :           wNegBefRes    = beamA[iSys].pNeg();</span>
<span class="lineNum">     565 </span>            :         // Rescattering on side B.
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :         } else if (normalA) {</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :           sHatTBef     += event[iB].pT2();</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :           wPosBef       = beamA[iSys].x() * eCM + event[iB].pPos();</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :           wNegBef       = event[iB].pNeg();</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :           wPosBefRes    = beamB[iSys].pPos();</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :           wNegBefRes    = beamB[iSys].pNeg();</span>
<span class="lineNum">     572 </span>            :         // Rescattering on both sides.
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :           sHatTBef     += pow2( event[iA].px() + event[iB].px())</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :                         + pow2( event[iA].py() + event[iB].py());</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :           wPosBef       = event[iA].pPos() + event[iB].pPos();</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :           wNegBef       = event[iA].pNeg() + event[iB].pNeg();</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :           wPosBefRes    = beamA[iSys].pPos() + beamB[iSys].pPos();</span>
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :           wNegBefRes    = beamA[iSys].pNeg() + beamB[iSys].pNeg();</span>
<span class="lineNum">     580 </span>            :         }
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span>            :         // Rescale outgoing momenta to keep same mass and rapidity of system
<span class="lineNum">     583 </span>            :         // as originally, and solve for kinematics.
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :         double rescale  = sqrt(sHatTAft / sHatTBef);</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :         double wPosAft  = rescale * wPosBef;</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :         double wNegAft  = rescale * wNegBef;</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :         wPosRem        -= wPosAft - wPosBefRes;</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :         wNegRem        -= wNegAft - wNegBefRes;</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :         double wPosA    = 0.5 * (sHatTAft + w2A - w2B + lamRoot) / wNegAft;</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :         double wNegB    = 0.5 * (sHatTAft + w2B - w2A + lamRoot) / wPosAft;</span>
<span class="lineNum">     591 </span>            : 
<span class="lineNum">     592 </span>            :         // Store modified beam parton momenta.
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :         beamA[iSys].e(  0.5 * (wPosA + w2A / wPosA) );</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :         beamA[iSys].pz( 0.5 * (wPosA - w2A / wPosA) );</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :         beamB[iSys].e(  0.5 * (w2B / wNegB + wNegB) );</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :         beamB[iSys].pz( 0.5 * (w2B / wNegB - wNegB) );</span>
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span>            :       // Second option keeps rescattered parton (and system mass) unchanged
<span class="lineNum">     599 </span>            :       // by primordial kT, by modification of system rapidity.
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :       } else {</span>
<span class="lineNum">     601 </span>            : 
<span class="lineNum">     602 </span>            :         // Rescattering on side A: preserve already scattered parton.
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :         if (normalB) {</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :           double wPosA  = beamA[iSys].pPos();</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :           double wNegB  = 0.5 * (w2Diff + lamRoot) / wPosA;</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :           beamB[iSys].e(  0.5 * (w2B / wNegB + wNegB) );</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :           beamB[iSys].pz( 0.5 * (w2B / wNegB - wNegB) );</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :           wPosRem      -= w2B / wNegB;</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :           wNegRem      -= wNegB;</span>
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span>            :         // Rescattering on side B: preserve already scattered parton.
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :         } else if (normalA) {</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :           double wNegB  = beamB[iSys].pNeg();</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :           double wPosA  = 0.5 * (w2Diff + lamRoot) / wNegB;</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :           beamA[iSys].e(  0.5 * (wPosA + w2A / wPosA) );</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :           beamA[iSys].pz( 0.5 * (wPosA - w2A / wPosA) );</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :           wPosRem      -= wPosA;</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :           wNegRem      -= w2A / wPosA;</span>
<span class="lineNum">     620 </span>            : 
<span class="lineNum">     621 </span>            :         // Primordial kT in double rescattering does change the mass of
<span class="lineNum">     622 </span>            :         // the system without any possible fix in this framework, which
<span class="lineNum">     623 </span>            :         // leads to incorrect boosts. Current choice is therefore always
<span class="lineNum">     624 </span>            :         // to handle it with the first procedure, where mass is retained.
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">     626 </span>            :         }
<span class="lineNum">     627 </span>            :       }
<span class="lineNum">     628 </span>            : 
<span class="lineNum">     629 </span>            :       // Construct system rotation and boost caused by primordial kT.
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :       Msys[iSys].reset();</span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :       Msys[iSys].toCMframe( event[iA].p(), event[iB].p() );</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :       Msys[iSys].fromCMframe( beamA[iSys].p(), beamB[iSys].p() );</span>
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span>            :       // Boost rescattered partons in subsequent beam A list.
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :       for (int iSys2 = iSys + 1; iSys2 &lt; nSys; ++iSys2) {</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :         if (!beamA[iSys2].isFromBeam()) {</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :           int iBefResc = event[ beamA[iSys2].iPos() ].mother1();</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :           for (int iMem = 0; iMem &lt; partonSystemsPtr-&gt;sizeOut(iSys); ++iMem)</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :           if (partonSystemsPtr-&gt;getOut(iSys, iMem) == iBefResc) {</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :             Vec4 pTemp = event[iBefResc].p();</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :             pTemp.rotbst( Msys[iSys] );</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :             beamA[iSys2].p( pTemp );</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span>            :         // Boost rescattered partons in subsequent beam B list.
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :         if (!beamB[iSys2].isFromBeam()) {</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :           int iBefResc = event[ beamB[iSys2].iPos() ].mother1();</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :           for (int iMem = 0; iMem &lt; partonSystemsPtr-&gt;sizeOut(iSys); ++iMem)</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :           if (partonSystemsPtr-&gt;getOut(iSys, iMem) == iBefResc) {</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :             Vec4 pTemp = event[iBefResc].p();</span>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :             pTemp.rotbst( Msys[iSys] );</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :             beamB[iSys2].p( pTemp );</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     656 </span>            :       }
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span>            :     // Check that remaining momentum is enough for remnants.
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :     if (wPosRem &lt; 0. || wNegRem &lt; 0.) physical = false;</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :     w2Rem = wPosRem * wNegRem;</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :     if (sqrtpos(w2Rem) &lt; sqrt(w2Beam[0]) + sqrt(w2Beam[1]))</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :       physical = false;</span>
<span class="lineNum">     664 </span>            : 
<span class="lineNum">     665 </span>            :     // End of loop over ten tries. Do not loop when solution found.
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :     if (physical) break;</span>
<span class="lineNum">     667 </span>            :   }
<span class="lineNum">     668 </span>            : 
<span class="lineNum">     669 </span>            :   // If no solution after ten tries then failed.
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :   if (!physical) {</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :     infoPtr-&gt;errorMsg(&quot;Error in BeamRemnants::setKinematics:&quot;</span>
<span class="lineNum">     672 </span>            :       &quot; kinematics construction failed&quot;);
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     674 </span>            :   }
<span class="lineNum">     675 </span>            : 
<span class="lineNum">     676 </span>            :   // For successful initiator kinematics process whole systems.
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :   Vec4 pSumOut;</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :   for (int iSys = 0; iSys &lt; nSys; ++iSys) {</span>
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span>            :     // Copy initiators and their systems and boost them accordingly.
<span class="lineNum">     681 </span>            :     // Update subsystem and beams info on new positions of partons.
<span class="lineNum">     682 </span>            :     // Update daughter info of mothers, i.e. of beams, for hardest interaction.
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :     if (beamA[iSys].isFromBeam()) {</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :       int iA       = beamA[iSys].iPos();</span>
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :       int iAcopy   = event.copy(iA, -61);</span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :       event[iAcopy].rotbst(Msys[iSys]);</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :       partonSystemsPtr-&gt;setInA(iSys, iAcopy);</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :       beamA[iSys].iPos( iAcopy);</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :       if (iSys == 0) {</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :         int mother = event[iAcopy].mother1();</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :         event[mother].daughter1(iAcopy);</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :     if (beamB[iSys].isFromBeam()) {</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :       int iB       = beamB[iSys].iPos();</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :       int iBcopy   = event.copy(iB, -61);</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :       event[iBcopy].rotbst(Msys[iSys]);</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :       partonSystemsPtr-&gt;setInB(iSys, iBcopy);</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :       beamB[iSys].iPos( iBcopy);</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :       if (iSys == 0) {</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :         int mother = event[iBcopy].mother1();</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :         event[mother].daughter1(iBcopy);</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     705 </span>            : 
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :     for (int iMem = 0; iMem &lt; partonSystemsPtr-&gt;sizeOut(iSys); ++iMem) {</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :       int iAB      = partonSystemsPtr-&gt;getOut(iSys, iMem);</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :       if (event[iAB].isFinal()) {</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :         int iABcopy = event.copy(iAB, 62);</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :         event[iABcopy].rotbst(Msys[iSys]);</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :         partonSystemsPtr-&gt;setOut(iSys, iMem, iABcopy);</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :         pSumOut   += event[iABcopy].p();</span>
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     714 </span>            :     }
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span>            :   }
<span class="lineNum">     717 </span>            : 
<span class="lineNum">     718 </span>            :   // Colour dipoles spanning systems gives mismatch between FSR recoils
<span class="lineNum">     719 </span>            :   // and primordial kT boosts.
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :   if (allowRescatter &amp;&amp; CORRECTMISMATCH) {</span>
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span>            :     // Find summed pT of beam remnants = - wanted pT of systems.
<span class="lineNum">     723 </span>            :     double pxBeams = 0.;
<span class="lineNum">     724 </span>            :     double pyBeams = 0.;
<span class="lineNum">     725 </span>            :     for (int iRem = nSys; iRem &lt; beamA.size(); ++iRem) {
<span class="lineNum">     726 </span>            :       pxBeams     += beamA[iRem].px();
<span class="lineNum">     727 </span>            :       pyBeams     += beamA[iRem].py();
<span class="lineNum">     728 </span>            :     }
<span class="lineNum">     729 </span>            :     for (int iRem = nSys; iRem &lt; beamB.size(); ++iRem) {
<span class="lineNum">     730 </span>            :       pxBeams     += beamB[iRem].px();
<span class="lineNum">     731 </span>            :       pyBeams     += beamB[iRem].py();
<span class="lineNum">     732 </span>            :     }
<span class="lineNum">     733 </span>            : 
<span class="lineNum">     734 </span>            :     // Boost all final partons in systems transversely, and also their sum.
<span class="lineNum">     735 </span>            :     Vec4 pSumTo( -pxBeams, -pyBeams, pSumOut.pz(), sqrt( pow2(pxBeams)
<span class="lineNum">     736 </span>            :       + pow2(pyBeams) + pow2(pSumOut.pz()) + pSumOut.m2Calc() ) );
<span class="lineNum">     737 </span>            :     RotBstMatrix Mmismatch;
<span class="lineNum">     738 </span>            :     Mmismatch.bst( pSumOut, pSumTo);
<span class="lineNum">     739 </span>            :     for (int iSys = 0; iSys &lt; nSys; ++iSys)
<span class="lineNum">     740 </span>            :     for (int iMem = 0; iMem &lt; partonSystemsPtr-&gt;sizeOut(iSys); ++iMem) {
<span class="lineNum">     741 </span>            :       int iAB = partonSystemsPtr-&gt;getOut(iSys, iMem);
<span class="lineNum">     742 </span>            :       if (event[iAB].isFinal()) event[iAB].rotbst(Mmismatch);
<span class="lineNum">     743 </span>            :     }
<span class="lineNum">     744 </span>            :     pSumOut.rotbst(Mmismatch);
<span class="lineNum">     745 </span>            : 
<span class="lineNum">     746 </span>            :    // Reset energy and momentum sum, to be compensated by beam remnants.
<span class="lineNum">     747 </span>            :     wPosRem = eCM - (pSumOut.e() + pSumOut.pz());
<span class="lineNum">     748 </span>            :     wNegRem = eCM - (pSumOut.e() - pSumOut.pz());
<span class="lineNum">     749 </span>            :     w2Rem    = wPosRem * wNegRem;
<span class="lineNum">     750 </span>            :     if ( wPosRem &lt; 0. || wNegRem &lt; 0.
<span class="lineNum">     751 </span>            :       || sqrtpos(w2Rem) &lt; sqrt(w2Beam[0]) + sqrt(w2Beam[1])) {
<span class="lineNum">     752 </span>            :       infoPtr-&gt;errorMsg(&quot;Error in BeamRemnants::setKinematics:&quot;
<span class="lineNum">     753 </span>            :         &quot; kinematics construction failed owing to recoil mismatch&quot;);
<span class="lineNum">     754 </span>            :       return false;
<span class="lineNum">     755 </span>            :     }
<span class="lineNum">     756 </span>            :   }
<span class="lineNum">     757 </span>            : 
<span class="lineNum">     758 </span>            :   // Construct x rescaling factors for the two remants.
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :   double lambdaRoot = sqrtpos( pow2(w2Rem - w2Beam[0] - w2Beam[1])</span>
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :     - 4. * w2Beam[0] * w2Beam[1] );</span>
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :   double rescaleA   = (w2Rem + w2Beam[0] - w2Beam[1] + lambdaRoot)</span>
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :     / (2. * w2Rem * xSum[0]) ;</span>
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :   double rescaleB   = (w2Rem + w2Beam[1] - w2Beam[0] + lambdaRoot)</span>
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :     / (2. * w2Rem * xSum[1]) ;</span>
<span class="lineNum">     765 </span>            : 
<span class="lineNum">     766 </span>            :   // Construct energy and pz for remnants in first beam.
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :   for (int iRem = nSys; iRem &lt; beamA.size(); ++iRem) {</span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :     double pPos = rescaleA * beamA[iRem].x() * wPosRem;</span>
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :     double pNeg = beamA[iRem].mT2() / pPos;</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :     beamA[iRem].e( 0.5 * (pPos + pNeg) );</span>
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :     beamA[iRem].pz( 0.5 * (pPos - pNeg) );</span>
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span>            :     // Add these partons to the normal event record.
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :     int iNew = event.append( beamA[iRem].id(), 63, 1 + nOffset, 0, 0, 0,</span>
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :       beamA[iRem].col(), beamA[iRem].acol(), beamA[iRem].p(),</span>
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :       beamA[iRem].m() );</span>
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :     beamA[iRem].iPos( iNew);</span>
<span class="lineNum">     778 </span>            :   }
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span>            :   // Construct energy and pz for remnants in second beam.
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :   for (int iRem = nSys; iRem &lt; beamB.size(); ++iRem) {</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :     double pNeg = rescaleB * beamB[iRem].x() * wNegRem;</span>
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :     double pPos = beamB[iRem].mT2() / pNeg;</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :     beamB[iRem].e( 0.5 * (pPos + pNeg) );</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :     beamB[iRem].pz( 0.5 * (pPos - pNeg) );</span>
<span class="lineNum">     786 </span>            : 
<span class="lineNum">     787 </span>            :     // Add these partons to the normal event record.
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :     int iNew = event.append( beamB[iRem].id(), 63, 2 + nOffset, 0, 0, 0,</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :       beamB[iRem].col(), beamB[iRem].acol(), beamB[iRem].p(),</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :       beamB[iRem].m() );</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :     beamB[iRem].iPos( iNew);</span>
<span class="lineNum">     792 </span>            :   }
<span class="lineNum">     793 </span>            : 
<span class="lineNum">     794 </span>            :   // Done.
<span class="lineNum">     795 </span>            :   return true;
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span>            : // Special beam remnant kinematics for Deeply Inelastic Scattering.
<a name="802"><span class="lineNum">     802 </span>            : // Currently assumes unresolved lepton.</a>
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span>            : bool BeamRemnants::setDISKinematics( Event&amp; event) {
<span class="lineNum">     805 </span>            : 
<span class="lineNum">     806 </span>            :   // Identify lepton and hadron beams.
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :   BeamParticle&amp; beamLep = (beamAPtr-&gt;isLepton()) ? *beamAPtr : *beamBPtr;</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :   BeamParticle&amp; beamHad = (beamBPtr-&gt;isLepton()) ? *beamAPtr : *beamBPtr;</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :   int iBeamHad = (beamBPtr-&gt;isLepton()) ? 1 : 2;</span>
<span class="lineNum">     810 </span>            : 
<span class="lineNum">     811 </span>            :   // Identify scattered lepton and scattered hadronic four-momentum.
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :   int iLepScat = beamLep[0].iPos() + 2;</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :   Vec4 pHadScat;</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :   for (int i = 5; i &lt; event.size(); ++i)</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :     if (event[i].isFinal() &amp;&amp; i != iLepScat) pHadScat += event[i].p();</span>
<span class="lineNum">     816 </span>            : 
<span class="lineNum">     817 </span>            :   // Boost to hadronic rest frame.
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :   Vec4 pLepScat = event[iLepScat].p();</span>
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :   Vec4 pHadTot  = event[0].p() - pLepScat;</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :   Vec4 pRemnant = pHadTot - pHadScat;</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :   double w2Tot  = pHadTot.m2Calc();</span>
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :   double w2Scat = pHadScat.m2Calc();</span>
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :   RotBstMatrix MtoHadRest;</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :   MtoHadRest.toCMframe( pHadScat, pRemnant);</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :   event.rotbst( MtoHadRest);</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :   pHadScat.rotbst( MtoHadRest);</span>
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span>            :   // Allow ten tries to construct kinematics (but normally works first).
<span class="lineNum">     829 </span>            :   bool isPhysical = true;
<span class="lineNum">     830 </span>            :   double xSum, xInvM, w2Remn, lambda;
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :   for (int iTry = 0; iTry &lt; NTRYKINMATCH; ++iTry) {</span>
<span class="lineNum">     832 </span>            :     isPhysical = true;
<span class="lineNum">     833 </span>            : 
<span class="lineNum">     834 </span>            :     // Pick unrescaled x values for remnants. Sum up (unscaled) p+ and p-.
<span class="lineNum">     835 </span>            :     xSum  = 0.;
<span class="lineNum">     836 </span>            :     xInvM = 0.;
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :     for (int iRem = 1; iRem &lt; beamHad.size(); ++iRem) {</span>
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :       double xPrel = beamHad.xRemnant( iRem);</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :       beamHad[iRem].x(xPrel);</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :       xSum  += xPrel;</span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :       xInvM += beamHad[iRem].mT2() / xPrel;</span>
<span class="lineNum">     842 </span>            :     }
<span class="lineNum">     843 </span>            : 
<span class="lineNum">     844 </span>            :     // Squared transverse mass for remnant, may give failure.
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :     w2Remn = xSum * xInvM;</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :     lambda = pow2( w2Tot - w2Scat - w2Remn) - 4. * w2Scat * w2Remn;</span>
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :     if (lambda &lt; 0.) isPhysical = false;</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :     if (isPhysical) break;</span>
<span class="lineNum">     849 </span>            :   }
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :   if (!isPhysical) {</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :     infoPtr-&gt;errorMsg(&quot;Error in BeamRemnants::setDISKinematics:&quot;</span>
<span class="lineNum">     852 </span>            :       &quot; too big beam remnant invariant mass&quot;);
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     854 </span>            :   }
<span class="lineNum">     855 </span>            : 
<span class="lineNum">     856 </span>            :   // Boost of scattered system to compensate for remnant mass.
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :   double pzNew = 0.5 * sqrt( lambda / w2Tot);</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :   double eNewScat = 0.5 * (w2Tot + w2Scat - w2Remn) / sqrt(w2Tot);</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :   Vec4 pNewScat( 0., 0., pzNew, eNewScat);</span>
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :   RotBstMatrix MforScat;</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :   MforScat.bst( pHadScat, pNewScat);</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :   int sizeSave = event.size();</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :   for (int i = 5; i &lt; sizeSave; ++i)</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :   if (event[i].isFinal() &amp;&amp; event[i].id() != beamLep[0].id()) {</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :     int iNew = event.copy( i, 62);</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :     event[iNew].rotbst( MforScat);</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     868 </span>            : 
<span class="lineNum">     869 </span>            :   // Calculate kinematics of remnants and insert into event record.
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :   double eNewRemn = 0.5 * (w2Tot + w2Remn - w2Scat) / sqrt(w2Tot);</span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :   double wNewRemn = eNewRemn + pzNew;</span>
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :   for (int iRem = 1; iRem &lt; beamHad.size(); ++iRem) {</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :     double wNegNow = wNewRemn * beamHad[iRem].x() / xSum;</span>
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :     double wPosNow = beamHad[iRem].mT2() / wNegNow;</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :     Vec4 pNow( 0., 0., -0.5 * (wNegNow - wPosNow), 0.5 * (wPosNow + wNegNow) );</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :     int iNew = event.append( beamHad[iRem].id(), 63, iBeamHad, 0, 0, 0,</span>
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :       beamHad[iRem].col(), beamHad[iRem].acol(), pNow, beamHad[iRem].m() );</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :     beamHad[iRem].iPos( iNew);</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     880 </span>            : 
<span class="lineNum">     881 </span>            :   // Boost back event.
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :   MtoHadRest.invert();</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :   event.rotbst( MtoHadRest);</span>
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span>            :   // Done.
<span class="lineNum">     886 </span>            :   return true;
<span class="lineNum">     887 </span>            : 
<span class="lineNum">     888 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     889 </span>            : 
<span class="lineNum">     890 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     891 </span>            : 
<a name="892"><span class="lineNum">     892 </span>            : // Collapse colours and check that they are consistent.</a>
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span>            : bool BeamRemnants::checkColours( Event&amp; event) {
<span class="lineNum">     895 </span>            : 
<span class="lineNum">     896 </span>            :   // No colours in lepton beams so no need to do anything.
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :   if (beamAPtr-&gt;isLepton() &amp;&amp; beamBPtr-&gt;isLepton()) return true;</span>
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span>            :   // Remove ambiguities when one colour collapses two ways.
<span class="lineNum">     900 </span>            :   // Resolve chains where one colour is mapped to another.
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :   for (int iCol = 1; iCol &lt; int(colFrom.size()); ++iCol)</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :   for (int iColRef = 0; iColRef &lt; iCol; ++iColRef) {</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :     if (colFrom[iCol] == colFrom[iColRef]) {</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :       colFrom[iCol] = colTo[iCol];</span>
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :       colTo[iCol] = colTo[iColRef];</span>
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :     if (colTo[iCol] == colFrom[iColRef]) colTo[iCol] = colTo[iColRef];</span>
<span class="lineNum">     908 </span>            :   }
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span>            :   // Transform event record colours from beam remnant colour collapses.
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :   for (int i = oldSize; i &lt; event.size(); ++i) {</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :     int col = event[i].col();</span>
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :     int acol = event[i].acol();</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :     for (int iCol = 0; iCol &lt; int(colFrom.size()); ++iCol) {</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :       if (col == colFrom[iCol]) {col = colTo[iCol]; event[i].col(col);}</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :       if (acol == colFrom[iCol]) {acol = colTo[iCol]; event[i].acol(acol);}</span>
<span class="lineNum">     917 </span>            :       // Sextets have extra, negative, tags.
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :       if (col == -colFrom[iCol]) {col = -colTo[iCol]; event[i].col(col);}</span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :       if (acol == -colFrom[iCol]) {acol = -colTo[iCol]; event[i].acol(acol);}</span>
<span class="lineNum">     920 </span>            :     }
<span class="lineNum">     921 </span>            :   }
<span class="lineNum">     922 </span>            : 
<span class="lineNum">     923 </span>            :   // Transform junction colours from beam remnant colour collapses.
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :   for (int iJun = 0; iJun &lt; event.sizeJunction(); ++iJun)</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :     for (int leg = 0; leg &lt; 3; ++leg) {</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :       int col = event.colJunction(iJun, leg);</span>
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :       for (int iCol = 0; iCol &lt; int(colFrom.size()); ++iCol) {</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :         if (col == colFrom[iCol]) {</span>
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :           col = colTo[iCol];</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :           event.colJunction(iJun, leg, col);</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     932 </span>            :       }
<span class="lineNum">     933 </span>            :     }
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span>            :   // Arrays for current colours and anticolours, and for singlet gluons.
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :   vector&lt;int&gt; colList;</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :   vector&lt;int&gt; acolList;</span>
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :   vector&lt;int&gt; iSingletGluon;</span>
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span>            :   // Find current colours and anticolours in the event record.
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :   for (int i = oldSize; i &lt; event.size(); ++i)</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :   if (event[i].isFinal()) {</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :     int id   = event[i].id();</span>
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :     int col  = event[i].col();</span>
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :     int acol = event[i].acol();</span>
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :     int colType = event[i].colType();</span>
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span>            :     // Quarks must have colour set, antiquarks anticolour, gluons both.
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :     if ( (id &gt; 0 &amp;&amp; id &lt; 9 &amp;&amp; (col &lt;= 0 || acol != 0) )</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :       || (id &lt; 0 &amp;&amp; id &gt; -9 &amp;&amp; (col != 0 || acol &lt;= 0) )</span>
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :       || (id == 21 &amp;&amp; (col &lt;= 0 || acol &lt;= 0) ) ) {</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :       infoPtr-&gt;errorMsg(&quot;Error in BeamRemnants::checkColours: &quot;</span>
<span class="lineNum">     953 </span>            :         &quot;q/qbar/g has wrong colour slots set&quot;);
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     955 </span>            :     }
<span class="lineNum">     956 </span>            : 
<span class="lineNum">     957 </span>            :     // Sextets must have one positive and one negative tag
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :     if ( (colType == 3 &amp;&amp; (col &lt;= 0 || acol &gt;= 0))</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :          || (colType == -3 &amp;&amp; (col &gt;= 0 || acol &lt;= 0)) ) {</span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :       infoPtr-&gt;errorMsg(&quot;Error in BeamRemnants::checkColours: &quot;</span>
<span class="lineNum">     961 </span>            :                         &quot;sextet has wrong colours&quot;);
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     963 </span>            : 
<span class="lineNum">     964 </span>            :     // Save colours/anticolours, and position of colour singlet gluons.
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :     if ( col &gt; 0)  colList.push_back(  col );</span>
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :     if (acol &gt; 0) acolList.push_back( acol );</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :     if (col &gt; 0 &amp;&amp; acol == col) iSingletGluon.push_back(i);</span>
<span class="lineNum">     968 </span>            :     // Colour sextets
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :     if ( col &lt; 0) acolList.push_back( -col );</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :     if (acol &lt; 0) colList.push_back( -acol );</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     972 </span>            : 
<span class="lineNum">     973 </span>            :   // Run through list of singlet gluons and put them on final-state dipole
<span class="lineNum">     974 </span>            :   // (i,j) that offers smallest (p_g p_i) * (p_g p_j) / (p_i p_j).
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :   for (int iS = 0; iS &lt; int(iSingletGluon.size()); ++iS) {</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :     int    iGlu      = iSingletGluon[iS];</span>
<span class="lineNum">     977 </span>            :     int    iAcolDip  = -1;
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :     double pT2DipMin = sCM;</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :     for (int iC = oldSize; iC &lt; event.size(); ++iC)</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :       if (iC != iGlu &amp;&amp; event[iC].isFinal()) {</span>
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :       int colDip = event[iC].col();</span>
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :       if (colDip &gt; 0 &amp;&amp; event[iC].acol() !=colDip)</span>
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :       for (int iA = oldSize; iA &lt; event.size(); ++iA)</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :         if (iA != iGlu &amp;&amp; iA != iC &amp;&amp; event[iA].isFinal()</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :         &amp;&amp; event[iA].acol() == colDip &amp;&amp; event[iA].col() !=colDip) {</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :         double pT2Dip = (event[iGlu].p() * event[iC].p())</span>
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :           * (event[iGlu].p() * event[iA].p())</span>
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :           / (event[iC].p() * event[iA].p());</span>
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :         if (pT2Dip &lt; pT2DipMin) {</span>
<span class="lineNum">     990 </span>            :           iAcolDip  = iA;
<span class="lineNum">     991 </span>            :           pT2DipMin = pT2Dip;
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span>            :     // Fail if no dipole. Else insert singlet gluon onto relevant dipole.
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :     if (iAcolDip == -1)  return false;</span>
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :     event[iGlu].acol( event[iAcolDip].acol() );</span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :     event[iAcolDip].acol( event[iGlu].col() );</span>
<span class="lineNum">    1000 </span>            : 
<span class="lineNum">    1001 </span>            :     // Update any junction legs that match reconnected dipole.
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :     for (int iJun = 0; iJun &lt; event.sizeJunction(); ++iJun) {</span>
<span class="lineNum">    1003 </span>            : 
<span class="lineNum">    1004 </span>            :       // Only junctions need to be updated, not antijunctions.
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :       if (event.kindJunction(iJun) % 2 == 0) continue;</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :       for (int leg = 0; leg &lt; 3; ++leg) {</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :         int col = event.colJunction(iJun, leg);</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :         if (col == event[iGlu].acol())</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :           event.colJunction(iJun, leg, event[iGlu].col());</span>
<span class="lineNum">    1010 </span>            :       }
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1012 </span>            : 
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1014 </span>            : 
<span class="lineNum">    1015 </span>            :   // Check that not the same colour or anticolour appears twice.
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :   for (int iCol = 0; iCol &lt; int(colList.size()) - 1; ++iCol) {</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :     int col = colList[iCol];</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :     for (int iCol2 = iCol + 1; iCol2 &lt; int(colList.size()); ++iCol2)</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :     if (colList[iCol2] == col) {</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :       infoPtr-&gt;errorMsg(&quot;Warning in BeamRemnants::checkColours:&quot;</span>
<span class="lineNum">    1021 </span>            :         &quot; colour appears twice&quot;);
<span class="lineNum">    1022 </span>            :       if (!ALLOWCOLOURTWICE) return false;
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1024 </span>            :   }
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :   for (int iAcol = 0; iAcol &lt; int(acolList.size()) - 1; ++iAcol) {</span>
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :     int acol = acolList[iAcol];</span>
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :     for (int iAcol2 = iAcol + 1; iAcol2 &lt; int(acolList.size()); ++iAcol2)</span>
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :     if (acolList[iAcol2] == acol) {</span>
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :       infoPtr-&gt;errorMsg(&quot;Warning in BeamRemnants::checkColours:&quot;</span>
<span class="lineNum">    1030 </span>            :         &quot; anticolour appears twice&quot;);
<span class="lineNum">    1031 </span>            :       if (!ALLOWCOLOURTWICE) return false;
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1033 </span>            :   }
<span class="lineNum">    1034 </span>            : 
<span class="lineNum">    1035 </span>            :   // Remove all matching colour-anticolour pairs.
<span class="lineNum">    1036 </span>            :   bool foundPair = true;
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :   while (foundPair &amp;&amp; colList.size() &gt; 0 &amp;&amp; acolList.size() &gt; 0) {</span>
<span class="lineNum">    1038 </span>            :     foundPair = false;
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :     for (int iCol = 0; iCol &lt; int(colList.size()); ++iCol) {</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :       for (int iAcol = 0; iAcol &lt; int(acolList.size()); ++iAcol) {</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :         if (acolList[iAcol] == colList[iCol]) {</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :           colList[iCol] = colList.back(); colList.pop_back();</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :           acolList[iAcol] = acolList.back(); acolList.pop_back();</span>
<span class="lineNum">    1044 </span>            :           foundPair = true;
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1046 </span>            :         }
<span class="lineNum">    1047 </span>            :       }
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :       if (foundPair) break;</span>
<span class="lineNum">    1049 </span>            :     }
<span class="lineNum">    1050 </span>            :   }
<span class="lineNum">    1051 </span>            : 
<span class="lineNum">    1052 </span>            :   // Check that remaining (anti)colours are accounted for by junctions.
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :   for (int iJun = 0; iJun &lt; event.sizeJunction(); ++iJun) {</span>
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :     int kindJun = event.kindJunction(iJun);</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :     for (int leg = 0; leg &lt; 3; ++leg) {</span>
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :       int colEnd = event.colJunction(iJun, leg);</span>
<span class="lineNum">    1057 </span>            : 
<span class="lineNum">    1058 </span>            :       // Junction connected to three colours.
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :       if (kindJun == 1) {</span>
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :         for (int iCol = 0; iCol &lt; int(colList.size()); ++iCol)</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :         if (colList[iCol] == colEnd) {</span>
<span class="lineNum">    1062 </span>            :           // Found colour match: remove and exit.
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :           colList[iCol] = colList.back();</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :           colList.pop_back();</span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1066 </span>            :         }
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1068 </span>            : 
<span class="lineNum">    1069 </span>            :       // Junction connected to three anticolours.
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :       else if (kindJun == 2) {</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :         for (int iAcol = 0; iAcol &lt; int(acolList.size()); ++iAcol)</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :         if (acolList[iAcol] == colEnd) {</span>
<span class="lineNum">    1073 </span>            :           // Found colour match: remove and exit.
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :           acolList[iAcol] = acolList.back();</span>
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :           acolList.pop_back();</span>
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1077 </span>            :         }
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1079 </span>            : 
<span class="lineNum">    1080 </span>            :       // Other junction types
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :       else if ( kindJun == 3 || kindJun == 5) {</span>
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :         for (int iCol = 0; iCol &lt; int(colList.size()); ++iCol)</span>
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :         if (colList[iCol] == colEnd) {</span>
<span class="lineNum">    1084 </span>            :           // Found colour match: remove and exit.
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :           colList[iCol] = colList.back();</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :           colList.pop_back();</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1088 </span>            :         }
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1090 </span>            : 
<span class="lineNum">    1091 </span>            :       // Other antijunction types
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :       else if ( kindJun == 4 || kindJun == 6) {</span>
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :         for (int iAcol = 0; iAcol &lt; int(acolList.size()); ++iAcol)</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :         if (acolList[iAcol] == colEnd) {</span>
<span class="lineNum">    1095 </span>            :           // Found colour match: remove and exit.
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :           acolList[iAcol] = acolList.back();</span>
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :           acolList.pop_back();</span>
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1099 </span>            :         }
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1101 </span>            : 
<span class="lineNum">    1102 </span>            :       // End junction check.
<span class="lineNum">    1103 </span>            :     }
<span class="lineNum">    1104 </span>            :   }
<span class="lineNum">    1105 </span>            : 
<span class="lineNum">    1106 </span>            : 
<span class="lineNum">    1107 </span>            :   // Repair step - sometimes needed when rescattering allowed.
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :   if (colList.size() &gt; 0 || acolList.size() &gt; 0) {</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :     infoPtr-&gt;errorMsg(&quot;Warning in BeamRemnants::checkColours:&quot;</span>
<span class="lineNum">    1110 </span>            :                       &quot; need to repair unmatched colours&quot;);
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :   while (colList.size() &gt; 0 &amp;&amp; acolList.size() &gt; 0) {</span>
<span class="lineNum">    1113 </span>            : 
<span class="lineNum">    1114 </span>            :     // Replace one colour and one anticolour index by a new common one.
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :     int  colMatch =  colList.back();</span>
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :     int acolMatch = acolList.back();</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :     int  colNew   = event.nextColTag();</span>
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :     colList.pop_back();</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :     acolList.pop_back();</span>
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :     for (int i = oldSize; i &lt; event.size(); ++i) {</span>
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :       if (event[i].isFinal() &amp;&amp; event[i].col() == colMatch) {</span>
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :         event[i].col( colNew);</span>
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1124 </span>            :       }
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :       else if (event[i].isFinal() &amp;&amp; event[i].acol() == -colMatch) {</span>
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :         event[i].acol( -colNew);</span>
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1128 </span>            :       }
<span class="lineNum">    1129 </span>            :     }
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :     for (int i = oldSize; i &lt; event.size(); ++i) {</span>
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :       if (event[i].isFinal() &amp;&amp; event[i].acol() == acolMatch) {</span>
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :         event[i].acol( colNew);</span>
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1134 </span>            :       }
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :       if (event[i].isFinal() &amp;&amp; event[i].col() == -acolMatch) {</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :         event[i].col( -colNew);</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1138 </span>            :       }
<span class="lineNum">    1139 </span>            :     }
<span class="lineNum">    1140 </span>            :   }
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span>            :   // Done.
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :   return (colList.size() == 0 &amp;&amp; acolList.size() == 0);</span>
<span class="lineNum">    1144 </span>            : 
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1146 </span>            : 
<span class="lineNum">    1147 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1148 </span>            : 
<a name="1149"><span class="lineNum">    1149 </span>            : // Update colours of outgoing particles in the event record.</a>
<span class="lineNum">    1150 </span>            : 
<span class="lineNum">    1151 </span>            : void BeamRemnants::updateColEvent( Event&amp; event,
<span class="lineNum">    1152 </span>            :   vector&lt;pair &lt;int,int&gt; &gt; colChanges) {
<span class="lineNum">    1153 </span>            : 
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :   for (int iCol = 0; iCol &lt; int(colChanges.size()); ++iCol) {</span>
<span class="lineNum">    1155 </span>            : 
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :     int oldCol = colChanges[iCol].first;</span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :     int newCol = colChanges[iCol].second;</span>
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :     if (oldCol == newCol)</span>
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">    1160 </span>            : 
<span class="lineNum">    1161 </span>            :     // Add a copy of final particles with old colour and change the colour.
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :     for (int j = 0; j &lt; event.size(); ++j) {</span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :       if (event[j].isFinal() &amp;&amp; event[j].col() == oldCol)</span>
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :         event[event.copy(j, 64)].col(newCol);</span>
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :       if (event[j].isFinal() &amp;&amp; event[j].acol() == -oldCol)</span>
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :         event[event.copy(j, 64)].acol(-newCol);</span>
<span class="lineNum">    1167 </span>            : 
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :       if (event[j].isFinal() &amp;&amp; event[j].acol() == oldCol)</span>
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :         event[event.copy(j,64)].acol(newCol);</span>
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :       if (event[j].isFinal() &amp;&amp; event[j].col() == -oldCol)</span>
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :         event[event.copy(j,64)].col(-newCol);</span>
<span class="lineNum">    1172 </span>            :     }
<span class="lineNum">    1173 </span>            : 
<span class="lineNum">    1174 </span>            :     // Update junction.
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :     for (int j = 0;j &lt; event.sizeJunction(); ++j)</span>
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 :       for (int jCol = 0; jCol &lt; 3; ++jCol)</span>
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :         if (event.colJunction(j,jCol) == oldCol)</span>
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :           event.colJunction(j,jCol,newCol);</span>
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1180 </span>            : 
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1182 </span>            : 
<span class="lineNum">    1183 </span>            : //==========================================================================
<span class="lineNum">    1184 </span>            : 
<span class="lineNum">    1185 </span>            : } // end namespace Pythia8
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
