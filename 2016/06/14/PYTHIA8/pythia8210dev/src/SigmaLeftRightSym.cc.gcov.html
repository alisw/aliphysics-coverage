<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - PYTHIA8/pythia8210dev/src/SigmaLeftRightSym.cc</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">PYTHIA8/pythia8210dev/src</a> - SigmaLeftRightSym.cc<span style="font-size: 80%;"> (source / <a href="SigmaLeftRightSym.cc.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">356</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">27</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // SigmaLeftRightSym.cc is a part of the PYTHIA event generator.</a>
<span class="lineNum">       2 </span>            : // Copyright (C) 2015 Torbjorn Sjostrand.
<span class="lineNum">       3 </span>            : // PYTHIA is licenced under the GNU GPL version 2, see COPYING for details.
<span class="lineNum">       4 </span>            : // Please respect the MCnet Guidelines, see GUIDELINES for details.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : // Function definitions (not found in the header) for the
<span class="lineNum">       7 </span>            : // left-right-symmetry simulation classes.
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;Pythia8/SigmaLeftRightSym.h&quot;
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : namespace Pythia8 {
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : //==========================================================================
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : // Sigma1ffbar2ZRight class.
<span class="lineNum">      16 </span>            : // Cross section for f fbar -&gt; Z_R^0 (righthanded gauge boson).
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      19 </span>            : 
<a name="20"><span class="lineNum">      20 </span>            : // Initialize process.</a>
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : void Sigma1ffbar2ZRight::initProc() {
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            :   // Store Z_R mass and width for propagator.
<span class="lineNum">      25 </span><span class="lineNoCov">          0 :   idZR     = 9900023;</span>
<span class="lineNum">      26 </span><span class="lineNoCov">          0 :   mRes     = particleDataPtr-&gt;m0(idZR);</span>
<span class="lineNum">      27 </span><span class="lineNoCov">          0 :   GammaRes = particleDataPtr-&gt;mWidth(idZR);</span>
<span class="lineNum">      28 </span><span class="lineNoCov">          0 :   m2Res    = mRes*mRes;</span>
<span class="lineNum">      29 </span><span class="lineNoCov">          0 :   GamMRat  = GammaRes / mRes;</span>
<span class="lineNum">      30 </span><span class="lineNoCov">          0 :   sin2tW   = couplingsPtr-&gt;sin2thetaW();</span>
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span>            :   // Set pointer to particle properties and decay table.
<span class="lineNum">      33 </span><span class="lineNoCov">          0 :   ZRPtr    = particleDataPtr-&gt;particleDataEntryPtr(idZR);</span>
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      38 </span>            : 
<a name="39"><span class="lineNum">      39 </span>            : // Evaluate sigmaHat(sHat), part independent of incoming flavour.</a>
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            : void Sigma1ffbar2ZRight::sigmaKin() {
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            :   // Set up Breit-Wigner. Width out only includes open channels.
<span class="lineNum">      44 </span><span class="lineNoCov">          0 :   double sigBW    = 12. * M_PI/ ( pow2(sH - m2Res) + pow2(sH * GamMRat) );</span>
<span class="lineNum">      45 </span><span class="lineNoCov">          0 :   double widthOut = ZRPtr-&gt;resWidthOpen(idZR, mH);</span>
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            :   // Prefactor for incoming widths. Combine. Done.
<span class="lineNum">      48 </span><span class="lineNoCov">          0 :   double preFac   = alpEM * mH / ( 48. * sin2tW * (1. - sin2tW)</span>
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :                   * (1. - 2. * sin2tW) );</span>
<span class="lineNum">      50 </span><span class="lineNoCov">          0 :   sigma0          = preFac * sigBW * widthOut;</span>
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      55 </span>            : 
<a name="56"><span class="lineNum">      56 </span>            : // Evaluate sigmaHat(sHat), including incoming flavour dependence.</a>
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : double Sigma1ffbar2ZRight::sigmaHat() {
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            :   // Vector and axial couplings of incoming fermion pair.
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :   int    idAbs = abs(id1);</span>
<span class="lineNum">      62 </span>            :   double af = 0.;
<span class="lineNum">      63 </span>            :   double vf = 0.;
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :   if (idAbs &lt; 9 &amp;&amp; idAbs%2 == 1) {</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :     af      = -1. + 2. * sin2tW;</span>
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :     vf      = -1. + 4. * sin2tW / 3.;</span>
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :   } else if (idAbs &lt; 9) {</span>
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :     af      = 1. - 2. * sin2tW;</span>
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :     vf      = 1. - 8. * sin2tW / 3.;</span>
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :   } else if (idAbs &lt; 19 &amp;&amp; idAbs%2 == 1) {</span>
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :     af      = -1. + 2. * sin2tW;</span>
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :     vf      = -1. + 4. * sin2tW;</span>
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            :   // Colour factor. Answer.
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :   double sigma = (vf*vf + af*af) * sigma0;</span>
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :   if (idAbs &lt; 9) sigma /= 3.;</span>
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :   return sigma;</span>
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            : }
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      83 </span>            : 
<a name="84"><span class="lineNum">      84 </span>            : // Select identity, colour and anticolour.</a>
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span>            : void Sigma1ffbar2ZRight::setIdColAcol() {
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            :   // Flavours trivial.
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :   setId( id1, id2, idZR);</span>
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            :   // Colour flow topologies. Swap when antiquarks.
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :   if (abs(id1) &lt; 9) setColAcol( 1, 0, 0, 1, 0, 0);</span>
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :   else              setColAcol( 0, 0, 0, 0, 0, 0);</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :   if (id1 &lt; 0) swapColAcol();</span>
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      99 </span>            : 
<a name="100"><span class="lineNum">     100 </span>            : // Evaluate weight for Z_R decay angle.</a>
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            : double Sigma1ffbar2ZRight::weightDecay( Event&amp; process, int iResBeg,
<span class="lineNum">     103 </span>            :   int iResEnd) {
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            :   // Identity of mother of decaying reseonance(s).
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :   int idMother = process[process[iResBeg].mother1()].idAbs();</span>
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span>            :   // For top decay hand over to standard routine.
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :   if (idMother == 6)</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :     return weightTopDecay( process, iResBeg, iResEnd);</span>
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span>            :   // Z_R should sit in entry 5.
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :   if (iResBeg != 5 || iResEnd != 5) return 1.;</span>
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            :   // Couplings for in- and out-flavours.
<span class="lineNum">     116 </span>            :   double ai, vi, af, vf;
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :   int idInAbs   = process[3].idAbs();</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :   if (idInAbs &lt; 9 &amp;&amp; idInAbs%2 == 1) {</span>
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :     ai          = -1. + 2. * sin2tW;</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :     vi          = -1. + 4. * sin2tW / 3.;</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :   } else if (idInAbs &lt; 9) {</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :     ai          = 1. - 2. * sin2tW;</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :     vi          = 1. - 8. * sin2tW / 3.;</span>
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :     ai          = -1. + 2. * sin2tW;</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :     vi          = -1. + 4. * sin2tW;</span>
<span class="lineNum">     127 </span>            :   }
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :   int idOutAbs = process[6].idAbs();</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :   if (idOutAbs &lt; 9 &amp;&amp; idOutAbs%2 == 1) {</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :     af          = -1. + 2. * sin2tW;</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :     vf          = -1. + 4. * sin2tW / 3.;</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :   } else if (idOutAbs &lt; 9) {</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :     af          = 1. - 2. * sin2tW;</span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :     vf          = 1. - 8. * sin2tW / 3.;</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :     af          = -1. + 2. * sin2tW;</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :     vf          = -1. + 4. * sin2tW;</span>
<span class="lineNum">     138 </span>            :   }
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            :   // Phase space factors. Reconstruct decay angle.
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :   double mr1    = pow2(process[6].m()) / sH;</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :   double mr2    = pow2(process[7].m()) / sH;</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :   double betaf  = sqrtpos( pow2(1. - mr1 - mr2) - 4. * mr1 * mr2);</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :   double cosThe = (process[3].p() - process[4].p())</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :     * (process[7].p() - process[6].p()) / (sH * betaf);</span>
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span>            :   // Angular weight and its maximum.
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :   double wt1    = (vi*vi + ai*ai) * (vf*vf + af*af * betaf*betaf);</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :   double wt2    = (1. - betaf*betaf) * (vi*vi + ai*ai) * vf*vf;</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :   double wt3    = betaf * 4. * vi * ai * vf * af;</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :   if (process[3].id() * process[6].id() &lt; 0) wt3 = -wt3;</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :   double wt     = wt1 * (1. + cosThe*cosThe) + wt2 * (1. - cosThe*cosThe)</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :                 + 2. * wt3 * cosThe;</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :   double wtMax  = 2. * (wt1 + abs(wt3));</span>
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span>            :   // Done.
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :   return wt / wtMax;</span>
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            : //==========================================================================
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            : // Sigma1ffbar2WRight class.
<span class="lineNum">     164 </span>            : // Cross section for f fbar' -&gt; W_R^+- (righthanded gauge boson).
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     167 </span>            : 
<a name="168"><span class="lineNum">     168 </span>            : // Initialize process.</a>
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span>            : void Sigma1ffbar2WRight::initProc() {
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            :   // Store W_R^+- mass and width for propagator.
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :   idWR     = 9900024;</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :   mRes     = particleDataPtr-&gt;m0(idWR);</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :   GammaRes = particleDataPtr-&gt;mWidth(idWR);</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :   m2Res    = mRes*mRes;</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :   GamMRat  = GammaRes / mRes;</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :   thetaWRat = 1. / (12. * couplingsPtr-&gt;sin2thetaW());</span>
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span>            :   // Set pointer to particle properties and decay table.
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :   particlePtr = particleDataPtr-&gt;particleDataEntryPtr(idWR);</span>
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     186 </span>            : 
<a name="187"><span class="lineNum">     187 </span>            : // Evaluate sigmaHat(sHat), part independent of incoming flavour.</a>
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            : void Sigma1ffbar2WRight::sigmaKin() {
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span>            :   // Common coupling factors.
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :   double colQ   = 3. * (1. + alpS / M_PI);</span>
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            :   // Reset quantities to sum. Declare variables inside loop.
<span class="lineNum">     195 </span>            :   double widOutPos = 0.;
<span class="lineNum">     196 </span>            :   double widOutNeg = 0.;
<span class="lineNum">     197 </span>            :   int    id1Now, id2Now, id1Abs, id2Abs, id1Neg, id2Neg, onMode;
<span class="lineNum">     198 </span>            :   double widNow, widSecPos, widSecNeg, mf1, mf2, mr1, mr2, kinFac;
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span>            :   // Loop over all W_R^+- decay channels.
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; particlePtr-&gt;sizeChannels(); ++i) {</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :     id1Now      = particlePtr-&gt;channel(i).product(0);</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :     id2Now      = particlePtr-&gt;channel(i).product(1);</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :     id1Abs      = abs(id1Now);</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :     id2Abs      = abs(id2Now);</span>
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span>            :     // Check that above threshold. Phase space.
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :     mf1 = particleDataPtr-&gt;m0(id1Abs);</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :     mf2 = particleDataPtr-&gt;m0(id2Abs);</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :     if (mH &gt; mf1 + mf2 + MASSMARGIN) {</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :       mr1    = pow2(mf1 / mH);</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :       mr2    = pow2(mf2 / mH);</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :       kinFac = (1. - 0.5 * (mr1 + mr2) - 0.5 * pow2(mr1 - mr2))</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :              * sqrtpos( pow2(1. - mr1 - mr2) - 4. * mr1 * mr2 );</span>
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span>            :       // Combine kinematics with colour factor and CKM couplings.
<span class="lineNum">     217 </span>            :       widNow = kinFac;
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :       if (id1Abs &lt; 9) widNow *= colQ * couplingsPtr-&gt;V2CKMid(id1Abs, id2Abs);</span>
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            :       // Secondary width from top and righthanded neutrino decay.
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :       id1Neg    = (id1Abs &lt; 19) ? -id1Now : id1Abs;</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :       id2Neg    = (id2Abs &lt; 19) ? -id2Now : id2Abs;</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :       widSecPos = particleDataPtr-&gt;resOpenFrac(id1Now, id2Now);</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :       widSecNeg = particleDataPtr-&gt;resOpenFrac(id1Neg, id2Neg);</span>
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            :       // Add weight for channels on for all, W_R^+ and W_R^-, respectively.
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :       onMode = particlePtr-&gt;channel(i).onMode();</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :       if (onMode == 1 || onMode == 2) widOutPos += widNow * widSecPos;</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :       if (onMode == 1 || onMode == 3) widOutNeg += widNow * widSecNeg;</span>
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span>            :     // End loop over fermions.
<span class="lineNum">     232 </span>            :     }
<span class="lineNum">     233 </span>            :   }
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            :   // Set up Breit-Wigner. Cross section for W_R^+ and W_R^- separately.
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :   double sigBW = 12. * M_PI * pow2(alpEM * thetaWRat) * sH</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :                / ( pow2(sH - m2Res) + pow2(sH * GamMRat) );</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :   sigma0Pos = sigBW * widOutPos;</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :   sigma0Neg = sigBW * widOutNeg;</span>
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     244 </span>            : 
<a name="245"><span class="lineNum">     245 </span>            : // Evaluate sigmaHat(sHat), including incoming flavour dependence.</a>
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span>            : double Sigma1ffbar2WRight::sigmaHat() {
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            :   // Secondary width for W_R^+ or W_R^-. CKM and colour factors.
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :   int idUp = (abs(id1)%2 == 0) ? id1 : id2;</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :   double sigma = (idUp &gt; 0) ? sigma0Pos : sigma0Neg;</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :   if (abs(id1) &lt; 9) sigma *= couplingsPtr-&gt;V2CKMid(abs(id1), abs(id2)) / 3.;</span>
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            :   // Answer.
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :   return sigma;</span>
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span>            : }
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     260 </span>            : 
<a name="261"><span class="lineNum">     261 </span>            : // Select identity, colour and anticolour.</a>
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            : void Sigma1ffbar2WRight::setIdColAcol() {
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            :   // Sign of outgoing W_R.
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :   int sign          = (abs(id1)%2 == 0) ? 1 : -1;</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :   if (id1 &lt; 0) sign = -sign;</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :   setId( id1, id2, idWR * sign);</span>
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            :   // Colour flow topologies. Swap when antiquarks.
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :   if (abs(id1) &lt; 9) setColAcol( 1, 0, 0, 1, 0, 0);</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :   else              setColAcol( 0, 0, 0, 0, 0, 0);</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :   if (id1 &lt; 0) swapColAcol();</span>
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     278 </span>            : 
<a name="279"><span class="lineNum">     279 </span>            : // Evaluate weight for W_R decay angle.</a>
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span>            : double Sigma1ffbar2WRight::weightDecay( Event&amp; process, int iResBeg,
<span class="lineNum">     282 </span>            :   int iResEnd) {
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span>            :   // Identity of mother of decaying reseonance(s).
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :   int idMother = process[process[iResBeg].mother1()].idAbs();</span>
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            :   // For top decay hand over to standard routine.
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :   if (idMother == 6)</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :     return weightTopDecay( process, iResBeg, iResEnd);</span>
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            :   // W_R should sit in entry 5.
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :   if (iResBeg != 5 || iResEnd != 5) return 1.;</span>
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            :   // Phase space factors.
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :   double mr1    = pow2(process[6].m()) / sH;</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :   double mr2    = pow2(process[7].m()) / sH;</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :   double betaf  = sqrtpos( pow2(1. - mr1 - mr2) - 4. * mr1 * mr2);</span>
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            :   // Sign of asymmetry.
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :   double eps    = (process[3].id() * process[6].id() &gt; 0) ? 1. : -1.;</span>
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span>            :   // Reconstruct decay angle and weight for it.
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :   double cosThe = (process[3].p() - process[4].p())</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :     * (process[7].p() - process[6].p()) / (sH * betaf);</span>
<span class="lineNum">     305 </span>            :   double wtMax  = 4.;
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :   double wt     = pow2(1. + betaf * eps * cosThe) - pow2(mr1 - mr2);</span>
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            :   // Done.
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :   return (wt / wtMax);</span>
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span>            : //==========================================================================
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span>            : // Sigma1ll2Hchgchg class.
<span class="lineNum">     316 </span>            : // Cross section for l l -&gt; H_L^++-- or H_R^++-- (doubly charged Higgs).
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     319 </span>            : 
<a name="320"><span class="lineNum">     320 </span>            : // Initialize process.</a>
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            : void Sigma1ll2Hchgchg::initProc() {
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span>            :   // Set process properties: H_L^++-- or H_R^++--.
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :   if (leftRight == 1) {</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :     idHLR    = 9900041;</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :     codeSave = 3121;</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :     nameSave = &quot;l l -&gt; H_L^++--&quot;;</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :     idHLR    = 9900042;</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :     codeSave = 3141;</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :     nameSave = &quot;l l -&gt; H_R^++--&quot;;</span>
<span class="lineNum">     333 </span>            :   }
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span>            :   // Read in Yukawa matrix for couplings to a lepton pair.
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :   yukawa[1][1]  = settingsPtr-&gt;parm(&quot;LeftRightSymmmetry:coupHee&quot;);</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :   yukawa[2][1]  = settingsPtr-&gt;parm(&quot;LeftRightSymmmetry:coupHmue&quot;);</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :   yukawa[2][2]  = settingsPtr-&gt;parm(&quot;LeftRightSymmmetry:coupHmumu&quot;);</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :   yukawa[3][1]  = settingsPtr-&gt;parm(&quot;LeftRightSymmmetry:coupHtaue&quot;);</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :   yukawa[3][2]  = settingsPtr-&gt;parm(&quot;LeftRightSymmmetry:coupHtaumu&quot;);</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :   yukawa[3][3]  = settingsPtr-&gt;parm(&quot;LeftRightSymmmetry:coupHtautau&quot;);</span>
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span>            :   // Store H_L/R mass and width for propagator.
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :   mRes     = particleDataPtr-&gt;m0(idHLR);</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :   GammaRes = particleDataPtr-&gt;mWidth(idHLR);</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :   m2Res    = mRes*mRes;</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :   GamMRat  = GammaRes / mRes;</span>
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span>            :   // Set pointer to particle properties and decay table.
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :   particlePtr = particleDataPtr-&gt;particleDataEntryPtr(idHLR);</span>
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     355 </span>            : 
<a name="356"><span class="lineNum">     356 </span>            : // Evaluate sigmaHat(sHat), including incoming flavour dependence.</a>
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span>            : double Sigma1ll2Hchgchg::sigmaHat() {
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span>            :   // Initial state must consist of two identical-sign leptons.
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :   if (id1 * id2 &lt; 0) return 0.;</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :   int id1Abs = abs(id1);</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :   int id2Abs = abs(id2);</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :   if (id1Abs != 11 &amp;&amp; id1Abs != 13 &amp;&amp; id1Abs != 15) return 0.;</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :   if (id2Abs != 11 &amp;&amp; id2Abs != 13 &amp;&amp; id2Abs != 15) return 0.;</span>
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span>            :   // Set up Breit-Wigner, inwidth and outwidth.
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :   double sigBW  = 8. * M_PI / ( pow2(sH - m2Res) + pow2(sH * GamMRat) );</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :   double widIn  = pow2(yukawa[(id1Abs-9)/2][(id2Abs-9)/2])</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :                 * mH / (8. * M_PI);</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :   int idSgn     = (id1 &lt; 0) ? idHLR : -idHLR;</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :   double widOut = particlePtr-&gt;resWidthOpen( idSgn, mH);</span>
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            :   // Answer.
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :   return widIn * sigBW * widOut;</span>
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     380 </span>            : 
<a name="381"><span class="lineNum">     381 </span>            : // Select identity, colour and anticolour.</a>
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span>            : void Sigma1ll2Hchgchg::setIdColAcol() {
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            :   // Sign of outgoing H_L/R.
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :   int idSgn     = (id1 &lt; 0) ? idHLR : -idHLR;</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :   setId( id1, id2, idSgn);</span>
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span>            :   // No colours whatsoever.
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :   setColAcol( 0, 0, 0, 0, 0, 0);</span>
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     395 </span>            : 
<a name="396"><span class="lineNum">     396 </span>            : // Evaluate weight for H_L/R sequential decay angles.</a>
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span>            : double Sigma1ll2Hchgchg::weightDecay( Event&amp; process, int iResBeg,
<span class="lineNum">     399 </span>            :   int iResEnd) {
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span>            :   // Identity of mother of decaying reseonance(s).
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :   int idMother = process[process[iResBeg].mother1()].idAbs();</span>
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span>            :   // For top decay hand over to standard routine.
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :   if (idMother == 6)</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :     return weightTopDecay( process, iResBeg, iResEnd);</span>
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            :   // Else isotropic decay.
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :   return 1.;</span>
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span>            : //==========================================================================
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            : // Sigma2lgm2Hchgchgl class.
<span class="lineNum">     416 </span>            : // Cross section for l gamma -&gt; H_L^++-- l or H_R^++-- l
<span class="lineNum">     417 </span>            : // (doubly charged Higgs).
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     420 </span>            : 
<a name="421"><span class="lineNum">     421 </span>            : // Initialize process.</a>
<span class="lineNum">     422 </span>            : 
<span class="lineNum">     423 </span>            : void Sigma2lgm2Hchgchgl::initProc() {
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span>            :   // Set process properties: H_L^++-- or H_R^++-- and e/mu/tau.
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :   idHLR        = (leftRight == 1) ? 9900041 : 9900042;</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :   codeSave     = (leftRight == 1) ? 3122 : 3142;</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :   if (idLep == 13) codeSave += 2;</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :   if (idLep == 15) codeSave += 4;</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :   if      (codeSave == 3122) nameSave = &quot;l^+- gamma -&gt; H_L^++-- e^-+&quot;;</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :   else if (codeSave == 3123) nameSave = &quot;l^+- gamma -&gt; H_L^++-- mu^-+&quot;;</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :   else if (codeSave == 3124) nameSave = &quot;l^+- gamma -&gt; H_L^++-- tau^-+&quot;;</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :   else if (codeSave == 3142) nameSave = &quot;l^+- gamma -&gt; H_R^++-- e^-+&quot;;</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :   else if (codeSave == 3143) nameSave = &quot;l^+- gamma -&gt; H_R^++-- mu^-+&quot;;</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :   else                       nameSave = &quot;l^+- gamma -&gt; H_R^++-- tau^-+&quot;;</span>
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span>            :   // Read in relevantYukawa matrix for couplings to a lepton pair.
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :   if (idLep == 11) {</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :     yukawa[1]  = settingsPtr-&gt;parm(&quot;LeftRightSymmmetry:coupHee&quot;);</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :     yukawa[2]  = settingsPtr-&gt;parm(&quot;LeftRightSymmmetry:coupHmue&quot;);</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :     yukawa[3]  = settingsPtr-&gt;parm(&quot;LeftRightSymmmetry:coupHtaue&quot;);</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :   } else if (idLep == 13) {</span>
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :     yukawa[1]  = settingsPtr-&gt;parm(&quot;LeftRightSymmmetry:coupHmue&quot;);</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :     yukawa[2]  = settingsPtr-&gt;parm(&quot;LeftRightSymmmetry:coupHmumu&quot;);</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :     yukawa[3]  = settingsPtr-&gt;parm(&quot;LeftRightSymmmetry:coupHtaumu&quot;);</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :     yukawa[1]  = settingsPtr-&gt;parm(&quot;LeftRightSymmmetry:coupHtaue&quot;);</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :     yukawa[2]  = settingsPtr-&gt;parm(&quot;LeftRightSymmmetry:coupHtaumu&quot;);</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :     yukawa[3]  = settingsPtr-&gt;parm(&quot;LeftRightSymmmetry:coupHtautau&quot;);</span>
<span class="lineNum">     450 </span>            :   }
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span>            :   // Secondary open width fractions.
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :   openFracPos  = particleDataPtr-&gt;resOpenFrac( idHLR);</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :   openFracNeg  = particleDataPtr-&gt;resOpenFrac(-idHLR);</span>
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     459 </span>            : 
<a name="460"><span class="lineNum">     460 </span>            : // Evaluate sigmaHat(sHat), including incoming flavour dependence.</a>
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span>            : double Sigma2lgm2Hchgchgl::sigmaHat() {
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span>            :   // Initial state must consist of a lepton and a photon.
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :   int idIn     = (id2 == 22) ? id1 : id2;</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :   int idInAbs  = abs(idIn);</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :   if (idInAbs != 11 &amp;&amp; idInAbs != 13 &amp;&amp; idInAbs != 15) return 0.;</span>
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span>            :   // Incoming squared lepton mass.
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :   double s1    = pow2( particleDataPtr-&gt;m0(idInAbs) );</span>
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span>            :   // Kinematical expressions.
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :   double smm1  = 8. * (sH + tH - s3) * (sH + tH - 2. * s3 - s1 - s4)</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :                / pow2(uH - s3);</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :   double smm2  = 2. * ( (2. * s3 - 3. * s1) * s4 + (s1 - 2. * s4) * tH</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :                - (tH - s4) * sH ) / pow2(tH - s4);</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :   double smm3  = 2. * ( (2. * s3 - 3. * s4 + tH) * s1</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :                - (2. * s1 - s4 + tH) * sH ) / pow2(sH - s1);</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :   double smm12 = 4. * ( (2. * s1 - s4 - 2. * s3 + tH) * sH</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :                + (tH - 3. * s3 - 3. * s4) * tH + (2. * s3 - 2. * s1</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :                + 3. * s4) * s3 ) / ( (uH - s3) * (tH - s4) );</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :   double smm13 = -4. * ( (tH + s1 - 2. * s4) * tH - (s3 + 3. * s1 - 2. * s4)</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :                * s3 + (s3 + 3. * s1 + tH) * sH - pow2(tH - s3 + sH) )</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :                / ( (uH - s3) * (sH - s1) );</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :   double smm23 = -4. * ( (s1 - s4 + s3) * tH - s3*s3 + s3 * (s1 + s4)</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :                - 3. * s1 * s4 - (s1 - s4 - s3 + tH) * sH)</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :                / ( (sH - s1) * (tH - s4) );</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :   double sigma = alpEM * pow2(sH / (sH - s1) ) * (smm1 + smm2 + smm3</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :                + smm12 + smm13 + smm23) / (4. * sH2);</span>
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span>            :   // Lepton Yukawa and secondary widths.
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :   sigma       *= pow2(yukawa[(idInAbs-9)/2]);</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :   sigma       *= (idIn &lt; 0) ? openFracPos : openFracNeg;</span>
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span>            :   // Answer.
<span class="lineNum">     496 </span>            :   return sigma;
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     501 </span>            : 
<a name="502"><span class="lineNum">     502 </span>            : // Select identity, colour and anticolour.</a>
<span class="lineNum">     503 </span>            : 
<span class="lineNum">     504 </span>            : void Sigma2lgm2Hchgchgl::setIdColAcol() {
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span>            :   // Sign of outgoing H_L/R.
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :   int idIn     = (id2 == 22) ? id1 : id2;</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :   int idSgn    = (idIn &lt; 0) ? idHLR : -idHLR;</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :   int idOut    = (idIn &lt; 0) ? idLep : -idLep;</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :   setId( id1, id2, idSgn, idOut);</span>
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span>            :   // tHat is defined between incoming lepton and outgoing Higgs.
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :   if (id1 == 22) swapTU = true;</span>
<span class="lineNum">     514 </span>            : 
<span class="lineNum">     515 </span>            :   // No colours whatsoever.
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :   setColAcol( 0, 0, 0, 0, 0, 0, 0, 0);</span>
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     521 </span>            : 
<a name="522"><span class="lineNum">     522 </span>            : // Evaluate weight for H_L/R sequential decay angles.</a>
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span>            : double Sigma2lgm2Hchgchgl::weightDecay( Event&amp; process, int iResBeg,
<span class="lineNum">     525 </span>            :   int iResEnd) {
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span>            :   // Identity of mother of decaying reseonance(s).
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :   int idMother = process[process[iResBeg].mother1()].idAbs();</span>
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span>            :   // For top decay hand over to standard routine.
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :   if (idMother == 6)</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :     return weightTopDecay( process, iResBeg, iResEnd);</span>
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span>            :   // Else isotropic decay.
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :   return 1.;</span>
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span>            : //==========================================================================
<span class="lineNum">     540 </span>            : 
<span class="lineNum">     541 </span>            : // Sigma3ff2HchgchgfftWW class.
<span class="lineNum">     542 </span>            : // Cross section for  f_1 f_2 -&gt; H_(L/R)^++-- f_3 f_4 (W+- W+- fusion).
<span class="lineNum">     543 </span>            : 
<span class="lineNum">     544 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     545 </span>            : 
<a name="546"><span class="lineNum">     546 </span>            : // Initialize process.</a>
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span>            : void Sigma3ff2HchgchgfftWW::initProc() {
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span>            :   // Set process properties: H_L^++-- or H_R^++--.
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :   if (leftRight == 1) {</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :     idHLR      = 9900041;</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :     codeSave   = 3125;</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :     nameSave   = &quot;f_1 f_2 -&gt; H_L^++-- f_3 f_4 (W+- W+- fusion)&quot;;</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :     idHLR      = 9900042;</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :     codeSave   = 3145;</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :     nameSave   = &quot;f_1 f_2 -&gt; H_R^++-- f_3 f_4 (W+- W+- fusion)&quot;;</span>
<span class="lineNum">     559 </span>            :   }
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span>            :   // Common fixed mass and coupling factor.
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :   double mW    = particleDataPtr-&gt;m0(24);</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :   double mWR   = particleDataPtr-&gt;m0(9900024);</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :   mWS          = (leftRight == 1) ? pow2(mW) : pow2(mWR);</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :   double gL    = settingsPtr-&gt;parm(&quot;LeftRightSymmmetry:gL&quot;);</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :   double gR    = settingsPtr-&gt;parm(&quot;LeftRightSymmmetry:gR&quot;);</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :   double vL    = settingsPtr-&gt;parm(&quot;LeftRightSymmmetry:vL&quot;);</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :   prefac       = (leftRight == 1) ? pow2(pow4(gL) * vL)</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :                                   : 2. * pow2(pow3(gR) * mWR);</span>
<span class="lineNum">     570 </span>            :   // Secondary open width fractions.
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :   openFracPos  = particleDataPtr-&gt;resOpenFrac( idHLR);</span>
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :   openFracNeg  = particleDataPtr-&gt;resOpenFrac(-idHLR);</span>
<span class="lineNum">     573 </span>            : 
<span class="lineNum">     574 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     575 </span>            : 
<span class="lineNum">     576 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     577 </span>            : 
<a name="578"><span class="lineNum">     578 </span>            : // Evaluate sigmaHat(sHat), part independent of incoming flavour.</a>
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span>            : void Sigma3ff2HchgchgfftWW::sigmaKin() {
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span>            :   // Required four-vector products.
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :   double pp12  = 0.5 * sH;</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :   double pp14  = 0.5 * mH * p4cm.pNeg();</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :   double pp15  = 0.5 * mH * p5cm.pNeg();</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :   double pp24  = 0.5 * mH * p4cm.pPos();</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :   double pp25  = 0.5 * mH * p5cm.pPos();</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :   double pp45  = p4cm * p5cm;</span>
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span>            :   // Cross section: kinematics part. Combine with couplings.
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :   double propT = 1. / ( (2. * pp14 + mWS) * (2. * pp25 + mWS) );</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :   double propU = 1. / ( (2. * pp24 + mWS) * (2. * pp15 + mWS) );</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :   sigma0TU     = prefac * pp12 * pp45 * pow2(propT + propU);</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :   sigma0T      = prefac * pp12 * pp45 * 2. * pow2(propT);</span>
<span class="lineNum">     595 </span>            : 
<span class="lineNum">     596 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     599 </span>            : 
<a name="600"><span class="lineNum">     600 </span>            : // Evaluate sigmaHat(sHat), including incoming flavour dependence.</a>
<span class="lineNum">     601 </span>            : 
<span class="lineNum">     602 </span>            : double Sigma3ff2HchgchgfftWW::sigmaHat() {
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span>            :   // Do not allow creation of righthanded neutrinos for H_R.
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :   int id1Abs   = abs(id1);</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :   int id2Abs   = abs(id2);</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :   if ( leftRight == 2 &amp;&amp; (id1Abs &gt; 10 || id2Abs &gt; 10) ) return 0.;</span>
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span>            :   // Many flavour combinations not possible because of charge.
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :   int chg1     = (( id1Abs%2 == 0 &amp;&amp; id1 &gt; 0)</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :                || (id1Abs%2 == 1 &amp;&amp; id1 &lt; 0) ) ? 1 : -1;</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :   int chg2     = (( id2Abs%2 == 0 &amp;&amp; id2 &gt; 0)</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :                || (id2Abs%2 == 1 &amp;&amp; id2 &lt; 0) ) ? 1 : -1;</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :   if (abs(chg1 + chg2) != 2) return 0.;</span>
<span class="lineNum">     615 </span>            : 
<span class="lineNum">     616 </span>            :   // Basic cross section. CKM factors for final states.
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :   double sigma = (id2 == id1 &amp;&amp; id1Abs &gt; 10) ? sigma0TU : sigma0T;</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :   sigma       *= couplingsPtr-&gt;V2CKMsum(id1Abs)</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :                * couplingsPtr-&gt;V2CKMsum(id2Abs);</span>
<span class="lineNum">     620 </span>            : 
<span class="lineNum">     621 </span>            :   // Secondary width for H0.
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :   sigma       *= (chg1 + chg2 == 2) ? openFracPos : openFracNeg;</span>
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span>            :   // Spin-state extra factor 2 per incoming neutrino.
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :   if (id1Abs == 12 || id1Abs == 14 || id1Abs == 16) sigma *= 2.;</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :   if (id2Abs == 12 || id2Abs == 14 || id2Abs == 16) sigma *= 2.;</span>
<span class="lineNum">     627 </span>            : 
<span class="lineNum">     628 </span>            :   // Answer.
<span class="lineNum">     629 </span>            :   return sigma;
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     632 </span>            : 
<span class="lineNum">     633 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     634 </span>            : 
<a name="635"><span class="lineNum">     635 </span>            : // Select identity, colour and anticolour.</a>
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            : void Sigma3ff2HchgchgfftWW::setIdColAcol() {
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span>            :   // Pick out-flavours by relative CKM weights.
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :   int id1Abs   = abs(id1);</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :   int id2Abs   = abs(id2);</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :   id4          = couplingsPtr-&gt;V2CKMpick(id1);</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :   id5          = couplingsPtr-&gt;V2CKMpick(id2);</span>
<span class="lineNum">     644 </span>            : 
<span class="lineNum">     645 </span>            :   // Find charge of Higgs .
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :   id3 = (( id1Abs%2 == 0 &amp;&amp; id1 &gt; 0) || (id1Abs%2 == 1 &amp;&amp; id1 &lt; 0) )</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :       ? idHLR : -idHLR;</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :   setId( id1, id2, id3, id4, id5);</span>
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span>            :   // Colour flow topologies. Swap when antiquarks.
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :   if (id1Abs &lt; 9 &amp;&amp; id2Abs &lt; 9 &amp;&amp; id1*id2 &gt; 0)</span>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :                        setColAcol( 1, 0, 2, 0, 0, 0, 1, 0, 2, 0);</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :   else if (id1Abs &lt; 9 &amp;&amp; id2Abs &lt; 9)</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :                        setColAcol( 1, 0, 0, 2, 0, 0, 1, 0, 0, 2);</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :   else if (id1Abs &lt; 9) setColAcol( 1, 0, 0, 0, 0, 0, 1, 0, 0, 0);</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :   else if (id2Abs &lt; 9) setColAcol( 0, 0, 1, 0, 0, 0, 0, 0, 1, 0);</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :   else                 setColAcol( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :   if ( (id1Abs &lt; 9 &amp;&amp; id1 &lt; 0) || (id1Abs &gt; 10 &amp;&amp; id2 &lt; 0) )</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :     swapColAcol();</span>
<span class="lineNum">     660 </span>            : 
<span class="lineNum">     661 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     662 </span>            : 
<span class="lineNum">     663 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     664 </span>            : 
<a name="665"><span class="lineNum">     665 </span>            : // Evaluate weight for decay angles.</a>
<span class="lineNum">     666 </span>            : 
<span class="lineNum">     667 </span>            : double Sigma3ff2HchgchgfftWW::weightDecay( Event&amp; process, int iResBeg,
<span class="lineNum">     668 </span>            :   int iResEnd) {
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span>            :   // Identity of mother of decaying reseonance(s).
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :   int idMother = process[process[iResBeg].mother1()].idAbs();</span>
<span class="lineNum">     672 </span>            : 
<span class="lineNum">     673 </span>            :   // For top decay hand over to standard routine.
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :   if (idMother == 6)</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :     return weightTopDecay( process, iResBeg, iResEnd);</span>
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span>            :   // Else done.
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :   return 1.;</span>
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     681 </span>            : 
<span class="lineNum">     682 </span>            : //==========================================================================
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span>            : // Sigma2ffbar2HchgchgHchgchg class.
<span class="lineNum">     685 </span>            : // Cross section for f fbar -&gt; H_(L/R)^++ H_(L/R)^-- (doubly charged Higgs).
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     688 </span>            : 
<a name="689"><span class="lineNum">     689 </span>            : // Initialize process.</a>
<span class="lineNum">     690 </span>            : 
<span class="lineNum">     691 </span>            : void Sigma2ffbar2HchgchgHchgchg::initProc() {
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span>            :   // Set process properties: H_L^++ H_L^-- or H_R^++ H_R^--.
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :   if (leftRight == 1) {</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :     idHLR      = 9900041;</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :     codeSave   = 3126;</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :     nameSave   = &quot;f fbar -&gt; H_L^++ H_L^--&quot;;</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :     idHLR      = 9900042;</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :     codeSave   = 3146;</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :     nameSave   = &quot;f fbar -&gt; H_R^++ H_R^--&quot;;</span>
<span class="lineNum">     702 </span>            :   }
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span>            :   // Read in Yukawa matrix for couplings to a lepton pair.
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :   yukawa[1][1] = settingsPtr-&gt;parm(&quot;LeftRightSymmmetry:coupHee&quot;);</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :   yukawa[2][1] = settingsPtr-&gt;parm(&quot;LeftRightSymmmetry:coupHmue&quot;);</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :   yukawa[2][2] = settingsPtr-&gt;parm(&quot;LeftRightSymmmetry:coupHmumu&quot;);</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :   yukawa[3][1] = settingsPtr-&gt;parm(&quot;LeftRightSymmmetry:coupHtaue&quot;);</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :   yukawa[3][2] = settingsPtr-&gt;parm(&quot;LeftRightSymmmetry:coupHtaumu&quot;);</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :   yukawa[3][3] = settingsPtr-&gt;parm(&quot;LeftRightSymmmetry:coupHtautau&quot;);</span>
<span class="lineNum">     711 </span>            : 
<span class="lineNum">     712 </span>            :   // Electroweak parameters.
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :   mRes         = particleDataPtr-&gt;m0(23);</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :   GammaRes     = particleDataPtr-&gt;mWidth(23);</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :   m2Res        = mRes*mRes;</span>
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :   GamMRat      = GammaRes / mRes;</span>
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :   sin2tW       = couplingsPtr-&gt;sin2thetaW();</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :   preFac       = (1. - 2. * sin2tW) / ( 8. * sin2tW * (1. - sin2tW) );</span>
<span class="lineNum">     719 </span>            : 
<span class="lineNum">     720 </span>            :   // Open fraction from secondary widths.
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :   openFrac     = particleDataPtr-&gt;resOpenFrac( idHLR, -idHLR);</span>
<span class="lineNum">     722 </span>            : 
<span class="lineNum">     723 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     726 </span>            : 
<a name="727"><span class="lineNum">     727 </span>            : // Evaluate sigmaHat(sHat), including incoming flavour dependence.</a>
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span>            : double Sigma2ffbar2HchgchgHchgchg::sigmaHat() {
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span>            :   // Electroweak couplings to gamma^*/Z^0.
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :   int    idAbs   = abs(id1);</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :   double ei      = couplingsPtr-&gt;ef(idAbs);</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :   double vi      = couplingsPtr-&gt;vf(idAbs);</span>
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :   double ai      = couplingsPtr-&gt;af(idAbs);</span>
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span>            :   // Part via gamma^*/Z^0 propagator. No Z^0 coupling to H_R.
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :   double resProp = 1. / ( pow2(sH - m2Res) + pow2(sH * GamMRat) );</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :   double sigma   = 8. * pow2(alpEM) * ei*ei / sH2;</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :   if (leftRight == 1) sigma += 8. * pow2(alpEM)</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :     * (2. * ei * vi * preFac * (sH - m2Res) * resProp / sH</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :     + (vi * vi + ai * ai) * pow2(preFac) * resProp);</span>
<span class="lineNum">     743 </span>            : 
<span class="lineNum">     744 </span>            :   // Part via t-channel lepton + interference; sum over possibilities.
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :   if (idAbs == 11 || idAbs == 13 || idAbs == 15) {</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :     double yuk2Sum;</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :     if (idAbs == 11) yuk2Sum</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :       = pow2(yukawa[1][1]) + pow2(yukawa[2][1]) + pow2(yukawa[3][1]);</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :     else if (idAbs == 13) yuk2Sum</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :       = pow2(yukawa[2][1]) + pow2(yukawa[2][2]) + pow2(yukawa[3][2]);</span>
<span class="lineNum">     751 </span>            :     else yuk2Sum
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :       = pow2(yukawa[3][1]) + pow2(yukawa[3][2]) + pow2(yukawa[3][3]);</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :     yuk2Sum /= 4. * M_PI;</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :     sigma   += 8. * alpEM * ei * yuk2Sum / (sH * tH)</span>
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :       + 4. * pow2(yuk2Sum) / tH2;</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :     if (leftRight == 1) sigma += 8. * alpEM * (vi + ai) * yuk2Sum</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :       * preFac * (sH - m2Res) * resProp / tH;</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     759 </span>            : 
<span class="lineNum">     760 </span>            :   // Common kinematical factor. Colour factor.
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :   sigma *= M_PI * (tH * uH - s3 * s4) / sH2;</span>
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :   if (idAbs &lt; 9) sigma /= 3.;</span>
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span>            :   // Answer.
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :   return sigma;</span>
<span class="lineNum">     766 </span>            : 
<span class="lineNum">     767 </span>            : }
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     770 </span>            : 
<a name="771"><span class="lineNum">     771 </span>            : // Select identity, colour and anticolour.</a>
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span>            : void Sigma2ffbar2HchgchgHchgchg::setIdColAcol() {
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span>            :   // Outgoing flavours trivial.
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :   setId( id1, id2, idHLR, -idHLR);</span>
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span>            :   // tHat is defined between incoming fermion and outgoing H--.
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :   if (id1 &gt; 0) swapTU = true;</span>
<span class="lineNum">     780 </span>            : 
<span class="lineNum">     781 </span>            :   // No colours at all or one flow topology. Swap if first is antiquark.
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :   if (abs(id1) &lt; 9) setColAcol( 1, 0, 0, 1, 0, 0, 0, 0);</span>
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :   else              setColAcol( 0, 0, 0, 0, 0, 0, 0, 0);</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :   if (id1 &lt; 0) swapColAcol();</span>
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     789 </span>            : 
<a name="790"><span class="lineNum">     790 </span>            : // Evaluate weight for H_L/R sequential decay angles.</a>
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span>            : double Sigma2ffbar2HchgchgHchgchg::weightDecay( Event&amp; process,
<span class="lineNum">     793 </span>            :   int iResBeg, int iResEnd) {
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span>            :   // Identity of mother of decaying reseonance(s).
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :   int idMother = process[process[iResBeg].mother1()].idAbs();</span>
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span>            :   // For top decay hand over to standard routine.
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :   if (idMother == 6)</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :     return weightTopDecay( process, iResBeg, iResEnd);</span>
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span>            :   // Else isotropic decay.
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :   return 1.;</span>
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     806 </span>            : 
<span class="lineNum">     807 </span>            : //==========================================================================
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span>            : } // end namespace Pythia8
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
