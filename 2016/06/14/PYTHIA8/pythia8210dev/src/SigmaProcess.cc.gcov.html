<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - PYTHIA8/pythia8210dev/src/SigmaProcess.cc</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">PYTHIA8/pythia8210dev/src</a> - SigmaProcess.cc<span style="font-size: 80%;"> (source / <a href="SigmaProcess.cc.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">817</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">19</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // SigmaProcess.cc is a part of the PYTHIA event generator.</a>
<span class="lineNum">       2 </span>            : // Copyright (C) 2015 Torbjorn Sjostrand.
<span class="lineNum">       3 </span>            : // PYTHIA is licenced under the GNU GPL version 2, see COPYING for details.
<span class="lineNum">       4 </span>            : // Please respect the MCnet Guidelines, see GUIDELINES for details.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : // Function definitions (not found in the header) for the
<span class="lineNum">       7 </span>            : // SigmaProcess class, and classes derived from it.
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;Pythia8/SigmaProcess.h&quot;
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : namespace Pythia8 {
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : //==========================================================================
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : // The SigmaProcess class.
<span class="lineNum">      16 </span>            : // Base class for cross sections.
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : // Constants: could be changed here if desired, but normally should not.
<span class="lineNum">      21 </span>            : // These are of technical nature, as described for each.
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : // Conversion of GeV^{-2} to mb for cross section.
<span class="lineNum">      24 </span>            : const double SigmaProcess::CONVERT2MB    = 0.389380;
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : // The sum of outgoing masses must not be too close to the cm energy.
<span class="lineNum">      27 </span>            : const double SigmaProcess::MASSMARGIN    = 0.1;
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : // Parameters of momentum rescaling procedure: maximally allowed
<span class="lineNum">      30 </span>            : // relative energy error and number of iterations.
<span class="lineNum">      31 </span>            : const double SigmaProcess::COMPRELERR = 1e-10;
<span class="lineNum">      32 </span>            : const int    SigmaProcess::NCOMPSTEP  = 10;
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      35 </span>            : 
<a name="36"><span class="lineNum">      36 </span>            : // Perform simple initialization and store pointers.</a>
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : void SigmaProcess::init(Info* infoPtrIn, Settings* settingsPtrIn,
<span class="lineNum">      39 </span>            :   ParticleData* particleDataPtrIn, Rndm* rndmPtrIn, BeamParticle* beamAPtrIn,
<span class="lineNum">      40 </span>            :   BeamParticle* beamBPtrIn, Couplings* couplingsPtrIn,
<span class="lineNum">      41 </span>            :   SigmaTotal* sigmaTotPtrIn, SLHAinterface* slhaInterfacePtrIn) {
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            :   // Store pointers.
<span class="lineNum">      44 </span><span class="lineNoCov">          0 :   infoPtr         = infoPtrIn;</span>
<span class="lineNum">      45 </span><span class="lineNoCov">          0 :   settingsPtr     = settingsPtrIn;</span>
<span class="lineNum">      46 </span><span class="lineNoCov">          0 :   particleDataPtr = particleDataPtrIn;</span>
<span class="lineNum">      47 </span><span class="lineNoCov">          0 :   rndmPtr         = rndmPtrIn;</span>
<span class="lineNum">      48 </span><span class="lineNoCov">          0 :   beamAPtr        = beamAPtrIn;</span>
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :   beamBPtr        = beamBPtrIn;</span>
<span class="lineNum">      50 </span><span class="lineNoCov">          0 :   couplingsPtr    = couplingsPtrIn;</span>
<span class="lineNum">      51 </span><span class="lineNoCov">          0 :   sigmaTotPtr     = sigmaTotPtrIn;</span>
<span class="lineNum">      52 </span>            :   // Pointer to SLHA object allows semi-internal processes to access
<span class="lineNum">      53 </span>            :   // SLHA blocks via getEntry() methods, see arXiv:1109.5852
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :   slhaPtr         = (slhaInterfacePtrIn != 0) ? &amp;slhaInterfacePtrIn-&gt;slha : 0;</span>
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            :   // Read out some properties of beams to allow shorthand.
<span class="lineNum">      57 </span><span class="lineNoCov">          0 :   idA             = (beamAPtr != 0) ? beamAPtr-&gt;id() : 0;</span>
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :   idB             = (beamBPtr != 0) ? beamBPtr-&gt;id() : 0;</span>
<span class="lineNum">      59 </span><span class="lineNoCov">          0 :   mA              = (beamAPtr != 0) ? beamAPtr-&gt;m() : 0.;</span>
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :   mB              = (beamBPtr != 0) ? beamBPtr-&gt;m() : 0.;</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :   isLeptonA       = (beamAPtr != 0) ? beamAPtr-&gt;isLepton() : false;</span>
<span class="lineNum">      62 </span><span class="lineNoCov">          0 :   isLeptonB       = (beamBPtr != 0) ? beamBPtr-&gt;isLepton() : false;</span>
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :   hasLeptonBeams  = isLeptonA || isLeptonB;</span>
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            :   // K factor, multiplying resolved processes. (But not here for MPI.)
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :   Kfactor         = settingsPtr-&gt;parm(&quot;SigmaProcess:Kfactor&quot;);</span>
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            :   // Maximum incoming quark flavour.
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :   nQuarkIn        = settingsPtr-&gt;mode(&quot;PDFinProcess:nQuarkIn&quot;);</span>
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span>            :   // Medium heavy fermion masses set massless or not in ME expressions.
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :   mcME            = (settingsPtr-&gt;flag(&quot;SigmaProcess:cMassiveME&quot;))</span>
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :                   ? particleDataPtr-&gt;m0(4)  : 0.;</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :   mbME            = (settingsPtr-&gt;flag(&quot;SigmaProcess:bMassiveME&quot;))</span>
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :                   ? particleDataPtr-&gt;m0(5)  : 0.;</span>
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :   mmuME           = (settingsPtr-&gt;flag(&quot;SigmaProcess:muMassiveME&quot;))</span>
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :                   ? particleDataPtr-&gt;m0(13) : 0.;</span>
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :   mtauME          = (settingsPtr-&gt;flag(&quot;SigmaProcess:tauMassiveME&quot;))</span>
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :                   ? particleDataPtr-&gt;m0(15) : 0.;</span>
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span>            :   // Renormalization scale choice.
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :   renormScale1    = settingsPtr-&gt;mode(&quot;SigmaProcess:renormScale1&quot;);</span>
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :   renormScale2    = settingsPtr-&gt;mode(&quot;SigmaProcess:renormScale2&quot;);</span>
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :   renormScale3    = settingsPtr-&gt;mode(&quot;SigmaProcess:renormScale3&quot;);</span>
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :   renormScale3VV  = settingsPtr-&gt;mode(&quot;SigmaProcess:renormScale3VV&quot;);</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :   renormMultFac   = settingsPtr-&gt;parm(&quot;SigmaProcess:renormMultFac&quot;);</span>
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :   renormFixScale  = settingsPtr-&gt;parm(&quot;SigmaProcess:renormFixScale&quot;);</span>
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span>            :   // Factorization scale choice.
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :   factorScale1    = settingsPtr-&gt;mode(&quot;SigmaProcess:factorScale1&quot;);</span>
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :   factorScale2    = settingsPtr-&gt;mode(&quot;SigmaProcess:factorScale2&quot;);</span>
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :   factorScale3    = settingsPtr-&gt;mode(&quot;SigmaProcess:factorScale3&quot;);</span>
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :   factorScale3VV  = settingsPtr-&gt;mode(&quot;SigmaProcess:factorScale3VV&quot;);</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :   factorMultFac   = settingsPtr-&gt;parm(&quot;SigmaProcess:factorMultFac&quot;);</span>
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :   factorFixScale  = settingsPtr-&gt;parm(&quot;SigmaProcess:factorFixScale&quot;);</span>
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            :   // CP violation parameters for the BSM Higgs sector.
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :   higgsH1parity   = settingsPtr-&gt;mode(&quot;HiggsH1:parity&quot;);</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :   higgsH1eta      = settingsPtr-&gt;parm(&quot;HiggsH1:etaParity&quot;);</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :   higgsH1phi      = settingsPtr-&gt;parm(&quot;HiggsH1:phiParity&quot;);</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :   higgsH2parity   = settingsPtr-&gt;mode(&quot;HiggsH2:parity&quot;);</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :   higgsH2eta      = settingsPtr-&gt;parm(&quot;HiggsH2:etaParity&quot;);</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :   higgsH2phi      = settingsPtr-&gt;parm(&quot;HiggsH2:phiParity&quot;);</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :   higgsA3parity   = settingsPtr-&gt;mode(&quot;HiggsA3:parity&quot;);</span>
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :   higgsA3eta      = settingsPtr-&gt;parm(&quot;HiggsA3:etaParity&quot;);</span>
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :   higgsA3phi      = settingsPtr-&gt;parm(&quot;HiggsA3:phiParity&quot;);</span>
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span>            :   // If BSM not switched on then H1 should have SM properties.
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :   if (!settingsPtr-&gt;flag(&quot;Higgs:useBSM&quot;)){</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :     higgsH1parity = 1;</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :     higgsH1eta    = 0.;</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :     higgsH1phi    = M_PI / 2.;</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span>            : // Set up allowed flux of incoming partons.
<span class="lineNum">     120 </span>            : // addBeam: set up PDF's that need to be evaluated for the two beams.
<a name="121"><span class="lineNum">     121 </span>            : // addPair: set up pairs of incoming partons from the two beams.</a>
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            : bool SigmaProcess::initFlux() {
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span>            :   // Reset arrays (in case of several init's in same run).
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :   inBeamA.clear();</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :   inBeamB.clear();</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :   inPair.clear();</span>
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            :   // Read in process-specific channel information.
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :   string fluxType = inFlux();</span>
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            :   // Case with g g incoming state.
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :   if (fluxType == &quot;gg&quot;) {</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :     addBeamA(21);</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :     addBeamB(21);</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :     addPair(21, 21);</span>
<span class="lineNum">     138 </span>            :   }
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            :   // Case with q g incoming state.
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :   else if (fluxType == &quot;qg&quot;) {</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :     for (int i = -nQuarkIn; i &lt;= nQuarkIn; ++i) {</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :       int idNow = (i == 0) ? 21 : i;</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :       addBeamA(idNow);</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :       addBeamB(idNow);</span>
<span class="lineNum">     146 </span>            :     }
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :     for (int idNow = -nQuarkIn; idNow &lt;= nQuarkIn; ++idNow)</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :     if (idNow != 0) {</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :       addPair(idNow, 21);</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :       addPair(21, idNow);</span>
<span class="lineNum">     151 </span>            :     }
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            :   // Case with q q', q qbar' or qbar qbar' incoming state.
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :   else if (fluxType == &quot;qq&quot;) {</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :     for (int idNow = -nQuarkIn; idNow &lt;= nQuarkIn; ++idNow)</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :     if (idNow != 0) {</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :       addBeamA(idNow);</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :       addBeamB(idNow);</span>
<span class="lineNum">     160 </span>            :     }
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :     for (int id1Now = -nQuarkIn; id1Now &lt;= nQuarkIn; ++id1Now)</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :     if (id1Now != 0)</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :     for (int id2Now = -nQuarkIn; id2Now &lt;= nQuarkIn; ++id2Now)</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :     if (id2Now != 0)</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :       addPair(id1Now, id2Now);</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span>            :   // Case with q qbar' incoming state.
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :   else if (fluxType == &quot;qqbar&quot;) {</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :     for (int idNow = -nQuarkIn; idNow &lt;= nQuarkIn; ++idNow)</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :     if (idNow != 0) {</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :       addBeamA(idNow);</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :       addBeamB(idNow);</span>
<span class="lineNum">     174 </span>            :     }
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :     for (int id1Now = -nQuarkIn; id1Now &lt;= nQuarkIn; ++id1Now)</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :     if (id1Now != 0)</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :     for (int id2Now = -nQuarkIn; id2Now &lt;= nQuarkIn; ++id2Now)</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :     if (id2Now != 0 &amp;&amp; id1Now * id2Now &lt; 0)</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :       addPair(id1Now, id2Now);</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            :   // Case with q qbar incoming state.
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :   else if (fluxType == &quot;qqbarSame&quot;) {</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :     for (int idNow = -nQuarkIn; idNow &lt;= nQuarkIn; ++idNow)</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :     if (idNow != 0) {</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :       addBeamA(idNow);</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :       addBeamB(idNow);</span>
<span class="lineNum">     188 </span>            :     }
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :     for (int idNow = -nQuarkIn; idNow &lt;= nQuarkIn; ++idNow)</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :     if (idNow != 0)</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :       addPair(idNow, -idNow);</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            :   // Case with f f', f fbar', fbar fbar' incoming state.
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :   else if (fluxType == &quot;ff&quot;) {</span>
<span class="lineNum">     196 </span>            :     // If beams are leptons then they are also the colliding partons.
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :     if ( isLeptonA &amp;&amp; isLeptonB ) {</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :       addBeamA(idA);</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :       addBeamB(idB);</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :       addPair(idA, idB);</span>
<span class="lineNum">     201 </span>            :     // First beam is lepton and second is hadron.
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :     } else if ( isLeptonA ) {</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :       addBeamA(idA);</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :       for (int idNow = -nQuarkIn; idNow &lt;= nQuarkIn; ++idNow)</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :       if (idNow != 0) {</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :         addBeamB(idNow);</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :         addPair(idA, idNow);</span>
<span class="lineNum">     208 </span>            :       }
<span class="lineNum">     209 </span>            :     // First beam is hadron and second is lepton.
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :     } else if ( isLeptonB ) {</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :       addBeamB(idB);</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :       for (int idNow = -nQuarkIn; idNow &lt;= nQuarkIn; ++idNow)</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :       if (idNow != 0) {</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :         addBeamA(idNow);</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :         addPair(idNow, idB);</span>
<span class="lineNum">     216 </span>            :       }
<span class="lineNum">     217 </span>            :     // Hadron beams gives quarks.
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :       for (int idNow = -nQuarkIn; idNow &lt;= nQuarkIn; ++idNow)</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :       if (idNow != 0) {</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :         addBeamA(idNow);</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :         addBeamB(idNow);</span>
<span class="lineNum">     223 </span>            :       }
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :       for (int id1Now = -nQuarkIn; id1Now &lt;= nQuarkIn; ++id1Now)</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :       if (id1Now != 0)</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :       for (int id2Now = -nQuarkIn; id2Now &lt;= nQuarkIn; ++id2Now)</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :       if (id2Now != 0)</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :         addPair(id1Now, id2Now);</span>
<span class="lineNum">     229 </span>            :     }
<span class="lineNum">     230 </span>            :   }
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            :   // Case with f fbar' generic incoming state.
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :   else if (fluxType == &quot;ffbar&quot;) {</span>
<span class="lineNum">     234 </span>            :     // If beams are leptons then also colliding partons.
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :     if (isLeptonA &amp;&amp; isLeptonB &amp;&amp; idA * idB &lt; 0) {</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :       addBeamA(idA);</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :       addBeamB(idB);</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :       addPair(idA, idB);</span>
<span class="lineNum">     239 </span>            :     // Hadron beams gives quarks.
<span class="lineNum">     240 </span>            :     } else {
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :       for (int idNow = -nQuarkIn; idNow &lt;= nQuarkIn; ++idNow)</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :       if (idNow != 0) {</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :         addBeamA(idNow);</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :         addBeamB(idNow);</span>
<span class="lineNum">     245 </span>            :       }
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :       for (int id1Now = -nQuarkIn; id1Now &lt;= nQuarkIn; ++id1Now)</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :       if (id1Now != 0)</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :       for (int id2Now = -nQuarkIn; id2Now &lt;= nQuarkIn; ++id2Now)</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :       if (id2Now != 0 &amp;&amp; id1Now * id2Now &lt; 0)</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :         addPair(id1Now, id2Now);</span>
<span class="lineNum">     251 </span>            :     }
<span class="lineNum">     252 </span>            :   }
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            :   // Case with f fbar incoming state.
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :   else if (fluxType == &quot;ffbarSame&quot;) {</span>
<span class="lineNum">     256 </span>            :     // If beams are antiparticle pair and leptons then also colliding partons.
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :     if ( idA + idB == 0 &amp;&amp; isLeptonA ) {</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :       addBeamA(idA);</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :       addBeamB(idB);</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :       addPair(idA, idB);</span>
<span class="lineNum">     261 </span>            :     // Else assume both to be hadrons, for better or worse.
<span class="lineNum">     262 </span>            :     } else {
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :       for (int idNow = -nQuarkIn; idNow &lt;= nQuarkIn; ++idNow)</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :       if (idNow != 0) {</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :         addBeamA(idNow);</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :         addBeamB(idNow);</span>
<span class="lineNum">     267 </span>            :       }
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :       for (int idNow = -nQuarkIn; idNow &lt;= nQuarkIn; ++idNow)</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :       if (idNow != 0)</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :         addPair(idNow, -idNow);</span>
<span class="lineNum">     271 </span>            :     }
<span class="lineNum">     272 </span>            :   }
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span>            :   // Case with f fbar' charged(+-1) incoming state.
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :   else if (fluxType == &quot;ffbarChg&quot;) {</span>
<span class="lineNum">     276 </span>            :     // If beams are leptons then also colliding partons.
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :     if ( isLeptonA &amp;&amp; isLeptonB &amp;&amp; abs( particleDataPtr-&gt;chargeType(idA)</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :              + particleDataPtr-&gt;chargeType(idB) ) == 3 ) {</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :       addBeamA(idA);</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :       addBeamB(idB);</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :       addPair(idA, idB);</span>
<span class="lineNum">     282 </span>            :     // Hadron beams gives quarks.
<span class="lineNum">     283 </span>            :     } else {
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :       for (int idNow = -nQuarkIn; idNow &lt;= nQuarkIn; ++idNow)</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :       if (idNow != 0) {</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :         addBeamA(idNow);</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :         addBeamB(idNow);</span>
<span class="lineNum">     288 </span>            :       }
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :       for (int id1Now = -nQuarkIn; id1Now &lt;= nQuarkIn; ++id1Now)</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :       if (id1Now != 0)</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :       for (int id2Now = -nQuarkIn; id2Now &lt;= nQuarkIn; ++id2Now)</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :       if (id2Now != 0 &amp;&amp; id1Now * id2Now &lt; 0</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :         &amp;&amp; (abs(id1Now) + abs(id2Now))%2 == 1) addPair(id1Now, id2Now);</span>
<span class="lineNum">     294 </span>            :     }
<span class="lineNum">     295 </span>            :   }
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span>            :   // Case with f gamma incoming state.
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :   else if (fluxType == &quot;fgm&quot;) {</span>
<span class="lineNum">     299 </span>            :     // Fermion from incoming side A.
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :     if ( isLeptonA ) {</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :       addBeamA(idA);</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :       addPair(idA, 22);</span>
<span class="lineNum">     303 </span>            :     } else {
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :       for (int idNow = -nQuarkIn; idNow &lt;= nQuarkIn; ++idNow)</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :       if (idNow != 0) {</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :         addBeamA(idNow);</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :         addPair(idNow, 22);</span>
<span class="lineNum">     308 </span>            :       }
<span class="lineNum">     309 </span>            :     }
<span class="lineNum">     310 </span>            :     // Fermion from incoming side B.
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :     if ( isLeptonB ) {</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :       addBeamB( idB);</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :       addPair(22, idB);</span>
<span class="lineNum">     314 </span>            :     } else {
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :       for (int idNow = -nQuarkIn; idNow &lt;= nQuarkIn; ++idNow)</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :       if (idNow != 0) {</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :         addBeamB(idNow);</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :         addPair(22, idNow);</span>
<span class="lineNum">     319 </span>            :       }
<span class="lineNum">     320 </span>            :     }
<span class="lineNum">     321 </span>            :     // Photons in the beams.
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :     addBeamA(22);</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :     addBeamB(22);</span>
<span class="lineNum">     324 </span>            :   }
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span>            :   // Case with gamma gamma incoming state.
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :   else if (fluxType == &quot;ggm&quot;) {</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :     addBeamA(21);</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :     addBeamA(22);</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :     addBeamB(21);</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :     addBeamB(22);</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :     addPair(21, 22);</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :     addPair(22, 21);</span>
<span class="lineNum">     334 </span>            :   }
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            :   // Case with gamma gamma incoming state.
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :   else if (fluxType == &quot;gmgm&quot;) {</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :     addBeamA(22);</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :     addBeamB(22);</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :     addPair(22, 22);</span>
<span class="lineNum">     341 </span>            :   }
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span>            :   // Unrecognized fluxType is bad sign. Else done.
<span class="lineNum">     344 </span>            :   else {
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :     infoPtr-&gt;errorMsg(&quot;Error in SigmaProcess::initFlux: &quot;</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :     &quot;unrecognized inFlux type&quot;, fluxType);</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     348 </span>            :   }
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     352 </span>            : 
<span class="lineNum">     353 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     354 </span>            : 
<a name="355"><span class="lineNum">     355 </span>            : // Convolute matrix-element expression(s) with parton flux and K factor.</a>
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span>            : double SigmaProcess::sigmaPDF() {
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span>            :   // Evaluate and store the required parton densities.
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :   for (int j = 0; j &lt; sizeBeamA(); ++j)</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :     inBeamA[j].pdf = beamAPtr-&gt;xfHard( inBeamA[j].id, x1Save, Q2FacSave);</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :   for (int j = 0; j &lt; sizeBeamB(); ++j)</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :     inBeamB[j].pdf = beamBPtr-&gt;xfHard( inBeamB[j].id, x2Save, Q2FacSave);</span>
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span>            :   // Loop over allowed incoming channels.
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :   sigmaSumSave = 0.;</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; sizePair(); ++i) {</span>
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span>            :     // Evaluate hard-scattering cross section. Include K factor.
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :     inPair[i].pdfSigma = Kfactor</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :                        * sigmaHatWrap(inPair[i].idA, inPair[i].idB);</span>
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            :     // Multiply by respective parton densities.
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :     for (int j = 0; j &lt; sizeBeamA(); ++j)</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :     if (inPair[i].idA == inBeamA[j].id) {</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :       inPair[i].pdfA      = inBeamA[j].pdf;</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :       inPair[i].pdfSigma *= inBeamA[j].pdf;</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     379 </span>            :     }
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :     for (int j = 0; j &lt; sizeBeamB(); ++j)</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :     if (inPair[i].idB == inBeamB[j].id) {</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :       inPair[i].pdfB      = inBeamB[j].pdf;</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :       inPair[i].pdfSigma *= inBeamB[j].pdf;</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     385 </span>            :     }
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span>            :     // Sum for all channels.
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :     sigmaSumSave += inPair[i].pdfSigma;</span>
<span class="lineNum">     389 </span>            :   }
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span>            :   // Done.
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :   return sigmaSumSave;</span>
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span>            : }
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     397 </span>            : 
<a name="398"><span class="lineNum">     398 </span>            : // Select incoming parton channel and extract parton densities (resolved).</a>
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span>            : void SigmaProcess::pickInState(int id1in, int id2in) {
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            :   // Multiparton interactions: partons already selected.
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :   if (id1in != 0 &amp;&amp; id2in != 0) {</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :     id1 = id1in;</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :     id2 = id2in;</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     407 </span>            :   }
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            :   // Pick channel. Extract channel flavours and pdf's.
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :   double sigmaRand =  sigmaSumSave * rndmPtr-&gt;flat();</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; sizePair(); ++i) {</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :     sigmaRand -= inPair[i].pdfSigma;</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :     if (sigmaRand &lt;= 0.) {</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :       id1      = inPair[i].idA;</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :       id2      = inPair[i].idB;</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :       pdf1Save = inPair[i].pdfA;</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :       pdf2Save = inPair[i].pdfB;</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     419 </span>            :     }
<span class="lineNum">     420 </span>            :   }
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     425 </span>            : 
<a name="426"><span class="lineNum">     426 </span>            : // Calculate incoming modified masses and four-vectors for matrix elements.</a>
<span class="lineNum">     427 </span>            : 
<span class="lineNum">     428 </span>            : bool SigmaProcess::setupForMEin() {
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            :   // Initially assume it will work out to set up modified kinematics.
<span class="lineNum">     431 </span>            :   bool allowME = true;
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span>            :   // Correct incoming c, b, mu and tau to be massive or not.
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :   mME[0] = 0.;</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :   int id1Tmp = abs(id1);</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :   if (id1Tmp ==  4) mME[0] = mcME;</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :   if (id1Tmp ==  5) mME[0] = mbME;</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :   if (id1Tmp == 13) mME[0] = mmuME;</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :   if (id1Tmp == 15) mME[0] = mtauME;</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :   mME[1] = 0.;</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :   int id2Tmp = abs(id2);</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :   if (id2Tmp ==  4) mME[1] = mcME;</span>
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :   if (id2Tmp ==  5) mME[1] = mbME;</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :   if (id2Tmp == 13) mME[1] = mmuME;</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :   if (id2Tmp == 15) mME[1] = mtauME;</span>
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span>            :   // If kinematically impossible return to massless case, but set error.
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :   if (mME[0] + mME[1] &gt;= mH) {</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :     mME[0] = 0.;</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :     mME[1] = 0.;</span>
<span class="lineNum">     451 </span>            :     allowME = false;
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            :   // Do incoming two-body kinematics for massless or massive cases.
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :   if (mME[0] == 0. &amp;&amp; mME[1] == 0.) {</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :   pME[0] = 0.5 * mH * Vec4( 0., 0.,  1., 1.);</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :   pME[1] = 0.5 * mH * Vec4( 0., 0., -1., 1.);</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :     double e0   = 0.5 * (mH * mH + mME[0] * mME[0] - mME[1] * mME[1]) / mH;</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :     double pz0  = sqrtpos(e0 * e0 - mME[0] * mME[0]);</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :     pME[0] = Vec4( 0., 0.,  pz0, e0);</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :     pME[1] = Vec4( 0., 0., -pz0, mH - e0);</span>
<span class="lineNum">     463 </span>            :   }
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            :   // Done.
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :   return allowME;</span>
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span>            : }
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     471 </span>            : 
<a name="472"><span class="lineNum">     472 </span>            : // Evaluate weight for W decay distribution in t -&gt; W b -&gt; f fbar b.</a>
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span>            : double SigmaProcess::weightTopDecay( Event&amp; process, int iResBeg,
<span class="lineNum">     475 </span>            :   int iResEnd) {
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span>            :   // If not pair W d/s/b and mother t then return unit weight.
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :   if (iResEnd - iResBeg != 1) return 1.;</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :   int iW1  = iResBeg;</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :   int iB2  = iResBeg + 1;</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :   int idW1 = process[iW1].idAbs();</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :   int idB2 = process[iB2].idAbs();</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :   if (idW1 != 24) {</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :     swap(iW1, iB2);</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :     swap(idW1, idB2);</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :   if (idW1 != 24 || (idB2 != 1 &amp;&amp; idB2 != 3 &amp;&amp; idB2 != 5)) return 1.;</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :   int iT   = process[iW1].mother1();</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :   if (iT &lt;= 0 || process[iT].idAbs() != 6) return 1.;</span>
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span>            :   // Find sign-matched order of W decay products.
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :   int iF    = process[iW1].daughter1();</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :   int iFbar = process[iW1].daughter2();</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :   if (iFbar - iF != 1) return 1.;</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :   if (process[iT].id() * process[iF].id() &lt; 0) swap(iF, iFbar);</span>
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span>            :   // Weight and maximum weight.
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :   double wt    = (process[iT].p() * process[iFbar].p())</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :                * (process[iF].p() * process[iB2].p());</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :   double wtMax = ( pow4(process[iT].m()) - pow4(process[iW1].m()) ) / 8.;</span>
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span>            :   // Done.
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :   return wt / wtMax;</span>
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span>            : // Evaluate weight for Z0/W+- decay distributions in H -&gt; Z0/W+ Z0/W- -&gt; 4f
<a name="510"><span class="lineNum">     510 </span>            : // and H -&gt; gamma Z0 -&gt; gamma f fbar.</a>
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span>            : double SigmaProcess::weightHiggsDecay( Event&amp; process, int iResBeg,
<span class="lineNum">     513 </span>            :   int iResEnd) {
<span class="lineNum">     514 </span>            : 
<span class="lineNum">     515 </span>            :   // If not pair Z0 Z0, W+ W- or gamma Z0 then return unit weight.
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :   if (iResEnd - iResBeg != 1) return 1.;</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :   int iZW1  = iResBeg;</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :   int iZW2  = iResBeg + 1;</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :   int idZW1 = process[iZW1].id();</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :   int idZW2 = process[iZW2].id();</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :   if (idZW1 &lt; 0 || idZW2 == 22) {</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :     swap(iZW1, iZW2);</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :     swap(idZW1, idZW2);</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :   if ( (idZW1 != 23 || idZW2 != 23) &amp;&amp; (idZW1 != 24 || idZW2 != -24)</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :     &amp;&amp; (idZW1 != 22 || idZW2 != 23) ) return 1.;</span>
<span class="lineNum">     527 </span>            : 
<span class="lineNum">     528 </span>            :   // If mother is not Higgs then return unit weight.
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :   int iH  = process[iZW1].mother1();</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :   if (iH &lt;= 0) return 1.;</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :   int idH = process[iH].id();</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :   if (idH != 25 &amp;&amp; idH != 35 &amp;&amp; idH !=36) return 1.;</span>
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span>            :   // H -&gt; gamma Z0 -&gt; gamma f fbar is 1 + cos^2(theta) in Z rest frame.
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :   if (idZW1 == 22) {</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :     int i5 = process[iZW2].daughter1();</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :     int i6 = process[iZW2].daughter2();</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :     double pgmZ = process[iZW1].p() * process[iZW2].p();</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :     double pgm5 = process[iZW1].p() * process[i5].p();</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :     double pgm6 = process[iZW1].p() * process[i6].p();</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :     return (pow2(pgm5) + pow2(pgm6)) / pow2(pgmZ);</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     543 </span>            : 
<span class="lineNum">     544 </span>            :   // Parameters depend on Higgs type: H0(H_1), H^0(H_2) or A^0(H_3).
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :   int    higgsParity = higgsH1parity;</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :   double higgsEta    = higgsH1eta;</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :   if (idH == 35) {</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :     higgsParity      = higgsH2parity;</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :     higgsEta         = higgsH2eta;</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :   } else if (idH == 36) {</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :     higgsParity      = higgsA3parity;</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :     higgsEta         = higgsA3eta;</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     554 </span>            : 
<span class="lineNum">     555 </span>            :   // Option with isotropic decays (also for pseudoscalar fermion couplings).
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :   if (higgsParity == 0 || higgsParity &gt; 3) return 1.;</span>
<span class="lineNum">     557 </span>            : 
<span class="lineNum">     558 </span>            :   // Maximum and initial weight.
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :   double wtMax = pow4(process[iH].m());</span>
<span class="lineNum">     560 </span>            :   double wt    = wtMax;
<span class="lineNum">     561 </span>            : 
<span class="lineNum">     562 </span>            :   // Find sign-matched order of Z0/W+- decay products.
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :   int i3 = process[iZW1].daughter1();</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :   int i4 = process[iZW1].daughter2();</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :   if (process[i3].id() &lt; 0) swap( i3, i4);</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :   int i5 = process[iZW2].daughter1();</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :   int i6 = process[iZW2].daughter2();</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :   if (process[i5].id() &lt; 0) swap( i5, i6);</span>
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span>            :   // Evaluate four-vector products and find masses..
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :   double p35  = 2. * process[i3].p() * process[i5].p();</span>
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :   double p36  = 2. * process[i3].p() * process[i6].p();</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :   double p45  = 2. * process[i4].p() * process[i5].p();</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :   double p46  = 2. * process[i4].p() * process[i6].p();</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :   double p34  = 2. * process[i3].p() * process[i4].p();</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :   double p56  = 2. * process[i5].p() * process[i6].p();</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :   double mZW1 = process[iZW1].m();</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :   double mZW2 = process[iZW2].m();</span>
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span>            :   // For mixed CP states need epsilon product and gauge boson masses.
<span class="lineNum">     581 </span>            :   double epsilonProd = 0.;
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :   if (higgsParity == 3) {</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :     double p[4][4];</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; 4; ++i) {</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :       int         ii = i3;</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :       if (i == 1) ii = i4;</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :       if (i == 2) ii = i5;</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :       if (i == 3) ii = i6;</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :       p[i][0] = process[ii].e();</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :       p[i][1] = process[ii].px();</span>
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :       p[i][2] = process[ii].py();</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :       p[i][3] = process[ii].pz();</span>
<span class="lineNum">     593 </span>            :     }
<span class="lineNum">     594 </span>            :     epsilonProd
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :       = p[0][0]*p[1][1]*p[2][2]*p[3][3] - p[0][0]*p[1][1]*p[2][3]*p[3][2]</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :       - p[0][0]*p[1][2]*p[2][1]*p[3][3] + p[0][0]*p[1][2]*p[2][3]*p[3][1]</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :       + p[0][0]*p[1][3]*p[2][1]*p[3][2] - p[0][0]*p[1][3]*p[2][2]*p[3][1]</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :       - p[0][1]*p[1][0]*p[2][2]*p[3][3] + p[0][1]*p[1][0]*p[2][3]*p[3][2]</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :       + p[0][1]*p[1][2]*p[2][0]*p[3][3] - p[0][1]*p[1][2]*p[2][3]*p[3][0]</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :       - p[0][1]*p[1][3]*p[2][0]*p[3][2] + p[0][1]*p[1][3]*p[2][2]*p[3][0]</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :       + p[0][2]*p[1][0]*p[2][1]*p[3][3] - p[0][2]*p[1][0]*p[2][3]*p[3][1]</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :       - p[0][2]*p[1][1]*p[2][0]*p[3][3] + p[0][2]*p[1][1]*p[2][3]*p[3][0]</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :       + p[0][2]*p[1][3]*p[2][0]*p[3][1] - p[0][2]*p[1][3]*p[2][1]*p[3][0]</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :       - p[0][3]*p[1][0]*p[2][1]*p[3][2] + p[0][3]*p[1][0]*p[2][2]*p[3][1]</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :       + p[0][3]*p[1][1]*p[2][0]*p[3][2] - p[0][3]*p[1][1]*p[2][2]*p[3][0]</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :       - p[0][3]*p[1][2]*p[2][0]*p[3][1] + p[0][3]*p[1][2]*p[2][1]*p[3][0];</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span>            :   // Z0 Z0 decay: vector and axial couplings of two fermion pairs.
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :   if (idZW1 == 23) {</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :     double vf1 = couplingsPtr-&gt;vf(process[i3].idAbs());</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :     double af1 = couplingsPtr-&gt;af(process[i3].idAbs());</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :     double vf2 = couplingsPtr-&gt;vf(process[i5].idAbs());</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :     double af2 = couplingsPtr-&gt;af(process[i5].idAbs());</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :     double va12asym = 4. * vf1 * af1 * vf2 * af2</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :       / ( (vf1*vf1 + af1*af1) * (vf2*vf2 + af2*af2) );</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :     double vh = 1;</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :     double ah = higgsEta / pow2( particleDataPtr-&gt;m0(23) );</span>
<span class="lineNum">     619 </span>            : 
<span class="lineNum">     620 </span>            :     // Normal CP-even decay.
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :     if (higgsParity == 1) wt = 8. * (1. + va12asym) * p35 * p46</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :       + 8. * (1. - va12asym) * p36 * p45;</span>
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span>            :     // CP-odd decay (normal for A0(H_3)).
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :     else if (higgsParity == 2) wt = ( pow2(p35 + p46)</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :       + pow2(p36 + p45) - 2. * p34 * p56</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :       - 2. * pow2(p35 * p46 - p36 * p45) / (p34 * p56)</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :       + va12asym * (p35 + p36 - p45 - p46) * (p35 + p45 - p36 - p46) )</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :       / (1. +  va12asym);</span>
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span>            :     // Mixed CP states.
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :     else wt = 32. * ( 0.25 * pow2(vh) * ( (1. + va12asym) * p35 * p46</span>
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :       + (1. - va12asym) * p36 * p45 ) - 0.5 * vh * ah * epsilonProd</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :       * ( (1. + va12asym) * (p35 + p46) - (1. - va12asym) * (p36 + p45) )</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :       + 0.0625 * pow2(ah) * (-2. * pow2(p34 * p56)</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :       - 2. * pow2(p35 * p46 - p36 * p45)</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :       + p34 * p56 * (pow2(p35 + p46) + pow2(p36 + p45))</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :       + va12asym * p34 * p56 * (p35 + p36 - p45 - p46)</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :       * (p35 + p45 - p36 - p46) ) )</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :       / ( pow2(vh) + 2. * abs(vh * ah) * mZW1 * mZW2</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :       + 2. * pow2(ah * mZW1 * mZW2) * (1. + va12asym) );</span>
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span>            :   // W+ W- decay.
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :   } else if (idZW1 == 24) {</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :     double vh = 1;</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :     double ah = higgsEta / pow2( particleDataPtr-&gt;m0(24) );</span>
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span>            :     // Normal CP-even decay.
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :     if (higgsParity == 1) wt = 16. * p35 * p46;</span>
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span>            :     // CP-odd decay (normal for A0(H_3)).
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :     else if (higgsParity == 2) wt = 0.5 * ( pow2(p35 + p46)</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :       + pow2(p36 + p45) - 2. * p34 * p56</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :       - 2. * pow2(p35 * p46 - p36 * p45) / (p34 * p56)</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :       + (p35 + p36 - p45 - p46) * (p35 + p45 - p36 - p46) );</span>
<span class="lineNum">     656 </span>            : 
<span class="lineNum">     657 </span>            :     // Mixed CP states.
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :     else wt = 32. * ( 0.25 * pow2(vh) * 2. * p35 * p46</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :       - 0.5 * vh * ah * epsilonProd * 2. * (p35 + p46)</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :       + 0.0625 * pow2(ah) * (-2. * pow2(p34 * p56)</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :       - 2. * pow2(p35 * p46 - p36 * p45)</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :       + p34 * p56 * (pow2(p35 + p46) + pow2(p36 + p45))</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :       + p34 * p56 * (p35 + p36 - p45 - p46) * (p35 + p45 - p36 - p46) ) )</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :       / ( pow2(vh) + 2. * abs(vh * ah) * mZW1 * mZW2</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :       + 2. * pow2(ah * mZW1 * mZW2) );</span>
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span>            :   // Done.
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :   return wt / wtMax;</span>
<span class="lineNum">     670 </span>            : 
<span class="lineNum">     671 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     672 </span>            : 
<span class="lineNum">     673 </span>            : //==========================================================================
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span>            : // The Sigma1Process class.
<span class="lineNum">     676 </span>            : // Base class for resolved 2 -&gt; 1 cross sections; derived from SigmaProcess.
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span>            : // Wrapper to sigmaHat, to (a) store current incoming flavours,
<span class="lineNum">     681 </span>            : // (b) convert from GeV^-2 to mb where required, and
<a name="682"><span class="lineNum">     682 </span>            : // (c) convert from |M|^2 to d(sigmaHat)/d(tHat) where required.</a>
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span>            : double Sigma1Process::sigmaHatWrap(int id1in, int id2in) {
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :   id1 = id1in;</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :   id2 = id2in;</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :   double sigmaTmp = sigmaHat();</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :   if (convertM2()) {</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :     sigmaTmp /= 2. * sH;</span>
<span class="lineNum">     691 </span>            :     // Convert 2 * pi * delta(p^2 - m^2) to Breit-Wigner with same area.
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :     int idTmp     = resonanceA();</span>
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :     double mTmp   = particleDataPtr-&gt;m0(idTmp);</span>
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :     double GamTmp = particleDataPtr-&gt;mWidth(idTmp);</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :     sigmaTmp *= 2. * mTmp * GamTmp / ( pow2(sH - mTmp * mTmp)</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :       + pow2(mTmp * GamTmp) );</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :   if (convert2mb()) sigmaTmp *= CONVERT2MB;</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :   return sigmaTmp;</span>
<span class="lineNum">     700 </span>            : 
<span class="lineNum">     701 </span>            : }
<span class="lineNum">     702 </span>            : 
<span class="lineNum">     703 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     704 </span>            : 
<a name="705"><span class="lineNum">     705 </span>            : // Input and complement kinematics for resolved 2 -&gt; 1 process.</a>
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span>            : void Sigma1Process::store1Kin( double x1in, double x2in, double sHin) {
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span>            :   // Default value only sensible for these processes.
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :   swapTU = false;</span>
<span class="lineNum">     711 </span>            : 
<span class="lineNum">     712 </span>            :   // Incoming parton momentum fractions and sHat.
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :   x1Save = x1in;</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :   x2Save = x2in;</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :   sH     = sHin;</span>
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :   mH     = sqrt(sH);</span>
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :   sH2    = sH * sH;</span>
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span>            :   // Different options for renormalization scale, but normally sHat.
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :   Q2RenSave                        = renormMultFac * sH;</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :   if (renormScale1 == 2) Q2RenSave = renormFixScale;</span>
<span class="lineNum">     722 </span>            : 
<span class="lineNum">     723 </span>            :   // Different options for factorization scale, but normally sHat.
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :   Q2FacSave                        = factorMultFac * sH;</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :   if (factorScale1 == 2) Q2FacSave = factorFixScale;</span>
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span>            :   // Evaluate alpha_strong and alpha_EM.
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :   alpS   = couplingsPtr-&gt;alphaS(Q2RenSave);</span>
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :   alpEM  = couplingsPtr-&gt;alphaEM(Q2RenSave);</span>
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     732 </span>            : 
<span class="lineNum">     733 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     734 </span>            : 
<a name="735"><span class="lineNum">     735 </span>            : // Calculate modified masses and four-vectors for matrix elements.</a>
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span>            : bool Sigma1Process::setupForME() {
<span class="lineNum">     738 </span>            : 
<span class="lineNum">     739 </span>            :   // Common initial-state handling.
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :   bool allowME = setupForMEin();</span>
<span class="lineNum">     741 </span>            : 
<span class="lineNum">     742 </span>            :   // Final state trivial here.
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :   mME[2] = mH;</span>
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :   pME[2] = Vec4( 0., 0., 0., mH);</span>
<span class="lineNum">     745 </span>            : 
<span class="lineNum">     746 </span>            :   // Done.
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :   return allowME;</span>
<span class="lineNum">     748 </span>            : 
<span class="lineNum">     749 </span>            : }
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span>            : //==========================================================================
<span class="lineNum">     752 </span>            : 
<span class="lineNum">     753 </span>            : // The Sigma2Process class.
<span class="lineNum">     754 </span>            : // Base class for resolved 2 -&gt; 2 cross sections; derived from SigmaProcess.
<span class="lineNum">     755 </span>            : 
<span class="lineNum">     756 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     757 </span>            : 
<a name="758"><span class="lineNum">     758 </span>            : // Input and complement kinematics for resolved 2 -&gt; 2 process.</a>
<span class="lineNum">     759 </span>            : 
<span class="lineNum">     760 </span>            : void Sigma2Process::store2Kin( double x1in, double x2in, double sHin,
<span class="lineNum">     761 </span>            :   double tHin, double m3in, double m4in, double runBW3in, double runBW4in) {
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span>            :   // Default ordering of particles 3 and 4.
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :   swapTU   = false;</span>
<span class="lineNum">     765 </span>            : 
<span class="lineNum">     766 </span>            :   // Incoming parton momentum fractions.
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :   x1Save   = x1in;</span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :   x2Save   = x2in;</span>
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span>            :   // Incoming masses and their squares.
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :   bool masslessKin = (id3Mass() == 0) &amp;&amp; (id4Mass() == 0);</span>
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :   if (masslessKin) {</span>
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :     m3     = 0.;</span>
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :     m4     = 0.;</span>
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :     m3     = m3in;</span>
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :     m4     = m4in;</span>
<span class="lineNum">     778 </span>            :   }
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :   mSave[3] = m3;</span>
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :   mSave[4] = m4;</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :   s3       = m3 * m3;</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :   s4       = m4 * m4;</span>
<span class="lineNum">     783 </span>            : 
<span class="lineNum">     784 </span>            :   // Standard Mandelstam variables and their squares.
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :   sH       = sHin;</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :   tH       = tHin;</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :   uH       = (masslessKin) ? -(sH + tH) : s3 + s4 - (sH + tH);</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :   mH       = sqrt(sH);</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :   sH2      = sH * sH;</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :   tH2      = tH * tH;</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :   uH2      = uH * uH;</span>
<span class="lineNum">     792 </span>            : 
<span class="lineNum">     793 </span>            :   // The nominal Breit-Wigner factors with running width.
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :   runBW3   = runBW3in;</span>
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :   runBW4   = runBW4in;</span>
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span>            :   // Calculate squared transverse momentum.
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :   pT2 = (masslessKin) ?  tH * uH / sH : (tH * uH - s3 * s4) / sH;</span>
<span class="lineNum">     799 </span>            : 
<span class="lineNum">     800 </span>            :   // Special case: pick scale as if 2 -&gt; 1 process in disguise.
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :   if (isSChannel()) {</span>
<span class="lineNum">     802 </span>            : 
<span class="lineNum">     803 </span>            :     // Different options for renormalization scale, but normally sHat.
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :     Q2RenSave                        = renormMultFac * sH;</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :     if (renormScale1 == 2) Q2RenSave = renormFixScale;</span>
<span class="lineNum">     806 </span>            : 
<span class="lineNum">     807 </span>            :     // Different options for factorization scale, but normally sHat.
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :     Q2FacSave                        = factorMultFac * sH;</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :     if (factorScale1 == 2) Q2FacSave = factorFixScale;</span>
<span class="lineNum">     810 </span>            : 
<span class="lineNum">     811 </span>            :   // Normal case with &quot;true&quot; 2 -&gt; 2.
<span class="lineNum">     812 </span>            :   } else {
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span>            :     // Different options for renormalization scale.
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :     if (masslessKin)            Q2RenSave = (renormScale2 &lt; 4) ? pT2 : sH;</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :     else if (renormScale2 == 1) Q2RenSave = pT2 + min(s3, s4);</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :     else if (renormScale2 == 2) Q2RenSave = sqrt((pT2 + s3) * (pT2 + s4));</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :     else if (renormScale2 == 3) Q2RenSave = pT2 + 0.5 * (s3 + s4);</span>
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :     else                        Q2RenSave = sH;</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :     Q2RenSave                            *= renormMultFac;</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :     if      (renormScale2 == 5) Q2RenSave = renormFixScale;</span>
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span>            :     // Different options for factorization scale.
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :     if (masslessKin)            Q2FacSave = (factorScale2 &lt; 4) ? pT2 : sH;</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :     else if (factorScale2 == 1) Q2FacSave = pT2 + min(s3, s4);</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :     else if (factorScale2 == 2) Q2FacSave = sqrt((pT2 + s3) * (pT2 + s4));</span>
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :     else if (factorScale2 == 3) Q2FacSave = pT2 + 0.5 * (s3 + s4);</span>
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :     else                        Q2FacSave = sH;</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :     Q2FacSave                            *= factorMultFac;</span>
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :     if      (factorScale2 == 5) Q2FacSave = factorFixScale;</span>
<span class="lineNum">     831 </span>            :   }
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span>            :   // Evaluate alpha_strong and alpha_EM.
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :   alpS  = couplingsPtr-&gt;alphaS(Q2RenSave);</span>
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :   alpEM = couplingsPtr-&gt;alphaEM(Q2RenSave);</span>
<span class="lineNum">     836 </span>            : 
<span class="lineNum">     837 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     840 </span>            : 
<a name="841"><span class="lineNum">     841 </span>            : // As above, special kinematics for multiparton interactions.</a>
<span class="lineNum">     842 </span>            : 
<span class="lineNum">     843 </span>            : void Sigma2Process::store2KinMPI( double x1in, double x2in,
<span class="lineNum">     844 </span>            :   double sHin, double tHin, double uHin, double alpSin, double alpEMin,
<span class="lineNum">     845 </span>            :   bool needMasses, double m3in, double m4in) {
<span class="lineNum">     846 </span>            : 
<span class="lineNum">     847 </span>            :   // Default ordering of particles 3 and 4.
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :   swapTU    = false;</span>
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span>            :   // Incoming x values.
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :   x1Save    = x1in;</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :   x2Save    = x2in;</span>
<span class="lineNum">     853 </span>            : 
<span class="lineNum">     854 </span>            :   // Standard Mandelstam variables and their squares.
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :   sH        = sHin;</span>
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :   tH        = tHin;</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :   uH        = uHin;</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :   mH        = sqrt(sH);</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :   sH2       = sH * sH;</span>
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :   tH2       = tH * tH;</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :   uH2       = uH * uH;</span>
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span>            :   // Strong and electroweak couplings.
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :   alpS      = alpSin;</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :   alpEM     = alpEMin;</span>
<span class="lineNum">     866 </span>            : 
<span class="lineNum">     867 </span>            :   // Assume vanishing masses. (Will be modified in final kinematics.)
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :   m3        = 0.;</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :   s3        = 0.;</span>
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :   m4        = 0.;</span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :   s4        = 0.;</span>
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :   sHBeta    = sH;</span>
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            :   // Scattering angle.
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :   cosTheta  = (tH - uH) / sH;</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :   sinTheta  = 2. * sqrtpos( tH * uH ) / sH;</span>
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span>            :   // In some cases must use masses and redefine meaning of tHat and uHat.
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :   if (needMasses) {</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :     m3      = m3in;</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :     s3      = m3 * m3;</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :     m4      = m4in;</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :     s4      = m4 * m4;</span>
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :     sHMass  = sH - s3 - s4;</span>
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :     sHBeta  = sqrtpos(sHMass*sHMass - 4. * s3 * s4);</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :     tH      = -0.5 * (sHMass - sHBeta * cosTheta);</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :     uH      = -0.5 * (sHMass + sHBeta * cosTheta);</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :     tH2     = tH * tH;</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :     uH2     = uH * uH;</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     891 </span>            : 
<span class="lineNum">     892 </span>            :   // pT2 with masses (at this stage) included.
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :   pT2Mass   = 0.25 * sHBeta * pow2(sinTheta);</span>
<span class="lineNum">     894 </span>            : 
<span class="lineNum">     895 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     896 </span>            : 
<span class="lineNum">     897 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     898 </span>            : 
<a name="899"><span class="lineNum">     899 </span>            : // Perform kinematics for a multiparton interaction, including a rescattering.</a>
<span class="lineNum">     900 </span>            : 
<span class="lineNum">     901 </span>            : bool Sigma2Process::final2KinMPI( int i1Res, int i2Res, Vec4 p1Res, Vec4 p2Res,
<span class="lineNum">     902 </span>            :   double m1Res, double m2Res) {
<span class="lineNum">     903 </span>            : 
<span class="lineNum">     904 </span>            :   // Have to set flavours and colours.
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :   setIdColAcol();</span>
<span class="lineNum">     906 </span>            : 
<span class="lineNum">     907 </span>            :   // Check that masses of outgoing particles not too big.
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :   m3           = particleDataPtr-&gt;m0(idSave[3]);</span>
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :   m4           = particleDataPtr-&gt;m0(idSave[4]);</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :   mH           = sqrt(sH);</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :   if (m3 + m4 + MASSMARGIN &gt; mH) return false;</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :   s3           = m3 * m3;</span>
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :   s4           = m4 * m4;</span>
<span class="lineNum">     914 </span>            : 
<span class="lineNum">     915 </span>            :   // Do kinematics of the production; without or with masses.
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :   double e1In  = 0.5 * mH;</span>
<span class="lineNum">     917 </span>            :   double e2In  = e1In;
<span class="lineNum">     918 </span>            :   double pzIn  = e1In;
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :   if (i1Res &gt; 0 || i2Res &gt; 0) {</span>
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :     double s1  = m1Res * m1Res;</span>
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :     double s2  = m2Res * m2Res;</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :     e1In       = 0.5 * (sH + s1 - s2) / mH;</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :     e2In       = 0.5 * (sH + s2 - s1) / mH;</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :     pzIn       = sqrtpos( e1In*e1In - s1 );</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     926 </span>            : 
<span class="lineNum">     927 </span>            :   // Do kinematics of the decay.
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :   double e3    = 0.5 * (sH + s3 - s4) / mH;</span>
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :   double e4    = 0.5 * (sH + s4 - s3) / mH;</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :   double pAbs  = sqrtpos( e3*e3 - s3 );</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :   phi          = 2. * M_PI * rndmPtr-&gt;flat();</span>
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :   double pZ    = pAbs * cosTheta;</span>
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :   pTFin        = pAbs * sinTheta;</span>
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :   double pX    = pTFin * sin(phi);</span>
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :   double pY    = pTFin * cos(phi);</span>
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :   double scale = 0.5 * mH * sinTheta;</span>
<span class="lineNum">     937 </span>            : 
<span class="lineNum">     938 </span>            :   // Fill particle info.
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :   int status1  = (i1Res == 0) ? -31 : -34;</span>
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :   int status2  = (i2Res == 0) ? -31 : -34;</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :   parton[1]    = Particle( idSave[1], status1, 0, 0, 3, 4,</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :     colSave[1], acolSave[1],  0.,  0.,  pzIn, e1In, m1Res, scale);</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :   parton[2]    = Particle( idSave[2], status2, 0, 0, 3, 4,</span>
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :     colSave[2], acolSave[2],  0.,  0., -pzIn, e2In, m2Res, scale);</span>
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :   parton[3]    = Particle( idSave[3],      33, 1, 2, 0, 0,</span>
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :     colSave[3], acolSave[3],  pX,  pY,    pZ,   e3,    m3, scale);</span>
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :   parton[4]    = Particle( idSave[4],      33, 1, 2, 0, 0,</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :     colSave[4], acolSave[4], -pX, -pY,   -pZ,   e4,    m4, scale);</span>
<span class="lineNum">     949 </span>            : 
<span class="lineNum">     950 </span>            :   // Boost particles from subprocess rest frame to event rest frame.
<span class="lineNum">     951 </span>            :   // Normal multiparton interaction: only longitudinal boost.
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :   if (i1Res == 0 &amp;&amp; i2Res == 0) {</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :     double betaZ = (x1Save - x2Save) / (x1Save + x2Save);</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :     for (int i = 1; i &lt;= 4; ++i) parton[i].bst(0., 0., betaZ);</span>
<span class="lineNum">     955 </span>            :   // Rescattering: generic rotation and boost required.
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :     RotBstMatrix M;</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :     M.fromCMframe( p1Res, p2Res);</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :     for (int i = 1; i &lt;= 4; ++i) parton[i].rotbst(M);</span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     961 </span>            : 
<span class="lineNum">     962 </span>            :   // Done.
<span class="lineNum">     963 </span>            :   return true;
<span class="lineNum">     964 </span>            : 
<span class="lineNum">     965 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     966 </span>            : 
<span class="lineNum">     967 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     968 </span>            : 
<a name="969"><span class="lineNum">     969 </span>            : // Calculate modified masses and four-vectors for matrix elements.</a>
<span class="lineNum">     970 </span>            : 
<span class="lineNum">     971 </span>            : bool Sigma2Process::setupForME() {
<span class="lineNum">     972 </span>            : 
<span class="lineNum">     973 </span>            :   // Common initial-state handling.
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :   bool allowME = setupForMEin();</span>
<span class="lineNum">     975 </span>            : 
<span class="lineNum">     976 </span>            :   // Correct outgoing c, b, mu and tau to be massive or not.
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :   mME[2] = m3;</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :   int id3Tmp = abs(id3Mass());</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :   if (id3Tmp ==  4) mME[2] = mcME;</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :   if (id3Tmp ==  5) mME[2] = mbME;</span>
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :   if (id3Tmp == 13) mME[2] = mmuME;</span>
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :   if (id3Tmp == 15) mME[2] = mtauME;</span>
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :   mME[3] = m4;</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :   int id4Tmp = abs(id4Mass());</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :   if (id4Tmp ==  4) mME[3] = mcME;</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :   if (id4Tmp ==  5) mME[3] = mbME;</span>
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :   if (id4Tmp == 13) mME[3] = mmuME;</span>
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :   if (id4Tmp == 15) mME[3] = mtauME;</span>
<span class="lineNum">     989 </span>            : 
<span class="lineNum">     990 </span>            :   // If kinematically impossible turn to massless case, but set error.
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :   if (mME[2] + mME[3] &gt;= mH) {</span>
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :     mME[2] = 0.;</span>
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :     mME[3] = 0.;</span>
<span class="lineNum">     994 </span>            :     allowME = false;
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     996 </span>            : 
<span class="lineNum">     997 </span>            :   // Calculate scattering angle in subsystem rest frame.
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :   double sH34 = sqrtpos( pow2(sH - s3 - s4) - 4. * s3 * s4);</span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :   double cThe = (tH - uH) / sH34;</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :   double sThe = sqrtpos(1. - cThe * cThe);</span>
<span class="lineNum">    1001 </span>            : 
<span class="lineNum">    1002 </span>            :   // Setup massive kinematics with preserved scattering angle.
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :   double s3ME   = pow2(mME[2]);</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :   double s4ME   = pow2(mME[3]);</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :   double sH34ME = sqrtpos( pow2(sH - s3ME - s4ME) - 4. * s3ME * s4ME);</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :   double pAbsME = 0.5 * sH34ME / mH;</span>
<span class="lineNum">    1007 </span>            : 
<span class="lineNum">    1008 </span>            :   // Normally allowed with unequal (or vanishing) masses.
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :   if (id3Tmp == 0 || id3Tmp != id4Tmp) {</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :     pME[2] = Vec4(  pAbsME * sThe, 0.,  pAbsME * cThe,</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :              0.5 * (sH + s3ME - s4ME) / mH);</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :     pME[3] = Vec4( -pAbsME * sThe, 0., -pAbsME * cThe,</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :              0.5 * (sH + s4ME - s3ME) / mH);</span>
<span class="lineNum">    1014 </span>            : 
<span class="lineNum">    1015 </span>            :   // For equal (anti)particles (e.g. W+ W-) use averaged mass.
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :     mME[2] = sqrtpos(0.5 * (s3ME + s4ME) - 0.25 * pow2(s3ME - s4ME) / sH);</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :     mME[3] = mME[2];</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :     pME[2] = Vec4(  pAbsME * sThe, 0.,  pAbsME * cThe, 0.5 * mH);</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :     pME[3] = Vec4( -pAbsME * sThe, 0., -pAbsME * cThe, 0.5 * mH);</span>
<span class="lineNum">    1021 </span>            :   }
<span class="lineNum">    1022 </span>            : 
<span class="lineNum">    1023 </span>            :   // Done.
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :   return allowME;</span>
<span class="lineNum">    1025 </span>            : 
<span class="lineNum">    1026 </span>            : }
<span class="lineNum">    1027 </span>            : 
<span class="lineNum">    1028 </span>            : //==========================================================================
<span class="lineNum">    1029 </span>            : 
<span class="lineNum">    1030 </span>            : // The Sigma3Process class.
<span class="lineNum">    1031 </span>            : // Base class for resolved 2 -&gt; 3 cross sections; derived from SigmaProcess.
<span class="lineNum">    1032 </span>            : 
<span class="lineNum">    1033 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1034 </span>            : 
<a name="1035"><span class="lineNum">    1035 </span>            : // Input and complement kinematics for resolved 2 -&gt; 3 process.</a>
<span class="lineNum">    1036 </span>            : 
<span class="lineNum">    1037 </span>            : void Sigma3Process::store3Kin( double x1in, double x2in, double sHin,
<span class="lineNum">    1038 </span>            :   Vec4 p3cmIn, Vec4 p4cmIn, Vec4 p5cmIn, double m3in, double m4in,
<span class="lineNum">    1039 </span>            :   double m5in, double runBW3in, double runBW4in, double runBW5in) {
<span class="lineNum">    1040 </span>            : 
<span class="lineNum">    1041 </span>            :   // Default ordering of particles 3 and 4 - not relevant here.
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :   swapTU   = false;</span>
<span class="lineNum">    1043 </span>            : 
<span class="lineNum">    1044 </span>            :   // Incoming parton momentum fractions.
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :   x1Save   = x1in;</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :   x2Save   = x2in;</span>
<span class="lineNum">    1047 </span>            : 
<span class="lineNum">    1048 </span>            :   // Incoming masses and their squares.
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :   if (id3Mass() == 0 &amp;&amp; id4Mass() == 0 &amp;&amp; id5Mass() == 0) {</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :     m3     = 0.;</span>
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :     m4     = 0.;</span>
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :     m5     = 0.;</span>
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :     m3     = m3in;</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :     m4     = m4in;</span>
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :     m5     = m5in;</span>
<span class="lineNum">    1057 </span>            :   }
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :   mSave[3] = m3;</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :   mSave[4] = m4;</span>
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :   mSave[5] = m5;</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :   s3       = m3 * m3;</span>
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :   s4       = m4 * m4;</span>
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :   s5       = m5 * m5;</span>
<span class="lineNum">    1064 </span>            : 
<span class="lineNum">    1065 </span>            :   // Standard Mandelstam variables and four-momenta in rest frame.
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :   sH       = sHin;</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :   mH       = sqrt(sH);</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :   sH2      = sH * sH;</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :   p3cm     = p3cmIn;</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :   p4cm     = p4cmIn;</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :   p5cm     = p5cmIn;</span>
<span class="lineNum">    1072 </span>            : 
<span class="lineNum">    1073 </span>            :   // The nominal Breit-Wigner factors with running width.
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :   runBW3   = runBW3in;</span>
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :   runBW4   = runBW4in;</span>
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :   runBW5   = runBW5in;</span>
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span>            :   // Special case: pick scale as if 2 -&gt; 1 process in disguise.
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :   if (isSChannel()) {</span>
<span class="lineNum">    1080 </span>            : 
<span class="lineNum">    1081 </span>            :     // Different options for renormalization scale, but normally sHat.
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :     Q2RenSave = renormMultFac * sH;</span>
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :     if (renormScale1 == 2) Q2RenSave = renormFixScale;</span>
<span class="lineNum">    1084 </span>            : 
<span class="lineNum">    1085 </span>            :     // Different options for factorization scale, but normally sHat.
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :     Q2FacSave = factorMultFac * sH;</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :     if (factorScale1 == 2) Q2RenSave = factorFixScale;</span>
<span class="lineNum">    1088 </span>            : 
<span class="lineNum">    1089 </span>            :   // &quot;Normal&quot; 2 -&gt; 3 processes, i.e. not vector boson fusion.
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :   } else if ( idTchan1() != 23 &amp;&amp; idTchan1() != 24 &amp;&amp; idTchan2() != 23</span>
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :     &amp;&amp; idTchan2() != 24 ) {</span>
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :     double mT3S = s3 + p3cm.pT2();</span>
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :     double mT4S = s4 + p4cm.pT2();</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :     double mT5S = s5 + p5cm.pT2();</span>
<span class="lineNum">    1095 </span>            : 
<span class="lineNum">    1096 </span>            :     // Different options for renormalization scale.
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :     if      (renormScale3 == 1) Q2RenSave = min( mT3S, min(mT4S, mT5S) );</span>
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :     else if (renormScale3 == 2) Q2RenSave = sqrt( mT3S * mT4S * mT5S</span>
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :       / max( mT3S, max(mT4S, mT5S) ) );</span>
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :     else if (renormScale3 == 3) Q2RenSave = pow( mT3S * mT4S * mT5S,</span>
<span class="lineNum">    1101 </span>            :                                             1./3. );
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :     else if (renormScale3 == 4) Q2RenSave = (mT3S + mT4S + mT5S) / 3.;</span>
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :     else                        Q2RenSave = sH;</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :     Q2RenSave                            *= renormMultFac;</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :     if      (renormScale3 == 6) Q2RenSave = renormFixScale;</span>
<span class="lineNum">    1106 </span>            : 
<span class="lineNum">    1107 </span>            :     // Different options for factorization scale.
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :     if      (factorScale3 == 1) Q2FacSave = min( mT3S, min(mT4S, mT5S) );</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :     else if (factorScale3 == 2) Q2FacSave = sqrt( mT3S * mT4S * mT5S</span>
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :       / max( mT3S, max(mT4S, mT5S) ) );</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :     else if (factorScale3 == 3) Q2FacSave = pow( mT3S * mT4S * mT5S,</span>
<span class="lineNum">    1112 </span>            :                                             1./3. );
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :     else if (factorScale3 == 4) Q2FacSave = (mT3S + mT4S + mT5S) / 3.;</span>
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :     else                        Q2FacSave = sH;</span>
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :     Q2FacSave                            *= factorMultFac;</span>
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :     if      (factorScale3 == 6) Q2FacSave = factorFixScale;</span>
<span class="lineNum">    1117 </span>            : 
<span class="lineNum">    1118 </span>            :   // Vector boson fusion 2 -&gt; 3 processes; recoils in positions 4 and 5.
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :     double sV4   = pow2( particleDataPtr-&gt;m0(idTchan1()) );</span>
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :     double sV5   = pow2( particleDataPtr-&gt;m0(idTchan2()) );</span>
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :     double mT3S  = s3  + p3cm.pT2();</span>
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :     double mTV4S = sV4 + p4cm.pT2();</span>
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :     double mTV5S = sV5 + p5cm.pT2();</span>
<span class="lineNum">    1125 </span>            : 
<span class="lineNum">    1126 </span>            :     // Different options for renormalization scale.
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :     if      (renormScale3VV == 1) Q2RenSave = max( sV4, sV5);</span>
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :     else if (renormScale3VV == 2) Q2RenSave = sqrt( mTV4S * mTV5S );</span>
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :     else if (renormScale3VV == 3) Q2RenSave = pow( mT3S * mTV4S * mTV5S,</span>
<span class="lineNum">    1130 </span>            :                                               1./3. );
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :     else if (renormScale3VV == 4) Q2RenSave = (mT3S * mTV4S * mTV5S) / 3.;</span>
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :     else                          Q2RenSave = sH;</span>
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :     Q2RenSave                              *= renormMultFac;</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :     if      (renormScale3VV == 6) Q2RenSave = renormFixScale;</span>
<span class="lineNum">    1135 </span>            : 
<span class="lineNum">    1136 </span>            :     // Different options for factorization scale.
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :     if      (factorScale3VV == 1) Q2FacSave = max( sV4, sV5);</span>
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :     else if (factorScale3VV == 2) Q2FacSave = sqrt( mTV4S * mTV5S );</span>
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :     else if (factorScale3VV == 3) Q2FacSave = pow( mT3S * mTV4S * mTV5S,</span>
<span class="lineNum">    1140 </span>            :                                               1./3. );
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :     else if (factorScale3VV == 4) Q2FacSave = (mT3S * mTV4S * mTV5S) / 3.;</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :     else                          Q2FacSave = sH;</span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :     Q2FacSave                              *= factorMultFac;</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :     if      (factorScale3VV == 6) Q2FacSave = factorFixScale;</span>
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1146 </span>            : 
<span class="lineNum">    1147 </span>            :   // Evaluate alpha_strong and alpha_EM.
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :   alpS  = couplingsPtr-&gt;alphaS(Q2RenSave);</span>
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :   alpEM = couplingsPtr-&gt;alphaEM(Q2RenSave);</span>
<span class="lineNum">    1150 </span>            : 
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1152 </span>            : 
<span class="lineNum">    1153 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1154 </span>            : 
<a name="1155"><span class="lineNum">    1155 </span>            : // Calculate modified masses and four-vectors for matrix elements.</a>
<span class="lineNum">    1156 </span>            : 
<span class="lineNum">    1157 </span>            : bool Sigma3Process::setupForME() {
<span class="lineNum">    1158 </span>            : 
<span class="lineNum">    1159 </span>            :   // Common initial-state handling.
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :   bool allowME = setupForMEin();</span>
<span class="lineNum">    1161 </span>            : 
<span class="lineNum">    1162 </span>            :   // Correct outgoing c, b, mu and tau to be massive or not.
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :   mME[2] = m3;</span>
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :   int id3Tmp = abs(id3Mass());</span>
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :   if (id3Tmp ==  4) mME[2] = mcME;</span>
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :   if (id3Tmp ==  5) mME[2] = mbME;</span>
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :   if (id3Tmp == 13) mME[2] = mmuME;</span>
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :   if (id3Tmp == 15) mME[2] = mtauME;</span>
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :   mME[3] = m4;</span>
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :   int id4Tmp = abs(id4Mass());</span>
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :   if (id4Tmp ==  4) mME[3] = mcME;</span>
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :   if (id4Tmp ==  5) mME[3] = mbME;</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :   if (id4Tmp == 13) mME[3] = mmuME;</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :   if (id4Tmp == 15) mME[3] = mtauME;</span>
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :   mME[4] = m5;</span>
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 :   int id5Tmp = abs(id5Mass());</span>
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :   if (id5Tmp ==  4) mME[4] = mcME;</span>
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :   if (id5Tmp ==  5) mME[4] = mbME;</span>
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :   if (id5Tmp == 13) mME[4] = mmuME;</span>
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :   if (id5Tmp == 15) mME[4] = mtauME;</span>
<span class="lineNum">    1181 </span>            : 
<span class="lineNum">    1182 </span>            :   // If kinematically impossible turn to massless case, but set error.
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :   if (mME[2] + mME[3] + mME[4] &gt;= mH) {</span>
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :     mME[2] = 0.;</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :     mME[3] = 0.;</span>
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :     mME[4] = 0.;</span>
<span class="lineNum">    1187 </span>            :     allowME = false;
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1189 </span>            : 
<span class="lineNum">    1190 </span>            :   // Form new average masses if identical particles.
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :   if (id3Tmp != 0 &amp;&amp; id4Tmp == id3Tmp &amp;&amp; id5Tmp == id3Tmp) {</span>
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :     double mAvg = (mME[2] + mME[3] + mME[4]) / 3.;</span>
<span class="lineNum">    1193 </span><span class="lineNoCov">          0 :     mME[2] = mAvg;</span>
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :     mME[3] = mAvg;</span>
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :     mME[4] = mAvg;</span>
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :   } else if (id3Tmp != 0 &amp;&amp; id4Tmp == id3Tmp) {</span>
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :     mME[2] = sqrtpos(0.5 * (pow2(mME[2]) + pow2(mME[3]))</span>
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :            - 0.25 * pow2(pow2(mME[2]) - pow2(mME[3])) / sH);</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :     mME[3] = mME[2];</span>
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :   } else if (id3Tmp != 0 &amp;&amp; id5Tmp == id3Tmp) {</span>
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :     mME[2] = sqrtpos(0.5 * (pow2(mME[2]) + pow2(mME[4]))</span>
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :            - 0.25 * pow2(pow2(mME[2]) - pow2(mME[4])) / sH);</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :     mME[4] = mME[2];</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :   } else if (id4Tmp != 0 &amp;&amp; id5Tmp == id4Tmp) {</span>
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 :     mME[3] = sqrtpos(0.5 * (pow2(mME[3]) + pow2(mME[4]))</span>
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :            - 0.25 * pow2(pow2(mME[3]) - pow2(mME[4])) / sH);</span>
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :     mME[4] = mME[2];</span>
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1209 </span>            : 
<span class="lineNum">    1210 </span>            :   // Iterate rescaled three-momenta until convergence.
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :   double m2ME3 = pow2(mME[2]);</span>
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :   double m2ME4 = pow2(mME[3]);</span>
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :   double m2ME5 = pow2(mME[4]);</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :   double p2ME3 = p3cm.pAbs2();</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :   double p2ME4 = p4cm.pAbs2();</span>
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :   double p2ME5 = p5cm.pAbs2();</span>
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :   double p2sum = p2ME3 + p2ME4 + p2ME5;</span>
<span class="lineNum">    1218 </span><span class="lineNoCov">          0 :   double eME3  = sqrt(m2ME3 + p2ME3);</span>
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :   double eME4  = sqrt(m2ME4 + p2ME4);</span>
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 :   double eME5  = sqrt(m2ME5 + p2ME5);</span>
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :   double esum  = eME3 + eME4 + eME5;</span>
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :   double p2rat = p2ME3 / eME3 + p2ME4 / eME4 + p2ME5 / eME5;</span>
<span class="lineNum">    1223 </span>            :   int iStep = 0;
<span class="lineNum">    1224 </span><span class="lineNoCov">          0 :   while ( abs(esum - mH) &gt; COMPRELERR * mH &amp;&amp; iStep &lt; NCOMPSTEP ) {</span>
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :     ++iStep;</span>
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :     double compFac = 1. + 2. * (mH - esum) / p2rat;</span>
<span class="lineNum">    1227 </span><span class="lineNoCov">          0 :     p2ME3 *= compFac;</span>
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :     p2ME4 *= compFac;</span>
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :     p2ME5 *= compFac;</span>
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :     eME3   = sqrt(m2ME3 + p2ME3);</span>
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :     eME4   = sqrt(m2ME4 + p2ME4);</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :     eME5   = sqrt(m2ME5 + p2ME5);</span>
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :     esum   = eME3 + eME4 + eME5;</span>
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :     p2rat  = p2ME3 / eME3 + p2ME4 / eME4 + p2ME5 / eME5;</span>
<span class="lineNum">    1235 </span>            :   }
<span class="lineNum">    1236 </span>            : 
<span class="lineNum">    1237 </span>            :   // If failed convergence set error flag.
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :   if (abs(esum - mH) &gt; COMPRELERR * mH) allowME = false;</span>
<span class="lineNum">    1239 </span>            : 
<span class="lineNum">    1240 </span>            :   // Set up accepted kinematics.
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :   double totFac = sqrt( (p2ME3 + p2ME4 + p2ME5) / p2sum);</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :   pME[2] = totFac * p3cm;</span>
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :   pME[2].e( eME3);</span>
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 :   pME[3] = totFac * p4cm;</span>
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :   pME[3].e( eME4);</span>
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 :   pME[4] = totFac * p5cm;</span>
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :   pME[4].e( eME5);</span>
<span class="lineNum">    1248 </span>            : 
<span class="lineNum">    1249 </span>            :   // Done.
<span class="lineNum">    1250 </span><span class="lineNoCov">          0 :   return allowME;</span>
<span class="lineNum">    1251 </span>            : 
<span class="lineNum">    1252 </span>            : }
<span class="lineNum">    1253 </span>            : 
<span class="lineNum">    1254 </span>            : //==========================================================================
<span class="lineNum">    1255 </span>            : 
<span class="lineNum">    1256 </span>            : // The SigmaLHAProcess class.
<span class="lineNum">    1257 </span>            : // Wrapper for Les Houches Accord external input; derived from SigmaProcess.
<span class="lineNum">    1258 </span>            : // Note: arbitrary subdivision into PhaseSpaceLHA and SigmaLHAProcess tasks.
<span class="lineNum">    1259 </span>            : 
<span class="lineNum">    1260 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1261 </span>            : 
<a name="1262"><span class="lineNum">    1262 </span>            : // Evaluate weight for decay angles.</a>
<span class="lineNum">    1263 </span>            : 
<span class="lineNum">    1264 </span>            : double SigmaLHAProcess::weightDecay( Event&amp; process, int iResBeg,
<span class="lineNum">    1265 </span>            :   int iResEnd) {
<span class="lineNum">    1266 </span>            : 
<span class="lineNum">    1267 </span>            :   // Do nothing if decays present already at input.
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :   if (iResBeg &lt; process.savedSizeValue()) return 1.;</span>
<span class="lineNum">    1269 </span>            : 
<span class="lineNum">    1270 </span>            :   // Identity of mother of decaying reseonance(s).
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :   int idMother = process[process[iResBeg].mother1()].idAbs();</span>
<span class="lineNum">    1272 </span>            : 
<span class="lineNum">    1273 </span>            :   // For Higgs decay hand over to standard routine.
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 :   if (idMother == 25 || idMother == 35 || idMother == 36)</span>
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :     return weightHiggsDecay( process, iResBeg, iResEnd);</span>
<span class="lineNum">    1276 </span>            : 
<span class="lineNum">    1277 </span>            :   // For top decay hand over to standard routine.
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :   if (idMother == 6)</span>
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :     return weightTopDecay( process, iResBeg, iResEnd);</span>
<span class="lineNum">    1280 </span>            : 
<span class="lineNum">    1281 </span>            :   // Else done.
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :   return 1.;</span>
<span class="lineNum">    1283 </span>            : 
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1285 </span>            : 
<span class="lineNum">    1286 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1287 </span>            : 
<a name="1288"><span class="lineNum">    1288 </span>            : // Set scale, alpha_strong and alpha_EM when not set.</a>
<span class="lineNum">    1289 </span>            : 
<span class="lineNum">    1290 </span>            : void SigmaLHAProcess::setScale() {
<span class="lineNum">    1291 </span>            : 
<span class="lineNum">    1292 </span>            :   // If scale has not been set, then to set.
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :   double scaleLHA = lhaUpPtr-&gt;scale();</span>
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 :   if (scaleLHA &lt; 0.) {</span>
<span class="lineNum">    1295 </span>            : 
<span class="lineNum">    1296 </span>            :     // Final-state partons and their invariant mass.
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 :     vector&lt;int&gt; iFin;</span>
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :     Vec4 pFinSum;</span>
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 :     for (int i = 3; i &lt; lhaUpPtr-&gt;sizePart(); ++i)</span>
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :     if (lhaUpPtr-&gt;mother1(i) == 1) {</span>
<span class="lineNum">    1301 </span><span class="lineNoCov">          0 :       iFin.push_back(i);</span>
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 :       pFinSum += Vec4( lhaUpPtr-&gt;px(i), lhaUpPtr-&gt;py(i),</span>
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :         lhaUpPtr-&gt;pz(i), lhaUpPtr-&gt;e(i) );</span>
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 :     int nFin = iFin.size();</span>
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :     sH       = pFinSum * pFinSum;</span>
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :     mH       = sqrt(sH);</span>
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :     sH2      = sH * sH;</span>
<span class="lineNum">    1309 </span>            : 
<span class="lineNum">    1310 </span>            :     // If 1 final-state particle then use Sigma1Process logic.
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 :     if (nFin == 1) {</span>
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :       Q2RenSave                             = renormMultFac * sH;</span>
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :       if (renormScale1 == 2) Q2RenSave      = renormFixScale;</span>
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :       Q2FacSave                             = factorMultFac * sH;</span>
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :       if (factorScale1 == 2) Q2FacSave      = factorFixScale;</span>
<span class="lineNum">    1316 </span>            : 
<span class="lineNum">    1317 </span>            :     // If 2 final-state particles then use Sigma2Process logic.
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :     } else if (nFin == 2) {</span>
<span class="lineNum">    1319 </span><span class="lineNoCov">          0 :       double s3  = pow2(lhaUpPtr-&gt;m(iFin[0]));</span>
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :       double s4  = pow2(lhaUpPtr-&gt;m(iFin[1]));</span>
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :       double pT2 = pow2(lhaUpPtr-&gt;px(iFin[0])) + pow2(lhaUpPtr-&gt;py(iFin[0]));</span>
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :       if      (renormScale2 == 1) Q2RenSave = pT2 + min(s3, s4);</span>
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :       else if (renormScale2 == 2) Q2RenSave = sqrt((pT2 + s3) * (pT2 + s4));</span>
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :       else if (renormScale2 == 3) Q2RenSave = pT2 + 0.5 * (s3 + s4);</span>
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :       else                        Q2RenSave = sH;</span>
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :       Q2RenSave                            *= renormMultFac;</span>
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :       if      (renormScale2 == 5) Q2RenSave = renormFixScale;</span>
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :       if      (factorScale2 == 1) Q2FacSave = pT2 + min(s3, s4);</span>
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :       else if (factorScale2 == 2) Q2FacSave = sqrt((pT2 + s3) * (pT2 + s4));</span>
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :       else if (factorScale2 == 3) Q2FacSave = pT2 + 0.5 * (s3 + s4);</span>
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :       else                        Q2FacSave = sH;</span>
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :       Q2FacSave                            *= factorMultFac;</span>
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 :       if      (factorScale2 == 5) Q2FacSave = factorFixScale;</span>
<span class="lineNum">    1334 </span>            : 
<span class="lineNum">    1335 </span>            :     // If 3 or more final-state particles then use Sigma3Process logic.
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">    1337 </span><span class="lineNoCov">          0 :       double mTSlow  = sH;</span>
<span class="lineNum">    1338 </span>            :       double mTSmed  = sH;
<span class="lineNum">    1339 </span>            :       double mTSprod = 1.;
<span class="lineNum">    1340 </span>            :       double mTSsum  = 0.;
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :       for (int i = 0; i &lt; nFin; ++i) {</span>
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :         double mTSnow = pow2(lhaUpPtr-&gt;m(iFin[i]))</span>
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :           + pow2(lhaUpPtr-&gt;px(iFin[i])) + pow2(lhaUpPtr-&gt;py(iFin[i]));</span>
<span class="lineNum">    1344 </span><span class="lineNoCov">          0 :         if      (mTSnow &lt; mTSlow) {mTSmed = mTSlow; mTSlow = mTSnow;}</span>
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :         else if (mTSnow &lt; mTSmed) mTSmed = mTSnow;</span>
<span class="lineNum">    1346 </span><span class="lineNoCov">          0 :         mTSprod *= mTSnow;</span>
<span class="lineNum">    1347 </span><span class="lineNoCov">          0 :         mTSsum  += mTSnow;</span>
<span class="lineNum">    1348 </span>            :       }
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :       if      (renormScale3 == 1) Q2RenSave = mTSlow;</span>
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :       else if (renormScale3 == 2) Q2RenSave = sqrt(mTSlow * mTSmed);</span>
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :       else if (renormScale3 == 3) Q2RenSave = pow(mTSprod, 1. / nFin);</span>
<span class="lineNum">    1352 </span><span class="lineNoCov">          0 :       else if (renormScale3 == 4) Q2RenSave = mTSsum / nFin;</span>
<span class="lineNum">    1353 </span><span class="lineNoCov">          0 :       else                        Q2RenSave = sH;</span>
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 :       Q2RenSave                            *= renormMultFac;</span>
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :       if      (renormScale3 == 6) Q2RenSave = renormFixScale;</span>
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 :       if      (factorScale3 == 1) Q2FacSave = mTSlow;</span>
<span class="lineNum">    1357 </span><span class="lineNoCov">          0 :       else if (factorScale3 == 2) Q2FacSave = sqrt(mTSlow * mTSmed);</span>
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 :       else if (factorScale3 == 3) Q2FacSave = pow(mTSprod, 1. / nFin);</span>
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :       else if (factorScale3 == 4) Q2FacSave = mTSsum / nFin;</span>
<span class="lineNum">    1360 </span><span class="lineNoCov">          0 :       else                        Q2FacSave = sH;</span>
<span class="lineNum">    1361 </span><span class="lineNoCov">          0 :       Q2FacSave                            *= factorMultFac;</span>
<span class="lineNum">    1362 </span><span class="lineNoCov">          0 :       if      (factorScale3 == 6) Q2FacSave = factorFixScale;</span>
<span class="lineNum">    1363 </span>            :     }
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1365 </span>            : 
<span class="lineNum">    1366 </span>            :   // If alpha_strong and alpha_EM have not been set, then set them.
<span class="lineNum">    1367 </span><span class="lineNoCov">          0 :   if (lhaUpPtr-&gt;alphaQCD() &lt; 0.001) {</span>
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :     double Q2RenNow = (scaleLHA &lt; 0.) ? Q2RenSave : pow2(scaleLHA);</span>
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :     alpS = couplingsPtr-&gt;alphaS(Q2RenNow);</span>
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :   if (lhaUpPtr-&gt;alphaQED() &lt; 0.001) {</span>
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :     double Q2RenNow = (scaleLHA &lt; 0.) ? Q2RenSave : pow2(scaleLHA);</span>
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 :     alpEM = couplingsPtr-&gt;alphaEM(Q2RenNow);</span>
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1375 </span>            : 
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1377 </span>            : 
<span class="lineNum">    1378 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1379 </span>            : 
<a name="1380"><span class="lineNum">    1380 </span>            : // Obtain number of final-state partons from LHA object.</a>
<span class="lineNum">    1381 </span>            : 
<span class="lineNum">    1382 </span>            : int SigmaLHAProcess::nFinal() const {
<span class="lineNum">    1383 </span>            : 
<span class="lineNum">    1384 </span>            :   // At initialization size unknown, so return 0.
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :   if (lhaUpPtr-&gt;sizePart() &lt;= 0) return 0;</span>
<span class="lineNum">    1386 </span>            : 
<span class="lineNum">    1387 </span>            :   // Sum up all particles that has first mother = 1.
<span class="lineNum">    1388 </span>            :   int nFin = 0;
<span class="lineNum">    1389 </span><span class="lineNoCov">          0 :   for (int i = 3; i &lt; lhaUpPtr-&gt;sizePart(); ++i)</span>
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :     if (lhaUpPtr-&gt;mother1(i) == 1) ++nFin;</span>
<span class="lineNum">    1391 </span>            :   return nFin;
<span class="lineNum">    1392 </span>            : 
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1394 </span>            : 
<span class="lineNum">    1395 </span>            : //==========================================================================
<span class="lineNum">    1396 </span>            : 
<span class="lineNum">    1397 </span>            : } // end namespace Pythia8
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
