<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - TRD/TRDbase/AliTRDseedV1.cxx</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">TRD/TRDbase</a> - AliTRDseedV1.cxx<span style="font-size: 80%;"> (source / <a href="AliTRDseedV1.cxx.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">768</td>
            <td class="headerCovTableEntry">1335</td>
            <td class="headerCovTableEntryLo">57.5 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">31</td>
            <td class="headerCovTableEntry">47</td>
            <td class="headerCovTableEntryLo">66.0 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**************************************************************************</a>
<span class="lineNum">       2 </span>            : * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
<span class="lineNum">       3 </span>            : *                                                                        *
<span class="lineNum">       4 </span>            : * Author: The ALICE Off-line Project.                                    *
<span class="lineNum">       5 </span>            : * Contributors are mentioned in the code where appropriate.              *
<span class="lineNum">       6 </span>            : *                                                                        *
<span class="lineNum">       7 </span>            : * Permission to use, copy, modify and distribute this software and its   *
<span class="lineNum">       8 </span>            : * documentation strictly for non-commercial purposes is hereby granted   *
<span class="lineNum">       9 </span>            : * without fee, provided that the above copyright notice appears in all   *
<span class="lineNum">      10 </span>            : * copies and that both the copyright notice and this permission notice   *
<span class="lineNum">      11 </span>            : * appear in the supporting documentation. The authors make no claims     *
<span class="lineNum">      12 </span>            : * about the suitability of this software for any purpose. It is          *
<span class="lineNum">      13 </span>            : * provided &quot;as is&quot; without express or implied warranty.                  *
<span class="lineNum">      14 </span>            : **************************************************************************/
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : /* $Id: AliTRDseedV1.cxx 60233 2013-01-10 09:04:08Z abercuci $ */
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : ////////////////////////////////////////////////////////////////////////////
<span class="lineNum">      19 </span>            : ////
<span class="lineNum">      20 </span>            : //  The TRD offline tracklet
<span class="lineNum">      21 </span>            : //
<span class="lineNum">      22 </span>            : // The running horse of the TRD reconstruction. The following tasks are preformed:
<span class="lineNum">      23 </span>            : //   1. Clusters attachment to tracks based on prior information stored at tracklet level (see AttachClusters)
<span class="lineNum">      24 </span>            : //   2. Clusters position recalculation based on track information (see GetClusterXY and Fit)
<span class="lineNum">      25 </span>            : //   3. Cluster error parametrization recalculation (see Fit)
<span class="lineNum">      26 </span>            : //   4. Linear track approximation (Fit)
<span class="lineNum">      27 </span>            : //   5. Optimal position (including z estimate for pad row cross tracklets) and covariance matrix of the track fit inside one TRD chamber (Fit)
<span class="lineNum">      28 </span>            : //   6. Tilt pad correction and systematic effects (GetCovAt)
<span class="lineNum">      29 </span>            : //   7. dEdx calculation (CookdEdx)
<span class="lineNum">      30 </span>            : //   8. PID probabilities estimation (CookPID)
<span class="lineNum">      31 </span>            : //
<span class="lineNum">      32 </span>            : //  Authors:                                                              //
<span class="lineNum">      33 </span>            : //    Alex Bercuci &lt;A.Bercuci@gsi.de&gt;                                     //
<span class="lineNum">      34 </span>            : //    Markus Fasel &lt;M.Fasel@gsi.de&gt;                                       //
<span class="lineNum">      35 </span>            : //                                                                        //
<span class="lineNum">      36 </span>            : ////////////////////////////////////////////////////////////////////////////
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : #include &quot;TMath.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;TGeoManager.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;TTreeStream.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;TGraphErrors.h&quot;
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : #include &quot;AliLog.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;AliMathBase.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;AliRieman.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;AliCDBManager.h&quot;
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            : #include &quot;AliTRDReconstructor.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;AliTRDpadPlane.h&quot;
<span class="lineNum">      50 </span>            : #include &quot;AliTRDtransform.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;AliTRDcluster.h&quot;
<span class="lineNum">      52 </span>            : #include &quot;AliTRDseedV1.h&quot;
<span class="lineNum">      53 </span>            : #include &quot;AliTRDtrackV1.h&quot;
<span class="lineNum">      54 </span>            : #include &quot;AliTRDcalibDB.h&quot;
<span class="lineNum">      55 </span>            : #include &quot;AliTRDchamberTimeBin.h&quot;
<span class="lineNum">      56 </span>            : #include &quot;AliTRDtrackingChamber.h&quot;
<span class="lineNum">      57 </span>            : #include &quot;AliTRDtrackerV1.h&quot;
<span class="lineNum">      58 </span>            : #include &quot;AliTRDrecoParam.h&quot;
<span class="lineNum">      59 </span>            : #include &quot;AliTRDCommonParam.h&quot;
<span class="lineNum">      60 </span>            : #include &quot;AliTRDtrackletOflHelper.h&quot;
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            : #include &quot;AliTRDCalTrkAttach.h&quot;
<span class="lineNum">      63 </span>            : #include &quot;AliTRDCalPID.h&quot;
<span class="lineNum">      64 </span>            : #include &quot;AliTRDCalROC.h&quot;
<span class="lineNum">      65 </span>            : #include &quot;AliTRDCalDet.h&quot;
<span class="lineNum">      66 </span>            : 
<a name="67"><span class="lineNum">      67 </span>            : class AliTracker;</a>
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span><span class="lineCov">         48 : ClassImp(AliTRDseedV1)</span>
<a name="70"><span class="lineNum">      70 </span>            : </a>
<span class="lineNum">      71 </span>            : //____________________________________________________________________
<span class="lineNum">      72 </span>            : AliTRDseedV1::AliTRDseedV1(Int_t det) 
<span class="lineNum">      73 </span><span class="lineCov">        369 :   :AliTRDtrackletBase()</span>
<span class="lineNum">      74 </span><span class="lineCov">        369 :   ,fkReconstructor(NULL)</span>
<span class="lineNum">      75 </span><span class="lineCov">        369 :   ,fClusterIter(NULL)</span>
<span class="lineNum">      76 </span><span class="lineCov">        369 :   ,fExB(0.)</span>
<span class="lineNum">      77 </span><span class="lineCov">        369 :   ,fVD(0.)</span>
<span class="lineNum">      78 </span><span class="lineCov">        369 :   ,fT0(0.)</span>
<span class="lineNum">      79 </span><span class="lineCov">        369 :   ,fS2PRF(0.)</span>
<span class="lineNum">      80 </span><span class="lineCov">        369 :   ,fDiffL(0.)</span>
<span class="lineNum">      81 </span><span class="lineCov">        369 :   ,fDiffT(0.)</span>
<span class="lineNum">      82 </span><span class="lineCov">        369 :   ,fClusterIdx(0)</span>
<span class="lineNum">      83 </span><span class="lineCov">        369 :   ,fErrorMsg(0)</span>
<span class="lineNum">      84 </span><span class="lineCov">        369 :   ,fN(0)</span>
<span class="lineNum">      85 </span><span class="lineCov">        369 :   ,fDet(det)</span>
<span class="lineNum">      86 </span><span class="lineCov">        369 :   ,fPt(0.)</span>
<span class="lineNum">      87 </span><span class="lineCov">        369 :   ,fdX(0.)</span>
<span class="lineNum">      88 </span><span class="lineCov">        369 :   ,fX0(0.)</span>
<span class="lineNum">      89 </span><span class="lineCov">        369 :   ,fX(0.)</span>
<span class="lineNum">      90 </span><span class="lineCov">        369 :   ,fY(0.)</span>
<span class="lineNum">      91 </span><span class="lineCov">        369 :   ,fZ(0.)</span>
<span class="lineNum">      92 </span><span class="lineCov">        369 :   ,fS2Y(0.)</span>
<span class="lineNum">      93 </span><span class="lineCov">        369 :   ,fS2Z(0.)</span>
<span class="lineNum">      94 </span><span class="lineCov">        369 :   ,fChi2(0.)</span>
<span class="lineNum">      95 </span><span class="lineCov">       1845 : {</span>
<span class="lineNum">      96 </span>            :   //
<span class="lineNum">      97 </span>            :   // Constructor
<span class="lineNum">      98 </span>            :   //
<span class="lineNum">      99 </span><span class="lineCov">        369 :   memset(fIndexes,0xFF,kNclusters*sizeof(fIndexes[0]));</span>
<span class="lineNum">     100 </span><span class="lineCov">        369 :   memset(fClusters, 0, kNclusters*sizeof(AliTRDcluster*));</span>
<span class="lineNum">     101 </span><span class="lineCov">        369 :   memset(fPad, 0, 4*sizeof(Float_t));</span>
<span class="lineNum">     102 </span><span class="lineCov">        369 :   fYref[0] = 0.; fYref[1] = 0.; </span>
<span class="lineNum">     103 </span><span class="lineCov">        369 :   fZref[0] = 0.; fZref[1] = 0.; </span>
<span class="lineNum">     104 </span><span class="lineCov">        369 :   fYfit[0] = 0.; fYfit[1] = 0.; </span>
<span class="lineNum">     105 </span><span class="lineCov">        369 :   fZfit[0] = 0.; fZfit[1] = 0.; </span>
<span class="lineNum">     106 </span><span class="lineCov">        369 :   memset(fdEdx, 0, kNdEdxSlices*sizeof(Float_t));</span>
<span class="lineNum">     107 </span><span class="lineCov">       4428 :   for(int ispec=0; ispec&lt;AliPID::kSPECIES; ispec++) fProb[ispec]  = -1.;</span>
<span class="lineNum">     108 </span><span class="lineCov">        369 :   fLabels[0]=-1; fLabels[1]=-1; // most freq MC labels</span>
<span class="lineNum">     109 </span><span class="lineCov">        369 :   fLabels[2]=0;  // number of different labels for tracklet</span>
<span class="lineNum">     110 </span><span class="lineCov">        369 :   memset(fRefCov, 0, 7*sizeof(Double_t));</span>
<span class="lineNum">     111 </span>            :   // stand alone curvature
<span class="lineNum">     112 </span><span class="lineCov">        369 :   fC[0] = 0.; fC[1] = 0.; </span>
<span class="lineNum">     113 </span>            :   // covariance matrix [diagonal]
<span class="lineNum">     114 </span>            :   // default sy = 200um and sz = 2.3 cm 
<span class="lineNum">     115 </span><span class="lineCov">        369 :   fCov[0] = 4.e-4; fCov[1] = 0.; fCov[2] = 5.3; </span>
<span class="lineNum">     116 </span><span class="lineCov">        369 :   SetStandAlone(kFALSE);</span>
<span class="lineNum">     117 </span><span class="lineCov">        738 : }</span>
<a name="118"><span class="lineNum">     118 </span>            : </a>
<span class="lineNum">     119 </span>            : //____________________________________________________________________
<span class="lineNum">     120 </span>            : AliTRDseedV1::AliTRDseedV1(const AliTRDseedV1 &amp;ref)
<span class="lineNum">     121 </span><span class="lineCov">        412 :   :AliTRDtrackletBase((AliTRDtrackletBase&amp;)ref)</span>
<span class="lineNum">     122 </span><span class="lineCov">        412 :   ,fkReconstructor(NULL)</span>
<span class="lineNum">     123 </span><span class="lineCov">        412 :   ,fClusterIter(NULL)</span>
<span class="lineNum">     124 </span><span class="lineCov">        412 :   ,fExB(0.)</span>
<span class="lineNum">     125 </span><span class="lineCov">        412 :   ,fVD(0.)</span>
<span class="lineNum">     126 </span><span class="lineCov">        412 :   ,fT0(0.)</span>
<span class="lineNum">     127 </span><span class="lineCov">        412 :   ,fS2PRF(0.)</span>
<span class="lineNum">     128 </span><span class="lineCov">        412 :   ,fDiffL(0.)</span>
<span class="lineNum">     129 </span><span class="lineCov">        412 :   ,fDiffT(0.)</span>
<span class="lineNum">     130 </span><span class="lineCov">        412 :   ,fClusterIdx(0)</span>
<span class="lineNum">     131 </span><span class="lineCov">        412 :   ,fErrorMsg(0)</span>
<span class="lineNum">     132 </span><span class="lineCov">        412 :   ,fN(0)</span>
<span class="lineNum">     133 </span><span class="lineCov">        412 :   ,fDet(-1)</span>
<span class="lineNum">     134 </span><span class="lineCov">        412 :   ,fPt(0.)</span>
<span class="lineNum">     135 </span><span class="lineCov">        412 :   ,fdX(0.)</span>
<span class="lineNum">     136 </span><span class="lineCov">        412 :   ,fX0(0.)</span>
<span class="lineNum">     137 </span><span class="lineCov">        412 :   ,fX(0.)</span>
<span class="lineNum">     138 </span><span class="lineCov">        412 :   ,fY(0.)</span>
<span class="lineNum">     139 </span><span class="lineCov">        412 :   ,fZ(0.)</span>
<span class="lineNum">     140 </span><span class="lineCov">        412 :   ,fS2Y(0.)</span>
<span class="lineNum">     141 </span><span class="lineCov">        412 :   ,fS2Z(0.)</span>
<span class="lineNum">     142 </span><span class="lineCov">        412 :   ,fChi2(0.)</span>
<span class="lineNum">     143 </span><span class="lineCov">       2060 : {</span>
<span class="lineNum">     144 </span>            :   //
<span class="lineNum">     145 </span>            :   // Copy Constructor performing a deep copy
<span class="lineNum">     146 </span>            :   //
<span class="lineNum">     147 </span><span class="lineCov">        412 :   if(this != &amp;ref){</span>
<span class="lineNum">     148 </span><span class="lineCov">        412 :     ref.Copy(*this);</span>
<span class="lineNum">     149 </span>            :   }
<span class="lineNum">     150 </span><span class="lineCov">        412 :   SetBit(kOwner, kFALSE);</span>
<span class="lineNum">     151 </span><span class="lineCov">        824 :   SetStandAlone(ref.IsStandAlone());</span>
<span class="lineNum">     152 </span><span class="lineCov">        824 : }</span>
<span class="lineNum">     153 </span>            : 
<a name="154"><span class="lineNum">     154 </span>            : </a>
<span class="lineNum">     155 </span>            : //____________________________________________________________________
<span class="lineNum">     156 </span>            : AliTRDseedV1&amp; AliTRDseedV1::operator=(const AliTRDseedV1 &amp;ref)
<span class="lineNum">     157 </span>            : {
<span class="lineNum">     158 </span>            :   //
<span class="lineNum">     159 </span>            :   // Assignment Operator using the copy function
<span class="lineNum">     160 </span>            :   //
<span class="lineNum">     161 </span>            : 
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :   if(this != &amp;ref){</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :     ref.Copy(*this);</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :   SetBit(kOwner, kFALSE);</span>
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :   return *this;</span>
<span class="lineNum">     168 </span>            : }
<a name="169"><span class="lineNum">     169 </span>            : </a>
<span class="lineNum">     170 </span>            : //____________________________________________________________________
<span class="lineNum">     171 </span>            : AliTRDseedV1::~AliTRDseedV1()
<span class="lineNum">     172 </span><span class="lineCov">       3950 : {</span>
<span class="lineNum">     173 </span>            :   //
<span class="lineNum">     174 </span>            :   // Destructor. The RecoParam object belongs to the underlying tracker.
<span class="lineNum">     175 </span>            :   //
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span>            :   //printf(&quot;I-AliTRDseedV1::~AliTRDseedV1() : Owner[%s]\n&quot;, IsOwner()?&quot;YES&quot;:&quot;NO&quot;);
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span><span class="lineCov">       1562 :   if(IsOwner()) {</span>
<span class="lineNum">     180 </span><span class="lineCov">      25956 :     for(int itb=0; itb&lt;kNclusters; itb++){</span>
<span class="lineNum">     181 </span><span class="lineCov">      12772 :       if(!fClusters[itb]) continue; </span>
<span class="lineNum">     182 </span>            :       //AliInfo(Form(&quot;deleting c %p @ %d&quot;, fClusters[itb], itb));
<span class="lineNum">     183 </span><span class="lineCov">       8960 :       delete fClusters[itb];</span>
<span class="lineNum">     184 </span><span class="lineCov">       4480 :       fClusters[itb] = NULL;</span>
<span class="lineNum">     185 </span><span class="lineCov">       4480 :     }</span>
<span class="lineNum">     186 </span><span class="lineCov">        206 :   }</span>
<span class="lineNum">     187 </span><span class="lineCov">       1975 : }</span>
<a name="188"><span class="lineNum">     188 </span>            : </a>
<span class="lineNum">     189 </span>            : //____________________________________________________________________
<span class="lineNum">     190 </span>            : void AliTRDseedV1::Copy(TObject &amp;ref) const
<span class="lineNum">     191 </span>            : {
<span class="lineNum">     192 </span>            :   //
<span class="lineNum">     193 </span>            :   // Copy function
<span class="lineNum">     194 </span>            :   //
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span>            :   //AliInfo(&quot;&quot;);
<span class="lineNum">     197 </span><span class="lineCov">        824 :   AliTRDseedV1 &amp;target = (AliTRDseedV1 &amp;)ref; </span>
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span><span class="lineCov">        412 :   target.fkReconstructor = fkReconstructor;</span>
<span class="lineNum">     200 </span><span class="lineCov">        412 :   target.fClusterIter   = NULL;</span>
<span class="lineNum">     201 </span><span class="lineCov">        412 :   target.fExB           = fExB;</span>
<span class="lineNum">     202 </span><span class="lineCov">        412 :   target.fVD            = fVD;</span>
<span class="lineNum">     203 </span><span class="lineCov">        412 :   target.fT0            = fT0;</span>
<span class="lineNum">     204 </span><span class="lineCov">        412 :   target.fS2PRF         = fS2PRF;</span>
<span class="lineNum">     205 </span><span class="lineCov">        412 :   target.fDiffL         = fDiffL;</span>
<span class="lineNum">     206 </span><span class="lineCov">        412 :   target.fDiffT         = fDiffT;</span>
<span class="lineNum">     207 </span><span class="lineCov">        412 :   target.fClusterIdx    = 0;</span>
<span class="lineNum">     208 </span><span class="lineCov">        412 :   target.fErrorMsg      = fErrorMsg;</span>
<span class="lineNum">     209 </span><span class="lineCov">        412 :   target.fN             = fN;</span>
<span class="lineNum">     210 </span><span class="lineCov">        412 :   target.fDet           = fDet;</span>
<span class="lineNum">     211 </span><span class="lineCov">        412 :   target.fPt            = fPt;</span>
<span class="lineNum">     212 </span><span class="lineCov">        412 :   target.fdX            = fdX;</span>
<span class="lineNum">     213 </span><span class="lineCov">        412 :   target.fX0            = fX0;</span>
<span class="lineNum">     214 </span><span class="lineCov">        412 :   target.fX             = fX;</span>
<span class="lineNum">     215 </span><span class="lineCov">        412 :   target.fY             = fY;</span>
<span class="lineNum">     216 </span><span class="lineCov">        412 :   target.fZ             = fZ;</span>
<span class="lineNum">     217 </span><span class="lineCov">        412 :   target.fS2Y           = fS2Y;</span>
<span class="lineNum">     218 </span><span class="lineCov">        412 :   target.fS2Z           = fS2Z;</span>
<span class="lineNum">     219 </span><span class="lineCov">        412 :   target.fChi2          = fChi2;</span>
<span class="lineNum">     220 </span>            :   
<span class="lineNum">     221 </span><span class="lineCov">        412 :   memcpy(target.fIndexes, fIndexes, kNclusters*sizeof(Int_t));</span>
<span class="lineNum">     222 </span><span class="lineCov">        412 :   memcpy(target.fClusters, fClusters, kNclusters*sizeof(AliTRDcluster*));</span>
<span class="lineNum">     223 </span><span class="lineCov">        412 :   memcpy(target.fPad, fPad, 4*sizeof(Float_t));</span>
<span class="lineNum">     224 </span><span class="lineCov">        412 :   target.fYref[0] = fYref[0]; target.fYref[1] = fYref[1]; </span>
<span class="lineNum">     225 </span><span class="lineCov">        412 :   target.fZref[0] = fZref[0]; target.fZref[1] = fZref[1]; </span>
<span class="lineNum">     226 </span><span class="lineCov">        412 :   target.fYfit[0] = fYfit[0]; target.fYfit[1] = fYfit[1]; </span>
<span class="lineNum">     227 </span><span class="lineCov">        412 :   target.fZfit[0] = fZfit[0]; target.fZfit[1] = fZfit[1]; </span>
<span class="lineNum">     228 </span><span class="lineCov">        412 :   memcpy(target.fdEdx, fdEdx, kNdEdxSlices*sizeof(Float_t));</span>
<span class="lineNum">     229 </span><span class="lineCov">        412 :   memcpy(target.fProb, fProb, AliPID::kSPECIES*sizeof(Float_t)); </span>
<span class="lineNum">     230 </span><span class="lineCov">        412 :   memcpy(target.fLabels, fLabels, 3*sizeof(Int_t)); </span>
<span class="lineNum">     231 </span><span class="lineCov">        412 :   memcpy(target.fRefCov, fRefCov, 7*sizeof(Double_t)); </span>
<span class="lineNum">     232 </span><span class="lineCov">        412 :   target.fC[0] = fC[0]; target.fC[1] = fC[1];</span>
<span class="lineNum">     233 </span><span class="lineCov">        412 :   memcpy(target.fCov, fCov, 3*sizeof(Double_t)); </span>
<span class="lineNum">     234 </span>            :   
<span class="lineNum">     235 </span><span class="lineCov">        412 :   TObject::Copy(ref);</span>
<span class="lineNum">     236 </span><span class="lineCov">        412 : }</span>
<span class="lineNum">     237 </span>            : 
<a name="238"><span class="lineNum">     238 </span>            : </a>
<span class="lineNum">     239 </span>            : //____________________________________________________________
<span class="lineNum">     240 </span>            : void AliTRDseedV1::Init(const AliRieman *rieman)
<span class="lineNum">     241 </span>            : {
<span class="lineNum">     242 </span>            : // Initialize this tracklet using the riemann fit information
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :   fZref[0] = rieman-&gt;GetZat(fX0);</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :   fZref[1] = rieman-&gt;GetDZat(fX0);</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :   fYref[0] = rieman-&gt;GetYat(fX0);</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :   fYref[1] = rieman-&gt;GetDYat(fX0);</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :   if(fkReconstructor &amp;&amp; fkReconstructor-&gt;IsHLT()){</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :     fRefCov[0] = 1;</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :     fRefCov[2] = 10;</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :   }else{</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :     fRefCov[0] = rieman-&gt;GetErrY(fX0);</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :     fRefCov[2] = rieman-&gt;GetErrZ(fX0);</span>
<span class="lineNum">     255 </span>            :   }
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :   fC[0]    = rieman-&gt;GetC(); </span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :   fChi2    = rieman-&gt;GetChi2();</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     259 </span>            : 
<a name="260"><span class="lineNum">     260 </span>            : </a>
<span class="lineNum">     261 </span>            : //____________________________________________________________
<span class="lineNum">     262 </span>            : Bool_t AliTRDseedV1::Init(const AliTRDtrackV1 *track)
<span class="lineNum">     263 </span>            : {
<span class="lineNum">     264 </span>            : // Initialize this tracklet using the track information
<span class="lineNum">     265 </span>            : //
<span class="lineNum">     266 </span>            : // Parameters:
<span class="lineNum">     267 </span>            : //   track - the TRD track used to initialize the tracklet
<span class="lineNum">     268 </span>            : // 
<span class="lineNum">     269 </span>            : // Detailed description
<span class="lineNum">     270 </span>            : // The function sets the starting point and direction of the
<span class="lineNum">     271 </span>            : // tracklet according to the information from the TRD track.
<span class="lineNum">     272 </span>            : // 
<span class="lineNum">     273 </span>            : // Caution
<span class="lineNum">     274 </span>            : // The TRD track has to be propagated to the beginning of the
<span class="lineNum">     275 </span>            : // chamber where the tracklet will be constructed
<span class="lineNum">     276 </span>            : //
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span><span class="lineCov">        524 :   Double_t y, z; </span>
<span class="lineNum">     279 </span><span class="lineCov">        262 :   if(!track-&gt;GetProlongation(fX0, y, z)) return kFALSE;</span>
<span class="lineNum">     280 </span><span class="lineCov">        262 :   Update(track);</span>
<span class="lineNum">     281 </span><span class="lineCov">        262 :   return kTRUE;</span>
<span class="lineNum">     282 </span><span class="lineCov">        262 : }</span>
<span class="lineNum">     283 </span>            : 
<a name="284"><span class="lineNum">     284 </span>            : </a>
<span class="lineNum">     285 </span>            : //_____________________________________________________________________________
<span class="lineNum">     286 </span>            : void AliTRDseedV1::Reset(Option_t *opt)
<span class="lineNum">     287 </span>            : {
<span class="lineNum">     288 </span>            : //
<span class="lineNum">     289 </span>            : // Reset seed. If option opt=&quot;c&quot; is given only cluster arrays are cleared.
<span class="lineNum">     290 </span>            : //
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :   for(Int_t ic=kNclusters; ic--;) fIndexes[ic] = -1;</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :   memset(fClusters, 0, kNclusters*sizeof(AliTRDcluster*));</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :   fN=0; SetBit(kRowCross, kFALSE);</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :   if(strcmp(opt, &quot;c&quot;)==0) return;</span>
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :   fExB=0.;fVD=0.;fT0=0.;fS2PRF=0.;</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :   fDiffL=0.;fDiffT=0.;</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :   fClusterIdx=0;</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :   fErrorMsg = 0;</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :   fDet=-1;</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :   fPt=0.;</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :   fdX=0.;fX0=0.; fX=0.; fY=0.; fZ=0.;</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :   fS2Y=0.; fS2Z=0.;</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :   fC[0]=0.; fC[1]=0.; </span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :   fChi2 = 0.;</span>
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :   memset(fPad, 0, 4*sizeof(Float_t));</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :   fYref[0] = 0.; fYref[1] = 0.; </span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :   fZref[0] = 0.; fZref[1] = 0.; </span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :   fYfit[0] = 0.; fYfit[1] = 0.; </span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :   fZfit[0] = 0.; fZfit[1] = 0.; </span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :   memset(fdEdx, 0, kNdEdxSlices*sizeof(Float_t));</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :   for(int ispec=0; ispec&lt;AliPID::kSPECIES; ispec++) fProb[ispec]  = -1.;</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :   fLabels[0]=-1; fLabels[1]=-1; // most freq MC labels</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :   fLabels[2]=0;  // number of different labels for tracklet</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :   memset(fRefCov, 0, 7*sizeof(Double_t));</span>
<span class="lineNum">     317 </span>            :   // covariance matrix [diagonal]
<span class="lineNum">     318 </span>            :   // default sy = 200um and sz = 2.3 cm 
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :   fCov[0] = 4.e-4; fCov[1] = 0.; fCov[2] = 5.3; </span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 : }</span>
<a name="321"><span class="lineNum">     321 </span>            : </a>
<span class="lineNum">     322 </span>            : //____________________________________________________________________
<span class="lineNum">     323 </span>            : void AliTRDseedV1::Update(const AliTRDtrackV1 *trk)
<span class="lineNum">     324 </span>            : { 
<span class="lineNum">     325 </span>            :   // update tracklet reference position from the TRD track
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span><span class="lineCov">        524 :   Double_t fSnp = trk-&gt;GetSnp();</span>
<span class="lineNum">     328 </span><span class="lineCov">        262 :   Double_t fTgl = trk-&gt;GetTgl();</span>
<span class="lineNum">     329 </span><span class="lineCov">        262 :   fPt = trk-&gt;Pt();</span>
<span class="lineNum">     330 </span><span class="lineCov">        262 :   Double_t norm =1./TMath::Sqrt((1.-fSnp)*(1.+fSnp)); </span>
<span class="lineNum">     331 </span><span class="lineCov">        262 :   fYref[1] = fSnp*norm;</span>
<span class="lineNum">     332 </span><span class="lineCov">        262 :   fZref[1] = fTgl*norm;</span>
<span class="lineNum">     333 </span><span class="lineCov">        262 :   SetCovRef(trk-&gt;GetCovariance());</span>
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span><span class="lineCov">        262 :   Double_t dx = trk-&gt;GetX() - fX0;</span>
<span class="lineNum">     336 </span><span class="lineCov">        262 :   fYref[0] = trk-&gt;GetY() - dx*fYref[1];</span>
<span class="lineNum">     337 </span><span class="lineCov">        262 :   fZref[0] = trk-&gt;GetZ() - dx*fZref[1];</span>
<span class="lineNum">     338 </span><span class="lineCov">        262 : }</span>
<a name="339"><span class="lineNum">     339 </span>            : </a>
<span class="lineNum">     340 </span>            : //_____________________________________________________________________________
<span class="lineNum">     341 </span>            : void AliTRDseedV1::UpdateUsed()
<span class="lineNum">     342 </span>            : {
<span class="lineNum">     343 </span>            :   //
<span class="lineNum">     344 </span>            :   // Calculate number of used clusers in the tracklet
<span class="lineNum">     345 </span>            :   //
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span>            :   Int_t nused = 0, nshared = 0;
<span class="lineNum">     348 </span><span class="lineCov">      14820 :   for (Int_t i = kNclusters; i--; ) {</span>
<span class="lineNum">     349 </span><span class="lineCov">      14136 :     if (!fClusters[i]) continue;</span>
<span class="lineNum">     350 </span><span class="lineCov">       4968 :     if(fClusters[i]-&gt;IsUsed()){ </span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :       nused++;</span>
<span class="lineNum">     352 </span><span class="lineCov">       4968 :     } else if(fClusters[i]-&gt;IsShared()){</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :       if(IsStandAlone()) nused++;</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :       else nshared++;</span>
<span class="lineNum">     355 </span>            :     }
<span class="lineNum">     356 </span>            :   }
<span class="lineNum">     357 </span><span class="lineCov">        228 :   SetNUsed(nused);</span>
<span class="lineNum">     358 </span><span class="lineCov">        228 :   SetNShared(nshared);</span>
<span class="lineNum">     359 </span><span class="lineCov">        228 : }</span>
<a name="360"><span class="lineNum">     360 </span>            : </a>
<span class="lineNum">     361 </span>            : //_____________________________________________________________________________
<span class="lineNum">     362 </span>            : void AliTRDseedV1::UseClusters()
<span class="lineNum">     363 </span>            : {
<span class="lineNum">     364 </span>            :   //
<span class="lineNum">     365 </span>            :   // Use clusters
<span class="lineNum">     366 </span>            :   //
<span class="lineNum">     367 </span>            :   // In stand alone mode:
<span class="lineNum">     368 </span>            :   // Clusters which are marked as used or shared from another track are
<span class="lineNum">     369 </span>            :   // removed from the tracklet
<span class="lineNum">     370 </span>            :   //
<span class="lineNum">     371 </span>            :   // In barrel mode:
<span class="lineNum">     372 </span>            :   // - Clusters which are used by another track become shared
<span class="lineNum">     373 </span>            :   // - Clusters which are attached to a kink track become shared
<span class="lineNum">     374 </span>            :   //
<span class="lineNum">     375 </span><span class="lineCov">        412 :   AliTRDcluster **c = &amp;fClusters[0];</span>
<span class="lineNum">     376 </span><span class="lineCov">      25956 :   for (Int_t ic=kNclusters; ic--; c++) {</span>
<span class="lineNum">     377 </span><span class="lineCov">      12772 :     if(!(*c)) continue;</span>
<span class="lineNum">     378 </span><span class="lineCov">       8960 :     if(IsStandAlone()){</span>
<span class="lineNum">     379 </span><span class="lineCov">       4480 :       if((*c)-&gt;IsShared() || (*c)-&gt;IsUsed()){ </span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :         if((*c)-&gt;IsShared()) SetNShared(GetNShared()-1);</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :         else SetNUsed(GetNUsed()-1);</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :         (*c) = NULL;</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :         fIndexes[ic] = -1;</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :         SetN(GetN()-1);</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     386 </span>            :       }
<span class="lineNum">     387 </span>            :     } else {
<span class="lineNum">     388 </span><span class="lineCov">       8960 :       if((*c)-&gt;IsUsed() || IsKink()){</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :         (*c)-&gt;SetShared();</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     391 </span>            :       }
<span class="lineNum">     392 </span>            :     }
<span class="lineNum">     393 </span><span class="lineCov">       4480 :     (*c)-&gt;Use();</span>
<span class="lineNum">     394 </span><span class="lineCov">       4480 :   }</span>
<span class="lineNum">     395 </span><span class="lineCov">        206 : }</span>
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            : 
<a name="398"><span class="lineNum">     398 </span>            : </a>
<span class="lineNum">     399 </span>            : //____________________________________________________________________
<span class="lineNum">     400 </span>            : void AliTRDseedV1::CookdEdx(Int_t nslices)
<span class="lineNum">     401 </span>            : {
<span class="lineNum">     402 </span>            : // Calculates average dE/dx for all slices and store them in the internal array fdEdx. 
<span class="lineNum">     403 </span>            : //
<span class="lineNum">     404 </span>            : // Parameters:
<span class="lineNum">     405 </span>            : //  nslices : number of slices for which dE/dx should be calculated
<span class="lineNum">     406 </span>            : // Output:
<span class="lineNum">     407 </span>            : //  store results in the internal array fdEdx. This can be accessed with the method
<span class="lineNum">     408 </span>            : //  AliTRDseedV1::GetdEdx()
<span class="lineNum">     409 </span>            : //
<span class="lineNum">     410 </span>            : // Detailed description
<span class="lineNum">     411 </span>            : // Calculates average dE/dx for all slices. Depending on the PID methode 
<span class="lineNum">     412 </span>            : // the number of slices can be 3 (LQ) or 8(NN). 
<span class="lineNum">     413 </span>            : // The calculation of dQ/dl are done using the tracklet fit results (see AliTRDseedV1::GetdQdl(Int_t))
<span class="lineNum">     414 </span>            : //
<span class="lineNum">     415 </span>            : // The following effects are included in the calculation:
<span class="lineNum">     416 </span>            : // 1. calibration values for t0 and vdrift (using x coordinate to calculate slice)
<span class="lineNum">     417 </span>            : // 2. cluster sharing (optional see AliTRDrecoParam::SetClusterSharing())
<span class="lineNum">     418 </span>            : // 3. cluster size
<span class="lineNum">     419 </span>            : //
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span><span class="lineCov">        412 :   memset(fdEdx, 0, kNdEdxSlices*sizeof(Float_t));</span>
<span class="lineNum">     422 </span><span class="lineCov">        206 :   const Double_t kDriftLength = (.5 * AliTRDgeometry::AmThick() + AliTRDgeometry::DrThick());</span>
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span>            :   AliTRDcluster *c(NULL);
<span class="lineNum">     425 </span><span class="lineCov">      11536 :   for(int ic=0; ic&lt;AliTRDtrackerV1::GetNTimeBins(); ic++){</span>
<span class="lineNum">     426 </span><span class="lineCov">       6808 :     if(!(c = fClusters[ic]) &amp;&amp; !(c = fClusters[ic+kNtb])) continue;</span>
<span class="lineNum">     427 </span><span class="lineCov">       4444 :     Float_t dx = TMath::Abs(fX0 - c-&gt;GetX());</span>
<span class="lineNum">     428 </span>            : 
<span class="lineNum">     429 </span>            :     // Filter clusters for dE/dx calculation
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span>            :     // 1.consider calibration effects for slice determination
<span class="lineNum">     432 </span>            :     Int_t slice;
<span class="lineNum">     433 </span><span class="lineCov">       4444 :     if(dx&lt;kDriftLength){ // TODO should be replaced by c-&gt;IsInChamber()</span>
<span class="lineNum">     434 </span><span class="lineCov">       4300 :       slice = Int_t(dx * nslices / kDriftLength);</span>
<span class="lineNum">     435 </span><span class="lineCov">       4444 :     } else slice = c-&gt;GetX() &lt; fX0 ? nslices-1 : 0;</span>
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            :     // 2. take sharing into account
<span class="lineNum">     439 </span>            :     Float_t w = /*c-&gt;IsShared() ? .5 :*/ 1.;
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span>            :     // 3. take into account large clusters TODO
<span class="lineNum">     442 </span>            :     //w *= c-&gt;GetNPads() &gt; 3 ? .8 : 1.;
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            :     //CHECK !!!
<span class="lineNum">     445 </span><span class="lineCov">       4444 :     fdEdx[slice]   += w * GetdQdl(ic); //fdQdl[ic];</span>
<span class="lineNum">     446 </span><span class="lineCov">       4444 :   } // End of loop over clusters</span>
<span class="lineNum">     447 </span><span class="lineCov">        206 : }</span>
<a name="448"><span class="lineNum">     448 </span>            : </a>
<span class="lineNum">     449 </span>            : //_____________________________________________________________________________
<span class="lineNum">     450 </span>            : void AliTRDseedV1::CookLabels()
<span class="lineNum">     451 </span>            : {
<span class="lineNum">     452 </span>            :   //
<span class="lineNum">     453 </span>            :   // Cook 2 labels for seed
<span class="lineNum">     454 </span>            :   //
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :   Int_t labels[200];</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :   Int_t out[200];</span>
<span class="lineNum">     458 </span>            :   Int_t nlab = 0;
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :   for (Int_t i = 0; i &lt; kNclusters; i++) {</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :     if (!fClusters[i]) continue;</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :     for (Int_t ilab = 0; ilab &lt; 3; ilab++) {</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :       if (fClusters[i]-&gt;GetLabel(ilab) &gt;= 0) {</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :         labels[nlab] = fClusters[i]-&gt;GetLabel(ilab);</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :         nlab++;</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     466 </span>            :     }
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :   fLabels[2] = AliMathBase::Freq(nlab,labels,out,kTRUE);</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :   fLabels[0] = out[0];</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :   if ((fLabels[2]  &gt; 1) &amp;&amp; (out[3] &gt; 1)) fLabels[1] = out[2];</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 : }</span>
<a name="473"><span class="lineNum">     473 </span>            : </a>
<span class="lineNum">     474 </span>            : //____________________________________________________________
<span class="lineNum">     475 </span>            : Float_t AliTRDseedV1::GetAnodeWireOffset(Float_t zt)
<span class="lineNum">     476 </span>            : {
<span class="lineNum">     477 </span>            : // Find position inside the amplification cell for reading drift velocity map
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :   Float_t d = fPad[3] - zt;</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :   if(d&lt;0.){</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :     AliError(Form(&quot;Fail AnodeWireOffset calculation z0[%+7.2f] zt[%+7.2f] d[%+7.2f].&quot;, fPad[3], zt, d));</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :     return 0.125;</span>
<span class="lineNum">     483 </span>            :   } 
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :   d -= ((Int_t)(2 * d)) / 2.0;</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :   if(d &gt; 0.25) d = 0.5 - d;</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :   return d;</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     488 </span>            : 
<a name="489"><span class="lineNum">     489 </span>            : </a>
<span class="lineNum">     490 </span>            : //____________________________________________________________________
<span class="lineNum">     491 </span>            : Float_t AliTRDseedV1::GetCharge(Bool_t useOutliers) const
<span class="lineNum">     492 </span>            : {
<span class="lineNum">     493 </span>            : // Computes total charge attached to tracklet. If &quot;useOutliers&quot; is set clusters 
<span class="lineNum">     494 </span>            : // which are not in chamber are also used (default false)
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span>            :   AliTRDcluster *c(NULL); Float_t qt(0.);
<span class="lineNum">     497 </span><span class="lineCov">      51912 :   for(int ic=0; ic&lt;kNclusters; ic++){</span>
<span class="lineNum">     498 </span><span class="lineCov">      25544 :     if(!(c=fClusters[ic])) continue;</span>
<span class="lineNum">     499 </span><span class="lineCov">       9516 :     if(!c-&gt;IsInChamber() &amp;&amp; !useOutliers) continue;</span>
<span class="lineNum">     500 </span><span class="lineCov">       8960 :     qt += TMath::Abs(c-&gt;GetQ());</span>
<span class="lineNum">     501 </span><span class="lineCov">       8960 :   }</span>
<span class="lineNum">     502 </span><span class="lineCov">        412 :   return qt;</span>
<span class="lineNum">     503 </span>            : }
<a name="504"><span class="lineNum">     504 </span>            : </a>
<span class="lineNum">     505 </span>            : //____________________________________________________________________
<span class="lineNum">     506 </span>            : Int_t AliTRDseedV1::GetChargeGaps(Float_t sz[kNtb], Float_t pos[kNtb], Int_t isz[kNtb]) const
<span class="lineNum">     507 </span>            : {
<span class="lineNum">     508 </span>            : // Find number, size and position of charge gaps (consecutive missing time bins).
<span class="lineNum">     509 </span>            : // Returns the number of gaps and fills their size in input array &quot;sz&quot; and position in array &quot;pos&quot;
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span>            :   Bool_t gap(kFALSE);
<span class="lineNum">     512 </span>            :   Int_t n(0);
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :   Int_t ipos[kNtb]; memset(isz, 0, kNtb*sizeof(Int_t));memset(ipos, 0, kNtb*sizeof(Int_t));</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :   for(int ic(0); ic&lt;kNtb; ic++){</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :     if(fClusters[ic] || fClusters[ic+kNtb]){</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :       if(gap) n++;</span>
<span class="lineNum">     517 </span>            :       continue;
<span class="lineNum">     518 </span>            :     }
<span class="lineNum">     519 </span>            :     gap = kTRUE;
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :     isz[n]++;</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :     ipos[n] = ic;</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :   if(!n) return 0;</span>
<span class="lineNum">     524 </span>            : 
<span class="lineNum">     525 </span>            :   // write calibrated values
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :   AliTRDcluster fake;</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :   for(Int_t igap(0); igap&lt;n; igap++){</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :     sz[igap] = isz[igap]*fVD/AliTRDCommonParam::Instance()-&gt;GetSamplingFrequency();</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :     fake.SetPadTime(ipos[igap]);</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :     pos[igap] = fake.GetXloc(fT0, fVD);</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :     if(isz[igap]&gt;1){</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :       fake.SetPadTime(ipos[igap]-isz[igap]+1);</span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :       pos[igap] += fake.GetXloc(fT0, fVD);</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :       pos[igap] /= 2.;</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     536 </span>            :   }
<span class="lineNum">     537 </span>            :   return n;
<span class="lineNum">     538 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     539 </span>            : 
<a name="540"><span class="lineNum">     540 </span>            : </a>
<span class="lineNum">     541 </span>            : //____________________________________________________________________
<span class="lineNum">     542 </span>            : Double_t AliTRDseedV1::EstimatedCrossPoint(AliTRDpadPlane *pp, Float_t bz)
<span class="lineNum">     543 </span>            : {
<span class="lineNum">     544 </span>            : // Algorithm to estimate cross point in the x-z plane for pad row cross tracklets or the z coordinate of pad row without pad row cross in the local chamber coordinates.
<span class="lineNum">     545 </span>            : // Returns variance of the radial offset from anode wire in case of raw cross or 0 otherwise.
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span>            :   Int_t row[] = {-1, -1};
<span class="lineNum">     548 </span><span class="lineCov">        456 :   Double_t zoff(0.5 * (pp-&gt;GetRow0() + pp-&gt;GetRowEnd())), sx(0.), mean(0.5*pp-&gt;GetNrows()-0.5);</span>
<span class="lineNum">     549 </span>            :   AliTRDcluster *c(NULL);
<span class="lineNum">     550 </span><span class="lineCov">        228 :   fS2Y = 0.;</span>
<span class="lineNum">     551 </span>            :   
<span class="lineNum">     552 </span><span class="lineCov">        228 :   if(!IsRowCross()){ </span>
<span class="lineNum">     553 </span><span class="lineCov">       1396 :     for(int ic=0; ic&lt;kNtb; ic++){</span>
<span class="lineNum">     554 </span><span class="lineCov">        698 :       if(!(c=fClusters[ic])) continue;</span>
<span class="lineNum">     555 </span><span class="lineCov">        354 :       if(!c-&gt;IsInChamber()) continue;</span>
<span class="lineNum">     556 </span><span class="lineCov">        214 :       row[0]   = c-&gt;GetPadRow();</span>
<span class="lineNum">     557 </span><span class="lineCov">        428 :       fZfit[0] = Int_t(mean-row[0])*pp-&gt;GetLengthIPad() + </span>
<span class="lineNum">     558 </span><span class="lineCov">        856 :                  0.5*(mean-row[0]&gt;0.?1.:-1.)*(row[0]&gt;0&amp;&amp;row[0]&lt;pp-&gt;GetNrows()-1?pp-&gt;GetLengthIPad():pp-&gt;GetLengthOPad());      </span>
<span class="lineNum">     559 </span><span class="lineCov">        214 :       break;</span>
<span class="lineNum">     560 </span>            :     }
<span class="lineNum">     561 </span><span class="lineCov">        214 :   } else {  </span>
<span class="lineNum">     562 </span>            :     Float_t tbm[2] = {0.}; // mean value of time bin in rows
<span class="lineNum">     563 </span><span class="lineCov">         14 :     Int_t tb[kNtb]={0}, //array of time bins from first row</span>
<span class="lineNum">     564 </span>            :           nc[2] = {0},  // no. of clusters in rows
<span class="lineNum">     565 </span>            :           mc(0);  // no. of common clusters
<span class="lineNum">     566 </span>            :     Bool_t w[2] = {kFALSE, kFALSE};   // acceptance flag for rows
<span class="lineNum">     567 </span>            :     // Find radial range for first row
<span class="lineNum">     568 </span><span class="lineCov">        896 :     for(int ic(0); ic&lt;kNtb; ic++){</span>
<span class="lineNum">     569 </span><span class="lineCov">        434 :       tb[ic]= -1;</span>
<span class="lineNum">     570 </span><span class="lineCov">        618 :       if(!(c=fClusters[ic]) || !c-&gt;IsInChamber()) continue;</span>
<span class="lineNum">     571 </span><span class="lineCov">        180 :       if(row[0]&lt;0) row[0] = c-&gt;GetPadRow();</span>
<span class="lineNum">     572 </span><span class="lineCov">        166 :       tb[nc[0]++] = ic; tbm[0] += ic;</span>
<span class="lineNum">     573 </span><span class="lineCov">        166 :     }</span>
<span class="lineNum">     574 </span><span class="lineCov">         14 :     if(nc[0]&gt;2){</span>
<span class="lineNum">     575 </span><span class="lineCov">         14 :       tbm[0] /= nc[0];</span>
<span class="lineNum">     576 </span>            :       w[0] = kTRUE;
<span class="lineNum">     577 </span><span class="lineCov">         14 :     }</span>
<span class="lineNum">     578 </span>            :     // Find radial range for second row
<span class="lineNum">     579 </span><span class="lineCov">        896 :     for(int ic(kNtb), jc(0); ic&lt;kNclusters; ic++, jc++){</span>
<span class="lineNum">     580 </span><span class="lineCov">        598 :       if(!(c=fClusters[ic]) || !c-&gt;IsInChamber()) continue;</span>
<span class="lineNum">     581 </span><span class="lineCov">        170 :       if(row[1]&lt;0) row[1] = c-&gt;GetPadRow();</span>
<span class="lineNum">     582 </span><span class="lineCov">        156 :       tbm[1] += jc; nc[1]++;</span>
<span class="lineNum">     583 </span><span class="lineCov">       3266 :       for(Int_t kc(0); kc&lt;nc[0]; kc++) </span>
<span class="lineNum">     584 </span><span class="lineCov">       1450 :         if(tb[kc]==jc){</span>
<span class="lineNum">     585 </span><span class="lineCov">         34 :           tb[kc] += 100; // mark common cluster</span>
<span class="lineNum">     586 </span><span class="lineCov">         34 :           mc++;</span>
<span class="lineNum">     587 </span><span class="lineCov">         34 :           break;</span>
<span class="lineNum">     588 </span>            :         }
<span class="lineNum">     589 </span><span class="lineCov">        156 :     }</span>
<span class="lineNum">     590 </span><span class="lineCov">         14 :     if(nc[1]&gt;2){</span>
<span class="lineNum">     591 </span><span class="lineCov">         14 :       tbm[1] /= nc[1];</span>
<span class="lineNum">     592 </span>            :       w[1] = kTRUE;
<span class="lineNum">     593 </span><span class="lineCov">         14 :     }</span>
<span class="lineNum">     594 </span>            :     //printf(&quot;0 : %f[%2d] 1 : %f[%2d] mc[%d]\n&quot;, tbm[0], nc[0], tbm[1], nc[1], mc);
<span class="lineNum">     595 </span><span class="lineCov">         14 :     if(!w[0] &amp;&amp; !w[1]){</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :       AliError(&quot;Too few clusters to estimate tracklet.&quot;);</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :       return -1;</span>
<span class="lineNum">     598 </span>            :     }
<span class="lineNum">     599 </span><span class="lineCov">         28 :     if(!w[0] || !w[1]){ </span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :       SetBit(kRowCross, kFALSE); // reset RC bit</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :       if(w[1]) row[0] = row[1];</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :       fZfit[0] = Int_t(mean-row[0])*pp-&gt;GetLengthIPad() + </span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :                  0.5*(mean-row[0]&gt;0.?1.:-1.)*(row[0]&gt;0&amp;&amp;row[0]&lt;pp-&gt;GetNrows()-1?pp-&gt;GetLengthIPad():pp-&gt;GetLengthOPad());      </span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :     }else{ // find the best matching timebin </span>
<span class="lineNum">     605 </span><span class="lineCov">         14 :       fZfit[0] = Int_t(mean-0.5*(row[0]+row[1]))*pp-&gt;GetLengthIPad(); </span>
<span class="lineNum">     606 </span>            :       Int_t itb(0), dtb(0);
<span class="lineNum">     607 </span><span class="lineCov">         14 :       if(!mc) { // no common range</span>
<span class="lineNum">     608 </span><span class="lineCov">          6 :         itb = Int_t(0.5*(tbm[0] + tbm[1]));</span>
<span class="lineNum">     609 </span><span class="lineCov">          6 :         dtb = Int_t(0.5*TMath::Abs(tbm[0] - tbm[1])); // simple parameterization of the cluster gap</span>
<span class="lineNum">     610 </span><span class="lineCov">          6 :       } else {</span>
<span class="lineNum">     611 </span>            :         Double_t rmax(100.); Int_t itbStart(-1), itbStop(0);
<span class="lineNum">     612 </span>            :         // compute distance from 
<span class="lineNum">     613 </span><span class="lineCov">        204 :         for(Int_t jc(0); jc&lt;nc[0]; jc++){</span>
<span class="lineNum">     614 </span><span class="lineCov">         94 :           if(tb[jc] &lt; 100) continue;</span>
<span class="lineNum">     615 </span><span class="lineCov">         34 :           Int_t ltb(tb[jc]-100);</span>
<span class="lineNum">     616 </span><span class="lineCov">         34 :           Double_t r = (1. - ltb/tbm[0])*(1. - ltb/tbm[1]);</span>
<span class="lineNum">     617 </span>            :           //printf(&quot;tb[%2d] dr[%f %f %f] rmax[%f]\n&quot;, ltb, r, 1. - ltb/tbm[0], 1. - ltb/tbm[1], rmax);
<span class="lineNum">     618 </span><span class="lineCov">         56 :           if(TMath::Abs(r)&lt;rmax){ rmax = TMath::Abs(r); itb = ltb; }</span>
<span class="lineNum">     619 </span><span class="lineCov">         42 :           if(itbStart&lt;0) itbStart = ltb;</span>
<span class="lineNum">     620 </span>            :           itbStop = ltb;
<span class="lineNum">     621 </span><span class="lineCov">         34 :         } </span>
<span class="lineNum">     622 </span><span class="lineCov">          8 :         dtb = itbStop-itbStart+1;</span>
<span class="lineNum">     623 </span>            :       }
<span class="lineNum">     624 </span><span class="lineCov">         14 :       AliTRDCommonParam *cp = AliTRDCommonParam::Instance(); </span>
<span class="lineNum">     625 </span><span class="lineCov">         42 :       Double_t freq(cp?cp-&gt;GetSamplingFrequency():10.);</span>
<span class="lineNum">     626 </span><span class="lineCov">         14 :       fS2Y = ((itb-0.5)/freq - fT0 - 0.189)*fVD; // xOff</span>
<span class="lineNum">     627 </span><span class="lineCov">         14 :       sx   = dtb*0.288675134594812921/freq; sx *= sx; sx += 1.56e-2; sx *= fVD*fVD;</span>
<span class="lineNum">     628 </span>            :     }    
<span class="lineNum">     629 </span><span class="lineCov">         28 :   }</span>
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span>            :   // estimate dzdx
<span class="lineNum">     632 </span><span class="lineCov">        228 :   Float_t dx(fX0-fS2Y);</span>
<span class="lineNum">     633 </span><span class="lineCov">        228 :   fZfit[1] = (fZfit[0]+zoff)/dx; </span>
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span>            :   // correct dzdx for the bias
<span class="lineNum">     636 </span><span class="lineCov">        228 :   UnbiasDZDX(IsRowCross(), bz);</span>
<span class="lineNum">     637 </span><span class="lineCov">        228 :   if(IsRowCross()){</span>
<span class="lineNum">     638 </span>            :     // correct x_cross/sigma(x_cross) for the bias in dzdx
<span class="lineNum">     639 </span><span class="lineCov">         14 :     const AliTRDrecoParam* const recoParam = fkReconstructor-&gt;GetRecoParam();</span>
<span class="lineNum">     640 </span><span class="lineCov">         14 :     if(recoParam){ </span>
<span class="lineNum">     641 </span><span class="lineCov">         14 :       fS2Y += recoParam-&gt;GetCorrDZDXxcross()*TMath::Abs(fZfit[1]);</span>
<span class="lineNum">     642 </span><span class="lineCov">         14 :       sx   += recoParam-&gt;GetCorrDZDXxcross()*recoParam-&gt;GetCorrDZDXxcross()*GetS2DZDX(fZfit[1]);</span>
<span class="lineNum">     643 </span><span class="lineCov">         14 :     }</span>
<span class="lineNum">     644 </span>            :     // correct sigma(x_cross) for the width of the crossing area
<span class="lineNum">     645 </span><span class="lineCov">         14 :     sx   += GetS2XcrossDZDX(TMath::Abs(fZfit[1]));</span>
<span class="lineNum">     646 </span>            :     
<span class="lineNum">     647 </span>            :     // estimate z and error @ anode wire
<span class="lineNum">     648 </span><span class="lineCov">         14 :     fZfit[0] += fZfit[1]*fS2Y;</span>
<span class="lineNum">     649 </span><span class="lineCov">         14 :     fS2Z  = fZfit[1]*fZfit[1]*sx+fS2Y*fS2Y*GetS2DZDX(fZfit[1]); </span>
<span class="lineNum">     650 </span><span class="lineCov">         14 :   }</span>
<span class="lineNum">     651 </span>            :   return sx;
<span class="lineNum">     652 </span><span class="lineCov">        228 : }</span>
<a name="653"><span class="lineNum">     653 </span>            : </a>
<span class="lineNum">     654 </span>            : //____________________________________________________________________
<span class="lineNum">     655 </span>            : void AliTRDseedV1::UnbiasDZDX(Bool_t rc, Float_t bz)
<span class="lineNum">     656 </span>            : {
<span class="lineNum">     657 </span>            :   // correct dzdx for the bias in z according to MC
<span class="lineNum">     658 </span><span class="lineCov">        228 :   const AliTRDrecoParam* const recoParam = fkReconstructor-&gt;GetRecoParam();</span>
<span class="lineNum">     659 </span><span class="lineCov">        228 :   if(!recoParam) return;</span>
<span class="lineNum">     660 </span><span class="lineCov">        228 :   fZfit[1] *= recoParam-&gt;GetCorrDZDX(rc)-(bz&gt;0?0.01:0.);</span>
<span class="lineNum">     661 </span><span class="lineCov">        242 :   if(rc) fZfit[1] += recoParam-&gt;GetCorrDZDXbiasRC(fZfit[1]&lt;0);</span>
<span class="lineNum">     662 </span><span class="lineCov">        456 : }</span>
<a name="663"><span class="lineNum">     663 </span>            : </a>
<span class="lineNum">     664 </span>            : //____________________________________________________________________
<span class="lineNum">     665 </span>            : Double_t AliTRDseedV1::UnbiasY(Bool_t rc, Float_t bz)
<span class="lineNum">     666 </span>            : {
<span class="lineNum">     667 </span>            : // correct y coordinate for tail cancellation. This should be fixed by considering TC as a function of q/pt. 
<span class="lineNum">     668 </span>            : //  rc : TRUE if tracklet crosses rows
<span class="lineNum">     669 </span>            : // bz : magnetic field z component
<span class="lineNum">     670 </span>            :   
<span class="lineNum">     671 </span><span class="lineCov">        228 :   const AliTRDrecoParam* const recoParam = fkReconstructor-&gt;GetRecoParam();</span>
<span class="lineNum">     672 </span><span class="lineCov">        228 :   if(!recoParam) return 0.;</span>
<span class="lineNum">     673 </span><span class="lineCov">        228 :   Double_t par[3]={0.};</span>
<span class="lineNum">     674 </span><span class="lineCov">        228 :   Int_t idx(2*(rc?1:0)+Int_t(bz&gt;0));</span>
<span class="lineNum">     675 </span><span class="lineCov">        228 :   recoParam-&gt;GetYcorrTailCancel(idx, par);</span>
<span class="lineNum">     676 </span><span class="lineCov">        228 :   return par[0]*TMath::Sin(par[1]*fYref[1])+par[2];</span>
<span class="lineNum">     677 </span><span class="lineCov">        456 : }</span>
<span class="lineNum">     678 </span>            : 
<a name="679"><span class="lineNum">     679 </span>            : </a>
<span class="lineNum">     680 </span>            : //____________________________________________________________________
<span class="lineNum">     681 </span>            : Float_t AliTRDseedV1::GetQperTB(Int_t tb) const
<span class="lineNum">     682 </span>            : {
<span class="lineNum">     683 </span>            :   //
<span class="lineNum">     684 </span>            :   // Charge of the clusters at timebin
<span class="lineNum">     685 </span>            :   //
<span class="lineNum">     686 </span>            :   Float_t q = 0;
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :   if(fClusters[tb] /*&amp;&amp; fClusters[tb]-&gt;IsInChamber()*/)</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :     q += TMath::Abs(fClusters[tb]-&gt;GetQ());</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :   if(fClusters[tb+kNtb] /*&amp;&amp; fClusters[tb+kNtb]-&gt;IsInChamber()*/)</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :     q += TMath::Abs(fClusters[tb+kNtb]-&gt;GetQ());</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :   return q/TMath::Sqrt(1. + fYref[1]*fYref[1] + fZref[1]*fZref[1]);</span>
<span class="lineNum">     692 </span>            : }
<a name="693"><span class="lineNum">     693 </span>            : </a>
<span class="lineNum">     694 </span>            : //____________________________________________________________________
<span class="lineNum">     695 </span>            : Float_t AliTRDseedV1::GetdQdl() const
<span class="lineNum">     696 </span>            : {
<span class="lineNum">     697 </span>            : // Calculate total charge / tracklet length for 1D PID
<span class="lineNum">     698 </span>            : //
<span class="lineNum">     699 </span><span class="lineCov">        824 :   Float_t Q = GetCharge(kTRUE);</span>
<span class="lineNum">     700 </span><span class="lineCov">        412 :   return Q/TMath::Sqrt(1. + fYref[1]*fYref[1] + fZref[1]*fZref[1]);</span>
<span class="lineNum">     701 </span>            : }
<a name="702"><span class="lineNum">     702 </span>            : </a>
<span class="lineNum">     703 </span>            : //____________________________________________________________________
<span class="lineNum">     704 </span>            : Float_t AliTRDseedV1::GetdQdl(Int_t ic, Float_t *dl) const
<span class="lineNum">     705 </span>            : {
<span class="lineNum">     706 </span>            : // Using the linear approximation of the track inside one TRD chamber (TRD tracklet) 
<span class="lineNum">     707 </span>            : // the charge per unit length can be written as:
<span class="lineNum">     708 </span>            : // BEGIN_LATEX
<span class="lineNum">     709 </span>            : // #frac{dq}{dl} = #frac{q_{c}}{dx * #sqrt{1 + #(){#frac{dy}{dx}}^{2}_{fit} + #(){#frac{dz}{dx}}^{2}_{ref}}}
<span class="lineNum">     710 </span>            : // END_LATEX
<span class="lineNum">     711 </span>            : // where qc is the total charge collected in the current time bin and dx is the length 
<span class="lineNum">     712 </span>            : // of the time bin. 
<span class="lineNum">     713 </span>            : // The following correction are applied :
<span class="lineNum">     714 </span>            : //   - charge : pad row cross corrections
<span class="lineNum">     715 </span>            : //              [diffusion and TRF assymetry] TODO
<span class="lineNum">     716 </span>            : //   - dx     : anisochronity, track inclination - see Fit and AliTRDcluster::GetXloc() 
<span class="lineNum">     717 </span>            : //              and AliTRDcluster::GetYloc() for the effects taken into account
<span class="lineNum">     718 </span>            : // 
<span class="lineNum">     719 </span>            : //Begin_Html
<span class="lineNum">     720 </span>            : //&lt;img src=&quot;TRD/trackletDQDT.gif&quot;&gt;
<span class="lineNum">     721 </span>            : //End_Html
<span class="lineNum">     722 </span>            : // In the picture the energy loss measured on the tracklet as a function of drift time [left] and respectively 
<span class="lineNum">     723 </span>            : // drift length [right] for different particle species is displayed.
<span class="lineNum">     724 </span>            : // Author : Alex Bercuci &lt;A.Bercuci@gsi.de&gt;
<span class="lineNum">     725 </span>            : //
<span class="lineNum">     726 </span>            :   Float_t dq = 0.;
<span class="lineNum">     727 </span>            :   // check whether both clusters are inside the chamber
<span class="lineNum">     728 </span>            :   Bool_t hasClusterInChamber = kFALSE;
<span class="lineNum">     729 </span><span class="lineCov">      13204 :   if(fClusters[ic] &amp;&amp; fClusters[ic]-&gt;IsInChamber()){</span>
<span class="lineNum">     730 </span>            :     hasClusterInChamber = kTRUE;
<span class="lineNum">     731 </span><span class="lineCov">       4046 :     dq += TMath::Abs(fClusters[ic]-&gt;GetQ());</span>
<span class="lineNum">     732 </span><span class="lineCov">       4046 :   }</span>
<span class="lineNum">     733 </span><span class="lineCov">       4608 :   if(fClusters[ic+kNtb] &amp;&amp; fClusters[ic+kNtb]-&gt;IsInChamber()){</span>
<span class="lineNum">     734 </span>            :     hasClusterInChamber = kTRUE;
<span class="lineNum">     735 </span><span class="lineCov">        156 :     dq += TMath::Abs(fClusters[ic+kNtb]-&gt;GetQ());</span>
<span class="lineNum">     736 </span><span class="lineCov">        156 :   }</span>
<span class="lineNum">     737 </span><span class="lineCov">       4720 :   if(!hasClusterInChamber) return 0.;</span>
<span class="lineNum">     738 </span><span class="lineCov">       4168 :   if(dq&lt;1.e-3) return 0.;</span>
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span><span class="lineCov">       4168 :   Double_t dx = fdX;</span>
<span class="lineNum">     741 </span><span class="lineCov">       8336 :   if(ic-1&gt;=0 &amp;&amp; ic+1&lt;kNtb){</span>
<span class="lineNum">     742 </span>            :     Float_t x2(0.), x1(0.);
<span class="lineNum">     743 </span>            :     // try to estimate upper radial position (find the cluster which is inside the chamber)
<span class="lineNum">     744 </span><span class="lineCov">      11706 :     if(fClusters[ic-1] &amp;&amp; fClusters[ic-1]-&gt;IsInChamber()) x2 = fClusters[ic-1]-&gt;GetX(); </span>
<span class="lineNum">     745 </span><span class="lineCov">        695 :     else if(fClusters[ic-1+kNtb] &amp;&amp; fClusters[ic-1+kNtb]-&gt;IsInChamber()) x2 = fClusters[ic-1+kNtb]-&gt;GetX(); </span>
<span class="lineNum">     746 </span><span class="lineCov">       1003 :     else if(fClusters[ic] &amp;&amp; fClusters[ic]-&gt;IsInChamber()) x2 = fClusters[ic]-&gt;GetX()+fdX;</span>
<span class="lineNum">     747 </span><span class="lineCov">         10 :     else x2 = fClusters[ic+kNtb]-&gt;GetX()+fdX;</span>
<span class="lineNum">     748 </span>            :     // try to estimate lower radial position (find the cluster which is inside the chamber)
<span class="lineNum">     749 </span><span class="lineCov">      11683 :     if(fClusters[ic+1] &amp;&amp; fClusters[ic+1]-&gt;IsInChamber()) x1 = fClusters[ic+1]-&gt;GetX();</span>
<span class="lineNum">     750 </span><span class="lineCov">        677 :     else if(fClusters[ic+1+kNtb] &amp;&amp; fClusters[ic+1+kNtb]-&gt;IsInChamber()) x1 = fClusters[ic+1+kNtb]-&gt;GetX();</span>
<span class="lineNum">     751 </span><span class="lineCov">       1011 :     else if(fClusters[ic] &amp;&amp; fClusters[ic]-&gt;IsInChamber()) x1 = fClusters[ic]-&gt;GetX()-fdX;</span>
<span class="lineNum">     752 </span><span class="lineCov">          6 :     else x1 = fClusters[ic+kNtb]-&gt;GetX()-fdX;</span>
<span class="lineNum">     753 </span>            : 
<span class="lineNum">     754 </span><span class="lineCov">       4168 :     dx = .5*(x2 - x1);</span>
<span class="lineNum">     755 </span><span class="lineCov">       4168 :   }</span>
<span class="lineNum">     756 </span><span class="lineCov">       4168 :   dx *= TMath::Sqrt(1. + fYfit[1]*fYfit[1] + fZref[1]*fZref[1]);</span>
<span class="lineNum">     757 </span><span class="lineCov">       4168 :   if(dl) (*dl) = dx;</span>
<span class="lineNum">     758 </span><span class="lineCov">       8336 :   if(dx&gt;1.e-9) return dq/dx;</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :   else return 0.;</span>
<span class="lineNum">     760 </span><span class="lineCov">       4444 : }</span>
<a name="761"><span class="lineNum">     761 </span>            : </a>
<span class="lineNum">     762 </span>            : //____________________________________________________________
<span class="lineNum">     763 </span>            : Float_t AliTRDseedV1::GetMomentum(Float_t *err) const
<span class="lineNum">     764 </span>            : { 
<span class="lineNum">     765 </span>            : // Returns momentum of the track after update with the current tracklet as:
<span class="lineNum">     766 </span>            : // BEGIN_LATEX
<span class="lineNum">     767 </span>            : // p=#frac{1}{1/p_{t}} #sqrt{1+tgl^{2}}
<span class="lineNum">     768 </span>            : // END_LATEX
<span class="lineNum">     769 </span>            : // and optionally the momentum error (if err is not null). 
<span class="lineNum">     770 </span>            : // The estimated variance of the momentum is given by:
<span class="lineNum">     771 </span>            : // BEGIN_LATEX
<span class="lineNum">     772 </span>            : // #sigma_{p}^{2} = (#frac{dp}{dp_{t}})^{2} #sigma_{p_{t}}^{2}+(#frac{dp}{dtgl})^{2} #sigma_{tgl}^{2}+2#frac{dp}{dp_{t}}#frac{dp}{dtgl} cov(tgl,1/p_{t})
<span class="lineNum">     773 </span>            : // END_LATEX
<span class="lineNum">     774 </span>            : // which can be simplified to
<span class="lineNum">     775 </span>            : // BEGIN_LATEX
<span class="lineNum">     776 </span>            : // #sigma_{p}^{2} = p^{2}p_{t}^{4}tgl^{2}#sigma_{tgl}^{2}-2p^{2}p_{t}^{3}tgl cov(tgl,1/p_{t})+p^{2}p_{t}^{2}#sigma_{1/p_{t}}^{2}
<span class="lineNum">     777 </span>            : // END_LATEX
<span class="lineNum">     778 </span>            : //
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span><span class="lineCov">        824 :   Double_t p = fPt*TMath::Sqrt(1.+fZref[1]*fZref[1]);</span>
<span class="lineNum">     781 </span><span class="lineCov">        412 :   if(err){</span>
<span class="lineNum">     782 </span><span class="lineCov">        206 :     Double_t p2 = p*p;</span>
<span class="lineNum">     783 </span><span class="lineCov">        206 :     Double_t tgl2 = fZref[1]*fZref[1];</span>
<span class="lineNum">     784 </span><span class="lineCov">        206 :     Double_t pt2 = fPt*fPt;</span>
<span class="lineNum">     785 </span>            :     Double_t s2 =
<span class="lineNum">     786 </span><span class="lineCov">        206 :       p2*tgl2*pt2*pt2*fRefCov[4]</span>
<span class="lineNum">     787 </span><span class="lineCov">        206 :      -2.*p2*fZref[1]*fPt*pt2*fRefCov[5]</span>
<span class="lineNum">     788 </span><span class="lineCov">        206 :      +p2*pt2*fRefCov[6];</span>
<span class="lineNum">     789 </span><span class="lineCov">        206 :     (*err) = TMath::Sqrt(s2);</span>
<span class="lineNum">     790 </span><span class="lineCov">        206 :   }</span>
<span class="lineNum">     791 </span><span class="lineCov">        412 :   return p;</span>
<span class="lineNum">     792 </span>            : }
<span class="lineNum">     793 </span>            : 
<a name="794"><span class="lineNum">     794 </span>            : </a>
<span class="lineNum">     795 </span>            : //____________________________________________________________________
<span class="lineNum">     796 </span>            : Int_t AliTRDseedV1::GetTBoccupancy() const
<span class="lineNum">     797 </span>            : {
<span class="lineNum">     798 </span>            : // Returns no. of TB occupied by clusters
<span class="lineNum">     799 </span>            : 
<span class="lineNum">     800 </span>            :   Int_t n(0);
<span class="lineNum">     801 </span><span class="lineCov">      57850 :   for(int ic(0); ic&lt;kNtb; ic++){</span>
<span class="lineNum">     802 </span><span class="lineCov">      36552 :     if(!fClusters[ic] &amp;&amp; !fClusters[ic+kNtb]) continue;</span>
<span class="lineNum">     803 </span><span class="lineCov">      19272 :     n++;</span>
<span class="lineNum">     804 </span><span class="lineCov">      19272 :   }</span>
<span class="lineNum">     805 </span><span class="lineCov">        890 :   return n;</span>
<span class="lineNum">     806 </span>            : }
<a name="807"><span class="lineNum">     807 </span>            : </a>
<span class="lineNum">     808 </span>            : //____________________________________________________________________
<span class="lineNum">     809 </span>            : Int_t AliTRDseedV1::GetTBcross() const
<span class="lineNum">     810 </span>            : {
<span class="lineNum">     811 </span>            : // Returns no. of TB occupied by 2 clusters for pad row cross tracklets
<span class="lineNum">     812 </span>            : 
<span class="lineNum">     813 </span><span class="lineCov">         28 :   if(!IsRowCross()) return 0;</span>
<span class="lineNum">     814 </span>            :   Int_t n(0);
<span class="lineNum">     815 </span><span class="lineCov">        896 :   for(int ic(0); ic&lt;kNtb; ic++){</span>
<span class="lineNum">     816 </span><span class="lineCov">        654 :     if(fClusters[ic] &amp;&amp; fClusters[ic+kNtb]) n++;</span>
<span class="lineNum">     817 </span>            :   }
<span class="lineNum">     818 </span>            :   return n;
<span class="lineNum">     819 </span><span class="lineCov">         14 : }</span>
<a name="820"><span class="lineNum">     820 </span>            : </a>
<span class="lineNum">     821 </span>            : //____________________________________________________________________
<span class="lineNum">     822 </span>            : Float_t* AliTRDseedV1::GetProbability(Bool_t force)
<span class="lineNum">     823 </span>            : {       
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :   if(!force) return &amp;fProb[0];</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :   if(!CookPID()) return NULL;</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :   return &amp;fProb[0];</span>
<span class="lineNum">     827 </span><span class="lineNoCov">          0 : }</span>
<a name="828"><span class="lineNum">     828 </span>            : </a>
<span class="lineNum">     829 </span>            : //____________________________________________________________
<span class="lineNum">     830 </span>            : Bool_t AliTRDseedV1::CookPID()
<span class="lineNum">     831 </span>            : {
<span class="lineNum">     832 </span>            : // Fill probability array for tracklet from the DB.
<span class="lineNum">     833 </span>            : //
<span class="lineNum">     834 </span>            : // Parameters
<span class="lineNum">     835 </span>            : //
<span class="lineNum">     836 </span>            : // Output
<span class="lineNum">     837 </span>            : //   returns pointer to the probability array and NULL if missing DB access 
<span class="lineNum">     838 </span>            : //
<span class="lineNum">     839 </span>            : // Retrieve PID probabilities for e+-, mu+-, K+-, pi+- and p+- from the DB according to tracklet information:
<span class="lineNum">     840 </span>            : // - estimated momentum at tracklet reference point 
<span class="lineNum">     841 </span>            : // - dE/dx measurements
<span class="lineNum">     842 </span>            : // - tracklet length
<span class="lineNum">     843 </span>            : // - TRD layer
<span class="lineNum">     844 </span>            : // According to the steering settings specified in the reconstruction one of the following methods are used
<span class="lineNum">     845 </span>            : // - Neural Network [default] - option &quot;nn&quot;  
<span class="lineNum">     846 </span>            : // - 2D Likelihood - option &quot;!nn&quot;  
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :   AliWarning(Form(&quot;Obsolete function. Use AliTRDPIDResponse::GetResponse() instead.&quot;));</span>
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :   AliTRDcalibDB *calibration = AliTRDcalibDB::Instance();</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :   if (!calibration) {</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :     AliError(&quot;No access to calibration data&quot;);</span>
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">     854 </span>            :   }
<span class="lineNum">     855 </span>            : 
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :   if (!fkReconstructor) {</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :     AliError(&quot;Reconstructor not set.&quot;);</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">     859 </span>            :   }
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span>            :   // Retrieve the CDB container class with the parametric detector response
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :   const AliTRDCalPID *pd = calibration-&gt;GetPIDObject(fkReconstructor-&gt;GetPIDMethod());</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :   if (!pd) {</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :     AliError(&quot;No access to AliTRDCalPID object&quot;);</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">     866 </span>            :   }
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span>            :   // calculate tracklet length TO DO
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :   Float_t length = (AliTRDgeometry::AmThick() + AliTRDgeometry::DrThick())/ TMath::Sqrt((1.0 - GetSnp()*GetSnp()) / (1.0 + GetTgl()*GetTgl()));</span>
<span class="lineNum">     870 </span>            :   
<span class="lineNum">     871 </span>            :   //calculate dE/dx
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :   CookdEdx(AliTRDCalPID::kNSlicesNN);</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :   AliDebug(4, Form(&quot;p=%6.4f[GeV/c] dEdx{%7.2f %7.2f %7.2f %7.2f %7.2f %7.2f %7.2f %7.2f} l=%4.2f[cm]&quot;, GetMomentum(), fdEdx[0], fdEdx[1], fdEdx[2], fdEdx[3], fdEdx[4], fdEdx[5], fdEdx[6], fdEdx[7], length));</span>
<span class="lineNum">     874 </span>            : 
<span class="lineNum">     875 </span>            :   // Sets the a priori probabilities
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :   Bool_t kPIDNN(fkReconstructor-&gt;GetPIDMethod()==AliTRDpidUtil::kNN);</span>
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :   for(int ispec=0; ispec&lt;AliPID::kSPECIES; ispec++)</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :     fProb[ispec] = pd-&gt;GetProbability(ispec, GetMomentum(), &amp;fdEdx[0], length, kPIDNN?GetPlane():fkReconstructor-&gt;GetRecoParam()-&gt;GetPIDLQslices());</span>
<span class="lineNum">     879 </span>            :   
<span class="lineNum">     880 </span>            :   return kTRUE;
<span class="lineNum">     881 </span><span class="lineNoCov">          0 : }</span>
<a name="882"><span class="lineNum">     882 </span>            : </a>
<span class="lineNum">     883 </span>            : //____________________________________________________________________
<span class="lineNum">     884 </span>            : Float_t AliTRDseedV1::GetQuality(Bool_t kZcorr) const
<span class="lineNum">     885 </span>            : {
<span class="lineNum">     886 </span>            :   //
<span class="lineNum">     887 </span>            :   // Returns a quality measurement of the current seed
<span class="lineNum">     888 </span>            :   //
<span class="lineNum">     889 </span>            : 
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :   Float_t zcorr = kZcorr ? GetTilt() * (fZfit[0] - fZref[0]) : 0.;</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :   return </span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :       .5 * TMath::Abs(18.0 - GetN())</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :     + 10.* TMath::Abs(fYfit[1] - fYref[1])</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :     + 5. * TMath::Abs(fYfit[0] - fYref[0] + zcorr)</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :     + 2. * TMath::Abs(fZfit[0] - fZref[0]) / GetPadLength();</span>
<span class="lineNum">     896 </span>            : }
<a name="897"><span class="lineNum">     897 </span>            : </a>
<span class="lineNum">     898 </span>            : //____________________________________________________________________
<span class="lineNum">     899 </span>            : void AliTRDseedV1::GetCovAt(Double_t /*x*/, Double_t *cov) const
<span class="lineNum">     900 </span>            : {
<span class="lineNum">     901 </span>            : // Computes covariance in the y-z plane at radial point x (in tracking coordinates) 
<span class="lineNum">     902 </span>            : // and returns the results in the preallocated array cov[3] as :
<span class="lineNum">     903 </span>            : //   cov[0] = Var(y)
<span class="lineNum">     904 </span>            : //   cov[1] = Cov(yz)
<span class="lineNum">     905 </span>            : //   cov[2] = Var(z)
<span class="lineNum">     906 </span>            : //
<span class="lineNum">     907 </span>            : // Details
<span class="lineNum">     908 </span>            : //
<span class="lineNum">     909 </span>            : // For the linear transformation
<span class="lineNum">     910 </span>            : // BEGIN_LATEX
<span class="lineNum">     911 </span>            : // Y = T_{x} X^{T}
<span class="lineNum">     912 </span>            : // END_LATEX
<span class="lineNum">     913 </span>            : //   The error propagation has the general form
<span class="lineNum">     914 </span>            : // BEGIN_LATEX
<span class="lineNum">     915 </span>            : // C_{Y} = T_{x} C_{X} T_{x}^{T} 
<span class="lineNum">     916 </span>            : // END_LATEX
<span class="lineNum">     917 </span>            : //  We apply this formula 2 times. First to calculate the covariance of the tracklet 
<span class="lineNum">     918 </span>            : // at point x we consider: 
<span class="lineNum">     919 </span>            : // BEGIN_LATEX
<span class="lineNum">     920 </span>            : // T_{x} = (1 x); X=(y0 dy/dx); C_{X}=#(){#splitline{Var(y0) Cov(y0, dy/dx)}{Cov(y0, dy/dx) Var(dy/dx)}} 
<span class="lineNum">     921 </span>            : // END_LATEX
<span class="lineNum">     922 </span>            : // and secondly to take into account the tilt angle
<span class="lineNum">     923 </span>            : // BEGIN_LATEX
<span class="lineNum">     924 </span>            : // T_{#alpha} = #(){#splitline{cos(#alpha) __ sin(#alpha)}{-sin(#alpha) __ cos(#alpha)}}; X=(y z); C_{X}=#(){#splitline{Var(y)    0}{0   Var(z)}} 
<span class="lineNum">     925 </span>            : // END_LATEX
<span class="lineNum">     926 </span>            : //
<span class="lineNum">     927 </span>            : // using simple trigonometrics one can write for this last case
<span class="lineNum">     928 </span>            : // BEGIN_LATEX
<span class="lineNum">     929 </span>            : // C_{Y}=#frac{1}{1+tg^{2}#alpha} #(){#splitline{(#sigma_{y}^{2}+tg^{2}#alpha#sigma_{z}^{2}) __ tg#alpha(#sigma_{z}^{2}-#sigma_{y}^{2})}{tg#alpha(#sigma_{z}^{2}-#sigma_{y}^{2}) __ (#sigma_{z}^{2}+tg^{2}#alpha#sigma_{y}^{2})}} 
<span class="lineNum">     930 </span>            : // END_LATEX
<span class="lineNum">     931 </span>            : // which can be aproximated for small alphas (2 deg) with
<span class="lineNum">     932 </span>            : // BEGIN_LATEX
<span class="lineNum">     933 </span>            : // C_{Y}=#(){#splitline{#sigma_{y}^{2} __ (#sigma_{z}^{2}-#sigma_{y}^{2})tg#alpha}{((#sigma_{z}^{2}-#sigma_{y}^{2})tg#alpha __ #sigma_{z}^{2}}} 
<span class="lineNum">     934 </span>            : // END_LATEX
<span class="lineNum">     935 </span>            : //
<span class="lineNum">     936 </span>            : // before applying the tilt rotation we also apply systematic uncertainties to the tracklet 
<span class="lineNum">     937 </span>            : // position which can be tunned from outside via the AliTRDrecoParam::SetSysCovMatrix(). They might 
<span class="lineNum">     938 </span>            : // account for extra misalignment/miscalibration uncertainties. 
<span class="lineNum">     939 </span>            : //
<span class="lineNum">     940 </span>            : // Author :
<span class="lineNum">     941 </span>            : // Alex Bercuci &lt;A.Bercuci@gsi.de&gt; 
<span class="lineNum">     942 </span>            : // Date : Jan 8th 2009
<span class="lineNum">     943 </span>            : //
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span>            :   //Double_t xr     = fX0-x; 
<span class="lineNum">     947 </span><span class="lineCov">       1098 :   Double_t sy2    = fCov[0];// +2.*xr*fCov[1] + xr*xr*fCov[2];</span>
<span class="lineNum">     948 </span><span class="lineCov">        549 :   Double_t sz2    = fS2Z;</span>
<span class="lineNum">     949 </span>            :   //GetPadLength()*GetPadLength()/12.;
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span>            :   // insert systematic uncertainties
<span class="lineNum">     952 </span><span class="lineCov">        549 :   if(fkReconstructor){</span>
<span class="lineNum">     953 </span><span class="lineCov">        549 :     Double_t sys[15]; memset(sys, 0, 15*sizeof(Double_t));</span>
<span class="lineNum">     954 </span><span class="lineCov">        549 :     fkReconstructor-&gt;GetRecoParam()-&gt;GetSysCovMatrix(sys);</span>
<span class="lineNum">     955 </span>            : //    sy2 += sys[0];
<span class="lineNum">     956 </span>            : //    sz2 += sys[1];
<span class="lineNum">     957 </span><span class="lineCov">        549 :   }</span>
<span class="lineNum">     958 </span>            : 
<span class="lineNum">     959 </span>            :   // rotate covariance matrix if no RC
<span class="lineNum">     960 </span><span class="lineCov">        549 :   if(!IsRowCross()){</span>
<span class="lineNum">     961 </span><span class="lineCov">        514 :     Double_t t2 = GetTilt()*GetTilt();</span>
<span class="lineNum">     962 </span><span class="lineCov">        514 :     Double_t correction = 1./(1. + t2);</span>
<span class="lineNum">     963 </span><span class="lineCov">        514 :     cov[0] = (sy2+t2*sz2)*correction;</span>
<span class="lineNum">     964 </span><span class="lineCov">        514 :     cov[1] = GetTilt()*(sz2 - sy2)*correction;</span>
<span class="lineNum">     965 </span><span class="lineCov">        514 :     cov[2] = (t2*sy2+sz2)*correction;</span>
<span class="lineNum">     966 </span><span class="lineCov">        514 :    } else {</span>
<span class="lineNum">     967 </span><span class="lineCov">         35 :      cov[0] = sy2; cov[1] = 0.; cov[2] = sz2;</span>
<span class="lineNum">     968 </span>            :    }
<span class="lineNum">     969 </span>            : 
<span class="lineNum">     970 </span><span class="lineCov">       1647 :   AliDebug(4, Form(&quot;C(%6.1f %+6.3f %6.1f)  RC[%c]&quot;, 1.e4*TMath::Sqrt(cov[0]), cov[1], 1.e4*TMath::Sqrt(cov[2]), IsRowCross()?'y':'n'));</span>
<span class="lineNum">     971 </span><span class="lineCov">        549 : }</span>
<a name="972"><span class="lineNum">     972 </span>            : </a>
<span class="lineNum">     973 </span>            : //____________________________________________________________
<span class="lineNum">     974 </span>            : Int_t AliTRDseedV1::GetCovSqrt(const Double_t * const c, Double_t *d)
<span class="lineNum">     975 </span>            : {
<span class="lineNum">     976 </span>            : // Helper function to calculate the square root of the covariance matrix. 
<span class="lineNum">     977 </span>            : // The input matrix is stored in the vector c and the result in the vector d. 
<span class="lineNum">     978 </span>            : // Both arrays have to be initialized by the user with at least 3 elements. Return negative in case of failure.
<span class="lineNum">     979 </span>            : // 
<span class="lineNum">     980 </span>            : // For calculating the square root of the symmetric matrix c
<span class="lineNum">     981 </span>            : // the following relation is used:
<span class="lineNum">     982 </span>            : // BEGIN_LATEX
<span class="lineNum">     983 </span>            : // C^{1/2} = VD^{1/2}V^{-1}
<span class="lineNum">     984 </span>            : // END_LATEX
<span class="lineNum">     985 </span>            : // with V being the matrix with the n eigenvectors as columns. 
<span class="lineNum">     986 </span>            : // In case C is symmetric the followings are true:
<span class="lineNum">     987 </span>            : //   - matrix D is diagonal with the diagonal given by the eigenvalues of C
<span class="lineNum">     988 </span>            : //   - V = V^{-1}
<span class="lineNum">     989 </span>            : //
<span class="lineNum">     990 </span>            : // Author A.Bercuci &lt;A.Bercuci@gsi.de&gt;
<span class="lineNum">     991 </span>            : // Date   Mar 19 2009
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span>            :   const Double_t kZero(1.e-20);
<span class="lineNum">     994 </span>            :   Double_t l[2], // eigenvalues
<span class="lineNum">     995 </span>            :            v[3]; // eigenvectors
<span class="lineNum">     996 </span>            :   // the secular equation and its solution :
<span class="lineNum">     997 </span>            :   // (c[0]-L)(c[2]-L)-c[1]^2 = 0
<span class="lineNum">     998 </span>            :   // L^2 - L*Tr(c)+DET(c) = 0
<span class="lineNum">     999 </span>            :   // L12 = [Tr(c) +- sqrt(Tr(c)^2-4*DET(c))]/2
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :   Double_t tr = c[0]+c[2],           // trace</span>
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :           det = c[0]*c[2]-c[1]*c[1]; // determinant</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :   if(TMath::Abs(det)&lt;kZero) return 1;</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :   Double_t dd = TMath::Sqrt(tr*tr - 4*det);</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :   l[0] = .5*(tr + dd*(c[0]&gt;c[2]?-1.:1.));</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :   l[1] = .5*(tr + dd*(c[0]&gt;c[2]?1.:-1.));</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :   if(l[0]&lt;kZero || l[1]&lt;kZero) return 2;</span>
<span class="lineNum">    1007 </span>            :   // the sym V matrix
<span class="lineNum">    1008 </span>            :   // | v00   v10|
<span class="lineNum">    1009 </span>            :   // | v10   v11|
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :   Double_t den = (l[0]-c[0])*(l[0]-c[0])+c[1]*c[1];</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :   if(den&lt;kZero){ // almost diagonal</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :     v[0] = TMath::Sign(0., c[1]);</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :     v[1] = TMath::Sign(1., (l[0]-c[0]));</span>
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :     v[2] = TMath::Sign(0., c[1]*(l[0]-c[0])*(l[1]-c[2]));</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :     Double_t tmp = 1./TMath::Sqrt(den);</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :     v[0] = c[1]* tmp;</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :     v[1] = (l[0]-c[0])*tmp;</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :     if(TMath::Abs(l[1]-c[2])&lt;kZero) v[2] = TMath::Sign(v[0]*(l[0]-c[0])/kZero, (l[1]-c[2]));</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :     else v[2] = v[0]*(l[0]-c[0])/(l[1]-c[2]);</span>
<span class="lineNum">    1021 </span>            :   }
<span class="lineNum">    1022 </span>            :   // the VD^{1/2}V is: 
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :   l[0] = TMath::Sqrt(l[0]); l[1] = TMath::Sqrt(l[1]);</span>
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :   d[0] = v[0]*v[0]*l[0]+v[1]*v[1]*l[1];</span>
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :   d[1] = v[0]*v[1]*l[0]+v[1]*v[2]*l[1];</span>
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :   d[2] = v[1]*v[1]*l[0]+v[2]*v[2]*l[1];</span>
<span class="lineNum">    1027 </span>            : 
<span class="lineNum">    1028 </span>            :   return 0;
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 : }</span>
<a name="1030"><span class="lineNum">    1030 </span>            : </a>
<span class="lineNum">    1031 </span>            : //____________________________________________________________
<span class="lineNum">    1032 </span>            : Double_t AliTRDseedV1::GetCovInv(const Double_t * const c, Double_t *d)
<span class="lineNum">    1033 </span>            : {
<span class="lineNum">    1034 </span>            : // Helper function to calculate the inverse of the covariance matrix.
<span class="lineNum">    1035 </span>            : // The input matrix is stored in the vector c and the result in the vector d. 
<span class="lineNum">    1036 </span>            : // Both arrays have to be initialized by the user with at least 3 elements
<span class="lineNum">    1037 </span>            : // The return value is the determinant or 0 in case of singularity.
<span class="lineNum">    1038 </span>            : //
<span class="lineNum">    1039 </span>            : // Author A.Bercuci &lt;A.Bercuci@gsi.de&gt;
<span class="lineNum">    1040 </span>            : // Date   Mar 19 2009
<span class="lineNum">    1041 </span>            : 
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :   Double_t det = c[0]*c[2] - c[1]*c[1];</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :   if(TMath::Abs(det)&lt;1.e-20) return 0.;</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :   Double_t invDet = 1./det;</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :   d[0] = c[2]*invDet;</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :   d[1] =-c[1]*invDet;</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :   d[2] = c[0]*invDet;</span>
<span class="lineNum">    1048 </span>            :   return det;
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 : }</span>
<a name="1050"><span class="lineNum">    1050 </span>            : </a>
<span class="lineNum">    1051 </span>            : //____________________________________________________________________
<span class="lineNum">    1052 </span>            : UShort_t AliTRDseedV1::GetVolumeId() const
<span class="lineNum">    1053 </span>            : {
<span class="lineNum">    1054 </span>            : // Returns geometry volume id by delegation 
<span class="lineNum">    1055 </span>            : 
<span class="lineNum">    1056 </span><span class="lineCov">       1410 :   for(Int_t ic(0);ic&lt;kNclusters; ic++){</span>
<span class="lineNum">    1057 </span><span class="lineCov">        808 :     if(fClusters[ic]) return fClusters[ic]-&gt;GetVolumeId();</span>
<span class="lineNum">    1058 </span>            :   }
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">    1060 </span><span class="lineCov">        206 : }</span>
<span class="lineNum">    1061 </span>            : 
<a name="1062"><span class="lineNum">    1062 </span>            : </a>
<span class="lineNum">    1063 </span>            : //____________________________________________________________________
<span class="lineNum">    1064 </span>            : void AliTRDseedV1::Calibrate()
<span class="lineNum">    1065 </span>            : {
<span class="lineNum">    1066 </span>            : // Retrieve calibration and position parameters from OCDB. 
<span class="lineNum">    1067 </span>            : // The following information are used
<span class="lineNum">    1068 </span>            : //  - detector index
<span class="lineNum">    1069 </span>            : //  - column and row position of first attached cluster. If no clusters are attached 
<span class="lineNum">    1070 </span>            : // to the tracklet a random central chamber position (c=70, r=7) will be used.
<span class="lineNum">    1071 </span>            : //
<span class="lineNum">    1072 </span>            : // The following information is cached in the tracklet
<span class="lineNum">    1073 </span>            : //   t0 (trigger delay)
<span class="lineNum">    1074 </span>            : //   drift velocity
<span class="lineNum">    1075 </span>            : //   PRF width
<span class="lineNum">    1076 </span>            : //   omega*tau = tg(a_L)
<span class="lineNum">    1077 </span>            : //   diffusion coefficients (longitudinal and transversal)
<span class="lineNum">    1078 </span>            : //
<span class="lineNum">    1079 </span>            : // Author :
<span class="lineNum">    1080 </span>            : // Alex Bercuci &lt;A.Bercuci@gsi.de&gt; 
<span class="lineNum">    1081 </span>            : // Date : Jan 8th 2009
<span class="lineNum">    1082 </span>            : //
<span class="lineNum">    1083 </span>            : 
<span class="lineNum">    1084 </span><span class="lineCov">        524 :   AliCDBManager *cdb = AliCDBManager::Instance();</span>
<span class="lineNum">    1085 </span><span class="lineCov">        262 :   if(cdb-&gt;GetRun() &lt; 0){</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :     AliError(&quot;OCDB manager not properly initialized&quot;);</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1088 </span>            :   }
<span class="lineNum">    1089 </span>            : 
<span class="lineNum">    1090 </span><span class="lineCov">        262 :   AliTRDcalibDB *calib = AliTRDcalibDB::Instance();</span>
<span class="lineNum">    1091 </span><span class="lineCov">        262 :   AliTRDCalROC  *vdROC = calib-&gt;GetVdriftROC(fDet),</span>
<span class="lineNum">    1092 </span><span class="lineCov">        262 :                 *t0ROC = calib-&gt;GetT0ROC(fDet);;</span>
<span class="lineNum">    1093 </span><span class="lineCov">        262 :   const AliTRDCalDet *vdDet = calib-&gt;GetVdriftDet();</span>
<span class="lineNum">    1094 </span><span class="lineCov">        262 :   const AliTRDCalDet *t0Det = calib-&gt;GetT0Det();</span>
<span class="lineNum">    1095 </span>            : 
<span class="lineNum">    1096 </span>            :   Int_t col = 70, row = 7;
<span class="lineNum">    1097 </span><span class="lineCov">        262 :   AliTRDcluster **c = &amp;fClusters[0];</span>
<span class="lineNum">    1098 </span><span class="lineCov">        262 :   if(GetN()){ </span>
<span class="lineNum">    1099 </span>            :     Int_t ic = 0;
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :     while (ic&lt;kNclusters &amp;&amp; !(*c)){ic++; c++;} </span>
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :     if(*c){</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :       col = (*c)-&gt;GetPadCol();</span>
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :       row = (*c)-&gt;GetPadRow();</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1106 </span>            : 
<span class="lineNum">    1107 </span><span class="lineCov">        262 :   fT0    = (t0Det-&gt;GetValue(fDet) + t0ROC-&gt;GetValue(col,row)) / AliTRDCommonParam::Instance()-&gt;GetSamplingFrequency();</span>
<span class="lineNum">    1108 </span><span class="lineCov">        262 :   fVD    = vdDet-&gt;GetValue(fDet) * vdROC-&gt;GetValue(col, row);</span>
<span class="lineNum">    1109 </span><span class="lineCov">        262 :   fS2PRF = calib-&gt;GetPRFWidth(fDet, col, row); fS2PRF *= fS2PRF;</span>
<span class="lineNum">    1110 </span><span class="lineCov">        262 :   fExB   = AliTRDCommonParam::Instance()-&gt;GetOmegaTau(fVD);</span>
<span class="lineNum">    1111 </span><span class="lineCov">        524 :   AliTRDCommonParam::Instance()-&gt;GetDiffCoeff(fDiffL,</span>
<span class="lineNum">    1112 </span><span class="lineCov">        262 :   fDiffT, fVD);</span>
<span class="lineNum">    1113 </span><span class="lineCov">        786 :   AliDebug(4, Form(&quot;Calibration params for Det[%3d] Col[%3d] Row[%2d]\n  t0[%f]  vd[%f]  s2PRF[%f]  ExB[%f]  Dl[%f]  Dt[%f]&quot;, fDet, col, row, fT0, fVD, fS2PRF, fExB, fDiffL, fDiffT));</span>
<span class="lineNum">    1114 </span>            : 
<span class="lineNum">    1115 </span>            : 
<span class="lineNum">    1116 </span><span class="lineCov">        262 :   SetBit(kCalib, kTRUE);</span>
<span class="lineNum">    1117 </span><span class="lineCov">        524 : }</span>
<a name="1118"><span class="lineNum">    1118 </span>            : </a>
<span class="lineNum">    1119 </span>            : //____________________________________________________________________
<span class="lineNum">    1120 </span>            : void AliTRDseedV1::SetOwner()
<span class="lineNum">    1121 </span>            : {
<span class="lineNum">    1122 </span>            :   //AliInfo(Form(&quot;own [%s] fOwner[%s]&quot;, own?&quot;YES&quot;:&quot;NO&quot;, fOwner?&quot;YES&quot;:&quot;NO&quot;));
<span class="lineNum">    1123 </span>            :   
<span class="lineNum">    1124 </span><span class="lineCov">        412 :   if(TestBit(kOwner)) return;</span>
<span class="lineNum">    1125 </span><span class="lineCov">      25956 :   for(int ic=0; ic&lt;kNclusters; ic++){</span>
<span class="lineNum">    1126 </span><span class="lineCov">      12772 :     if(!fClusters[ic]) continue;</span>
<span class="lineNum">    1127 </span><span class="lineCov">       8960 :     fClusters[ic] = new AliTRDcluster(*fClusters[ic]);</span>
<span class="lineNum">    1128 </span><span class="lineCov">       4480 :   }</span>
<span class="lineNum">    1129 </span><span class="lineCov">        206 :   SetBit(kOwner);</span>
<span class="lineNum">    1130 </span><span class="lineCov">        412 : }</span>
<a name="1131"><span class="lineNum">    1131 </span>            : </a>
<span class="lineNum">    1132 </span>            : //____________________________________________________________
<span class="lineNum">    1133 </span>            : void AliTRDseedV1::SetPadPlane(AliTRDpadPlane * const p)
<span class="lineNum">    1134 </span>            : {
<span class="lineNum">    1135 </span>            : // Shortcut method to initialize pad geometry.
<span class="lineNum">    1136 </span><span class="lineCov">        524 :   fPad[0] = p-&gt;GetLengthIPad();</span>
<span class="lineNum">    1137 </span><span class="lineCov">        262 :   fPad[1] = p-&gt;GetWidthIPad();</span>
<span class="lineNum">    1138 </span><span class="lineCov">        262 :   fPad[2] = TMath::Tan(TMath::DegToRad()*p-&gt;GetTiltingAngle());</span>
<span class="lineNum">    1139 </span><span class="lineCov">        262 :   fPad[3] = p-&gt;GetRow0() + p-&gt;GetAnodeWireOffset();</span>
<span class="lineNum">    1140 </span><span class="lineCov">        262 : }</span>
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span>            : 
<a name="1143"><span class="lineNum">    1143 </span>            : </a>
<span class="lineNum">    1144 </span>            : //____________________________________________________________________
<span class="lineNum">    1145 </span>            : Bool_t  AliTRDseedV1::AttachClusters(AliTRDtrackingChamber *const chamber, Bool_t tilt, Bool_t chgPos, Int_t ev)
<span class="lineNum">    1146 </span>            : {
<span class="lineNum">    1147 </span>            : //
<span class="lineNum">    1148 </span>            : // Projective algorithm to attach clusters to seeding tracklets. The following steps are performed :
<span class="lineNum">    1149 </span>            : // 1. Collapse x coordinate for the full detector plane
<span class="lineNum">    1150 </span>            : // 2. truncated mean on y (r-phi) direction
<span class="lineNum">    1151 </span>            : // 3. purge clusters
<span class="lineNum">    1152 </span>            : // 4. truncated mean on z direction
<span class="lineNum">    1153 </span>            : // 5. purge clusters
<span class="lineNum">    1154 </span>            : //
<span class="lineNum">    1155 </span>            : // Parameters
<span class="lineNum">    1156 </span>            : //  - chamber : pointer to tracking chamber container used to search the tracklet
<span class="lineNum">    1157 </span>            : //  - tilt    : switch for tilt correction during road building [default true]
<span class="lineNum">    1158 </span>            : //  - chgPos  : mark same[kFALSE] and opposite[kTRUE] sign tracks with respect to Bz field sign [default true]
<span class="lineNum">    1159 </span>            : //  - ev      : event number for debug purposes [default = -1]
<span class="lineNum">    1160 </span>            : // Output
<span class="lineNum">    1161 </span>            : //  - true    : if tracklet found successfully. Failure can happend because of the following:
<span class="lineNum">    1162 </span>            : //      -
<span class="lineNum">    1163 </span>            : // Detailed description
<span class="lineNum">    1164 </span>            : //  
<span class="lineNum">    1165 </span>            : // We start up by defining the track direction in the xy plane and roads. The roads are calculated based
<span class="lineNum">    1166 </span>            : // on tracking information (variance in the r-phi direction) and estimated variance of the standard 
<span class="lineNum">    1167 </span>            : // clusters (see AliTRDcluster::SetSigmaY2()) corrected for tilt (see GetCovAt()). From this the road is
<span class="lineNum">    1168 </span>            : // BEGIN_LATEX
<span class="lineNum">    1169 </span>            : // r_{y} = 3*#sqrt{12*(#sigma^{2}_{Trk}(y) + #frac{#sigma^{2}_{cl}(y) + tg^{2}(#alpha_{L})#sigma^{2}_{cl}(z)}{1+tg^{2}(#alpha_{L})})}
<span class="lineNum">    1170 </span>            : // r_{z} = 1.5*L_{pad}
<span class="lineNum">    1171 </span>            : // END_LATEX
<span class="lineNum">    1172 </span>            : // 
<span class="lineNum">    1173 </span>            : // Author : Alexandru Bercuci &lt;A.Bercuci@gsi.de&gt;
<span class="lineNum">    1174 </span>            : // Debug  : level = 2 for calibration
<span class="lineNum">    1175 </span>            : //          level = 3 for visualization in the track SR
<span class="lineNum">    1176 </span>            : //          level = 4 for full visualization including digit level
<span class="lineNum">    1177 </span>            : 
<span class="lineNum">    1178 </span><span class="lineCov">        262 :   const AliTRDrecoParam* const recoParam = fkReconstructor-&gt;GetRecoParam(); //the dynamic cast in GetRecoParam is slow, so caching the pointer to it</span>
<span class="lineNum">    1179 </span>            : 
<span class="lineNum">    1180 </span>            :   //RS define max cl. per layer to search
<span class="lineNum">    1181 </span>            :   const int kMaxClFindPerLayer = 6;
<span class="lineNum">    1182 </span><span class="lineCov">        262 :   int maxClFind = kMaxClFindPerLayer + AliTRDReconstructor::GetExtraMaxClPerLayer();</span>
<span class="lineNum">    1183 </span>            : 
<span class="lineNum">    1184 </span>            :   //RS define roads with optional extension
<span class="lineNum">    1185 </span>            :   const Double_t kroady = 3.; //recoParam-&gt;GetRoad1y();
<span class="lineNum">    1186 </span><span class="lineCov">        262 :   const Double_t kroadz = GetPadLength() * recoParam-&gt;GetRoadzMultiplicator() + 1.;</span>
<span class="lineNum">    1187 </span><span class="lineCov">        262 :   double extraRoadY = AliTRDReconstructor::GetExtraRoadY();</span>
<span class="lineNum">    1188 </span><span class="lineCov">        262 :   double extraRoadZ = AliTRDReconstructor::GetExtraRoadZ();</span>
<span class="lineNum">    1189 </span>            : 
<span class="lineNum">    1190 </span><span class="lineCov">        262 :   if(!recoParam){</span>
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :     AliError(&quot;Tracklets can not be used without a valid RecoParam.&quot;);</span>
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">    1193 </span>            :   }
<span class="lineNum">    1194 </span><span class="lineCov">        262 :   AliTRDcalibDB *calibration = AliTRDcalibDB::Instance();</span>
<span class="lineNum">    1195 </span><span class="lineCov">        262 :   if (!calibration) {</span>
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :     AliError(&quot;No access to calibration data&quot;);</span>
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">    1198 </span>            :   }
<span class="lineNum">    1199 </span>            :   // Retrieve the CDB container class with the parametric likelihood
<span class="lineNum">    1200 </span><span class="lineCov">        262 :   const AliTRDCalTrkAttach *attach = calibration-&gt;GetAttachObject();</span>
<span class="lineNum">    1201 </span><span class="lineCov">        262 :   if (!attach) {</span>
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :     AliError(&quot;No usable AttachClusters calib object.&quot;);</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">    1204 </span>            :   }
<span class="lineNum">    1205 </span>            : 
<span class="lineNum">    1206 </span>            :   // Initialize reco params for this tracklet
<span class="lineNum">    1207 </span>            :   // 1. first time bin in the drift region
<span class="lineNum">    1208 </span>            :   Int_t t0 = 14;
<span class="lineNum">    1209 </span><span class="lineCov">        262 :   Int_t kClmin = Int_t(recoParam-&gt;GetFindableClusters()*AliTRDtrackerV1::GetNTimeBins());</span>
<span class="lineNum">    1210 </span>            :   Int_t kTBmin = 4;
<span class="lineNum">    1211 </span>            : 
<span class="lineNum">    1212 </span><span class="lineCov">        262 :   Double_t sysCov[5]; recoParam-&gt;GetSysCovMatrix(sysCov); </span>
<span class="lineNum">    1213 </span><span class="lineCov">        262 :   Double_t s2yTrk= fRefCov[0], </span>
<span class="lineNum">    1214 </span>            :            s2yCl = 0., 
<span class="lineNum">    1215 </span><span class="lineCov">        262 :            s2zCl = GetPadLength()*GetPadLength()/12., </span>
<span class="lineNum">    1216 </span><span class="lineCov">        262 :            syRef = TMath::Sqrt(s2yTrk),</span>
<span class="lineNum">    1217 </span><span class="lineCov">        262 :            t2    = GetTilt()*GetTilt();</span>
<span class="lineNum">    1218 </span>            :   // define probing cluster (the perfect cluster) and default calibration
<span class="lineNum">    1219 </span><span class="lineCov">        262 :   Short_t sig[] = {0, 0, 10, 30, 10, 0,0};</span>
<span class="lineNum">    1220 </span><span class="lineCov">        262 :   AliTRDcluster cp(fDet, 6, 75, 0, sig, 0);</span>
<span class="lineNum">    1221 </span><span class="lineCov">        262 :   if(fkReconstructor-&gt;IsHLT()) cp.SetRPhiMethod(AliTRDcluster::kCOG);</span>
<span class="lineNum">    1222 </span><span class="lineCov">        524 :   if(!IsCalibrated()) Calibrate();</span>
<span class="lineNum">    1223 </span>            : 
<span class="lineNum">    1224 </span>            : /*  Int_t kroadyShift(0);
<span class="lineNum">    1225 </span>            :   Float_t bz(AliTrackerBase::GetBz());
<span class="lineNum">    1226 </span>            :   if(TMath::Abs(bz)&gt;2.){
<span class="lineNum">    1227 </span>            :     if(bz&lt;0.) kroadyShift = chgPos ? +1 : -1;
<span class="lineNum">    1228 </span>            :     else kroadyShift = chgPos ? -1 : +1;
<span class="lineNum">    1229 </span>            :   }*/
<span class="lineNum">    1230 </span><span class="lineCov">       1310 :   AliDebug(4, Form(&quot;\n       syTrk[cm]=%4.2f dydxTrk[deg]=%+6.2f Chg[%c] rY[cm]=%4.2f rZ[cm]=%5.2f TC[%c]&quot;, syRef, TMath::ATan(fYref[1])*TMath::RadToDeg(), chgPos?'+':'-', kroady, kroadz, tilt?'y':'n'));</span>
<span class="lineNum">    1231 </span><span class="lineCov">        262 :   Double_t phiTrk(TMath::ATan(fYref[1])),</span>
<span class="lineNum">    1232 </span><span class="lineCov">        262 :            thtTrk(TMath::ATan(fZref[1]));</span>
<span class="lineNum">    1233 </span>            : 
<span class="lineNum">    1234 </span>            :   // working variables
<span class="lineNum">    1235 </span>            :   const Int_t kNrows = 16;
<span class="lineNum">    1236 </span>            :   const Int_t kNcls  = 3*kNclusters; // buffer size
<span class="lineNum">    1237 </span><span class="lineCov">       8646 :   TObjArray clst[kNrows];</span>
<span class="lineNum">    1238 </span><span class="lineCov">        262 :   Bool_t blst[kNrows][kNcls];</span>
<span class="lineNum">    1239 </span><span class="lineCov">        262 :   Double_t cond[4],</span>
<span class="lineNum">    1240 </span>            :            dx, dy, dz,
<span class="lineNum">    1241 </span>            :            yt, zt,
<span class="lineNum">    1242 </span>            :            zc[kNrows],
<span class="lineNum">    1243 </span>            :            xres[kNrows][kNcls], yres[kNrows][kNcls], zres[kNrows][kNcls], s2y[kNrows][kNcls];
<span class="lineNum">    1244 </span><span class="lineCov">        262 :   Int_t idxs[kNrows][kNcls], ncl[kNrows], ncls = 0;</span>
<span class="lineNum">    1245 </span><span class="lineCov">        262 :   memset(ncl, 0, kNrows*sizeof(Int_t));</span>
<span class="lineNum">    1246 </span><span class="lineCov">        262 :   memset(zc, 0, kNrows*sizeof(Double_t));</span>
<span class="lineNum">    1247 </span><span class="lineCov">        262 :   memset(idxs, 0, kNrows*kNcls*sizeof(Int_t));</span>
<span class="lineNum">    1248 </span><span class="lineCov">        262 :   memset(xres, 0, kNrows*kNcls*sizeof(Double_t));</span>
<span class="lineNum">    1249 </span><span class="lineCov">        262 :   memset(yres, 0, kNrows*kNcls*sizeof(Double_t));</span>
<span class="lineNum">    1250 </span><span class="lineCov">        262 :   memset(zres, 0, kNrows*kNcls*sizeof(Double_t));</span>
<span class="lineNum">    1251 </span><span class="lineCov">        262 :   memset(s2y, 0, kNrows*kNcls*sizeof(Double_t));</span>
<span class="lineNum">    1252 </span><span class="lineCov">        262 :   memset(blst, 0, kNrows*kNcls*sizeof(Bool_t));   //this is 8 times faster to memset than &quot;memset(clst, 0, kNrows*kNcls*sizeof(AliTRDcluster*))&quot;</span>
<span class="lineNum">    1253 </span>            : 
<span class="lineNum">    1254 </span><span class="lineCov">        262 :   Double_t roady(0.), s2Mean(0.); Int_t ns2Mean(0);</span>
<span class="lineNum">    1255 </span>            : 
<span class="lineNum">    1256 </span>            :   // Do cluster projection and pick up cluster candidates
<span class="lineNum">    1257 </span>            :   AliTRDcluster *c(NULL);
<span class="lineNum">    1258 </span>            :   AliTRDchamberTimeBin *layer(NULL);
<span class="lineNum">    1259 </span>            :   Bool_t kBUFFER = kFALSE;
<span class="lineNum">    1260 </span><span class="lineCov">      17030 :   for (Int_t it = 0; it &lt; kNtb; it++) {</span>
<span class="lineNum">    1261 </span><span class="lineCov">       8122 :     if(!(layer = chamber-&gt;GetTB(it))) continue;</span>
<span class="lineNum">    1262 </span><span class="lineCov">       8122 :     if(!Int_t(*layer)) continue;</span>
<span class="lineNum">    1263 </span>            :     // get track projection at layers position
<span class="lineNum">    1264 </span><span class="lineCov">       5895 :     dx   = fX0 - layer-&gt;GetX();</span>
<span class="lineNum">    1265 </span><span class="lineCov">       5895 :     yt = fYref[0] - fYref[1] * dx;</span>
<span class="lineNum">    1266 </span><span class="lineCov">       5895 :     zt = fZref[0] - fZref[1] * dx;</span>
<span class="lineNum">    1267 </span>            :     // get standard cluster error corrected for tilt if selected
<span class="lineNum">    1268 </span><span class="lineCov">       5895 :     cp.SetLocalTimeBin(it);</span>
<span class="lineNum">    1269 </span><span class="lineCov">       5895 :     cp.SetSigmaY2(0.02, fDiffT, fExB, dx, -1./*zt*/, fYref[1]);</span>
<span class="lineNum">    1270 </span><span class="lineCov">       5895 :     s2yCl = cp.GetSigmaY2() + sysCov[0]; if(!tilt) s2yCl = (s2yCl + t2*s2zCl)/(1.+t2);</span>
<span class="lineNum">    1271 </span><span class="lineCov">       9117 :     if(TMath::Abs(it-12)&lt;7){ s2Mean += cp.GetSigmaY2(); ns2Mean++;}</span>
<span class="lineNum">    1272 </span>            :     // get estimated road in r-phi direction
<span class="lineNum">    1273 </span><span class="lineCov">       5895 :     if (extraRoadY&gt;0) roady = kroady + extraRoadY;</span>
<span class="lineNum">    1274 </span><span class="lineCov">       5895 :     else roady = TMath::Min(3.*TMath::Sqrt(12.*(s2yTrk + s2yCl)), kroady);</span>
<span class="lineNum">    1275 </span><span class="lineCov">      29475 :     AliDebug(5, Form(&quot;\n&quot;</span>
<span class="lineNum">    1276 </span>            :       &quot;  %2d xd[cm]=%6.3f yt[cm]=%7.2f zt[cm]=%8.2f\n&quot;
<span class="lineNum">    1277 </span>            :       &quot;      syTrk[um]=%6.2f syCl[um]=%6.2f syClTlt[um]=%6.2f\n&quot;
<span class="lineNum">    1278 </span>            :       &quot;      Ry[mm]=%f&quot;
<span class="lineNum">    1279 </span>            :       , it, dx, yt, zt
<span class="lineNum">    1280 </span>            :       , 1.e4*TMath::Sqrt(s2yTrk), 1.e4*TMath::Sqrt(cp.GetSigmaY2()+sysCov[0]), 1.e4*TMath::Sqrt(s2yCl)
<span class="lineNum">    1281 </span>            :       , 1.e1*roady));
<span class="lineNum">    1282 </span>            : 
<span class="lineNum">    1283 </span>            :     // get clusters from layer
<span class="lineNum">    1284 </span><span class="lineCov">       5895 :     cond[0] = yt/*+0.5*kroadyShift*kroady*/; cond[2] = roady;</span>
<span class="lineNum">    1285 </span><span class="lineCov">       5895 :     cond[1] = zt; cond[3] = kroadz + extraRoadZ;</span>
<span class="lineNum">    1286 </span><span class="lineCov">       5895 :     Int_t n=0, idx[maxClFind]; layer-&gt;GetClusters(cond, idx, n, maxClFind);</span>
<span class="lineNum">    1287 </span><span class="lineCov">      23172 :     for(Int_t ic = n; ic--;){</span>
<span class="lineNum">    1288 </span><span class="lineCov">       5487 :       c  = (*layer)[idx[ic]];</span>
<span class="lineNum">    1289 </span><span class="lineCov">       5487 :       dx = fX0 - c-&gt;GetX();</span>
<span class="lineNum">    1290 </span><span class="lineCov">       5487 :       yt = fYref[0] - fYref[1] * dx;</span>
<span class="lineNum">    1291 </span><span class="lineCov">       5487 :       zt = fZref[0] - fZref[1] * dx;</span>
<span class="lineNum">    1292 </span><span class="lineCov">       5487 :       dz = zt - c-&gt;GetZ();</span>
<span class="lineNum">    1293 </span><span class="lineCov">      16461 :       dy = yt - (c-&gt;GetY() + (tilt ? (GetTilt() * dz) : 0.));</span>
<span class="lineNum">    1294 </span><span class="lineCov">       5487 :       Int_t r = c-&gt;GetPadRow();</span>
<span class="lineNum">    1295 </span><span class="lineCov">       5487 :       clst[r].AddAtAndExpand(c, ncl[r]);</span>
<span class="lineNum">    1296 </span><span class="lineCov">       5487 :       blst[r][ncl[r]] = kTRUE;</span>
<span class="lineNum">    1297 </span><span class="lineCov">       5487 :       idxs[r][ncl[r]] = idx[ic];</span>
<span class="lineNum">    1298 </span><span class="lineCov">       5487 :       zres[r][ncl[r]] = dz/GetPadLength();</span>
<span class="lineNum">    1299 </span><span class="lineCov">       5487 :       yres[r][ncl[r]] = dy;</span>
<span class="lineNum">    1300 </span><span class="lineCov">       5487 :       xres[r][ncl[r]] = dx;</span>
<span class="lineNum">    1301 </span><span class="lineCov">       5487 :       zc[r]           = c-&gt;GetZ();</span>
<span class="lineNum">    1302 </span>            :       // TODO temporary solution to avoid divercences in error parametrization
<span class="lineNum">    1303 </span><span class="lineCov">       5487 :       s2y[r][ncl[r]]  = TMath::Min(c-&gt;GetSigmaY2()+sysCov[0], 0.025); </span>
<span class="lineNum">    1304 </span><span class="lineCov">      27435 :       AliDebug(5, Form(&quot;   -&gt; dy[cm]=%+7.4f yc[cm]=%7.2f row[%d] idx[%2d]&quot;, dy, c-&gt;GetY(), r, ncl[r]));</span>
<span class="lineNum">    1305 </span><span class="lineCov">       5487 :       ncl[r]++; ncls++;</span>
<span class="lineNum">    1306 </span>            : 
<span class="lineNum">    1307 </span><span class="lineCov">       5487 :       if(ncl[r] &gt;= kNcls) {</span>
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :         AliWarning(Form(&quot;Cluster candidates row[%d] reached buffer limit[%d]. Some may be lost.&quot;, r, kNcls));</span>
<span class="lineNum">    1309 </span>            :         kBUFFER = kTRUE;
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1311 </span>            :       }
<span class="lineNum">    1312 </span><span class="lineCov">       5487 :     }</span>
<span class="lineNum">    1313 </span><span class="lineCov">       5895 :     if(kBUFFER) break;</span>
<span class="lineNum">    1314 </span><span class="lineCov">      11790 :   }</span>
<span class="lineNum">    1315 </span><span class="lineCov">        262 :   if(ncls&lt;kClmin){ </span>
<span class="lineNum">    1316 </span><span class="lineCov">        160 :     AliDebug(1, Form(&quot;CLUSTERS FOUND %d LESS THAN THRESHOLD %d.&quot;, ncls, kClmin));</span>
<span class="lineNum">    1317 </span><span class="lineCov">         32 :     SetErrorMsg(kAttachClFound);</span>
<span class="lineNum">    1318 </span><span class="lineCov">       1088 :     for(Int_t ir(kNrows);ir--;) clst[ir].Clear();</span>
<span class="lineNum">    1319 </span><span class="lineCov">         32 :     return kFALSE;</span>
<span class="lineNum">    1320 </span>            :   }
<span class="lineNum">    1321 </span><span class="lineCov">        230 :   if(ns2Mean&lt;kTBmin){</span>
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :     AliDebug(1, Form(&quot;CLUSTERS IN TimeBins %d LESS THAN THRESHOLD %d.&quot;, ns2Mean, kTBmin));</span>
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :     SetErrorMsg(kAttachClFound);</span>
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :     for(Int_t ir(kNrows);ir--;) clst[ir].Clear();</span>
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">    1326 </span>            :   }
<span class="lineNum">    1327 </span><span class="lineCov">        230 :   s2Mean /= ns2Mean; //sMean = TMath::Sqrt(s2Mean);</span>
<span class="lineNum">    1328 </span>            :   //Double_t sRef(TMath::Sqrt(s2Mean+s2yTrk)); // reference error parameterization
<span class="lineNum">    1329 </span>            : 
<span class="lineNum">    1330 </span>            :   // organize row candidates
<span class="lineNum">    1331 </span><span class="lineCov">        230 :   Int_t idxRow[kNrows], nrc(0); Double_t zresRow[kNrows];</span>
<span class="lineNum">    1332 </span><span class="lineCov">       7820 :   for(Int_t ir(0); ir&lt;kNrows; ir++){</span>
<span class="lineNum">    1333 </span><span class="lineCov">       3680 :     idxRow[ir]=-1; zresRow[ir] = 999.;</span>
<span class="lineNum">    1334 </span><span class="lineCov">       3680 :     if(!ncl[ir]) continue;</span>
<span class="lineNum">    1335 </span>            :     // get mean z resolution
<span class="lineNum">    1336 </span><span class="lineCov">      11745 :     dz = 0.; for(Int_t ic = ncl[ir]; ic--;) dz += zres[ir][ic]; dz/=ncl[ir];</span>
<span class="lineNum">    1337 </span>            :     // insert row
<span class="lineNum">    1338 </span><span class="lineCov">        265 :     idxRow[nrc] = ir; zresRow[nrc] = TMath::Abs(dz); nrc++;</span>
<span class="lineNum">    1339 </span><span class="lineCov">        265 :   }</span>
<span class="lineNum">    1340 </span><span class="lineCov">       1150 :   AliDebug(4, Form(&quot;Found %d clusters in %d rows. Sorting ...&quot;, ncls, nrc));</span>
<span class="lineNum">    1341 </span>            : 
<span class="lineNum">    1342 </span>            :   // sort row candidates
<span class="lineNum">    1343 </span><span class="lineCov">        230 :   if(nrc&gt;=2){</span>
<span class="lineNum">    1344 </span><span class="lineCov">         33 :     if(nrc==2){</span>
<span class="lineNum">    1345 </span><span class="lineCov">         31 :       if(zresRow[0]&gt;zresRow[1]){ // swap</span>
<span class="lineNum">    1346 </span><span class="lineCov">         14 :         Int_t itmp=idxRow[1]; idxRow[1] = idxRow[0]; idxRow[0] = itmp;</span>
<span class="lineNum">    1347 </span><span class="lineCov">         14 :         Double_t dtmp=zresRow[1]; zresRow[1] = zresRow[0]; zresRow[0] = dtmp;</span>
<span class="lineNum">    1348 </span><span class="lineCov">         14 :       }</span>
<span class="lineNum">    1349 </span><span class="lineCov">         31 :       if(TMath::Abs(idxRow[1] - idxRow[0]) != 1){</span>
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :         SetErrorMsg(kAttachRowGap);</span>
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :         AliDebug(2, Form(&quot;Rows attached not continuous. Select first candidate.\n&quot;</span>
<span class="lineNum">    1352 </span>            :                     &quot;       row[%2d] Ncl[%2d] &lt;dz&gt;[cm]=%+8.2f row[%2d] Ncl[%2d] &lt;dz&gt;[cm]=%+8.2f&quot;,
<span class="lineNum">    1353 </span>            :                     idxRow[0], ncl[idxRow[0]], zresRow[0], idxRow[1], idxRow[1]&lt;0?0:ncl[idxRow[1]], zresRow[1]));
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 :         nrc=1; idxRow[1] = -1; zresRow[1] = 999.;</span>
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1356 </span>            :     } else {
<span class="lineNum">    1357 </span><span class="lineCov">          2 :       Int_t idx0[kNrows];</span>
<span class="lineNum">    1358 </span><span class="lineCov">          2 :       TMath::Sort(nrc, zresRow, idx0, kFALSE);</span>
<span class="lineNum">    1359 </span>            :       nrc = 3; // select only maximum first 3 candidates
<span class="lineNum">    1360 </span><span class="lineCov">          2 :       Int_t iatmp[] = {-1, -1, -1}; Double_t datmp[] = {999., 999., 999.};</span>
<span class="lineNum">    1361 </span><span class="lineCov">         16 :       for(Int_t irc(0); irc&lt;nrc; irc++){</span>
<span class="lineNum">    1362 </span><span class="lineCov">          6 :         iatmp[irc] = idxRow[idx0[irc]];</span>
<span class="lineNum">    1363 </span><span class="lineCov">          6 :         datmp[irc] = zresRow[idx0[irc]];</span>
<span class="lineNum">    1364 </span>            :       }
<span class="lineNum">    1365 </span><span class="lineCov">          2 :       idxRow[0] = iatmp[0]; zresRow[0] = datmp[0];</span>
<span class="lineNum">    1366 </span><span class="lineCov">          2 :       idxRow[1] = iatmp[1]; zresRow[1] = datmp[1];</span>
<span class="lineNum">    1367 </span><span class="lineCov">          2 :       idxRow[2] = iatmp[2]; zresRow[2] = datmp[2]; // temporary</span>
<span class="lineNum">    1368 </span><span class="lineCov">          2 :       if(TMath::Abs(idxRow[1] - idxRow[0]) != 1){</span>
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :         SetErrorMsg(kAttachRowGap);</span>
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :         AliDebug(2, Form(&quot;Rows attached not continuous. Turn on selection.\n&quot;</span>
<span class="lineNum">    1371 </span>            :                     &quot;row[%2d] Ncl[%2d] &lt;dz&gt;[cm]=%+8.2f\n&quot;
<span class="lineNum">    1372 </span>            :                     &quot;row[%2d] Ncl[%2d] &lt;dz&gt;[cm]=%+8.2f\n&quot;
<span class="lineNum">    1373 </span>            :                     &quot;row[%2d] Ncl[%2d] &lt;dz&gt;[cm]=%+8.2f&quot;,
<span class="lineNum">    1374 </span>            :                     idxRow[0], ncl[idxRow[0]], zresRow[0],
<span class="lineNum">    1375 </span>            :                     idxRow[1], ncl[idxRow[1]], zresRow[1],
<span class="lineNum">    1376 </span>            :                     idxRow[2], ncl[idxRow[2]], zresRow[2]));
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :         if(TMath::Abs(idxRow[0] - idxRow[2]) == 1){ // select second candidate</span>
<span class="lineNum">    1378 </span><span class="lineNoCov">          0 :           AliDebug(2, &quot;Solved ! Remove second candidate.&quot;);</span>
<span class="lineNum">    1379 </span>            :           nrc = 2;
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :           idxRow[1] = idxRow[2]; zresRow[1] = zresRow[2]; // swap</span>
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :           idxRow[2] = -1; zresRow[2] = 999.;              // remove</span>
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 :         } else if(TMath::Abs(idxRow[1] - idxRow[2]) == 1){</span>
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 :           if(ncl[idxRow[1]]+ncl[idxRow[2]] &gt; ncl[idxRow[0]]){</span>
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 :             AliDebug(2, &quot;Solved ! Remove first candidate.&quot;);</span>
<span class="lineNum">    1385 </span>            :             nrc = 2;
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 :             idxRow[0] = idxRow[1]; zresRow[0] = zresRow[1]; // swap</span>
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :             idxRow[1] = idxRow[2]; zresRow[1] = zresRow[2]; // swap</span>
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 :           } else {</span>
<span class="lineNum">    1389 </span><span class="lineNoCov">          0 :             AliDebug(2, &quot;Solved ! Remove second and third candidate.&quot;);</span>
<span class="lineNum">    1390 </span>            :             nrc = 1;
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :             idxRow[1] = -1; zresRow[1] = 999.; // remove</span>
<span class="lineNum">    1392 </span><span class="lineNoCov">          0 :             idxRow[2] = -1; zresRow[2] = 999.; // remove</span>
<span class="lineNum">    1393 </span>            :           }
<span class="lineNum">    1394 </span>            :         } else {
<span class="lineNum">    1395 </span><span class="lineNoCov">          0 :           AliDebug(2, &quot;Unsolved !!! Remove second and third candidate.&quot;);</span>
<span class="lineNum">    1396 </span>            :           nrc = 1;
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :           idxRow[1] = -1; zresRow[1] = 999.; // remove</span>
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :           idxRow[2] = -1; zresRow[2] = 999.; // remove</span>
<span class="lineNum">    1399 </span>            :         }
<span class="lineNum">    1400 </span>            :       } else { // remove temporary candidate
<span class="lineNum">    1401 </span>            :         nrc = 2;
<span class="lineNum">    1402 </span><span class="lineCov">          2 :         idxRow[2] = -1; zresRow[2] = 999.;</span>
<span class="lineNum">    1403 </span>            :       }
<span class="lineNum">    1404 </span><span class="lineCov">          2 :     }</span>
<span class="lineNum">    1405 </span>            :   }
<span class="lineNum">    1406 </span><span class="lineCov">       1150 :   AliDebug(4, Form(&quot;Sorted row candidates:\n&quot;</span>
<span class="lineNum">    1407 </span>            :       &quot;  row[%2d] Ncl[%2d] &lt;dz&gt;[cm]=%+8.2f row[%2d] Ncl[%2d] &lt;dz&gt;[cm]=%+8.2f&quot;
<span class="lineNum">    1408 </span>            :       , idxRow[0], ncl[idxRow[0]], zresRow[0], idxRow[1], idxRow[1]&lt;0?0:ncl[idxRow[1]], zresRow[1]));
<span class="lineNum">    1409 </span>            : 
<span class="lineNum">    1410 </span>            :   // initialize debug streamer
<span class="lineNum">    1411 </span>            :   TTreeSRedirector *pstreamer(NULL);
<span class="lineNum">    1412 </span><span class="lineCov">        460 :   if((recoParam-&gt;GetStreamLevel(AliTRDrecoParam::kTracker) &gt; 3 &amp;&amp; fkReconstructor-&gt;IsDebugStreaming())||</span>
<span class="lineNum">    1413 </span><span class="lineCov">        230 :      AliTRDReconstructor::GetStreamLevel()&gt;30) pstreamer = fkReconstructor-&gt;GetDebugStream(AliTRDrecoParam::kTracker);</span>
<span class="lineNum">    1414 </span><span class="lineCov">        230 :   if(pstreamer){</span>
<span class="lineNum">    1415 </span>            :     // save config. for calibration
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :     TVectorD vdy[2], vdx[2], vs2[2];</span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :     for(Int_t jr(0); jr&lt;nrc; jr++){</span>
<span class="lineNum">    1418 </span><span class="lineNoCov">          0 :       Int_t ir(idxRow[jr]);</span>
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :       vdx[jr].ResizeTo(ncl[ir]); vdy[jr].ResizeTo(ncl[ir]); vs2[jr].ResizeTo(ncl[ir]);</span>
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :       for(Int_t ic(ncl[ir]); ic--;){</span>
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 :         vdx[jr](ic) = xres[ir][ic];</span>
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :         vdy[jr](ic) = yres[ir][ic];</span>
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :         vs2[jr](ic) = s2y[ir][ic];</span>
<span class="lineNum">    1424 </span>            :       }
<span class="lineNum">    1425 </span>            :     }
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 :     (*pstreamer) &lt;&lt; &quot;AttachClusters4&quot;</span>
<span class="lineNum">    1427 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;r0=&quot;     &lt;&lt; idxRow[0]</span>
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;dz0=&quot;    &lt;&lt; zresRow[0]</span>
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;dx0=&quot;    &lt;&lt; &amp;vdx[0]</span>
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;dy0=&quot;    &lt;&lt; &amp;vdy[0]</span>
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;s20=&quot;    &lt;&lt; &amp;vs2[0]</span>
<span class="lineNum">    1432 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;r1=&quot;     &lt;&lt; idxRow[1]</span>
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;dz1=&quot;    &lt;&lt; zresRow[1]</span>
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;dx1=&quot;    &lt;&lt; &amp;vdx[1]</span>
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;dy1=&quot;    &lt;&lt; &amp;vdy[1]</span>
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;s21=&quot;    &lt;&lt; &amp;vs2[1]</span>
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :     vdx[0].Clear(); vdy[0].Clear(); vs2[0].Clear();</span>
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :     vdx[1].Clear(); vdy[1].Clear(); vs2[1].Clear();</span>
<span class="lineNum">    1440 </span><span class="lineNoCov">          0 :     if(recoParam-&gt;GetStreamLevel(AliTRDrecoParam::kTracker) &gt; 4 ||AliTRDReconstructor::GetStreamLevel()&gt;4){    </span>
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :       Int_t idx(idxRow[1]);</span>
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :       if(idx&lt;0){ </span>
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :         for(Int_t ir(0); ir&lt;kNrows; ir++){ </span>
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :           if(clst[ir].GetEntries()&gt;0) continue;</span>
<span class="lineNum">    1445 </span>            :           idx = ir;
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1447 </span>            :         }
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :       (*pstreamer) &lt;&lt; &quot;AttachClusters5&quot;</span>
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;c0.=&quot;    &lt;&lt; &amp;clst[idxRow[0]]</span>
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;c1.=&quot;    &lt;&lt; &amp;clst[idx]</span>
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1455 </span>            : 
<span class="lineNum">    1456 </span>            : //=======================================================================================
<span class="lineNum">    1457 </span>            :   // Analyse cluster topology
<span class="lineNum">    1458 </span><span class="lineCov">        230 :   Double_t f[kNcls],     // likelihood factors for segments</span>
<span class="lineNum">    1459 </span>            :            r[2][kNcls],  // d(dydx) of tracklet candidate with respect to track
<span class="lineNum">    1460 </span>            :            xm[2][kNcls], // mean &lt;x&gt;
<span class="lineNum">    1461 </span>            :            ym[2][kNcls], // mean &lt;y&gt;
<span class="lineNum">    1462 </span>            :            sm[2][kNcls], // mean &lt;s_y&gt;
<span class="lineNum">    1463 </span>            :            s[2][kNcls],  // sigma_y
<span class="lineNum">    1464 </span>            :            p[2][kNcls],  // prob of Gauss
<span class="lineNum">    1465 </span>            :            q[2][kNcls];  // charge/segment
<span class="lineNum">    1466 </span><span class="lineCov">        230 :   memset(f, 0, kNcls*sizeof(Double_t));</span>
<span class="lineNum">    1467 </span><span class="lineCov">        230 :   Int_t index[2][kNcls], n[2][kNcls];</span>
<span class="lineNum">    1468 </span><span class="lineCov">        230 :   memset(n, 0, 2*kNcls*sizeof(Int_t));</span>
<span class="lineNum">    1469 </span><span class="lineCov">        230 :   Int_t mts(0), nts[2] = {0, 0};   // no of tracklet segments in row</span>
<span class="lineNum">    1470 </span><span class="lineCov">        460 :   AliTRDpadPlane *pp(AliTRDtransform::Geometry().GetPadPlane(fDet));</span>
<span class="lineNum">    1471 </span><span class="lineCov">        230 :   AliTRDtrackletOflHelper helper;</span>
<span class="lineNum">    1472 </span><span class="lineCov">        230 :   Int_t lyDet(AliTRDgeometry::GetLayer(fDet));</span>
<span class="lineNum">    1473 </span><span class="lineCov">        986 :   for(Int_t jr(0), n0(0); jr&lt;nrc; jr++){</span>
<span class="lineNum">    1474 </span><span class="lineCov">        263 :     Int_t ir(idxRow[jr]);</span>
<span class="lineNum">    1475 </span>            :     // cluster segmentation
<span class="lineNum">    1476 </span>            :     Bool_t kInit(kFALSE);
<span class="lineNum">    1477 </span><span class="lineCov">        263 :     if(jr==0){ </span>
<span class="lineNum">    1478 </span><span class="lineCov">        230 :       n0 = helper.Init(pp, &amp;clst[ir]); kInit = kTRUE;</span>
<span class="lineNum">    1479 </span><span class="lineCov">        690 :       if(!n0 || (helper.ClassifyTopology() == AliTRDtrackletOflHelper::kNormal)){</span>
<span class="lineNum">    1480 </span><span class="lineCov">        216 :         nts[jr] = 1; memset(index[jr], 0, ncl[ir]*sizeof(Int_t));</span>
<span class="lineNum">    1481 </span><span class="lineCov">        216 :         n[jr][0] = ncl[ir];</span>
<span class="lineNum">    1482 </span><span class="lineCov">        216 :       }</span>
<span class="lineNum">    1483 </span>            :     }
<span class="lineNum">    1484 </span><span class="lineCov">        263 :     if(!n[jr][0]){</span>
<span class="lineNum">    1485 </span><span class="lineCov">         94 :       nts[jr] = AliTRDtrackletOflHelper::Segmentation(ncl[ir], xres[ir], yres[ir], index[jr]);</span>
<span class="lineNum">    1486 </span><span class="lineCov">       1978 :       for(Int_t ic(ncl[ir]);ic--;) n[jr][index[jr][ic]]++;</span>
<span class="lineNum">    1487 </span><span class="lineCov">         47 :     }</span>
<span class="lineNum">    1488 </span><span class="lineCov">        263 :     mts += nts[jr];</span>
<span class="lineNum">    1489 </span>            :     
<span class="lineNum">    1490 </span>            :     // tracklet segment processing
<span class="lineNum">    1491 </span><span class="lineCov">       1148 :     for(Int_t its(0); its&lt;nts[jr]; its++){</span>
<span class="lineNum">    1492 </span><span class="lineCov">        311 :       if(n[jr][its]&lt;=2) {   // don't touch small segments</span>
<span class="lineNum">    1493 </span><span class="lineCov">         20 :         xm[jr][its] = 0.;ym[jr][its] = 0.;sm[jr][its] = 0.;</span>
<span class="lineNum">    1494 </span><span class="lineCov">        816 :         for(Int_t ic(ncl[ir]); ic--;){</span>
<span class="lineNum">    1495 </span><span class="lineCov">        752 :           if(its != index[jr][ic]) continue;</span>
<span class="lineNum">    1496 </span><span class="lineCov">         24 :           ym[jr][its] += yres[ir][ic];</span>
<span class="lineNum">    1497 </span><span class="lineCov">         24 :           xm[jr][its] += xres[ir][ic];</span>
<span class="lineNum">    1498 </span><span class="lineCov">         24 :           sm[jr][its] += TMath::Sqrt(s2y[ir][ic]);</span>
<span class="lineNum">    1499 </span>            :         }
<span class="lineNum">    1500 </span><span class="lineCov">         24 :         if(n[jr][its]==2){ xm[jr][its] *= 0.5; ym[jr][its] *= 0.5; sm[jr][its] *= 0.5;}</span>
<span class="lineNum">    1501 </span><span class="lineCov">         20 :         xm[jr][its]= fX0 - xm[jr][its];</span>
<span class="lineNum">    1502 </span><span class="lineCov">         20 :         r[jr][its] = 0.;</span>
<span class="lineNum">    1503 </span><span class="lineCov">         20 :         s[jr][its] = 1.e-5;</span>
<span class="lineNum">    1504 </span><span class="lineCov">         20 :         p[jr][its] = 1.;</span>
<span class="lineNum">    1505 </span><span class="lineCov">         20 :         q[jr][its] = -1.;</span>
<span class="lineNum">    1506 </span><span class="lineCov">         20 :         continue;</span>
<span class="lineNum">    1507 </span>            :       }
<span class="lineNum">    1508 </span>            :       
<span class="lineNum">    1509 </span>            :       // for longer tracklet segments
<span class="lineNum">    1510 </span><span class="lineCov">        369 :       if(!kInit) n0 = helper.Init(pp, &amp;clst[ir], index[jr], its);</span>
<span class="lineNum">    1511 </span><span class="lineCov">        291 :       Int_t n1 = helper.GetRMS(r[jr][its], ym[jr][its], s[jr][its], fX0/*xm[jr][its]*/);</span>
<span class="lineNum">    1512 </span><span class="lineCov">        291 :       p[jr][its]  = Double_t(n1)/n0;</span>
<span class="lineNum">    1513 </span><span class="lineCov">        582 :       sm[jr][its] = helper.GetSyMean();</span>
<span class="lineNum">    1514 </span><span class="lineCov">        582 :       q[jr][its]  = helper.GetQ()/TMath::Sqrt(1. + fYref[1]*fYref[1] + fZref[1]*fZref[1]);</span>
<span class="lineNum">    1515 </span><span class="lineCov">        291 :       xm[jr][its] = fX0;</span>
<span class="lineNum">    1516 </span><span class="lineCov">        291 :       Double_t dxm= fX0 - xm[jr][its];</span>
<span class="lineNum">    1517 </span><span class="lineCov">        291 :       yt = fYref[0] - fYref[1]*dxm;</span>
<span class="lineNum">    1518 </span><span class="lineCov">        291 :       zt = fZref[0] - fZref[1]*dxm;</span>
<span class="lineNum">    1519 </span>            :       // correct tracklet fit for tilt
<span class="lineNum">    1520 </span><span class="lineCov">        291 :       ym[jr][its]+= GetTilt()*(zt - zc[ir]);</span>
<span class="lineNum">    1521 </span><span class="lineCov">        291 :       r[jr][its] += GetTilt() * fZref[1];</span>
<span class="lineNum">    1522 </span>            :       // correct tracklet fit for track position/inclination
<span class="lineNum">    1523 </span><span class="lineCov">        291 :       ym[jr][its] = yt - ym[jr][its];</span>
<span class="lineNum">    1524 </span><span class="lineCov">        291 :       r[jr][its]  = (r[jr][its] - fYref[1])/(1+r[jr][its]*fYref[1]);</span>
<span class="lineNum">    1525 </span>            :       // report inclination in radians
<span class="lineNum">    1526 </span><span class="lineCov">        291 :       r[jr][its] = TMath::ATan(r[jr][its]);</span>
<span class="lineNum">    1527 </span><span class="lineCov">        330 :       if(jr) continue; // calculate only for first row likelihoods</span>
<span class="lineNum">    1528 </span>            :         
<span class="lineNum">    1529 </span><span class="lineCov">        504 :       f[its] = attach-&gt;CookLikelihood(chgPos, lyDet, fPt, phiTrk, n[jr][its], ym[jr][its]/*sRef*/, r[jr][its]*TMath::RadToDeg(), s[jr][its]/sm[jr][its]);</span>
<span class="lineNum">    1530 </span><span class="lineCov">        252 :     }</span>
<span class="lineNum">    1531 </span>            :   }
<span class="lineNum">    1532 </span><span class="lineCov">       1150 :   AliDebug(4, Form(&quot;   Tracklet candidates: row[%2d] = %2d row[%2d] = %2d:&quot;, idxRow[0], nts[0], idxRow[1], nts[1]));</span>
<span class="lineNum">    1533 </span><span class="lineCov">        460 :   if(AliLog::GetDebugLevel(&quot;TRD&quot;, &quot;AliTRDseedV1&quot;)&gt;3){</span>
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :     for(Int_t jr(0); jr&lt;nrc; jr++){</span>
<span class="lineNum">    1535 </span><span class="lineNoCov">          0 :       Int_t ir(idxRow[jr]);</span>
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 :       for(Int_t its(0); its&lt;nts[jr]; its++){</span>
<span class="lineNum">    1537 </span><span class="lineNoCov">          0 :         printf(&quot;  segId[%2d] row[%2d] Ncl[%2d] x[cm]=%7.2f dz[pu]=%4.2f dy[mm]=%+7.3f r[deg]=%+6.2f p[%%]=%6.2f s[um]=%7.2f\n&quot;,</span>
<span class="lineNum">    1538 </span><span class="lineNoCov">          0 :             its, ir, n[jr][its], xm[jr][its], zresRow[jr], 1.e1*ym[jr][its], r[jr][its]*TMath::RadToDeg(), 100.*p[jr][its], 1.e4*s[jr][its]);</span>
<span class="lineNum">    1539 </span>            :       }
<span class="lineNum">    1540 </span>            :     }
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1542 </span><span class="lineCov">        460 :   if(!pstreamer &amp;&amp; </span>
<span class="lineNum">    1543 </span><span class="lineCov">        230 :      ( (recoParam-&gt;GetStreamLevel(AliTRDrecoParam::kTracker) &gt; 2 &amp;&amp; fkReconstructor-&gt;IsDebugStreaming()) ||</span>
<span class="lineNum">    1544 </span><span class="lineCov">        230 :        AliTRDReconstructor::GetStreamLevel()&gt;2 ) </span>
<span class="lineNum">    1545 </span><span class="lineNoCov">          0 :      ) pstreamer = fkReconstructor-&gt;GetDebugStream(AliTRDrecoParam::kTracker);</span>
<span class="lineNum">    1546 </span><span class="lineCov">        230 :   if(pstreamer){</span>
<span class="lineNum">    1547 </span>            :     // save config. for calibration
<span class="lineNum">    1548 </span><span class="lineNoCov">          0 :     TVectorD vidx, vn, vx, vy, vr, vs, vsm, vp, vf;</span>
<span class="lineNum">    1549 </span><span class="lineNoCov">          0 :     vidx.ResizeTo(ncl[idxRow[0]]+(idxRow[1]&lt;0?0:ncl[idxRow[1]]));</span>
<span class="lineNum">    1550 </span><span class="lineNoCov">          0 :     vn.ResizeTo(mts);</span>
<span class="lineNum">    1551 </span><span class="lineNoCov">          0 :     vx.ResizeTo(mts);</span>
<span class="lineNum">    1552 </span><span class="lineNoCov">          0 :     vy.ResizeTo(mts);</span>
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :     vr.ResizeTo(mts);</span>
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :     vs.ResizeTo(mts);</span>
<span class="lineNum">    1555 </span><span class="lineNoCov">          0 :     vsm.ResizeTo(mts);</span>
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 :     vp.ResizeTo(mts);</span>
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :     vf.ResizeTo(mts);</span>
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 :     for(Int_t jr(0), jts(0), jc(0); jr&lt;nrc; jr++){</span>
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :        Int_t ir(idxRow[jr]);</span>
<span class="lineNum">    1560 </span><span class="lineNoCov">          0 :        for(Int_t its(0); its&lt;nts[jr]; its++, jts++){</span>
<span class="lineNum">    1561 </span><span class="lineNoCov">          0 :         vn[jts] = n[jr][its];</span>
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 :         vx[jts] = xm[jr][its];</span>
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :         vy[jts] = ym[jr][its];</span>
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :         vr[jts] = r[jr][its];</span>
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :         vs[jts] = s[jr][its];</span>
<span class="lineNum">    1566 </span><span class="lineNoCov">          0 :         vsm[jts]= sm[jr][its];</span>
<span class="lineNum">    1567 </span><span class="lineNoCov">          0 :         vp[jts] = p[jr][its];</span>
<span class="lineNum">    1568 </span><span class="lineNoCov">          0 :         vf[jts] = jr?-1.:f[its];</span>
<span class="lineNum">    1569 </span>            :       }
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :       for(Int_t ic(0); ic&lt;ncl[ir]; ic++, jc++) vidx[jc] = index[jr][ic];</span>
<span class="lineNum">    1571 </span>            :     }
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :     (*pstreamer) &lt;&lt; &quot;AttachClusters3&quot;</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;idx=&quot;    &lt;&lt; &amp;vidx</span>
<span class="lineNum">    1574 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;n=&quot;      &lt;&lt; &amp;vn</span>
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;x=&quot;      &lt;&lt; &amp;vx</span>
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;y=&quot;      &lt;&lt; &amp;vy</span>
<span class="lineNum">    1577 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;r=&quot;      &lt;&lt; &amp;vr</span>
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;s=&quot;      &lt;&lt; &amp;vs</span>
<span class="lineNum">    1579 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;sm=&quot;     &lt;&lt; &amp;vsm</span>
<span class="lineNum">    1580 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;p=&quot;      &lt;&lt; &amp;vp</span>
<span class="lineNum">    1581 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;f=&quot;      &lt;&lt; &amp;vf</span>
<span class="lineNum">    1582 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1584 </span>            : 
<span class="lineNum">    1585 </span>            : //=========================================================
<span class="lineNum">    1586 </span>            :   // Get seed tracklet segment
<span class="lineNum">    1587 </span><span class="lineCov">        230 :   Int_t idx2[kNcls]; memset(idx2, 0, kNcls*sizeof(Int_t)); // seeding indexing</span>
<span class="lineNum">    1588 </span><span class="lineCov">        244 :   if(nts[0]&gt;1) TMath::Sort(nts[0], f, idx2);</span>
<span class="lineNum">    1589 </span><span class="lineCov">        230 :   Int_t is(idx2[0]); // seed index</span>
<span class="lineNum">    1590 </span><span class="lineCov">        230 :   Int_t     idxTrklt[kNcls],</span>
<span class="lineNum">    1591 </span>            :             kts(0),
<span class="lineNum">    1592 </span><span class="lineCov">        230 :             nTrklt(n[0][is]);</span>
<span class="lineNum">    1593 </span><span class="lineCov">       1610 :   Double_t  fTrklt(f[is]),</span>
<span class="lineNum">    1594 </span><span class="lineCov">        230 :             rTrklt(r[0][is]), </span>
<span class="lineNum">    1595 </span><span class="lineCov">        230 :             yTrklt(ym[0][is]), </span>
<span class="lineNum">    1596 </span><span class="lineCov">        230 :             sTrklt(s[0][is]), </span>
<span class="lineNum">    1597 </span><span class="lineCov">        230 :             smTrklt(sm[0][is]), </span>
<span class="lineNum">    1598 </span><span class="lineCov">        230 :             xTrklt(xm[0][is]), </span>
<span class="lineNum">    1599 </span><span class="lineCov">        230 :             pTrklt(p[0][is]),</span>
<span class="lineNum">    1600 </span><span class="lineCov">        230 :             qTrklt(q[0][is]);</span>
<span class="lineNum">    1601 </span><span class="lineCov">        230 :   memset(idxTrklt, 0, kNcls*sizeof(Int_t));</span>
<span class="lineNum">    1602 </span>            :   // check seed idx2[0] exit if not found
<span class="lineNum">    1603 </span><span class="lineCov">        460 :   if(f[is]&lt;1.e-2){</span>
<span class="lineNum">    1604 </span><span class="lineCov">        240 :     AliDebug(1, Form(&quot;Seed   seg[%d] row[%2d] n[%2d] f[%f]&lt;0.01.&quot;, is, idxRow[0], n[0][is], f[is]));</span>
<span class="lineNum">    1605 </span><span class="lineCov">          2 :     SetErrorMsg(kAttachClAttach);</span>
<span class="lineNum">    1606 </span><span class="lineCov">          4 :     if(!pstreamer &amp;&amp; </span>
<span class="lineNum">    1607 </span><span class="lineCov">          2 :        ( (recoParam-&gt;GetStreamLevel(AliTRDrecoParam::kTracker) &gt; 1 &amp;&amp; fkReconstructor-&gt;IsDebugStreaming()) ||</span>
<span class="lineNum">    1608 </span><span class="lineCov">          2 :          AliTRDReconstructor::GetStreamLevel()&gt;1 ) </span>
<span class="lineNum">    1609 </span><span class="lineNoCov">          0 :        ) pstreamer = fkReconstructor-&gt;GetDebugStream(AliTRDrecoParam::kTracker);</span>
<span class="lineNum">    1610 </span><span class="lineCov">          2 :     if(pstreamer){</span>
<span class="lineNum">    1611 </span><span class="lineNoCov">          0 :       UChar_t stat(0);</span>
<span class="lineNum">    1612 </span><span class="lineNoCov">          0 :       if(IsKink()) SETBIT(stat, 1);</span>
<span class="lineNum">    1613 </span><span class="lineNoCov">          0 :       if(IsStandAlone()) SETBIT(stat, 2);</span>
<span class="lineNum">    1614 </span><span class="lineNoCov">          0 :       if(IsRowCross()) SETBIT(stat, 3);</span>
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :       SETBIT(stat, 4); // set error bit</span>
<span class="lineNum">    1616 </span><span class="lineNoCov">          0 :       TVectorD vidx; vidx.ResizeTo(1); vidx[0] = is;</span>
<span class="lineNum">    1617 </span><span class="lineNoCov">          0 :       (*pstreamer) &lt;&lt; &quot;AttachClusters2&quot;</span>
<span class="lineNum">    1618 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;stat=&quot;   &lt;&lt; stat</span>
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;ev=&quot;     &lt;&lt; ev</span>
<span class="lineNum">    1620 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;chg=&quot;    &lt;&lt; chgPos</span>
<span class="lineNum">    1621 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;det=&quot;    &lt;&lt; fDet</span>
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;x0=&quot;     &lt;&lt; fX0</span>
<span class="lineNum">    1623 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;y0=&quot;     &lt;&lt; fYref[0]</span>
<span class="lineNum">    1624 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;z0=&quot;     &lt;&lt; fZref[0]</span>
<span class="lineNum">    1625 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;phi=&quot;    &lt;&lt; phiTrk</span>
<span class="lineNum">    1626 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;tht=&quot;    &lt;&lt; thtTrk</span>
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;pt=&quot;     &lt;&lt; fPt</span>
<span class="lineNum">    1628 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;s2Trk=&quot;  &lt;&lt; s2yTrk</span>
<span class="lineNum">    1629 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;s2Cl=&quot;   &lt;&lt; s2Mean</span>
<span class="lineNum">    1630 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;idx=&quot;    &lt;&lt; &amp;vidx</span>
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;n=&quot;      &lt;&lt; nTrklt</span>
<span class="lineNum">    1632 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;f=&quot;      &lt;&lt; fTrklt</span>
<span class="lineNum">    1633 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;x=&quot;      &lt;&lt; xTrklt</span>
<span class="lineNum">    1634 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;y=&quot;      &lt;&lt; yTrklt</span>
<span class="lineNum">    1635 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;r=&quot;      &lt;&lt; rTrklt</span>
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;s=&quot;      &lt;&lt; sTrklt</span>
<span class="lineNum">    1637 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;sm=&quot;     &lt;&lt; smTrklt</span>
<span class="lineNum">    1638 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;p=&quot;      &lt;&lt; pTrklt</span>
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;q=&quot;      &lt;&lt; qTrklt</span>
<span class="lineNum">    1640 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">    1641 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1642 </span><span class="lineCov">          2 :     return kFALSE;</span>
<span class="lineNum">    1643 </span>            :   }
<span class="lineNum">    1644 </span><span class="lineCov">       1140 :   AliDebug(2, Form(&quot;Seed   seg[%d] row[%2d] n[%2d] dy[%f] r[%+5.2f] s[%+5.2f] f[%5.3f] q[%6.2f]&quot;, is, idxRow[0], n[0][is], ym[0][is], r[0][is]*TMath::RadToDeg(), s[0][is]/sm[0][is], f[is], q[0][is]));</span>
<span class="lineNum">    1645 </span>            : 
<span class="lineNum">    1646 </span>            :   // save seeding segment in the helper
<span class="lineNum">    1647 </span><span class="lineCov">        228 :   idxTrklt[kts++] = is;</span>
<span class="lineNum">    1648 </span><span class="lineCov">        228 :   helper.Init(pp, &amp;clst[idxRow[0]], index[0], is);</span>
<span class="lineNum">    1649 </span><span class="lineCov">        228 :   AliTRDtrackletOflHelper test; // helper to test segment expantion</span>
<span class="lineNum">    1650 </span><span class="lineCov">        228 :   Float_t rcLikelihood(0.); SetBit(kRowCross, kFALSE);</span>
<span class="lineNum">    1651 </span><span class="lineCov">        228 :   Double_t dyRez[kNcls]; Int_t idx3[kNcls];</span>
<span class="lineNum">    1652 </span>            :   
<span class="lineNum">    1653 </span>            :   //=========================================================
<span class="lineNum">    1654 </span>            :   // Define filter parameters from OCDB
<span class="lineNum">    1655 </span><span class="lineCov">        228 :   Int_t kNSgmDy[2]; attach-&gt;GetNsgmDy(kNSgmDy[0], kNSgmDy[1]);</span>
<span class="lineNum">    1656 </span><span class="lineCov">        228 :   Float_t kLikeMinRelDecrease[2]; attach-&gt;GetLikeMinRelDecrease(kLikeMinRelDecrease[0], kLikeMinRelDecrease[1]);</span>
<span class="lineNum">    1657 </span><span class="lineCov">        228 :   Float_t kRClikeLimit(attach-&gt;GetRClikeLimit());</span>
<span class="lineNum">    1658 </span>            : 
<span class="lineNum">    1659 </span>            :   //=========================================================
<span class="lineNum">    1660 </span>            :   // Try attaching next segments from first row (if any)
<span class="lineNum">    1661 </span><span class="lineCov">        228 :   if(nts[0]&gt;1){</span>
<span class="lineNum">    1662 </span><span class="lineCov">         14 :     Int_t jr(0), ir(idxRow[jr]);</span>
<span class="lineNum">    1663 </span>            :     // organize  secondary sgms. in decreasing order of their distance from seed 
<span class="lineNum">    1664 </span><span class="lineCov">         14 :     memset(dyRez, 0, nts[jr]*sizeof(Double_t));</span>
<span class="lineNum">    1665 </span><span class="lineCov">        108 :     for(Int_t jts(1); jts&lt;nts[jr]; jts++) {</span>
<span class="lineNum">    1666 </span><span class="lineCov">         40 :       Int_t its(idx2[jts]);</span>
<span class="lineNum">    1667 </span><span class="lineCov">         40 :       Double_t rot(TMath::Tan(r[0][is]));</span>
<span class="lineNum">    1668 </span><span class="lineCov">         40 :       dyRez[its] = TMath::Abs(ym[0][is] - ym[jr][its] + rot*(xm[0][is]-xm[jr][its]));</span>
<span class="lineNum">    1669 </span>            :     }
<span class="lineNum">    1670 </span><span class="lineCov">         14 :     TMath::Sort(nts[jr], dyRez, idx3, kFALSE);</span>
<span class="lineNum">    1671 </span><span class="lineCov">        108 :     for (Int_t jts(1); jts&lt;nts[jr]; jts++) {</span>
<span class="lineNum">    1672 </span><span class="lineCov">         40 :       Int_t its(idx3[jts]);</span>
<span class="lineNum">    1673 </span><span class="lineCov">         40 :       if(dyRez[its] &gt; kNSgmDy[jr]*smTrklt){</span>
<span class="lineNum">    1674 </span><span class="lineCov">         80 :         AliDebug(2, Form(&quot;Reject seg[%d] row[%2d] n[%2d] dy[%f] &gt; %d*s[%f].&quot;, its, idxRow[jr], n[jr][its], dyRez[its], kNSgmDy[jr], kNSgmDy[jr]*smTrklt));</span>
<span class="lineNum">    1675 </span><span class="lineCov">         16 :         continue;</span>
<span class="lineNum">    1676 </span>            :       }
<span class="lineNum">    1677 </span>            :       
<span class="lineNum">    1678 </span><span class="lineCov">         24 :       test = helper;</span>
<span class="lineNum">    1679 </span><span class="lineCov">         24 :       Int_t n0 = test.Expand(&amp;clst[ir], index[jr], its);</span>
<span class="lineNum">    1680 </span><span class="lineCov">         24 :       Double_t rt, dyt, st, xt, smt, pt, qt, ft;</span>
<span class="lineNum">    1681 </span><span class="lineCov">         24 :       Int_t n1 = test.GetRMS(rt, dyt, st, fX0/*xt*/);</span>
<span class="lineNum">    1682 </span><span class="lineCov">         24 :       pt = Double_t(n1)/n0;</span>
<span class="lineNum">    1683 </span><span class="lineCov">         24 :       smt = test.GetSyMean();</span>
<span class="lineNum">    1684 </span><span class="lineCov">         48 :       qt  = test.GetQ()/TMath::Sqrt(1. + fYref[1]*fYref[1] + fZref[1]*fZref[1]);</span>
<span class="lineNum">    1685 </span><span class="lineCov">         24 :       xt  = fX0;</span>
<span class="lineNum">    1686 </span>            :       // correct position
<span class="lineNum">    1687 </span><span class="lineCov">         24 :       Double_t dxm= fX0 - xt;</span>
<span class="lineNum">    1688 </span><span class="lineCov">         24 :       yt = fYref[0] - fYref[1]*dxm; </span>
<span class="lineNum">    1689 </span><span class="lineCov">         24 :       zt = fZref[0] - fZref[1]*dxm;</span>
<span class="lineNum">    1690 </span>            :       // correct tracklet fit for tilt
<span class="lineNum">    1691 </span><span class="lineCov">         24 :       dyt+= GetTilt()*(zt - zc[idxRow[0]]);</span>
<span class="lineNum">    1692 </span><span class="lineCov">         24 :       rt += GetTilt() * fZref[1];</span>
<span class="lineNum">    1693 </span>            :       // correct tracklet fit for track position/inclination
<span class="lineNum">    1694 </span><span class="lineCov">         24 :       dyt  = yt - dyt;</span>
<span class="lineNum">    1695 </span><span class="lineCov">         24 :       rt   = (rt - fYref[1])/(1+rt*fYref[1]);</span>
<span class="lineNum">    1696 </span>            :       // report inclination in radians
<span class="lineNum">    1697 </span><span class="lineCov">         24 :       rt = TMath::ATan(rt);</span>
<span class="lineNum">    1698 </span>            :         
<span class="lineNum">    1699 </span><span class="lineCov">         72 :       ft = (n0&gt;=2) ? attach-&gt;CookLikelihood(chgPos, lyDet, fPt, phiTrk, n0,  dyt/*sRef*/, rt*TMath::RadToDeg(), st/smt) : 0.;</span>
<span class="lineNum">    1700 </span><span class="lineCov">         24 :       Bool_t kAccept(ft&gt;=fTrklt*(1.-kLikeMinRelDecrease[jr]));</span>
<span class="lineNum">    1701 </span>            :       
<span class="lineNum">    1702 </span><span class="lineCov">        120 :       AliDebug(2, Form(&quot;%s seg[%d] row[%2d] n[%2d] dy[%f] r[%+5.2f] s[%+5.2f] f[%f] &lt; %4.2f*F[%f].&quot;, </span>
<span class="lineNum">    1703 </span>            :         (kAccept?&quot;Adding&quot;:&quot;Reject&quot;), its, idxRow[jr], n0, dyt, rt*TMath::RadToDeg(), st/smt, ft, 1.-kLikeMinRelDecrease[jr], fTrklt*(1.-kLikeMinRelDecrease[jr])));
<span class="lineNum">    1704 </span><span class="lineCov">         24 :       if(kAccept){</span>
<span class="lineNum">    1705 </span><span class="lineCov">         16 :         idxTrklt[kts++] = its;</span>
<span class="lineNum">    1706 </span><span class="lineCov">         16 :         nTrklt = n0;</span>
<span class="lineNum">    1707 </span><span class="lineCov">         16 :         fTrklt = ft;</span>
<span class="lineNum">    1708 </span><span class="lineCov">         16 :         rTrklt = rt;</span>
<span class="lineNum">    1709 </span><span class="lineCov">         16 :         yTrklt = dyt;</span>
<span class="lineNum">    1710 </span><span class="lineCov">         16 :         sTrklt = st;</span>
<span class="lineNum">    1711 </span><span class="lineCov">         16 :         smTrklt= smt;</span>
<span class="lineNum">    1712 </span><span class="lineCov">         16 :         xTrklt = xt;</span>
<span class="lineNum">    1713 </span><span class="lineCov">         16 :         pTrklt = pt;</span>
<span class="lineNum">    1714 </span><span class="lineCov">         16 :         qTrklt = qt;</span>
<span class="lineNum">    1715 </span><span class="lineCov">         16 :         helper.Expand(&amp;clst[ir], index[jr], its);</span>
<span class="lineNum">    1716 </span>            :       }
<span class="lineNum">    1717 </span><span class="lineCov">         24 :     }</span>
<span class="lineNum">    1718 </span><span class="lineCov">         14 :   }</span>
<span class="lineNum">    1719 </span>            :   
<span class="lineNum">    1720 </span>            :   //=========================================================
<span class="lineNum">    1721 </span>            :   // Try attaching next segments from second row (if any)
<span class="lineNum">    1722 </span><span class="lineCov">        259 :   if(nts[1] &amp;&amp; (rcLikelihood = zresRow[0]/zresRow[1]) &gt; kRClikeLimit){</span>
<span class="lineNum">    1723 </span>            :     // organize  secondaries in decreasing order of their distance from seed 
<span class="lineNum">    1724 </span><span class="lineCov">         21 :     Int_t jr(1), ir(idxRow[jr]);</span>
<span class="lineNum">    1725 </span><span class="lineCov">         21 :     memset(dyRez, 0, nts[jr]*sizeof(Double_t));</span>
<span class="lineNum">    1726 </span><span class="lineCov">         21 :     Double_t rot(TMath::Tan(r[0][is]));</span>
<span class="lineNum">    1727 </span><span class="lineCov">         88 :     for(Int_t jts(0); jts&lt;nts[jr]; jts++) {</span>
<span class="lineNum">    1728 </span><span class="lineCov">         23 :       dyRez[jts] = TMath::Abs(ym[0][is] - ym[jr][jts] + rot*(xm[0][is]-xm[jr][jts]));</span>
<span class="lineNum">    1729 </span>            :     }
<span class="lineNum">    1730 </span><span class="lineCov">         21 :     TMath::Sort(nts[jr], dyRez, idx3, kFALSE);</span>
<span class="lineNum">    1731 </span><span class="lineCov">         88 :     for (Int_t jts(0); jts&lt;nts[jr]; jts++) {</span>
<span class="lineNum">    1732 </span><span class="lineCov">         23 :       Int_t its(idx3[jts]);</span>
<span class="lineNum">    1733 </span><span class="lineCov">         23 :       if(dyRez[its] &gt; kNSgmDy[jr]*smTrklt){</span>
<span class="lineNum">    1734 </span><span class="lineCov">         35 :         AliDebug(2, Form(&quot;Reject seg[%d] row[%2d] n[%2d] dy[%f] &gt; %d*s[%f].&quot;, its, idxRow[jr], n[jr][its], dyRez[its], kNSgmDy[jr], kNSgmDy[jr]*smTrklt));</span>
<span class="lineNum">    1735 </span><span class="lineCov">          7 :         continue;</span>
<span class="lineNum">    1736 </span>            :       }
<span class="lineNum">    1737 </span>            :       
<span class="lineNum">    1738 </span><span class="lineCov">         16 :       test = helper;</span>
<span class="lineNum">    1739 </span><span class="lineCov">         16 :       Int_t n0 = test.Expand(&amp;clst[ir], index[jr], its);</span>
<span class="lineNum">    1740 </span><span class="lineCov">         16 :       Double_t rt, dyt, st, xt, smt, pt, qt, ft;</span>
<span class="lineNum">    1741 </span><span class="lineCov">         16 :       Int_t n1 = test.GetRMS(rt, dyt, st, fX0/*xt*/);</span>
<span class="lineNum">    1742 </span><span class="lineCov">         16 :       pt = Double_t(n1)/n0;</span>
<span class="lineNum">    1743 </span><span class="lineCov">         16 :       smt = test.GetSyMean();</span>
<span class="lineNum">    1744 </span><span class="lineCov">         32 :       qt  = test.GetQ()/TMath::Sqrt(1. + fYref[1]*fYref[1] + fZref[1]*fZref[1]);</span>
<span class="lineNum">    1745 </span><span class="lineCov">         16 :       xt  = fX0;</span>
<span class="lineNum">    1746 </span>            :       // correct position
<span class="lineNum">    1747 </span><span class="lineCov">         16 :       Double_t dxm= fX0 - xt;</span>
<span class="lineNum">    1748 </span><span class="lineCov">         16 :       yt = fYref[0] - fYref[1]*dxm; </span>
<span class="lineNum">    1749 </span><span class="lineCov">         16 :       zt = fZref[0] - fZref[1]*dxm;</span>
<span class="lineNum">    1750 </span>            :       // correct tracklet fit for tilt
<span class="lineNum">    1751 </span><span class="lineCov">         16 :       dyt+= GetTilt()*(zt - zc[idxRow[0]]);</span>
<span class="lineNum">    1752 </span><span class="lineCov">         16 :       rt += GetTilt() * fZref[1];</span>
<span class="lineNum">    1753 </span>            :       // correct tracklet fit for track position/inclination
<span class="lineNum">    1754 </span><span class="lineCov">         16 :       dyt  = yt - dyt;</span>
<span class="lineNum">    1755 </span><span class="lineCov">         16 :       rt   = (rt - fYref[1])/(1+rt*fYref[1]);</span>
<span class="lineNum">    1756 </span>            :       // report inclination in radians
<span class="lineNum">    1757 </span><span class="lineCov">         16 :       rt = TMath::ATan(rt);</span>
<span class="lineNum">    1758 </span>            :         
<span class="lineNum">    1759 </span><span class="lineCov">         48 :       ft = (n0&gt;=2) ? attach-&gt;CookLikelihood(chgPos, lyDet, fPt, phiTrk, n0,  dyt/*sRef*/, rt*TMath::RadToDeg(), st/smt) : 0.;</span>
<span class="lineNum">    1760 </span><span class="lineCov">         16 :       Bool_t kAccept(ft&gt;=fTrklt*(1.-kLikeMinRelDecrease[jr]));</span>
<span class="lineNum">    1761 </span>            :       
<span class="lineNum">    1762 </span><span class="lineCov">         80 :       AliDebug(2, Form(&quot;%s seg[%d] row[%2d] n[%2d] dy[%f] r[%+5.2f] s[%+5.2f] f[%f] &lt; %4.2f*F[%f].&quot;, </span>
<span class="lineNum">    1763 </span>            :         (kAccept?&quot;Adding&quot;:&quot;Reject&quot;), its, idxRow[jr], n0, dyt, rt*TMath::RadToDeg(), st/smt, ft, 1.-kLikeMinRelDecrease[jr], fTrklt*(1.-kLikeMinRelDecrease[jr])));
<span class="lineNum">    1764 </span><span class="lineCov">         16 :       if(kAccept){</span>
<span class="lineNum">    1765 </span><span class="lineCov">         16 :         idxTrklt[kts++] = its;</span>
<span class="lineNum">    1766 </span><span class="lineCov">         16 :         nTrklt = n0;</span>
<span class="lineNum">    1767 </span><span class="lineCov">         16 :         fTrklt = ft;</span>
<span class="lineNum">    1768 </span><span class="lineCov">         16 :         rTrklt = rt;</span>
<span class="lineNum">    1769 </span><span class="lineCov">         16 :         yTrklt = dyt;</span>
<span class="lineNum">    1770 </span><span class="lineCov">         16 :         sTrklt = st;</span>
<span class="lineNum">    1771 </span><span class="lineCov">         16 :         smTrklt= smt;</span>
<span class="lineNum">    1772 </span><span class="lineCov">         16 :         xTrklt = xt;</span>
<span class="lineNum">    1773 </span><span class="lineCov">         16 :         pTrklt = pt;</span>
<span class="lineNum">    1774 </span><span class="lineCov">         16 :         qTrklt = qt;</span>
<span class="lineNum">    1775 </span><span class="lineCov">         16 :         helper.Expand(&amp;clst[ir], index[jr], its);</span>
<span class="lineNum">    1776 </span><span class="lineCov">         16 :         SetBit(kRowCross, kTRUE); // mark pad row crossing</span>
<span class="lineNum">    1777 </span>            :       }
<span class="lineNum">    1778 </span><span class="lineCov">         16 :     }</span>
<span class="lineNum">    1779 </span><span class="lineCov">         21 :   }</span>
<span class="lineNum">    1780 </span>            :   // clear local copy of clusters
<span class="lineNum">    1781 </span><span class="lineCov">      11400 :   for(Int_t ir(0); ir&lt;kNrows; ir++) clst[ir].Clear();</span>
<span class="lineNum">    1782 </span>            :   
<span class="lineNum">    1783 </span><span class="lineCov">        456 :   if(!pstreamer &amp;&amp; </span>
<span class="lineNum">    1784 </span><span class="lineCov">        228 :      ((recoParam-&gt;GetStreamLevel(AliTRDrecoParam::kTracker) &gt; 1 &amp;&amp; fkReconstructor-&gt;IsDebugStreaming()) ||</span>
<span class="lineNum">    1785 </span><span class="lineCov">        228 :       AliTRDReconstructor::GetStreamLevel()&gt;1 )</span>
<span class="lineNum">    1786 </span><span class="lineNoCov">          0 :      ) pstreamer = fkReconstructor-&gt;GetDebugStream(AliTRDrecoParam::kTracker);</span>
<span class="lineNum">    1787 </span><span class="lineCov">        228 :   if(pstreamer){</span>
<span class="lineNum">    1788 </span><span class="lineNoCov">          0 :     UChar_t stat(0);</span>
<span class="lineNum">    1789 </span><span class="lineNoCov">          0 :     if(IsKink()) SETBIT(stat, 1);</span>
<span class="lineNum">    1790 </span><span class="lineNoCov">          0 :     if(IsStandAlone()) SETBIT(stat, 2);</span>
<span class="lineNum">    1791 </span><span class="lineNoCov">          0 :     if(IsRowCross()) SETBIT(stat, 3);</span>
<span class="lineNum">    1792 </span><span class="lineNoCov">          0 :     TVectorD vidx; vidx.ResizeTo(kts);</span>
<span class="lineNum">    1793 </span><span class="lineNoCov">          0 :     for(Int_t its(0); its&lt;kts; its++) vidx[its] = idxTrklt[its];</span>
<span class="lineNum">    1794 </span><span class="lineNoCov">          0 :     (*pstreamer) &lt;&lt; &quot;AttachClusters2&quot;</span>
<span class="lineNum">    1795 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;stat=&quot;   &lt;&lt; stat</span>
<span class="lineNum">    1796 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;ev=&quot;     &lt;&lt; ev</span>
<span class="lineNum">    1797 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;chg=&quot;    &lt;&lt; chgPos</span>
<span class="lineNum">    1798 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;det=&quot;    &lt;&lt; fDet</span>
<span class="lineNum">    1799 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;x0=&quot;     &lt;&lt; fX0</span>
<span class="lineNum">    1800 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;y0=&quot;     &lt;&lt; fYref[0]</span>
<span class="lineNum">    1801 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;z0=&quot;     &lt;&lt; fZref[0]</span>
<span class="lineNum">    1802 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;phi=&quot;    &lt;&lt; phiTrk</span>
<span class="lineNum">    1803 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;tht=&quot;    &lt;&lt; thtTrk</span>
<span class="lineNum">    1804 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;pt=&quot;     &lt;&lt; fPt</span>
<span class="lineNum">    1805 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;s2Trk=&quot;  &lt;&lt; s2yTrk</span>
<span class="lineNum">    1806 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;s2Cl=&quot;   &lt;&lt; s2Mean</span>
<span class="lineNum">    1807 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;idx=&quot;    &lt;&lt; &amp;vidx</span>
<span class="lineNum">    1808 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;n=&quot;      &lt;&lt; nTrklt</span>
<span class="lineNum">    1809 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;q=&quot;      &lt;&lt; qTrklt</span>
<span class="lineNum">    1810 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;f=&quot;      &lt;&lt; fTrklt</span>
<span class="lineNum">    1811 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;x=&quot;      &lt;&lt; xTrklt</span>
<span class="lineNum">    1812 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;y=&quot;      &lt;&lt; yTrklt</span>
<span class="lineNum">    1813 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;r=&quot;      &lt;&lt; rTrklt</span>
<span class="lineNum">    1814 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;s=&quot;      &lt;&lt; sTrklt</span>
<span class="lineNum">    1815 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;sm=&quot;     &lt;&lt; smTrklt</span>
<span class="lineNum">    1816 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;p=&quot;      &lt;&lt; pTrklt</span>
<span class="lineNum">    1817 </span><span class="lineNoCov">          0 :         &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">    1818 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1819 </span>            :   
<span class="lineNum">    1820 </span>            :   
<span class="lineNum">    1821 </span>            :   //=========================================================
<span class="lineNum">    1822 </span>            :   // Store clusters
<span class="lineNum">    1823 </span>            :   Int_t nselected(0), nc(0);
<span class="lineNum">    1824 </span><span class="lineCov">        228 :   TObjArray *selected(helper.GetClusters());</span>
<span class="lineNum">    1825 </span><span class="lineCov">        684 :   if(!selected || !(nselected = selected-&gt;GetEntriesFast())){</span>
<span class="lineNum">    1826 </span><span class="lineNoCov">          0 :     AliError(&quot;Cluster candidates missing !!!&quot;);</span>
<span class="lineNum">    1827 </span><span class="lineNoCov">          0 :     SetErrorMsg(kAttachClAttach);</span>
<span class="lineNum">    1828 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">    1829 </span>            :   }
<span class="lineNum">    1830 </span><span class="lineCov">      10662 :   for(Int_t ic(0); ic&lt;nselected; ic++){</span>
<span class="lineNum">    1831 </span><span class="lineCov">      10206 :     if(!(c = (AliTRDcluster*)selected-&gt;At(ic))) continue;</span>
<span class="lineNum">    1832 </span><span class="lineCov">       5103 :     Int_t it(c-&gt;GetPadTime()),</span>
<span class="lineNum">    1833 </span><span class="lineCov">       5103 :           jr(Int_t(helper.GetRow() != c-&gt;GetPadRow())),</span>
<span class="lineNum">    1834 </span><span class="lineCov">       5103 :           idx(it+kNtb*jr);</span>
<span class="lineNum">    1835 </span><span class="lineCov">       5103 :     if(fClusters[idx]){</span>
<span class="lineNum">    1836 </span><span class="lineCov">        675 :       AliDebug(1, Form(&quot;Multiple clusters/tb for D[%03d] Tb[%02d] Row[%2d]&quot;, fDet, it, c-&gt;GetPadRow()));</span>
<span class="lineNum">    1837 </span><span class="lineCov">        135 :       continue; // already booked</span>
<span class="lineNum">    1838 </span>            :     }
<span class="lineNum">    1839 </span>            :     // TODO proper indexing of clusters !!
<span class="lineNum">    1840 </span><span class="lineCov">       4968 :     fIndexes[idx]  = chamber-&gt;GetTB(it)-&gt;GetGlobalIndex(idxs[idxRow[jr]][ic]);</span>
<span class="lineNum">    1841 </span><span class="lineCov">       4968 :     fClusters[idx] = c;</span>
<span class="lineNum">    1842 </span><span class="lineCov">       4968 :     nc++;</span>
<span class="lineNum">    1843 </span><span class="lineCov">       4968 :   }</span>
<span class="lineNum">    1844 </span><span class="lineCov">       1140 :   AliDebug(2, Form(&quot;Clusters Found[%2d] Attached[%2d] RC[%c]&quot;, nselected, nc, IsRowCross()?'y':'n'));</span>
<span class="lineNum">    1845 </span>            : 
<span class="lineNum">    1846 </span>            :   // number of minimum numbers of clusters expected for the tracklet
<span class="lineNum">    1847 </span><span class="lineCov">        228 :   if (nc &lt; kClmin){</span>
<span class="lineNum">    1848 </span><span class="lineNoCov">          0 :     AliDebug(1, Form(&quot;NOT ENOUGH CLUSTERS %d ATTACHED TO THE TRACKLET [min %d] FROM FOUND %d.&quot;, nc, kClmin, ncls));</span>
<span class="lineNum">    1849 </span><span class="lineNoCov">          0 :     SetErrorMsg(kAttachClAttach);</span>
<span class="lineNum">    1850 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">    1851 </span>            :   }
<span class="lineNum">    1852 </span><span class="lineCov">        228 :   SetN(nc);</span>
<span class="lineNum">    1853 </span>            : 
<span class="lineNum">    1854 </span>            :   // Load calibration parameters for this tracklet  
<span class="lineNum">    1855 </span>            :   //Calibrate();
<span class="lineNum">    1856 </span>            : 
<span class="lineNum">    1857 </span>            :   // calculate dx for time bins in the drift region (calibration aware)
<span class="lineNum">    1858 </span><span class="lineCov">        228 :   Float_t x[2] = {0.,0.}; Int_t tb[2]={0,0};</span>
<span class="lineNum">    1859 </span><span class="lineCov">       2146 :   for (Int_t it = t0, irp=0; irp&lt;2 &amp;&amp; it &lt; AliTRDtrackerV1::GetNTimeBins(); it++) {</span>
<span class="lineNum">    1860 </span><span class="lineCov">        562 :     if(!fClusters[it]) continue;</span>
<span class="lineNum">    1861 </span><span class="lineCov">        448 :     x[irp]  = fClusters[it]-&gt;GetX();</span>
<span class="lineNum">    1862 </span><span class="lineCov">        448 :     tb[irp] = fClusters[it]-&gt;GetLocalTimeBin();</span>
<span class="lineNum">    1863 </span><span class="lineCov">        448 :     irp++;</span>
<span class="lineNum">    1864 </span><span class="lineCov">        448 :   }  </span>
<span class="lineNum">    1865 </span><span class="lineCov">        228 :   Int_t dtb = tb[1] - tb[0];</span>
<span class="lineNum">    1866 </span><span class="lineCov">        680 :   fdX = dtb ? (x[0] - x[1]) / dtb : 0.15;</span>
<span class="lineNum">    1867 </span>            :   return kTRUE;
<span class="lineNum">    1868 </span><span class="lineCov">       5664 : }</span>
<a name="1869"><span class="lineNum">    1869 </span>            : </a>
<span class="lineNum">    1870 </span>            : //____________________________________________________________
<span class="lineNum">    1871 </span>            : void AliTRDseedV1::Bootstrap(const AliTRDReconstructor *rec)
<span class="lineNum">    1872 </span>            : {
<span class="lineNum">    1873 </span>            : //   Fill in all derived information. It has to be called after recovery from file or HLT.
<span class="lineNum">    1874 </span>            : //   The primitive data are
<span class="lineNum">    1875 </span>            : //   - list of clusters
<span class="lineNum">    1876 </span>            : //   - detector (as the detector will be removed from clusters)
<span class="lineNum">    1877 </span>            : //   - position of anode wire (fX0) - temporary
<span class="lineNum">    1878 </span>            : //   - track reference position and direction
<span class="lineNum">    1879 </span>            : //   - momentum of the track
<span class="lineNum">    1880 </span>            : //   - time bin length [cm]
<span class="lineNum">    1881 </span>            : // 
<span class="lineNum">    1882 </span>            : //   A.Bercuci &lt;A.Bercuci@gsi.de&gt; Oct 30th 2008
<span class="lineNum">    1883 </span>            : //
<span class="lineNum">    1884 </span><span class="lineNoCov">          0 :   fkReconstructor = rec;</span>
<span class="lineNum">    1885 </span><span class="lineNoCov">          0 :   AliTRDgeometry g;</span>
<span class="lineNum">    1886 </span><span class="lineNoCov">          0 :   SetPadPlane(g.GetPadPlane(fDet));</span>
<span class="lineNum">    1887 </span>            : 
<span class="lineNum">    1888 </span>            :   //fSnp = fYref[1]/TMath::Sqrt(1+fYref[1]*fYref[1]);
<span class="lineNum">    1889 </span>            :   //fTgl = fZref[1];
<span class="lineNum">    1890 </span>            :   Int_t n = 0, nshare = 0, nused = 0;
<span class="lineNum">    1891 </span><span class="lineNoCov">          0 :   AliTRDcluster **cit = &amp;fClusters[0];</span>
<span class="lineNum">    1892 </span><span class="lineNoCov">          0 :   for(Int_t ic = kNclusters; ic--; cit++){</span>
<span class="lineNum">    1893 </span><span class="lineNoCov">          0 :     if(!(*cit)) return;</span>
<span class="lineNum">    1894 </span><span class="lineNoCov">          0 :     n++;</span>
<span class="lineNum">    1895 </span><span class="lineNoCov">          0 :     if((*cit)-&gt;IsShared()) nshare++;</span>
<span class="lineNum">    1896 </span><span class="lineNoCov">          0 :     if((*cit)-&gt;IsUsed()) nused++;</span>
<span class="lineNum">    1897 </span>            :   }
<span class="lineNum">    1898 </span><span class="lineNoCov">          0 :   SetN(n); SetNUsed(nused); SetNShared(nshare);</span>
<span class="lineNum">    1899 </span><span class="lineNoCov">          0 :   Fit();</span>
<span class="lineNum">    1900 </span><span class="lineNoCov">          0 :   CookLabels();</span>
<span class="lineNum">    1901 </span><span class="lineNoCov">          0 :   GetProbability();</span>
<span class="lineNum">    1902 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1903 </span>            : 
<a name="1904"><span class="lineNum">    1904 </span>            : </a>
<span class="lineNum">    1905 </span>            : //____________________________________________________________________
<span class="lineNum">    1906 </span>            : Bool_t AliTRDseedV1::Fit(UChar_t opt)
<span class="lineNum">    1907 </span>            : {
<span class="lineNum">    1908 </span>            : //
<span class="lineNum">    1909 </span>            : // Linear fit of the clusters attached to the tracklet
<span class="lineNum">    1910 </span>            : //
<span class="lineNum">    1911 </span>            : // Parameters :
<span class="lineNum">    1912 </span>            : //   - opt : switch for tilt pad correction of cluster y position. Options are
<span class="lineNum">    1913 </span>            : //           0 no correction [default]
<span class="lineNum">    1914 </span>            : //           1 full tilt correction [dz/dx and z0]
<span class="lineNum">    1915 </span>            : //           2 pseudo tilt correction [dz/dx from pad-chamber geometry]
<span class="lineNum">    1916 </span>            : //
<span class="lineNum">    1917 </span>            : // Output :
<span class="lineNum">    1918 </span>            : //  True if successful
<span class="lineNum">    1919 </span>            : //
<span class="lineNum">    1920 </span>            : // Detailed description
<span class="lineNum">    1921 </span>            : //
<span class="lineNum">    1922 </span>            : //            Fit in the xy plane
<span class="lineNum">    1923 </span>            : // 
<span class="lineNum">    1924 </span>            : // The fit is performed to estimate the y position of the tracklet and the track 
<span class="lineNum">    1925 </span>            : // angle in the bending plane. The clusters are represented in the chamber coordinate 
<span class="lineNum">    1926 </span>            : // system (with respect to the anode wire - see AliTRDtrackerV1::FollowBackProlongation() 
<span class="lineNum">    1927 </span>            : // on how this is set). The x and y position of the cluster and also their variances 
<span class="lineNum">    1928 </span>            : // are known from clusterizer level (see AliTRDcluster::GetXloc(), AliTRDcluster::GetYloc(), 
<span class="lineNum">    1929 </span>            : // AliTRDcluster::GetSX() and AliTRDcluster::GetSY()). 
<span class="lineNum">    1930 </span>            : // If gaussian approximation is used to calculate y coordinate of the cluster the position 
<span class="lineNum">    1931 </span>            : // is recalculated taking into account the track angle. The general formula to calculate the 
<span class="lineNum">    1932 </span>            : // error of cluster position in the gaussian approximation taking into account diffusion and track
<span class="lineNum">    1933 </span>            : // inclination is given for TRD by:
<span class="lineNum">    1934 </span>            : // BEGIN_LATEX
<span class="lineNum">    1935 </span>            : // #sigma^{2}_{y} = #sigma^{2}_{PRF} + #frac{x#delta_{t}^{2}}{(1+tg(#alpha_{L}))^{2}} + #frac{x^{2}tg^{2}(#phi-#alpha_{L})tg^{2}(#alpha_{L})}{12}
<span class="lineNum">    1936 </span>            : // END_LATEX
<span class="lineNum">    1937 </span>            : //
<span class="lineNum">    1938 </span>            : // Since errors are calculated only in the y directions, radial errors (x direction) are mapped to y
<span class="lineNum">    1939 </span>            : // by projection i.e.
<span class="lineNum">    1940 </span>            : // BEGIN_LATEX
<span class="lineNum">    1941 </span>            : // #sigma_{x|y} = tg(#phi) #sigma_{x}
<span class="lineNum">    1942 </span>            : // END_LATEX
<span class="lineNum">    1943 </span>            : // and also by the lorentz angle correction
<span class="lineNum">    1944 </span>            : //
<span class="lineNum">    1945 </span>            : //            Fit in the xz plane
<span class="lineNum">    1946 </span>            : //
<span class="lineNum">    1947 </span>            : // The &quot;fit&quot; is performed to estimate the radial position (x direction) where pad row cross happens. 
<span class="lineNum">    1948 </span>            : // If no pad row crossing the z position is taken from geometry and radial position is taken from the xy 
<span class="lineNum">    1949 </span>            : // fit (see below).
<span class="lineNum">    1950 </span>            : // 
<span class="lineNum">    1951 </span>            : // There are two methods to estimate the radial position of the pad row cross:
<span class="lineNum">    1952 </span>            : //   1. leading cluster radial position : Here the lower part of the tracklet is considered and the last 
<span class="lineNum">    1953 </span>            : // cluster registered (at radial x0) on this segment is chosen to mark the pad row crossing. The error 
<span class="lineNum">    1954 </span>            : // of the z estimate is given by :
<span class="lineNum">    1955 </span>            : // BEGIN_LATEX
<span class="lineNum">    1956 </span>            : // #sigma_{z} = tg(#theta) #Delta x_{x_{0}}/12
<span class="lineNum">    1957 </span>            : // END_LATEX
<span class="lineNum">    1958 </span>            : // The systematic errors for this estimation are generated by the following sources:
<span class="lineNum">    1959 </span>            : //   - no charge sharing between pad rows is considered (sharp cross)
<span class="lineNum">    1960 </span>            : //   - missing cluster at row cross (noise peak-up, under-threshold signal etc.).
<span class="lineNum">    1961 </span>            : // 
<span class="lineNum">    1962 </span>            : //   2. charge fit over the crossing point : Here the full energy deposit along the tracklet is considered 
<span class="lineNum">    1963 </span>            : // to estimate the position of the crossing by a fit in the qx plane. The errors in the q directions are 
<span class="lineNum">    1964 </span>            : // parameterized as s_q = q^2. The systematic errors for this estimation are generated by the following sources:
<span class="lineNum">    1965 </span>            : //   - no general model for the qx dependence
<span class="lineNum">    1966 </span>            : //   - physical fluctuations of the charge deposit 
<span class="lineNum">    1967 </span>            : //   - gain calibration dependence
<span class="lineNum">    1968 </span>            : //
<span class="lineNum">    1969 </span>            : //            Estimation of the radial position of the tracklet
<span class="lineNum">    1970 </span>            : //
<span class="lineNum">    1971 </span>            : // For pad row cross the radial position is taken from the xz fit (see above). Otherwise it is taken as the 
<span class="lineNum">    1972 </span>            : // interpolation point of the tracklet i.e. the point where the error in y of the fit is minimum. The error
<span class="lineNum">    1973 </span>            : // in the y direction of the tracklet is (see AliTRDseedV1::GetCovAt()):
<span class="lineNum">    1974 </span>            : // BEGIN_LATEX
<span class="lineNum">    1975 </span>            : // #sigma_{y} = #sigma^{2}_{y_{0}} + 2xcov(y_{0}, dy/dx) + #sigma^{2}_{dy/dx}
<span class="lineNum">    1976 </span>            : // END_LATEX
<span class="lineNum">    1977 </span>            : // and thus the radial position is:
<span class="lineNum">    1978 </span>            : // BEGIN_LATEX
<span class="lineNum">    1979 </span>            : // x = - cov(y_{0}, dy/dx)/#sigma^{2}_{dy/dx}
<span class="lineNum">    1980 </span>            : // END_LATEX
<span class="lineNum">    1981 </span>            : //
<span class="lineNum">    1982 </span>            : //            Estimation of tracklet position error 
<span class="lineNum">    1983 </span>            : //
<span class="lineNum">    1984 </span>            : // The error in y direction is the error of the linear fit at the radial position of the tracklet while in the z 
<span class="lineNum">    1985 </span>            : // direction is given by the cluster error or pad row cross error. In case of no pad row cross this is given by:
<span class="lineNum">    1986 </span>            : // BEGIN_LATEX
<span class="lineNum">    1987 </span>            : // #sigma_{y} = #sigma^{2}_{y_{0}} - 2cov^{2}(y_{0}, dy/dx)/#sigma^{2}_{dy/dx} + #sigma^{2}_{dy/dx}
<span class="lineNum">    1988 </span>            : // #sigma_{z} = Pad_{length}/12
<span class="lineNum">    1989 </span>            : // END_LATEX
<span class="lineNum">    1990 </span>            : // For pad row cross the full error is calculated at the radial position of the crossing (see above) and the error 
<span class="lineNum">    1991 </span>            : // in z by the width of the crossing region - being a matter of parameterization. 
<span class="lineNum">    1992 </span>            : // BEGIN_LATEX
<span class="lineNum">    1993 </span>            : // #sigma_{z} = tg(#theta) #Delta x_{x_{0}}/12
<span class="lineNum">    1994 </span>            : // END_LATEX
<span class="lineNum">    1995 </span>            : // In case of no tilt correction (default in the barrel tracking) the tilt is taken into account by the rotation of
<span class="lineNum">    1996 </span>            : // the covariance matrix. See AliTRDseedV1::GetCovAt() for details.
<span class="lineNum">    1997 </span>            : //
<span class="lineNum">    1998 </span>            : // Author 
<span class="lineNum">    1999 </span>            : // A.Bercuci &lt;A.Bercuci@gsi.de&gt;
<span class="lineNum">    2000 </span>            : 
<span class="lineNum">    2001 </span><span class="lineNoCov">          0 :   if(!fkReconstructor){</span>
<span class="lineNum">    2002 </span><span class="lineNoCov">          0 :     AliError(&quot;The tracklet needs the reconstruction setup. Please initialize by SetReconstructor().&quot;);</span>
<span class="lineNum">    2003 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">    2004 </span>            :   }
<span class="lineNum">    2005 </span><span class="lineNoCov">          0 :   if(!IsCalibrated()) Calibrate();</span>
<span class="lineNum">    2006 </span><span class="lineNoCov">          0 :   if(opt&gt;2){</span>
<span class="lineNum">    2007 </span><span class="lineNoCov">          0 :     AliWarning(Form(&quot;Option [%d] outside range [0, 2]. Using default&quot;,opt));</span>
<span class="lineNum">    2008 </span>            :     opt=0;
<span class="lineNum">    2009 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2010 </span>            : 
<span class="lineNum">    2011 </span>            :   const Int_t kClmin = 8;
<span class="lineNum">    2012 </span>            :   const Float_t kScalePulls = 10.; // factor to scale y pulls - NOT UNDERSTOOD
<span class="lineNum">    2013 </span>            :   // get track direction
<span class="lineNum">    2014 </span><span class="lineNoCov">          0 :   Double_t y0   = fYref[0];</span>
<span class="lineNum">    2015 </span><span class="lineNoCov">          0 :   Double_t dydx = fYref[1]; </span>
<span class="lineNum">    2016 </span><span class="lineNoCov">          0 :   Double_t z0   = fZref[0];</span>
<span class="lineNum">    2017 </span><span class="lineNoCov">          0 :   Double_t dzdx = fZref[1];</span>
<span class="lineNum">    2018 </span>            : 
<span class="lineNum">    2019 </span><span class="lineNoCov">          0 :   AliTRDtrackerV1::AliTRDLeastSquare fitterY;</span>
<span class="lineNum">    2020 </span><span class="lineNoCov">          0 :   AliTRDtrackerV1::AliTRDLeastSquare fitterZ;</span>
<span class="lineNum">    2021 </span>            : 
<span class="lineNum">    2022 </span>            :   // book cluster information
<span class="lineNum">    2023 </span><span class="lineNoCov">          0 :   Double_t qc[kNclusters], xc[kNclusters], yc[kNclusters], zc[kNclusters], sy[kNclusters];</span>
<span class="lineNum">    2024 </span>            : 
<span class="lineNum">    2025 </span><span class="lineNoCov">          0 :   Bool_t tilt(opt==1)       // full tilt correction</span>
<span class="lineNum">    2026 </span><span class="lineNoCov">          0 :         ,pseudo(opt==2)     // pseudo tilt correction</span>
<span class="lineNum">    2027 </span><span class="lineNoCov">          0 :         ,rc(IsRowCross())   // row cross candidate </span>
<span class="lineNum">    2028 </span><span class="lineNoCov">          0 :         ,kDZDX(IsPrimary());// switch dzdx calculation for barrel primary tracks</span>
<span class="lineNum">    2029 </span>            :   Int_t n(0);   // clusters used in fit 
<span class="lineNum">    2030 </span><span class="lineNoCov">          0 :   AliTRDcluster *c(NULL), *cc(NULL), **jc = &amp;fClusters[0];</span>
<span class="lineNum">    2031 </span><span class="lineNoCov">          0 :   const AliTRDrecoParam* const recoParam = fkReconstructor-&gt;GetRecoParam(); //the dynamic cast in GetRecoParam is slow, so caching the pointer to it</span>
<span class="lineNum">    2032 </span>            : 
<span class="lineNum">    2033 </span><span class="lineNoCov">          0 :   const Char_t *tcName[]={&quot;NONE&quot;, &quot;FULL&quot;, &quot;HALF&quot;};</span>
<span class="lineNum">    2034 </span><span class="lineNoCov">          0 :   AliDebug(2, Form(&quot;Options : TC[%s] dzdx[%c]&quot;, tcName[opt], kDZDX?'Y':'N'));</span>
<span class="lineNum">    2035 </span>            : 
<span class="lineNum">    2036 </span>            :   
<span class="lineNum">    2037 </span><span class="lineNoCov">          0 :   for (Int_t ic=0; ic&lt;kNclusters; ic++, ++jc) {</span>
<span class="lineNum">    2038 </span><span class="lineNoCov">          0 :     xc[ic]  = -1.; yc[ic]  = 999.; zc[ic]  = 999.; sy[ic]  = 0.;</span>
<span class="lineNum">    2039 </span><span class="lineNoCov">          0 :     if(!(c = (*jc))) continue;</span>
<span class="lineNum">    2040 </span><span class="lineNoCov">          0 :     if(!c-&gt;IsInChamber()) continue;</span>
<span class="lineNum">    2041 </span>            :     // compute pseudo tilt correction
<span class="lineNum">    2042 </span><span class="lineNoCov">          0 :     if(kDZDX){ </span>
<span class="lineNum">    2043 </span><span class="lineNoCov">          0 :       fZfit[0] = c-&gt;GetZ();</span>
<span class="lineNum">    2044 </span><span class="lineNoCov">          0 :       if(rc){</span>
<span class="lineNum">    2045 </span><span class="lineNoCov">          0 :         for(Int_t kc=AliTRDseedV1::kNtb; kc&lt;AliTRDseedV1::kNclusters; kc++){</span>
<span class="lineNum">    2046 </span><span class="lineNoCov">          0 :           if(!(cc=fClusters[kc])) continue;</span>
<span class="lineNum">    2047 </span><span class="lineNoCov">          0 :           if(!cc-&gt;IsInChamber()) continue;</span>
<span class="lineNum">    2048 </span><span class="lineNoCov">          0 :           fZfit[0] += cc-&gt;GetZ(); fZfit[0] *= 0.5;</span>
<span class="lineNum">    2049 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2050 </span>            :         }
<span class="lineNum">    2051 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    2052 </span><span class="lineNoCov">          0 :       fZfit[1] = fZfit[0]/fX0;</span>
<span class="lineNum">    2053 </span><span class="lineNoCov">          0 :       if(rc){</span>
<span class="lineNum">    2054 </span><span class="lineNoCov">          0 :         fZfit[0] += fZfit[1]*0.5*AliTRDgeometry::CdrHght();</span>
<span class="lineNum">    2055 </span><span class="lineNoCov">          0 :         fZfit[1] = fZfit[0]/fX0;</span>
<span class="lineNum">    2056 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    2057 </span>            :       kDZDX=kFALSE;
<span class="lineNum">    2058 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2059 </span>            : 
<span class="lineNum">    2060 </span>            : //   TODO use this information to adjust cluster error parameterization
<span class="lineNum">    2061 </span>            : //     Float_t w = 1.;
<span class="lineNum">    2062 </span>            : //     if(c-&gt;GetNPads()&gt;4) w = .5;
<span class="lineNum">    2063 </span>            : //     if(c-&gt;GetNPads()&gt;5) w = .2;
<span class="lineNum">    2064 </span>            : 
<span class="lineNum">    2065 </span>            :     // cluster charge
<span class="lineNum">    2066 </span><span class="lineNoCov">          0 :     qc[n]   = TMath::Abs(c-&gt;GetQ());</span>
<span class="lineNum">    2067 </span>            :     // pad row of leading 
<span class="lineNum">    2068 </span>            : 
<span class="lineNum">    2069 </span><span class="lineNoCov">          0 :     xc[n]   = fX0 - c-&gt;GetX();</span>
<span class="lineNum">    2070 </span>            : 
<span class="lineNum">    2071 </span>            :     // Recalculate cluster error based on tracking information
<span class="lineNum">    2072 </span><span class="lineNoCov">          0 :     c-&gt;SetSigmaY2(fS2PRF, fDiffT, fExB, xc[n], -1./*zcorr?zt:-1.*/, dydx);</span>
<span class="lineNum">    2073 </span><span class="lineNoCov">          0 :     c-&gt;SetSigmaZ2(fPad[0]*fPad[0]/12.); // for HLT</span>
<span class="lineNum">    2074 </span><span class="lineNoCov">          0 :     sy[n]  = TMath::Sqrt(c-&gt;GetSigmaY2());</span>
<span class="lineNum">    2075 </span>            : 
<span class="lineNum">    2076 </span><span class="lineNoCov">          0 :     yc[n]  = recoParam-&gt;UseGAUS() ? </span>
<span class="lineNum">    2077 </span><span class="lineNoCov">          0 :       c-&gt;GetYloc(y0, sy[n], GetPadWidth()): c-&gt;GetY();</span>
<span class="lineNum">    2078 </span><span class="lineNoCov">          0 :     zc[n]   = c-&gt;GetZ();</span>
<span class="lineNum">    2079 </span>            : 
<span class="lineNum">    2080 </span>            :     //optional r-phi correction
<span class="lineNum">    2081 </span>            :     //printf(&quot;   n[%2d] yc[%7.5f] &quot;, n, yc[n]);
<span class="lineNum">    2082 </span>            :     Float_t correction(0.);
<span class="lineNum">    2083 </span><span class="lineNoCov">          0 :     if(tilt) correction = fPad[2]*(xc[n]*dzdx + zc[n] - z0);</span>
<span class="lineNum">    2084 </span><span class="lineNoCov">          0 :     else if(pseudo) correction = fPad[2]*(xc[n]*fZfit[1] + zc[n]-fZfit[0]);</span>
<span class="lineNum">    2085 </span><span class="lineNoCov">          0 :     yc[n]-=correction;</span>
<span class="lineNum">    2086 </span>            :     //printf(&quot;corr(%s%s)[%7.5f] yc1[%7.5f]\n&quot;, (tilt?&quot;TC&quot;:&quot;&quot;), (zcorr?&quot;PC&quot;:&quot;&quot;), correction, yc[n]);
<span class="lineNum">    2087 </span>            : 
<span class="lineNum">    2088 </span><span class="lineNoCov">          0 :     AliDebug(5, Form(&quot;  tb[%2d] dx[%6.3f] y[%6.2f+-%6.3f]&quot;, c-&gt;GetLocalTimeBin(), xc[n], yc[n], sy[n]));</span>
<span class="lineNum">    2089 </span><span class="lineNoCov">          0 :     fitterY.AddPoint(&amp;xc[n], yc[n], sy[n]);</span>
<span class="lineNum">    2090 </span><span class="lineNoCov">          0 :     if(rc) fitterZ.AddPoint(&amp;xc[n], qc[n]*(ic&lt;kNtb?1.:-1.), 1.);</span>
<span class="lineNum">    2091 </span><span class="lineNoCov">          0 :     n++;</span>
<span class="lineNum">    2092 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2093 </span>            : 
<span class="lineNum">    2094 </span>            :   // to few clusters
<span class="lineNum">    2095 </span><span class="lineNoCov">          0 :   if (n &lt; kClmin){ </span>
<span class="lineNum">    2096 </span><span class="lineNoCov">          0 :     AliDebug(1, Form(&quot;Not enough clusters to fit. Clusters: Attached[%d] Fit[%d].&quot;, GetN(), n));</span>
<span class="lineNum">    2097 </span><span class="lineNoCov">          0 :     SetErrorMsg(kFitCl);</span>
<span class="lineNum">    2098 </span><span class="lineNoCov">          0 :     return kFALSE; </span>
<span class="lineNum">    2099 </span>            :   }
<span class="lineNum">    2100 </span>            :   // fit XY
<span class="lineNum">    2101 </span><span class="lineNoCov">          0 :   if(!fitterY.Eval()){</span>
<span class="lineNum">    2102 </span><span class="lineNoCov">          0 :     AliDebug(1, &quot;Fit Y failed.&quot;);</span>
<span class="lineNum">    2103 </span><span class="lineNoCov">          0 :     SetErrorMsg(kFitFailedY);</span>
<span class="lineNum">    2104 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">    2105 </span>            :   }
<span class="lineNum">    2106 </span><span class="lineNoCov">          0 :   fYfit[0] = fitterY.GetFunctionParameter(0);</span>
<span class="lineNum">    2107 </span><span class="lineNoCov">          0 :   fYfit[1] = -fitterY.GetFunctionParameter(1);</span>
<span class="lineNum">    2108 </span>            :   // store covariance
<span class="lineNum">    2109 </span><span class="lineNoCov">          0 :   Double_t p[3];</span>
<span class="lineNum">    2110 </span><span class="lineNoCov">          0 :   fitterY.GetCovarianceMatrix(p);</span>
<span class="lineNum">    2111 </span><span class="lineNoCov">          0 :   fCov[0] = kScalePulls*p[1]; // variance of y0</span>
<span class="lineNum">    2112 </span><span class="lineNoCov">          0 :   fCov[1] = kScalePulls*p[2]; // covariance of y0, dydx</span>
<span class="lineNum">    2113 </span><span class="lineNoCov">          0 :   fCov[2] = kScalePulls*p[0]; // variance of dydx</span>
<span class="lineNum">    2114 </span>            :   // the ref radial position is set at the minimum of 
<span class="lineNum">    2115 </span>            :   // the y variance of the tracklet
<span class="lineNum">    2116 </span><span class="lineNoCov">          0 :   fX   = -fCov[1]/fCov[2];</span>
<span class="lineNum">    2117 </span><span class="lineNoCov">          0 :   fS2Y = fCov[0] +2.*fX*fCov[1] + fX*fX*fCov[2];</span>
<span class="lineNum">    2118 </span>            : 
<span class="lineNum">    2119 </span><span class="lineNoCov">          0 :   Float_t xs=fX+.5*AliTRDgeometry::CamHght();</span>
<span class="lineNum">    2120 </span><span class="lineNoCov">          0 :   if(xs &lt; 0. || xs &gt; AliTRDgeometry::CamHght()+AliTRDgeometry::CdrHght()){</span>
<span class="lineNum">    2121 </span><span class="lineNoCov">          0 :     AliDebug(1, Form(&quot;Ref radial position ouside chamber x[%5.2f].&quot;, fX));</span>
<span class="lineNum">    2122 </span><span class="lineNoCov">          0 :     SetErrorMsg(kFitFailedY);</span>
<span class="lineNum">    2123 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">    2124 </span>            :   }
<span class="lineNum">    2125 </span>            : 
<span class="lineNum">    2126 </span>            : /*    // THE LEADING CLUSTER METHOD for z fit
<span class="lineNum">    2127 </span>            :     Float_t xMin = fX0;
<span class="lineNum">    2128 </span>            :     Int_t ic=n=kNclusters-1; jc = &amp;fClusters[ic];
<span class="lineNum">    2129 </span>            :     AliTRDcluster *c0 =0x0, **kc = &amp;fClusters[kNtb-1];
<span class="lineNum">    2130 </span>            :     for(; ic&gt;kNtb; ic--, --jc, --kc){
<span class="lineNum">    2131 </span>            :       if((c0 = (*kc)) &amp;&amp; c0-&gt;IsInChamber() &amp;&amp; (xMin&gt;c0-&gt;GetX())) xMin = c0-&gt;GetX();
<span class="lineNum">    2132 </span>            :       if(!(c = (*jc))) continue;
<span class="lineNum">    2133 </span>            :       if(!c-&gt;IsInChamber()) continue;
<span class="lineNum">    2134 </span>            :       zc[kNclusters-1] = c-&gt;GetZ(); 
<span class="lineNum">    2135 </span>            :       fX = fX0 - c-&gt;GetX();
<span class="lineNum">    2136 </span>            :     }
<span class="lineNum">    2137 </span>            :     fZfit[0] = .5*(zc[0]+zc[kNclusters-1]); fZfit[1] = 0.;
<span class="lineNum">    2138 </span>            :     // Error parameterization
<span class="lineNum">    2139 </span>            :     fS2Z     = fdX*fZref[1];
<span class="lineNum">    2140 </span>            :     fS2Z    *= fS2Z; fS2Z    *= 0.2887; //  1/sqrt(12)*/
<span class="lineNum">    2141 </span>            : 
<span class="lineNum">    2142 </span>            :   // fit QZ
<span class="lineNum">    2143 </span><span class="lineNoCov">          0 :   if(opt!=1 &amp;&amp; IsRowCross()){</span>
<span class="lineNum">    2144 </span><span class="lineNoCov">          0 :     if(!fitterZ.Eval()) SetErrorMsg(kFitFailedZ);</span>
<span class="lineNum">    2145 </span><span class="lineNoCov">          0 :     if(!HasError(kFitFailedZ) &amp;&amp; TMath::Abs(fitterZ.GetFunctionParameter(1))&gt;1.e-10){ </span>
<span class="lineNum">    2146 </span>            :       // TODO - one has to recalculate xy fit based on
<span class="lineNum">    2147 </span>            :       // better knowledge of z position
<span class="lineNum">    2148 </span>            : //       Double_t x = -fitterZ.GetFunctionParameter(0)/fitterZ.GetFunctionParameter(1);
<span class="lineNum">    2149 </span>            : //       Double_t z0 = .5*(zc[0]+zc[n-1]);
<span class="lineNum">    2150 </span>            : //       fZfit[0] = z0 + fZfit[1]*x; 
<span class="lineNum">    2151 </span>            : //       fZfit[1] = fZfit[0]/fX0; 
<span class="lineNum">    2152 </span>            : //       redo fit on xy plane
<span class="lineNum">    2153 </span>            :     }
<span class="lineNum">    2154 </span>            :     // temporary external error parameterization
<span class="lineNum">    2155 </span><span class="lineNoCov">          0 :     fS2Z     = 0.05+0.4*TMath::Abs(fZref[1]); fS2Z *= fS2Z;</span>
<span class="lineNum">    2156 </span>            :     // TODO correct formula
<span class="lineNum">    2157 </span>            :     //fS2Z     = sigma_x*TMath::Abs(fZref[1]);
<span class="lineNum">    2158 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">    2159 </span>            :     //fZfit[0] = zc[0] + dzdx*0.5*AliTRDgeometry::CdrHght();
<span class="lineNum">    2160 </span><span class="lineNoCov">          0 :     fS2Z     = GetPadLength()*GetPadLength()/12.;</span>
<span class="lineNum">    2161 </span>            :   }
<span class="lineNum">    2162 </span><span class="lineNoCov">          0 :   return kTRUE;</span>
<span class="lineNum">    2163 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2164 </span>            : 
<a name="2165"><span class="lineNum">    2165 </span>            : </a>
<span class="lineNum">    2166 </span>            : //____________________________________________________________________
<span class="lineNum">    2167 </span>            : Bool_t AliTRDseedV1::FitRobust(AliTRDpadPlane *pp, TGeoHMatrix *mDet, Float_t bz, Int_t chg, Int_t opt, Float_t tgl)
<span class="lineNum">    2168 </span>            : {
<span class="lineNum">    2169 </span>            : //
<span class="lineNum">    2170 </span>            : // Linear fit of the clusters attached to the tracklet
<span class="lineNum">    2171 </span>            : //   The fit is performed in local chamber coordinates (27.11.2013) to take into account correctly the misalignment
<span class="lineNum">    2172 </span>            : //   Also the pad row cross is checked here and some background is removed
<span class="lineNum">    2173 </span>            : //
<span class="lineNum">    2174 </span>            : // Author 
<span class="lineNum">    2175 </span>            : // A.Bercuci &lt;A.Bercuci@gsi.de&gt;
<span class="lineNum">    2176 </span>            : 
<span class="lineNum">    2177 </span>            :   TTreeSRedirector *pstreamer(NULL);
<span class="lineNum">    2178 </span><span class="lineCov">        228 :   const AliTRDrecoParam* const recoParam = fkReconstructor-&gt;GetRecoParam();   </span>
<span class="lineNum">    2179 </span><span class="lineCov">        456 :   if( (recoParam-&gt;GetStreamLevel(AliTRDrecoParam::kTracker) &gt; 3 &amp;&amp; fkReconstructor-&gt;IsDebugStreaming()) ||</span>
<span class="lineNum">    2180 </span><span class="lineCov">        228 :     AliTRDReconstructor::GetStreamLevel()&gt;3 ) pstreamer = fkReconstructor-&gt;GetDebugStream(AliTRDrecoParam::kTracker);</span>
<span class="lineNum">    2181 </span>            : 
<span class="lineNum">    2182 </span>            :   // factor to scale y pulls.
<span class="lineNum">    2183 </span>            :   // ideally if error parametrization correct this is 1.
<span class="lineNum">    2184 </span>            :   //Float_t lyScaler = 1./(AliTRDgeometry::GetLayer(fDet)+1.);
<span class="lineNum">    2185 </span>            :   Float_t kScalePulls = 1.; 
<span class="lineNum">    2186 </span><span class="lineCov">        228 :   AliTRDcalibDB *calibration = AliTRDcalibDB::Instance();</span>
<span class="lineNum">    2187 </span><span class="lineCov">        228 :   if(!calibration){ </span>
<span class="lineNum">    2188 </span><span class="lineNoCov">          0 :     AliWarning(&quot;No access to calibration data&quot;);</span>
<span class="lineNum">    2189 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">    2190 </span>            :     // Retrieve the CDB container class with the parametric likelihood
<span class="lineNum">    2191 </span><span class="lineCov">        228 :     const AliTRDCalTrkAttach *attach = calibration-&gt;GetAttachObject();</span>
<span class="lineNum">    2192 </span><span class="lineCov">        228 :     if(!attach){ </span>
<span class="lineNum">    2193 </span><span class="lineNoCov">          0 :       AliWarning(&quot;No usable AttachClusters calib object.&quot;);</span>
<span class="lineNum">    2194 </span><span class="lineNoCov">          0 :     } else { </span>
<span class="lineNum">    2195 </span>            :       //kScalePulls = attach-&gt;GetScaleCov();//*lyScaler;
<span class="lineNum">    2196 </span>            :     }
<span class="lineNum">    2197 </span>            :     // Retrieve chamber status
<span class="lineNum">    2198 </span><span class="lineCov">        228 :     SetChmbGood(calibration-&gt;IsChamberGood(fDet));</span>
<span class="lineNum">    2199 </span><span class="lineCov">        228 :     if(!IsChmbGood()) kScalePulls*=10.;</span>
<span class="lineNum">    2200 </span>            :   }  
<span class="lineNum">    2201 </span><span class="lineCov">        228 :   AliTRDCommonParam *cp = AliTRDCommonParam::Instance(); </span>
<span class="lineNum">    2202 </span><span class="lineCov">        684 :   Double_t freq(cp?cp-&gt;GetSamplingFrequency():10.);</span>
<span class="lineNum">    2203 </span>            :       
<span class="lineNum">    2204 </span>            :   // evaluate locally z and dzdx from TRD only information
<span class="lineNum">    2205 </span><span class="lineCov">        228 :   if(EstimatedCrossPoint(pp, bz)&lt;0.) return kFALSE;</span>
<span class="lineNum">    2206 </span>            :   
<span class="lineNum">    2207 </span>            :   //printf(&quot;D%03d RC[%c] dzdx[%f %f] opt[%d]\n&quot;, fDet, IsRowCross()?'y':'n', fZref[1], fZfit[1], opt);
<span class="lineNum">    2208 </span>            :   Double_t //xchmb = 0.5 * AliTRDgeometry::AmThick() + AliTRDgeometry::DrThick(),
<span class="lineNum">    2209 </span>            :            //zchmb = 0.5 * (pp-&gt;GetRow0() + pp-&gt;GetRowEnd()),
<span class="lineNum">    2210 </span><span class="lineCov">        228 :            z0(0.5 * (pp-&gt;GetRow0() + pp-&gt;GetRowEnd()) + fZfit[0]),  </span>
<span class="lineNum">    2211 </span><span class="lineCov">        228 :            DZ(pp-&gt;GetRow0() - pp-&gt;GetRowEnd() - pp-&gt;GetAnodeWireOffset() + fZfit[0]),</span>
<span class="lineNum">    2212 </span>            :            z, d(-1.);
<span class="lineNum">    2213 </span><span class="lineCov">        456 :   Double_t xc[kNclusters], yc[kNclusters], dz(0.), dzdx(0.), </span>
<span class="lineNum">    2214 </span>            :            s2dz(0.), s2dzdx(0.), sy[kNclusters],
<span class="lineNum">    2215 </span><span class="lineCov">        228 :            s2x((8.33e-2/freq/freq+1.56e-2)*fVD*fVD),  // error of 1tb + error of mean time (TRF)</span>
<span class="lineNum">    2216 </span><span class="lineCov">        456 :            t2(fPad[2]*fPad[2]), loc[3]={0.};</span>
<span class="lineNum">    2217 </span><span class="lineCov">        228 :   Int_t n(0),          // clusters used in fit </span>
<span class="lineNum">    2218 </span>            :         row[]={-1, -1};// pad row spanned by the tracklet
<span class="lineNum">    2219 </span><span class="lineCov">        228 :   Double_t ycorr(UnbiasY(IsRowCross(), bz)),</span>
<span class="lineNum">    2220 </span><span class="lineCov">        228 :            kS2Ycorr(recoParam-&gt;GetS2Ycorr(IsRowCross(), chg&gt;0));</span>
<span class="lineNum">    2221 </span>            :         
<span class="lineNum">    2222 </span><span class="lineCov">        228 :   AliTRDcluster *c(NULL), **jc = &amp;fClusters[0];</span>
<span class="lineNum">    2223 </span><span class="lineCov">      14592 :   for(Int_t ic=0; ic&lt;kNtb; ic++, ++jc) {</span>
<span class="lineNum">    2224 </span><span class="lineCov">       7068 :     if(!(c = (*jc))) continue;</span>
<span class="lineNum">    2225 </span><span class="lineCov">       4804 :     if(!c-&gt;IsInChamber()) continue;</span>
<span class="lineNum">    2226 </span><span class="lineCov">       4486 :     if(row[0]&lt;0){ </span>
<span class="lineNum">    2227 </span><span class="lineCov">        228 :       row[0] = c-&gt;GetPadRow();</span>
<span class="lineNum">    2228 </span><span class="lineCov">        228 :       z      = pp-&gt;GetRowPos(row[0]) - 0.5*pp-&gt;GetRowSize(row[0]);</span>
<span class="lineNum">    2229 </span><span class="lineCov">        228 :       switch(opt){ </span>
<span class="lineNum">    2230 </span>            :         case 0: // no dz correction (only for RC tracklet) and dzdx from chamber position assuming primary
<span class="lineNum">    2231 </span><span class="lineCov">        470 :           dzdx  = IsRowCross()?fZfit[1]:0.; </span>
<span class="lineNum">    2232 </span><span class="lineCov">        470 :           s2dzdx= IsRowCross()?GetS2DZDX(dzdx):0.;</span>
<span class="lineNum">    2233 </span><span class="lineCov">        470 :           dz    = IsRowCross()?(z - z0):0.;  </span>
<span class="lineNum">    2234 </span><span class="lineCov">        470 :           s2dz  = IsRowCross()?fS2Z:0.;</span>
<span class="lineNum">    2235 </span><span class="lineCov">        228 :           break;</span>
<span class="lineNum">    2236 </span>            :         case 1: // dz correction only for RC tracklet and dzdx from reference
<span class="lineNum">    2237 </span><span class="lineNoCov">          0 :           dzdx = fZref[1];</span>
<span class="lineNum">    2238 </span><span class="lineNoCov">          0 :           dz   = IsRowCross()?(z - z0):0.; </span>
<span class="lineNum">    2239 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2240 </span>            :         case 2: // full z correction (z0 &amp; dzdx from reference)
<span class="lineNum">    2241 </span><span class="lineNoCov">          0 :           dzdx = fZref[1];</span>
<span class="lineNum">    2242 </span><span class="lineNoCov">          0 :           dz   = c-&gt;GetZ()-fZref[0]; </span>
<span class="lineNum">    2243 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2244 </span>            :         default:
<span class="lineNum">    2245 </span><span class="lineNoCov">          0 :           AliError(Form(&quot;Wrong option fit %d !&quot;, opt));</span>
<span class="lineNum">    2246 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2247 </span>            :       }    
<span class="lineNum">    2248 </span>            :     }
<span class="lineNum">    2249 </span>            :     //Use local cluster coordinates 
<span class="lineNum">    2250 </span>            :     //A.Bercuci 27.11.13/30.06.14
<span class="lineNum">    2251 </span><span class="lineCov">       4486 :     Double_t trk[] = {c-&gt;GetX(), c-&gt;GetY(), c-&gt;GetZ()};</span>
<span class="lineNum">    2252 </span><span class="lineCov">       4486 :     mDet-&gt;MasterToLocal(trk, loc);</span>
<span class="lineNum">    2253 </span><span class="lineCov">       4486 :     xc[n] = AliTRDgeometry::AnodePos()-loc[0]; //c-&gt;GetXloc(fT0, fVD); // c-&gt;GetX();</span>
<span class="lineNum">    2254 </span><span class="lineCov">       4486 :     yc[n] = loc[1]; //c-&gt;GetYloc(pp-&gt;GetColPos(col) + .5*cs, fS2PRF, cs) - xc[n]*fExB; //c-&gt;GetY();</span>
<span class="lineNum">    2255 </span><span class="lineCov">       4486 :     yc[n]-= fPad[2]*(dz+xc[n]*dzdx);</span>
<span class="lineNum">    2256 </span><span class="lineCov">       4486 :     yc[n]-= ycorr;</span>
<span class="lineNum">    2257 </span><span class="lineCov">       4486 :     if(IsRowCross()){ // estimate closest distance to anode wire</span>
<span class="lineNum">    2258 </span><span class="lineCov">        166 :       d = DZ-xc[n]*dzdx;</span>
<span class="lineNum">    2259 </span><span class="lineCov">        166 :       d -= ((Int_t)(2 * d)) / 2.0;</span>
<span class="lineNum">    2260 </span><span class="lineCov">        244 :       if (d &gt; 0.25) d  = 0.5 - d;</span>
<span class="lineNum">    2261 </span>            :     }
<span class="lineNum">    2262 </span>            :     // recalculate cluster error from knowledge of the track inclination in the bending plane 
<span class="lineNum">    2263 </span>            :     // and eventually distance to anode wire
<span class="lineNum">    2264 </span><span class="lineCov">       4486 :     c-&gt;SetSigmaY2(fS2PRF, fDiffT, fExB, xc[n], d, fYref[1]);</span>
<span class="lineNum">    2265 </span><span class="lineCov">       4486 :     s2x = c-&gt;GetSX(c-&gt;GetLocalTimeBin(), d); s2x*=s2x;</span>
<span class="lineNum">    2266 </span><span class="lineCov">      13458 :     sy[n] = c-&gt;GetSigmaY2()&gt;0?(TMath::Min(Double_t(c-&gt;GetSigmaY2()), 6.4e-3)):6.4e-3;</span>
<span class="lineNum">    2267 </span><span class="lineCov">       4486 :     sy[n]+= t2*(s2dz+xc[n]*xc[n]*s2dzdx+dzdx*dzdx*s2x);</span>
<span class="lineNum">    2268 </span><span class="lineCov">       4486 :     sy[n] = TMath::Sqrt(sy[n]);</span>
<span class="lineNum">    2269 </span><span class="lineCov">       4486 :     n++;</span>
<span class="lineNum">    2270 </span><span class="lineCov">       4486 :   }</span>
<span class="lineNum">    2271 </span><span class="lineCov">      14592 :   for(Int_t ic=kNtb; ic&lt;kNclusters; ic++, ++jc) {</span>
<span class="lineNum">    2272 </span><span class="lineCov">       7068 :     if(!(c = (*jc))) continue;</span>
<span class="lineNum">    2273 </span><span class="lineCov">        164 :     if(!c-&gt;IsInChamber()) continue;</span>
<span class="lineNum">    2274 </span><span class="lineCov">        156 :     if(row[1]&lt;0){ </span>
<span class="lineNum">    2275 </span><span class="lineCov">         14 :       row[1] = c-&gt;GetPadRow();</span>
<span class="lineNum">    2276 </span><span class="lineCov">         14 :       z      = pp-&gt;GetRowPos(row[1]) - 0.5*pp-&gt;GetRowSize(row[1]);</span>
<span class="lineNum">    2277 </span><span class="lineCov">         14 :       switch(opt){ </span>
<span class="lineNum">    2278 </span>            :         case 0: // no dz correction (only for RC tracklet) and dzdx from chamber position assuming primary
<span class="lineNum">    2279 </span>            :           //dzdx = fZfit[1];
<span class="lineNum">    2280 </span><span class="lineCov">         14 :           dz   = z - z0; </span>
<span class="lineNum">    2281 </span><span class="lineCov">         14 :           break;</span>
<span class="lineNum">    2282 </span>            :         case 1: // dz correction only for RC tracklet and dzdx from reference
<span class="lineNum">    2283 </span>            :           //dzdx = fZref[1];
<span class="lineNum">    2284 </span><span class="lineNoCov">          0 :           dz   = z - z0; </span>
<span class="lineNum">    2285 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2286 </span>            :         case 2: // full z correction (z0 &amp; dzdx from reference)
<span class="lineNum">    2287 </span>            :           //dzdx = fZref[1];
<span class="lineNum">    2288 </span><span class="lineNoCov">          0 :           dz   = c-&gt;GetZ()-fZref[0]; </span>
<span class="lineNum">    2289 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2290 </span>            :         default:
<span class="lineNum">    2291 </span><span class="lineNoCov">          0 :           AliError(Form(&quot;Wrong option fit %d !&quot;, opt));</span>
<span class="lineNum">    2292 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2293 </span>            :       }    
<span class="lineNum">    2294 </span>            :     }  
<span class="lineNum">    2295 </span>            : 
<span class="lineNum">    2296 </span>            :     //Use local cluster coordinates - the code should be identical with AliTRDtransform::Transform() !!!
<span class="lineNum">    2297 </span>            :     //A.Bercuci 27.11.13
<span class="lineNum">    2298 </span><span class="lineCov">        156 :     Double_t trk[] = {c-&gt;GetX(), c-&gt;GetY(), c-&gt;GetZ()};</span>
<span class="lineNum">    2299 </span><span class="lineCov">        156 :     mDet-&gt;MasterToLocal(trk, loc);</span>
<span class="lineNum">    2300 </span><span class="lineCov">        156 :     xc[n] = AliTRDgeometry::AnodePos()-loc[0]; //c-&gt;GetXloc(fT0, fVD); // c-&gt;GetX();</span>
<span class="lineNum">    2301 </span><span class="lineCov">        156 :     yc[n] = loc[1]; //c-&gt;GetYloc(pp-&gt;GetColPos(col) + .5*cs, fS2PRF, cs) - xc[n]*fExB; //c-&gt;GetY();</span>
<span class="lineNum">    2302 </span><span class="lineCov">        156 :     yc[n]-= fPad[2]*(dz+xc[n]*dzdx);</span>
<span class="lineNum">    2303 </span><span class="lineCov">        156 :     yc[n]-= ycorr;</span>
<span class="lineNum">    2304 </span>            : 
<span class="lineNum">    2305 </span><span class="lineCov">        156 :     d = DZ-xc[n]*dzdx;</span>
<span class="lineNum">    2306 </span><span class="lineCov">        156 :     d -= ((Int_t)(2 * d)) / 2.0;</span>
<span class="lineNum">    2307 </span><span class="lineCov">        262 :     if (d &gt; 0.25) d  = 0.5 - d;</span>
<span class="lineNum">    2308 </span><span class="lineCov">        156 :     c-&gt;SetSigmaY2(fS2PRF, fDiffT, fExB, xc[n], d, fYref[1]);</span>
<span class="lineNum">    2309 </span><span class="lineCov">        156 :     s2x = c-&gt;GetSX(c-&gt;GetLocalTimeBin(), d); s2x*=s2x;</span>
<span class="lineNum">    2310 </span><span class="lineCov">        468 :     sy[n] = c-&gt;GetSigmaY2()&gt;0?(TMath::Min(Double_t(c-&gt;GetSigmaY2()), 6.4e-3)):6.4e-3;</span>
<span class="lineNum">    2311 </span><span class="lineCov">        156 :     sy[n]+= t2*(s2dz+xc[n]*xc[n]*s2dzdx+dzdx*dzdx*s2x);</span>
<span class="lineNum">    2312 </span><span class="lineCov">        156 :     sy[n] = TMath::Sqrt(sy[n]);</span>
<span class="lineNum">    2313 </span><span class="lineCov">        156 :     n++;</span>
<span class="lineNum">    2314 </span><span class="lineCov">        156 :   }</span>
<span class="lineNum">    2315 </span>            : 
<span class="lineNum">    2316 </span><span class="lineCov">        228 :   UChar_t status(0);</span>
<span class="lineNum">    2317 </span>            :   // the ref radial position is set close to the minimum of 
<span class="lineNum">    2318 </span>            :   // the y variance of the tracklet
<span class="lineNum">    2319 </span><span class="lineCov">        228 :   fX   = 0.;//set reference to anode wire</span>
<span class="lineNum">    2320 </span><span class="lineCov">        228 :   Double_t par[3] = {0.,0.,fX}, cov[3];</span>
<span class="lineNum">    2321 </span><span class="lineCov">        228 :   if(!AliTRDtrackletOflHelper::Fit(n, xc, yc, sy, par, 1.5, cov)) { </span>
<span class="lineNum">    2322 </span><span class="lineNoCov">          0 :     AliDebug(1, Form(&quot;Tracklet fit failed D[%03d].&quot;, fDet));</span>
<span class="lineNum">    2323 </span><span class="lineNoCov">          0 :     SetErrorMsg(kFitCl);</span>
<span class="lineNum">    2324 </span><span class="lineNoCov">          0 :     return kFALSE; </span>
<span class="lineNum">    2325 </span>            :   }
<span class="lineNum">    2326 </span><span class="lineCov">        228 :   fYfit[0] = par[0] - fX * par[1];</span>
<span class="lineNum">    2327 </span><span class="lineCov">        228 :   fYfit[1] = -par[1];</span>
<span class="lineNum">    2328 </span>            :   //printf(&quot; yfit: %f [%f] x[%e] dydx[%f]\n&quot;, fYfit[0], par[0], fX, par[1]);
<span class="lineNum">    2329 </span>            :   // store covariance
<span class="lineNum">    2330 </span><span class="lineCov">        228 :   fCov[0] = kScalePulls*kS2Ycorr*cov[0]; // variance of y0</span>
<span class="lineNum">    2331 </span><span class="lineCov">        228 :   fCov[1] = kScalePulls*cov[2]; // covariance of y0, dydx</span>
<span class="lineNum">    2332 </span><span class="lineCov">        228 :   fCov[2] = kScalePulls*cov[1]; // variance of dydx</span>
<span class="lineNum">    2333 </span>            :   // check radial position
<span class="lineNum">    2334 </span><span class="lineCov">        228 :   Float_t xs=fX+.5*AliTRDgeometry::CamHght();</span>
<span class="lineNum">    2335 </span><span class="lineCov">        456 :   if(xs &lt; 0. || xs &gt; AliTRDgeometry::CamHght()+AliTRDgeometry::CdrHght()){</span>
<span class="lineNum">    2336 </span><span class="lineNoCov">          0 :     AliDebug(1, Form(&quot;Ref radial position x[%5.2f] ouside D[%3d].&quot;, fX, fDet));</span>
<span class="lineNum">    2337 </span><span class="lineNoCov">          0 :     SetErrorMsg(kFitFailedY);</span>
<span class="lineNum">    2338 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">    2339 </span>            :   }
<span class="lineNum">    2340 </span><span class="lineCov">        228 :   if(!IsRowCross()){ </span>
<span class="lineNum">    2341 </span>            :     //    Double_t padEffLength(fPad[0] - TMath::Abs(dzdx));
<span class="lineNum">    2342 </span><span class="lineCov">        214 :     Double_t padEffLength(fPad[0]);</span>
<span class="lineNum">    2343 </span>            :     //
<span class="lineNum">    2344 </span>            :     // correct Z for most probable value accounting for the fact that it is not RC
<span class="lineNum">    2345 </span><span class="lineCov">        214 :     double zCorrNRC = tgl*recoParam-&gt;GetZCorrCoefNRC();</span>
<span class="lineNum">    2346 </span><span class="lineCov">        214 :     padEffLength -= TMath::Abs(zCorrNRC*2);</span>
<span class="lineNum">    2347 </span><span class="lineCov">        214 :     fZfit[0] += zCorrNRC;</span>
<span class="lineNum">    2348 </span><span class="lineCov">        214 :     fYfit[0] += GetTilt()*zCorrNRC;</span>
<span class="lineNum">    2349 </span><span class="lineCov">        214 :     fS2Z = padEffLength*padEffLength/12.;</span>
<span class="lineNum">    2350 </span><span class="lineCov">        214 :   }</span>
<span class="lineNum">    2351 </span><span class="lineCov">        684 :   AliDebug(2, Form(&quot;[I]  x[cm]=%6.2f y[cm]=%+5.2f z[cm]=%+6.2f dydx[deg]=%+5.2f&quot;, GetX(), GetY(), GetZ(), TMath::ATan(fYfit[1])*TMath::RadToDeg()));</span>
<span class="lineNum">    2352 </span>            :   
<span class="lineNum">    2353 </span><span class="lineCov">        228 :   if(pstreamer){</span>
<span class="lineNum">    2354 </span><span class="lineNoCov">          0 :     Float_t x= fX0 -fX,</span>
<span class="lineNum">    2355 </span><span class="lineNoCov">          0 :             y = GetY(),</span>
<span class="lineNum">    2356 </span><span class="lineNoCov">          0 :             yt = fYref[0]-fX*fYref[1];</span>
<span class="lineNum">    2357 </span><span class="lineNoCov">          0 :     SETBIT(status, 2);</span>
<span class="lineNum">    2358 </span><span class="lineNoCov">          0 :     TVectorD vcov(3); vcov[0]=cov[0];vcov[1]=cov[1];vcov[2]=cov[2];</span>
<span class="lineNum">    2359 </span><span class="lineNoCov">          0 :     Double_t sm(0.), chi2(0.), tmp, dy[kNclusters];</span>
<span class="lineNum">    2360 </span><span class="lineNoCov">          0 :     for(Int_t ic(0); ic&lt;n; ic++){</span>
<span class="lineNum">    2361 </span><span class="lineNoCov">          0 :       sm   += sy[ic];</span>
<span class="lineNum">    2362 </span><span class="lineNoCov">          0 :       dy[ic] = yc[ic]-(fYfit[0]+(xc[ic]-fX0)*fYfit[1]); tmp = dy[ic]/sy[ic];</span>
<span class="lineNum">    2363 </span><span class="lineNoCov">          0 :       chi2 += tmp*tmp;</span>
<span class="lineNum">    2364 </span>            :     }
<span class="lineNum">    2365 </span><span class="lineNoCov">          0 :     sm /= n; chi2 = TMath::Sqrt(chi2);</span>
<span class="lineNum">    2366 </span><span class="lineNoCov">          0 :     Double_t m(0.), s(0.);</span>
<span class="lineNum">    2367 </span><span class="lineNoCov">          0 :     AliMathBase::EvaluateUni(n, dy, m, s, 0);</span>
<span class="lineNum">    2368 </span><span class="lineNoCov">          0 :     (*pstreamer) &lt;&lt; &quot;FitRobust4&quot;</span>
<span class="lineNum">    2369 </span><span class="lineNoCov">          0 :       &lt;&lt; &quot;stat=&quot; &lt;&lt; status</span>
<span class="lineNum">    2370 </span><span class="lineNoCov">          0 :       &lt;&lt; &quot;opt=&quot;  &lt;&lt; opt</span>
<span class="lineNum">    2371 </span><span class="lineNoCov">          0 :       &lt;&lt; &quot;ncl=&quot;  &lt;&lt; n</span>
<span class="lineNum">    2372 </span><span class="lineNoCov">          0 :       &lt;&lt; &quot;det=&quot;  &lt;&lt; fDet</span>
<span class="lineNum">    2373 </span><span class="lineNoCov">          0 :       &lt;&lt; &quot;x0=&quot;   &lt;&lt; fX0</span>
<span class="lineNum">    2374 </span><span class="lineNoCov">          0 :       &lt;&lt; &quot;y0=&quot;   &lt;&lt; fYfit[0]</span>
<span class="lineNum">    2375 </span><span class="lineNoCov">          0 :       &lt;&lt; &quot;x=&quot;    &lt;&lt; x</span>
<span class="lineNum">    2376 </span><span class="lineNoCov">          0 :       &lt;&lt; &quot;y=&quot;    &lt;&lt; y</span>
<span class="lineNum">    2377 </span><span class="lineNoCov">          0 :       &lt;&lt; &quot;dydx=&quot; &lt;&lt; fYfit[1]</span>
<span class="lineNum">    2378 </span><span class="lineNoCov">          0 :       &lt;&lt; &quot;pt=&quot;   &lt;&lt; fPt</span>
<span class="lineNum">    2379 </span><span class="lineNoCov">          0 :       &lt;&lt; &quot;yt=&quot;   &lt;&lt; yt</span>
<span class="lineNum">    2380 </span><span class="lineNoCov">          0 :       &lt;&lt; &quot;dydxt=&quot;&lt;&lt; fYref[1]</span>
<span class="lineNum">    2381 </span><span class="lineNoCov">          0 :       &lt;&lt; &quot;cov=&quot;  &lt;&lt; &amp;vcov</span>
<span class="lineNum">    2382 </span><span class="lineNoCov">          0 :       &lt;&lt; &quot;chi2=&quot; &lt;&lt; chi2</span>
<span class="lineNum">    2383 </span><span class="lineNoCov">          0 :       &lt;&lt; &quot;sm=&quot;   &lt;&lt; sm</span>
<span class="lineNum">    2384 </span><span class="lineNoCov">          0 :       &lt;&lt; &quot;ss=&quot;   &lt;&lt; s</span>
<span class="lineNum">    2385 </span><span class="lineNoCov">          0 :       &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">    2386 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2387 </span><span class="lineCov">        228 :   return kTRUE;</span>
<span class="lineNum">    2388 </span><span class="lineCov">        456 : }</span>
<a name="2389"><span class="lineNum">    2389 </span>            : </a>
<span class="lineNum">    2390 </span>            : //___________________________________________________________________
<span class="lineNum">    2391 </span>            : void AliTRDseedV1::SetXYZ(TGeoHMatrix *mDet)
<span class="lineNum">    2392 </span>            : {
<span class="lineNum">    2393 </span>            : // Apply alignment to the local position of tracklet
<span class="lineNum">    2394 </span>            : // A.Bercuci @ 27.11.2013
<span class="lineNum">    2395 </span>            : 
<span class="lineNum">    2396 </span><span class="lineCov">        456 :   Double_t loc[] = {AliTRDgeometry::AnodePos(), GetLocalY(), fZfit[0]}, trk[3]={0.};</span>
<span class="lineNum">    2397 </span><span class="lineCov">        228 :   mDet-&gt;LocalToMaster(loc, trk);</span>
<span class="lineNum">    2398 </span><span class="lineCov">        228 :   fX0 = trk[0];</span>
<span class="lineNum">    2399 </span><span class="lineCov">        228 :   fY  = trk[1];</span>
<span class="lineNum">    2400 </span><span class="lineCov">        228 :   fZ  = trk[2];</span>
<span class="lineNum">    2401 </span>            :   return;
<span class="lineNum">    2402 </span>            : //   if(!IsRowCross()){/*fZfit[1] *= 1.09;*/ return;}
<span class="lineNum">    2403 </span>            : //   // recalculate local z coordinate assuming primary track for row cross tracklets
<span class="lineNum">    2404 </span>            : //   Double_t zoff(fZ-fZfit[0]); // no alignment aware !
<span class="lineNum">    2405 </span>            : //   //printf(&quot;SetXYZ : zoff[%f] zpp[%f]\n&quot;, zoff, zpp);
<span class="lineNum">    2406 </span>            : //   fZfit[0] = fX0*fZfit[1] - zoff; 
<span class="lineNum">    2407 </span>            : //   // recalculate tracking coordinates based on the new z coordinate
<span class="lineNum">    2408 </span>            : //   loc[2] = fZfit[0];
<span class="lineNum">    2409 </span>            : //   mDet-&gt;LocalToMaster(loc, trk);
<span class="lineNum">    2410 </span>            : //   fX0 = trk[0];
<span class="lineNum">    2411 </span>            : //   fY  = trk[1];
<span class="lineNum">    2412 </span>            : //   fZ  = trk[2];//-zcorr[stk];
<span class="lineNum">    2413 </span>            :   //fZfit[1] = /*(IsRowCross()?1.05:1.09)**/fZ/(fX0-fS2Y);
<span class="lineNum">    2414 </span><span class="lineCov">        228 : }</span>
<span class="lineNum">    2415 </span>            : 
<a name="2416"><span class="lineNum">    2416 </span>            : </a>
<span class="lineNum">    2417 </span>            : //___________________________________________________________________
<span class="lineNum">    2418 </span>            : void AliTRDseedV1::Print(Option_t *o) const
<span class="lineNum">    2419 </span>            : {
<span class="lineNum">    2420 </span>            :   //
<span class="lineNum">    2421 </span>            :   // Printing the seedstatus
<span class="lineNum">    2422 </span>            :   //
<span class="lineNum">    2423 </span>            : 
<span class="lineNum">    2424 </span><span class="lineNoCov">          0 :   AliInfo(Form(&quot;Det[%3d] X0[%7.2f] Pad{L[%5.2f] W[%5.2f] Tilt[%+6.2f]}&quot;, fDet, fX0, GetPadLength(), GetPadWidth(), GetTilt()));</span>
<span class="lineNum">    2425 </span><span class="lineNoCov">          0 :   AliInfo(Form(&quot;N[%2d] Nused[%2d] Nshared[%2d] [%d]&quot;, GetN(), GetNUsed(), GetNShared(), fN));</span>
<span class="lineNum">    2426 </span><span class="lineNoCov">          0 :   AliInfo(Form(&quot;FLAGS : RC[%c] Kink[%c] SA[%c]&quot;, IsRowCross()?'y':'n', IsKink()?'y':'n', IsStandAlone()?'y':'n'));</span>
<span class="lineNum">    2427 </span><span class="lineNoCov">          0 :   AliInfo(Form(&quot;CALIB PARAMS :  T0[%5.2f]  Vd[%5.2f]  s2PRF[%5.2f]  ExB[%5.2f]  Dl[%5.2f]  Dt[%5.2f]&quot;, fT0, fVD, fS2PRF, fExB, fDiffL, fDiffT));</span>
<span class="lineNum">    2428 </span>            : 
<span class="lineNum">    2429 </span><span class="lineNoCov">          0 :   Double_t cov[3], x=GetX();</span>
<span class="lineNum">    2430 </span><span class="lineNoCov">          0 :   GetCovAt(x, cov);</span>
<span class="lineNum">    2431 </span><span class="lineNoCov">          0 :   AliInfo(&quot;    |  x[cm]  |      y[cm]       |      z[cm]      |  dydx |  dzdx |&quot;);</span>
<span class="lineNum">    2432 </span><span class="lineNoCov">          0 :   AliInfo(Form(&quot;Fit | %7.2f | %7.2f+-%7.2f | %7.2f+-%7.2f| %5.2f | ----- |&quot;, x, GetY(), TMath::Sqrt(cov[0]), GetZ(), TMath::Sqrt(cov[2]), fYfit[1]));</span>
<span class="lineNum">    2433 </span><span class="lineNoCov">          0 :   AliInfo(Form(&quot;Ref | %7.2f | %7.2f+-%7.2f | %7.2f+-%7.2f| %5.2f | %5.2f |&quot;, x, fYref[0]-fX*fYref[1], TMath::Sqrt(fRefCov[0]), fZref[0]-fX*fYref[1], TMath::Sqrt(fRefCov[2]), fYref[1], fZref[1]));</span>
<span class="lineNum">    2434 </span><span class="lineNoCov">          0 :   AliInfo(Form(&quot;P / Pt [GeV/c] = %f / %f&quot;, GetMomentum(), fPt));</span>
<span class="lineNum">    2435 </span><span class="lineNoCov">          0 :   if(IsStandAlone()) AliInfo(Form(&quot;C Rieman / Vertex [1/cm] = %f / %f&quot;, fC[0], fC[1]));</span>
<span class="lineNum">    2436 </span><span class="lineNoCov">          0 :   AliInfo(Form(&quot;dEdx [a.u.]    = %f / %f / %f / %f / %f/ %f / %f / %f&quot;, fdEdx[0], fdEdx[1], fdEdx[2], fdEdx[3], fdEdx[4], fdEdx[5], fdEdx[6], fdEdx[7]));</span>
<span class="lineNum">    2437 </span><span class="lineNoCov">          0 :   AliInfo(Form(&quot;PID            = %5.3f / %5.3f / %5.3f / %5.3f / %5.3f&quot;, fProb[0], fProb[1], fProb[2], fProb[3], fProb[4]));</span>
<span class="lineNum">    2438 </span>            : 
<span class="lineNum">    2439 </span><span class="lineNoCov">          0 :   if(strcmp(o, &quot;a&quot;)!=0) return;</span>
<span class="lineNum">    2440 </span>            : 
<span class="lineNum">    2441 </span><span class="lineNoCov">          0 :   AliTRDcluster* const* jc = &amp;fClusters[0];</span>
<span class="lineNum">    2442 </span><span class="lineNoCov">          0 :   for(int ic=0; ic&lt;kNclusters; ic++, jc++) {</span>
<span class="lineNum">    2443 </span><span class="lineNoCov">          0 :     if(!(*jc)) continue;</span>
<span class="lineNum">    2444 </span><span class="lineNoCov">          0 :     (*jc)-&gt;Print(o);</span>
<span class="lineNum">    2445 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2446 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2447 </span>            : 
<a name="2448"><span class="lineNum">    2448 </span>            : </a>
<span class="lineNum">    2449 </span>            : //___________________________________________________________________
<span class="lineNum">    2450 </span>            : Bool_t AliTRDseedV1::IsEqual(const TObject *o) const
<span class="lineNum">    2451 </span>            : {
<span class="lineNum">    2452 </span>            :   // Checks if current instance of the class has the same essential members
<span class="lineNum">    2453 </span>            :   // as the given one
<span class="lineNum">    2454 </span>            : 
<span class="lineNum">    2455 </span><span class="lineNoCov">          0 :   if(!o) return kFALSE;</span>
<span class="lineNum">    2456 </span><span class="lineNoCov">          0 :   const AliTRDseedV1 *inTracklet = dynamic_cast&lt;const AliTRDseedV1*&gt;(o);</span>
<span class="lineNum">    2457 </span><span class="lineNoCov">          0 :   if(!inTracklet) return kFALSE;</span>
<span class="lineNum">    2458 </span>            : 
<span class="lineNum">    2459 </span><span class="lineNoCov">          0 :   for (Int_t i = 0; i &lt; 2; i++){</span>
<span class="lineNum">    2460 </span><span class="lineNoCov">          0 :     if ( fYref[i] != inTracklet-&gt;fYref[i] ) return kFALSE;</span>
<span class="lineNum">    2461 </span><span class="lineNoCov">          0 :     if ( fZref[i] != inTracklet-&gt;fZref[i] ) return kFALSE;</span>
<span class="lineNum">    2462 </span>            :   }
<span class="lineNum">    2463 </span>            :   
<span class="lineNum">    2464 </span><span class="lineNoCov">          0 :   if ( TMath::Abs(fS2Y - inTracklet-&gt;fS2Y)&gt;1.e-10 ) return kFALSE;</span>
<span class="lineNum">    2465 </span><span class="lineNoCov">          0 :   if ( TMath::Abs(GetTilt() - inTracklet-&gt;GetTilt())&gt;1.e-10 ) return kFALSE;</span>
<span class="lineNum">    2466 </span><span class="lineNoCov">          0 :   if ( TMath::Abs(GetPadLength() - inTracklet-&gt;GetPadLength())&gt;1.e-10 ) return kFALSE;</span>
<span class="lineNum">    2467 </span>            :   
<span class="lineNum">    2468 </span><span class="lineNoCov">          0 :   for (Int_t i = 0; i &lt; kNclusters; i++){</span>
<span class="lineNum">    2469 </span>            : //     if ( fX[i] != inTracklet-&gt;GetX(i) ) return kFALSE;
<span class="lineNum">    2470 </span>            : //     if ( fY[i] != inTracklet-&gt;GetY(i) ) return kFALSE;
<span class="lineNum">    2471 </span>            : //     if ( fZ[i] != inTracklet-&gt;GetZ(i) ) return kFALSE;
<span class="lineNum">    2472 </span><span class="lineNoCov">          0 :     if ( fIndexes[i] != inTracklet-&gt;fIndexes[i] ) return kFALSE;</span>
<span class="lineNum">    2473 </span>            :   }
<span class="lineNum">    2474 </span>            : //   if ( fUsable != inTracklet-&gt;fUsable ) return kFALSE;
<span class="lineNum">    2475 </span>            : 
<span class="lineNum">    2476 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i &lt; 2; i++){</span>
<span class="lineNum">    2477 </span><span class="lineNoCov">          0 :     if ( fYfit[i] != inTracklet-&gt;fYfit[i] ) return kFALSE;</span>
<span class="lineNum">    2478 </span><span class="lineNoCov">          0 :     if ( fZfit[i] != inTracklet-&gt;fZfit[i] ) return kFALSE;</span>
<span class="lineNum">    2479 </span><span class="lineNoCov">          0 :     if ( fLabels[i] != inTracklet-&gt;fLabels[i] ) return kFALSE;</span>
<span class="lineNum">    2480 </span>            :   }
<span class="lineNum">    2481 </span>            :   
<span class="lineNum">    2482 </span>            : /*  if ( fMeanz != inTracklet-&gt;GetMeanz() ) return kFALSE;
<span class="lineNum">    2483 </span>            :   if ( fZProb != inTracklet-&gt;GetZProb() ) return kFALSE;*/
<span class="lineNum">    2484 </span><span class="lineNoCov">          0 :   if ( fN != inTracklet-&gt;fN ) return kFALSE;</span>
<span class="lineNum">    2485 </span>            :   //if ( fNUsed != inTracklet-&gt;fNUsed ) return kFALSE;
<span class="lineNum">    2486 </span>            :   //if ( fFreq != inTracklet-&gt;GetFreq() ) return kFALSE;
<span class="lineNum">    2487 </span>            :   //if ( fNChange != inTracklet-&gt;GetNChange() ) return kFALSE;
<span class="lineNum">    2488 </span>            :    
<span class="lineNum">    2489 </span><span class="lineNoCov">          0 :   if ( TMath::Abs(fC[0] - inTracklet-&gt;fC[0])&gt;1.e-10 ) return kFALSE;</span>
<span class="lineNum">    2490 </span>            :   //if ( fCC != inTracklet-&gt;GetCC() ) return kFALSE;
<span class="lineNum">    2491 </span><span class="lineNoCov">          0 :   if ( TMath::Abs(fChi2 - inTracklet-&gt;fChi2)&gt;1.e-10 ) return kFALSE;</span>
<span class="lineNum">    2492 </span>            :   //  if ( fChi2Z != inTracklet-&gt;GetChi2Z() ) return kFALSE;
<span class="lineNum">    2493 </span>            : 
<span class="lineNum">    2494 </span><span class="lineNoCov">          0 :   if ( fDet != inTracklet-&gt;fDet ) return kFALSE;</span>
<span class="lineNum">    2495 </span><span class="lineNoCov">          0 :   if ( TMath::Abs(fPt - inTracklet-&gt;fPt)&gt;1.e-10 ) return kFALSE;</span>
<span class="lineNum">    2496 </span><span class="lineNoCov">          0 :   if ( TMath::Abs(fdX - inTracklet-&gt;fdX)&gt;1.e-10 ) return kFALSE;</span>
<span class="lineNum">    2497 </span>            :   
<span class="lineNum">    2498 </span><span class="lineNoCov">          0 :   for (Int_t iCluster = 0; iCluster &lt; kNclusters; iCluster++){</span>
<span class="lineNum">    2499 </span><span class="lineNoCov">          0 :     AliTRDcluster *curCluster = fClusters[iCluster];</span>
<span class="lineNum">    2500 </span><span class="lineNoCov">          0 :     AliTRDcluster *inCluster = inTracklet-&gt;fClusters[iCluster];</span>
<span class="lineNum">    2501 </span><span class="lineNoCov">          0 :     if (curCluster &amp;&amp; inCluster){</span>
<span class="lineNum">    2502 </span><span class="lineNoCov">          0 :       if (! curCluster-&gt;IsEqual(inCluster) ) {</span>
<span class="lineNum">    2503 </span><span class="lineNoCov">          0 :         curCluster-&gt;Print();</span>
<span class="lineNum">    2504 </span><span class="lineNoCov">          0 :         inCluster-&gt;Print();</span>
<span class="lineNum">    2505 </span><span class="lineNoCov">          0 :         return kFALSE;</span>
<span class="lineNum">    2506 </span>            :       }
<span class="lineNum">    2507 </span>            :     } else {
<span class="lineNum">    2508 </span>            :       // if one cluster exists, and corresponding 
<span class="lineNum">    2509 </span>            :       // in other tracklet doesn't - return kFALSE
<span class="lineNum">    2510 </span><span class="lineNoCov">          0 :       if(curCluster || inCluster) return kFALSE;</span>
<span class="lineNum">    2511 </span>            :     }
<span class="lineNum">    2512 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2513 </span><span class="lineNoCov">          0 :   return kTRUE;</span>
<span class="lineNum">    2514 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2515 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
