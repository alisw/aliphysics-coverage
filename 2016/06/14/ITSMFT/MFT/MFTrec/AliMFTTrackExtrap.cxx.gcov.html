<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - ITSMFT/MFT/MFTrec/AliMFTTrackExtrap.cxx</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">ITSMFT/MFT/MFTrec</a> - AliMFTTrackExtrap.cxx<span style="font-size: 80%;"> (source / <a href="AliMFTTrackExtrap.cxx.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntry">642</td>
            <td class="headerCovTableEntryLo">0.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntry">36</td>
            <td class="headerCovTableEntryLo">5.6 %</td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**************************************************************************</a>
<span class="lineNum">       2 </span>            :  * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
<span class="lineNum">       3 </span>            :  *                                                                        *
<span class="lineNum">       4 </span>            :  * Author: The ALICE Off-line Project.                                    *
<span class="lineNum">       5 </span>            :  * Contributors are mentioned in the code where appropriate.              *
<span class="lineNum">       6 </span>            :  *                                                                        *
<span class="lineNum">       7 </span>            :  * Permission to use, copy, modify and distribute this software and its   *
<span class="lineNum">       8 </span>            :  * documentation strictly for non-commercial purposes is hereby granted   *
<span class="lineNum">       9 </span>            :  * without fee, provided that the above copyright notice appears in all   *
<span class="lineNum">      10 </span>            :  * copies and that both the copyright notice and this permission notice   *
<span class="lineNum">      11 </span>            :  * appear in the supporting documentation. The authors make no claims     *
<span class="lineNum">      12 </span>            :  * about the suitability of this software for any purpose. It is          *
<span class="lineNum">      13 </span>            :  * provided &quot;as is&quot; without express or implied warranty.                  *
<span class="lineNum">      14 </span>            :  **************************************************************************/
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : /* $Id$ */
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : //-----------------------------------------------------------------------------
<span class="lineNum">      19 </span>            : // Class AliMFTTrackExtrap
<span class="lineNum">      20 </span>            : // ------------------------
<span class="lineNum">      21 </span>            : // Tools for track extrapolation in ALICE MFT
<span class="lineNum">      22 </span>            : // Adapted from AliMUONTrackExtrap by R. Tieulent
<span class="lineNum">      23 </span>            : // Original Author: Philippe Pillot
<span class="lineNum">      24 </span>            : //-----------------------------------------------------------------------------
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : #include &quot;AliMFTTrackExtrap.h&quot;  
<span class="lineNum">      27 </span>            : #include &quot;AliMFTTrackParam.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;AliMFTConstants.h&quot;
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : #include &quot;AliMagF.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;AliExternalTrackParam.h&quot;
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : #include &lt;TGeoGlobalMagField.h&gt;
<span class="lineNum">      34 </span>            : #include &lt;TGeoManager.h&gt;
<span class="lineNum">      35 </span>            : #include &lt;TMath.h&gt;
<span class="lineNum">      36 </span>            : #include &lt;TDatabasePDG.h&gt;
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : #include &lt;Riostream.h&gt;
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : using std::endl;
<a name="41"><span class="lineNum">      41 </span>            : using std::cout;</a>
<span class="lineNum">      42 </span>            : /// \cond CLASSIMP
<span class="lineNum">      43 </span><span class="lineCov">         12 : ClassImp(AliMFTTrackExtrap) // Class implementation in ROOT context</span>
<a name="44"><span class="lineNum">      44 </span>            : /// \endcond</a>
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span><span class="lineCov">         12 : const Double_t AliMFTTrackExtrap::fgkSimpleBPosition = 0.5 * (AliMFTConstants::DefaultPlaneZ(0) + AliMFTConstants::DefaultPlaneZ(9));</span>
<span class="lineNum">      47 </span>            : //const Double_t AliMFTTrackExtrap::fgkSimpleBLength = 0.5 * (AliMUONConstants::CoilL() + AliMUONConstants::YokeL());
<span class="lineNum">      48 </span>            :       Double_t AliMFTTrackExtrap::fgSimpleBValue = 0.;
<span class="lineNum">      49 </span>            :       Bool_t   AliMFTTrackExtrap::fgFieldON = kFALSE;
<span class="lineNum">      50 </span>            : const Bool_t   AliMFTTrackExtrap::fgkUseHelix = kTRUE;
<span class="lineNum">      51 </span>            : const Int_t    AliMFTTrackExtrap::fgkMaxStepNumber = 5000;
<span class="lineNum">      52 </span>            : const Double_t AliMFTTrackExtrap::fgkHelixStepLength = 0.1;
<span class="lineNum">      53 </span>            : const Double_t AliMFTTrackExtrap::fgkRungeKuttaMaxResidue = 0.002;
<a name="54"><span class="lineNum">      54 </span>            : </a>
<span class="lineNum">      55 </span>            : //__________________________________________________________________________
<span class="lineNum">      56 </span>            : void AliMFTTrackExtrap::SetField()
<span class="lineNum">      57 </span>            : {
<span class="lineNum">      58 </span>            :   /// set field on/off flag;  
<span class="lineNum">      59 </span>            :   /// set field at the centre of the MFT
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :   const Double_t x[3] = {0.,0.,fgkSimpleBPosition};</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :   Double_t b[3] = {0.,0.,0.};</span>
<span class="lineNum">      62 </span><span class="lineNoCov">          0 :   TGeoGlobalMagField::Instance()-&gt;Field(x,b);</span>
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :         cout&lt;&lt;Form(&quot;Field = %e %e %e&quot;,b[0],b[1],b[2])&lt;&lt;endl;</span>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :   fgSimpleBValue = b[2];</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :   fgFieldON = (TMath::Abs(fgSimpleBValue) &gt; 1.e-10) ? kTRUE : kFALSE;</span>
<span class="lineNum">      66 </span>            : //      fgFieldON = kFALSE;
<span class="lineNum">      67 </span><span class="lineNoCov">          0 : }</span>
<a name="68"><span class="lineNum">      68 </span>            : </a>
<span class="lineNum">      69 </span>            : //__________________________________________________________________________
<span class="lineNum">      70 </span>            : Double_t AliMFTTrackExtrap::GetImpactParamFromBendingMomentum(Double_t bendingMomentum)
<span class="lineNum">      71 </span>            : {
<span class="lineNum">      72 </span>            :   /// Returns impact parameter at vertex in bending plane (cm),
<span class="lineNum">      73 </span>            :   /// from the signed bending momentum &quot;BendingMomentum&quot; in bending plane (GeV/c),
<span class="lineNum">      74 </span>            :   /// using simple values for dipole magnetic field.
<span class="lineNum">      75 </span>            :   /// The sign of &quot;BendingMomentum&quot; is the sign of the charge.
<span class="lineNum">      76 </span>            :   
<span class="lineNum">      77 </span>            : //  if (bendingMomentum == 0.) return 1.e10;
<span class="lineNum">      78 </span>            : //  
<span class="lineNum">      79 </span>            : //  const Double_t kCorrectionFactor = 1.1; // impact parameter is 10% underestimated
<span class="lineNum">      80 </span>            : //  
<span class="lineNum">      81 </span>            : //  return kCorrectionFactor * (-0.0003 * fgSimpleBValue * fgkSimpleBLength * fgkSimpleBPosition / bendingMomentum);
<span class="lineNum">      82 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      83 </span>            : 
<a name="84"><span class="lineNum">      84 </span>            : //__________________________________________________________________________</a>
<span class="lineNum">      85 </span>            : Double_t 
<span class="lineNum">      86 </span>            : AliMFTTrackExtrap::GetBendingMomentumFromImpactParam(Double_t impactParam)
<span class="lineNum">      87 </span>            : {
<span class="lineNum">      88 </span>            :   /// Returns signed bending momentum in bending plane (GeV/c),
<span class="lineNum">      89 </span>            :   /// the sign being the sign of the charge for particles moving forward in Z,
<span class="lineNum">      90 </span>            :   /// from the impact parameter &quot;ImpactParam&quot; at vertex in bending plane (cm),
<span class="lineNum">      91 </span>            :   /// using simple values for dipole magnetic field.
<span class="lineNum">      92 </span>            :   
<span class="lineNum">      93 </span>            : //  if (impactParam == 0.) return 1.e10;
<span class="lineNum">      94 </span>            : //  
<span class="lineNum">      95 </span>            : //  const Double_t kCorrectionFactor = 1.1; // bending momentum is 10% underestimated
<span class="lineNum">      96 </span>            : //  
<span class="lineNum">      97 </span>            : //  if (fgFieldON) 
<span class="lineNum">      98 </span>            : //  {
<span class="lineNum">      99 </span>            : //    return kCorrectionFactor * (-0.0003 * fgSimpleBValue * fgkSimpleBLength * fgkSimpleBPosition / impactParam);
<span class="lineNum">     100 </span>            : //  }
<span class="lineNum">     101 </span>            : //  else 
<span class="lineNum">     102 </span>            : //  {
<span class="lineNum">     103 </span>            : //    return AliMUONConstants::GetMostProbBendingMomentum();
<span class="lineNum">     104 </span>            : //  }
<a name="105"><span class="lineNum">     105 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     106 </span>            : //__________________________________________________________________________
<span class="lineNum">     107 </span>            : Double_t AliMFTTrackExtrap::Sagitta(Int_t nVal, Double_t *xVal, Double_t *yVal, Double_t &amp;distL2, Double_t &amp;q2)
<span class="lineNum">     108 </span>            : {
<span class="lineNum">     109 </span>            :         /// Calculate sagitta of the track
<span class="lineNum">     110 </span>            :         /// Return sagitta
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :         cout&lt;&lt;&quot;Sagitta&quot;&lt;&lt;endl;</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :         Double_t q0,q1,chi2;</span>
<span class="lineNum">     113 </span>            :         // fit by a polynom of 2nd order
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :         chi2 = QuadraticRegression(nVal,xVal ,yVal, q0, q1,q2);</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :         cout&lt;&lt;Form(&quot;q param = %f  %f  %f  chi2 = %e &quot;,q0, q1,q2,chi2)&lt;&lt;endl;</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :         cout&lt;&lt;Form(&quot;pt from 2nd order parameter %f &quot;,0.01/q2/2.*0.3*fgSimpleBValue/10.)&lt;&lt;endl;</span>
<span class="lineNum">     117 </span>            :         
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span>            :         Double_t maxDist = 0.;
<span class="lineNum">     120 </span>            :         Int_t i1 = -1;
<span class="lineNum">     121 </span>            :         Int_t i2 = -1;
<span class="lineNum">     122 </span>            :         Double_t sagitta = 0.;
<span class="lineNum">     123 </span>            :         Double_t dist ;
<span class="lineNum">     124 </span>            :         Double_t distTot = 0.;
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :         for (int i=0; i&lt;nVal-1; i++) {</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :                 distTot += TMath::Sqrt((xVal[i]-xVal[i+1]) * (xVal[i]-xVal[i+1]) + (yVal[i]-yVal[i+1]) * (yVal[i]-yVal[i+1]));</span>
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :                 for (int j = i+1; j&lt;nVal; j++) {</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :                         Double_t dist = (xVal[i]-xVal[j]) * (xVal[i]-xVal[j]) + (yVal[i]-yVal[j]) * (yVal[i]-yVal[j]);</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :                         if(dist&gt;maxDist){</span>
<span class="lineNum">     132 </span>            :                                 i1 = i;
<span class="lineNum">     133 </span>            :                                 i2 = j;
<span class="lineNum">     134 </span>            :                                 maxDist = dist;
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :                         }</span>
<span class="lineNum">     136 </span>            :                 }
<span class="lineNum">     137 </span>            :         }
<span class="lineNum">     138 </span>            :         
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :         cout&lt;&lt;Form(&quot;distMAx = %f distTot =%f   i1 = %d i2 =%d&quot;,TMath::Sqrt(maxDist),distTot,i1,i2)&lt;&lt;endl;</span>
<span class="lineNum">     140 </span>            :         
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :         distL2 = 1.e-2*TMath::Sqrt((xVal[i1]-xVal[i2]) * (xVal[i1]-xVal[i2]) + (yVal[i1]-yVal[i2]) * (yVal[i1]-yVal[i2]) );</span>
<span class="lineNum">     142 </span>            :         
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :         Double_t p1 = (yVal[i1]-yVal[i2]) / (xVal[i1]-xVal[i2]);</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :         Double_t p0 = yVal[i2] - xVal[i2] * p1;</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :         cout&lt;&lt;Form(&quot;p param = %f  %f  &quot;,p0, p1)&lt;&lt;endl;</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :         q2 = TMath::Sign(q2,q1*q2*(-(p0 + p1 * (xVal[i1]+xVal[i2])/2.))*(fgSimpleBValue));</span>
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            :         
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :         Double_t y12 = q0+q1*xVal[i1]+q2*xVal[i1]*xVal[i1];</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :         Double_t y22 = q0+q1*xVal[i2]+q2*xVal[i2]*xVal[i2];</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :         cout&lt;&lt;Form(&quot;x1, y1 %f  %f  &quot;,xVal[i1], y12)&lt;&lt;endl;</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :         cout&lt;&lt;Form(&quot;x2, y2 %f  %f  &quot;,xVal[i2], y22)&lt;&lt;endl;</span>
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            : //      Double_t p12 = (y12-y22) / (xVal[i1]-xVal[i2]);
<span class="lineNum">     155 </span>            : //      Double_t p02 = y22 - xVal[i2] * p12;
<span class="lineNum">     156 </span>            : //      cout&lt;&lt;Form(&quot;p2 param = %f  %f  &quot;,p02, p12)&lt;&lt;endl;
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            :         Double_t maxSagitta = 0.;
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :         for (int i=0; i&lt;20; i++) {</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :                 Double_t step =TMath::Abs(xVal[i1]-xVal[i2])/20.;</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :                 Double_t xmiddle = xVal[i1] + i*step;</span>
<span class="lineNum">     162 </span>            :                 
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :                 Double_t y1 = p0 + p1 * xmiddle;</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :                 Double_t p1perp = -1./p1;</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :                 Double_t p0perp = p0 + xmiddle *(p1-p1perp);</span>
<span class="lineNum">     166 </span>            :                 //cout&lt;&lt;Form(&quot;p param perp = %f  %f  &quot;,p0perp, p1perp)&lt;&lt;endl;
<span class="lineNum">     167 </span>            :                 
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :                 Double_t xmax = (p1perp - q1 + TMath::Sqrt(p1perp*p1perp - 2*p1perp*q1 + q1*q1 + 4*p0perp*q2 - 4*q0*q2))/(2*q2);</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :                 Double_t xmax2 = -(q1 -p1perp + TMath::Sqrt(p1perp*p1perp - 2*p1perp*q1 + q1*q1 + 4*p0perp*q2 - 4*q0*q2))/(2*q2);</span>
<span class="lineNum">     170 </span>            :                 //              cout&lt;&lt;Form(&quot;xmax = %f   xmax2  %f&quot;,xmax,xmax2)&lt;&lt;endl;
<span class="lineNum">     171 </span>            :                 
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :                 if (TMath::Abs(xmax2-xmiddle) &lt; TMath::Abs(xmax-xmiddle)) xmax = xmax2;</span>
<span class="lineNum">     173 </span>            :                 
<span class="lineNum">     174 </span>            :                 
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :                 Double_t y2 = q0 + q1 * xmax  + q2 * xmax * xmax;</span>
<span class="lineNum">     176 </span>            :                 
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :                 sagitta = 1e-2*TMath::Sqrt((xmiddle-xmax) * (xmiddle-xmax) + (y1-y2) * (y1-y2) );</span>
<span class="lineNum">     178 </span>            :                 
<span class="lineNum">     179 </span>            :                 //              cout&lt;&lt;Form(&quot;sagitta = %f   Bz = %f&quot;,sagitta,fgSimpleBValue)&lt;&lt;endl;
<span class="lineNum">     180 </span>            :                 
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :                 sagitta = TMath::Sign(sagitta,q1*q2*(-y1)*(fgSimpleBValue));</span>
<span class="lineNum">     182 </span>            :                 
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :                 if(TMath::Abs(sagitta)&gt;TMath::Abs(maxSagitta)) maxSagitta = sagitta;</span>
<span class="lineNum">     184 </span>            :                 
<span class="lineNum">     185 </span>            :         }
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :         cout&lt;&lt;Form(&quot; Max sagitta = %e =&gt; pt = %f&quot;,maxSagitta, 0.3*0.5*distL2*distL2/8./maxSagitta)&lt;&lt;endl;</span>
<span class="lineNum">     187 </span>            : //      p0 = p02;
<span class="lineNum">     188 </span>            : //      p1 = p12;
<span class="lineNum">     189 </span>            : //      
<span class="lineNum">     190 </span>            : //
<span class="lineNum">     191 </span>            : //       maxSagitta = 0.;
<span class="lineNum">     192 </span>            : //      for (int i=0; i&lt;20; i++) {
<span class="lineNum">     193 </span>            : //              Double_t step =TMath::Abs(xVal[i1]-xVal[i2])/20.;
<span class="lineNum">     194 </span>            : //              Double_t xmiddle = xVal[i1] + i*step;
<span class="lineNum">     195 </span>            : ////            cout&lt;&lt;Form(&quot;x middle = %f  &quot;,xmiddle)&lt;&lt;endl;
<span class="lineNum">     196 </span>            : //              
<span class="lineNum">     197 </span>            : //              Double_t y1 = p0 + p1 * xmiddle;
<span class="lineNum">     198 </span>            : //              Double_t p1perp = -1./p1;
<span class="lineNum">     199 </span>            : //              Double_t p0perp = p0 + xmiddle *(p1-p1perp);
<span class="lineNum">     200 </span>            : //              //cout&lt;&lt;Form(&quot;p param perp = %f  %f  &quot;,p0perp, p1perp)&lt;&lt;endl;
<span class="lineNum">     201 </span>            : //              
<span class="lineNum">     202 </span>            : //              Double_t xmax  =  (p1perp - q1 + TMath::Sqrt(p1perp*p1perp - 2*p1perp*q1 + q1*q1 + 4*p0perp*q2 - 4*q0*q2))/(2*q2);
<span class="lineNum">     203 </span>            : //              Double_t xmax2 = -(q1 - p1perp + TMath::Sqrt(p1perp*p1perp - 2*p1perp*q1 + q1*q1 + 4*p0perp*q2 - 4*q0*q2))/(2*q2);
<span class="lineNum">     204 </span>            : ////            cout&lt;&lt;Form(&quot;xmax = %f   xmax2  %f&quot;,xmax,xmax2)&lt;&lt;endl;
<span class="lineNum">     205 </span>            : //              
<span class="lineNum">     206 </span>            : //              if (TMath::Abs(xmax2-xmiddle) &lt; TMath::Abs(xmax-xmiddle)) xmax = xmax2;
<span class="lineNum">     207 </span>            : //              
<span class="lineNum">     208 </span>            : //              
<span class="lineNum">     209 </span>            : //              Double_t y2 = q0 + q1 * xmax  + q2 * xmax * xmax;
<span class="lineNum">     210 </span>            : //              
<span class="lineNum">     211 </span>            : //              sagitta = 1e-2*TMath::Sqrt((xmiddle-xmax) * (xmiddle-xmax) + (y1-y2) * (y1-y2) );
<span class="lineNum">     212 </span>            : //              
<span class="lineNum">     213 </span>            : ////            cout&lt;&lt;Form(&quot;sagitta = %f   Bz = %f&quot;,sagitta,fgSimpleBValue)&lt;&lt;endl;
<span class="lineNum">     214 </span>            : //              
<span class="lineNum">     215 </span>            : //              sagitta = TMath::Sign(sagitta,q1*q2*(-y1)*(fgSimpleBValue));
<span class="lineNum">     216 </span>            : //              
<span class="lineNum">     217 </span>            : ////            cout&lt;&lt;Form(&quot;Signed sagitta = %e &quot;,sagitta)&lt;&lt;endl;
<span class="lineNum">     218 </span>            : //              if(sagitta&gt;maxSagitta) maxSagitta = sagitta;
<span class="lineNum">     219 </span>            : //              
<span class="lineNum">     220 </span>            : //      }
<span class="lineNum">     221 </span>            : //      cout&lt;&lt;Form(&quot; Max sagitta 2 = %e =&gt; pt = %f&quot;,maxSagitta, 0.3*0.5*distL2*distL2/8./maxSagitta )&lt;&lt;endl;
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :         return maxSagitta;</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 : }</span>
<a name="225"><span class="lineNum">     225 </span>            : </a>
<span class="lineNum">     226 </span>            : //__________________________________________________________________________
<span class="lineNum">     227 </span>            : Double_t AliMFTTrackExtrap::LinearRegression(Int_t nVal, Double_t *xVal, Double_t *yVal, Double_t &amp;p0, Double_t &amp;p1)
<span class="lineNum">     228 </span>            : {
<span class="lineNum">     229 </span>            :         /// Perform a Linear Regression
<span class="lineNum">     230 </span>            :         /// Return Chi2
<span class="lineNum">     231 </span>            :         Double_t meanx =0, meany=0.;
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :         for (Int_t i = 0; i&lt; nVal; i++) {</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :                 meanx =(meanx*i+xVal[i])/(i+1);</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :                 meany =(meany*i+yVal[i])/(i+1);</span>
<span class="lineNum">     236 </span>            :         }
<span class="lineNum">     237 </span>            :         Double_t cov_xy = 0., var_x=0., var_y=0.;
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :         for (Int_t i = 0; i&lt; nVal; i++) {</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :                 var_x  += (xVal[i] -meanx) * (xVal[i] -meanx);</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :                 var_y  += (yVal[i] -meany) * (yVal[i] -meany);</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :                 cov_xy += (xVal[i] -meanx) * (yVal[i] -meany);</span>
<span class="lineNum">     242 </span>            :         }
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :         if(var_x&lt;1.e-6) return 0.;</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :         p1 = cov_xy/var_x;</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :         p0 = meany - p1 * meanx;</span>
<span class="lineNum">     246 </span>            :         
<span class="lineNum">     247 </span>            :         Double_t chi2 = 0.;
<span class="lineNum">     248 </span>            :         Double_t yest=0.;
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :         for (Int_t i = 0; i&lt; nVal; i++) {</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :                 yest = xVal[i]*p1+p0;</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :                 chi2 += (yest-yVal[i]) * (yest-yVal[i]);</span>
<span class="lineNum">     252 </span>            :         }
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :         chi2 /= var_y;</span>
<span class="lineNum">     254 </span>            :         
<span class="lineNum">     255 </span>            :         
<span class="lineNum">     256 </span>            :         return chi2;
<a name="257"><span class="lineNum">     257 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     258 </span>            : //__________________________________________________________________________
<span class="lineNum">     259 </span>            : Double_t AliMFTTrackExtrap::QuadraticRegression(Int_t nVal, Double_t *xVal, Double_t *yVal, Double_t &amp;p0, Double_t &amp;p1, Double_t &amp;p2)
<span class="lineNum">     260 </span>            : {
<span class="lineNum">     261 </span>            :         /// Perform a Quadratic Regression
<span class="lineNum">     262 </span>            :         /// Assume same error on all clusters = 1
<span class="lineNum">     263 </span>            :         /// Return ~ Chi2
<span class="lineNum">     264 </span>            :         
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :         TMatrixD y(nVal,1);</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :         TMatrixD x(nVal,3);</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :         TMatrixD xtrans(3,nVal);</span>
<span class="lineNum">     268 </span>            :         
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :         for (int i=0; i&lt;nVal; i++) {</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :                 y(i,0) = yVal[i];</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :                 x(i,0) = 1.;</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :                 x(i,1) = xVal[i];</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :                 x(i,2) = xVal[i]*xVal[i];</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :                 xtrans(0,i) = 1.;</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :                 xtrans(1,i) = xVal[i];</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :                 xtrans(2,i) = xVal[i]*xVal[i];</span>
<span class="lineNum">     277 </span>            :         }
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :         TMatrixD tmp(xtrans,TMatrixD::kMult,x);</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :         tmp.Invert();</span>
<span class="lineNum">     280 </span>            :         
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :         TMatrixD tmp2(xtrans,TMatrixD::kMult,y);</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :         TMatrixD b(tmp,TMatrixD::kMult,tmp2);</span>
<span class="lineNum">     283 </span>            :         
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :         p0 = b(0,0);</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :         p1 = b(1,0);</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :         p2 = b(2,0);</span>
<span class="lineNum">     287 </span>            :         
<span class="lineNum">     288 </span>            :         // chi2 = (y-xb)^t . W . (y-xb)
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :         TMatrixD tmp3(x,TMatrixD::kMult,b);</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :         TMatrixD tmp4(y,TMatrixD::kMinus,tmp3);</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :         TMatrixD chi2(tmp4,TMatrixD::kTransposeMult,tmp4);</span>
<span class="lineNum">     292 </span>            :         
<span class="lineNum">     293 </span>            :         
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :         return chi2(0,0);</span>
<a name="295"><span class="lineNum">     295 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     296 </span>            : //__________________________________________________________________________
<span class="lineNum">     297 </span>            : Double_t AliMFTTrackExtrap::CircleRegression(Int_t nVal, Double_t *xVal, Double_t *yVal)
<span class="lineNum">     298 </span>            : {
<span class="lineNum">     299 </span>            :         /// Perform a Circular Regression
<span class="lineNum">     300 </span>            :         /// Assume same error on all clusters = 1
<span class="lineNum">     301 </span>            :         /// Return Radius evaluation
<span class="lineNum">     302 </span>            :         Double_t sumxi2 =0., sumxi =0., sumxiyi =0., sumyi =0.,sumyi2 =0., sumxi3 =0., sumyi3 =0.;
<span class="lineNum">     303 </span>            :         Double_t sumxi2yi=0., sumxiyi2=0.;
<span class="lineNum">     304 </span>            :         Double_t xi,yi, ri;
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :         for (int i=0; i&lt;nVal; i++) {</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :                 xi = xVal[i]/100.;</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :                 yi = yVal[i]/100.;</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :                 ri = TMath::Sqrt(xi*xi + yi*yi);</span>
<span class="lineNum">     309 </span>            : //              xi /= ri*ri;
<span class="lineNum">     310 </span>            : //              yi /= ri*ri;
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :                 sumxi += xi;</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :                 sumyi += yi;</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :                 sumxi2 += xi*xi;</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :                 sumyi2 += yi*yi;</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :                 sumxi3 += xi*xi*xi;</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :                 sumyi3 += yi*yi*yi;</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :                 sumxiyi += xi*yi;</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :                 sumxi2yi += xi*xi*yi;</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :                 sumxiyi2 += xi*yi*yi;</span>
<span class="lineNum">     321 </span>            :         }
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :         Double_t A = nVal * sumxi2 - sumxi*sumxi;</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :         Double_t B = nVal * sumxiyi - sumxi*sumyi;</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :         Double_t C = nVal * sumyi2 - sumyi*sumyi;</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :         Double_t D = 0.5*(nVal*sumxiyi2 -sumxi*sumyi2  +nVal*sumxi3 -sumxi*sumxi2);</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :         Double_t E = 0.5*(nVal*sumxi2yi -sumyi*sumxi2  +nVal*sumyi3 -sumyi*sumyi2);</span>
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :         Double_t aM = (D*C-B*E) / (A*C-B*B);</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :         Double_t bM = (A*E-B*D) / (A*C-B*B);</span>
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            :         Double_t rM = 0.;
<span class="lineNum">     333 </span>            :         Double_t rK = 0.;
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :         for (int i=0; i&lt;nVal; i++) {</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :                 xi = xVal[i]/100.;</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :                 yi = yVal[i]/100.;</span>
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :                 rM += TMath::Sqrt( (xi-aM)*(xi-aM) + (yi-bM)*(yi-bM) );</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :                 rK +=  ((xi-aM)*(xi-aM) + (yi-bM)*(yi-bM) );</span>
<span class="lineNum">     341 </span>            :         }
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :         rM /= nVal;</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :         rK = TMath::Sqrt(rK/nVal);</span>
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :         cout&lt;&lt;Form(&quot;aM %f bM %f rM %f rK %f =&gt; pt = %f or %f &quot;,aM,bM,rM,rK,rM*0.3*0.5, rK*0.3*0.5)&lt;&lt;endl;</span>
<span class="lineNum">     346 </span>            :         
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :         return (rM+rK)/2.;</span>
<span class="lineNum">     348 </span>            : }
<a name="349"><span class="lineNum">     349 </span>            : </a>
<span class="lineNum">     350 </span>            : //__________________________________________________________________________
<span class="lineNum">     351 </span>            : void AliMFTTrackExtrap::LinearExtrapToZ(AliMFTTrackParam* trackParam, Double_t zEnd)
<span class="lineNum">     352 </span>            : {
<span class="lineNum">     353 </span>            :   /// Track parameters linearly extrapolated to the plane at &quot;zEnd&quot;.
<span class="lineNum">     354 </span>            :   /// On return, results from the extrapolation are updated in trackParam.
<span class="lineNum">     355 </span>            :   
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :   if (trackParam-&gt;GetZ() == zEnd) return; // nothing to be done if same z</span>
<span class="lineNum">     357 </span>            :   
<span class="lineNum">     358 </span>            :   // Compute track parameters
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :   Double_t dZ = zEnd - trackParam-&gt;GetZ();</span>
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :         trackParam-&gt;SetX(trackParam-&gt;GetX() + trackParam-&gt;GetSlopeX() * dZ);</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :         trackParam-&gt;SetY(trackParam-&gt;GetY() + trackParam-&gt;GetSlopeY() * dZ);</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :         trackParam-&gt;SetZ(zEnd);</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 : }</span>
<a name="365"><span class="lineNum">     365 </span>            : </a>
<span class="lineNum">     366 </span>            : //__________________________________________________________________________
<span class="lineNum">     367 </span>            : void AliMFTTrackExtrap::LinearExtrapToZCov(AliMFTTrackParam* trackParam, Double_t zEnd, Bool_t updatePropagator)
<span class="lineNum">     368 </span>            : {
<span class="lineNum">     369 </span>            :   /// Track parameters and their covariances linearly extrapolated to the plane at &quot;zEnd&quot;.
<span class="lineNum">     370 </span>            :   /// On return, results from the extrapolation are updated in trackParam.
<span class="lineNum">     371 </span>            :   
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :         if (trackParam-&gt;GetZ() == zEnd) return; // nothing to be done if same z</span>
<span class="lineNum">     373 </span>            :         
<span class="lineNum">     374 </span>            :         // No need to propagate the covariance matrix if it does not exist
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :         if (!trackParam-&gt;CovariancesExist()) {</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :                 cout&lt;&lt;&quot;W-AliMUONTrackExtrap::LinearExtrapToZCov: Covariance matrix does not exist&quot;&lt;&lt;endl;</span>
<span class="lineNum">     377 </span>            :                 // Extrapolate linearly track parameters to &quot;zEnd&quot;
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :                 LinearExtrapToZ(trackParam,zEnd);</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     380 </span>            :         }
<span class="lineNum">     381 </span>            :         
<span class="lineNum">     382 </span>            :         // Compute track parameters
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :         Double_t dZ = zEnd - trackParam-&gt;GetZ();</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :         trackParam-&gt;SetX(trackParam-&gt;GetX() + trackParam-&gt;GetSlopeX() * dZ);</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :         trackParam-&gt;SetY(trackParam-&gt;GetY() + trackParam-&gt;GetSlopeY() * dZ);</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :         trackParam-&gt;SetZ(zEnd);</span>
<span class="lineNum">     387 </span>            :         
<span class="lineNum">     388 </span>            :         // Calculate the jacobian related to the track parameters linear extrapolation to &quot;zEnd&quot;
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :         TMatrixD jacob(5,5);</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :         jacob.UnitMatrix();</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :         jacob(0,2) = dZ;</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :         jacob(1,3) = dZ;</span>
<span class="lineNum">     393 </span>            :         
<span class="lineNum">     394 </span>            :         // Extrapolate track parameter covariances to &quot;zEnd&quot;
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :         TMatrixD tmp(trackParam-&gt;GetCovariances(),TMatrixD::kMultTranspose,jacob);</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :         TMatrixD tmp2(jacob,TMatrixD::kMult,tmp);</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :         trackParam-&gt;SetCovariances(tmp2);</span>
<span class="lineNum">     398 </span>            :         
<span class="lineNum">     399 </span>            :         // Update the propagator if required
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :         if (updatePropagator) trackParam-&gt;UpdatePropagator(jacob);</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 : }</span>
<a name="402"><span class="lineNum">     402 </span>            : </a>
<span class="lineNum">     403 </span>            : //__________________________________________________________________________
<span class="lineNum">     404 </span>            : Bool_t AliMFTTrackExtrap::ExtrapToZ(AliMFTTrackParam* trackParam, Double_t zEnd)
<span class="lineNum">     405 </span>            : {
<span class="lineNum">     406 </span>            :   /// Interface to track parameter extrapolation to the plane at &quot;Z&quot; using Helix or Rungekutta algorithm.
<span class="lineNum">     407 </span>            :   /// On return, the track parameters resulting from the extrapolation are updated in trackParam.
<span class="lineNum">     408 </span>            : //return AliMFTTrackExtrap::ExtrapToZHelix(trackParam,zEnd);
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :         if (!fgFieldON) {</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :     AliMFTTrackExtrap::LinearExtrapToZ(trackParam,zEnd);</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :     return kTRUE;</span>
<span class="lineNum">     412 </span>            :   }
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :   else if (fgkUseHelix) return AliMFTTrackExtrap::ExtrapToZHelix(trackParam,zEnd);</span>
<span class="lineNum">     414 </span>            :   else return AliMFTTrackExtrap::ExtrapToZRungekutta(trackParam,zEnd);
<span class="lineNum">     415 </span><span class="lineNoCov">          0 : }</span>
<a name="416"><span class="lineNum">     416 </span>            : </a>
<span class="lineNum">     417 </span>            : //__________________________________________________________________________
<span class="lineNum">     418 </span>            : Bool_t AliMFTTrackExtrap::ExtrapToZHelix(AliMFTTrackParam* trackParam, Double_t zEnd)
<span class="lineNum">     419 </span>            : {
<span class="lineNum">     420 </span>            : //      cout&lt;&lt;&quot;I-AliMFTTrackExtrap::ExtrapToZHelix: Entering ------ &quot;&lt;&lt;endl;
<span class="lineNum">     421 </span>            :   /// Track parameter extrapolation to the plane at &quot;Z&quot; using Helix algorithm.
<span class="lineNum">     422 </span>            :   /// On return, the track parameters resulting from the extrapolation are updated in trackParam.
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :   if (trackParam-&gt;GetZ() == zEnd) return kTRUE; // nothing to be done if same Z</span>
<span class="lineNum">     424 </span>            :   Double_t forwardBackward; // +1 if forward, -1 if backward
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :   if (zEnd &lt; trackParam-&gt;GetZ()) forwardBackward = 1.0; // spectro. z&lt;0 </span>
<span class="lineNum">     426 </span>            :   else forwardBackward = -1.0;
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :   Double_t v3[7], v3New[7]; // 7 in parameter ????</span>
<span class="lineNum">     428 </span>            :   Int_t i3, stepNumber;
<span class="lineNum">     429 </span>            :   // For safety: return kTRUE or kFALSE ????
<span class="lineNum">     430 </span>            :   // Parameter vector for calling EXTRAP_ONESTEP
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :   ConvertTrackParamForExtrap(trackParam, forwardBackward, v3);</span>
<span class="lineNum">     432 </span>            :   // sign of charge (sign of fInverseBendingMomentum if forward motion)
<span class="lineNum">     433 </span>            :   // must be changed if backward extrapolation
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :   Double_t chargeExtrap = forwardBackward * TMath::Sign(Double_t(1.0), trackParam-&gt;GetInverseTransverseMomentum());</span>
<span class="lineNum">     435 </span>            : //      cout&lt;&lt;&quot;chargeExtrap = &quot;&lt;&lt;chargeExtrap&lt;&lt;endl;
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span>            :   // Extrapolation loop
<span class="lineNum">     438 </span>            :   stepNumber = 0;
<span class="lineNum">     439 </span>            : //      cout&lt;&lt;&quot; (-forwardBackward * (v3[2] - zEnd)) = &quot;&lt;&lt;(-forwardBackward * (v3[2] - zEnd))&lt;&lt;endl;
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :   while (((-forwardBackward * (v3[2] - zEnd)) &lt;= 0.0) &amp;&amp; (stepNumber &lt; fgkMaxStepNumber)) { // spectro. z&lt;0</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :     stepNumber++;</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :     ExtrapOneStepHelix(chargeExtrap, fgkHelixStepLength, v3, v3New);</span>
<span class="lineNum">     443 </span>            : //              cout&lt;&lt;&quot; (-forwardBackward * (v3New[2] - zEnd)) = &quot;&lt;&lt;(-forwardBackward * (v3New[2] - zEnd))&lt;&lt;endl;
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :     if ((-forwardBackward * (v3New[2] - zEnd)) &gt; 0.0) break; // one is beyond Z spectro. z&lt;0</span>
<span class="lineNum">     446 </span>            :                                                              // better use TArray ????
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :     for (i3 = 0; i3 &lt; 7; i3++) {</span>
<span class="lineNum">     448 </span>            : //                      cout&lt;&lt;&quot; v3New[&quot;&lt;&lt;i3&lt;&lt; &quot;] = &quot;&lt;&lt;v3New[i3]&lt;&lt;endl;
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :                         v3[i3] = v3New[i3];</span>
<span class="lineNum">     450 </span>            :                 }
<span class="lineNum">     451 </span>            :   }
<span class="lineNum">     452 </span>            :   // check fgkMaxStepNumber ????
<span class="lineNum">     453 </span>            :   // Interpolation back to exact Z (2nd order)
<span class="lineNum">     454 </span>            :   // should be in function ???? using TArray ????
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :   Double_t dZ12 = v3New[2] - v3[2]; // 1-&gt;2</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :   if (TMath::Abs(dZ12) &gt; 0) {</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :     Double_t dZ1i = zEnd - v3[2]; // 1-i</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :     Double_t dZi2 = v3New[2] - zEnd; // i-&gt;2</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :     Double_t xPrime = (v3New[0] - v3[0]) / dZ12;</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :     Double_t xSecond = ((v3New[3] / v3New[5]) - (v3[3] / v3[5])) / dZ12;</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :     Double_t yPrime = (v3New[1] - v3[1]) / dZ12;</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :     Double_t ySecond = ((v3New[4] / v3New[5]) - (v3[4] / v3[5])) / dZ12;</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :     v3[0] = v3[0] + xPrime * dZ1i - 0.5 * xSecond * dZ1i * dZi2; // X</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :     v3[1] = v3[1] + yPrime * dZ1i - 0.5 * ySecond * dZ1i * dZi2; // Y</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :     v3[2] = zEnd; // Z</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :     Double_t xPrimeI = xPrime - 0.5 * xSecond * (dZi2 - dZ1i);</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :     Double_t yPrimeI = yPrime - 0.5 * ySecond * (dZi2 - dZ1i);</span>
<span class="lineNum">     468 </span>            :     // (PX, PY, PZ)/PTOT assuming forward motion
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :     v3[5] = 1.0 / TMath::Sqrt(1.0 + xPrimeI * xPrimeI + yPrimeI * yPrimeI); // PZ/PTOT</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :     v3[3] = xPrimeI * v3[5]; // PX/PTOT</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :     v3[4] = yPrimeI * v3[5]; // PY/PTOT</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :     cout&lt;&lt;&quot;W-AliMFTTrackExtrap::ExtrapToZHelix: Extrap. to Z not reached, Z = &quot;&lt;&lt;zEnd&lt;&lt;endl;</span>
<span class="lineNum">     474 </span>            :   }
<span class="lineNum">     475 </span>            :   // Recover track parameters (charge back for forward motion)
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :   RecoverTrackParam(v3, chargeExtrap * forwardBackward, trackParam);</span>
<span class="lineNum">     477 </span>            :   return kTRUE;
<span class="lineNum">     478 </span><span class="lineNoCov">          0 : }</span>
<a name="479"><span class="lineNum">     479 </span>            : </a>
<span class="lineNum">     480 </span>            : //__________________________________________________________________________
<span class="lineNum">     481 </span>            : Bool_t AliMFTTrackExtrap::ExtrapToZRungekutta(AliMFTTrackParam* trackParam, Double_t zEnd)
<span class="lineNum">     482 </span>            : {
<span class="lineNum">     483 </span>            :         /// Track parameter extrapolation to the plane at &quot;Z&quot; using Rungekutta algorithm.
<span class="lineNum">     484 </span>            :         /// On return, the track parameters resulting from the extrapolation are updated in trackParam.
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :         if (trackParam-&gt;GetZ() == zEnd) return kTRUE; // nothing to be done if same Z</span>
<span class="lineNum">     486 </span>            :         Double_t forwardBackward; // +1 if forward, -1 if backward
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :         if (zEnd &lt; trackParam-&gt;GetZ()) forwardBackward = 1.0; // spectro. z&lt;0</span>
<span class="lineNum">     488 </span>            :         else forwardBackward = -1.0;
<span class="lineNum">     489 </span>            :         // sign of charge (sign of fInverseBendingMomentum if forward motion)
<span class="lineNum">     490 </span>            :         // must be changed if backward extrapolation
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :         Double_t chargeExtrap = forwardBackward * TMath::Sign(Double_t(1.0), trackParam-&gt;GetInverseTransverseMomentum());</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :         Double_t v3[7], v3New[7];</span>
<span class="lineNum">     493 </span>            :         Double_t dZ, step;
<span class="lineNum">     494 </span>            :         Int_t stepNumber = 0;
<span class="lineNum">     495 </span>            :         
<span class="lineNum">     496 </span>            :         // Extrapolation loop (until within tolerance or the track turn around)
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :         Double_t residue = zEnd - trackParam-&gt;GetZ();</span>
<span class="lineNum">     498 </span>            :         Bool_t uturn = kFALSE;
<span class="lineNum">     499 </span>            :         Bool_t trackingFailed = kFALSE;
<span class="lineNum">     500 </span>            :         Bool_t tooManyStep = kFALSE;
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :         while (TMath::Abs(residue) &gt; fgkRungeKuttaMaxResidue &amp;&amp; stepNumber &lt;= fgkMaxStepNumber) {</span>
<span class="lineNum">     502 </span>            :                 
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :                 dZ = zEnd - trackParam-&gt;GetZ();</span>
<span class="lineNum">     504 </span>            :                 // step lenght assuming linear trajectory
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :                 step = dZ * TMath::Sqrt(1.0 + trackParam-&gt;GetSlopeY()*trackParam-&gt;GetSlopeY() +</span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :                                                                                                                 trackParam-&gt;GetSlopeX()*trackParam-&gt;GetSlopeX());</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :                 ConvertTrackParamForExtrap(trackParam, forwardBackward, v3);</span>
<span class="lineNum">     508 </span>            :                 
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :                 do { // reduce step lenght while zEnd oversteped</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :                         if (stepNumber &gt; fgkMaxStepNumber) {</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :                                 cout&lt;&lt;&quot;W-AliMFTTrackExtrap::ExtrapToZRungekutta: Too many trials: &quot;&lt;&lt;stepNumber&lt;&lt;endl;</span>
<span class="lineNum">     512 </span>            :                                 tooManyStep = kTRUE;
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">     514 </span>            :                         }
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :                         stepNumber ++;</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :                         step = TMath::Abs(step);</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :                         if (!AliMFTTrackExtrap::ExtrapOneStepRungekutta(chargeExtrap,step,v3,v3New)) {</span>
<span class="lineNum">     518 </span>            :                                 trackingFailed = kTRUE;
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">     520 </span>            :                         }
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :                         residue = zEnd - v3New[2];</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :                         step *= dZ/(v3New[2]-trackParam-&gt;GetZ());</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :                 } while (residue*dZ &lt; 0 &amp;&amp; TMath::Abs(residue) &gt; fgkRungeKuttaMaxResidue);</span>
<span class="lineNum">     524 </span>            :                 
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :                 if (trackingFailed) break;</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :                 else if (v3New[5]*v3[5] &lt; 0) { // the track turned around</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :                         cout&lt;&lt;&quot;W-AliMFTTrackExtrap::ExtrapToZRungekutta: The track turned around&quot;&lt;&lt;endl;</span>
<span class="lineNum">     528 </span>            :                         uturn = kTRUE;
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :                 } else RecoverTrackParam(v3New, chargeExtrap * forwardBackward, trackParam);</span>
<span class="lineNum">     531 </span>            :                 
<span class="lineNum">     532 </span>            :         }
<span class="lineNum">     533 </span>            :         
<span class="lineNum">     534 </span>            :         // terminate the extropolation with a straight line up to the exact &quot;zEnd&quot; value
<span class="lineNum">     535 </span>            :         /// todo : change that
<span class="lineNum">     536 </span>            : //      if (trackingFailed || uturn) {
<span class="lineNum">     537 </span>            : //              
<span class="lineNum">     538 </span>            : //              // track ends +-100 meters away in the bending direction
<span class="lineNum">     539 </span>            : //              dZ = zEnd - v3[2];
<span class="lineNum">     540 </span>            : //              Double_t bendingSlope = TMath::Sign(1.e4,-fgSimpleBValue*trackParam-&gt;GetInverseBendingMomentum()) / dZ;
<span class="lineNum">     541 </span>            : //              Double_t pZ = TMath::Abs(1. / trackParam-&gt;GetInverseBendingMomentum()) / TMath::Sqrt(1.0 + bendingSlope * bendingSlope);
<span class="lineNum">     542 </span>            : //              Double_t nonBendingSlope = TMath::Sign(TMath::Abs(v3[3]) * v3[6] / pZ, trackParam-&gt;GetNonBendingSlope());
<span class="lineNum">     543 </span>            : //              trackParam-&gt;SetNonBendingCoor(trackParam-&gt;GetNonBendingCoor() + dZ * nonBendingSlope);
<span class="lineNum">     544 </span>            : //              trackParam-&gt;SetNonBendingSlope(nonBendingSlope);
<span class="lineNum">     545 </span>            : //              trackParam-&gt;SetBendingCoor(trackParam-&gt;GetBendingCoor() + dZ * bendingSlope);
<span class="lineNum">     546 </span>            : //              trackParam-&gt;SetBendingSlope(bendingSlope);
<span class="lineNum">     547 </span>            : //              trackParam-&gt;SetZ(zEnd);
<span class="lineNum">     548 </span>            : //              
<span class="lineNum">     549 </span>            : //              return kFALSE;
<span class="lineNum">     550 </span>            : //              
<span class="lineNum">     551 </span>            : //      } else {
<span class="lineNum">     552 </span>            : //              
<span class="lineNum">     553 </span>            : //              // track extrapolated normally
<span class="lineNum">     554 </span>            : //              trackParam-&gt;SetNonBendingCoor(trackParam-&gt;GetNonBendingCoor() + residue * trackParam-&gt;GetNonBendingSlope());
<span class="lineNum">     555 </span>            : //              trackParam-&gt;SetBendingCoor(trackParam-&gt;GetBendingCoor() + residue * trackParam-&gt;GetBendingSlope());
<span class="lineNum">     556 </span>            : //              trackParam-&gt;SetZ(zEnd);
<span class="lineNum">     557 </span>            : //              
<span class="lineNum">     558 </span>            : //              return !tooManyStep;
<span class="lineNum">     559 </span>            : //              
<span class="lineNum">     560 </span>            : //      }
<span class="lineNum">     561 </span>            :         
<span class="lineNum">     562 </span><span class="lineNoCov">          0 : }</span>
<a name="563"><span class="lineNum">     563 </span>            : </a>
<span class="lineNum">     564 </span>            : //__________________________________________________________________________
<span class="lineNum">     565 </span>            : void AliMFTTrackExtrap::ConvertTrackParamForExtrap(AliMFTTrackParam* trackParam, Double_t forwardBackward, Double_t *v3)
<span class="lineNum">     566 </span>            : {
<span class="lineNum">     567 </span>            :   /// Set vector of Geant3 parameters pointed to by &quot;v3&quot; from track parameters in trackParam.
<span class="lineNum">     568 </span>            :   /// Since AliMFTTrackParam is only geometry, one uses &quot;forwardBackward&quot;
<span class="lineNum">     569 </span>            :   /// to know whether the particle is going forward (+1) or backward (-1).
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :   v3[0] = trackParam-&gt;GetX(); // X</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :   v3[1] = trackParam-&gt;GetY(); // Y</span>
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :   v3[2] = trackParam-&gt;GetZ(); // Z</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :         Double_t slopeX = trackParam-&gt;GetSlopeX() ;</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :         Double_t slopeY = trackParam-&gt;GetSlopeY() ;</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :         Double_t slope2 = TMath::Sqrt(1.+slopeX*slopeX +slopeY*slopeY);</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :         Double_t pt = TMath::Abs(1.0 / trackParam-&gt;GetInverseTransverseMomentum());</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :   v3[6] = pt*slope2/TMath::Sqrt(slopeX*slopeX +slopeY*slopeY); // PTOT</span>
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :   v3[5] = -forwardBackward / slope2; // PZ/PTOT spectro. z&lt;0</span>
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :         v3[3] = slopeX / slope2; // PX/PTOT</span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :   v3[4] = slopeY / slope2; // PY/PTOT</span>
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span>            :         
<span class="lineNum">     584 </span>            : //      v3[0] = trackParam-&gt;GetX(); // X
<span class="lineNum">     585 </span>            : //      v3[1] = trackParam-&gt;GetY(); // Y
<span class="lineNum">     586 </span>            : //      v3[2] = trackParam-&gt;GetZ(); // Z
<span class="lineNum">     587 </span>            : //      Double_t pYZ = TMath::Abs(1.0 / trackParam-&gt;GetInverseMomentum());
<span class="lineNum">     588 </span>            : //      Double_t pZ = pYZ / TMath::Sqrt(1.0 + trackParam-&gt;GetSlopeY() * trackParam-&gt;GetSlopeY());
<span class="lineNum">     589 </span>            : //      v3[6] = TMath::Sqrt(pYZ * pYZ + pZ * pZ * trackParam-&gt;GetSlopeX() * trackParam-&gt;GetSlopeX()); // PTOT
<span class="lineNum">     590 </span>            : //      v3[5] = -forwardBackward * pZ / v3[6]; // PZ/PTOT spectro. z&lt;0
<span class="lineNum">     591 </span>            : //      v3[3] = trackParam-&gt;GetSlopeX() * v3[5]; // PX/PTOT
<span class="lineNum">     592 </span>            : //      v3[4] = trackParam-&gt;GetSlopeY() * v3[5]; // PY/PTOT
<span class="lineNum">     593 </span>            : 
<span class="lineNum">     594 </span><span class="lineNoCov">          0 : }</span>
<a name="595"><span class="lineNum">     595 </span>            : </a>
<span class="lineNum">     596 </span>            : //__________________________________________________________________________
<span class="lineNum">     597 </span>            : void AliMFTTrackExtrap::RecoverTrackParam(Double_t *v3, Double_t charge, AliMFTTrackParam* trackParam)
<span class="lineNum">     598 </span>            : {
<span class="lineNum">     599 </span>            :   /// Set track parameters in trackParam from Geant3 parameters pointed to by &quot;v3&quot;,
<span class="lineNum">     600 </span>            :   /// assumed to be calculated for forward motion in Z.
<span class="lineNum">     601 </span>            :   /// &quot;InverseBendingMomentum&quot; is signed with &quot;charge&quot;.
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :   trackParam-&gt;SetX(v3[0]); // X</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :   trackParam-&gt;SetY(v3[1]); // Y</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :   trackParam-&gt;SetZ(v3[2]); // Z</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :         Double_t pt = v3[6]*TMath::Sqrt(1. - v3[5]*v3[5]);</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :         trackParam-&gt;SetInverseTransverseMomentum(charge/pt);</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :         trackParam-&gt;SetSlopeY(v3[4]/v3[5]);</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :         trackParam-&gt;SetSlopeX(v3[3]/v3[5]);</span>
<span class="lineNum">     609 </span>            : //
<span class="lineNum">     610 </span>            : //      trackParam-&gt;SetX(v3[0]); // X
<span class="lineNum">     611 </span>            : //      trackParam-&gt;SetY(v3[1]); // Y
<span class="lineNum">     612 </span>            : //      trackParam-&gt;SetZ(v3[2]); // Z
<span class="lineNum">     613 </span>            : //      Double_t pYZ = v3[6] * TMath::Sqrt((1.-v3[3])*(1.+v3[3]));
<span class="lineNum">     614 </span>            : //      trackParam-&gt;SetInverseMomentum(charge/pYZ);
<span class="lineNum">     615 </span>            : //      trackParam-&gt;SetSlopeY(v3[4]/v3[5]);
<span class="lineNum">     616 </span>            : //      trackParam-&gt;SetSlopeX(v3[3]/v3[5]);
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span><span class="lineNoCov">          0 : }</span>
<a name="619"><span class="lineNum">     619 </span>            : </a>
<span class="lineNum">     620 </span>            : //__________________________________________________________________________
<span class="lineNum">     621 </span>            : Bool_t AliMFTTrackExtrap::ExtrapToZCov(AliMFTTrackParam* trackParam, Double_t zEnd, Bool_t updatePropagator)
<span class="lineNum">     622 </span>            : {
<span class="lineNum">     623 </span>            :   /// Track parameters and their covariances extrapolated to the plane at &quot;zEnd&quot;.
<span class="lineNum">     624 </span>            :   /// On return, results from the extrapolation are updated in trackParam.
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :   if (trackParam-&gt;GetZ() == zEnd) return kTRUE; // nothing to be done if same z</span>
<span class="lineNum">     626 </span>            :         
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :   if (!fgFieldON) { // linear extrapolation if no magnetic field</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :     AliMFTTrackExtrap::LinearExtrapToZCov(trackParam,zEnd,updatePropagator);</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :     return kTRUE;</span>
<span class="lineNum">     630 </span>            :   }
<span class="lineNum">     631 </span>            :   
<span class="lineNum">     632 </span>            :   // No need to propagate the covariance matrix if it does not exist
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :   if (!trackParam-&gt;CovariancesExist()) {</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :     cout&lt;&lt;&quot;W-AliMFTTrackExtrap::ExtrapToZCov: Covariance matrix does not exist&quot;&lt;&lt;endl;</span>
<span class="lineNum">     635 </span>            :     // Extrapolate track parameters to &quot;zEnd&quot;
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :     return ExtrapToZ(trackParam,zEnd);</span>
<span class="lineNum">     637 </span>            :   }
<span class="lineNum">     638 </span>            :   
<span class="lineNum">     639 </span>            :   // Save the actual track parameters
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :   AliMFTTrackParam trackParamSave(*trackParam);</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :   TMatrixD paramSave(trackParamSave.GetParameters());</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :   Double_t zBegin = trackParamSave.GetZ();</span>
<span class="lineNum">     643 </span>            : 
<span class="lineNum">     644 </span>            :   // Get reference to the parameter covariance matrix
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :   const TMatrixD&amp; kParamCov = trackParam-&gt;GetCovariances();</span>
<span class="lineNum">     646 </span>            :         
<span class="lineNum">     647 </span>            :   // Extrapolate track parameters to &quot;zEnd&quot;
<span class="lineNum">     648 </span>            :   // Do not update the covariance matrix if the extrapolation failed
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :   if (!ExtrapToZ(trackParam,zEnd)) return kFALSE;</span>
<span class="lineNum">     650 </span>            :         
<span class="lineNum">     651 </span>            :   // Get reference to the extrapolated parameters
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :   const TMatrixD&amp; extrapParam = trackParam-&gt;GetParameters();</span>
<span class="lineNum">     653 </span>            :   
<span class="lineNum">     654 </span>            :   // Calculate the jacobian related to the track parameters extrapolation to &quot;zEnd&quot;
<span class="lineNum">     655 </span>            :   Bool_t extrapStatus = kTRUE;
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :   TMatrixD jacob(5,5);</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :   jacob.Zero();</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :   TMatrixD dParam(5,1);</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :   Double_t direction[5] = {-1.,-1.,1.,1.,-1.};</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;5; i++) {</span>
<span class="lineNum">     661 </span>            :     // Skip jacobian calculation for parameters with no associated error
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :     if (kParamCov(i,i) &lt;= 0.) continue;</span>
<span class="lineNum">     663 </span>            :     
<span class="lineNum">     664 </span>            :     // Small variation of parameter i only
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :                 for (Int_t j=0; j&lt;5; j++) {</span>
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :                         if (j==i) {</span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :                                 dParam(j,0) = TMath::Sqrt(kParamCov(i,i));</span>
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :                                 dParam(j,0) *= TMath::Sign(1.,direction[j]*paramSave(j,0)); // variation always in the same direction</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :                         } else dParam(j,0) = 0.;</span>
<span class="lineNum">     670 </span>            :                 }
<span class="lineNum">     671 </span>            :     // Set new parameters
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :     trackParamSave.SetParameters(paramSave);</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :     trackParamSave.AddParameters(dParam);</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :     trackParamSave.SetZ(zBegin);</span>
<span class="lineNum">     675 </span>            :     // Extrapolate new track parameters to &quot;zEnd&quot;
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :     if (!ExtrapToZ(&amp;trackParamSave,zEnd)) {</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :       cout&lt;&lt;&quot;W-AliMFTTrackExtrap::ExtrapToZCov: Bad covariance matrix&quot;&lt;&lt;endl;</span>
<span class="lineNum">     678 </span>            :       extrapStatus = kFALSE;
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     680 </span>            : 
<span class="lineNum">     681 </span>            :     // Calculate the jacobian
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :     TMatrixD jacobji(trackParamSave.GetParameters(),TMatrixD::kMinus,extrapParam);</span>
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :     jacobji *= 1. / dParam(i,0);</span>
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :    jacob.SetSub(0,i,jacobji);</span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :         cout&lt;&lt;&quot;jacob&quot;&lt;&lt;endl;</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :         jacob.Print();</span>
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span>            :   // Extrapolate track parameter covariances to &quot;zEnd&quot;
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :         cout&lt;&lt;&quot;Initial Cov MAtrix &quot;&lt;&lt;endl;</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :         kParamCov.Print();</span>
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :   TMatrixD tmp(kParamCov,TMatrixD::kMultTranspose,jacob);</span>
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :   TMatrixD tmp2(jacob,TMatrixD::kMult,tmp);</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :         cout&lt;&lt;&quot;Extrapolated Cov MAtrix &quot;&lt;&lt;endl;</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :         tmp2.Print();</span>
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :   trackParam-&gt;SetCovariances(tmp2);</span>
<span class="lineNum">     699 </span>            :   // Update the propagator if required
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :   if (updatePropagator) trackParam-&gt;UpdatePropagator(jacob);</span>
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span>            : //  return extrapStatus;
<span class="lineNum">     703 </span>            :         return kTRUE;
<span class="lineNum">     704 </span><span class="lineNoCov">          0 : }</span>
<a name="705"><span class="lineNum">     705 </span>            : </a>
<span class="lineNum">     706 </span>            : ////__________________________________________________________________________
<span class="lineNum">     707 </span>            : void AliMFTTrackExtrap::AddMCSEffectInAbsorber(AliMFTTrackParam* param, Double_t signedPathLength, Double_t f0, Double_t f1, Double_t f2)
<span class="lineNum">     708 </span>            : {
<span class="lineNum">     709 </span>            :   /// Add to the track parameter covariances the effects of multiple Coulomb scattering
<span class="lineNum">     710 </span>            :   /// signedPathLength must have the sign of (zOut - zIn) where all other parameters are assumed to be given at zOut.
<span class="lineNum">     711 </span>            : //
<span class="lineNum">     712 </span>            : //  // absorber related covariance parameters
<span class="lineNum">     713 </span>            : //  Double_t bendingSlope = param-&gt;GetSlopeY();
<span class="lineNum">     714 </span>            : //  Double_t nonBendingSlope = param-&gt;GetSlopeX();
<span class="lineNum">     715 </span>            : //  Double_t inverseBendingMomentum = param-&gt;GetInverseMomentum();
<span class="lineNum">     716 </span>            : //  Double_t alpha2 = 0.0136 * 0.0136 * inverseBendingMomentum * inverseBendingMomentum * (1.0 + bendingSlope * bendingSlope) /
<span class="lineNum">     717 </span>            : //                    (1.0 + bendingSlope *bendingSlope + nonBendingSlope * nonBendingSlope); // velocity = 1
<span class="lineNum">     718 </span>            : //  Double_t pathLength = TMath::Abs(signedPathLength);
<span class="lineNum">     719 </span>            : //  Double_t varCoor = alpha2 * (pathLength * pathLength * f0 - 2. * pathLength * f1 + f2);
<span class="lineNum">     720 </span>            : //  Double_t covCorrSlope = TMath::Sign(1.,signedPathLength) * alpha2 * (pathLength * f0 - f1);
<span class="lineNum">     721 </span>            : //  Double_t varSlop = alpha2 * f0;
<span class="lineNum">     722 </span>            : //  
<span class="lineNum">     723 </span>            : //  // Set MCS covariance matrix
<span class="lineNum">     724 </span>            : //  TMatrixD newParamCov(param-&gt;GetCovariances());
<span class="lineNum">     725 </span>            : //  // Non bending plane
<span class="lineNum">     726 </span>            : //  newParamCov(0,0) += varCoor;       newParamCov(0,1) += covCorrSlope;
<span class="lineNum">     727 </span>            : //  newParamCov(1,0) += covCorrSlope;  newParamCov(1,1) += varSlop;
<span class="lineNum">     728 </span>            : //  // Bending plane
<span class="lineNum">     729 </span>            : //  newParamCov(2,2) += varCoor;       newParamCov(2,3) += covCorrSlope;
<span class="lineNum">     730 </span>            : //  newParamCov(3,2) += covCorrSlope;  newParamCov(3,3) += varSlop;
<span class="lineNum">     731 </span>            : //  
<span class="lineNum">     732 </span>            : //  // Set momentum related covariances if B!=0
<span class="lineNum">     733 </span>            : //  if (fgFieldON) {
<span class="lineNum">     734 </span>            : //    // compute derivative d(q/Pxy) / dSlopeX and d(q/Pxy) / dSlopeY
<span class="lineNum">     735 </span>            : //    Double_t dqPxydSlopeX = inverseBendingMomentum * nonBendingSlope / (1. + nonBendingSlope*nonBendingSlope + bendingSlope*bendingSlope);
<span class="lineNum">     736 </span>            : //    Double_t dqPxydSlopeY = - inverseBendingMomentum * nonBendingSlope*nonBendingSlope * bendingSlope /
<span class="lineNum">     737 </span>            : //                              (1. + bendingSlope*bendingSlope) / (1. + nonBendingSlope*nonBendingSlope + bendingSlope*bendingSlope);
<span class="lineNum">     738 </span>            : //    // Inverse bending momentum (due to dependences with bending and non bending slopes)
<span class="lineNum">     739 </span>            : //    newParamCov(4,0) += dqPxydSlopeX * covCorrSlope; newParamCov(0,4) += dqPxydSlopeX * covCorrSlope;
<span class="lineNum">     740 </span>            : //    newParamCov(4,1) += dqPxydSlopeX * varSlop;      newParamCov(1,4) += dqPxydSlopeX * varSlop;
<span class="lineNum">     741 </span>            : //    newParamCov(4,2) += dqPxydSlopeY * covCorrSlope; newParamCov(2,4) += dqPxydSlopeY * covCorrSlope;
<span class="lineNum">     742 </span>            : //    newParamCov(4,3) += dqPxydSlopeY * varSlop;      newParamCov(3,4) += dqPxydSlopeY * varSlop;
<span class="lineNum">     743 </span>            : //    newParamCov(4,4) += (dqPxydSlopeX*dqPxydSlopeX + dqPxydSlopeY*dqPxydSlopeY) * varSlop;
<span class="lineNum">     744 </span>            : //  }
<span class="lineNum">     745 </span>            : //  
<span class="lineNum">     746 </span>            : //  // Set new covariances
<span class="lineNum">     747 </span>            : //  param-&gt;SetCovariances(newParamCov);
<span class="lineNum">     748 </span><span class="lineNoCov">          0 : }</span>
<a name="749"><span class="lineNum">     749 </span>            : </a>
<span class="lineNum">     750 </span>            : //__________________________________________________________________________
<span class="lineNum">     751 </span>            : void AliMFTTrackExtrap::CorrectMCSEffectInAbsorber(AliMFTTrackParam* param,
<span class="lineNum">     752 </span>            :                                                     Double_t xVtx, Double_t yVtx, Double_t zVtx,
<span class="lineNum">     753 </span>            :                                                     Double_t errXVtx, Double_t errYVtx,
<span class="lineNum">     754 </span>            :                                                     Double_t absZBeg, Double_t pathLength, Double_t f0, Double_t f1, Double_t f2)
<span class="lineNum">     755 </span>            : {
<span class="lineNum">     756 </span>            : //  /// Correct parameters and corresponding covariances using Branson correction
<span class="lineNum">     757 </span>            : //  /// - input param are parameters and covariances at the end of absorber
<span class="lineNum">     758 </span>            : //  /// - output param are parameters and covariances at vertex
<span class="lineNum">     759 </span>            : //  /// Absorber correction parameters are supposed to be calculated at the current track z-position
<span class="lineNum">     760 </span>            : //  
<span class="lineNum">     761 </span>            : //  // Position of the Branson plane (spectro. (z&lt;0))
<span class="lineNum">     762 </span>            : //  Double_t zB = (f1&gt;0.) ? absZBeg - f2/f1 : 0.;
<span class="lineNum">     763 </span>            : //  
<span class="lineNum">     764 </span>            : //  // Add MCS effects to current parameter covariances (spectro. (z&lt;0))
<span class="lineNum">     765 </span>            : //  AddMCSEffectInAbsorber(param, -pathLength, f0, f1, f2);
<span class="lineNum">     766 </span>            : //  
<span class="lineNum">     767 </span>            : //  // Get track parameters and covariances in the Branson plane corrected for magnetic field effect
<span class="lineNum">     768 </span>            : //  ExtrapToZCov(param,zVtx);
<span class="lineNum">     769 </span>            : //  LinearExtrapToZCov(param,zB);
<span class="lineNum">     770 </span>            : //  
<span class="lineNum">     771 </span>            : //  // compute track parameters at vertex
<span class="lineNum">     772 </span>            : //  TMatrixD newParam(5,1);
<span class="lineNum">     773 </span>            : //  newParam(0,0) = xVtx;
<span class="lineNum">     774 </span>            : //  newParam(1,0) = (param-&gt;GetX() - xVtx) / (zB - zVtx);
<span class="lineNum">     775 </span>            : //  newParam(2,0) = yVtx;
<span class="lineNum">     776 </span>            : //  newParam(3,0) = (param-&gt;GetY() - yVtx) / (zB - zVtx);
<span class="lineNum">     777 </span>            : //  newParam(4,0) = param-&gt;GetCharge() / param-&gt;P() *
<span class="lineNum">     778 </span>            : //                  TMath::Sqrt(1.0 + newParam(1,0)*newParam(1,0) + newParam(3,0)*newParam(3,0)) /
<span class="lineNum">     779 </span>            : //                TMath::Sqrt(1.0 + newParam(3,0)*newParam(3,0));
<span class="lineNum">     780 </span>            : //  
<span class="lineNum">     781 </span>            : //  // Get covariances in (X, SlopeX, Y, SlopeY, q*PTot) coordinate system
<span class="lineNum">     782 </span>            : //  TMatrixD paramCovP(param-&gt;GetCovariances());
<span class="lineNum">     783 </span>            : //  Cov2CovP(param-&gt;GetParameters(),paramCovP);
<span class="lineNum">     784 </span>            : //  
<span class="lineNum">     785 </span>            : //  // Get the covariance matrix in the (XVtx, X, YVtx, Y, q*PTot) coordinate system
<span class="lineNum">     786 </span>            : //  TMatrixD paramCovVtx(5,5);
<span class="lineNum">     787 </span>            : //  paramCovVtx.Zero();
<span class="lineNum">     788 </span>            : //  paramCovVtx(0,0) = errXVtx * errXVtx;
<span class="lineNum">     789 </span>            : //  paramCovVtx(1,1) = paramCovP(0,0);
<span class="lineNum">     790 </span>            : //  paramCovVtx(2,2) = errYVtx * errYVtx;
<span class="lineNum">     791 </span>            : //  paramCovVtx(3,3) = paramCovP(2,2);
<span class="lineNum">     792 </span>            : //  paramCovVtx(4,4) = paramCovP(4,4);
<span class="lineNum">     793 </span>            : //  paramCovVtx(1,3) = paramCovP(0,2);
<span class="lineNum">     794 </span>            : //  paramCovVtx(3,1) = paramCovP(2,0);
<span class="lineNum">     795 </span>            : //  paramCovVtx(1,4) = paramCovP(0,4);
<span class="lineNum">     796 </span>            : //  paramCovVtx(4,1) = paramCovP(4,0);
<span class="lineNum">     797 </span>            : //  paramCovVtx(3,4) = paramCovP(2,4);
<span class="lineNum">     798 </span>            : //  paramCovVtx(4,3) = paramCovP(4,2);
<span class="lineNum">     799 </span>            : //  
<span class="lineNum">     800 </span>            : //  // Jacobian of the transformation (XVtx, X, YVtx, Y, q*PTot) -&gt; (XVtx, SlopeXVtx, YVtx, SlopeYVtx, q*PTotVtx)
<span class="lineNum">     801 </span>            : //  TMatrixD jacob(5,5);
<span class="lineNum">     802 </span>            : //  jacob.UnitMatrix();
<span class="lineNum">     803 </span>            : //  jacob(1,0) = - 1. / (zB - zVtx);
<span class="lineNum">     804 </span>            : //  jacob(1,1) = 1. / (zB - zVtx);
<span class="lineNum">     805 </span>            : //  jacob(3,2) = - 1. / (zB - zVtx);
<span class="lineNum">     806 </span>            : //  jacob(3,3) = 1. / (zB - zVtx);
<span class="lineNum">     807 </span>            : //  
<span class="lineNum">     808 </span>            : //  // Compute covariances at vertex in the (XVtx, SlopeXVtx, YVtx, SlopeYVtx, q*PTotVtx) coordinate system
<span class="lineNum">     809 </span>            : //  TMatrixD tmp(paramCovVtx,TMatrixD::kMultTranspose,jacob);
<span class="lineNum">     810 </span>            : //  TMatrixD newParamCov(jacob,TMatrixD::kMult,tmp);
<span class="lineNum">     811 </span>            : //  
<span class="lineNum">     812 </span>            : //  // Compute covariances at vertex in the (XVtx, SlopeXVtx, YVtx, SlopeYVtx, q/PyzVtx) coordinate system
<span class="lineNum">     813 </span>            : //  CovP2Cov(newParam,newParamCov);
<span class="lineNum">     814 </span>            : //  
<span class="lineNum">     815 </span>            : //  // Set parameters and covariances at vertex
<span class="lineNum">     816 </span>            : //  param-&gt;SetParameters(newParam);
<span class="lineNum">     817 </span>            : //  param-&gt;SetZ(zVtx);
<span class="lineNum">     818 </span>            : //  param-&gt;SetCovariances(newParamCov);
<span class="lineNum">     819 </span><span class="lineNoCov">          0 : }</span>
<a name="820"><span class="lineNum">     820 </span>            : </a>
<span class="lineNum">     821 </span>            : //__________________________________________________________________________
<span class="lineNum">     822 </span>            : void AliMFTTrackExtrap::CorrectELossEffectInAbsorber(AliMFTTrackParam* param, Double_t eLoss, Double_t sigmaELoss2)
<span class="lineNum">     823 </span>            : {
<span class="lineNum">     824 </span>            :   /// Correct parameters for energy loss and add energy loss fluctuation effect to covariances
<span class="lineNum">     825 </span>            :   
<span class="lineNum">     826 </span>            : //  // Get parameter covariances in (X, SlopeX, Y, SlopeY, q*PTot) coordinate system
<span class="lineNum">     827 </span>            : //  TMatrixD newParamCov(param-&gt;GetCovariances());
<span class="lineNum">     828 </span>            : //  Cov2CovP(param-&gt;GetParameters(),newParamCov);
<span class="lineNum">     829 </span>            : //  
<span class="lineNum">     830 </span>            : //  // Compute new parameters corrected for energy loss
<span class="lineNum">     831 </span>            : //  Double_t muMass = TDatabasePDG::Instance()-&gt;GetParticle(&quot;mu-&quot;)-&gt;Mass(); // GeV
<span class="lineNum">     832 </span>            : //  Double_t p = param-&gt;P();
<span class="lineNum">     833 </span>            : //  Double_t e = TMath::Sqrt(p*p + muMass*muMass);
<span class="lineNum">     834 </span>            : //  Double_t eCorr = e + eLoss;
<span class="lineNum">     835 </span>            : //  Double_t pCorr = TMath::Sqrt(eCorr*eCorr - muMass*muMass);
<span class="lineNum">     836 </span>            : //  Double_t nonBendingSlope = param-&gt;GetSlopeX();
<span class="lineNum">     837 </span>            : //  Double_t bendingSlope = param-&gt;GetSlopeY();
<span class="lineNum">     838 </span>            : //  param-&gt;SetInverseMomentum(param-&gt;GetCharge() / pCorr *
<span class="lineNum">     839 </span>            : //                                 TMath::Sqrt(1.0 + nonBendingSlope*nonBendingSlope + bendingSlope*bendingSlope) /
<span class="lineNum">     840 </span>            : //                                 TMath::Sqrt(1.0 + bendingSlope*bendingSlope));
<span class="lineNum">     841 </span>            : //  
<span class="lineNum">     842 </span>            : //  // Add effects of energy loss fluctuation to covariances
<span class="lineNum">     843 </span>            : //  newParamCov(4,4) += eCorr * eCorr / pCorr / pCorr * sigmaELoss2;
<span class="lineNum">     844 </span>            : //  
<span class="lineNum">     845 </span>            : //  // Get new parameter covariances in (X, SlopeX, Y, SlopeY, q/Pyz) coordinate system
<span class="lineNum">     846 </span>            : //  CovP2Cov(param-&gt;GetParameters(),newParamCov);
<span class="lineNum">     847 </span>            : //  
<span class="lineNum">     848 </span>            : //  // Set new parameter covariances
<span class="lineNum">     849 </span>            : //  param-&gt;SetCovariances(newParamCov);
<span class="lineNum">     850 </span><span class="lineNoCov">          0 : }</span>
<a name="851"><span class="lineNum">     851 </span>            : </a>
<span class="lineNum">     852 </span>            : //__________________________________________________________________________
<span class="lineNum">     853 </span>            : Bool_t AliMFTTrackExtrap::GetAbsorberCorrectionParam(Double_t trackXYZIn[3], Double_t trackXYZOut[3], Double_t pTotal,
<span class="lineNum">     854 </span>            :                                                       Double_t &amp;pathLength, Double_t &amp;f0, Double_t &amp;f1, Double_t &amp;f2,
<span class="lineNum">     855 </span>            :                                                       Double_t &amp;meanRho, Double_t &amp;totalELoss, Double_t &amp;sigmaELoss2)
<span class="lineNum">     856 </span>            : {
<span class="lineNum">     857 </span>            :   /// Parameters used to correct for Multiple Coulomb Scattering and energy loss in absorber
<span class="lineNum">     858 </span>            :   /// Calculated assuming a linear propagation from trackXYZIn to trackXYZOut (order is important)
<span class="lineNum">     859 </span>            :   // pathLength: path length between trackXYZIn and trackXYZOut (cm)
<span class="lineNum">     860 </span>            :   // f0:         0th moment of z calculated with the inverse radiation-length distribution
<span class="lineNum">     861 </span>            :   // f1:         1st moment of z calculated with the inverse radiation-length distribution
<span class="lineNum">     862 </span>            :   // f2:         2nd moment of z calculated with the inverse radiation-length distribution
<span class="lineNum">     863 </span>            :   // meanRho:    average density of crossed material (g/cm3)
<span class="lineNum">     864 </span>            :   // totalELoss: total energy loss in absorber
<span class="lineNum">     865 </span>            :   
<span class="lineNum">     866 </span>            :   // Reset absorber's parameters
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :   pathLength = 0.;</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :   f0 = 0.;</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :   f1 = 0.;</span>
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :   f2 = 0.;</span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :   meanRho = 0.;</span>
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :   totalELoss = 0.;</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :   sigmaELoss2 = 0.;</span>
<span class="lineNum">     874 </span>            :   
<span class="lineNum">     875 </span>            :   // Check whether the geometry is available
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :   if (!gGeoManager) {</span>
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :     cout&lt;&lt;&quot;E-AliMFTTrackExtrap::GetAbsorberCorrectionParam: no TGeo&quot;&lt;&lt;endl;</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">     879 </span>            :   }
<span class="lineNum">     880 </span>            :   
<span class="lineNum">     881 </span>            :   // Initialize starting point and direction
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :   pathLength = TMath::Sqrt((trackXYZOut[0] - trackXYZIn[0])*(trackXYZOut[0] - trackXYZIn[0])+</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :                            (trackXYZOut[1] - trackXYZIn[1])*(trackXYZOut[1] - trackXYZIn[1])+</span>
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :                            (trackXYZOut[2] - trackXYZIn[2])*(trackXYZOut[2] - trackXYZIn[2]));</span>
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :   if (pathLength &lt; TGeoShape::Tolerance()) return kFALSE;</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :   Double_t b[3];</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :   b[0] = (trackXYZOut[0] - trackXYZIn[0]) / pathLength;</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :   b[1] = (trackXYZOut[1] - trackXYZIn[1]) / pathLength;</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :   b[2] = (trackXYZOut[2] - trackXYZIn[2]) / pathLength;</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :   TGeoNode *currentnode = gGeoManager-&gt;InitTrack(trackXYZIn, b);</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :   if (!currentnode) {</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :     cout&lt;&lt;&quot;E-AliMFTTrackExtrap::GetAbsorberCorrectionParam: start point out of geometry&quot;&lt;&lt;endl;</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">     894 </span>            :   }
<span class="lineNum">     895 </span>            :   
<span class="lineNum">     896 </span>            :   // loop over absorber slices and calculate absorber's parameters
<span class="lineNum">     897 </span>            :   Double_t rho = 0.; // material density (g/cm3)
<span class="lineNum">     898 </span>            :   Double_t x0 = 0.;  // radiation-length (cm-1)
<span class="lineNum">     899 </span>            :   Double_t atomicA = 0.; // A of material
<span class="lineNum">     900 </span>            :   Double_t atomicZ = 0.; // Z of material
<span class="lineNum">     901 </span>            :   Double_t atomicZoverA = 0.; // Z/A of material
<span class="lineNum">     902 </span>            :   Double_t localPathLength = 0;
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :   Double_t remainingPathLength = pathLength;</span>
<span class="lineNum">     904 </span>            :   Double_t sigmaELoss = 0.;
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :   Double_t zB = trackXYZIn[2];</span>
<span class="lineNum">     906 </span>            :   Double_t zE, dzB, dzE;
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :   do {</span>
<span class="lineNum">     908 </span>            :     // Get material properties
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :     TGeoMaterial *material = currentnode-&gt;GetVolume()-&gt;GetMedium()-&gt;GetMaterial();</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :     rho = material-&gt;GetDensity();</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :     x0 = material-&gt;GetRadLen();</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :     atomicA = material-&gt;GetA();</span>
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :     atomicZ = material-&gt;GetZ();</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :     if(material-&gt;IsMixture()){</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :       TGeoMixture * mixture = (TGeoMixture*)material;</span>
<span class="lineNum">     916 </span>            :       atomicZoverA = 0.;
<span class="lineNum">     917 </span>            :       Double_t sum = 0.;
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :       for (Int_t iel=0;iel&lt;mixture-&gt;GetNelements();iel++){</span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :         sum  += mixture-&gt;GetWmixt()[iel];</span>
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :         atomicZoverA += mixture-&gt;GetZmixt()[iel]*mixture-&gt;GetWmixt()[iel]/mixture-&gt;GetAmixt()[iel];</span>
<span class="lineNum">     921 </span>            :       }
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :       atomicZoverA/=sum;</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :     else atomicZoverA = atomicZ/atomicA;</span>
<span class="lineNum">     925 </span>            :     
<span class="lineNum">     926 </span>            :     // Get path length within this material
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :     gGeoManager-&gt;FindNextBoundary(remainingPathLength);</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :     localPathLength = gGeoManager-&gt;GetStep() + 1.e-6;</span>
<span class="lineNum">     929 </span>            :     // Check if boundary within remaining path length. If so, make sure to cross the boundary to prepare the next step
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :     if (localPathLength &gt;= remainingPathLength) localPathLength = remainingPathLength;</span>
<span class="lineNum">     931 </span>            :     else {
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :       currentnode = gGeoManager-&gt;Step();</span>
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :       if (!currentnode) {</span>
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :         cout&lt;&lt;&quot;E-AliMFTTrackExtrap::GetAbsorberCorrectionParam: navigation failed&quot;&lt;&lt;endl;</span>
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :         f0 = f1 = f2 = meanRho = totalELoss = sigmaELoss2 = 0.;</span>
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :         return kFALSE;</span>
<span class="lineNum">     937 </span>            :       }
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :       if (!gGeoManager-&gt;IsEntering()) {</span>
<span class="lineNum">     939 </span>            :         // make another small step to try to enter in new absorber slice
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :         gGeoManager-&gt;SetStep(0.001);</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :         currentnode = gGeoManager-&gt;Step();</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :         if (!gGeoManager-&gt;IsEntering() || !currentnode) {</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :           cout&lt;&lt;&quot;E-AliMFTTrackExtrap::GetAbsorberCorrectionParam: navigation failed&quot;&lt;&lt;endl;</span>
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :           f0 = f1 = f2 = meanRho = totalELoss = sigmaELoss2 = 0.;</span>
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :           return kFALSE;</span>
<span class="lineNum">     946 </span>            :         }
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :         localPathLength += 0.001;</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     949 </span>            :     }
<span class="lineNum">     950 </span>            :     
<span class="lineNum">     951 </span>            :     // calculate absorber's parameters
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :     zE = b[2] * localPathLength + zB;</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :     dzB = zB - trackXYZIn[2];</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :     dzE = zE - trackXYZIn[2];</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :     f0 += localPathLength / x0;</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :     f1 += (dzE*dzE - dzB*dzB) / b[2] / b[2] / x0 / 2.;</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :     f2 += (dzE*dzE*dzE - dzB*dzB*dzB) / b[2] / b[2] / b[2] / x0 / 3.;</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :     meanRho += localPathLength * rho;</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :     totalELoss += BetheBloch(pTotal, localPathLength, rho, atomicZ, atomicZoverA);</span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :     sigmaELoss += EnergyLossFluctuation(pTotal, localPathLength, rho, atomicZoverA);</span>
<span class="lineNum">     961 </span>            :     
<span class="lineNum">     962 </span>            :     // prepare next step
<span class="lineNum">     963 </span>            :     zB = zE;
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :     remainingPathLength -= localPathLength;</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :   } while (remainingPathLength &gt; TGeoShape::Tolerance());</span>
<span class="lineNum">     966 </span>            :   
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :   meanRho /= pathLength;</span>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :   sigmaELoss2 = sigmaELoss*sigmaELoss;</span>
<span class="lineNum">     969 </span>            :   
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :   return kTRUE;</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 : }</span>
<a name="972"><span class="lineNum">     972 </span>            : </a>
<span class="lineNum">     973 </span>            : //__________________________________________________________________________
<span class="lineNum">     974 </span>            : Double_t AliMFTTrackExtrap::GetMCSAngle2(const AliMFTTrackParam&amp; param, Double_t dZ, Double_t x0)
<span class="lineNum">     975 </span>            : {
<span class="lineNum">     976 </span>            :   /// Return the angular dispersion square due to multiple Coulomb scattering
<span class="lineNum">     977 </span>            :   /// through a material of thickness &quot;dZ&quot; and of radiation length &quot;x0&quot;
<span class="lineNum">     978 </span>            :   /// assuming linear propagation and using the small angle approximation.
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :         return 0.;</span>
<span class="lineNum">     980 </span>            : //  Double_t bendingSlope = param.GetSlopeY();
<span class="lineNum">     981 </span>            : //  Double_t nonBendingSlope = param.GetSlopeX();
<span class="lineNum">     982 </span>            : //  Double_t inverseTotalMomentum2 = param.GetInverseMomentum() * param.GetInverseMomentum() *
<span class="lineNum">     983 </span>            : //                                   (1.0 + bendingSlope * bendingSlope) /
<span class="lineNum">     984 </span>            : //                                   (1.0 + bendingSlope *bendingSlope + nonBendingSlope * nonBendingSlope); 
<span class="lineNum">     985 </span>            : //  // Path length in the material
<span class="lineNum">     986 </span>            : //  Double_t pathLength = TMath::Abs(dZ) * TMath::Sqrt(1.0 + bendingSlope*bendingSlope + nonBendingSlope*nonBendingSlope);
<span class="lineNum">     987 </span>            : //  // relativistic velocity
<span class="lineNum">     988 </span>            : //  Double_t velo = 1.;
<span class="lineNum">     989 </span>            : //  // Angular dispersion square of the track (variance) in a plane perpendicular to the trajectory
<span class="lineNum">     990 </span>            : //  Double_t theta02 = 0.0136 / velo * (1 + 0.038 * TMath::Log(pathLength/x0));
<span class="lineNum">     991 </span>            : //  
<span class="lineNum">     992 </span>            : //  return theta02 * theta02 * inverseTotalMomentum2 * pathLength / x0;
<span class="lineNum">     993 </span>            : }
<span class="lineNum">     994 </span>            : 
<span class="lineNum">     995 </span>            : 
<a name="996"><span class="lineNum">     996 </span>            : </a>
<span class="lineNum">     997 </span>            : //__________________________________________________________________________
<span class="lineNum">     998 </span>            : void AliMFTTrackExtrap::AddMCSEffect(AliMFTTrackParam *param, Double_t dZ, Double_t x0)
<span class="lineNum">     999 </span>            : {
<span class="lineNum">    1000 </span>            :   /// Add to the track parameter covariances the effects of multiple Coulomb scattering
<span class="lineNum">    1001 </span>            :   /// through a material of thickness &quot;Abs(dZ)&quot; and of radiation length &quot;x0&quot;
<span class="lineNum">    1002 </span>            :   /// assuming linear propagation and using the small angle approximation.
<span class="lineNum">    1003 </span>            :   /// dZ = zOut - zIn (sign is important) and &quot;param&quot; is assumed to be given zOut.
<span class="lineNum">    1004 </span>            :   /// If x0 &lt;= 0., assume dZ = pathLength/x0 and consider the material thickness as negligible.
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :         Double_t slopeX = param-&gt;GetSlopeX();</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :         Double_t slopeY = param-&gt;GetSlopeY();</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :         Double_t slope2 = slopeX*slopeX+slopeY*slopeY;</span>
<span class="lineNum">    1008 </span>            :         
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :         Double_t inversePt = TMath::Abs(param-&gt;GetInverseTransverseMomentum());</span>
<span class="lineNum">    1010 </span>            : 
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :   Double_t inverseTotalMomentum2 = inversePt*inversePt / (1. + 1./slope2 );</span>
<span class="lineNum">    1012 </span>            :   // Path length in the material
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :         Double_t signedPathLength = dZ * TMath::Sqrt(1.0 + slope2);</span>
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :   Double_t pathLengthOverX0 = (x0 &gt; 0.) ? TMath::Abs(signedPathLength * x0 /dZ) : TMath::Abs(signedPathLength);</span>
<span class="lineNum">    1015 </span>            :   // relativistic velocity
<span class="lineNum">    1016 </span>            :   Double_t velo = 1.;
<span class="lineNum">    1017 </span>            :   // Angular dispersion square of the track (variance) in a plane perpendicular to the trajectory
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :   Double_t theta02 = 0.0136 / velo * (1 + 0.038 * TMath::Log(pathLengthOverX0));</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :   theta02 *= theta02 * inverseTotalMomentum2 * pathLengthOverX0;</span>
<span class="lineNum">    1020 </span>            :  
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :   Double_t varCoor      = (x0 &gt; 0.) ? signedPathLength * signedPathLength * theta02 / 3. : 0.;</span>
<span class="lineNum">    1022 </span>            :   Double_t varSlop      = theta02;
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :         Double_t covCorrSlope = (x0 &gt; 0.) ? signedPathLength * theta02/ 2. : 0.;</span>
<span class="lineNum">    1024 </span>            :         
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :         cout&lt;&lt;Form(&quot;theta02=%e inverseTotalMomentum2=%e signedPathLength=%e pathLengthOverX0=%e   &quot;,theta02,inverseTotalMomentum2,signedPathLength,pathLengthOverX0 )&lt;&lt;endl;</span>
<span class="lineNum">    1026 </span>            : 
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :                 cout&lt;&lt;Form(&quot;dz=%e x0=%e varCoor=%e  varSlop=%e  covCorrSlope=%e &quot;,dZ,x0,varCoor,varSlop,covCorrSlope )&lt;&lt;endl;</span>
<span class="lineNum">    1028 </span>            :   // Set MCS covariance matrix
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :   TMatrixD newParamCov(param-&gt;GetCovariances());</span>
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :         cout&lt;&lt;&quot;Covariance avant MCS&quot;&lt;&lt;endl;</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :         newParamCov.Print();</span>
<span class="lineNum">    1032 </span>            :         // Non bending plane
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :         newParamCov(0,0) += varCoor;       newParamCov(0,2) += covCorrSlope;</span>
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :         newParamCov(2,0) += covCorrSlope;  newParamCov(2,2) += varSlop;</span>
<span class="lineNum">    1035 </span>            :         // Bending plane
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :         newParamCov(1,1) += varCoor;       newParamCov(1,3) += covCorrSlope;</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :         newParamCov(3,1) += covCorrSlope;  newParamCov(3,3) += varSlop;</span>
<span class="lineNum">    1038 </span>            :         
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :         cout&lt;&lt;&quot;Covariance apres MCS&quot;&lt;&lt;endl;</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :         newParamCov.Print();</span>
<span class="lineNum">    1041 </span>            : 
<span class="lineNum">    1042 </span>            : //  // Set momentum related covariances if B!=0
<span class="lineNum">    1043 </span>            : //  if (fgFieldON) {
<span class="lineNum">    1044 </span>            : //    // compute derivative d(q/Pxy) / dSlopeX and d(q/Pxy) / dSlopeY
<span class="lineNum">    1045 </span>            : //    Double_t dqPxydSlopeX = inverseBendingMomentum * nonBendingSlope / (1. + nonBendingSlope*nonBendingSlope + bendingSlope*bendingSlope);
<span class="lineNum">    1046 </span>            : //    Double_t dqPxydSlopeY = - inverseBendingMomentum * nonBendingSlope*nonBendingSlope * bendingSlope /
<span class="lineNum">    1047 </span>            : //                              (1. + bendingSlope*bendingSlope) / (1. + nonBendingSlope*nonBendingSlope + bendingSlope*bendingSlope);
<span class="lineNum">    1048 </span>            : //    // Inverse bending momentum (due to dependences with bending and non bending slopes)
<span class="lineNum">    1049 </span>            : //    newParamCov(4,0) += dqPxydSlopeX * covCorrSlope; newParamCov(0,4) += dqPxydSlopeX * covCorrSlope;
<span class="lineNum">    1050 </span>            : //    newParamCov(4,1) += dqPxydSlopeX * varSlop;      newParamCov(1,4) += dqPxydSlopeX * varSlop;
<span class="lineNum">    1051 </span>            : //    newParamCov(4,2) += dqPxydSlopeY * covCorrSlope; newParamCov(2,4) += dqPxydSlopeY * covCorrSlope;
<span class="lineNum">    1052 </span>            : //    newParamCov(4,3) += dqPxydSlopeY * varSlop;      newParamCov(3,4) += dqPxydSlopeY * varSlop;
<span class="lineNum">    1053 </span>            : //    newParamCov(4,4) += (dqPxydSlopeX*dqPxydSlopeX + dqPxydSlopeY*dqPxydSlopeY) * varSlop;
<span class="lineNum">    1054 </span>            : //  }
<span class="lineNum">    1055 </span>            : //      cout&lt;&lt;&quot;Covariance apres&quot;&lt;&lt;endl;
<span class="lineNum">    1056 </span>            : //      newParamCov.Print();
<span class="lineNum">    1057 </span>            : 
<span class="lineNum">    1058 </span>            :   // Set new covariances
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :   param-&gt;SetCovariances(newParamCov);</span>
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 : }</span>
<a name="1061"><span class="lineNum">    1061 </span>            : </a>
<span class="lineNum">    1062 </span>            : //__________________________________________________________________________
<span class="lineNum">    1063 </span>            : void AliMFTTrackExtrap::ExtrapToVertex(AliMFTTrackParam* trackParam,
<span class="lineNum">    1064 </span>            :                                         Double_t xVtx, Double_t yVtx, Double_t zVtx,
<span class="lineNum">    1065 </span>            :                                         Double_t errXVtx, Double_t errYVtx,
<span class="lineNum">    1066 </span>            :                                         Bool_t correctForMCS, Bool_t correctForEnergyLoss)
<span class="lineNum">    1067 </span>            : {
<span class="lineNum">    1068 </span>            :   /// Main method for extrapolation to the vertex:
<span class="lineNum">    1069 </span>            :   /// Returns the track parameters and covariances resulting from the extrapolation of the current trackParam
<span class="lineNum">    1070 </span>            :   /// Changes parameters and covariances according to multiple scattering and energy loss corrections:
<span class="lineNum">    1071 </span>            :   /// if correctForMCS=kTRUE:  compute parameters using Branson correction and add correction resolution to covariances
<span class="lineNum">    1072 </span>            :   /// if correctForMCS=kFALSE: add parameter dispersion due to MCS in parameter covariances
<span class="lineNum">    1073 </span>            :   /// if correctForEnergyLoss=kTRUE:  correct parameters for energy loss and add energy loss fluctuation to covariances
<span class="lineNum">    1074 </span>            :   /// if correctForEnergyLoss=kFALSE: do nothing about energy loss
<span class="lineNum">    1075 </span>            :   
<span class="lineNum">    1076 </span>            : //  if (trackParam-&gt;GetZ() == zVtx) return; // nothing to be done if already at vertex
<span class="lineNum">    1077 </span>            : //  
<span class="lineNum">    1078 </span>            : //  if (trackParam-&gt;GetZ() &gt; zVtx) { // spectro. (z&lt;0)
<span class="lineNum">    1079 </span>            : //    cout&lt;&lt;&quot;E-AliMFTTrackExtrap::ExtrapToVertex: Starting Z (&quot;&lt;&lt;trackParam-&gt;GetZ()
<span class="lineNum">    1080 </span>            : //        &lt;&lt;&quot;) upstream the vertex (zVtx = &quot;&lt;&lt;zVtx&lt;&lt;&quot;)&quot;&lt;&lt;endl;
<span class="lineNum">    1081 </span>            : //    return;
<span class="lineNum">    1082 </span>            : //  }
<span class="lineNum">    1083 </span>            : //  
<span class="lineNum">    1084 </span>            : //  // Check the vertex position relatively to the absorber
<span class="lineNum">    1085 </span>            : //  if (zVtx &lt; AliMUONConstants::AbsZBeg() &amp;&amp; zVtx &gt; AliMUONConstants::AbsZEnd()) { // spectro. (z&lt;0)
<span class="lineNum">    1086 </span>            : //    cout&lt;&lt;&quot;W-AliMFTTrackExtrap::ExtrapToVertex: Ending Z (&quot;&lt;&lt;zVtx
<span class="lineNum">    1087 </span>            : //        &lt;&lt;&quot;) inside the front absorber (&quot;&lt;&lt;AliMUONConstants::AbsZBeg()&lt;&lt;&quot;,&quot;&lt;&lt;AliMUONConstants::AbsZEnd()&lt;&lt;&quot;)&quot;&lt;&lt;endl;
<span class="lineNum">    1088 </span>            : //  } else if (zVtx &lt; AliMUONConstants::AbsZEnd() ) { // spectro. (z&lt;0)
<span class="lineNum">    1089 </span>            : //    cout&lt;&lt;&quot;W-AliMFTTrackExtrap::ExtrapToVertex: Ending Z (&quot;&lt;&lt;zVtx
<span class="lineNum">    1090 </span>            : //        &lt;&lt;&quot;) downstream the front absorber (zAbsorberEnd = &quot;&lt;&lt;AliMUONConstants::AbsZEnd()&lt;&lt;&quot;)&quot;&lt;&lt;endl;
<span class="lineNum">    1091 </span>            : //    if (trackParam-&gt;CovariancesExist()) ExtrapToZCov(trackParam,zVtx);
<span class="lineNum">    1092 </span>            : //    else ExtrapToZ(trackParam,zVtx);
<span class="lineNum">    1093 </span>            : //    return;
<span class="lineNum">    1094 </span>            : //  }
<span class="lineNum">    1095 </span>            : //  
<span class="lineNum">    1096 </span>            : //  // Check the track position relatively to the absorber and extrapolate track parameters to the end of the absorber if needed
<span class="lineNum">    1097 </span>            : //  if (trackParam-&gt;GetZ() &gt; AliMUONConstants::AbsZBeg()) { // spectro. (z&lt;0)
<span class="lineNum">    1098 </span>            : //    cout&lt;&lt;&quot;W-AliMFTTrackExtrap::ExtrapToVertex: Starting Z (&quot;&lt;&lt;trackParam-&gt;GetZ()
<span class="lineNum">    1099 </span>            : //        &lt;&lt;&quot;) upstream the front absorber (zAbsorberBegin = &quot;&lt;&lt;AliMUONConstants::AbsZBeg()&lt;&lt;&quot;)&quot;&lt;&lt;endl;
<span class="lineNum">    1100 </span>            : //    if (trackParam-&gt;CovariancesExist()) ExtrapToZCov(trackParam,zVtx);
<span class="lineNum">    1101 </span>            : //    else ExtrapToZ(trackParam,zVtx);
<span class="lineNum">    1102 </span>            : //    return;
<span class="lineNum">    1103 </span>            : //  } else if (trackParam-&gt;GetZ() &gt; AliMUONConstants::AbsZEnd()) { // spectro. (z&lt;0)
<span class="lineNum">    1104 </span>            : //    cout&lt;&lt;&quot;W-AliMFTTrackExtrap::ExtrapToVertex: Starting Z (&quot;&lt;&lt;trackParam-&gt;GetZ()
<span class="lineNum">    1105 </span>            : //        &lt;&lt;&quot;) inside the front absorber (&quot;&lt;&lt;AliMUONConstants::AbsZBeg()&lt;&lt;&quot;,&quot;&lt;&lt;AliMUONConstants::AbsZEnd()&lt;&lt;&quot;)&quot;&lt;&lt;endl;
<span class="lineNum">    1106 </span>            : //  } else {
<span class="lineNum">    1107 </span>            : //    if (trackParam-&gt;CovariancesExist()) ExtrapToZCov(trackParam,AliMUONConstants::AbsZEnd());
<span class="lineNum">    1108 </span>            : //    else ExtrapToZ(trackParam,AliMUONConstants::AbsZEnd());
<span class="lineNum">    1109 </span>            : //  }
<span class="lineNum">    1110 </span>            : //  
<span class="lineNum">    1111 </span>            : //  // Get absorber correction parameters assuming linear propagation in absorber
<span class="lineNum">    1112 </span>            : //  Double_t trackXYZOut[3];
<span class="lineNum">    1113 </span>            : //  trackXYZOut[0] = trackParam-&gt;GetX();
<span class="lineNum">    1114 </span>            : //  trackXYZOut[1] = trackParam-&gt;GetY();
<span class="lineNum">    1115 </span>            : //  trackXYZOut[2] = trackParam-&gt;GetZ();
<span class="lineNum">    1116 </span>            : //  Double_t trackXYZIn[3];
<span class="lineNum">    1117 </span>            : //  if (correctForMCS) { // assume linear propagation until the vertex
<span class="lineNum">    1118 </span>            : //    trackXYZIn[2] = TMath::Min(zVtx, AliMUONConstants::AbsZBeg()); // spectro. (z&lt;0)
<span class="lineNum">    1119 </span>            : //    trackXYZIn[0] = trackXYZOut[0] + (xVtx - trackXYZOut[0]) / (zVtx - trackXYZOut[2]) * (trackXYZIn[2] - trackXYZOut[2]);
<span class="lineNum">    1120 </span>            : //    trackXYZIn[1] = trackXYZOut[1] + (yVtx - trackXYZOut[1]) / (zVtx - trackXYZOut[2]) * (trackXYZIn[2] - trackXYZOut[2]);
<span class="lineNum">    1121 </span>            : //  } else {
<span class="lineNum">    1122 </span>            : //    AliMFTTrackParam trackParamIn(*trackParam);
<span class="lineNum">    1123 </span>            : //    ExtrapToZ(&amp;trackParamIn, TMath::Min(zVtx, AliMUONConstants::AbsZBeg()));
<span class="lineNum">    1124 </span>            : //    trackXYZIn[0] = trackParamIn.GetX();
<span class="lineNum">    1125 </span>            : //    trackXYZIn[1] = trackParamIn.GetY();
<span class="lineNum">    1126 </span>            : //    trackXYZIn[2] = trackParamIn.GetZ();
<span class="lineNum">    1127 </span>            : //  }
<span class="lineNum">    1128 </span>            : //  Double_t pTot = trackParam-&gt;P();
<span class="lineNum">    1129 </span>            : //  Double_t pathLength, f0, f1, f2, meanRho, totalELoss, sigmaELoss2;
<span class="lineNum">    1130 </span>            : //  if (!GetAbsorberCorrectionParam(trackXYZIn,trackXYZOut,pTot,pathLength,f0,f1,f2,meanRho,totalELoss,sigmaELoss2)) {
<span class="lineNum">    1131 </span>            : //    cout&lt;&lt;&quot;E-AliMFTTrackExtrap::ExtrapToVertex: Unable to take into account the absorber effects&quot;&lt;&lt;endl;
<span class="lineNum">    1132 </span>            : //    if (trackParam-&gt;CovariancesExist()) ExtrapToZCov(trackParam,zVtx);
<span class="lineNum">    1133 </span>            : //    else ExtrapToZ(trackParam,zVtx);
<span class="lineNum">    1134 </span>            : //    return;
<span class="lineNum">    1135 </span>            : //  }
<span class="lineNum">    1136 </span>            : //  
<span class="lineNum">    1137 </span>            : //  // Compute track parameters and covariances at vertex according to correctForMCS and correctForEnergyLoss flags
<span class="lineNum">    1138 </span>            : //  if (correctForMCS) {
<span class="lineNum">    1139 </span>            : //    
<span class="lineNum">    1140 </span>            : //    if (correctForEnergyLoss) {
<span class="lineNum">    1141 </span>            : //      
<span class="lineNum">    1142 </span>            : //      // Correct for multiple scattering and energy loss
<span class="lineNum">    1143 </span>            : //      CorrectELossEffectInAbsorber(trackParam, 0.5*totalELoss, 0.5*sigmaELoss2);
<span class="lineNum">    1144 </span>            : //      CorrectMCSEffectInAbsorber(trackParam, xVtx, yVtx, zVtx, errXVtx, errYVtx,
<span class="lineNum">    1145 </span>            : //                               trackXYZIn[2], pathLength, f0, f1, f2);
<span class="lineNum">    1146 </span>            : //      CorrectELossEffectInAbsorber(trackParam, 0.5*totalELoss, 0.5*sigmaELoss2);
<span class="lineNum">    1147 </span>            : //      
<span class="lineNum">    1148 </span>            : //    } else {
<span class="lineNum">    1149 </span>            : //      
<span class="lineNum">    1150 </span>            : //      // Correct for multiple scattering
<span class="lineNum">    1151 </span>            : //      CorrectMCSEffectInAbsorber(trackParam, xVtx, yVtx, zVtx, errXVtx, errYVtx,
<span class="lineNum">    1152 </span>            : //                               trackXYZIn[2], pathLength, f0, f1, f2);
<span class="lineNum">    1153 </span>            : //    }
<span class="lineNum">    1154 </span>            : //    
<span class="lineNum">    1155 </span>            : //  } else {
<span class="lineNum">    1156 </span>            : //    
<span class="lineNum">    1157 </span>            : //    if (correctForEnergyLoss) {
<span class="lineNum">    1158 </span>            : //      
<span class="lineNum">    1159 </span>            : //      // Correct for energy loss add multiple scattering dispersion in covariance matrix
<span class="lineNum">    1160 </span>            : //      CorrectELossEffectInAbsorber(trackParam, 0.5*totalELoss, 0.5*sigmaELoss2);
<span class="lineNum">    1161 </span>            : //      AddMCSEffectInAbsorber(trackParam, -pathLength, f0, f1, f2); // (spectro. (z&lt;0))
<span class="lineNum">    1162 </span>            : //      ExtrapToZCov(trackParam, trackXYZIn[2]);
<span class="lineNum">    1163 </span>            : //      CorrectELossEffectInAbsorber(trackParam, 0.5*totalELoss, 0.5*sigmaELoss2);
<span class="lineNum">    1164 </span>            : //      ExtrapToZCov(trackParam, zVtx);
<span class="lineNum">    1165 </span>            : //      
<span class="lineNum">    1166 </span>            : //    } else {
<span class="lineNum">    1167 </span>            : //      
<span class="lineNum">    1168 </span>            : //      // add multiple scattering dispersion in covariance matrix
<span class="lineNum">    1169 </span>            : //      AddMCSEffectInAbsorber(trackParam, -pathLength, f0, f1, f2); // (spectro. (z&lt;0))
<span class="lineNum">    1170 </span>            : //      ExtrapToZCov(trackParam, zVtx);
<span class="lineNum">    1171 </span>            : //      
<span class="lineNum">    1172 </span>            : //    }
<span class="lineNum">    1173 </span>            : //    
<span class="lineNum">    1174 </span>            : //  }
<span class="lineNum">    1175 </span>            :         
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 : }</span>
<a name="1177"><span class="lineNum">    1177 </span>            : </a>
<span class="lineNum">    1178 </span>            : //__________________________________________________________________________
<span class="lineNum">    1179 </span>            : void AliMFTTrackExtrap::ExtrapToVertex(AliMFTTrackParam* trackParam,
<span class="lineNum">    1180 </span>            :                                         Double_t xVtx, Double_t yVtx, Double_t zVtx,
<span class="lineNum">    1181 </span>            :                                         Double_t errXVtx, Double_t errYVtx)
<span class="lineNum">    1182 </span>            : {
<span class="lineNum">    1183 </span>            :   /// Extrapolate track parameters to vertex, corrected for multiple scattering and energy loss effects
<span class="lineNum">    1184 </span>            :   /// Add branson correction resolution and energy loss fluctuation to parameter covariances
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :   ExtrapToVertex(trackParam, xVtx, yVtx, zVtx, errXVtx, errYVtx, kTRUE, kTRUE);</span>
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 : }</span>
<a name="1187"><span class="lineNum">    1187 </span>            : </a>
<span class="lineNum">    1188 </span>            : //__________________________________________________________________________
<span class="lineNum">    1189 </span>            : void AliMFTTrackExtrap::ExtrapToVertexWithoutELoss(AliMFTTrackParam* trackParam,
<span class="lineNum">    1190 </span>            :                                                     Double_t xVtx, Double_t yVtx, Double_t zVtx,
<span class="lineNum">    1191 </span>            :                                                     Double_t errXVtx, Double_t errYVtx)
<span class="lineNum">    1192 </span>            : {
<span class="lineNum">    1193 </span>            :   /// Extrapolate track parameters to vertex, corrected for multiple scattering effects only
<span class="lineNum">    1194 </span>            :   /// Add branson correction resolution to parameter covariances
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :   ExtrapToVertex(trackParam, xVtx, yVtx, zVtx, errXVtx, errYVtx, kTRUE, kFALSE);</span>
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 : }</span>
<a name="1197"><span class="lineNum">    1197 </span>            : </a>
<span class="lineNum">    1198 </span>            : //__________________________________________________________________________
<span class="lineNum">    1199 </span>            : void AliMFTTrackExtrap::ExtrapToVertexWithoutBranson(AliMFTTrackParam* trackParam, Double_t zVtx)
<span class="lineNum">    1200 </span>            : {
<span class="lineNum">    1201 </span>            :   /// Extrapolate track parameters to vertex, corrected for energy loss effects only
<span class="lineNum">    1202 </span>            :   /// Add dispersion due to multiple scattering and energy loss fluctuation to parameter covariances
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :   ExtrapToVertex(trackParam, 0., 0., zVtx, 0., 0., kFALSE, kTRUE);</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 : }</span>
<a name="1205"><span class="lineNum">    1205 </span>            : </a>
<span class="lineNum">    1206 </span>            : //__________________________________________________________________________
<span class="lineNum">    1207 </span>            : void AliMFTTrackExtrap::ExtrapToVertexUncorrected(AliMFTTrackParam* trackParam, Double_t zVtx)
<span class="lineNum">    1208 </span>            : {
<span class="lineNum">    1209 </span>            :   /// Extrapolate track parameters to vertex without multiple scattering and energy loss corrections
<span class="lineNum">    1210 </span>            :   /// Add dispersion due to multiple scattering to parameter covariances
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :   ExtrapToVertex(trackParam, 0., 0., zVtx, 0., 0., kFALSE, kFALSE);</span>
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 : }</span>
<a name="1213"><span class="lineNum">    1213 </span>            : </a>
<span class="lineNum">    1214 </span>            : //__________________________________________________________________________
<span class="lineNum">    1215 </span>            : Double_t AliMFTTrackExtrap::TotalMomentumEnergyLoss(AliMFTTrackParam* trackParam, Double_t xVtx, Double_t yVtx, Double_t zVtx)
<span class="lineNum">    1216 </span>            : {
<span class="lineNum">    1217 </span>            :   /// Calculate the total momentum energy loss in-between the track position and the vertex assuming a linear propagation
<span class="lineNum">    1218 </span>            :   
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :   if (trackParam-&gt;GetZ() == zVtx) return 0.; // nothing to be done if already at vertex</span>
<span class="lineNum">    1220 </span>            :   
<span class="lineNum">    1221 </span>            :   // Check whether the geometry is available
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :   if (!gGeoManager) {</span>
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :     cout&lt;&lt;&quot;E-AliMFTTrackExtrap::TotalMomentumEnergyLoss: no TGeo&quot;&lt;&lt;endl;</span>
<span class="lineNum">    1224 </span><span class="lineNoCov">          0 :     return 0.;</span>
<span class="lineNum">    1225 </span>            :   }
<span class="lineNum">    1226 </span>            :   
<span class="lineNum">    1227 </span>            :   // Get encountered material correction parameters assuming linear propagation from vertex to the track position
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :   Double_t trackXYZOut[3];</span>
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :   trackXYZOut[0] = trackParam-&gt;GetX();</span>
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :   trackXYZOut[1] = trackParam-&gt;GetY();</span>
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :   trackXYZOut[2] = trackParam-&gt;GetZ();</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :   Double_t trackXYZIn[3];</span>
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :   trackXYZIn[0] = xVtx;</span>
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :   trackXYZIn[1] = yVtx;</span>
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :   trackXYZIn[2] = zVtx;</span>
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 :   Double_t pTot = trackParam-&gt;P();</span>
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :   Double_t pathLength, f0, f1, f2, meanRho, totalELoss, sigmaELoss2;</span>
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :   GetAbsorberCorrectionParam(trackXYZIn,trackXYZOut,pTot,pathLength,f0,f1,f2,meanRho,totalELoss,sigmaELoss2);</span>
<span class="lineNum">    1239 </span>            :   
<span class="lineNum">    1240 </span>            :   // total momentum corrected for energy loss
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :   Double_t muMass = TDatabasePDG::Instance()-&gt;GetParticle(&quot;mu-&quot;)-&gt;Mass(); // GeV</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :   Double_t e = TMath::Sqrt(pTot*pTot + muMass*muMass);</span>
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :   Double_t eCorr = e + totalELoss;</span>
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 :   Double_t pTotCorr = TMath::Sqrt(eCorr*eCorr - muMass*muMass);</span>
<span class="lineNum">    1245 </span>            :   
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 :   return pTotCorr - pTot;</span>
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 : }</span>
<a name="1248"><span class="lineNum">    1248 </span>            : </a>
<span class="lineNum">    1249 </span>            : //__________________________________________________________________________
<span class="lineNum">    1250 </span>            : Double_t AliMFTTrackExtrap::BetheBloch(Double_t pTotal, Double_t pathLength, Double_t rho, Double_t atomicZ, Double_t atomicZoverA)
<span class="lineNum">    1251 </span>            : {
<span class="lineNum">    1252 </span>            :   /// Returns the mean total momentum energy loss of muon with total momentum='pTotal'
<span class="lineNum">    1253 </span>            :   /// in the absorber layer of lenght='pathLength', density='rho', A='atomicA' and Z='atomicZ'
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :   Double_t muMass = TDatabasePDG::Instance()-&gt;GetParticle(&quot;mu-&quot;)-&gt;Mass(); // GeV</span>
<span class="lineNum">    1255 </span>            :   
<span class="lineNum">    1256 </span>            :   // mean exitation energy (GeV)
<span class="lineNum">    1257 </span>            :   Double_t i;
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :   if (atomicZ &lt; 13) i = (12. * atomicZ + 7.) * 1.e-9;</span>
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :   else i = (9.76 * atomicZ + 58.8 * TMath::Power(atomicZ,-0.19)) * 1.e-9;</span>
<span class="lineNum">    1260 </span>            :   
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :   return pathLength * rho * AliExternalTrackParam::BetheBlochGeant(pTotal/muMass, rho, 0.20, 3.00, i, atomicZoverA);</span>
<span class="lineNum">    1262 </span>            : }
<a name="1263"><span class="lineNum">    1263 </span>            : </a>
<span class="lineNum">    1264 </span>            : //__________________________________________________________________________
<span class="lineNum">    1265 </span>            : Double_t AliMFTTrackExtrap::EnergyLossFluctuation(Double_t pTotal, Double_t pathLength, Double_t rho, Double_t atomicZoverA)
<span class="lineNum">    1266 </span>            : {
<span class="lineNum">    1267 </span>            :   /// Returns the total momentum energy loss fluctuation of muon with total momentum='pTotal'
<span class="lineNum">    1268 </span>            :   /// in the absorber layer of lenght='pathLength', density='rho', A='atomicA' and Z='atomicZ'
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :   Double_t muMass = TDatabasePDG::Instance()-&gt;GetParticle(&quot;mu-&quot;)-&gt;Mass(); // GeV</span>
<span class="lineNum">    1270 </span>            :   //Double_t eMass = 0.510998918e-3; // GeV
<span class="lineNum">    1271 </span>            :   Double_t k = 0.307075e-3; // GeV.g^-1.cm^2
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :   Double_t p2=pTotal*pTotal;</span>
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :   Double_t beta2=p2/(p2 + muMass*muMass);</span>
<span class="lineNum">    1274 </span>            :   
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :   Double_t fwhm = 2. * k * rho * pathLength * atomicZoverA / beta2; // FWHM of the energy loss Landau distribution</span>
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :   Double_t sigma = fwhm / TMath::Sqrt(8.*log(2.)); // gaussian: fwmh = 2 * srqt(2*ln(2)) * sigma (i.e. fwmh = 2.35 * sigma)</span>
<span class="lineNum">    1277 </span>            :   
<span class="lineNum">    1278 </span>            :   //sigma2 = k * rho * pathLength * atomicZ / atomicA * eMass; // sigma2 of the energy loss gaussian distribution
<span class="lineNum">    1279 </span>            :   
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :   return sigma;</span>
<span class="lineNum">    1281 </span>            : }
<a name="1282"><span class="lineNum">    1282 </span>            : </a>
<span class="lineNum">    1283 </span>            : //__________________________________________________________________________
<span class="lineNum">    1284 </span>            : void AliMFTTrackExtrap::Cov2CovP(const TMatrixD &amp;param, TMatrixD &amp;cov)
<span class="lineNum">    1285 </span>            : {
<span class="lineNum">    1286 </span>            :   /// change coordinate system: (X, SlopeX, Y, SlopeY, q/Pyz) -&gt; (X, SlopeX, Y, SlopeY, q*PTot)
<span class="lineNum">    1287 </span>            :   /// parameters (param) are given in the (X, SlopeX, Y, SlopeY, q/Pyz) coordinate system
<span class="lineNum">    1288 </span>            :   
<span class="lineNum">    1289 </span>            :   // charge * total momentum
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :   Double_t qPTot = TMath::Sqrt(1. + param(1,0)*param(1,0) + param(3,0)*param(3,0)) /</span>
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :                    TMath::Sqrt(1. + param(3,0)*param(3,0)) / param(4,0);</span>
<span class="lineNum">    1292 </span>            :   
<span class="lineNum">    1293 </span>            :   // Jacobian of the opposite transformation
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 :   TMatrixD jacob(5,5);</span>
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 :   jacob.UnitMatrix();</span>
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :   jacob(4,1) = qPTot * param(1,0) / (1. + param(1,0)*param(1,0) + param(3,0)*param(3,0));</span>
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 :   jacob(4,3) = - qPTot * param(1,0) * param(1,0) * param(3,0) /</span>
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :                  (1. + param(3,0)*param(3,0)) / (1. + param(1,0)*param(1,0) + param(3,0)*param(3,0));</span>
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 :   jacob(4,4) = - qPTot / param(4,0);</span>
<span class="lineNum">    1300 </span>            :   
<span class="lineNum">    1301 </span>            :   // compute covariances in new coordinate system
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 :   TMatrixD tmp(cov,TMatrixD::kMultTranspose,jacob);</span>
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :   cov.Mult(jacob,tmp);</span>
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 : }</span>
<a name="1305"><span class="lineNum">    1305 </span>            : </a>
<span class="lineNum">    1306 </span>            : //__________________________________________________________________________
<span class="lineNum">    1307 </span>            : void AliMFTTrackExtrap::CovP2Cov(const TMatrixD &amp;param, TMatrixD &amp;covP)
<span class="lineNum">    1308 </span>            : {
<span class="lineNum">    1309 </span>            :   /// change coordinate system: (X, SlopeX, Y, SlopeY, q*PTot) -&gt; (X, SlopeX, Y, SlopeY, q/Pyz)
<span class="lineNum">    1310 </span>            :   /// parameters (param) are given in the (X, SlopeX, Y, SlopeY, q/Pyz) coordinate system
<span class="lineNum">    1311 </span>            :   
<span class="lineNum">    1312 </span>            :   // charge * total momentum
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :   Double_t qPTot = TMath::Sqrt(1. + param(1,0)*param(1,0) + param(3,0)*param(3,0)) /</span>
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :                    TMath::Sqrt(1. + param(3,0)*param(3,0)) / param(4,0);</span>
<span class="lineNum">    1315 </span>            :   
<span class="lineNum">    1316 </span>            :   // Jacobian of the transformation
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :   TMatrixD jacob(5,5);</span>
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :   jacob.UnitMatrix();</span>
<span class="lineNum">    1319 </span><span class="lineNoCov">          0 :   jacob(4,1) = param(4,0) * param(1,0) / (1. + param(1,0)*param(1,0) + param(3,0)*param(3,0));</span>
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :   jacob(4,3) = - param(4,0) * param(1,0) * param(1,0) * param(3,0) /</span>
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :                  (1. + param(3,0)*param(3,0)) / (1. + param(1,0)*param(1,0) + param(3,0)*param(3,0));</span>
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :   jacob(4,4) = - param(4,0) / qPTot;</span>
<span class="lineNum">    1323 </span>            :   
<span class="lineNum">    1324 </span>            :   // compute covariances in new coordinate system
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :   TMatrixD tmp(covP,TMatrixD::kMultTranspose,jacob);</span>
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :   covP.Mult(jacob,tmp);</span>
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 : }</span>
<a name="1328"><span class="lineNum">    1328 </span>            : </a>
<span class="lineNum">    1329 </span>            :  //__________________________________________________________________________
<span class="lineNum">    1330 </span>            : void AliMFTTrackExtrap::ExtrapOneStepHelix(Double_t charge, Double_t step, const Double_t *vect, Double_t *vout)
<span class="lineNum">    1331 </span>            : {
<span class="lineNum">    1332 </span>            : /// &lt;pre&gt;
<span class="lineNum">    1333 </span>            : ///    ******************************************************************
<span class="lineNum">    1334 </span>            : ///    *                                                                *
<span class="lineNum">    1335 </span>            : ///    *  Performs the tracking of one step in a magnetic field         *
<span class="lineNum">    1336 </span>            : ///    *  The trajectory is assumed to be a helix in a constant field   *
<span class="lineNum">    1337 </span>            : ///    *  taken at the mid point of the step.                           *
<span class="lineNum">    1338 </span>            : ///    *  Parameters:                                                   *
<span class="lineNum">    1339 </span>            : ///    *   input                                                        *
<span class="lineNum">    1340 </span>            : ///    *     STEP =arc length of the step asked                         *
<span class="lineNum">    1341 </span>            : ///    *     VECT =input vector (position,direction cos and momentum)   *
<span class="lineNum">    1342 </span>            : ///    *     CHARGE=  electric charge of the particle                   *
<span class="lineNum">    1343 </span>            : ///    *   output                                                       *
<span class="lineNum">    1344 </span>            : ///    *     VOUT = same as VECT after completion of the step           *
<span class="lineNum">    1345 </span>            : ///    *                                                                *
<span class="lineNum">    1346 </span>            : ///    *    ==&gt;Called by : USER, GUSWIM                               *
<span class="lineNum">    1347 </span>            : ///    *       Author    m.hansroul  *********                          *
<span class="lineNum">    1348 </span>            : ///    *       modified  s.egli, s.v.levonian                           *
<span class="lineNum">    1349 </span>            : ///    *       modified  v.perevoztchikov
<span class="lineNum">    1350 </span>            : ///    *                                                                *
<span class="lineNum">    1351 </span>            : ///    ******************************************************************
<span class="lineNum">    1352 </span>            : /// &lt;/pre&gt;
<span class="lineNum">    1353 </span>            : 
<span class="lineNum">    1354 </span>            : // modif: everything in double precision
<span class="lineNum">    1355 </span>            : 
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 :     Double_t xyz[3], h[4], hxp[3];</span>
<span class="lineNum">    1357 </span>            :     Double_t h2xy, hp, rho, tet;
<span class="lineNum">    1358 </span>            :     Double_t sint, sintt, tsint, cos1t;
<span class="lineNum">    1359 </span>            :     Double_t f1, f2, f3, f4, f5, f6;
<span class="lineNum">    1360 </span>            : 
<span class="lineNum">    1361 </span>            :     const Int_t kix  = 0;
<span class="lineNum">    1362 </span>            :     const Int_t kiy  = 1;
<span class="lineNum">    1363 </span>            :     const Int_t kiz  = 2;
<span class="lineNum">    1364 </span>            :     const Int_t kipx = 3;
<span class="lineNum">    1365 </span>            :     const Int_t kipy = 4;
<span class="lineNum">    1366 </span>            :     const Int_t kipz = 5;
<span class="lineNum">    1367 </span>            :     const Int_t kipp = 6;
<span class="lineNum">    1368 </span>            : //      cout&lt;&lt;&quot;vin  =&quot;&lt;&lt; vect[kix]&lt;&lt;&quot; &quot;&lt;&lt; vect[kiy]&lt;&lt;&quot; &quot;&lt;&lt; vect[kiz]&lt;&lt;&quot; pxyz/ptot &quot;&lt;&lt; vect[kipx]&lt;&lt;&quot; &quot;&lt;&lt; vect[kipy]&lt;&lt;&quot; &quot;&lt;&lt; vect[kipz]&lt;&lt;endl;
<span class="lineNum">    1369 </span>            : 
<span class="lineNum">    1370 </span>            :     const Double_t kec = 2.9979251e-4;
<span class="lineNum">    1371 </span>            :     //
<span class="lineNum">    1372 </span>            :     //    ------------------------------------------------------------------
<span class="lineNum">    1373 </span>            :     //
<span class="lineNum">    1374 </span>            :     //       units are kgauss,centimeters,gev/c
<span class="lineNum">    1375 </span>            :     //
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 :     vout[kipp] = vect[kipp];</span>
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :     if (TMath::Abs(charge) &lt; 0.00001) {</span>
<span class="lineNum">    1378 </span><span class="lineNoCov">          0 :       for (Int_t i = 0; i &lt; 3; i++) {</span>
<span class="lineNum">    1379 </span><span class="lineNoCov">          0 :         vout[i] = vect[i] + step * vect[i+3];</span>
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :         vout[i+3] = vect[i+3];</span>
<span class="lineNum">    1381 </span>            :       }
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1383 </span>            :     }
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 :     xyz[0]    = vect[kix] + 0.5 * step * vect[kipx];</span>
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :     xyz[1]    = vect[kiy] + 0.5 * step * vect[kipy];</span>
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 :     xyz[2]    = vect[kiz] + 0.5 * step * vect[kipz];</span>
<span class="lineNum">    1387 </span>            : 
<span class="lineNum">    1388 </span>            :     //cmodif: call gufld (xyz, h) changed into:
<span class="lineNum">    1389 </span><span class="lineNoCov">          0 :     TGeoGlobalMagField::Instance()-&gt;Field(xyz,h);</span>
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :     h2xy = h[0]*h[0] + h[1]*h[1];</span>
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :     h[3] = h[2]*h[2]+ h2xy;</span>
<span class="lineNum">    1392 </span>            : // cout&lt;&lt;&quot;Field =&quot;&lt;&lt; h[0]&lt;&lt;&quot; &quot;&lt;&lt; h[1]&lt;&lt;&quot; &quot;&lt;&lt; h[2]&lt;&lt;&quot; &quot;&lt;&lt; h[3]&lt;&lt;endl;
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :     if (h[3] &lt; 1.e-12) {</span>
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 :       for (Int_t i = 0; i &lt; 3; i++) {</span>
<span class="lineNum">    1395 </span><span class="lineNoCov">          0 :         vout[i] = vect[i] + step * vect[i+3];</span>
<span class="lineNum">    1396 </span><span class="lineNoCov">          0 :         vout[i+3] = vect[i+3];</span>
<span class="lineNum">    1397 </span>            :       }
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1399 </span>            :     }
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :     if (h2xy &lt; 1.e-12*h[3]) {</span>
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :       ExtrapOneStepHelix3(charge*h[2], step, vect, vout);</span>
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1403 </span>            :     }
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 :     h[3] = TMath::Sqrt(h[3]);</span>
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 :     h[0] /= h[3];</span>
<span class="lineNum">    1406 </span><span class="lineNoCov">          0 :     h[1] /= h[3];</span>
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :     h[2] /= h[3];</span>
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :     h[3] *= kec;</span>
<span class="lineNum">    1409 </span>            : 
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :     hxp[0] = h[1]*vect[kipz] - h[2]*vect[kipy];</span>
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :     hxp[1] = h[2]*vect[kipx] - h[0]*vect[kipz];</span>
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :     hxp[2] = h[0]*vect[kipy] - h[1]*vect[kipx];</span>
<span class="lineNum">    1413 </span>            :  
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :     hp = h[0]*vect[kipx] + h[1]*vect[kipy] + h[2]*vect[kipz];</span>
<span class="lineNum">    1415 </span>            : 
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :     rho = -charge*h[3]/vect[kipp];</span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :     tet = rho * step;</span>
<span class="lineNum">    1418 </span>            : 
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :     if (TMath::Abs(tet) &gt; 0.15) {</span>
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :       sint = TMath::Sin(tet);</span>
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 :       sintt = (sint/tet);</span>
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :       tsint = (tet-sint)/tet;</span>
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :       cos1t = 2.*(TMath::Sin(0.5*tet))*(TMath::Sin(0.5*tet))/tet;</span>
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">    1425 </span><span class="lineNoCov">          0 :       tsint = tet*tet/36.;</span>
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 :       sintt = (1. - tsint);</span>
<span class="lineNum">    1427 </span><span class="lineNoCov">          0 :       sint = tet*sintt;</span>
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :       cos1t = 0.5*tet;</span>
<span class="lineNum">    1429 </span>            :     }
<span class="lineNum">    1430 </span>            : 
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 :     f1 = step * sintt;</span>
<span class="lineNum">    1432 </span><span class="lineNoCov">          0 :     f2 = step * cos1t;</span>
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :     f3 = step * tsint * hp;</span>
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :     f4 = -tet*cos1t;</span>
<span class="lineNum">    1435 </span>            :     f5 = sint;
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :     f6 = tet * cos1t * hp;</span>
<span class="lineNum">    1437 </span>            :  
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :     vout[kix] = vect[kix] + f1*vect[kipx] + f2*hxp[0] + f3*h[0];</span>
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :     vout[kiy] = vect[kiy] + f1*vect[kipy] + f2*hxp[1] + f3*h[1];</span>
<span class="lineNum">    1440 </span><span class="lineNoCov">          0 :     vout[kiz] = vect[kiz] + f1*vect[kipz] + f2*hxp[2] + f3*h[2];</span>
<span class="lineNum">    1441 </span>            :  
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :     vout[kipx] = vect[kipx] + f4*vect[kipx] + f5*hxp[0] + f6*h[0];</span>
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :     vout[kipy] = vect[kipy] + f4*vect[kipy] + f5*hxp[1] + f6*h[1];</span>
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :     vout[kipz] = vect[kipz] + f4*vect[kipz] + f5*hxp[2] + f6*h[2];</span>
<span class="lineNum">    1445 </span>            : //              cout&lt;&lt;&quot;vout =&quot;&lt;&lt; vout[kix]&lt;&lt;&quot; &quot;&lt;&lt; vout[kiy]&lt;&lt;&quot; &quot;&lt;&lt; vout[kiz]&lt;&lt;&quot; pxyz/ptot &quot;&lt;&lt; vout[kipx]&lt;&lt;&quot; &quot;&lt;&lt; vout[kipy]&lt;&lt;&quot; &quot;&lt;&lt; vout[kipz]&lt;&lt;endl;
<span class="lineNum">    1446 </span>            : //      cout&lt;&lt;&quot;vlin =&quot;&lt;&lt; vect[kix] + step * vect[kix+3]&lt;&lt;&quot; &quot;&lt;&lt; vect[kiy] + step * vect[kiy+3]&lt;&lt;&quot; &quot;&lt;&lt; vect[kiz] + step * vect[kiz+3]&lt;&lt;&quot; pxyz/ptot &quot;&lt;&lt; vect[kipx]&lt;&lt;&quot; &quot;&lt;&lt; vect[kipy]&lt;&lt;&quot; &quot;&lt;&lt; vect[kipz]&lt;&lt;endl;
<span class="lineNum">    1447 </span>            : 
<span class="lineNum">    1448 </span>            : 
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 : }</span>
<a name="1451"><span class="lineNum">    1451 </span>            : </a>
<span class="lineNum">    1452 </span>            :  //__________________________________________________________________________
<span class="lineNum">    1453 </span>            : void AliMFTTrackExtrap::ExtrapOneStepHelix3(Double_t field, Double_t step, const Double_t *vect, Double_t *vout)
<span class="lineNum">    1454 </span>            : {
<span class="lineNum">    1455 </span>            : /// &lt;pre&gt;
<span class="lineNum">    1456 </span>            : ///     ******************************************************************
<span class="lineNum">    1457 </span>            : ///     *                                                                *
<span class="lineNum">    1458 </span>            : ///     *       Tracking routine in a constant field oriented            *
<span class="lineNum">    1459 </span>            : ///     *       along axis 3                                             *
<span class="lineNum">    1460 </span>            : ///     *       Tracking is performed with a conventional                *
<span class="lineNum">    1461 </span>            : ///     *       helix step method                                        *
<span class="lineNum">    1462 </span>            : ///     *                                                                *
<span class="lineNum">    1463 </span>            : ///     *    ==&gt;Called by : USER, GUSWIM                              *
<span class="lineNum">    1464 </span>            : ///     *       Authors    R.Brun, M.Hansroul  *********                 *
<span class="lineNum">    1465 </span>            : ///     *       Rewritten  V.Perevoztchikov
<span class="lineNum">    1466 </span>            : ///     *                                                                *
<span class="lineNum">    1467 </span>            : ///     ******************************************************************
<span class="lineNum">    1468 </span>            : /// &lt;/pre&gt;
<span class="lineNum">    1469 </span>            : 
<span class="lineNum">    1470 </span>            :     Double_t hxp[3];
<span class="lineNum">    1471 </span>            :     Double_t h4, hp, rho, tet;
<span class="lineNum">    1472 </span>            :     Double_t sint, sintt, tsint, cos1t;
<span class="lineNum">    1473 </span>            :     Double_t f1, f2, f3, f4, f5, f6;
<span class="lineNum">    1474 </span>            : 
<span class="lineNum">    1475 </span>            :     const Int_t kix  = 0;
<span class="lineNum">    1476 </span>            :     const Int_t kiy  = 1;
<span class="lineNum">    1477 </span>            :     const Int_t kiz  = 2;
<span class="lineNum">    1478 </span>            :     const Int_t kipx = 3;
<span class="lineNum">    1479 </span>            :     const Int_t kipy = 4;
<span class="lineNum">    1480 </span>            :     const Int_t kipz = 5;
<span class="lineNum">    1481 </span>            :     const Int_t kipp = 6;
<span class="lineNum">    1482 </span>            : 
<span class="lineNum">    1483 </span>            :     const Double_t kec = 2.9979251e-4;
<span class="lineNum">    1484 </span>            : 
<span class="lineNum">    1485 </span>            : // 
<span class="lineNum">    1486 </span>            : //     ------------------------------------------------------------------
<span class="lineNum">    1487 </span>            : // 
<span class="lineNum">    1488 </span>            : //       units are kgauss,centimeters,gev/c
<span class="lineNum">    1489 </span>            : // 
<span class="lineNum">    1490 </span><span class="lineNoCov">          0 :     vout[kipp] = vect[kipp];</span>
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 :     h4 = field * kec;</span>
<span class="lineNum">    1492 </span>            : 
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :     hxp[0] = - vect[kipy];</span>
<span class="lineNum">    1494 </span><span class="lineNoCov">          0 :     hxp[1] = + vect[kipx];</span>
<span class="lineNum">    1495 </span>            :  
<span class="lineNum">    1496 </span><span class="lineNoCov">          0 :     hp = vect[kipz];</span>
<span class="lineNum">    1497 </span>            : 
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 :     rho = -h4/vect[kipp];</span>
<span class="lineNum">    1499 </span><span class="lineNoCov">          0 :     tet = rho * step;</span>
<span class="lineNum">    1500 </span><span class="lineNoCov">          0 :     if (TMath::Abs(tet) &gt; 0.15) {</span>
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 :       sint = TMath::Sin(tet);</span>
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 :       sintt = (sint/tet);</span>
<span class="lineNum">    1503 </span><span class="lineNoCov">          0 :       tsint = (tet-sint)/tet;</span>
<span class="lineNum">    1504 </span><span class="lineNoCov">          0 :       cos1t = 2.* TMath::Sin(0.5*tet) * TMath::Sin(0.5*tet)/tet;</span>
<span class="lineNum">    1505 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">    1506 </span><span class="lineNoCov">          0 :       tsint = tet*tet/36.;</span>
<span class="lineNum">    1507 </span><span class="lineNoCov">          0 :       sintt = (1. - tsint);</span>
<span class="lineNum">    1508 </span><span class="lineNoCov">          0 :       sint = tet*sintt;</span>
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :       cos1t = 0.5*tet;</span>
<span class="lineNum">    1510 </span>            :     }
<span class="lineNum">    1511 </span>            : 
<span class="lineNum">    1512 </span><span class="lineNoCov">          0 :     f1 = step * sintt;</span>
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :     f2 = step * cos1t;</span>
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 :     f3 = step * tsint * hp;</span>
<span class="lineNum">    1515 </span><span class="lineNoCov">          0 :     f4 = -tet*cos1t;</span>
<span class="lineNum">    1516 </span>            :     f5 = sint;
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 :     f6 = tet * cos1t * hp;</span>
<span class="lineNum">    1518 </span>            :  
<span class="lineNum">    1519 </span><span class="lineNoCov">          0 :     vout[kix] = vect[kix] + f1*vect[kipx] + f2*hxp[0];</span>
<span class="lineNum">    1520 </span><span class="lineNoCov">          0 :     vout[kiy] = vect[kiy] + f1*vect[kipy] + f2*hxp[1];</span>
<span class="lineNum">    1521 </span><span class="lineNoCov">          0 :     vout[kiz] = vect[kiz] + f1*vect[kipz] + f3;</span>
<span class="lineNum">    1522 </span>            :  
<span class="lineNum">    1523 </span><span class="lineNoCov">          0 :     vout[kipx] = vect[kipx] + f4*vect[kipx] + f5*hxp[0];</span>
<span class="lineNum">    1524 </span><span class="lineNoCov">          0 :     vout[kipy] = vect[kipy] + f4*vect[kipy] + f5*hxp[1];</span>
<span class="lineNum">    1525 </span><span class="lineNoCov">          0 :     vout[kipz] = vect[kipz] + f4*vect[kipz] + f6;</span>
<span class="lineNum">    1526 </span>            : 
<span class="lineNum">    1527 </span>            :     return;
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 : }</span>
<a name="1529"><span class="lineNum">    1529 </span>            : </a>
<span class="lineNum">    1530 </span>            :  //__________________________________________________________________________
<span class="lineNum">    1531 </span>            : Bool_t AliMFTTrackExtrap::ExtrapOneStepRungekutta(Double_t charge, Double_t step, const Double_t* vect, Double_t* vout)
<span class="lineNum">    1532 </span>            : {
<span class="lineNum">    1533 </span>            : /// &lt;pre&gt;
<span class="lineNum">    1534 </span>            : ///     ******************************************************************
<span class="lineNum">    1535 </span>            : ///     *                                                                *
<span class="lineNum">    1536 </span>            : ///     *  Runge-Kutta method for tracking a particle through a magnetic *
<span class="lineNum">    1537 </span>            : ///     *  field. Uses Nystroem algorithm (See Handbook Nat. Bur. of     *
<span class="lineNum">    1538 </span>            : ///     *  Standards, procedure 25.5.20)                                 *
<span class="lineNum">    1539 </span>            : ///     *                                                                *
<span class="lineNum">    1540 </span>            : ///     *  Input parameters                                              *
<span class="lineNum">    1541 </span>            : ///     *       CHARGE    Particle charge                                *
<span class="lineNum">    1542 </span>            : ///     *       STEP      Step size                                      *
<span class="lineNum">    1543 </span>            : ///     *       VECT      Initial co-ords,direction cosines,momentum     *
<span class="lineNum">    1544 </span>            : ///     *  Output parameters                                             *
<span class="lineNum">    1545 </span>            : ///     *       VOUT      Output co-ords,direction cosines,momentum      *
<span class="lineNum">    1546 </span>            : ///     *  User routine called                                           *
<span class="lineNum">    1547 </span>            : ///     *       CALL GUFLD(X,F)                                          *
<span class="lineNum">    1548 </span>            : ///     *                                                                *
<span class="lineNum">    1549 </span>            : ///     *    ==&gt;Called by : USER, GUSWIM                              *
<span class="lineNum">    1550 </span>            : ///     *       Authors    R.Brun, M.Hansroul  *********                 *
<span class="lineNum">    1551 </span>            : ///     *                  V.Perevoztchikov (CUT STEP implementation)    *
<span class="lineNum">    1552 </span>            : ///     *                                                                *
<span class="lineNum">    1553 </span>            : ///     *                                                                *
<span class="lineNum">    1554 </span>            : ///     ******************************************************************
<span class="lineNum">    1555 </span>            : /// &lt;/pre&gt;
<span class="lineNum">    1556 </span>            : 
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :     Double_t h2, h4, f[4];</span>
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 :     Double_t xyzt[3] = {FLT_MAX, FLT_MAX, FLT_MAX};</span>
<span class="lineNum">    1559 </span>            :     Double_t a, b, c, ph,ph2;
<span class="lineNum">    1560 </span>            :     Double_t secxs[4],secys[4],seczs[4],hxp[3];
<span class="lineNum">    1561 </span>            :     Double_t g1, g2, g3, g4, g5, g6, ang2, dxt, dyt, dzt;
<span class="lineNum">    1562 </span>            :     Double_t est, at, bt, ct, cba;
<span class="lineNum">    1563 </span>            :     Double_t f1, f2, f3, f4, rho, tet, hnorm, hp, rho1, sint, cost;
<span class="lineNum">    1564 </span>            :     
<span class="lineNum">    1565 </span>            :     Double_t x;
<span class="lineNum">    1566 </span>            :     Double_t y;
<span class="lineNum">    1567 </span>            :     Double_t z;
<span class="lineNum">    1568 </span>            :     
<span class="lineNum">    1569 </span>            :     Double_t xt;
<span class="lineNum">    1570 </span>            :     Double_t yt;
<span class="lineNum">    1571 </span>            :     Double_t zt;
<span class="lineNum">    1572 </span>            : 
<span class="lineNum">    1573 </span>            :     Double_t maxit = 1992;
<span class="lineNum">    1574 </span>            :     Double_t maxcut = 11;
<span class="lineNum">    1575 </span>            : 
<span class="lineNum">    1576 </span>            :     const Double_t kdlt   = 1e-4;
<span class="lineNum">    1577 </span>            :     const Double_t kdlt32 = kdlt/32.;
<span class="lineNum">    1578 </span>            :     const Double_t kthird = 1./3.;
<span class="lineNum">    1579 </span>            :     const Double_t khalf  = 0.5;
<span class="lineNum">    1580 </span>            :     const Double_t kec = 2.9979251e-4;
<span class="lineNum">    1581 </span>            : 
<span class="lineNum">    1582 </span>            :     const Double_t kpisqua = 9.86960440109;
<span class="lineNum">    1583 </span>            :     const Int_t kix  = 0;
<span class="lineNum">    1584 </span>            :     const Int_t kiy  = 1;
<span class="lineNum">    1585 </span>            :     const Int_t kiz  = 2;
<span class="lineNum">    1586 </span>            :     const Int_t kipx = 3;
<span class="lineNum">    1587 </span>            :     const Int_t kipy = 4;
<span class="lineNum">    1588 </span>            :     const Int_t kipz = 5;
<span class="lineNum">    1589 </span>            :   
<span class="lineNum">    1590 </span>            :     // *.
<span class="lineNum">    1591 </span>            :     // *.    ------------------------------------------------------------------
<span class="lineNum">    1592 </span>            :     // *.
<span class="lineNum">    1593 </span>            :     // *             this constant is for units cm,gev/c and kgauss
<span class="lineNum">    1594 </span>            :     // *
<span class="lineNum">    1595 </span>            :     Int_t iter = 0;
<span class="lineNum">    1596 </span>            :     Int_t ncut = 0;
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :     for(Int_t j = 0; j &lt; 7; j++)</span>
<span class="lineNum">    1598 </span><span class="lineNoCov">          0 :       vout[j] = vect[j];</span>
<span class="lineNum">    1599 </span>            : 
<span class="lineNum">    1600 </span><span class="lineNoCov">          0 :     Double_t  pinv   = kec * charge / vect[6];</span>
<span class="lineNum">    1601 </span>            :     Double_t tl = 0.;
<span class="lineNum">    1602 </span>            :     Double_t h = step;
<span class="lineNum">    1603 </span>            :     Double_t rest;
<span class="lineNum">    1604 </span>            : 
<span class="lineNum">    1605 </span>            :  
<span class="lineNum">    1606 </span><span class="lineNoCov">          0 :     do {</span>
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 :       rest  = step - tl;</span>
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 :       if (TMath::Abs(h) &gt; TMath::Abs(rest)) h = rest;</span>
<span class="lineNum">    1609 </span>            :       //cmodif: call gufld(vout,f) changed into:
<span class="lineNum">    1610 </span><span class="lineNoCov">          0 :       TGeoGlobalMagField::Instance()-&gt;Field(vout,f);</span>
<span class="lineNum">    1611 </span>            : 
<span class="lineNum">    1612 </span>            :       // *
<span class="lineNum">    1613 </span>            :       // *             start of integration
<span class="lineNum">    1614 </span>            :       // *
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :       x      = vout[0];</span>
<span class="lineNum">    1616 </span><span class="lineNoCov">          0 :       y      = vout[1];</span>
<span class="lineNum">    1617 </span><span class="lineNoCov">          0 :       z      = vout[2];</span>
<span class="lineNum">    1618 </span><span class="lineNoCov">          0 :       a      = vout[3];</span>
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :       b      = vout[4];</span>
<span class="lineNum">    1620 </span><span class="lineNoCov">          0 :       c      = vout[5];</span>
<span class="lineNum">    1621 </span>            : 
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 :       h2     = khalf * h;</span>
<span class="lineNum">    1623 </span><span class="lineNoCov">          0 :       h4     = khalf * h2;</span>
<span class="lineNum">    1624 </span><span class="lineNoCov">          0 :       ph     = pinv * h;</span>
<span class="lineNum">    1625 </span><span class="lineNoCov">          0 :       ph2    = khalf * ph;</span>
<span class="lineNum">    1626 </span><span class="lineNoCov">          0 :       secxs[0] = (b * f[2] - c * f[1]) * ph2;</span>
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 :       secys[0] = (c * f[0] - a * f[2]) * ph2;</span>
<span class="lineNum">    1628 </span><span class="lineNoCov">          0 :       seczs[0] = (a * f[1] - b * f[0]) * ph2;</span>
<span class="lineNum">    1629 </span><span class="lineNoCov">          0 :       ang2 = (secxs[0]*secxs[0] + secys[0]*secys[0] + seczs[0]*seczs[0]);</span>
<span class="lineNum">    1630 </span><span class="lineNoCov">          0 :       if (ang2 &gt; kpisqua) break;</span>
<span class="lineNum">    1631 </span>            : 
<span class="lineNum">    1632 </span><span class="lineNoCov">          0 :       dxt    = h2 * a + h4 * secxs[0];</span>
<span class="lineNum">    1633 </span><span class="lineNoCov">          0 :       dyt    = h2 * b + h4 * secys[0];</span>
<span class="lineNum">    1634 </span><span class="lineNoCov">          0 :       dzt    = h2 * c + h4 * seczs[0];</span>
<span class="lineNum">    1635 </span><span class="lineNoCov">          0 :       xt     = x + dxt;</span>
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :       yt     = y + dyt;</span>
<span class="lineNum">    1637 </span><span class="lineNoCov">          0 :       zt     = z + dzt;</span>
<span class="lineNum">    1638 </span>            :       // *
<span class="lineNum">    1639 </span>            :       // *              second intermediate point
<span class="lineNum">    1640 </span>            :       // *
<span class="lineNum">    1641 </span>            : 
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 :       est = TMath::Abs(dxt) + TMath::Abs(dyt) + TMath::Abs(dzt);</span>
<span class="lineNum">    1643 </span><span class="lineNoCov">          0 :       if (est &gt; h) {</span>
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :         if (ncut++ &gt; maxcut) break;</span>
<span class="lineNum">    1645 </span>            :         h *= khalf;
<span class="lineNum">    1646 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    1647 </span>            :       }
<span class="lineNum">    1648 </span>            :  
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 :       xyzt[0] = xt;</span>
<span class="lineNum">    1650 </span><span class="lineNoCov">          0 :       xyzt[1] = yt;</span>
<span class="lineNum">    1651 </span><span class="lineNoCov">          0 :       xyzt[2] = zt;</span>
<span class="lineNum">    1652 </span>            : 
<span class="lineNum">    1653 </span>            :       //cmodif: call gufld(xyzt,f) changed into:
<span class="lineNum">    1654 </span><span class="lineNoCov">          0 :       TGeoGlobalMagField::Instance()-&gt;Field(xyzt,f);</span>
<span class="lineNum">    1655 </span>            : 
<span class="lineNum">    1656 </span><span class="lineNoCov">          0 :       at     = a + secxs[0];</span>
<span class="lineNum">    1657 </span><span class="lineNoCov">          0 :       bt     = b + secys[0];</span>
<span class="lineNum">    1658 </span><span class="lineNoCov">          0 :       ct     = c + seczs[0];</span>
<span class="lineNum">    1659 </span>            : 
<span class="lineNum">    1660 </span><span class="lineNoCov">          0 :       secxs[1] = (bt * f[2] - ct * f[1]) * ph2;</span>
<span class="lineNum">    1661 </span><span class="lineNoCov">          0 :       secys[1] = (ct * f[0] - at * f[2]) * ph2;</span>
<span class="lineNum">    1662 </span><span class="lineNoCov">          0 :       seczs[1] = (at * f[1] - bt * f[0]) * ph2;</span>
<span class="lineNum">    1663 </span><span class="lineNoCov">          0 :       at     = a + secxs[1];</span>
<span class="lineNum">    1664 </span><span class="lineNoCov">          0 :       bt     = b + secys[1];</span>
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :       ct     = c + seczs[1];</span>
<span class="lineNum">    1666 </span><span class="lineNoCov">          0 :       secxs[2] = (bt * f[2] - ct * f[1]) * ph2;</span>
<span class="lineNum">    1667 </span><span class="lineNoCov">          0 :       secys[2] = (ct * f[0] - at * f[2]) * ph2;</span>
<span class="lineNum">    1668 </span><span class="lineNoCov">          0 :       seczs[2] = (at * f[1] - bt * f[0]) * ph2;</span>
<span class="lineNum">    1669 </span><span class="lineNoCov">          0 :       dxt    = h * (a + secxs[2]);</span>
<span class="lineNum">    1670 </span><span class="lineNoCov">          0 :       dyt    = h * (b + secys[2]);</span>
<span class="lineNum">    1671 </span><span class="lineNoCov">          0 :       dzt    = h * (c + seczs[2]);</span>
<span class="lineNum">    1672 </span><span class="lineNoCov">          0 :       xt     = x + dxt;</span>
<span class="lineNum">    1673 </span><span class="lineNoCov">          0 :       yt     = y + dyt;</span>
<span class="lineNum">    1674 </span><span class="lineNoCov">          0 :       zt     = z + dzt;</span>
<span class="lineNum">    1675 </span><span class="lineNoCov">          0 :       at     = a + 2.*secxs[2];</span>
<span class="lineNum">    1676 </span><span class="lineNoCov">          0 :       bt     = b + 2.*secys[2];</span>
<span class="lineNum">    1677 </span><span class="lineNoCov">          0 :       ct     = c + 2.*seczs[2];</span>
<span class="lineNum">    1678 </span>            : 
<span class="lineNum">    1679 </span><span class="lineNoCov">          0 :       est = TMath::Abs(dxt)+TMath::Abs(dyt)+TMath::Abs(dzt);</span>
<span class="lineNum">    1680 </span><span class="lineNoCov">          0 :       if (est &gt; 2.*TMath::Abs(h)) {</span>
<span class="lineNum">    1681 </span><span class="lineNoCov">          0 :         if (ncut++ &gt; maxcut) break;</span>
<span class="lineNum">    1682 </span>            :         h *= khalf;
<span class="lineNum">    1683 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    1684 </span>            :       }
<span class="lineNum">    1685 </span>            :  
<span class="lineNum">    1686 </span><span class="lineNoCov">          0 :       xyzt[0] = xt;</span>
<span class="lineNum">    1687 </span><span class="lineNoCov">          0 :       xyzt[1] = yt;</span>
<span class="lineNum">    1688 </span><span class="lineNoCov">          0 :       xyzt[2] = zt;</span>
<span class="lineNum">    1689 </span>            : 
<span class="lineNum">    1690 </span>            :       //cmodif: call gufld(xyzt,f) changed into:
<span class="lineNum">    1691 </span><span class="lineNoCov">          0 :       TGeoGlobalMagField::Instance()-&gt;Field(xyzt,f);</span>
<span class="lineNum">    1692 </span>            : 
<span class="lineNum">    1693 </span><span class="lineNoCov">          0 :       z      = z + (c + (seczs[0] + seczs[1] + seczs[2]) * kthird) * h;</span>
<span class="lineNum">    1694 </span><span class="lineNoCov">          0 :       y      = y + (b + (secys[0] + secys[1] + secys[2]) * kthird) * h;</span>
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :       x      = x + (a + (secxs[0] + secxs[1] + secxs[2]) * kthird) * h;</span>
<span class="lineNum">    1696 </span>            : 
<span class="lineNum">    1697 </span><span class="lineNoCov">          0 :       secxs[3] = (bt*f[2] - ct*f[1])* ph2;</span>
<span class="lineNum">    1698 </span><span class="lineNoCov">          0 :       secys[3] = (ct*f[0] - at*f[2])* ph2;</span>
<span class="lineNum">    1699 </span><span class="lineNoCov">          0 :       seczs[3] = (at*f[1] - bt*f[0])* ph2;</span>
<span class="lineNum">    1700 </span><span class="lineNoCov">          0 :       a      = a+(secxs[0]+secxs[3]+2. * (secxs[1]+secxs[2])) * kthird;</span>
<span class="lineNum">    1701 </span><span class="lineNoCov">          0 :       b      = b+(secys[0]+secys[3]+2. * (secys[1]+secys[2])) * kthird;</span>
<span class="lineNum">    1702 </span><span class="lineNoCov">          0 :       c      = c+(seczs[0]+seczs[3]+2. * (seczs[1]+seczs[2])) * kthird;</span>
<span class="lineNum">    1703 </span>            : 
<span class="lineNum">    1704 </span><span class="lineNoCov">          0 :       est    = TMath::Abs(secxs[0]+secxs[3] - (secxs[1]+secxs[2]))</span>
<span class="lineNum">    1705 </span><span class="lineNoCov">          0 :         + TMath::Abs(secys[0]+secys[3] - (secys[1]+secys[2]))</span>
<span class="lineNum">    1706 </span><span class="lineNoCov">          0 :         + TMath::Abs(seczs[0]+seczs[3] - (seczs[1]+seczs[2]));</span>
<span class="lineNum">    1707 </span>            : 
<span class="lineNum">    1708 </span><span class="lineNoCov">          0 :       if (est &gt; kdlt &amp;&amp; TMath::Abs(h) &gt; 1.e-4) {</span>
<span class="lineNum">    1709 </span><span class="lineNoCov">          0 :         if (ncut++ &gt; maxcut) break;</span>
<span class="lineNum">    1710 </span>            :         h *= khalf;
<span class="lineNum">    1711 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    1712 </span>            :       }
<span class="lineNum">    1713 </span>            : 
<span class="lineNum">    1714 </span>            :       ncut = 0;
<span class="lineNum">    1715 </span>            :       // *               if too many iterations, go to helix
<span class="lineNum">    1716 </span><span class="lineNoCov">          0 :       if (iter++ &gt; maxit) break;</span>
<span class="lineNum">    1717 </span>            : 
<span class="lineNum">    1718 </span><span class="lineNoCov">          0 :       tl += h;</span>
<span class="lineNum">    1719 </span><span class="lineNoCov">          0 :       if (est &lt; kdlt32) </span>
<span class="lineNum">    1720 </span><span class="lineNoCov">          0 :         h *= 2.;</span>
<span class="lineNum">    1721 </span><span class="lineNoCov">          0 :       cba    = 1./ TMath::Sqrt(a*a + b*b + c*c);</span>
<span class="lineNum">    1722 </span><span class="lineNoCov">          0 :       vout[0] = x;</span>
<span class="lineNum">    1723 </span><span class="lineNoCov">          0 :       vout[1] = y;</span>
<span class="lineNum">    1724 </span><span class="lineNoCov">          0 :       vout[2] = z;</span>
<span class="lineNum">    1725 </span><span class="lineNoCov">          0 :       vout[3] = cba*a;</span>
<span class="lineNum">    1726 </span><span class="lineNoCov">          0 :       vout[4] = cba*b;</span>
<span class="lineNum">    1727 </span><span class="lineNoCov">          0 :       vout[5] = cba*c;</span>
<span class="lineNum">    1728 </span><span class="lineNoCov">          0 :       rest = step - tl;</span>
<span class="lineNum">    1729 </span><span class="lineNoCov">          0 :       if (step &lt; 0.) rest = -rest;</span>
<span class="lineNum">    1730 </span><span class="lineNoCov">          0 :       if (rest &lt; 1.e-5*TMath::Abs(step)) return kTRUE;</span>
<span class="lineNum">    1731 </span>            : 
<span class="lineNum">    1732 </span>            :     } while(1);
<span class="lineNum">    1733 </span>            : 
<span class="lineNum">    1734 </span>            :     // angle too big, use helix
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 :     cout&lt;&lt;&quot;W-AliMFTTrackExtrap::ExtrapOneStepRungekutta: Ruge-Kutta failed: switch to helix&quot;&lt;&lt;endl;</span>
<span class="lineNum">    1736 </span>            : 
<span class="lineNum">    1737 </span><span class="lineNoCov">          0 :     f1  = f[0];</span>
<span class="lineNum">    1738 </span><span class="lineNoCov">          0 :     f2  = f[1];</span>
<span class="lineNum">    1739 </span><span class="lineNoCov">          0 :     f3  = f[2];</span>
<span class="lineNum">    1740 </span><span class="lineNoCov">          0 :     f4  = TMath::Sqrt(f1*f1+f2*f2+f3*f3);</span>
<span class="lineNum">    1741 </span><span class="lineNoCov">          0 :     if (f4 &lt; 1.e-10) {</span>
<span class="lineNum">    1742 </span><span class="lineNoCov">          0 :       cout&lt;&lt;&quot;E-AliMFTTrackExtrap::ExtrapOneStepRungekutta: magnetic field at (&quot;;</span>
<span class="lineNum">    1743 </span><span class="lineNoCov">          0 :       cout&lt;&lt;xyzt[0]&lt;&lt;&quot;, &quot;&lt;&lt;xyzt[1]&lt;&lt;&quot;, &quot;&lt;&lt;xyzt[2]&lt;&lt;&quot;) = &quot;&lt;&lt;f4&lt;&lt;&quot;: giving up&quot;&lt;&lt;endl;</span>
<span class="lineNum">    1744 </span><span class="lineNoCov">          0 :       return kFALSE;</span>
<span class="lineNum">    1745 </span>            :     }
<span class="lineNum">    1746 </span><span class="lineNoCov">          0 :     rho = -f4*pinv;</span>
<span class="lineNum">    1747 </span><span class="lineNoCov">          0 :     tet = rho * step;</span>
<span class="lineNum">    1748 </span>            :  
<span class="lineNum">    1749 </span><span class="lineNoCov">          0 :     hnorm = 1./f4;</span>
<span class="lineNum">    1750 </span><span class="lineNoCov">          0 :     f1 = f1*hnorm;</span>
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :     f2 = f2*hnorm;</span>
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :     f3 = f3*hnorm;</span>
<span class="lineNum">    1753 </span>            : 
<span class="lineNum">    1754 </span><span class="lineNoCov">          0 :     hxp[0] = f2*vect[kipz] - f3*vect[kipy];</span>
<span class="lineNum">    1755 </span><span class="lineNoCov">          0 :     hxp[1] = f3*vect[kipx] - f1*vect[kipz];</span>
<span class="lineNum">    1756 </span><span class="lineNoCov">          0 :     hxp[2] = f1*vect[kipy] - f2*vect[kipx];</span>
<span class="lineNum">    1757 </span>            :  
<span class="lineNum">    1758 </span><span class="lineNoCov">          0 :     hp = f1*vect[kipx] + f2*vect[kipy] + f3*vect[kipz];</span>
<span class="lineNum">    1759 </span>            : 
<span class="lineNum">    1760 </span><span class="lineNoCov">          0 :     rho1 = 1./rho;</span>
<span class="lineNum">    1761 </span><span class="lineNoCov">          0 :     sint = TMath::Sin(tet);</span>
<span class="lineNum">    1762 </span><span class="lineNoCov">          0 :     cost = 2.*TMath::Sin(khalf*tet)*TMath::Sin(khalf*tet);</span>
<span class="lineNum">    1763 </span>            : 
<span class="lineNum">    1764 </span><span class="lineNoCov">          0 :     g1 = sint*rho1;</span>
<span class="lineNum">    1765 </span><span class="lineNoCov">          0 :     g2 = cost*rho1;</span>
<span class="lineNum">    1766 </span><span class="lineNoCov">          0 :     g3 = (tet-sint) * hp*rho1;</span>
<span class="lineNum">    1767 </span><span class="lineNoCov">          0 :     g4 = -cost;</span>
<span class="lineNum">    1768 </span>            :     g5 = sint;
<span class="lineNum">    1769 </span><span class="lineNoCov">          0 :     g6 = cost * hp;</span>
<span class="lineNum">    1770 </span>            :  
<span class="lineNum">    1771 </span><span class="lineNoCov">          0 :     vout[kix] = vect[kix] + g1*vect[kipx] + g2*hxp[0] + g3*f1;</span>
<span class="lineNum">    1772 </span><span class="lineNoCov">          0 :     vout[kiy] = vect[kiy] + g1*vect[kipy] + g2*hxp[1] + g3*f2;</span>
<span class="lineNum">    1773 </span><span class="lineNoCov">          0 :     vout[kiz] = vect[kiz] + g1*vect[kipz] + g2*hxp[2] + g3*f3;</span>
<span class="lineNum">    1774 </span>            :  
<span class="lineNum">    1775 </span><span class="lineNoCov">          0 :     vout[kipx] = vect[kipx] + g4*vect[kipx] + g5*hxp[0] + g6*f1;</span>
<span class="lineNum">    1776 </span><span class="lineNoCov">          0 :     vout[kipy] = vect[kipy] + g4*vect[kipy] + g5*hxp[1] + g6*f2;</span>
<span class="lineNum">    1777 </span><span class="lineNoCov">          0 :     vout[kipz] = vect[kipz] + g4*vect[kipz] + g5*hxp[2] + g6*f3;</span>
<span class="lineNum">    1778 </span>            : 
<span class="lineNum">    1779 </span><span class="lineNoCov">          0 :     return kTRUE;</span>
<span class="lineNum">    1780 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1781 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
