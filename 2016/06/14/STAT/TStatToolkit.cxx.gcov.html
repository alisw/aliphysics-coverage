<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - STAT/TStatToolkit.cxx</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">STAT</a> - TStatToolkit.cxx<span style="font-size: 80%;"> (source / <a href="TStatToolkit.cxx.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">1415</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">38</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**************************************************************************</a>
<span class="lineNum">       2 </span>            :  * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
<span class="lineNum">       3 </span>            :  *                                                                        *
<span class="lineNum">       4 </span>            :  * Author: The ALICE Off-line Project.                                    *
<span class="lineNum">       5 </span>            :  * Contributors are mentioned in the code where appropriate.              *
<span class="lineNum">       6 </span>            :  *                                                                        *
<span class="lineNum">       7 </span>            :  * Permission to use, copy, modify and distribute this software and its   *
<span class="lineNum">       8 </span>            :  * documentation strictly for non-commercial purposes is hereby granted   *
<span class="lineNum">       9 </span>            :  * without fee, provided that the above copyright notice appears in all   *
<span class="lineNum">      10 </span>            :  * copies and that both the copyright notice and this permission notice   *
<span class="lineNum">      11 </span>            :  * appear in the supporting documentation. The authors make no claims     *
<span class="lineNum">      12 </span>            :  * about the suitability of this software for any purpose. It is          *
<span class="lineNum">      13 </span>            :  * provided &quot;as is&quot; without express or implied warranty.                  *
<span class="lineNum">      14 </span>            :  **************************************************************************/
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : ///////////////////////////////////////////////////////////////////////////
<span class="lineNum">      18 </span>            : /// \file TStatToolkit.cxx
<span class="lineNum">      19 </span>            : /// \class TStatToolkit
<span class="lineNum">      20 </span>            : /// \brief Summary of statistics functions
<span class="lineNum">      21 </span>            : /// Subset of  matheamtical functions  not included in the TMath
<span class="lineNum">      22 </span>            : //
<span class="lineNum">      23 </span>            : //
<span class="lineNum">      24 </span>            : /////////////////////////////////////////////////////////////////////////
<span class="lineNum">      25 </span>            : #include &quot;TStopwatch.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;TStatToolkit.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;TTreeFormula.h&quot;
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : using std::cout;
<span class="lineNum">      30 </span>            : using std::cerr;
<span class="lineNum">      31 </span>            : using std::endl;
<a name="32"><span class="lineNum">      32 </span>            : </a>
<span class="lineNum">      33 </span>            : //_____________________________________________________________________________
<span class="lineNum">      34 </span>            : void TStatToolkit::EvaluateUni(Int_t nvectors, Double_t *data, Double_t &amp;mean
<span class="lineNum">      35 </span>            :                            , Double_t &amp;sigma, Int_t hh)
<span class="lineNum">      36 </span>            : {
<span class="lineNum">      37 </span>            :   //
<span class="lineNum">      38 </span>            :   // Robust estimator in 1D case MI version - (faster than ROOT version)
<span class="lineNum">      39 </span>            :   //
<span class="lineNum">      40 </span>            :   // For the univariate case
<span class="lineNum">      41 </span>            :   // estimates of location and scatter are returned in mean and sigma parameters
<span class="lineNum">      42 </span>            :   // the algorithm works on the same principle as in multivariate case -
<span class="lineNum">      43 </span>            :   // it finds a subset of size hh with smallest sigma, and then returns mean and
<span class="lineNum">      44 </span>            :   // sigma of this subset
<span class="lineNum">      45 </span>            :   //
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span><span class="lineNoCov">          0 :   if (hh==0)</span>
<span class="lineNum">      48 </span><span class="lineNoCov">          0 :     hh=(nvectors+2)/2;</span>
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :   Double_t faclts[]={2.6477,2.5092,2.3826,2.2662,2.1587,2.0589,1.9660,1.879,1.7973,1.7203,1.6473};</span>
<span class="lineNum">      50 </span><span class="lineNoCov">          0 :   Int_t *index=new Int_t[nvectors];</span>
<span class="lineNum">      51 </span><span class="lineNoCov">          0 :   TMath::Sort(nvectors, data, index, kFALSE);</span>
<span class="lineNum">      52 </span>            :   
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :   Int_t    nquant = TMath::Min(Int_t(Double_t(((hh*1./nvectors)-0.5)*40))+1, 11);</span>
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :   Double_t factor = faclts[TMath::Max(0,nquant-1)];</span>
<span class="lineNum">      55 </span>            :   
<span class="lineNum">      56 </span>            :   Double_t sumx  =0;
<span class="lineNum">      57 </span>            :   Double_t sumx2 =0;
<span class="lineNum">      58 </span>            :   Int_t    bestindex = -1;
<span class="lineNum">      59 </span>            :   Double_t bestmean  = 0; 
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :   Double_t bestsigma = (data[index[nvectors-1]]-data[index[0]]+1.);   // maximal possible sigma</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :   bestsigma *=bestsigma;</span>
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;hh; i++){</span>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :     sumx  += data[index[i]];</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :     sumx2 += data[index[i]]*data[index[i]];</span>
<span class="lineNum">      66 </span>            :   }
<span class="lineNum">      67 </span>            :   
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :   Double_t norm = 1./Double_t(hh);</span>
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :   Double_t norm2 = (hh-1)&gt;0 ? 1./Double_t(hh-1):1;</span>
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :   for (Int_t i=hh; i&lt;nvectors; i++){</span>
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :     Double_t cmean  = sumx*norm;</span>
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :     Double_t csigma = (sumx2 - hh*cmean*cmean)*norm2;</span>
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :     if (csigma&lt;bestsigma){</span>
<span class="lineNum">      74 </span>            :       bestmean  = cmean;
<span class="lineNum">      75 </span>            :       bestsigma = csigma;
<span class="lineNum">      76 </span>            :       bestindex = i-hh;
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">      78 </span>            :     
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :     sumx  += data[index[i]]-data[index[i-hh]];</span>
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :     sumx2 += data[index[i]]*data[index[i]]-data[index[i-hh]]*data[index[i-hh]];</span>
<span class="lineNum">      81 </span>            :   }
<span class="lineNum">      82 </span>            :   
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :   Double_t bstd=factor*TMath::Sqrt(TMath::Abs(bestsigma));</span>
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :   mean  = bestmean;</span>
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :   sigma = bstd;</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :   delete [] index;</span>
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      89 </span>            : 
<a name="90"><span class="lineNum">      90 </span>            : </a>
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            : void TStatToolkit::EvaluateUniExternal(Int_t nvectors, Double_t *data, Double_t &amp;mean, Double_t &amp;sigma, Int_t hh,  Float_t externalfactor)
<span class="lineNum">      93 </span>            : {
<span class="lineNum">      94 </span>            :   // Modified version of ROOT robust EvaluateUni
<span class="lineNum">      95 </span>            :   // robust estimator in 1D case MI version
<span class="lineNum">      96 </span>            :   // added external factor to include precision of external measurement
<span class="lineNum">      97 </span>            :   // 
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :   if (hh==0)</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :     hh=(nvectors+2)/2;</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :   Double_t faclts[]={2.6477,2.5092,2.3826,2.2662,2.1587,2.0589,1.9660,1.879,1.7973,1.7203,1.6473};</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :   Int_t *index=new Int_t[nvectors];</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :   TMath::Sort(nvectors, data, index, kFALSE);</span>
<span class="lineNum">     104 </span>            :   //
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :   Int_t    nquant = TMath::Min(Int_t(Double_t(((hh*1./nvectors)-0.5)*40))+1, 11);</span>
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :   Double_t factor = faclts[0];</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :   if (nquant&gt;0){</span>
<span class="lineNum">     108 </span>            :     // fix proper normalization - Anja
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :     factor = faclts[nquant-1];</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span>            :   //
<span class="lineNum">     113 </span>            :   //
<span class="lineNum">     114 </span>            :   Double_t sumx  =0;
<span class="lineNum">     115 </span>            :   Double_t sumx2 =0;
<span class="lineNum">     116 </span>            :   Int_t    bestindex = -1;
<span class="lineNum">     117 </span>            :   Double_t bestmean  = 0; 
<span class="lineNum">     118 </span>            :   Double_t bestsigma = -1;
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;hh; i++){</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :     sumx  += data[index[i]];</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :     sumx2 += data[index[i]]*data[index[i]];</span>
<span class="lineNum">     122 </span>            :   }
<span class="lineNum">     123 </span>            :   //   
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :   Double_t kfactor = 2.*externalfactor - externalfactor*externalfactor;</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :   Double_t norm = 1./Double_t(hh);</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :   for (Int_t i=hh; i&lt;nvectors; i++){</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :     Double_t cmean  = sumx*norm;</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :     Double_t csigma = (sumx2*norm - cmean*cmean*kfactor);</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :     if (csigma&lt;bestsigma ||  bestsigma&lt;0){</span>
<span class="lineNum">     130 </span>            :       bestmean  = cmean;
<span class="lineNum">     131 </span>            :       bestsigma = csigma;
<span class="lineNum">     132 </span>            :       bestindex = i-hh;
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     134 </span>            :     //
<span class="lineNum">     135 </span>            :     //
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :     sumx  += data[index[i]]-data[index[i-hh]];</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :     sumx2 += data[index[i]]*data[index[i]]-data[index[i-hh]]*data[index[i-hh]];</span>
<span class="lineNum">     138 </span>            :   }
<span class="lineNum">     139 </span>            :   
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :   Double_t bstd=factor*TMath::Sqrt(TMath::Abs(bestsigma));</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :   mean  = bestmean;</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :   sigma = bstd;</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :   delete [] index;</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     145 </span>            : 
<a name="146"><span class="lineNum">     146 </span>            : </a>
<span class="lineNum">     147 </span>            : //_____________________________________________________________________________
<span class="lineNum">     148 </span>            : Int_t TStatToolkit::Freq(Int_t n, const Int_t *inlist
<span class="lineNum">     149 </span>            :                         , Int_t *outlist, Bool_t down)
<span class="lineNum">     150 </span>            : {    
<span class="lineNum">     151 </span>            :   //
<span class="lineNum">     152 </span>            :   //  Sort eleements according occurancy 
<span class="lineNum">     153 </span>            :   //  The size of output array has is 2*n 
<span class="lineNum">     154 </span>            :   //
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :   Int_t * sindexS = new Int_t[n];     // temp array for sorting</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :   Int_t * sindexF = new Int_t[2*n];   </span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :   for (Int_t i=0;i&lt;n;i++) sindexS[i]=0;</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :   for (Int_t i=0;i&lt;2*n;i++) sindexF[i]=0;</span>
<span class="lineNum">     160 </span>            :   //
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :   TMath::Sort(n,inlist, sindexS, down);  </span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :   Int_t last      = inlist[sindexS[0]];</span>
<span class="lineNum">     163 </span>            :   Int_t val       = last;
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :   sindexF[0]      = 1;</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :   sindexF[0+n]    = last;</span>
<span class="lineNum">     166 </span>            :   Int_t countPos  = 0;
<span class="lineNum">     167 </span>            :   //
<span class="lineNum">     168 </span>            :   //  find frequency
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :   for(Int_t i=1;i&lt;n; i++){</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :     val = inlist[sindexS[i]];</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :     if (last == val)   sindexF[countPos]++;</span>
<span class="lineNum">     172 </span>            :     else{      
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :       countPos++;</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :       sindexF[countPos+n] = val;</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :       sindexF[countPos]++;</span>
<span class="lineNum">     176 </span>            :       last =val;
<span class="lineNum">     177 </span>            :     }
<span class="lineNum">     178 </span>            :   }
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :   if (last==val) countPos++;</span>
<span class="lineNum">     180 </span>            :   // sort according frequency
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :   TMath::Sort(countPos, sindexF, sindexS, kTRUE);</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :   for (Int_t i=0;i&lt;countPos;i++){</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :     outlist[2*i  ] = sindexF[sindexS[i]+n];</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :     outlist[2*i+1] = sindexF[sindexS[i]];</span>
<span class="lineNum">     185 </span>            :   }
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :   delete [] sindexS;</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :   delete [] sindexF;</span>
<span class="lineNum">     188 </span>            :   
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :   return countPos;</span>
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span>            : }
<span class="lineNum">     192 </span>            : 
<a name="193"><span class="lineNum">     193 </span>            : </a>
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            : void TStatToolkit::MedianFilter(TH1 * his1D, Int_t nmedian){
<span class="lineNum">     196 </span>            :   //
<span class="lineNum">     197 </span>            :   // Algorithm to filter  histogram
<span class="lineNum">     198 </span>            :   // author:  marian.ivanov@cern.ch
<span class="lineNum">     199 </span>            :   // Details of algorithm:
<span class="lineNum">     200 </span>            :   // http://en.wikipedia.org/w/index.php?title=Median_filter&amp;oldid=582191524
<span class="lineNum">     201 </span>            :   // Input parameters:
<span class="lineNum">     202 </span>            :   //    his1D - input histogam - to be modiefied by Medianfilter
<span class="lineNum">     203 </span>            :   //    nmendian - number of bins in median filter
<span class="lineNum">     204 </span>            :   //
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :   Int_t nbins    = his1D-&gt;GetNbinsX();</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :   TVectorD vectorH(nbins);</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :   for (Int_t ibin=0; ibin&lt;nbins; ibin++) vectorH[ibin]=his1D-&gt;GetBinContent(ibin+1);</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :   for (Int_t ibin=0; ibin&lt;nbins; ibin++) {</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :     Int_t index0=ibin-nmedian;</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :     Int_t index1=ibin+nmedian;</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :     if (index0&lt;0) {index1+=-index0; index0=0;}</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :     if (index1&gt;=nbins) {index0-=index1-nbins+1; index1=nbins-1;}    </span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :     Double_t value= TMath::Median(index1-index0,&amp;(vectorH.GetMatrixArray()[index0]));</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :     his1D-&gt;SetBinContent(ibin+1, value);</span>
<span class="lineNum">     215 </span>            :   }  
<span class="lineNum">     216 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     217 </span>            : 
<a name="218"><span class="lineNum">     218 </span>            : </a>
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            : Float_t TStatToolkit::GetCOG(const Short_t *arr, Int_t nBins, Float_t xMin, Float_t xMax, Float_t *rms, Float_t *sum)
<span class="lineNum">     221 </span>            : {
<span class="lineNum">     222 </span>            :     //
<span class="lineNum">     223 </span>            :     //  calculate center of gravity rms and sum for array 'arr' with nBins an a x range xMin to xMax
<span class="lineNum">     224 </span>            :     //  return COG; in case of failure return xMin
<span class="lineNum">     225 </span>            :     //
<span class="lineNum">     226 </span>            :     Float_t meanCOG = 0;
<span class="lineNum">     227 </span>            :     Float_t rms2COG = 0;
<span class="lineNum">     228 </span>            :     Float_t sumCOG  = 0;
<span class="lineNum">     229 </span>            :     Int_t npoints   = 0;
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :     Float_t binWidth = (xMax-xMin)/(Float_t)nBins;</span>
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :     for (Int_t ibin=0; ibin&lt;nBins; ibin++){</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :         Float_t entriesI = (Float_t)arr[ibin];</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :         Double_t xcenter = xMin+(ibin+0.5)*binWidth;</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :         if ( entriesI&gt;0 ){</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :             meanCOG += xcenter*entriesI;</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :             rms2COG += xcenter*entriesI*xcenter;</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :             sumCOG  += entriesI;</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :             npoints++;</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     242 </span>            :     }
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :     if ( sumCOG == 0 ) return xMin;</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :     meanCOG/=sumCOG;</span>
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :     if ( rms ){</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :         rms2COG /=sumCOG;</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :         (*rms) = TMath::Sqrt(TMath::Abs(meanCOG*meanCOG-rms2COG));</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :         if ( npoints == 1 ) (*rms) = binWidth/TMath::Sqrt(12);</span>
<span class="lineNum">     250 </span>            :     }
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :     if ( sum )</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :         (*sum) = sumCOG;</span>
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :     return meanCOG;</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            : ///////////////////////////////////////////////////////////////
<span class="lineNum">     261 </span>            : //////////////         TEST functions /////////////////////////
<span class="lineNum">     262 </span>            : ///////////////////////////////////////////////////////////////
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            : 
<a name="266"><span class="lineNum">     266 </span>            : </a>
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span>            : void TStatToolkit::TestGausFit(Int_t nhistos){
<span class="lineNum">     269 </span>            :   //
<span class="lineNum">     270 </span>            :   // Test performance of the parabolic - gaussian fit - compare it with 
<span class="lineNum">     271 </span>            :   // ROOT gauss fit
<span class="lineNum">     272 </span>            :   //  nhistos - number of histograms to be used for test
<span class="lineNum">     273 </span>            :   //
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :   TTreeSRedirector *pcstream = new TTreeSRedirector(&quot;fitdebug.root&quot;,&quot;recreate&quot;);</span>
<span class="lineNum">     275 </span>            :   
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :   Float_t  *xTrue = new Float_t[nhistos];</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :   Float_t  *sTrue = new Float_t[nhistos];</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :   TVectorD **par1  = new TVectorD*[nhistos];</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :   TVectorD **par2  = new TVectorD*[nhistos];</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :   TMatrixD dummy(3,3);</span>
<span class="lineNum">     281 </span>            :   
<span class="lineNum">     282 </span>            :   
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :   TH1F **h1f = new TH1F*[nhistos];</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :   TF1  *myg = new TF1(&quot;myg&quot;,&quot;gaus&quot;);</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :   TF1  *fit = new TF1(&quot;fit&quot;,&quot;gaus&quot;);</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :   gRandom-&gt;SetSeed(0);</span>
<span class="lineNum">     287 </span>            :   
<span class="lineNum">     288 </span>            :   //init
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :   for (Int_t i=0;i&lt;nhistos; i++){</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :     par1[i] = new TVectorD(3);</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :     par2[i] = new TVectorD(3);</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :     h1f[i]  = new TH1F(Form(&quot;h1f%d&quot;,i),Form(&quot;h1f%d&quot;,i),20,-10,10);</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :     xTrue[i]= gRandom-&gt;Rndm();</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :     gSystem-&gt;Sleep(2);</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :     sTrue[i]= .75+gRandom-&gt;Rndm()*.5;</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :     myg-&gt;SetParameters(1,xTrue[i],sTrue[i]);</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :     h1f[i]-&gt;FillRandom(&quot;myg&quot;);</span>
<span class="lineNum">     298 </span>            :   }
<span class="lineNum">     299 </span>            :   
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :   TStopwatch s; </span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :   s.Start();</span>
<span class="lineNum">     302 </span>            :   //standard gaus fit
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;nhistos; i++){</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :     h1f[i]-&gt;Fit(fit,&quot;0q&quot;);</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :     (*par1[i])(0) = fit-&gt;GetParameter(0);</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :     (*par1[i])(1) = fit-&gt;GetParameter(1);</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :     (*par1[i])(2) = fit-&gt;GetParameter(2);</span>
<span class="lineNum">     308 </span>            :   }
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :   s.Stop();</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :   printf(&quot;Gaussian fit\t&quot;);</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :   s.Print();</span>
<span class="lineNum">     312 </span>            :   
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :   s.Start();</span>
<span class="lineNum">     314 </span>            :   //TStatToolkit gaus fit
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;nhistos; i++){</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :     TStatToolkit::FitGaus(h1f[i]-&gt;GetArray()+1,h1f[i]-&gt;GetNbinsX(),h1f[i]-&gt;GetXaxis()-&gt;GetXmin(),h1f[i]-&gt;GetXaxis()-&gt;GetXmax(),par2[i],&amp;dummy);</span>
<span class="lineNum">     317 </span>            :   }
<span class="lineNum">     318 </span>            :   
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :   s.Stop();</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :   printf(&quot;Parabolic fit\t&quot;);</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :   s.Print();</span>
<span class="lineNum">     322 </span>            :   //write stream
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :   for (Int_t i=0;i&lt;nhistos; i++){</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :     Float_t xt  = xTrue[i];</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :     Float_t st  = sTrue[i];</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :     (*pcstream)&lt;&lt;&quot;data&quot;</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :                &lt;&lt;&quot;xTrue=&quot;&lt;&lt;xt</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :                &lt;&lt;&quot;sTrue=&quot;&lt;&lt;st</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :                &lt;&lt;&quot;pg.=&quot;&lt;&lt;(par1[i])</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :                &lt;&lt;&quot;pa.=&quot;&lt;&lt;(par2[i])</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :                &lt;&lt;&quot;\n&quot;;</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :   }    </span>
<span class="lineNum">     333 </span>            :   //delete pointers
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :   for (Int_t i=0;i&lt;nhistos; i++){</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :     delete par1[i];</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :     delete par2[i];</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :     delete h1f[i];</span>
<span class="lineNum">     338 </span>            :   }
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :   delete pcstream;</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :   delete []h1f;</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :   delete []xTrue;</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :   delete []sTrue;</span>
<span class="lineNum">     343 </span>            :   //
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :   delete []par1;</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :   delete []par2;</span>
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     348 </span>            : 
<a name="349"><span class="lineNum">     349 </span>            : </a>
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span>            : TGraph2D * TStatToolkit::MakeStat2D(TH3 * his, Int_t delta0, Int_t delta1, Int_t type){
<span class="lineNum">     352 </span>            :   //
<span class="lineNum">     353 </span>            :   //
<span class="lineNum">     354 </span>            :   //
<span class="lineNum">     355 </span>            :   // delta - number of bins to integrate
<span class="lineNum">     356 </span>            :   // type - 0 - mean value
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :   TAxis * xaxis  = his-&gt;GetXaxis();</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :   TAxis * yaxis  = his-&gt;GetYaxis();</span>
<span class="lineNum">     360 </span>            :   //  TAxis * zaxis  = his-&gt;GetZaxis();
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :   Int_t   nbinx  = xaxis-&gt;GetNbins();</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :   Int_t   nbiny  = yaxis-&gt;GetNbins();</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :   char name[1000];</span>
<span class="lineNum">     364 </span>            :   Int_t icount=0;
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :   TGraph2D  *graph = new TGraph2D(nbinx*nbiny);</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :   TF1 f1(&quot;f1&quot;,&quot;gaus&quot;);</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :   for (Int_t ix=0; ix&lt;nbinx;ix++)</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :     for (Int_t iy=0; iy&lt;nbiny;iy++){</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :       Float_t xcenter = xaxis-&gt;GetBinCenter(ix); </span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :       Float_t ycenter = yaxis-&gt;GetBinCenter(iy); </span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :       snprintf(name,1000,&quot;%s_%d_%d&quot;,his-&gt;GetName(), ix,iy);</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :       TH1 *projection = his-&gt;ProjectionZ(name,ix-delta0,ix+delta0,iy-delta1,iy+delta1);</span>
<span class="lineNum">     373 </span>            :       Float_t stat= 0;
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :       if (type==0) stat = projection-&gt;GetMean();</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :       if (type==1) stat = projection-&gt;GetRMS();</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :       if (type==2 || type==3){</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :         TVectorD vec(10);</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :         TStatToolkit::LTM((TH1F*)projection,&amp;vec,0.7);</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :         if (type==2) stat= vec[1];</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :         if (type==3) stat= vec[0];      </span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :       if (type==4|| type==5){</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :         projection-&gt;Fit(&amp;f1);</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :         if (type==4) stat= f1.GetParameter(1);</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :         if (type==5) stat= f1.GetParameter(2);</span>
<span class="lineNum">     386 </span>            :       }
<span class="lineNum">     387 </span>            :       //printf(&quot;%d\t%f\t%f\t%f\n&quot;, icount,xcenter, ycenter, stat);
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :       graph-&gt;SetPoint(icount,xcenter, ycenter, stat);</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :       icount++;</span>
<span class="lineNum">     390 </span>            :     }
<span class="lineNum">     391 </span>            :   return graph;
<a name="392"><span class="lineNum">     392 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span>            : TGraphErrors * TStatToolkit::MakeStat1D(TH2 * his, Int_t deltaBin, Double_t fraction, Int_t returnType, Int_t markerStyle, Int_t markerColor){
<span class="lineNum">     395 </span>            :   //
<span class="lineNum">     396 </span>            :   // function to retrieve the &quot;mean and RMS estimate&quot; of 2D histograms
<span class="lineNum">     397 </span>            :   //     
<span class="lineNum">     398 </span>            :   // Robust statistic to estimate properties of the distribution
<span class="lineNum">     399 </span>            :   // See http://en.wikipedia.org/wiki/Trimmed_estimator
<span class="lineNum">     400 </span>            :   //
<span class="lineNum">     401 </span>            :   // deltaBin - number of bins to integrate (bin+-deltaBin)
<span class="lineNum">     402 </span>            :   // fraction - fraction of values for the LTM and for the gauss fit
<span class="lineNum">     403 </span>            :   // returnType - 
<span class="lineNum">     404 </span>            :   //        0 - mean value
<span class="lineNum">     405 </span>            :   //        1 - RMS
<span class="lineNum">     406 </span>            :   //        2 - LTM mean
<span class="lineNum">     407 </span>            :   //        3 - LTM sigma
<span class="lineNum">     408 </span>            :   //        4 - Gaus fit mean  - on LTM range
<span class="lineNum">     409 </span>            :   //        5 - Gaus fit sigma - on LTM  range
<span class="lineNum">     410 </span>            :   //        6 - Robust bin median
<span class="lineNum">     411 </span>            :   // 
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :   TAxis * xaxis  = his-&gt;GetXaxis();</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :   Int_t   nbinx  = xaxis-&gt;GetNbins();</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :   char name[1000];</span>
<span class="lineNum">     415 </span>            :   Int_t icount=0;
<span class="lineNum">     416 </span>            :   //
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :   TVectorD vecX(nbinx);</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :   TVectorD vecXErr(nbinx);</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :   TVectorD vecY(nbinx);</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :   TVectorD vecYErr(nbinx);</span>
<span class="lineNum">     421 </span>            :   //
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :   TF1 f1(&quot;f1&quot;,&quot;gaus&quot;);</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :   TVectorD vecLTM(10);</span>
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :   for (Int_t jx=1; jx&lt;=nbinx;jx++){</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :     Int_t ix=jx-1;</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :     Float_t xcenter = xaxis-&gt;GetBinCenter(jx); </span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :     snprintf(name,1000,&quot;%s_%d&quot;,his-&gt;GetName(), ix);</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :     TH1 *projection = his-&gt;ProjectionY(name,TMath::Max(jx-deltaBin,1),TMath::Min(jx+deltaBin,nbinx));</span>
<span class="lineNum">     430 </span>            :     Double_t stat= 0;
<span class="lineNum">     431 </span>            :     Double_t err =0;
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :     TStatToolkit::LTMHisto((TH1F*)projection,vecLTM,fraction);  </span>
<span class="lineNum">     433 </span>            :     //
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :     if (returnType==0) {</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :       stat = projection-&gt;GetMean();</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :       err  = projection-&gt;GetMeanError();</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :     else if (returnType==1) {</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :       stat = projection-&gt;GetRMS();</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :       err = projection-&gt;GetRMSError();</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :     else if (returnType==2 || returnType==3){</span>
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :       if (returnType==2) {stat= vecLTM[1];  err =projection-&gt;GetRMSError();}</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :         if (returnType==3) {stat= vecLTM[2];     err =projection-&gt;GetRMSError();}</span>
<span class="lineNum">     445 </span>            :     }
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :     else if (returnType==4|| returnType==5){</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :       f1.SetParameters(vecLTM[0], vecLTM[1], vecLTM[2]+0.05);</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :       projection-&gt;Fit(&amp;f1,&quot;QN&quot;,&quot;QN&quot;, vecLTM[7]-vecLTM[2], vecLTM[8]+vecLTM[2]);</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :       if (returnType==4) {</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :         stat= f1.GetParameter(1);</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :         err=f1.GetParError(1);</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :       if (returnType==5) {</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :         stat= f1.GetParameter(2);</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :         err=f1.GetParError(2);</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     457 </span>            :     }
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :     else if (returnType==6) {</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :       stat=RobustBinMedian(projection,fraction);</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :     vecX[icount]=xcenter;</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :     vecY[icount]=stat;</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :     vecYErr[icount]=err;</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :     icount++;</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :     delete projection;</span>
<span class="lineNum">     467 </span>            :   }
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :   TGraphErrors  *graph = new TGraphErrors(icount,vecX.GetMatrixArray(), vecY.GetMatrixArray(),0, vecYErr.GetMatrixArray());</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :   graph-&gt;SetMarkerStyle(markerStyle);</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :   graph-&gt;SetMarkerColor(markerColor);</span>
<span class="lineNum">     471 </span>            :   return graph;
<a name="472"><span class="lineNum">     472 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span>            : Double_t TStatToolkit::RobustBinMedian(TH1* hist, Double_t fractionCut/*=1.*/)
<span class="lineNum">     475 </span>            : {
<span class="lineNum">     476 </span>            :   // Robust median with average from neighbouring bins
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :   const Int_t nbins1D=hist-&gt;GetNbinsX();</span>
<span class="lineNum">     478 </span>            :   Double_t binMedian=0;
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :   Double_t limits[2]={hist-&gt;GetBinCenter(1), hist-&gt;GetBinCenter(nbins1D)};</span>
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :   Double_t* integral=hist-&gt;GetIntegral();</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :   for (Int_t i=1; i&lt;nbins1D-1; i++){</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :     if (integral[i-1]&lt;0.5 &amp;&amp; integral[i]&gt;=0.5){</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :       if (hist-&gt;GetBinContent(i-1)+hist-&gt;GetBinContent(i)&gt;0){</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :         binMedian=hist-&gt;GetBinCenter(i);</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :         Double_t dIdx=-(integral[i-1]-integral[i]);</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :         Double_t dx=(0.5+(0.5-integral[i])/dIdx)*hist-&gt;GetBinWidth(i);</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :         binMedian+=dx;</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     490 </span>            :     }
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :     if (integral[i-1]&lt;fractionCut &amp;&amp; integral[i]&gt;=fractionCut){</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :       limits[0]=hist-&gt;GetBinCenter(i-1)-hist-&gt;GetBinWidth(i);</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :     if (integral[i]&lt;1-fractionCut &amp;&amp; integral[i+1]&gt;=1-fractionCut){</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :       limits[1]=hist-&gt;GetBinCenter(i+1)+hist-&gt;GetBinWidth(i);</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     497 </span>            :   }
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :   return binMedian;</span>
<span class="lineNum">     500 </span>            : }
<a name="501"><span class="lineNum">     501 </span>            : </a>
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span>            : TString* TStatToolkit::FitPlane(TTree *tree, const char* drawCommand, const char* formula, const char* cuts, Double_t &amp; chi2, Int_t &amp;npoints, TVectorD &amp;fitParam, TMatrixD &amp;covMatrix, Float_t frac, Int_t start, Int_t stop,Bool_t fix0){
<span class="lineNum">     504 </span>            :    //
<span class="lineNum">     505 </span>            :    // fit an arbitrary function, specified by formula into the data, specified by drawCommand and cuts
<span class="lineNum">     506 </span>            :    // returns chi2, fitParam and covMatrix
<span class="lineNum">     507 </span>            :    // returns TString with fitted formula
<span class="lineNum">     508 </span>            :    //
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :    TString formulaStr(formula); </span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :    TString drawStr(drawCommand);</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :    TString cutStr(cuts);</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :    TString ferr(&quot;1&quot;);</span>
<span class="lineNum">     514 </span>            : 
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :    TString strVal(drawCommand);</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :    if (strVal.Contains(&quot;:&quot;)){</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :      TObjArray* valTokens = strVal.Tokenize(&quot;:&quot;);</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :      drawStr = valTokens-&gt;At(0)-&gt;GetName();</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :      ferr       = valTokens-&gt;At(1)-&gt;GetName();     </span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :      delete valTokens;</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :    }</span>
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span>            :       
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :    formulaStr.ReplaceAll(&quot;++&quot;, &quot;~&quot;);</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :    TObjArray* formulaTokens = formulaStr.Tokenize(&quot;~&quot;); </span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :    Int_t dim = formulaTokens-&gt;GetEntriesFast();</span>
<span class="lineNum">     527 </span>            :    
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :    fitParam.ResizeTo(dim);</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :    covMatrix.ResizeTo(dim,dim);</span>
<span class="lineNum">     530 </span>            :    
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :    TLinearFitter* fitter = new TLinearFitter(dim+1, Form(&quot;hyp%d&quot;,dim));</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :    fitter-&gt;StoreData(kTRUE);   </span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :    fitter-&gt;ClearPoints();</span>
<span class="lineNum">     534 </span>            :    
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :    Int_t entries = tree-&gt;Draw(drawStr.Data(), cutStr.Data(), &quot;goff&quot;,  stop-start, start);</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :    if (entries == -1) {</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :      delete formulaTokens;</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :      return new TString(TString::Format(&quot;ERROR expr: %s\t%s\tEntries==0&quot;,drawStr.Data(),cutStr.Data()));</span>
<span class="lineNum">     539 </span>            :    }
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :    Double_t **values = new Double_t*[dim+1] ;</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :    for (Int_t i=0; i&lt;dim+1; i++) values[i]=NULL; </span>
<span class="lineNum">     542 </span>            :    //
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :    entries = tree-&gt;Draw(ferr.Data(), cutStr.Data(), &quot;goff&quot;,  stop-start, start);</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :    if (entries == -1) {</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :      delete formulaTokens;</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :      delete []values;</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :      return new TString(TString::Format(&quot;ERROR error part: %s\t%s\tEntries==0&quot;,ferr.Data(),cutStr.Data()));</span>
<span class="lineNum">     548 </span>            :    }
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :    Double_t *errors = new Double_t[entries];</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :    memcpy(errors,  tree-&gt;GetV1(), entries*sizeof(Double_t));</span>
<span class="lineNum">     551 </span>            :    
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :    for (Int_t i = 0; i &lt; dim + 1; i++){</span>
<span class="lineNum">     553 </span>            :       Int_t centries = 0;
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :       if (i &lt; dim) centries = tree-&gt;Draw(((TObjString*)formulaTokens-&gt;At(i))-&gt;GetName(), cutStr.Data(), &quot;goff&quot;, stop-start,start);</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :       else  centries = tree-&gt;Draw(drawStr.Data(), cutStr.Data(), &quot;goff&quot;, stop-start,start);</span>
<span class="lineNum">     556 </span>            :       
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :       if (entries != centries) {</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :         delete []errors;</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :         delete []values;</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :         return new TString(TString::Format(&quot;ERROR: %s\t%s\tEntries==%d\tEntries2=%d\n&quot;,drawStr.Data(),cutStr.Data(),entries,centries));</span>
<span class="lineNum">     561 </span>            :       }
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :       values[i] = new Double_t[entries];</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :       memcpy(values[i],  tree-&gt;GetV1(), entries*sizeof(Double_t)); </span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :    }</span>
<span class="lineNum">     565 </span>            :    
<span class="lineNum">     566 </span>            :    // add points to the fitter
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :    for (Int_t i = 0; i &lt; entries; i++){</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :       Double_t x[1000];</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :       for (Int_t j=0; j&lt;dim;j++) x[j]=values[j][i];</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :       fitter-&gt;AddPoint(x, values[dim][i], errors[i]);</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :    }</span>
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :    fitter-&gt;Eval();</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :    if (frac&gt;0.5 &amp;&amp; frac&lt;1){</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :      fitter-&gt;EvalRobust(frac);</span>
<span class="lineNum">     576 </span>            :    }else{
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :      if (fix0) {</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :        fitter-&gt;FixParameter(0,0);</span>
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :        fitter-&gt;Eval();     </span>
<span class="lineNum">     580 </span>            :      }
<span class="lineNum">     581 </span>            :    }
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :    fitter-&gt;GetParameters(fitParam);</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :    fitter-&gt;GetCovarianceMatrix(covMatrix);</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :    chi2 = fitter-&gt;GetChisquare();</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :    npoints = entries;   </span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :    TString *preturnFormula = new TString(Form(&quot;( %f+&quot;,fitParam[0])), &amp;returnFormula = *preturnFormula; </span>
<span class="lineNum">     587 </span>            :    
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :    for (Int_t iparam = 0; iparam &lt; dim; iparam++) {</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :      returnFormula.Append(Form(&quot;%s*(%f)&quot;,((TObjString*)formulaTokens-&gt;At(iparam))-&gt;GetName(),fitParam[iparam+1]));</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :      if (iparam &lt; dim-1) returnFormula.Append(&quot;+&quot;);</span>
<span class="lineNum">     591 </span>            :    }
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :    returnFormula.Append(&quot; )&quot;);</span>
<span class="lineNum">     593 </span>            :    
<span class="lineNum">     594 </span>            :    
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :    for (Int_t j=0; j&lt;dim+1;j++) delete [] values[j];</span>
<span class="lineNum">     596 </span>            : 
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :    delete formulaTokens;</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :    delete fitter;</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :    delete[] values;</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :    delete[] errors;</span>
<span class="lineNum">     602 </span>            :    return preturnFormula;
<a name="603"><span class="lineNum">     603 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span>            : TString* TStatToolkit::FitPlaneConstrain(TTree *tree, const char* drawCommand, const char* formula, const char* cuts, Double_t &amp; chi2, Int_t &amp;npoints, TVectorD &amp;fitParam, TMatrixD &amp;covMatrix, Float_t frac, Int_t start, Int_t stop,Double_t constrain){
<span class="lineNum">     606 </span>            :    //
<span class="lineNum">     607 </span>            :    // fit an arbitrary function, specified by formula into the data, specified by drawCommand and cuts
<span class="lineNum">     608 </span>            :    // returns chi2, fitParam and covMatrix
<span class="lineNum">     609 </span>            :    // returns TString with fitted formula
<span class="lineNum">     610 </span>            :    //
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :    TString formulaStr(formula); </span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :    TString drawStr(drawCommand);</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :    TString cutStr(cuts);</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :    TString ferr(&quot;1&quot;);</span>
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :    TString strVal(drawCommand);</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :    if (strVal.Contains(&quot;:&quot;)){</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :      TObjArray* valTokens = strVal.Tokenize(&quot;:&quot;);</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :      drawStr = valTokens-&gt;At(0)-&gt;GetName();</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :      ferr       = valTokens-&gt;At(1)-&gt;GetName();     </span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :      delete valTokens;</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :    }</span>
<span class="lineNum">     624 </span>            : 
<span class="lineNum">     625 </span>            :       
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :    formulaStr.ReplaceAll(&quot;++&quot;, &quot;~&quot;);</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :    TObjArray* formulaTokens = formulaStr.Tokenize(&quot;~&quot;); </span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :    Int_t dim = formulaTokens-&gt;GetEntriesFast();</span>
<span class="lineNum">     629 </span>            :    
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :    fitParam.ResizeTo(dim);</span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :    covMatrix.ResizeTo(dim,dim);</span>
<span class="lineNum">     632 </span>            :    
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :    TLinearFitter* fitter = new TLinearFitter(dim+1, Form(&quot;hyp%d&quot;,dim));</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :    fitter-&gt;StoreData(kTRUE);   </span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :    fitter-&gt;ClearPoints();</span>
<span class="lineNum">     636 </span>            :    
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :    Int_t entries = tree-&gt;Draw(drawStr.Data(), cutStr.Data(), &quot;goff&quot;,  stop-start, start);</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :    if (entries == -1) {</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :      delete formulaTokens;</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :      return new TString(&quot;An ERROR has occured during fitting!&quot;);</span>
<span class="lineNum">     641 </span>            :    }
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :    Double_t **values = new Double_t*[dim+1] ; </span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :    for (Int_t i=0; i&lt;dim+1; i++) values[i]=NULL; </span>
<span class="lineNum">     644 </span>            :    //
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :    entries = tree-&gt;Draw(ferr.Data(), cutStr.Data(), &quot;goff&quot;,  stop-start, start);</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :    if (entries == -1) {</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :      delete formulaTokens;</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :      delete [] values;</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :      return new TString(&quot;An ERROR has occured during fitting!&quot;);</span>
<span class="lineNum">     650 </span>            :    }
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :    Double_t *errors = new Double_t[entries];</span>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :    memcpy(errors,  tree-&gt;GetV1(), entries*sizeof(Double_t));</span>
<span class="lineNum">     653 </span>            :    
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :    for (Int_t i = 0; i &lt; dim + 1; i++){</span>
<span class="lineNum">     655 </span>            :       Int_t centries = 0;
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :       if (i &lt; dim) centries = tree-&gt;Draw(((TObjString*)formulaTokens-&gt;At(i))-&gt;GetName(), cutStr.Data(), &quot;goff&quot;, stop-start,start);</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :       else  centries = tree-&gt;Draw(drawStr.Data(), cutStr.Data(), &quot;goff&quot;, stop-start,start);</span>
<span class="lineNum">     658 </span>            :       
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :       if (entries != centries) {</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :         delete []errors;</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :         delete []values;</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :         delete formulaTokens;</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :         return new TString(&quot;An ERROR has occured during fitting!&quot;);</span>
<span class="lineNum">     664 </span>            :       }
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :       values[i] = new Double_t[entries];</span>
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :       memcpy(values[i],  tree-&gt;GetV1(), entries*sizeof(Double_t)); </span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :    }</span>
<span class="lineNum">     668 </span>            :    
<span class="lineNum">     669 </span>            :    // add points to the fitter
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :    for (Int_t i = 0; i &lt; entries; i++){</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :       Double_t x[1000];</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :       for (Int_t j=0; j&lt;dim;j++) x[j]=values[j][i];</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :       fitter-&gt;AddPoint(x, values[dim][i], errors[i]);</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :    }</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :    if (constrain&gt;0){</span>
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :      for (Int_t i = 0; i &lt; dim; i++){</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :        Double_t x[1000];</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :        for (Int_t j=0; j&lt;dim;j++) if (i!=j) x[j]=0;</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :        x[i]=1.;</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :        fitter-&gt;AddPoint(x, 0, constrain);</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :      }</span>
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :    }</span>
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span>            : 
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :    fitter-&gt;Eval();</span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :    if (frac&gt;0.5 &amp;&amp; frac&lt;1){</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :      fitter-&gt;EvalRobust(frac);   </span>
<span class="lineNum">     688 </span>            :    }
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :    fitter-&gt;GetParameters(fitParam);</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :    fitter-&gt;GetCovarianceMatrix(covMatrix);</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :    chi2 = fitter-&gt;GetChisquare();</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :    npoints = entries;</span>
<span class="lineNum">     693 </span>            :    
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :    TString *preturnFormula = new TString(Form(&quot;( %f+&quot;,fitParam[0])), &amp;returnFormula = *preturnFormula; </span>
<span class="lineNum">     695 </span>            :    
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :    for (Int_t iparam = 0; iparam &lt; dim; iparam++) {</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :      returnFormula.Append(Form(&quot;%s*(%f)&quot;,((TObjString*)formulaTokens-&gt;At(iparam))-&gt;GetName(),fitParam[iparam+1]));</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :      if (iparam &lt; dim-1) returnFormula.Append(&quot;+&quot;);</span>
<span class="lineNum">     699 </span>            :    }
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :    returnFormula.Append(&quot; )&quot;);</span>
<span class="lineNum">     701 </span>            :    
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :    for (Int_t j=0; j&lt;dim+1;j++) delete [] values[j];</span>
<span class="lineNum">     703 </span>            :    
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span>            : 
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :    delete formulaTokens;</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :    delete fitter;</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :    delete[] values;</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :    delete[] errors;</span>
<span class="lineNum">     710 </span>            :    return preturnFormula;
<span class="lineNum">     711 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     712 </span>            : 
<a name="713"><span class="lineNum">     713 </span>            : </a>
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span>            : TString* TStatToolkit::FitPlaneFixed(TTree *tree, const char* drawCommand, const char* formula, const char* cuts, Double_t &amp; chi2, Int_t &amp;npoints, TVectorD &amp;fitParam, TMatrixD &amp;covMatrix, Float_t frac, Int_t start, Int_t stop){
<span class="lineNum">     716 </span>            :    //
<span class="lineNum">     717 </span>            :    // fit an arbitrary function, specified by formula into the data, specified by drawCommand and cuts
<span class="lineNum">     718 </span>            :    // returns chi2, fitParam and covMatrix
<span class="lineNum">     719 </span>            :    // returns TString with fitted formula
<span class="lineNum">     720 </span>            :    //
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :    TString formulaStr(formula); </span>
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :    TString drawStr(drawCommand);</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :    TString cutStr(cuts);</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :    TString ferr(&quot;1&quot;);</span>
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :    TString strVal(drawCommand);</span>
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :    if (strVal.Contains(&quot;:&quot;)){</span>
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :      TObjArray* valTokens = strVal.Tokenize(&quot;:&quot;);</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :      drawStr = valTokens-&gt;At(0)-&gt;GetName();</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :      ferr       = valTokens-&gt;At(1)-&gt;GetName();</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :      delete valTokens;</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :    }</span>
<span class="lineNum">     734 </span>            : 
<span class="lineNum">     735 </span>            :       
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :    formulaStr.ReplaceAll(&quot;++&quot;, &quot;~&quot;);</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :    TObjArray* formulaTokens = formulaStr.Tokenize(&quot;~&quot;); </span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :    Int_t dim = formulaTokens-&gt;GetEntriesFast();</span>
<span class="lineNum">     739 </span>            :    
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :    fitParam.ResizeTo(dim);</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :    covMatrix.ResizeTo(dim,dim);</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :    TString fitString=&quot;x0&quot;;</span>
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :    for (Int_t i=1; i&lt;dim; i++) fitString+=Form(&quot;++x%d&quot;,i);     </span>
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :    TLinearFitter* fitter = new TLinearFitter(dim, fitString.Data());</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :    fitter-&gt;StoreData(kTRUE);   </span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :    fitter-&gt;ClearPoints();</span>
<span class="lineNum">     747 </span>            :    
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :    Int_t entries = tree-&gt;Draw(drawStr.Data(), cutStr.Data(), &quot;goff&quot;,  stop-start, start);</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :    if (entries == -1) {</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :      delete formulaTokens;</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :      return new TString(&quot;An ERROR has occured during fitting!&quot;);</span>
<span class="lineNum">     752 </span>            :    }
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :    Double_t **values = new Double_t*[dim+1] ; </span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :    for (Int_t i=0; i&lt;dim+1; i++) values[i]=NULL; </span>
<span class="lineNum">     755 </span>            :    //
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :    entries = tree-&gt;Draw(ferr.Data(), cutStr.Data(), &quot;goff&quot;,  stop-start, start);</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :    if (entries == -1) {</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :      delete []values;</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :      delete formulaTokens;</span>
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :      return new TString(&quot;An ERROR has occured during fitting!&quot;);</span>
<span class="lineNum">     761 </span>            :    }
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :    Double_t *errors = new Double_t[entries];</span>
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :    memcpy(errors,  tree-&gt;GetV1(), entries*sizeof(Double_t));</span>
<span class="lineNum">     764 </span>            :    
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :    for (Int_t i = 0; i &lt; dim + 1; i++){</span>
<span class="lineNum">     766 </span>            :       Int_t centries = 0;
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :       if (i &lt; dim) centries = tree-&gt;Draw(((TObjString*)formulaTokens-&gt;At(i))-&gt;GetName(), cutStr.Data(), &quot;goff&quot;, stop-start,start);</span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :       else  centries = tree-&gt;Draw(drawStr.Data(), cutStr.Data(), &quot;goff&quot;, stop-start,start);</span>
<span class="lineNum">     769 </span>            :       
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :       if (entries != centries) {</span>
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :         delete []errors;</span>
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :         delete []values;</span>
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :         delete formulaTokens;</span>
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :         return new TString(&quot;An ERROR has occured during fitting!&quot;);</span>
<span class="lineNum">     775 </span>            :       }
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :       values[i] = new Double_t[entries];</span>
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :       memcpy(values[i],  tree-&gt;GetV1(), entries*sizeof(Double_t)); </span>
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :    }</span>
<span class="lineNum">     779 </span>            :    
<span class="lineNum">     780 </span>            :    // add points to the fitter
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :    for (Int_t i = 0; i &lt; entries; i++){</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :       Double_t x[1000];</span>
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :       for (Int_t j=0; j&lt;dim;j++) x[j]=values[j][i];</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :       fitter-&gt;AddPoint(x, values[dim][i], errors[i]);</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :    }</span>
<span class="lineNum">     786 </span>            : 
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :    fitter-&gt;Eval();</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :    if (frac&gt;0.5 &amp;&amp; frac&lt;1){</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :      fitter-&gt;EvalRobust(frac);</span>
<span class="lineNum">     790 </span>            :    }
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :    fitter-&gt;GetParameters(fitParam);</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :    fitter-&gt;GetCovarianceMatrix(covMatrix);</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :    chi2 = fitter-&gt;GetChisquare();</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :    npoints = entries;</span>
<span class="lineNum">     795 </span>            :    
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :    TString *preturnFormula = new TString(&quot;(&quot;), &amp;returnFormula = *preturnFormula; </span>
<span class="lineNum">     797 </span>            :    
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :    for (Int_t iparam = 0; iparam &lt; dim; iparam++) {</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :      returnFormula.Append(Form(&quot;%s*(%f)&quot;,((TObjString*)formulaTokens-&gt;At(iparam))-&gt;GetName(),fitParam[iparam]));</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :      if (iparam &lt; dim-1) returnFormula.Append(&quot;+&quot;);</span>
<span class="lineNum">     801 </span>            :    }
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :    returnFormula.Append(&quot; )&quot;);</span>
<span class="lineNum">     803 </span>            :    
<span class="lineNum">     804 </span>            :    
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :    for (Int_t j=0; j&lt;dim+1;j++) delete [] values[j];</span>
<span class="lineNum">     806 </span>            :    
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :    delete formulaTokens;</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :    delete fitter;</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :    delete[] values;</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :    delete[] errors;</span>
<span class="lineNum">     811 </span>            :    return preturnFormula;
<span class="lineNum">     812 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span>            : 
<span class="lineNum">     815 </span>            : 
<a name="816"><span class="lineNum">     816 </span>            : </a>
<span class="lineNum">     817 </span>            : 
<span class="lineNum">     818 </span>            : Int_t TStatToolkit::GetFitIndex(const TString fString, const TString subString){
<span class="lineNum">     819 </span>            :   //
<span class="lineNum">     820 </span>            :   // fitString - ++ separated list of fits
<span class="lineNum">     821 </span>            :   // substring - ++ separated list of the requiered substrings
<span class="lineNum">     822 </span>            :   //
<span class="lineNum">     823 </span>            :   // return the last occurance of substring in fit string
<span class="lineNum">     824 </span>            :   // 
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :   TObjArray *arrFit = fString.Tokenize(&quot;++&quot;);</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :   TObjArray *arrSub = subString.Tokenize(&quot;++&quot;);</span>
<span class="lineNum">     827 </span>            :   Int_t index=-1;
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;arrFit-&gt;GetEntries(); i++){</span>
<span class="lineNum">     829 </span>            :     Bool_t isOK=kTRUE;
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :     TString str =arrFit-&gt;At(i)-&gt;GetName();</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :     for (Int_t isub=0; isub&lt;arrSub-&gt;GetEntries(); isub++){</span>
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :       if (str.Contains(arrSub-&gt;At(isub)-&gt;GetName())==0) isOK=kFALSE;</span>
<span class="lineNum">     833 </span>            :     }
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :     if (isOK) index=i;</span>
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :   delete arrFit;</span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :   delete arrSub;</span>
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :   return index;</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 : }</span>
<a name="840"><span class="lineNum">     840 </span>            : </a>
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span>            : TString  TStatToolkit::FilterFit(const TString &amp;input, const TString filter, TVectorD &amp;param, TMatrixD &amp; covar){
<span class="lineNum">     843 </span>            :   //
<span class="lineNum">     844 </span>            :   // Filter fit expression make sub-fit
<span class="lineNum">     845 </span>            :   //
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :   TObjArray *array0= input.Tokenize(&quot;++&quot;);</span>
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :   TObjArray *array1= filter.Tokenize(&quot;++&quot;);</span>
<span class="lineNum">     848 </span>            :   //TString *presult=new TString(&quot;(0&quot;);
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :   TString result=&quot;(0.0&quot;;</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;array0-&gt;GetEntries(); i++){</span>
<span class="lineNum">     851 </span>            :     Bool_t isOK=kTRUE;
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :     TString str(array0-&gt;At(i)-&gt;GetName());</span>
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :     for (Int_t j=0; j&lt;array1-&gt;GetEntries(); j++){</span>
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :       if (str.Contains(array1-&gt;At(j)-&gt;GetName())==0) isOK=kFALSE;      </span>
<span class="lineNum">     855 </span>            :     }
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :     if (isOK) {</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :       result+=&quot;+&quot;+str;</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :       result+=Form(&quot;*(%f)&quot;,param[i+1]);</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :       printf(&quot;%f\t%f\t%s\n&quot;,param[i+1], TMath::Sqrt(covar(i+1,i+1)),str.Data());    </span>
<span class="lineNum">     860 </span>            :     }
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :   result+=&quot;-0.)&quot;;</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :   delete array0;</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :   delete array1;</span>
<span class="lineNum">     865 </span>            :   return result;
<a name="866"><span class="lineNum">     866 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span>            : void TStatToolkit::Update1D(Double_t delta, Double_t sigma, Int_t s1, TMatrixD &amp;vecXk, TMatrixD &amp;covXk){
<span class="lineNum">     869 </span>            :   //
<span class="lineNum">     870 </span>            :   // Update parameters and covariance - with one measurement
<span class="lineNum">     871 </span>            :   // Input:
<span class="lineNum">     872 </span>            :   // vecXk - input vector - Updated in function 
<span class="lineNum">     873 </span>            :   // covXk - covariance matrix - Updated in function
<span class="lineNum">     874 </span>            :   // delta, sigma, s1 - new measurement, rms of new measurement and the index of measurement
<span class="lineNum">     875 </span>            :   const Int_t knMeas=1;
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :   Int_t knElem=vecXk.GetNrows();</span>
<span class="lineNum">     877 </span>            :  
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :   TMatrixD mat1(knElem,knElem);            // update covariance matrix</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :   TMatrixD matHk(1,knElem);        // vector to mesurement</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :   TMatrixD vecYk(knMeas,1);        // Innovation or measurement residual</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :   TMatrixD matHkT(knElem,knMeas);  // helper matrix Hk transpose</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :   TMatrixD matSk(knMeas,knMeas);   // Innovation (or residual) covariance</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :   TMatrixD matKk(knElem,knMeas);   // Optimal Kalman gain</span>
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :   TMatrixD covXk2(knElem,knElem);  // helper matrix</span>
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :   TMatrixD covXk3(knElem,knElem);  // helper matrix</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :   TMatrixD vecZk(1,1);</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :   TMatrixD measR(1,1);</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :   vecZk(0,0)=delta;</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :   measR(0,0)=sigma*sigma;</span>
<span class="lineNum">     890 </span>            :   //
<span class="lineNum">     891 </span>            :   // reset matHk
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :   for (Int_t iel=0;iel&lt;knElem;iel++) </span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :     for (Int_t ip=0;ip&lt;knMeas;ip++) matHk(ip,iel)=0; </span>
<span class="lineNum">     894 </span>            :   //mat1
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :   for (Int_t iel=0;iel&lt;knElem;iel++) {</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :     for (Int_t jel=0;jel&lt;knElem;jel++) mat1(iel,jel)=0;</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :     mat1(iel,iel)=1;</span>
<span class="lineNum">     898 </span>            :   }
<span class="lineNum">     899 </span>            :   //
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :   matHk(0, s1)=1;</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :   vecYk = vecZk-matHk*vecXk;               // Innovation or measurement residual</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :   matHkT=matHk.T(); matHk.T();</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :   matSk = (matHk*(covXk*matHkT))+measR;    // Innovation (or residual) covariance</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :   matSk.Invert();</span>
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :   matKk = (covXk*matHkT)*matSk;            //  Optimal Kalman gain</span>
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :   vecXk += matKk*vecYk;                    //  updated vector </span>
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :   covXk2= (mat1-(matKk*matHk));</span>
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :   covXk3 =  covXk2*covXk;          </span>
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :   covXk = covXk3;  </span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :   Int_t nrows=covXk3.GetNrows();</span>
<span class="lineNum">     911 </span>            :   
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :   for (Int_t irow=0; irow&lt;nrows; irow++)</span>
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :     for (Int_t icol=0; icol&lt;nrows; icol++){</span>
<span class="lineNum">     914 </span>            :       // rounding problems - make matrix again symteric
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :       covXk(irow,icol)=(covXk3(irow,icol)+covXk3(icol,irow))*0.5; </span>
<span class="lineNum">     916 </span>            :     }
<span class="lineNum">     917 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     918 </span>            : 
<a name="919"><span class="lineNum">     919 </span>            : </a>
<span class="lineNum">     920 </span>            : 
<span class="lineNum">     921 </span>            : void   TStatToolkit::Constrain1D(const TString &amp;input, const TString filter, TVectorD &amp;param, TMatrixD &amp; covar, Double_t mean, Double_t sigma){
<span class="lineNum">     922 </span>            :   //
<span class="lineNum">     923 </span>            :   // constrain linear fit
<span class="lineNum">     924 </span>            :   // input  - string description of fit function
<span class="lineNum">     925 </span>            :   // filter - string filter to select sub fits
<span class="lineNum">     926 </span>            :   // param,covar - parameters and covariance matrix of the fit
<span class="lineNum">     927 </span>            :   // mean,sigma  - new measurement uning which the fit is updated
<span class="lineNum">     928 </span>            :   //
<span class="lineNum">     929 </span>            :   
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :   TObjArray *array0= input.Tokenize(&quot;++&quot;);</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :   TObjArray *array1= filter.Tokenize(&quot;++&quot;);</span>
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :   TMatrixD paramM(param.GetNrows(),1);</span>
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;=array0-&gt;GetEntries(); i++){paramM(i,0)=param(i);}</span>
<span class="lineNum">     934 </span>            :   
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :   if (filter.Length()==0){</span>
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :     TStatToolkit::Update1D(mean, sigma, 0, paramM, covar);//</span>
<span class="lineNum">     937 </span>            :   }else{  
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :     for (Int_t i=0; i&lt;array0-&gt;GetEntries(); i++){</span>
<span class="lineNum">     939 </span>            :       Bool_t isOK=kTRUE;
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :       TString str(array0-&gt;At(i)-&gt;GetName());</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :       for (Int_t j=0; j&lt;array1-&gt;GetEntries(); j++){</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :         if (str.Contains(array1-&gt;At(j)-&gt;GetName())==0) isOK=kFALSE;      </span>
<span class="lineNum">     943 </span>            :       }
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :       if (isOK) {</span>
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :         TStatToolkit::Update1D(mean, sigma, i+1, paramM, covar);//</span>
<span class="lineNum">     946 </span>            :       }
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     948 </span>            :   }
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;=array0-&gt;GetEntries(); i++){</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :     param(i)=paramM(i,0);</span>
<span class="lineNum">     951 </span>            :   }
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :   delete array0;</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :   delete array1;</span>
<a name="954"><span class="lineNum">     954 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     955 </span>            : 
<span class="lineNum">     956 </span>            : TString  TStatToolkit::MakeFitString(const TString &amp;input, const TVectorD &amp;param, const TMatrixD &amp; covar, Bool_t verbose){
<span class="lineNum">     957 </span>            :   //
<span class="lineNum">     958 </span>            :   //
<span class="lineNum">     959 </span>            :   //
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :   TObjArray *array0= input.Tokenize(&quot;++&quot;);</span>
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :   TString result=Form(&quot;(%f&quot;,param[0]);</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :   printf(&quot;%f\t%f\t\n&quot;, param[0], TMath::Sqrt(covar(0,0))); </span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;array0-&gt;GetEntries(); i++){</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :     TString str(array0-&gt;At(i)-&gt;GetName());</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :     result+=&quot;+&quot;+str;</span>
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :     result+=Form(&quot;*(%f)&quot;,param[i+1]);</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :     if (verbose) printf(&quot;%f\t%f\t%s\n&quot;, param[i+1], TMath::Sqrt(covar(i+1,i+1)),str.Data());    </span>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :   result+=&quot;-0.)&quot;;</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :   delete array0;</span>
<span class="lineNum">     971 </span>            :   return result;
<a name="972"><span class="lineNum">     972 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     973 </span>            : 
<span class="lineNum">     974 </span>            : TGraphErrors * TStatToolkit::MakeGraphErrors(TTree * tree, const char * expr, const char * cut,  Int_t mstyle, Int_t mcolor, Float_t msize, Float_t offset, Int_t drawEntries, Int_t firstEntry){
<span class="lineNum">     975 </span>            :   //
<span class="lineNum">     976 </span>            :   // Query a graph errors
<span class="lineNum">     977 </span>            :   // return TGraphErrors specified by expr and cut 
<span class="lineNum">     978 </span>            :   // Example  usage TStatToolkit::MakeGraphError(tree,&quot;Y:X:ErrY&quot;,&quot;X&gt;0&quot;, 25,2,0.4)
<span class="lineNum">     979 </span>            :   // tree   - tree with variable
<span class="lineNum">     980 </span>            :   // expr   - examp 
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :   const Int_t entries =  tree-&gt;Draw(expr,cut,&quot;goff&quot;,drawEntries,firstEntry);</span>
<span class="lineNum">     982 </span>            :  
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :   if (entries&lt;=0) {</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :     ::Error(&quot;TStatToolkit::MakeGraphError&quot;,&quot;Empty or Not valid expression (%s) or cut *%s)&quot;, expr,cut);</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     986 </span>            :   }
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :   if (  tree-&gt;GetV2()==0){</span>
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :     ::Error(&quot;TStatToolkit::MakeGraphError&quot;,&quot;Not valid expression (%s) &quot;, expr);</span>
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     990 </span>            :   }
<span class="lineNum">     991 </span>            :   TGraphErrors * graph=0;
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :   if ( tree-&gt;GetV3()!=0){</span>
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :     graph = new TGraphErrors (entries, tree-&gt;GetV2(),tree-&gt;GetV1(),0,tree-&gt;GetV3());</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :   }else{</span>
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :     graph = new TGraphErrors (entries, tree-&gt;GetV2(),tree-&gt;GetV1(),0,0);</span>
<span class="lineNum">     996 </span>            :   }
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :   graph-&gt;SetMarkerStyle(mstyle); </span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :   graph-&gt;SetMarkerColor(mcolor);</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :   graph-&gt;SetLineColor(mcolor);</span>
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :   graph-&gt;SetTitle(expr);</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :   TString chstring(expr);</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :   TObjArray *charray = chstring.Tokenize(&quot;:&quot;);</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :   graph-&gt;GetXaxis()-&gt;SetTitle(charray-&gt;At(1)-&gt;GetName());</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :   graph-&gt;GetYaxis()-&gt;SetTitle(charray-&gt;At(0)-&gt;GetName());</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :   THashList * metaData = (THashList*) tree-&gt;GetUserInfo()-&gt;FindObject(&quot;metaTable&quot;);</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :   if (!metaData == 0){    </span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :     TNamed *nmdTitle0 = TStatToolkit::GetMetadata(tree,Form(&quot;%s.Title&quot;,charray-&gt;At(0)-&gt;GetName()));</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :     TNamed *nmdTitle1 = TStatToolkit::GetMetadata(tree,Form(&quot;%s.Title&quot;,charray-&gt;At(1)-&gt;GetName()));</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :     TNamed *nmdYAxis  = TStatToolkit::GetMetadata(tree,Form(&quot;%s.AxisTitle&quot;,charray-&gt;At(0)-&gt;GetName()));</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :     TNamed *nmdXAxis  = TStatToolkit::GetMetadata(tree,Form(&quot;%s.AxisTitle&quot;,charray-&gt;At(1)-&gt;GetName())); </span>
<span class="lineNum">    1012 </span>            :     //
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :     TString grTitle=charray-&gt;At(0)-&gt;GetName();</span>
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :     if (nmdTitle0)  grTitle=nmdTitle0-&gt;GetTitle();</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :     if (nmdTitle1)  {</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :       grTitle+=&quot;:&quot;;</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :       grTitle+=nmdTitle1-&gt;GetTitle();</span>
<span class="lineNum">    1018 </span>            :     }else{
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :       grTitle+=&quot;:&quot;;</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :       grTitle+=charray-&gt;At(1)-&gt;GetName();</span>
<span class="lineNum">    1021 </span>            :     }
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :     if (nmdYAxis) {graph-&gt;GetYaxis()-&gt;SetTitle(nmdYAxis-&gt;GetTitle());}</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :     if (nmdXAxis) {graph-&gt;GetXaxis()-&gt;SetTitle(nmdXAxis-&gt;GetTitle());}  </span>
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :     graph-&gt;SetTitle(grTitle.Data());</span>
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :   }  </span>
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :   delete charray;</span>
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :   if (msize&gt;0) graph-&gt;SetMarkerSize(msize);</span>
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :   for(Int_t i=0;i&lt;graph-&gt;GetN();i++) graph-&gt;GetX()[i]+=offset;</span>
<span class="lineNum">    1029 </span>            :   //
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :   if (tree-&gt;GetVar(1)-&gt;IsInteger()){</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :     TAxis * axis = tree-&gt;GetHistogram()-&gt;GetXaxis();</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :     axis-&gt;Copy(*(graph-&gt;GetXaxis()));</span>
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :   if (tree-&gt;GetVar(0)-&gt;IsInteger()){</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :     TAxis * axis = tree-&gt;GetHistogram()-&gt;GetYaxis();</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :     axis-&gt;Copy(*(graph-&gt;GetYaxis()));</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :   graph-&gt;Sort();</span>
<span class="lineNum">    1039 </span>            :   return graph;
<span class="lineNum">    1040 </span>            :   
<a name="1041"><span class="lineNum">    1041 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1042 </span>            : 
<span class="lineNum">    1043 </span>            : THashList*  TStatToolkit::AddMetadata(TTree* tree, const char *varTagName,const char *varTagValue){
<span class="lineNum">    1044 </span>            :   //
<span class="lineNum">    1045 </span>            :   // Add metadata infromation as user info to the tree - see https://alice.its.cern.ch/jira/browse/ATO-290
<span class="lineNum">    1046 </span>            :   // TTree metdata are used for the Drawing methods in the folling drawing functions
<span class="lineNum">    1047 </span>            :   /*
<span class="lineNum">    1048 </span>            :     Supported metadata:
<span class="lineNum">    1049 </span>            :     - &lt;varName&gt;.AxisTitle
<span class="lineNum">    1050 </span>            :     - &lt;varName&gt;.Legend
<span class="lineNum">    1051 </span>            :     - &lt;varname&gt;.Color
<span class="lineNum">    1052 </span>            :     - &lt;varname&gt;.MarkerStyle
<span class="lineNum">    1053 </span>            :     This metadata than can be used by the TStatToolkit
<span class="lineNum">    1054 </span>            :     - TStatToolkit::MakeGraphSparse
<span class="lineNum">    1055 </span>            :     - TStatToolkit::MakeGraphErrors
<span class="lineNum">    1056 </span>            :    */
<span class="lineNum">    1057 </span>            :   // 
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :   if (!tree) return NULL;</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :   THashList * metaData = (THashList*) tree-&gt;GetUserInfo()-&gt;FindObject(&quot;metaTable&quot;);</span>
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :   if (metaData == NULL){  </span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :     metaData=new THashList;</span>
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :     metaData-&gt;SetName(&quot;metaTable&quot;);</span>
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :     tree-&gt;GetUserInfo()-&gt;AddLast(metaData);</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :   } </span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :   if (varTagName!=NULL &amp;&amp; varTagValue!=NULL){</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :     TNamed * named = TStatToolkit::GetMetadata(tree, varTagName);</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :     if (named==NULL){</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :       metaData-&gt;AddLast(new TNamed(varTagName,varTagValue));</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :     }else{</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :       named-&gt;SetTitle(varTagValue);</span>
<span class="lineNum">    1071 </span>            :     }
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1073 </span>            :   return metaData;
<a name="1074"><span class="lineNum">    1074 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1075 </span>            : 
<span class="lineNum">    1076 </span>            : TNamed* TStatToolkit::GetMetadata(TTree* tree, const char *vartagName){
<span class="lineNum">    1077 </span>            :   //
<span class="lineNum">    1078 </span>            :   //  Get metadata description
<span class="lineNum">    1079 </span>            :   //
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :   if (!tree) return 0;</span>
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :   THashList * metaData = (THashList*) tree-&gt;GetUserInfo()-&gt;FindObject(&quot;metaTable&quot;);</span>
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :   if (metaData == NULL){  </span>
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :     metaData=new THashList;</span>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :     metaData-&gt;SetName(&quot;metaTable&quot;);</span>
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :     tree-&gt;GetUserInfo()-&gt;AddLast(metaData);</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1087 </span>            :   } 
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :   TNamed * named = (TNamed*)metaData-&gt;FindObject(vartagName);</span>
<span class="lineNum">    1089 </span>            :   return named;
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1091 </span>            : 
<a name="1092"><span class="lineNum">    1092 </span>            : </a>
<span class="lineNum">    1093 </span>            : 
<span class="lineNum">    1094 </span>            : TGraph * TStatToolkit::MakeGraphSparse(TTree * tree, const char * expr, const char * cut, Int_t mstyle, Int_t mcolor, Float_t msize, Float_t offset){
<span class="lineNum">    1095 </span>            :   //
<span class="lineNum">    1096 </span>            :   // Make a sparse draw of the variables
<span class="lineNum">    1097 </span>            :   // Format of expr : Var:Run or Var:Run:ErrorY or Var:Run:ErrorY:ErrorX
<span class="lineNum">    1098 </span>            :   // offset : points can slightly be shifted in x for better visibility with more graphs
<span class="lineNum">    1099 </span>            :   //
<span class="lineNum">    1100 </span>            :   // Patrick Reichelt and Marian Ivanov
<span class="lineNum">    1101 </span>            :   // maintained and updated by Marian Ivanov
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :   const Int_t entries = tree-&gt;Draw(expr,cut,&quot;goff&quot;);</span>
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :   if (entries&lt;=0) {</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :     ::Error(&quot;TStatToolkit::MakeGraphSparse&quot;,&quot;Empty or Not valid expression (%s) or cut (%s)&quot;, expr, cut);</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1106 </span>            :   }
<span class="lineNum">    1107 </span>            :   //  TGraph * graph = (TGraph*)gPad-&gt;GetPrimitive(&quot;Graph&quot;); // 2D
<span class="lineNum">    1108 </span>            : 
<span class="lineNum">    1109 </span>            :   Double_t *graphY, *graphX;
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :   graphY = tree-&gt;GetV1();</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :   graphX = tree-&gt;GetV2();</span>
<span class="lineNum">    1112 </span>            : 
<span class="lineNum">    1113 </span>            :   // sort according to run number
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :   Int_t *index = new Int_t[entries*4];</span>
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :   TMath::Sort(entries,graphX,index,kFALSE);</span>
<span class="lineNum">    1116 </span>            : 
<span class="lineNum">    1117 </span>            :   // define arrays for the new graph
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :   Double_t *unsortedX = new Double_t[entries];</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :   Int_t *runNumber = new Int_t[entries];</span>
<span class="lineNum">    1120 </span>            :   Double_t count = 0.5;
<span class="lineNum">    1121 </span>            : 
<span class="lineNum">    1122 </span>            :   // evaluate arrays for the new graph according to the run-number
<span class="lineNum">    1123 </span>            :   Int_t icount=0;
<span class="lineNum">    1124 </span>            :   //first entry
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :   unsortedX[index[0]] = count;</span>
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :   runNumber[0] = graphX[index[0]];</span>
<span class="lineNum">    1127 </span>            :   // loop the rest of entries
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :   for(Int_t i=1;i&lt;entries;i++)</span>
<span class="lineNum">    1129 </span>            :   {
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :     if(graphX[index[i]]==graphX[index[i-1]])</span>
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :       unsortedX[index[i]] = count;</span>
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :     else if(graphX[index[i]]!=graphX[index[i-1]]){</span>
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :       count++;</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :       icount++;</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :       unsortedX[index[i]] = count;</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :       runNumber[icount]=graphX[index[i]];</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1138 </span>            :   }
<span class="lineNum">    1139 </span>            : 
<span class="lineNum">    1140 </span>            :   // count the number of xbins (run-wise) for the new graph
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :   const Int_t newNbins = int(count+0.5);</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :   Double_t *newBins = new Double_t[newNbins+1];</span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :   for(Int_t i=0; i&lt;=count+1;i++){</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :     newBins[i] = i;</span>
<span class="lineNum">    1145 </span>            :   }
<span class="lineNum">    1146 </span>            : 
<span class="lineNum">    1147 </span>            :   // define and fill the new graph
<span class="lineNum">    1148 </span>            :   TGraph *graphNew = 0;
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :   if (tree-&gt;GetV3()) {</span>
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :     if (tree-&gt;GetV4()) {</span>
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :       graphNew = new TGraphErrors(entries,unsortedX,graphY,tree-&gt;GetV4(),tree-&gt;GetV3());</span>
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :     else { graphNew = new TGraphErrors(entries,unsortedX,graphY,0,tree-&gt;GetV3()); }</span>
<span class="lineNum">    1154 </span>            :   }
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :   else { graphNew = new TGraphErrors(entries,unsortedX,graphY,0,0); }</span>
<span class="lineNum">    1156 </span>            :   // with &quot;Set(...)&quot;, the x-axis is being sorted
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :   graphNew-&gt;GetXaxis()-&gt;Set(newNbins,newBins);</span>
<span class="lineNum">    1158 </span>            : 
<span class="lineNum">    1159 </span>            :   // set the bins for the x-axis, apply shifting of points
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :   Char_t xName[50];</span>
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :   for(Int_t i=0;i&lt;count;i++){</span>
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :     snprintf(xName,50,&quot;%d&quot;,runNumber[i]);</span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :     graphNew-&gt;GetXaxis()-&gt;SetBinLabel(i+1,xName);</span>
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :     graphNew-&gt;GetX()[i]+=offset;</span>
<span class="lineNum">    1165 </span>            :   }
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :   if (tree-&gt;GetVar(1)-&gt;IsInteger() &amp;&amp; strlen(tree-&gt;GetHistogram()-&gt;GetXaxis()-&gt;GetBinLabel(1))&gt;0){    </span>
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :     for(Int_t i=0;i&lt;count;i++){</span>
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :       graphNew-&gt;GetXaxis()-&gt;SetBinLabel(i+1,tree-&gt;GetHistogram()-&gt;GetXaxis()-&gt;GetBinLabel(i+1));</span>
<span class="lineNum">    1169 </span>            :     }
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :   if (tree-&gt;GetVar(0)-&gt;IsInteger() &amp;&amp;  strlen(tree-&gt;GetHistogram()-&gt;GetXaxis()-&gt;GetBinLabel(1))&gt;0 ){</span>
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :     for(Int_t i=0;i&lt;count;i++){</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :       graphNew-&gt;GetYaxis()-&gt;SetBinLabel(i+1,tree-&gt;GetHistogram()-&gt;GetYaxis()-&gt;GetBinLabel(i+1));</span>
<span class="lineNum">    1174 </span>            :     }
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1176 </span>            : 
<span class="lineNum">    1177 </span>            : 
<span class="lineNum">    1178 </span>            : 
<span class="lineNum">    1179 </span>            : 
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :   graphNew-&gt;GetHistogram()-&gt;SetTitle(&quot;&quot;);</span>
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :   graphNew-&gt;SetMarkerStyle(mstyle);</span>
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :   graphNew-&gt;SetMarkerColor(mcolor);  graphNew-&gt;SetLineColor(mcolor);</span>
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :   if (msize&gt;0) { graphNew-&gt;SetMarkerSize(msize); graphNew-&gt;SetLineWidth(msize); }</span>
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :   delete [] unsortedX;</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :   delete [] runNumber;</span>
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :   delete [] index;</span>
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :   delete [] newBins;</span>
<span class="lineNum">    1188 </span>            :   // 
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :   TString chstring(expr);</span>
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :   if (cut) chstring+=TString::Format(&quot; ( %s )&quot;, cut);</span>
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :   graphNew-&gt;SetTitle(chstring);</span>
<span class="lineNum">    1192 </span>            : 
<span class="lineNum">    1193 </span><span class="lineNoCov">          0 :   THashList * metaData = (THashList*) tree-&gt;GetUserInfo()-&gt;FindObject(&quot;metaTable&quot;);</span>
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :   if (!metaData == 0){    </span>
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :     chstring=expr;</span>
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :     TObjArray *charray = chstring.Tokenize(&quot;:&quot;);</span>
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :     graphNew-&gt;GetXaxis()-&gt;SetTitle(charray-&gt;At(1)-&gt;GetName());</span>
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :     graphNew-&gt;GetYaxis()-&gt;SetTitle(charray-&gt;At(0)-&gt;GetName());    </span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :     TNamed *nmdTitle0 = TStatToolkit::GetMetadata(tree,Form(&quot;%s.Title&quot;,charray-&gt;At(0)-&gt;GetName()));</span>
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :     TNamed *nmdTitle1 = TStatToolkit::GetMetadata(tree,Form(&quot;%s.Title&quot;,charray-&gt;At(1)-&gt;GetName()));</span>
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :     TNamed *nmdYAxis  = TStatToolkit::GetMetadata(tree,Form(&quot;%s.AxisTitle&quot;,charray-&gt;At(0)-&gt;GetName()));</span>
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :     TNamed *nmdXAxis  = TStatToolkit::GetMetadata(tree,Form(&quot;%s.AxisTitle&quot;,charray-&gt;At(1)-&gt;GetName())); </span>
<span class="lineNum">    1203 </span>            :     //
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :     TString grTitle=charray-&gt;At(0)-&gt;GetName();</span>
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 :     if (nmdTitle0)  grTitle=nmdTitle0-&gt;GetTitle();</span>
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :     if (nmdTitle1)  {</span>
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :       grTitle+=&quot;:&quot;;</span>
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :       grTitle+=nmdTitle1-&gt;GetTitle();</span>
<span class="lineNum">    1209 </span>            :     }else{
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :       grTitle+=&quot;:&quot;;</span>
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :       grTitle+=charray-&gt;At(1)-&gt;GetName();</span>
<span class="lineNum">    1212 </span>            :     }
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :     if (cut)  grTitle+=TString::Format(&quot; ( %s )&quot;, cut);</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :     graphNew-&gt;SetTitle(grTitle);</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :     if (nmdYAxis) {graphNew-&gt;GetYaxis()-&gt;SetTitle(nmdYAxis-&gt;GetTitle());}</span>
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :     if (nmdXAxis) {graphNew-&gt;GetXaxis()-&gt;SetTitle(nmdXAxis-&gt;GetTitle());}            </span>
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :     delete charray;</span>
<span class="lineNum">    1218 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1219 </span>            :   return graphNew;
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1221 </span>            : 
<span class="lineNum">    1222 </span>            : 
<span class="lineNum">    1223 </span>            : 
<span class="lineNum">    1224 </span>            : //
<span class="lineNum">    1225 </span>            : // functions used for the trending
<span class="lineNum">    1226 </span>            : //
<a name="1227"><span class="lineNum">    1227 </span>            : </a>
<span class="lineNum">    1228 </span>            : 
<span class="lineNum">    1229 </span>            : Int_t  TStatToolkit::MakeStatAlias(TTree * tree, const char * expr, const char * cut, const char * alias) 
<span class="lineNum">    1230 </span>            : {
<span class="lineNum">    1231 </span>            :   //
<span class="lineNum">    1232 </span>            :   // Add alias using statistical values of a given variable.
<span class="lineNum">    1233 </span>            :   // (by MI, Patrick Reichelt)
<span class="lineNum">    1234 </span>            :   //
<span class="lineNum">    1235 </span>            :   // tree - input tree
<span class="lineNum">    1236 </span>            :   // expr - variable expression
<span class="lineNum">    1237 </span>            :   // cut  - selection criteria
<span class="lineNum">    1238 </span>            :   // Output - return number of entries used to define variable
<span class="lineNum">    1239 </span>            :   // In addition mean, rms, median, and robust mean and rms (choosing fraction of data with smallest RMS)
<span class="lineNum">    1240 </span>            :   // 
<span class="lineNum">    1241 </span>            :   /* Example usage:
<span class="lineNum">    1242 </span>            :      1.) create the robust estimators for variable expr=&quot;QA.TPC.CPass1.meanTPCncl&quot; and create a corresponding
<span class="lineNum">    1243 </span>            :      aliases with the prefix alias[0]=&quot;ncl&quot;, calculated using fraction alias[1]=&quot;0.90&quot;
<span class="lineNum">    1244 </span>            : 
<span class="lineNum">    1245 </span>            :      TStatToolkit::MakeStatAlias(tree,&quot;QA.TPC.CPass1.meanTPCncl&quot;,&quot;QA.TPC.CPass1.status&gt;0&quot;,&quot;ncl:0.9&quot;);
<span class="lineNum">    1246 </span>            :      root [4] tree-&gt;GetListOfAliases().Print()
<span class="lineNum">    1247 </span>            :      OBJ: TNamed    ncl_Median      (130.964333+0)
<span class="lineNum">    1248 </span>            :      OBJ: TNamed    ncl_Mean        (122.120387+0)
<span class="lineNum">    1249 </span>            :      OBJ: TNamed    ncl_RMS         (33.509623+0)
<span class="lineNum">    1250 </span>            :      OBJ: TNamed    ncl_Mean90      (131.503862+0)
<span class="lineNum">    1251 </span>            :      OBJ: TNamed    ncl_RMS90       (3.738260+0)    
<span class="lineNum">    1252 </span>            :   */
<span class="lineNum">    1253 </span>            :   // 
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :   Int_t entries = tree-&gt;Draw(expr,cut,&quot;goff&quot;);</span>
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :   if (entries&lt;=1){</span>
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :     printf(&quot;Expression or cut not valid:\t%s\t%s\n&quot;, expr, cut);</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1258 </span>            :   }
<span class="lineNum">    1259 </span>            :   //
<span class="lineNum">    1260 </span><span class="lineNoCov">          0 :   TObjArray* oaAlias = TString(alias).Tokenize(&quot;:&quot;);</span>
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :   if (oaAlias-&gt;GetEntries()&lt;2) {</span>
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :     printf(&quot;Alias must have 2 arguments:\t%s\n&quot;, alias);</span>
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1264 </span>            :   }
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :   Float_t entryFraction = atof( oaAlias-&gt;At(1)-&gt;GetName() );</span>
<span class="lineNum">    1266 </span>            :   //
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :   Double_t median = TMath::Median(entries,tree-&gt;GetV1());</span>
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :   Double_t mean   = TMath::Mean(entries,tree-&gt;GetV1());</span>
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :   Double_t rms    = TMath::RMS(entries,tree-&gt;GetV1());</span>
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :   Double_t meanEF=0, rmsEF=0;</span>
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :   TStatToolkit::EvaluateUni(entries, tree-&gt;GetV1(), meanEF, rmsEF, entries*entryFraction);</span>
<span class="lineNum">    1272 </span>            :   //
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :   tree-&gt;SetAlias(Form(&quot;%s_Median&quot;,oaAlias-&gt;At(0)-&gt;GetName()), Form(&quot;(%f+0)&quot;,median));</span>
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 :   tree-&gt;SetAlias(Form(&quot;%s_Mean&quot;,oaAlias-&gt;At(0)-&gt;GetName()), Form(&quot;(%f+0)&quot;,mean));</span>
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :   tree-&gt;SetAlias(Form(&quot;%s_RMS&quot;,oaAlias-&gt;At(0)-&gt;GetName()), Form(&quot;(%f+0)&quot;,rms));</span>
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :   tree-&gt;SetAlias(Form(&quot;%s_Mean%d&quot;,oaAlias-&gt;At(0)-&gt;GetName(),Int_t(entryFraction*100)), Form(&quot;(%f+0)&quot;,meanEF));</span>
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :   tree-&gt;SetAlias(Form(&quot;%s_RMS%d&quot;,oaAlias-&gt;At(0)-&gt;GetName(),Int_t(entryFraction*100)), Form(&quot;(%f+0)&quot;,rmsEF));</span>
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :   delete oaAlias; </span>
<span class="lineNum">    1279 </span>            :   return entries;
<a name="1280"><span class="lineNum">    1280 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1281 </span>            : 
<span class="lineNum">    1282 </span>            : Int_t  TStatToolkit::SetStatusAlias(TTree * tree, const char * expr, const char * cut, const char * alias) 
<span class="lineNum">    1283 </span>            : {
<span class="lineNum">    1284 </span>            :   //
<span class="lineNum">    1285 </span>            :   // Add alias to trending tree using statistical values of a given variable.
<span class="lineNum">    1286 </span>            :   // (by MI, Patrick Reichelt)
<span class="lineNum">    1287 </span>            :   //
<span class="lineNum">    1288 </span>            :   // format of expr :  varname (e.g. meanTPCncl)
<span class="lineNum">    1289 </span>            :   // format of cut  :  char like in TCut
<span class="lineNum">    1290 </span>            :   // format of alias:  alias:query:entryFraction(EF) (fraction of entries used for uniformity evaluation)
<span class="lineNum">    1291 </span>            :   //            e.g.:  varname_Out:(abs(varname-meanEF)&gt;6.*rmsEF):0.8
<span class="lineNum">    1292 </span>            :   // available internal variables are: 'varname, Median, Mean, MeanEF, RMS, RMSEF'
<span class="lineNum">    1293 </span>            :   // in the alias, 'varname' will be replaced by its content, and 'EF' by the percentage (e.g. MeanEF -&gt; Mean80)
<span class="lineNum">    1294 </span>            :   //
<span class="lineNum">    1295 </span>            :   /* Example usage:
<span class="lineNum">    1296 </span>            :      1.) Define robust mean (possible, but easier done with TStatToolkit::MakeStatAlias(...)) 
<span class="lineNum">    1297 </span>            :      TStatToolkit::SetStatusAlias(tree, &quot;meanTPCnclF&quot;, &quot;meanTPCnclF&gt;0&quot;, &quot;meanTPCnclF_MeanEF:MeanEF:0.80&quot;) ;
<span class="lineNum">    1298 </span>            :      root [10] tree-&gt;GetListOfAliases()-&gt;Print()
<span class="lineNum">    1299 </span>            :                Collection name='TList', class='TList', size=1
<span class="lineNum">    1300 </span>            :                OBJ: TNamed    meanTPCnclF_Mean80      0.899308
<span class="lineNum">    1301 </span>            :      2.) create alias outlyers  - 6 sigma cut
<span class="lineNum">    1302 </span>            :      TStatToolkit::SetStatusAlias(tree, &quot;meanTPCnclF&quot;, &quot;meanTPCnclF&gt;0&quot;, &quot;meanTPCnclF_Out:(abs(meanTPCnclF-MeanEF)&gt;6.*RMSEF):0.8&quot;)
<span class="lineNum">    1303 </span>            :      meanTPCnclF_Out ==&gt; (abs(meanTPCnclF-0.899308)&gt;6.*0.016590)
<span class="lineNum">    1304 </span>            :      3.) the same functionality as in 2.)
<span class="lineNum">    1305 </span>            :      TStatToolkit::SetStatusAlias(tree, &quot;meanTPCnclF&quot;, &quot;meanTPCnclF&gt;0&quot;, &quot;varname_Out2:(abs(varname-MeanEF)&gt;6.*RMSEF):0.8&quot;) 
<span class="lineNum">    1306 </span>            :      meanTPCnclF_Out2 ==&gt; (abs(meanTPCnclF-0.899308)&gt;6.*0.016590)
<span class="lineNum">    1307 </span>            :   */
<span class="lineNum">    1308 </span>            :   //
<span class="lineNum">    1309 </span><span class="lineNoCov">          0 :   Int_t entries = tree-&gt;Draw(expr,cut,&quot;goff&quot;);</span>
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :   if (entries&lt;1){</span>
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 :     printf(&quot;Expression or cut not valid:\t%s\t%s\n&quot;, expr, cut);</span>
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1313 </span>            :   }
<span class="lineNum">    1314 </span>            :   //
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :   TObjArray* oaVar = TString(expr).Tokenize(&quot;:&quot;);</span>
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :   char varname[50];</span>
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :   snprintf(varname,50,&quot;%s&quot;, oaVar-&gt;At(0)-&gt;GetName());</span>
<span class="lineNum">    1318 </span>            :   Float_t entryFraction = 0.8;
<span class="lineNum">    1319 </span>            :   //
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :   TObjArray* oaAlias = TString(alias).Tokenize(&quot;:&quot;);</span>
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :   if (oaAlias-&gt;GetEntries()&lt;2) {</span>
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :     printf(&quot;Alias must have at least 2 arguments:\t%s\n&quot;, alias);</span>
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1324 </span>            :   }
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :   else if (oaAlias-&gt;GetEntries()&lt;3) {</span>
<span class="lineNum">    1326 </span>            :     //printf(&quot;Using default entryFraction if needed:\t%f\n&quot;, entryFraction);
<span class="lineNum">    1327 </span>            :   }
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :   else entryFraction = atof( oaAlias-&gt;At(2)-&gt;GetName() );</span>
<span class="lineNum">    1329 </span>            :   //
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :   Double_t median = TMath::Median(entries,tree-&gt;GetV1());</span>
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :   Double_t mean   = TMath::Mean(entries,tree-&gt;GetV1());</span>
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :   Double_t rms    = TMath::RMS(entries,tree-&gt;GetV1());</span>
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 :   Double_t meanEF=0, rmsEF=0;</span>
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 :   TStatToolkit::EvaluateUni(entries, tree-&gt;GetV1(), meanEF, rmsEF, entries*entryFraction);</span>
<span class="lineNum">    1335 </span>            :   //
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :   TString sAlias( oaAlias-&gt;At(0)-&gt;GetName() );</span>
<span class="lineNum">    1337 </span><span class="lineNoCov">          0 :   sAlias.ReplaceAll(&quot;varname&quot;,varname);</span>
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :   sAlias.ReplaceAll(&quot;MeanEF&quot;, Form(&quot;Mean%1.0f&quot;,entryFraction*100) );</span>
<span class="lineNum">    1339 </span><span class="lineNoCov">          0 :   sAlias.ReplaceAll(&quot;RMSEF&quot;,  Form(&quot;RMS%1.0f&quot;,entryFraction*100) );</span>
<span class="lineNum">    1340 </span><span class="lineNoCov">          0 :   TString sQuery( oaAlias-&gt;At(1)-&gt;GetName() );</span>
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :   sQuery.ReplaceAll(&quot;varname&quot;,varname);</span>
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :   sQuery.ReplaceAll(&quot;MeanEF&quot;, Form(&quot;%f&quot;,meanEF) );</span>
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :   sQuery.ReplaceAll(&quot;RMSEF&quot;,  Form(&quot;%f&quot;,rmsEF) ); //make sure to replace 'RMSEF' before 'RMS'...</span>
<span class="lineNum">    1344 </span><span class="lineNoCov">          0 :   sQuery.ReplaceAll(&quot;Median&quot;, Form(&quot;%f&quot;,median) );</span>
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :   sQuery.ReplaceAll(&quot;Mean&quot;,   Form(&quot;%f&quot;,mean) );</span>
<span class="lineNum">    1346 </span><span class="lineNoCov">          0 :   sQuery.ReplaceAll(&quot;RMS&quot;,    Form(&quot;%f&quot;,rms) );</span>
<span class="lineNum">    1347 </span><span class="lineNoCov">          0 :   printf(&quot;define alias:\t%s = %s\n&quot;, sAlias.Data(), sQuery.Data());</span>
<span class="lineNum">    1348 </span>            :   //
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :   char query[200];</span>
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :   char aname[200];</span>
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :   snprintf(query,200,&quot;%s&quot;, sQuery.Data());</span>
<span class="lineNum">    1352 </span><span class="lineNoCov">          0 :   snprintf(aname,200,&quot;%s&quot;, sAlias.Data());</span>
<span class="lineNum">    1353 </span><span class="lineNoCov">          0 :   tree-&gt;SetAlias(aname, query);</span>
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 :   delete oaVar;</span>
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :   delete oaAlias;</span>
<span class="lineNum">    1356 </span>            :   return entries;
<a name="1357"><span class="lineNum">    1357 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1358 </span>            : 
<span class="lineNum">    1359 </span>            : TMultiGraph*  TStatToolkit::MakeStatusMultGr(TTree * tree, const char * expr, const char * cut, const char * alias, Int_t igr) 
<span class="lineNum">    1360 </span>            : {
<span class="lineNum">    1361 </span>            :   //
<span class="lineNum">    1362 </span>            :   // Compute a trending multigraph that shows for which runs a variable has outliers.
<span class="lineNum">    1363 </span>            :   // (by MI, Patrick Reichelt)
<span class="lineNum">    1364 </span>            :   //
<span class="lineNum">    1365 </span>            :   // format of expr :  varname:xaxis (e.g. meanTPCncl:run, but 'varname' can be any string that you need for seach-and-replace)
<span class="lineNum">    1366 </span>            :   // format of cut  :  char like in TCut
<span class="lineNum">    1367 </span>            :   // format of alias:  (1):(statisticOK):(varname_Warning):(varname_Out)[:(varname_PhysAcc):(varname_Extra)]
<span class="lineNum">    1368 </span>            :   //
<span class="lineNum">    1369 </span>            :   // function MakeGraphSparse() is called for each alias argument, which will be used as tree expression.
<span class="lineNum">    1370 </span>            :   // each alias argument is supposed to be a Boolean statement which can be evaluated as tree expression.
<span class="lineNum">    1371 </span>            :   // the order of these criteria should be kept, as the marker styles and colors are chosen to be meaningful this way!
<span class="lineNum">    1372 </span>            :   // 'statisticOK' could e.g. be an alias for '(meanTPCncl&gt;0)'.
<span class="lineNum">    1373 </span>            :   // if you dont need e.g. a 'warning' condition, then just replace it by (0).
<span class="lineNum">    1374 </span>            :   // in the alias, 'varname' will be replaced by its content (e.g. varname_Out -&gt; meanTPCncl_Out)
<span class="lineNum">    1375 </span>            :   // note: the aliases 'varname_Out' etc have to be defined by function TStatToolkit::SetStatusAlias(...)
<span class="lineNum">    1376 </span>            :   // counter igr is used to shift the multigraph in y when filling a TObjArray.
<span class="lineNum">    1377 </span>            :   //
<span class="lineNum">    1378 </span>            :   //
<span class="lineNum">    1379 </span>            :   // To create the Status Bar, the following is done in principle.
<span class="lineNum">    1380 </span>            :   //    ( example current usage in $ALICE_ROOT/PWGPP/TPC/macros/drawPerformanceTPCQAMatchTrends.C and ./qaConfig.C. )
<span class="lineNum">    1381 </span>            :   //
<span class="lineNum">    1382 </span>            :   //  TStatToolkit::SetStatusAlias(tree, &quot;meanTPCncl&quot;,    &quot;&quot;, &quot;varname_Out:(abs(varname-MeanEF)&gt;6.*RMSEF):0.8&quot;);
<span class="lineNum">    1383 </span>            :   //  TStatToolkit::SetStatusAlias(tree, &quot;tpcItsMatchA&quot;,  &quot;&quot;, &quot;varname_Out:(abs(varname-MeanEF)&gt;6.*RMSEF):0.8&quot;);
<span class="lineNum">    1384 </span>            :   //  TStatToolkit::SetStatusAlias(tree, &quot;meanTPCncl&quot;,    &quot;&quot;, &quot;varname_Warning:(abs(varname-MeanEF)&gt;3.*RMSEF):0.8&quot;);
<span class="lineNum">    1385 </span>            :   //  TStatToolkit::SetStatusAlias(tree, &quot;tpcItsMatchA&quot;,  &quot;&quot;, &quot;varname_Warning:(abs(varname-MeanEF)&gt;3.*RMSEF):0.8&quot;);
<span class="lineNum">    1386 </span>            :   //  TObjArray* oaMultGr = new TObjArray(); int igr=0;
<span class="lineNum">    1387 </span>            :   //  oaMultGr-&gt;Add( TStatToolkit::MakeStatusMultGr(tree, &quot;tpcItsMatchA:run&quot;,  &quot;&quot;, &quot;(1):(meanTPCncl&gt;0):(varname_Warning):(varname_Outlier):&quot;, igr) ); igr++;
<span class="lineNum">    1388 </span>            :   //  oaMultGr-&gt;Add( TStatToolkit::MakeStatusMultGr(tree, &quot;meanTPCncl:run&quot;,    &quot;&quot;, &quot;(1):(meanTPCncl&gt;0):(varname_Warning):(varname_Outlier):&quot;, igr) ); igr++;
<span class="lineNum">    1389 </span>            :   //  TCanvas *c1 = new TCanvas(&quot;c1&quot;,&quot;c1&quot;);
<span class="lineNum">    1390 </span>            :   //  TStatToolkit::AddStatusPad(c1, 0.30, 0.40);
<span class="lineNum">    1391 </span>            :   //  TStatToolkit::DrawStatusGraphs(oaMultGr);
<span class="lineNum">    1392 </span>            :   
<span class="lineNum">    1393 </span>            :   
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 :   TObjArray* oaVar = TString(expr).Tokenize(&quot;:&quot;);</span>
<span class="lineNum">    1395 </span><span class="lineNoCov">          0 :   if (oaVar-&gt;GetEntries()&lt;2) {</span>
<span class="lineNum">    1396 </span><span class="lineNoCov">          0 :     printf(&quot;Expression has to be of type 'varname:xaxis':\t%s\n&quot;, expr);</span>
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1398 </span>            :   }
<span class="lineNum">    1399 </span><span class="lineNoCov">          0 :   char varname[50];</span>
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :   char var_x[50];</span>
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :   snprintf(varname,50,&quot;%s&quot;, oaVar-&gt;At(0)-&gt;GetName());</span>
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 :   snprintf(var_x  ,50,&quot;%s&quot;, oaVar-&gt;At(1)-&gt;GetName());</span>
<span class="lineNum">    1403 </span>            :   //
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 :   TString sAlias(alias);</span>
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 :   sAlias.ReplaceAll(&quot;varname&quot;,varname);</span>
<span class="lineNum">    1406 </span><span class="lineNoCov">          0 :   TObjArray* oaAlias = TString(sAlias.Data()).Tokenize(&quot;:&quot;);</span>
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :   if (oaAlias-&gt;GetEntries()&lt;2) {</span>
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :     printf(&quot;Alias must have 2-6 arguments:\t%s\n&quot;, alias);</span>
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1410 </span>            :   }
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :   char query[200];</span>
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :   TMultiGraph* multGr = new TMultiGraph();</span>
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :   Int_t marArr[6]      = {24+igr%2, 20+igr%2, 20+igr%2, 20+igr%2, 20+igr%2, 20+igr%2};</span>
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :   Int_t colArr[6]      = {kBlack, kBlack, kOrange, kRed, kGreen+1, kBlue};</span>
<span class="lineNum">    1415 </span><span class="lineNoCov">          0 :   Double_t sizeArr[6]  = {1.4, 1.1, 1.5, 1.1, 1.4, 0.8};</span>
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :   Double_t shiftArr[6] = {0., 0., 0.25, 0.25, -0.25, -0.25};</span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :   const Int_t ngr = oaAlias-&gt;GetEntriesFast();</span>
<span class="lineNum">    1418 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;ngr; i++){</span>
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :     snprintf(query,200, &quot;%f*(%s-0.5):%s&quot;, 1.+igr, oaAlias-&gt;At(i)-&gt;GetName(), var_x);</span>
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :     TGraphErrors * gr = (TGraphErrors*) TStatToolkit::MakeGraphSparse(tree,query,cut,marArr[i],colArr[i],sizeArr[i],shiftArr[i]);</span>
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 :     if (gr) multGr-&gt;Add(gr);</span>
<span class="lineNum">    1422 </span>            :   }
<span class="lineNum">    1423 </span>            :   //
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :   multGr-&gt;SetName(varname);</span>
<span class="lineNum">    1425 </span><span class="lineNoCov">          0 :   multGr-&gt;SetTitle(varname); // used for y-axis labels of status bar, can be modified by calling function.</span>
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 :   delete oaVar;</span>
<span class="lineNum">    1427 </span><span class="lineNoCov">          0 :   delete oaAlias;</span>
<span class="lineNum">    1428 </span>            :   return multGr;
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 : }</span>
<a name="1430"><span class="lineNum">    1430 </span>            : </a>
<span class="lineNum">    1431 </span>            : 
<span class="lineNum">    1432 </span>            : void  TStatToolkit::AddStatusPad(TCanvas* c1, Float_t padratio, Float_t bottommargin)
<span class="lineNum">    1433 </span>            : {
<span class="lineNum">    1434 </span>            :   //
<span class="lineNum">    1435 </span>            :   // add pad to bottom of canvas for Status graphs (by Patrick Reichelt)
<span class="lineNum">    1436 </span>            :   // call function &quot;DrawStatusGraphs(...)&quot; afterwards
<span class="lineNum">    1437 </span>            :   //
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :   TCanvas* c1_clone = (TCanvas*) c1-&gt;Clone(&quot;c1_clone&quot;);</span>
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :   c1-&gt;Clear();</span>
<span class="lineNum">    1440 </span>            :   // produce new pads
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :   c1-&gt;cd();</span>
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :   TPad* pad1 = new TPad(&quot;pad1&quot;, &quot;pad1&quot;, 0., padratio, 1., 1.); </span>
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :   pad1-&gt;Draw();</span>
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :   pad1-&gt;SetNumber(1); // so it can be called via &quot;c1-&gt;cd(1);&quot;</span>
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :   c1-&gt;cd();</span>
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :   TPad* pad2 = new TPad(&quot;pad2&quot;, &quot;pad2&quot;, 0., 0., 1., padratio);</span>
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 :   pad2-&gt;Draw();</span>
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :   pad2-&gt;SetNumber(2);</span>
<span class="lineNum">    1449 </span>            :   // draw original canvas into first pad
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :   c1-&gt;cd(1);</span>
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :   c1_clone-&gt;DrawClonePad();</span>
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :   pad1-&gt;SetBottomMargin(0.001);</span>
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :   pad1-&gt;SetRightMargin(0.01);</span>
<span class="lineNum">    1454 </span>            :   // set up second pad
<span class="lineNum">    1455 </span><span class="lineNoCov">          0 :   c1-&gt;cd(2);</span>
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 :   pad2-&gt;SetGrid(3);</span>
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :   pad2-&gt;SetTopMargin(0);</span>
<span class="lineNum">    1458 </span><span class="lineNoCov">          0 :   pad2-&gt;SetBottomMargin(bottommargin); // for the long x-axis labels (runnumbers)</span>
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 :   pad2-&gt;SetRightMargin(0.01);</span>
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 : }</span>
<a name="1461"><span class="lineNum">    1461 </span>            : </a>
<span class="lineNum">    1462 </span>            : 
<span class="lineNum">    1463 </span>            : void  TStatToolkit::DrawStatusGraphs(TObjArray* oaMultGr)
<span class="lineNum">    1464 </span>            : {
<span class="lineNum">    1465 </span>            :   //
<span class="lineNum">    1466 </span>            :   // draw Status graphs into active pad of canvas (by MI, Patrick Reichelt)
<span class="lineNum">    1467 </span>            :   // ...into bottom pad, if called after &quot;AddStatusPad(...)&quot;
<span class="lineNum">    1468 </span>            :   //
<span class="lineNum">    1469 </span><span class="lineNoCov">          0 :   const Int_t nvars = oaMultGr-&gt;GetEntriesFast();</span>
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :   TGraph* grAxis = (TGraph*) ((TMultiGraph*) oaMultGr-&gt;At(0))-&gt;GetListOfGraphs()-&gt;At(0);</span>
<span class="lineNum">    1471 </span><span class="lineNoCov">          0 :   grAxis-&gt;SetMaximum(0.5*nvars+0.5);</span>
<span class="lineNum">    1472 </span><span class="lineNoCov">          0 :   grAxis-&gt;SetMinimum(0);</span>
<span class="lineNum">    1473 </span><span class="lineNoCov">          0 :   grAxis-&gt;GetYaxis()-&gt;SetLabelSize(0);</span>
<span class="lineNum">    1474 </span><span class="lineNoCov">          0 :   grAxis-&gt;GetYaxis()-&gt;SetTitle(&quot;&quot;);</span>
<span class="lineNum">    1475 </span><span class="lineNoCov">          0 :   grAxis-&gt;SetTitle(&quot;&quot;);</span>
<span class="lineNum">    1476 </span><span class="lineNoCov">          0 :   Int_t entries = grAxis-&gt;GetN();</span>
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :   grAxis-&gt;GetXaxis()-&gt;SetLabelSize(5.7*TMath::Min(TMath::Max(5./entries,0.01),0.03));</span>
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :   grAxis-&gt;GetXaxis()-&gt;LabelsOption(&quot;v&quot;);</span>
<span class="lineNum">    1479 </span><span class="lineNoCov">          0 :   grAxis-&gt;Draw(&quot;ap&quot;);</span>
<span class="lineNum">    1480 </span>            :   //
<span class="lineNum">    1481 </span>            :   // draw multigraphs &amp; names of status variables on the y axis
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;nvars; i++){</span>
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 :     ((TMultiGraph*) oaMultGr-&gt;At(i))-&gt;Draw(&quot;p&quot;);</span>
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :     TLatex* ylabel = new TLatex(-0.1, 0.5*i+0.5, ((TMultiGraph*) oaMultGr-&gt;At(i))-&gt;GetTitle());</span>
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :     ylabel-&gt;SetTextAlign(32); //hor:right &amp; vert:centered</span>
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :     ylabel-&gt;SetTextSize(0.025/gPad-&gt;GetHNDC());</span>
<span class="lineNum">    1487 </span><span class="lineNoCov">          0 :     ylabel-&gt;Draw();</span>
<span class="lineNum">    1488 </span>            :   }
<span class="lineNum">    1489 </span><span class="lineNoCov">          0 : }</span>
<a name="1490"><span class="lineNum">    1490 </span>            : </a>
<span class="lineNum">    1491 </span>            : 
<span class="lineNum">    1492 </span>            : TTree*  TStatToolkit::WriteStatusToTree(TObject* oStatusGr) 
<span class="lineNum">    1493 </span>            : {
<span class="lineNum">    1494 </span>            :   //
<span class="lineNum">    1495 </span>            :   // Create Tree with Integers for each status variable flag (warning, outlier, physacc).
<span class="lineNum">    1496 </span>            :   // (by Patrick Reichelt)
<span class="lineNum">    1497 </span>            :   //
<span class="lineNum">    1498 </span>            :   // input: either a TMultiGraph with status of single variable, which 
<span class="lineNum">    1499 </span>            :   //        was computed by TStatToolkit::MakeStatusMultGr(),
<span class="lineNum">    1500 </span>            :   //        or a TObjArray which contains up to 10 of such variables.
<span class="lineNum">    1501 </span>            :   //        example: TTree* statusTree = WriteStatusToTree( TStatToolkit::MakeStatusMultGr(tree, &quot;tpcItsMatch:run&quot;,  &quot;&quot;, sCriteria.Data(), 0) );
<span class="lineNum">    1502 </span>            :   //        or     : TTree* statusTree = TStatToolkit::WriteStatusToTree(oaMultGr);
<span class="lineNum">    1503 </span>            :   // 
<span class="lineNum">    1504 </span>            :   // output tree: 1=flag is true, 0=flag is false, -1=flag was not computed.
<span class="lineNum">    1505 </span>            :   // To be rewritten to the pcstream
<span class="lineNum">    1506 </span>            :   
<span class="lineNum">    1507 </span>            :   TObjArray* oaMultGr = NULL;
<span class="lineNum">    1508 </span>            :   Bool_t needDeletion=kFALSE;
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :   if (oStatusGr-&gt;IsA() == TObjArray::Class()) {</span>
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 :     oaMultGr = (TObjArray*) oStatusGr;</span>
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1512 </span><span class="lineNoCov">          0 :   else if (oStatusGr-&gt;IsA() == TMultiGraph::Class()) {</span>
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :     oaMultGr = new TObjArray(); needDeletion=kTRUE;</span>
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 :     oaMultGr-&gt;Add((TMultiGraph*) oStatusGr);</span>
<span class="lineNum">    1515 </span>            :   }
<span class="lineNum">    1516 </span>            :   else {
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 :     Printf(&quot;WriteStatusToTree(): Error! 'oStatusGr' must be a TMultiGraph or a TObjArray of them!&quot;);</span>
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1519 </span>            :   }
<span class="lineNum">    1520 </span>            :   // variables for output tree
<span class="lineNum">    1521 </span>            :   const int nvarsMax=10;
<span class="lineNum">    1522 </span>            :   const int ncritMax=5;
<span class="lineNum">    1523 </span><span class="lineNoCov">          0 :   Int_t    currentRun;</span>
<span class="lineNum">    1524 </span><span class="lineNoCov">          0 :   Int_t    treevars[nvarsMax*ncritMax];</span>
<span class="lineNum">    1525 </span><span class="lineNoCov">          0 :   TString  varnames[nvarsMax*ncritMax];</span>
<span class="lineNum">    1526 </span><span class="lineNoCov">          0 :   for (int i=0; i&lt;nvarsMax*ncritMax; i++) treevars[i]=-1;</span>
<span class="lineNum">    1527 </span>            :   
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 :   Printf(&quot;WriteStatusToTree(): writing following variables to TTree (maybe only subset of listed criteria filled)&quot;);</span>
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 :   for (Int_t vari=0; vari&lt;nvarsMax; vari++) </span>
<span class="lineNum">    1530 </span>            :   {
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :     if (vari &lt; oaMultGr-&gt;GetEntriesFast()) {</span>
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :       varnames[vari*ncritMax+0] = Form(&quot;%s_statisticOK&quot;, ((TMultiGraph*) oaMultGr-&gt;At(vari))-&gt;GetName());</span>
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 :       varnames[vari*ncritMax+1] = Form(&quot;%s_Warning&quot;,     ((TMultiGraph*) oaMultGr-&gt;At(vari))-&gt;GetName());</span>
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :       varnames[vari*ncritMax+2] = Form(&quot;%s_Outlier&quot;,     ((TMultiGraph*) oaMultGr-&gt;At(vari))-&gt;GetName());</span>
<span class="lineNum">    1535 </span><span class="lineNoCov">          0 :       varnames[vari*ncritMax+3] = Form(&quot;%s_PhysAcc&quot;,     ((TMultiGraph*) oaMultGr-&gt;At(vari))-&gt;GetName());</span>
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 :       varnames[vari*ncritMax+4] = Form(&quot;%s_Extra&quot;,       ((TMultiGraph*) oaMultGr-&gt;At(vari))-&gt;GetName());</span>
<span class="lineNum">    1537 </span>            :     }
<span class="lineNum">    1538 </span>            :     else {
<span class="lineNum">    1539 </span><span class="lineNoCov">          0 :       varnames[vari*ncritMax+0] = Form(&quot;dummy&quot;);</span>
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :       varnames[vari*ncritMax+1] = Form(&quot;dummy&quot;);</span>
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 :       varnames[vari*ncritMax+2] = Form(&quot;dummy&quot;);</span>
<span class="lineNum">    1542 </span><span class="lineNoCov">          0 :       varnames[vari*ncritMax+3] = Form(&quot;dummy&quot;);</span>
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :       varnames[vari*ncritMax+4] = Form(&quot;dummy&quot;);</span>
<span class="lineNum">    1544 </span>            :     }
<span class="lineNum">    1545 </span><span class="lineNoCov">          0 :     cout &lt;&lt; &quot;  &quot; &lt;&lt; varnames[vari*ncritMax+0].Data() &lt;&lt; &quot; &quot; &lt;&lt; varnames[vari*ncritMax+1].Data() &lt;&lt; &quot; &quot; &lt;&lt; varnames[vari*ncritMax+2].Data() &lt;&lt; &quot; &quot; &lt;&lt; varnames[vari*ncritMax+3].Data() &lt;&lt; &quot; &quot; &lt;&lt; varnames[vari*ncritMax+4].Data() &lt;&lt; endl;</span>
<span class="lineNum">    1546 </span>            :   }
<span class="lineNum">    1547 </span>            :   
<span class="lineNum">    1548 </span><span class="lineNoCov">          0 :   TTree* statusTree = new TTree(&quot;statusTree&quot;,&quot;statusTree&quot;);</span>
<span class="lineNum">    1549 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(&quot;run&quot;,                &amp;currentRun  );</span>
<span class="lineNum">    1550 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[ 0].Data(),  &amp;treevars[ 0]);</span>
<span class="lineNum">    1551 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[ 1].Data(),  &amp;treevars[ 1]);</span>
<span class="lineNum">    1552 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[ 2].Data(),  &amp;treevars[ 2]);</span>
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[ 3].Data(),  &amp;treevars[ 3]);</span>
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[ 4].Data(),  &amp;treevars[ 4]);</span>
<span class="lineNum">    1555 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[ 5].Data(),  &amp;treevars[ 5]);</span>
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[ 6].Data(),  &amp;treevars[ 6]);</span>
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[ 7].Data(),  &amp;treevars[ 7]);</span>
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[ 8].Data(),  &amp;treevars[ 8]);</span>
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[ 9].Data(),  &amp;treevars[ 9]);</span>
<span class="lineNum">    1560 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[10].Data(),  &amp;treevars[10]);</span>
<span class="lineNum">    1561 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[11].Data(),  &amp;treevars[11]);</span>
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[12].Data(),  &amp;treevars[12]);</span>
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[13].Data(),  &amp;treevars[13]);</span>
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[14].Data(),  &amp;treevars[14]);</span>
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[15].Data(),  &amp;treevars[15]);</span>
<span class="lineNum">    1566 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[16].Data(),  &amp;treevars[16]);</span>
<span class="lineNum">    1567 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[17].Data(),  &amp;treevars[17]);</span>
<span class="lineNum">    1568 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[18].Data(),  &amp;treevars[18]);</span>
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[19].Data(),  &amp;treevars[19]);</span>
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[20].Data(),  &amp;treevars[20]);</span>
<span class="lineNum">    1571 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[21].Data(),  &amp;treevars[21]);</span>
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[22].Data(),  &amp;treevars[22]);</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[23].Data(),  &amp;treevars[23]);</span>
<span class="lineNum">    1574 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[24].Data(),  &amp;treevars[24]);</span>
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[25].Data(),  &amp;treevars[25]);</span>
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[26].Data(),  &amp;treevars[26]);</span>
<span class="lineNum">    1577 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[27].Data(),  &amp;treevars[27]);</span>
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[28].Data(),  &amp;treevars[28]);</span>
<span class="lineNum">    1579 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[29].Data(),  &amp;treevars[29]);</span>
<span class="lineNum">    1580 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[30].Data(),  &amp;treevars[30]);</span>
<span class="lineNum">    1581 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[31].Data(),  &amp;treevars[31]);</span>
<span class="lineNum">    1582 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[32].Data(),  &amp;treevars[32]);</span>
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[33].Data(),  &amp;treevars[33]);</span>
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[34].Data(),  &amp;treevars[34]);</span>
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[35].Data(),  &amp;treevars[35]);</span>
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[36].Data(),  &amp;treevars[36]);</span>
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[37].Data(),  &amp;treevars[37]);</span>
<span class="lineNum">    1588 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[38].Data(),  &amp;treevars[38]);</span>
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[39].Data(),  &amp;treevars[39]);</span>
<span class="lineNum">    1590 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[40].Data(),  &amp;treevars[40]);</span>
<span class="lineNum">    1591 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[41].Data(),  &amp;treevars[41]);</span>
<span class="lineNum">    1592 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[42].Data(),  &amp;treevars[42]);</span>
<span class="lineNum">    1593 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[43].Data(),  &amp;treevars[43]);</span>
<span class="lineNum">    1594 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[44].Data(),  &amp;treevars[44]);</span>
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[45].Data(),  &amp;treevars[45]);</span>
<span class="lineNum">    1596 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[46].Data(),  &amp;treevars[46]);</span>
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[47].Data(),  &amp;treevars[47]);</span>
<span class="lineNum">    1598 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[48].Data(),  &amp;treevars[48]);</span>
<span class="lineNum">    1599 </span><span class="lineNoCov">          0 :   statusTree-&gt;Branch(varnames[49].Data(),  &amp;treevars[49]);</span>
<span class="lineNum">    1600 </span>            :   
<span class="lineNum">    1601 </span>            :   // run loop
<span class="lineNum">    1602 </span><span class="lineNoCov">          0 :   Double_t graphX; // x-position of marker (0.5, 1.5, ...)</span>
<span class="lineNum">    1603 </span><span class="lineNoCov">          0 :   Double_t graphY; // if &gt;0 -&gt; warning/outlier/physacc! if =-0.5 -&gt; no warning/outlier/physacc</span>
<span class="lineNum">    1604 </span><span class="lineNoCov">          0 :   TList* arrRuns = (TList*) ((TGraph*) ((TMultiGraph*) oaMultGr-&gt;At(0))-&gt;GetListOfGraphs()-&gt;At(0))-&gt;GetXaxis()-&gt;GetLabels();</span>
<span class="lineNum">    1605 </span>            :   //'TAxis-&gt;GetLabels()' returns THashList of TObjString, but using THashList gives compilation error &quot;... incomplete type 'struct THashList' &quot;
<span class="lineNum">    1606 </span><span class="lineNoCov">          0 :   for (Int_t runi=0; runi&lt;arrRuns-&gt;GetSize(); runi++) </span>
<span class="lineNum">    1607 </span>            :   {
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 :     currentRun = atoi( arrRuns-&gt;At(runi)-&gt;GetName() );</span>
<span class="lineNum">    1609 </span>            :     //Printf(&quot; runi=%2i, name: %s \t run number: %i&quot;, runi, arrRuns-&gt;At(runi)-&gt;GetName(), currentRun);
<span class="lineNum">    1610 </span>            :     
<span class="lineNum">    1611 </span>            :     // status variable loop
<span class="lineNum">    1612 </span><span class="lineNoCov">          0 :     for (Int_t vari=0; vari&lt;oaMultGr-&gt;GetEntriesFast(); vari++) </span>
<span class="lineNum">    1613 </span>            :     {
<span class="lineNum">    1614 </span><span class="lineNoCov">          0 :       TMultiGraph* multGr = (TMultiGraph*) oaMultGr-&gt;At(vari);</span>
<span class="lineNum">    1615 </span>            :       
<span class="lineNum">    1616 </span>            :       // criteria loop
<span class="lineNum">    1617 </span>            :       // the order is given by TStatToolkit::MakeStatusMultGr().
<span class="lineNum">    1618 </span>            :       // criterion #1 is 'statisticOK' and mandatory, the rest is optional. (#0 is always True, thus skipped)
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :       for (Int_t criti=1; criti&lt;multGr-&gt;GetListOfGraphs()-&gt;GetEntries(); criti++) </span>
<span class="lineNum">    1620 </span>            :       {
<span class="lineNum">    1621 </span><span class="lineNoCov">          0 :         TGraph* grCriterion = (TGraph*) multGr-&gt;GetListOfGraphs()-&gt;At(criti);</span>
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 :         graphX = -1, graphY = -1;</span>
<span class="lineNum">    1623 </span><span class="lineNoCov">          0 :         grCriterion-&gt;GetPoint(runi, graphX, graphY);</span>
<span class="lineNum">    1624 </span><span class="lineNoCov">          0 :         treevars[(vari)*ncritMax+(criti-1)] = (graphY&gt;0)?1:0;</span>
<span class="lineNum">    1625 </span>            :       }
<span class="lineNum">    1626 </span>            :     }
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 :     statusTree-&gt;Fill();</span>
<span class="lineNum">    1628 </span>            :   }
<span class="lineNum">    1629 </span>            :   
<span class="lineNum">    1630 </span><span class="lineNoCov">          0 :   if (needDeletion) delete oaMultGr;</span>
<span class="lineNum">    1631 </span>            :   
<span class="lineNum">    1632 </span>            :   return statusTree;
<span class="lineNum">    1633 </span><span class="lineNoCov">          0 : }</span>
<a name="1634"><span class="lineNum">    1634 </span>            : </a>
<span class="lineNum">    1635 </span>            : 
<span class="lineNum">    1636 </span>            : void   TStatToolkit::MakeSummaryTree(TTree* treeIn, TTreeSRedirector *pcstream, TObjString &amp; sumID, TCut &amp;selection){
<span class="lineNum">    1637 </span>            :   //
<span class="lineNum">    1638 </span>            :   // Make a  summary tree for the input tree 
<span class="lineNum">    1639 </span>            :   // For the moment statistic works only for the primitive branches (Float/Double/Int)
<span class="lineNum">    1640 </span>            :   // Extension recursive version planned for graphs a and histograms
<span class="lineNum">    1641 </span>            :   //
<span class="lineNum">    1642 </span>            :   // Following statistics are exctracted:
<span class="lineNum">    1643 </span>            :   //   - Standard: mean, meadian, rms
<span class="lineNum">    1644 </span>            :   //   - LTM robust statistic: mean60, rms60, mean90, rms90
<span class="lineNum">    1645 </span>            :   // Parameters:
<span class="lineNum">    1646 </span>            :   //    treeIn    - input tree 
<span class="lineNum">    1647 </span>            :   //    pctream   - Output redirector
<span class="lineNum">    1648 </span>            :   //    sumID     - ID as will be used in output tree
<span class="lineNum">    1649 </span>            :   //    selection - selection criteria define the set of entries used to evaluat statistic 
<span class="lineNum">    1650 </span>            :   //
<span class="lineNum">    1651 </span>            :   // Curently only predefined statistic used to fill summary information
<span class="lineNum">    1652 </span>            :   // Future plans an option user defined statistic descriptor instead of the defualt (if exist)
<span class="lineNum">    1653 </span>            :   // 
<span class="lineNum">    1654 </span>            :   //      e.g 
<span class="lineNum">    1655 </span>            :   //          default.Branches=median:mean90:rms90:mean60:rms60
<span class="lineNum">    1656 </span>            :   //          interactionRate.Branches   mean90:median:rms90:mean95:rms95:mean60:rms60
<span class="lineNum">    1657 </span>            :   //
<span class="lineNum">    1658 </span><span class="lineNoCov">          0 :   TObjArray * brArray = treeIn-&gt;GetListOfBranches();</span>
<span class="lineNum">    1659 </span><span class="lineNoCov">          0 :   Int_t tEntries= treeIn-&gt;GetEntries();</span>
<span class="lineNum">    1660 </span><span class="lineNoCov">          0 :   Int_t nBranches=brArray-&gt;GetEntries();</span>
<span class="lineNum">    1661 </span><span class="lineNoCov">          0 :   TString treeName = treeIn-&gt;GetName();</span>
<span class="lineNum">    1662 </span>            : 
<span class="lineNum">    1663 </span><span class="lineNoCov">          0 :   (*pcstream)&lt;&lt;treeName.Data()&lt;&lt;&quot;entries=&quot;&lt;&lt;tEntries;</span>
<span class="lineNum">    1664 </span><span class="lineNoCov">          0 :   (*pcstream)&lt;&lt;treeName.Data()&lt;&lt;&quot;ID.=&quot;&lt;&lt;&amp;sumID;</span>
<span class="lineNum">    1665 </span>            :   
<span class="lineNum">    1666 </span><span class="lineNoCov">          0 :   TMatrixD valBranch(nBranches,7);</span>
<span class="lineNum">    1667 </span><span class="lineNoCov">          0 :   for (Int_t iBr=0; iBr&lt;nBranches; iBr++){    </span>
<span class="lineNum">    1668 </span><span class="lineNoCov">          0 :     TString brName= brArray-&gt;At(iBr)-&gt;GetName();</span>
<span class="lineNum">    1669 </span><span class="lineNoCov">          0 :     Int_t entries=treeIn-&gt;Draw(TString::Format(&quot;%s&gt;&gt;dummy(10,0,1)&quot;,brArray-&gt;At(iBr)-&gt;GetName()).Data(),selection,&quot;goff&quot;);</span>
<span class="lineNum">    1670 </span><span class="lineNoCov">          0 :     if (entries==0) continue;</span>
<span class="lineNum">    1671 </span><span class="lineNoCov">          0 :     Double_t median, mean, rms, mean60,rms60, mean90, rms90;</span>
<span class="lineNum">    1672 </span><span class="lineNoCov">          0 :     mean  = TMath::Mean(entries,treeIn-&gt;GetV1());</span>
<span class="lineNum">    1673 </span><span class="lineNoCov">          0 :     median= TMath::Median(entries,treeIn-&gt;GetV1());</span>
<span class="lineNum">    1674 </span><span class="lineNoCov">          0 :     rms   = TMath::RMS(entries,treeIn-&gt;GetV1());</span>
<span class="lineNum">    1675 </span><span class="lineNoCov">          0 :     TStatToolkit::EvaluateUni(entries, treeIn-&gt;GetV1(), mean60,rms60,TMath::Min(TMath::Max(2., 0.60*entries),Double_t(entries)));</span>
<span class="lineNum">    1676 </span><span class="lineNoCov">          0 :     TStatToolkit::EvaluateUni(entries, treeIn-&gt;GetV1(), mean90,rms90,TMath::Min(TMath::Max(2., 0.90*entries),Double_t(entries)));</span>
<span class="lineNum">    1677 </span><span class="lineNoCov">          0 :     valBranch(iBr,0)=mean; </span>
<span class="lineNum">    1678 </span><span class="lineNoCov">          0 :     valBranch(iBr,1)=median; </span>
<span class="lineNum">    1679 </span><span class="lineNoCov">          0 :     valBranch(iBr,2)=rms; </span>
<span class="lineNum">    1680 </span><span class="lineNoCov">          0 :     valBranch(iBr,3)=mean60; </span>
<span class="lineNum">    1681 </span><span class="lineNoCov">          0 :     valBranch(iBr,4)=rms60; </span>
<span class="lineNum">    1682 </span><span class="lineNoCov">          0 :     valBranch(iBr,5)=mean90; </span>
<span class="lineNum">    1683 </span><span class="lineNoCov">          0 :     valBranch(iBr,6)=rms90; </span>
<span class="lineNum">    1684 </span><span class="lineNoCov">          0 :     (*pcstream)&lt;&lt;treeName.Data()&lt;&lt;</span>
<span class="lineNum">    1685 </span><span class="lineNoCov">          0 :       brName+&quot;=&quot;&lt;&lt;valBranch(iBr,1)&lt;&lt;           // use as an default median estimator</span>
<span class="lineNum">    1686 </span><span class="lineNoCov">          0 :       brName+&quot;_Mean=&quot;&lt;&lt;valBranch(iBr,0)&lt;&lt; </span>
<span class="lineNum">    1687 </span><span class="lineNoCov">          0 :       brName+&quot;_Median=&quot;&lt;&lt;valBranch(iBr,1)&lt;&lt;</span>
<span class="lineNum">    1688 </span><span class="lineNoCov">          0 :       brName+&quot;_RMS=&quot;&lt;&lt;valBranch(iBr,2)&lt;&lt;</span>
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 :       brName+&quot;_Mean60=&quot;&lt;&lt;valBranch(iBr,3)&lt;&lt;</span>
<span class="lineNum">    1690 </span><span class="lineNoCov">          0 :       brName+&quot;_RMS60=&quot;&lt;&lt;valBranch(iBr,4)&lt;&lt;</span>
<span class="lineNum">    1691 </span><span class="lineNoCov">          0 :       brName+&quot;_Mean90=&quot;&lt;&lt;valBranch(iBr,5)&lt;&lt;</span>
<span class="lineNum">    1692 </span><span class="lineNoCov">          0 :       brName+&quot;_RMS90=&quot;&lt;&lt;valBranch(iBr,6);  </span>
<span class="lineNum">    1693 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1694 </span><span class="lineNoCov">          0 :   (*pcstream)&lt;&lt;treeName.Data()&lt;&lt;&quot;\n&quot;;</span>
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1696 </span>            : 
<a name="1697"><span class="lineNum">    1697 </span>            : </a>
<span class="lineNum">    1698 </span>            : 
<span class="lineNum">    1699 </span>            : TMultiGraph*  TStatToolkit::MakeStatusLines(TTree * tree, const char * expr, const char * cut, const char * alias) 
<span class="lineNum">    1700 </span>            : {
<span class="lineNum">    1701 </span>            :   //
<span class="lineNum">    1702 </span>            :   // Create status lines for trending using MakeGraphSparse(), very similar to MakeStatusMultGr().
<span class="lineNum">    1703 </span>            :   // (by Patrick Reichelt)
<span class="lineNum">    1704 </span>            :   //
<span class="lineNum">    1705 </span>            :   // format of expr :  varname:xaxis (e.g. meanTPCncl:run, but 'varname' can be any string that you need for seach-and-replace)
<span class="lineNum">    1706 </span>            :   // format of cut  :  char like in TCut
<span class="lineNum">    1707 </span>            :   // format of alias:  varname_OutlierMin:varname_OutlierMax:varname_WarningMin:varname_WarningMax:varname_PhysAccMin:varname_PhysAccMax:varname_RobustMean
<span class="lineNum">    1708 </span>            :   //
<span class="lineNum">    1709 </span><span class="lineNoCov">          0 :   TObjArray* oaVar = TString(expr).Tokenize(&quot;:&quot;);</span>
<span class="lineNum">    1710 </span><span class="lineNoCov">          0 :   if (oaVar-&gt;GetEntries()&lt;2) {</span>
<span class="lineNum">    1711 </span><span class="lineNoCov">          0 :     printf(&quot;Expression has to be of type 'varname:xaxis':\t%s\n&quot;, expr);</span>
<span class="lineNum">    1712 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1713 </span>            :   }
<span class="lineNum">    1714 </span><span class="lineNoCov">          0 :   char varname[50];</span>
<span class="lineNum">    1715 </span><span class="lineNoCov">          0 :   char var_x[50];</span>
<span class="lineNum">    1716 </span><span class="lineNoCov">          0 :   snprintf(varname,50,&quot;%s&quot;, oaVar-&gt;At(0)-&gt;GetName());</span>
<span class="lineNum">    1717 </span><span class="lineNoCov">          0 :   snprintf(var_x  ,50,&quot;%s&quot;, oaVar-&gt;At(1)-&gt;GetName());</span>
<span class="lineNum">    1718 </span>            :   //
<span class="lineNum">    1719 </span><span class="lineNoCov">          0 :   TString sAlias(alias);</span>
<span class="lineNum">    1720 </span><span class="lineNoCov">          0 :   if (sAlias.IsNull()) { // alias for default usage set here:</span>
<span class="lineNum">    1721 </span><span class="lineNoCov">          0 :     sAlias = &quot;varname_OutlierMin:varname_OutlierMax:varname_WarningMin:varname_WarningMax:varname_PhysAccMin:varname_PhysAccMax:varname_RobustMean&quot;;</span>
<span class="lineNum">    1722 </span>            :   }
<span class="lineNum">    1723 </span><span class="lineNoCov">          0 :   sAlias.ReplaceAll(&quot;varname&quot;,varname);</span>
<span class="lineNum">    1724 </span><span class="lineNoCov">          0 :   TObjArray* oaAlias = TString(sAlias.Data()).Tokenize(&quot;:&quot;);</span>
<span class="lineNum">    1725 </span><span class="lineNoCov">          0 :   if (oaAlias-&gt;GetEntries()&lt;2) {</span>
<span class="lineNum">    1726 </span><span class="lineNoCov">          0 :     printf(&quot;Alias must have 2-7 arguments:\t%s\n&quot;, alias);</span>
<span class="lineNum">    1727 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1728 </span>            :   }
<span class="lineNum">    1729 </span><span class="lineNoCov">          0 :   char query[200];</span>
<span class="lineNum">    1730 </span><span class="lineNoCov">          0 :   TMultiGraph* multGr = new TMultiGraph();</span>
<span class="lineNum">    1731 </span><span class="lineNoCov">          0 :   Int_t colArr[7] = {kRed, kRed, kOrange, kOrange, kGreen+1, kGreen+1, kGray+2};</span>
<span class="lineNum">    1732 </span><span class="lineNoCov">          0 :   const Int_t ngr = oaAlias-&gt;GetEntriesFast();</span>
<span class="lineNum">    1733 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;ngr; i++){</span>
<span class="lineNum">    1734 </span><span class="lineNoCov">          0 :     snprintf(query,200, &quot;%s:%s&quot;, oaAlias-&gt;At(i)-&gt;GetName(), var_x);</span>
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 :     multGr-&gt;Add( (TGraphErrors*) TStatToolkit::MakeGraphSparse(tree,query,cut,29,colArr[i],1.5) );</span>
<span class="lineNum">    1736 </span>            :   }
<span class="lineNum">    1737 </span>            :   //
<span class="lineNum">    1738 </span><span class="lineNoCov">          0 :   multGr-&gt;SetName(varname);</span>
<span class="lineNum">    1739 </span><span class="lineNoCov">          0 :   multGr-&gt;SetTitle(varname);</span>
<span class="lineNum">    1740 </span><span class="lineNoCov">          0 :   delete oaVar;</span>
<span class="lineNum">    1741 </span><span class="lineNoCov">          0 :   delete oaAlias;</span>
<span class="lineNum">    1742 </span>            :   return multGr;
<span class="lineNum">    1743 </span><span class="lineNoCov">          0 : }</span>
<a name="1744"><span class="lineNum">    1744 </span>            : </a>
<span class="lineNum">    1745 </span>            : 
<span class="lineNum">    1746 </span>            : TH1* TStatToolkit::DrawHistogram(TTree * tree, const char* drawCommand, const char* cuts, const char* histoname, const char* histotitle, Int_t nsigma, Float_t fraction, TObjArray *description )
<span class="lineNum">    1747 </span>            : {
<span class="lineNum">    1748 </span>            :   //
<span class="lineNum">    1749 </span>            :   // Draw histogram from TTree with robust range
<span class="lineNum">    1750 </span>            :   // Only for 1D so far!
<span class="lineNum">    1751 </span>            :   // 
<span class="lineNum">    1752 </span>            :   // Parameters:
<span class="lineNum">    1753 </span>            :   // - histoname:  name of histogram
<span class="lineNum">    1754 </span>            :   // - histotitle: title of histgram
<span class="lineNum">    1755 </span>            :   // - fraction:   fraction of data to define the robust mean
<span class="lineNum">    1756 </span>            :   // - nsigma:     nsigma value for range
<span class="lineNum">    1757 </span>            :   //
<span class="lineNum">    1758 </span>            :   // To add:
<span class="lineNum">    1759 </span>            :   //    automatic ranges - separatelly for X, Y and Z nbins  - as string
<span class="lineNum">    1760 </span>            :   //    names for the variables
<span class="lineNum">    1761 </span>            :   //    option, entries, first entry  like in tree draw
<span class="lineNum">    1762 </span>            :   //
<span class="lineNum">    1763 </span><span class="lineNoCov">          0 :    TString drawStr(drawCommand);</span>
<span class="lineNum">    1764 </span><span class="lineNoCov">          0 :    TString cutStr(cuts);</span>
<span class="lineNum">    1765 </span>            :    Int_t dim = 1;
<span class="lineNum">    1766 </span>            : 
<span class="lineNum">    1767 </span><span class="lineNoCov">          0 :    if(!tree) {</span>
<span class="lineNum">    1768 </span><span class="lineNoCov">          0 :      ::Error(&quot;TStatToolkit::DrawHistogram&quot;,&quot;Tree pointer is NULL!&quot;);</span>
<span class="lineNum">    1769 </span><span class="lineNoCov">          0 :      return 0;</span>
<span class="lineNum">    1770 </span>            :    }
<span class="lineNum">    1771 </span>            : 
<span class="lineNum">    1772 </span>            :    // get entries
<span class="lineNum">    1773 </span><span class="lineNoCov">          0 :    Int_t entries = tree-&gt;Draw(drawStr.Data(), cutStr.Data(), &quot;goff&quot;);</span>
<span class="lineNum">    1774 </span><span class="lineNoCov">          0 :    if (entries == -1) {</span>
<span class="lineNum">    1775 </span><span class="lineNoCov">          0 :      ::Error(&quot;TStatToolkit::DrawHistogram&quot;,&quot;Tree draw returns -!&quot;);</span>
<span class="lineNum">    1776 </span><span class="lineNoCov">          0 :      return 0;</span>
<span class="lineNum">    1777 </span>            :    }
<span class="lineNum">    1778 </span><span class="lineNoCov">          0 :    TObjArray *charray = drawStr.Tokenize(&quot;:&quot;);</span>
<span class="lineNum">    1779 </span>            : 
<span class="lineNum">    1780 </span>            :    // get dimension
<span class="lineNum">    1781 </span><span class="lineNoCov">          0 :    if(tree-&gt;GetV1()) dim = 1;</span>
<span class="lineNum">    1782 </span><span class="lineNoCov">          0 :    if(tree-&gt;GetV2()) dim = 2;</span>
<span class="lineNum">    1783 </span><span class="lineNoCov">          0 :    if(tree-&gt;GetV3()) dim = 3;</span>
<span class="lineNum">    1784 </span><span class="lineNoCov">          0 :    if(dim &gt; 2){</span>
<span class="lineNum">    1785 </span><span class="lineNoCov">          0 :      cerr&lt;&lt;&quot;TTree has more than 2 dimensions (not yet supported)&quot;&lt;&lt;endl;</span>
<span class="lineNum">    1786 </span><span class="lineNoCov">          0 :      return 0;</span>
<span class="lineNum">    1787 </span>            :    }
<span class="lineNum">    1788 </span>            : 
<span class="lineNum">    1789 </span>            :    // draw robust
<span class="lineNum">    1790 </span>            :    // Get estimators
<span class="lineNum">    1791 </span><span class="lineNoCov">          0 :    Double_t mean1=0, rms1=0, min1=0, max1=0;</span>
<span class="lineNum">    1792 </span><span class="lineNoCov">          0 :    Double_t mean2=0, rms2=0, min2=0, max2=0;</span>
<span class="lineNum">    1793 </span><span class="lineNoCov">          0 :    Double_t mean3=0, rms3=0, min3=0, max3=0;</span>
<span class="lineNum">    1794 </span>            :    
<span class="lineNum">    1795 </span><span class="lineNoCov">          0 :    TStatToolkit::GetMinMaxMean( tree-&gt;GetV1(),entries, min1,max1, mean1);  </span>
<span class="lineNum">    1796 </span><span class="lineNoCov">          0 :    TStatToolkit::EvaluateUni(entries, tree-&gt;GetV1(),mean1,rms1, fraction*entries);</span>
<span class="lineNum">    1797 </span><span class="lineNoCov">          0 :    if(dim&gt;1){</span>
<span class="lineNum">    1798 </span><span class="lineNoCov">          0 :      TStatToolkit::GetMinMaxMean( tree-&gt;GetV2(),entries, min2,max2, mean2);  </span>
<span class="lineNum">    1799 </span><span class="lineNoCov">          0 :      TStatToolkit::EvaluateUni(entries, tree-&gt;GetV1(),mean2,rms2, fraction*entries);</span>
<span class="lineNum">    1800 </span>            :    }
<span class="lineNum">    1801 </span><span class="lineNoCov">          0 :    if(dim&gt;2){</span>
<span class="lineNum">    1802 </span><span class="lineNoCov">          0 :      TStatToolkit::GetMinMaxMean( tree-&gt;GetV3(),entries, min3,max3, mean3);  </span>
<span class="lineNum">    1803 </span><span class="lineNoCov">          0 :      TStatToolkit::EvaluateUni(entries, tree-&gt;GetV3(),mean3,rms3, fraction*entries);</span>
<span class="lineNum">    1804 </span>            :    }
<span class="lineNum">    1805 </span>            : 
<span class="lineNum">    1806 </span>            :    TH1* hOut=NULL;
<span class="lineNum">    1807 </span><span class="lineNoCov">          0 :    if(dim==1){</span>
<span class="lineNum">    1808 </span><span class="lineNoCov">          0 :      hOut = new TH1F(histoname, histotitle, 200, mean1-nsigma*rms1, mean1+nsigma*rms1);</span>
<span class="lineNum">    1809 </span><span class="lineNoCov">          0 :      for (Int_t i=0; i&lt;entries; i++) hOut-&gt;Fill(tree-&gt;GetV1()[i]);</span>
<span class="lineNum">    1810 </span><span class="lineNoCov">          0 :      hOut-&gt;GetXaxis()-&gt;SetTitle(tree-&gt;GetHistogram()-&gt;GetXaxis()-&gt;GetTitle());</span>
<span class="lineNum">    1811 </span>            :    }
<span class="lineNum">    1812 </span><span class="lineNoCov">          0 :    else if(dim==2){</span>
<span class="lineNum">    1813 </span><span class="lineNoCov">          0 :      hOut = new TH2F(histoname, histotitle, 200, min2, max2,200, mean1-nsigma*rms1, mean1+nsigma*rms1);</span>
<span class="lineNum">    1814 </span><span class="lineNoCov">          0 :      for (Int_t i=0; i&lt;entries; i++) hOut-&gt;Fill(tree-&gt;GetV2()[i],tree-&gt;GetV1()[i]);</span>
<span class="lineNum">    1815 </span><span class="lineNoCov">          0 :      hOut-&gt;GetXaxis()-&gt;SetTitle(tree-&gt;GetHistogram()-&gt;GetXaxis()-&gt;GetTitle());</span>
<span class="lineNum">    1816 </span><span class="lineNoCov">          0 :      hOut-&gt;GetYaxis()-&gt;SetTitle(tree-&gt;GetHistogram()-&gt;GetYaxis()-&gt;GetTitle());</span>
<span class="lineNum">    1817 </span>            :    }
<span class="lineNum">    1818 </span><span class="lineNoCov">          0 :    THashList * metaData = (THashList*) tree-&gt;GetUserInfo()-&gt;FindObject(&quot;metaTable&quot;);</span>
<span class="lineNum">    1819 </span>            :    
<span class="lineNum">    1820 </span><span class="lineNoCov">          0 :    if (!metaData == 0){    </span>
<span class="lineNum">    1821 </span><span class="lineNoCov">          0 :     TNamed *nmdTitle0 = TStatToolkit::GetMetadata(tree,Form(&quot;%s.Title&quot;,charray-&gt;At(0)-&gt;GetName()));</span>
<span class="lineNum">    1822 </span><span class="lineNoCov">          0 :     TNamed *nmdXAxis  = TStatToolkit::GetMetadata(tree,Form(&quot;%s.AxisTitle&quot;,charray-&gt;At(1)-&gt;GetName())); </span>
<span class="lineNum">    1823 </span><span class="lineNoCov">          0 :     TNamed *nmdTitle1 = TStatToolkit::GetMetadata(tree,Form(&quot;%s.Title&quot;,charray-&gt;At(1)-&gt;GetName()));</span>
<span class="lineNum">    1824 </span><span class="lineNoCov">          0 :     TNamed *nmdYAxis  = TStatToolkit::GetMetadata(tree,Form(&quot;%s.AxisTitle&quot;,charray-&gt;At(0)-&gt;GetName()));</span>
<span class="lineNum">    1825 </span>            :     //
<span class="lineNum">    1826 </span><span class="lineNoCov">          0 :     TString hisTitle=charray-&gt;At(0)-&gt;GetName();</span>
<span class="lineNum">    1827 </span><span class="lineNoCov">          0 :     if (nmdTitle0)  hisTitle=nmdTitle0-&gt;GetTitle();</span>
<span class="lineNum">    1828 </span><span class="lineNoCov">          0 :     if (nmdTitle1)  {</span>
<span class="lineNum">    1829 </span><span class="lineNoCov">          0 :       hisTitle+=&quot;:&quot;;</span>
<span class="lineNum">    1830 </span><span class="lineNoCov">          0 :       hisTitle+=nmdTitle1-&gt;GetTitle();</span>
<span class="lineNum">    1831 </span>            :     }else{
<span class="lineNum">    1832 </span><span class="lineNoCov">          0 :       hisTitle+=&quot;:&quot;;</span>
<span class="lineNum">    1833 </span><span class="lineNoCov">          0 :       hisTitle+=charray-&gt;At(1)-&gt;GetName();</span>
<span class="lineNum">    1834 </span>            :     }
<span class="lineNum">    1835 </span><span class="lineNoCov">          0 :     if (nmdYAxis) {hOut-&gt;GetYaxis()-&gt;SetTitle(nmdYAxis-&gt;GetTitle());}</span>
<span class="lineNum">    1836 </span><span class="lineNoCov">          0 :     if (nmdXAxis) {hOut-&gt;GetXaxis()-&gt;SetTitle(nmdXAxis-&gt;GetTitle());}            </span>
<span class="lineNum">    1837 </span><span class="lineNoCov">          0 :     hOut-&gt;SetTitle(hisTitle);</span>
<span class="lineNum">    1838 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1839 </span><span class="lineNoCov">          0 :   delete charray;</span>
<span class="lineNum">    1840 </span>            :   // if (option) hOut-&gt;Draw(option);
<span class="lineNum">    1841 </span>            :   return hOut;
<a name="1842"><span class="lineNum">    1842 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1843 </span>            : 
<span class="lineNum">    1844 </span>            : void TStatToolkit::CheckTreeAliases(TTree * tree, Int_t ncheck){
<span class="lineNum">    1845 </span>            :   //
<span class="lineNum">    1846 </span>            :   // Check consistency of tree aliases
<span class="lineNum">    1847 </span>            :   //
<span class="lineNum">    1848 </span>            :   Int_t nCheck=100;
<span class="lineNum">    1849 </span><span class="lineNoCov">          0 :   TList * aliases = (TList*)tree-&gt;GetListOfAliases();</span>
<span class="lineNum">    1850 </span><span class="lineNoCov">          0 :   Int_t entries = aliases-&gt;GetEntries();</span>
<span class="lineNum">    1851 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;entries; i++){</span>
<span class="lineNum">    1852 </span><span class="lineNoCov">          0 :     TObject * object= aliases-&gt;At(i);</span>
<span class="lineNum">    1853 </span><span class="lineNoCov">          0 :     if (!object) continue;</span>
<span class="lineNum">    1854 </span><span class="lineNoCov">          0 :     Int_t ndraw=tree-&gt;Draw(aliases-&gt;At(i)-&gt;GetName(),&quot;1&quot;,&quot;goff&quot;,nCheck);</span>
<span class="lineNum">    1855 </span><span class="lineNoCov">          0 :     if (ndraw==0){</span>
<span class="lineNum">    1856 </span><span class="lineNoCov">          0 :       ::Error(&quot;Alias:\tProblem&quot;,&quot;%s&quot;,aliases-&gt;At(i)-&gt;GetName());</span>
<span class="lineNum">    1857 </span><span class="lineNoCov">          0 :     }else{</span>
<span class="lineNum">    1858 </span><span class="lineNoCov">          0 :       ::Info(&quot;Alias:\tOK&quot;,&quot;%s&quot;,aliases-&gt;At(i)-&gt;GetName());</span>
<span class="lineNum">    1859 </span>            :     }
<span class="lineNum">    1860 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1861 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1862 </span>            : 
<span class="lineNum">    1863 </span>            : 
<a name="1864"><span class="lineNum">    1864 </span>            : </a>
<span class="lineNum">    1865 </span>            : 
<span class="lineNum">    1866 </span>            : Double_t TStatToolkit::GetDefaultStat(TTree * tree, const char * var, const char * selection, TStatType statType){
<span class="lineNum">    1867 </span>            :   //
<span class="lineNum">    1868 </span>            :   //
<span class="lineNum">    1869 </span>            :   //
<span class="lineNum">    1870 </span><span class="lineNoCov">          0 :   Int_t entries = tree-&gt;Draw(var,selection,&quot;goff&quot;);</span>
<span class="lineNum">    1871 </span><span class="lineNoCov">          0 :   if (entries==0) return 0;</span>
<span class="lineNum">    1872 </span><span class="lineNoCov">          0 :   switch(statType){    </span>
<span class="lineNum">    1873 </span>            :   case kEntries:    
<span class="lineNum">    1874 </span><span class="lineNoCov">          0 :     return entries;</span>
<span class="lineNum">    1875 </span>            :   case kSum:    
<span class="lineNum">    1876 </span><span class="lineNoCov">          0 :     return entries*TMath::Mean(entries, tree-&gt;GetV1());</span>
<span class="lineNum">    1877 </span>            :   case kMean:    
<span class="lineNum">    1878 </span><span class="lineNoCov">          0 :     return TMath::Mean(entries, tree-&gt;GetV1());</span>
<span class="lineNum">    1879 </span>            :   case kRMS:     
<span class="lineNum">    1880 </span><span class="lineNoCov">          0 :     return TMath::RMS(entries, tree-&gt;GetV1());</span>
<span class="lineNum">    1881 </span>            :   case kMedian:  
<span class="lineNum">    1882 </span><span class="lineNoCov">          0 :     return TMath::Median(entries, tree-&gt;GetV1());    </span>
<span class="lineNum">    1883 </span>            :   }
<span class="lineNum">    1884 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">    1885 </span><span class="lineNoCov">          0 : }</span>
<a name="1886"><span class="lineNum">    1886 </span>            : </a>
<span class="lineNum">    1887 </span>            : //_____________________________________________________________________________
<span class="lineNum">    1888 </span>            : void TStatToolkit::CombineArray(TTree *tree, TVectorD &amp;values)
<span class="lineNum">    1889 </span>            : {
<span class="lineNum">    1890 </span>            :   /// Collect all variables from the last draw in one array.
<span class="lineNum">    1891 </span>            :   ///
<span class="lineNum">    1892 </span>            :   /// It is assumed that the Draw function of the TTree was called before
<span class="lineNum">    1893 </span>            :   /// if e.g. Draw(&quot;v1:v2:v3&quot;) had been called, then values will contain
<span class="lineNum">    1894 </span>            :   /// the concatenated array of the values from v1,v2 and v3.
<span class="lineNum">    1895 </span>            :   /// E.g. if the v1[0..n], v2[0..n], v3[0..n] then
<span class="lineNum">    1896 </span>            :   /// values[0..3n] = [v1, v2, v3]
<span class="lineNum">    1897 </span>            :   /// \param[in]  tree   input tree
<span class="lineNum">    1898 </span>            :   /// \param[out] values array in which to summarise all 'drawn' values
<span class="lineNum">    1899 </span><span class="lineNoCov">          0 :   const Int_t numberOfDimensions = tree-&gt;GetPlayer()-&gt;GetDimension();</span>
<span class="lineNum">    1900 </span><span class="lineNoCov">          0 :   if (numberOfDimensions==1) {</span>
<span class="lineNum">    1901 </span><span class="lineNoCov">          0 :     values.Use(tree-&gt;GetSelectedRows(), tree-&gt;GetVal(0));</span>
<span class="lineNum">    1902 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1903 </span>            :   }
<span class="lineNum">    1904 </span>            : 
<span class="lineNum">    1905 </span><span class="lineNoCov">          0 :   const Int_t numberOfSelectedRows = tree-&gt;GetSelectedRows();</span>
<span class="lineNum">    1906 </span><span class="lineNoCov">          0 :   values.ResizeTo(numberOfDimensions * numberOfSelectedRows);</span>
<span class="lineNum">    1907 </span>            : 
<span class="lineNum">    1908 </span>            :   Int_t nfill=0;
<span class="lineNum">    1909 </span><span class="lineNoCov">          0 :   for (Int_t idim=0; idim&lt;numberOfDimensions; ++idim) {</span>
<span class="lineNum">    1910 </span><span class="lineNoCov">          0 :     const Double_t *arr = tree-&gt;GetVal(idim);</span>
<span class="lineNum">    1911 </span><span class="lineNoCov">          0 :     if (!arr) continue;</span>
<span class="lineNum">    1912 </span>            : 
<span class="lineNum">    1913 </span><span class="lineNoCov">          0 :     for (Int_t ival=0; ival&lt;numberOfSelectedRows; ++ival) {</span>
<span class="lineNum">    1914 </span><span class="lineNoCov">          0 :       values.GetMatrixArray()[nfill++] = arr[ival];</span>
<span class="lineNum">    1915 </span>            :     }
<span class="lineNum">    1916 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1917 </span>            : 
<span class="lineNum">    1918 </span><span class="lineNoCov">          0 : }</span>
<a name="1919"><span class="lineNum">    1919 </span>            : </a>
<span class="lineNum">    1920 </span>            : //_____________________________________________________________________________
<span class="lineNum">    1921 </span>            : Double_t TStatToolkit::GetDistance(const TVectorD &amp;values, const ENormType normType,
<span class="lineNum">    1922 </span>            :                                    const Bool_t normaliseToEntries/*=kFALSE*/, const Double_t pvalue/*=1*/)
<span class="lineNum">    1923 </span>            : {
<span class="lineNum">    1924 </span>            :   /// Calculate the distance of the elements in values using a certain norm
<span class="lineNum">    1925 </span>            :   /// \param[in] values             array with input values
<span class="lineNum">    1926 </span>            :   /// \param[in] normType           normalisation to use
<span class="lineNum">    1927 </span>            :   /// \param[in] normaliseToEntries divide the norm by the number of eleements ('average norm')
<span class="lineNum">    1928 </span>            :   /// \param[in] pvalue             the p value for the p-type norm, ignored for all other norms
<span class="lineNum">    1929 </span>            :   /// \return                       calculated distance
<span class="lineNum">    1930 </span>            : 
<span class="lineNum">    1931 </span>            :   Double_t norm=0.;
<span class="lineNum">    1932 </span>            : 
<span class="lineNum">    1933 </span><span class="lineNoCov">          0 :   switch (normType) {</span>
<span class="lineNum">    1934 </span>            :     case kL1:
<span class="lineNum">    1935 </span><span class="lineNoCov">          0 :       norm=values.Norm1();</span>
<span class="lineNum">    1936 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1937 </span>            :     case kL2:
<span class="lineNum">    1938 </span><span class="lineNoCov">          0 :       norm=TMath::Sqrt(values.Norm2Sqr());</span>
<span class="lineNum">    1939 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1940 </span>            :     case kLp:
<span class="lineNum">    1941 </span>            :     {
<span class="lineNum">    1942 </span><span class="lineNoCov">          0 :       if (pvalue&lt;1.) {</span>
<span class="lineNum">    1943 </span><span class="lineNoCov">          0 :         ::Error(&quot;TStatToolkit::GetDistance&quot;,&quot;Lp norm: p-value=%5.3g not valid. Only p-value&gt;=1 is allowed&quot;, pvalue);</span>
<span class="lineNum">    1944 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1945 </span>            :       }
<span class="lineNum">    1946 </span>            :       Double_t sum=0.;
<span class="lineNum">    1947 </span><span class="lineNoCov">          0 :       for (Int_t ival=0; ival&lt;values.GetNrows(); ++ival) {</span>
<span class="lineNum">    1948 </span><span class="lineNoCov">          0 :         sum+=TMath::Power(TMath::Abs(values.GetMatrixArray()[ival]), pvalue);</span>
<span class="lineNum">    1949 </span>            :       }
<span class="lineNum">    1950 </span><span class="lineNoCov">          0 :       norm=TMath::Power(sum, 1./pvalue);</span>
<span class="lineNum">    1951 </span>            :     }
<span class="lineNum">    1952 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    1953 </span>            :     case kMax:
<span class="lineNum">    1954 </span><span class="lineNoCov">          0 :       norm=values.NormInf();</span>
<span class="lineNum">    1955 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1956 </span>            :     case kHamming:
<span class="lineNum">    1957 </span>            :     {
<span class="lineNum">    1958 </span>            :       Double_t sum=0.;
<span class="lineNum">    1959 </span><span class="lineNoCov">          0 :       for (Int_t ival=0; ival&lt;values.GetNrows(); ++ival) {</span>
<span class="lineNum">    1960 </span><span class="lineNoCov">          0 :         if (TMath::Abs(values.GetMatrixArray()[ival])&gt;1e-30) ++sum;</span>
<span class="lineNum">    1961 </span>            :       }
<span class="lineNum">    1962 </span>            :       norm=sum;
<span class="lineNum">    1963 </span>            :     }
<span class="lineNum">    1964 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    1965 </span>            :   }
<span class="lineNum">    1966 </span><span class="lineNoCov">          0 :   if (normaliseToEntries &amp;&amp; values.GetNrows()&gt;0) {</span>
<span class="lineNum">    1967 </span><span class="lineNoCov">          0 :     norm/=values.GetNrows();</span>
<span class="lineNum">    1968 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1969 </span><span class="lineNoCov">          0 :   return norm;</span>
<span class="lineNum">    1970 </span>            : }
<a name="1971"><span class="lineNum">    1971 </span>            : </a>
<span class="lineNum">    1972 </span>            : //_____________________________________________________________________________
<span class="lineNum">    1973 </span>            : Double_t TStatToolkit::GetDistance(const Int_t size, const Double_t *values, const ENormType normType,
<span class="lineNum">    1974 </span>            :                                    const Bool_t normaliseToEntries/*=kFALSE*/, const Double_t pvalue/*=1*/)
<span class="lineNum">    1975 </span>            : {
<span class="lineNum">    1976 </span>            :   /// Calculate the distance of the elements in values using a certain norm
<span class="lineNum">    1977 </span>            :   /// \sa GetDistance()
<span class="lineNum">    1978 </span><span class="lineNoCov">          0 :   TVectorD vecvalues;</span>
<span class="lineNum">    1979 </span><span class="lineNoCov">          0 :   vecvalues.Use(size, values);</span>
<span class="lineNum">    1980 </span><span class="lineNoCov">          0 :   return GetDistance(vecvalues, normType, normaliseToEntries, pvalue);</span>
<span class="lineNum">    1981 </span><span class="lineNoCov">          0 : }</span>
<a name="1982"><span class="lineNum">    1982 </span>            : </a>
<span class="lineNum">    1983 </span>            : //_____________________________________________________________________________
<span class="lineNum">    1984 </span>            : Double_t TStatToolkit::GetDistance(TTree * tree, const char* var, const char * selection,
<span class="lineNum">    1985 </span>            :                                    const ENormType normType, const Bool_t normaliseToEntries/*=kFALSE*/, const Double_t pvalue/*=1*/)
<span class="lineNum">    1986 </span>            : {
<span class="lineNum">    1987 </span>            :   /// Calculate the distance of the values selecte in tree-&gt;Draw(var, selection)
<span class="lineNum">    1988 </span>            :   ///
<span class="lineNum">    1989 </span>            :   /// If var contains more than one variable (separated by ':' as usual) the arrays
<span class="lineNum">    1990 </span>            :   /// are concatenated:&lt;BR&gt;
<span class="lineNum">    1991 </span>            :   /// E.g. if var=&quot;v1:v2:v3&quot;, then the norm of the
<span class="lineNum">    1992 </span>            :   /// the concatenated array of the values from v1,v2 and v3 will be calculated:&lt;BR&gt;
<span class="lineNum">    1993 </span>            :   /// This means if the internal tree arrays for each variable are v1[0..n], v2[0..n], v3[0..n] then
<span class="lineNum">    1994 </span>            :   /// the norm of vx[0..3n] = [v1, v2, v3] is calculated.
<span class="lineNum">    1995 </span>            :   /// \param[in] tree               input tree
<span class="lineNum">    1996 </span>            :   /// \param[in] var                variable expression for the tree-&gt;Draw()
<span class="lineNum">    1997 </span>            :   /// \param[in] selection          selection for the tree-&gt;Draw()
<span class="lineNum">    1998 </span>            :   /// \param[in] normType           norm to use for calculating the point distances
<span class="lineNum">    1999 </span>            :   /// \param[in] normaliseToEntries divide the norm by the number of eleements ('average norm')
<span class="lineNum">    2000 </span>            :   /// \param[in] pvalue             p-value for the p-norm (ignored for other norm types
<span class="lineNum">    2001 </span>            :   /// \return                       calculated distnace
<span class="lineNum">    2002 </span><span class="lineNoCov">          0 :   Int_t entries = tree-&gt;Draw(var,selection,&quot;goff&quot;);</span>
<span class="lineNum">    2003 </span><span class="lineNoCov">          0 :   if (entries==0) return 0.;</span>
<span class="lineNum">    2004 </span>            : 
<span class="lineNum">    2005 </span><span class="lineNoCov">          0 :   TVectorD values;</span>
<span class="lineNum">    2006 </span><span class="lineNoCov">          0 :   CombineArray(tree, values);</span>
<span class="lineNum">    2007 </span><span class="lineNoCov">          0 :   return GetDistance(values, normType, normaliseToEntries, pvalue);</span>
<span class="lineNum">    2008 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2009 </span>            : 
<a name="2010"><span class="lineNum">    2010 </span>            : </a>
<span class="lineNum">    2011 </span>            : 
<span class="lineNum">    2012 </span>            : void TStatToolkit::MakeDistortionMap(Int_t iter, THnBase * histo, TTreeSRedirector *pcstream, TMatrixD &amp;projectionInfo,Int_t dumpHisto, Int_t verbose){
<span class="lineNum">    2013 </span>            :   //
<span class="lineNum">    2014 </span>            :   // Recursive function to calculate Distortion maps from the residual histograms
<span class="lineNum">    2015 </span>            :   // Input:
<span class="lineNum">    2016 </span>            :   //   iter     - ndim..0
<span class="lineNum">    2017 </span>            :   //   histo    - THn histogram
<span class="lineNum">    2018 </span>            :   //   pcstream -
<span class="lineNum">    2019 </span>            :   //   projectionInfo  - TMatrix speicifiing distortion map cration setup
<span class="lineNum">    2020 </span>            :   //     user specify columns:
<span class="lineNum">    2021 </span>            :   //       0.) sequence of dimensions 
<span class="lineNum">    2022 </span>            :   //       1.) grouping in dimensions (how many bins will be groupd in specific dimension - 0 means onl specified bin 1, curren +-1 bin ...)
<span class="lineNum">    2023 </span>            :   //       2.) step in dimension ( in case &gt;1 some n(projectionInfo(&lt;dim&gt;,2) bins will be not exported
<span class="lineNum">    2024 </span>            :   //     internally used collumns (needed to pass current bin index and bin center to the recursive function) 
<span class="lineNum">    2025 </span>            :   //       3.) current bin value  
<span class="lineNum">    2026 </span>            :   //       4.) current bin center
<span class="lineNum">    2027 </span>            :   //
<span class="lineNum">    2028 </span>            :   //  Output:
<span class="lineNum">    2029 </span>            :   //   pcstream - file with output distortion tree
<span class="lineNum">    2030 </span>            :   //    1.) distortion characteristic: mean, rms, gaussian fit parameters, meang, rmsG chi2 ... at speciefied bin 
<span class="lineNum">    2031 </span>            :   //    2.) specidfied bins (tree branches) are defined by the name of the histogram axis in input histograms
<span class="lineNum">    2032 </span>            :   //  
<span class="lineNum">    2033 </span>            :   //    
<span class="lineNum">    2034 </span>            :   //   Example projection info
<span class="lineNum">    2035 </span>            :   /*
<span class="lineNum">    2036 </span>            :     TFile *f  = TFile::Open(&quot;/hera/alice/hellbaer/alice-tpc-notes/SpaceChargeDistortion/data/ATO-108/fullMerge/SCcalibMergeLHC12d.root&quot;);
<span class="lineNum">    2037 </span>            :     THnF* histof= (THnF*) f-&gt;Get(&quot;deltaY_ClTPC_ITSTOF&quot;);
<span class="lineNum">    2038 </span>            :     histof-&gt;SetName(&quot;deltaRPhiTPCTISTOF&quot;);
<span class="lineNum">    2039 </span>            :     histof-&gt;GetAxis(4)-&gt;SetName(&quot;qpt&quot;);
<span class="lineNum">    2040 </span>            :     TH1::SetDirectory(0);
<span class="lineNum">    2041 </span>            :     TTreeSRedirector * pcstream = new TTreeSRedirector(&quot;distortion.root&quot;,&quot;recreate&quot;);
<span class="lineNum">    2042 </span>            :     TMatrixD projectionInfo(5,5);
<span class="lineNum">    2043 </span>            :     projectionInfo(0,0)=0;  projectionInfo(0,1)=0;  projectionInfo(0,2)=0;
<span class="lineNum">    2044 </span>            :     projectionInfo(1,0)=4;  projectionInfo(1,1)=0;  projectionInfo(1,2)=1; 
<span class="lineNum">    2045 </span>            :     projectionInfo(2,0)=3;  projectionInfo(2,1)=3;  projectionInfo(2,2)=2;
<span class="lineNum">    2046 </span>            :     projectionInfo(3,0)=2;  projectionInfo(3,1)=0;  projectionInfo(3,2)=5;
<span class="lineNum">    2047 </span>            :     projectionInfo(4,0)=1;  projectionInfo(4,1)=5;  projectionInfo(4,2)=20;
<span class="lineNum">    2048 </span>            :     MakeDistortionMap(4, histof, pcstream, projectionInfo); 
<span class="lineNum">    2049 </span>            :     delete pcstream;
<span class="lineNum">    2050 </span>            :   */
<span class="lineNum">    2051 </span>            :   //
<span class="lineNum">    2052 </span><span class="lineNoCov">          0 :   static TF1 fgaus(&quot;fgaus&quot;,&quot;gaus&quot;,-10,10);</span>
<span class="lineNum">    2053 </span>            :   const Double_t kMinEntries=50;
<span class="lineNum">    2054 </span><span class="lineNoCov">          0 :   Int_t ndim=histo-&gt;GetNdimensions();</span>
<span class="lineNum">    2055 </span><span class="lineNoCov">          0 :   Int_t axis[ndim];</span>
<span class="lineNum">    2056 </span><span class="lineNoCov">          0 :   Double_t meanVector[ndim];</span>
<span class="lineNum">    2057 </span><span class="lineNoCov">          0 :   Int_t binVector[ndim];</span>
<span class="lineNum">    2058 </span><span class="lineNoCov">          0 :   Double_t centerVector[ndim];</span>
<span class="lineNum">    2059 </span><span class="lineNoCov">          0 :   for (Int_t idim=0; idim&lt;ndim; idim++) axis[idim]=idim;</span>
<span class="lineNum">    2060 </span>            :   //
<span class="lineNum">    2061 </span><span class="lineNoCov">          0 :   if (iter==0){</span>
<span class="lineNum">    2062 </span><span class="lineNoCov">          0 :     char tname[100];</span>
<span class="lineNum">    2063 </span><span class="lineNoCov">          0 :     char aname[100];</span>
<span class="lineNum">    2064 </span><span class="lineNoCov">          0 :     char bname[100];</span>
<span class="lineNum">    2065 </span><span class="lineNoCov">          0 :     char cname[100];</span>
<span class="lineNum">    2066 </span>            :     
<span class="lineNum">    2067 </span><span class="lineNoCov">          0 :     snprintf(tname, 100, &quot;%sDist&quot;,histo-&gt;GetName());</span>
<span class="lineNum">    2068 </span>            :     //
<span class="lineNum">    2069 </span>            :     //
<span class="lineNum">    2070 </span>            :     // 1.) Calculate  properties   - mean, rms, gaus fit, chi2, entries
<span class="lineNum">    2071 </span>            :     // 2.) Dump properties to tree 1D properties  - plus dimension descriptor f
<span class="lineNum">    2072 </span>            :     Int_t axis1D[1]={0};
<span class="lineNum">    2073 </span><span class="lineNoCov">          0 :     Int_t dimProject   = TMath::Nint(projectionInfo(iter,0));</span>
<span class="lineNum">    2074 </span>            :     axis1D[0]=dimProject;
<span class="lineNum">    2075 </span><span class="lineNoCov">          0 :     TH1 *his1DFull = histo-&gt;Projection(dimProject);</span>
<span class="lineNum">    2076 </span><span class="lineNoCov">          0 :     Double_t mean= his1DFull-&gt;GetMean();</span>
<span class="lineNum">    2077 </span><span class="lineNoCov">          0 :     Double_t rms= his1DFull-&gt;GetRMS();</span>
<span class="lineNum">    2078 </span><span class="lineNoCov">          0 :     Int_t entries=  his1DFull-&gt;GetEntries();</span>
<span class="lineNum">    2079 </span><span class="lineNoCov">          0 :     TString hname=&quot;his_&quot;;</span>
<span class="lineNum">    2080 </span><span class="lineNoCov">          0 :     for (Int_t idim=0; idim&lt;ndim; idim++) {hname+=&quot;_&quot;; hname+=TMath::Nint(projectionInfo(idim,3));}</span>
<span class="lineNum">    2081 </span><span class="lineNoCov">          0 :     Double_t meanG=0, rmsG=0, chi2G=0;</span>
<span class="lineNum">    2082 </span><span class="lineNoCov">          0 :     if (entries&gt;kMinEntries){</span>
<span class="lineNum">    2083 </span><span class="lineNoCov">          0 :       fgaus.SetParameters(entries,mean,rms);</span>
<span class="lineNum">    2084 </span><span class="lineNoCov">          0 :       his1DFull-&gt;Fit(&amp;fgaus,&quot;qnr&quot;,&quot;qnr&quot;);</span>
<span class="lineNum">    2085 </span><span class="lineNoCov">          0 :       meanG = fgaus.GetParameter(1);</span>
<span class="lineNum">    2086 </span><span class="lineNoCov">          0 :       rmsG = fgaus.GetParameter(2);</span>
<span class="lineNum">    2087 </span><span class="lineNoCov">          0 :       chi2G = fgaus.GetChisquare()/fgaus.GetNumberFreeParameters();</span>
<span class="lineNum">    2088 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2089 </span><span class="lineNoCov">          0 :     if (dumpHisto&gt;=0) {</span>
<span class="lineNum">    2090 </span>            :       static Int_t histoCounter=0;
<span class="lineNum">    2091 </span><span class="lineNoCov">          0 :       if ((histoCounter%dumpHisto)==0) his1DFull-&gt;Write(hname.Data());</span>
<span class="lineNum">    2092 </span><span class="lineNoCov">          0 :       histoCounter++;</span>
<span class="lineNum">    2093 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2094 </span><span class="lineNoCov">          0 :     delete his1DFull;</span>
<span class="lineNum">    2095 </span><span class="lineNoCov">          0 :     (*pcstream)&lt;&lt;tname&lt;&lt;</span>
<span class="lineNum">    2096 </span><span class="lineNoCov">          0 :     &quot;entries=&quot;&lt;&lt;entries&lt;&lt; // number of entries</span>
<span class="lineNum">    2097 </span><span class="lineNoCov">          0 :     &quot;mean=&quot;&lt;&lt;mean&lt;&lt;       // mean value of the last dimension</span>
<span class="lineNum">    2098 </span><span class="lineNoCov">          0 :     &quot;rms=&quot;&lt;&lt;rms&lt;&lt;         // rms value of the last dimension</span>
<span class="lineNum">    2099 </span><span class="lineNoCov">          0 :     &quot;meanG=&quot;&lt;&lt;meanG&lt;&lt;     // mean of the gaus fit</span>
<span class="lineNum">    2100 </span><span class="lineNoCov">          0 :     &quot;rmsG=&quot;&lt;&lt;rmsG&lt;&lt;       // rms of the gaus fit</span>
<span class="lineNum">    2101 </span><span class="lineNoCov">          0 :     &quot;chi2G=&quot;&lt;&lt;chi2G;      // chi2 of the gaus fit</span>
<span class="lineNum">    2102 </span>            :     
<span class="lineNum">    2103 </span><span class="lineNoCov">          0 :     for (Int_t idim=0; idim&lt;ndim; idim++){</span>
<span class="lineNum">    2104 </span>            :       axis1D[0]=idim;
<span class="lineNum">    2105 </span><span class="lineNoCov">          0 :       TH1 *his1DAxis = histo-&gt;Projection(idim);</span>
<span class="lineNum">    2106 </span><span class="lineNoCov">          0 :       meanVector[idim] = his1DAxis-&gt;GetMean();</span>
<span class="lineNum">    2107 </span><span class="lineNoCov">          0 :       snprintf(aname, 100, &quot;%sMean=&quot;,histo-&gt;GetAxis(idim)-&gt;GetName());</span>
<span class="lineNum">    2108 </span><span class="lineNoCov">          0 :       (*pcstream)&lt;&lt;tname&lt;&lt;</span>
<span class="lineNum">    2109 </span><span class="lineNoCov">          0 :       aname&lt;&lt;meanVector[idim];      // current bin means</span>
<span class="lineNum">    2110 </span><span class="lineNoCov">          0 :       delete his1DAxis;</span>
<span class="lineNum">    2111 </span>            :     }
<span class="lineNum">    2112 </span><span class="lineNoCov">          0 :     for (Int_t iIter=0; iIter&lt;ndim; iIter++){</span>
<span class="lineNum">    2113 </span><span class="lineNoCov">          0 :       Int_t idim = TMath::Nint(projectionInfo(iIter,0));</span>
<span class="lineNum">    2114 </span><span class="lineNoCov">          0 :       binVector[idim] = TMath::Nint(projectionInfo(iIter,3));</span>
<span class="lineNum">    2115 </span><span class="lineNoCov">          0 :       centerVector[idim] = projectionInfo(iIter,4);</span>
<span class="lineNum">    2116 </span><span class="lineNoCov">          0 :       snprintf(bname, 100, &quot;%sBin=&quot;,histo-&gt;GetAxis(idim)-&gt;GetName());</span>
<span class="lineNum">    2117 </span><span class="lineNoCov">          0 :       snprintf(cname, 100, &quot;%sCenter=&quot;,histo-&gt;GetAxis(idim)-&gt;GetName());</span>
<span class="lineNum">    2118 </span><span class="lineNoCov">          0 :       (*pcstream)&lt;&lt;tname&lt;&lt;</span>
<span class="lineNum">    2119 </span><span class="lineNoCov">          0 :       bname&lt;&lt;binVector[idim]&lt;&lt;      // current bin values</span>
<span class="lineNum">    2120 </span><span class="lineNoCov">          0 :       cname&lt;&lt;centerVector[idim];    // current bin centers</span>
<span class="lineNum">    2121 </span>            :     }
<span class="lineNum">    2122 </span><span class="lineNoCov">          0 :     (*pcstream)&lt;&lt;tname&lt;&lt;&quot;\n&quot;;</span>
<span class="lineNum">    2123 </span><span class="lineNoCov">          0 :   }else{</span>
<span class="lineNum">    2124 </span>            :     // loop over the diminsion of interest
<span class="lineNum">    2125 </span>            :     //      project selecting bin+-deltabin histoProj
<span class="lineNum">    2126 </span>            :     //      MakeDistortionMap(histoProj ...) 
<span class="lineNum">    2127 </span>            :     //
<span class="lineNum">    2128 </span><span class="lineNoCov">          0 :     Int_t dimProject   = TMath::Nint(projectionInfo(iter,0));</span>
<span class="lineNum">    2129 </span><span class="lineNoCov">          0 :     Int_t groupProject =  TMath::Nint(projectionInfo(iter,1));</span>
<span class="lineNum">    2130 </span><span class="lineNoCov">          0 :     Int_t stepProject =  TMath::Nint(projectionInfo(iter,2));</span>
<span class="lineNum">    2131 </span><span class="lineNoCov">          0 :     if (stepProject&lt;1) stepProject=1;</span>
<span class="lineNum">    2132 </span><span class="lineNoCov">          0 :     Int_t nbins = histo-&gt;GetAxis(dimProject)-&gt;GetNbins();</span>
<span class="lineNum">    2133 </span>            :     
<span class="lineNum">    2134 </span><span class="lineNoCov">          0 :     for (Int_t ibin=1; ibin&lt;=nbins; ibin+=stepProject){</span>
<span class="lineNum">    2135 </span><span class="lineNoCov">          0 :       if (iter&gt;1 &amp;&amp; verbose){</span>
<span class="lineNum">    2136 </span><span class="lineNoCov">          0 :         for (Int_t idim=0; idim&lt;ndim; idim++){</span>
<span class="lineNum">    2137 </span><span class="lineNoCov">          0 :           printf(&quot;\t%d(%d,%d)&quot;,TMath::Nint(projectionInfo(idim,3)),TMath::Nint(projectionInfo(idim,0)),TMath::Nint(projectionInfo(idim,1) ));</span>
<span class="lineNum">    2138 </span>            :         }
<span class="lineNum">    2139 </span><span class="lineNoCov">          0 :         printf(&quot;\n&quot;);     </span>
<span class="lineNum">    2140 </span><span class="lineNoCov">          0 :         AliSysInfo::AddStamp(&quot;xxx&quot;,iter, dimProject);</span>
<span class="lineNum">    2141 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    2142 </span><span class="lineNoCov">          0 :       Int_t bin0=TMath::Max(ibin-groupProject,1);</span>
<span class="lineNum">    2143 </span><span class="lineNoCov">          0 :       Int_t bin1=TMath::Min(ibin+groupProject,nbins);</span>
<span class="lineNum">    2144 </span><span class="lineNoCov">          0 :       histo-&gt;GetAxis(dimProject)-&gt;SetRange(bin0,bin1);</span>
<span class="lineNum">    2145 </span><span class="lineNoCov">          0 :       projectionInfo(iter,3)=ibin;</span>
<span class="lineNum">    2146 </span><span class="lineNoCov">          0 :       projectionInfo(iter,4)=histo-&gt;GetAxis(dimProject)-&gt;GetBinCenter(ibin);</span>
<span class="lineNum">    2147 </span><span class="lineNoCov">          0 :       Int_t iterProject=iter-1;</span>
<span class="lineNum">    2148 </span><span class="lineNoCov">          0 :       MakeDistortionMap(iterProject, histo, pcstream, projectionInfo);</span>
<span class="lineNum">    2149 </span>            :     }
<span class="lineNum">    2150 </span>            :   }
<span class="lineNum">    2151 </span>            :   //
<a name="2152"><span class="lineNum">    2152 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    2153 </span>            : 
<span class="lineNum">    2154 </span>            : void TStatToolkit::MakeDistortionMapFast(THnBase * histo, TTreeSRedirector *pcstream, TMatrixD &amp;projectionInfo,Int_t verbose,  Double_t fractionCut, const char * estimators)
<span class="lineNum">    2155 </span>            : {
<span class="lineNum">    2156 </span>            :   //
<span class="lineNum">    2157 </span>            :   // Function to calculate Distortion maps from the residual histograms
<span class="lineNum">    2158 </span>            :   // Input:
<span class="lineNum">    2159 </span>            :   //   histo    - THn histogram
<span class="lineNum">    2160 </span>            :   //   pcstream -
<span class="lineNum">    2161 </span>            :   //   projectionInfo  - TMatrix speicifiing distortion map cration setup
<span class="lineNum">    2162 </span>            :   //     user specify columns:
<span class="lineNum">    2163 </span>            :   //       0.) sequence of dimensions 
<span class="lineNum">    2164 </span>            :   //       1.) grouping in dimensions (how many bins will be groupd in specific dimension - 0 means onl specified bin 1, curren +-1 bin ...)
<span class="lineNum">    2165 </span>            :   //       2.) step in dimension ( in case &gt;1 some n(projectionInfo(&lt;dim&gt;,2) bins will be not exported
<span class="lineNum">    2166 </span>            :   //
<span class="lineNum">    2167 </span>            :   //  Output:
<span class="lineNum">    2168 </span>            :   //   pcstream - file with output distortion tree
<span class="lineNum">    2169 </span>            :   //    1.) distortion characteristic: mean, rms, gaussian fit parameters, meang, rmsG chi2 ... at speciefied bin 
<span class="lineNum">    2170 </span>            :   //    2.) specidfied bins (tree branches) are defined by the name of the histogram axis in input histograms
<span class="lineNum">    2171 </span>            :   //    3.) in debug mode - controlled by env variable &quot;gDumpHistoFraction&quot; fractio of histogram + fits dumped to the file 
<span class="lineNum">    2172 </span>            :   //    
<span class="lineNum">    2173 </span>            :   //   Example projection info
<span class="lineNum">    2174 </span>            :   /*
<span class="lineNum">    2175 </span>            :     TFile *f  = TFile::Open(&quot;/hera/alice/hellbaer/alice-tpc-notes/SpaceChargeDistortion/data/ATO-108/fullMerge/SCcalibMergeLHC12d.root&quot;);
<span class="lineNum">    2176 </span>            :     THnF* histof= (THnF*) f-&gt;Get(&quot;deltaY_ClTPC_ITSTOF&quot;);
<span class="lineNum">    2177 </span>            :     histof-&gt;SetName(&quot;deltaRPhiTPCTISTOF&quot;);
<span class="lineNum">    2178 </span>            :     histof-&gt;GetAxis(4)-&gt;SetName(&quot;qpt&quot;);
<span class="lineNum">    2179 </span>            :     TH1::SetDirectory(0);
<span class="lineNum">    2180 </span>            :     TTreeSRedirector * pcstream = new TTreeSRedirector(&quot;distortion.root&quot;,&quot;recreate&quot;);
<span class="lineNum">    2181 </span>            :     TMatrixD projectionInfo(5,3);
<span class="lineNum">    2182 </span>            :     projectionInfo(0,0)=0;  projectionInfo(0,1)=0;  projectionInfo(0,2)=0;
<span class="lineNum">    2183 </span>            :     projectionInfo(1,0)=4;  projectionInfo(1,1)=0;  projectionInfo(1,2)=1; 
<span class="lineNum">    2184 </span>            :     projectionInfo(2,0)=3;  projectionInfo(2,1)=3;  projectionInfo(2,2)=2;
<span class="lineNum">    2185 </span>            :     projectionInfo(3,0)=2;  projectionInfo(3,1)=0;  projectionInfo(3,2)=5;
<span class="lineNum">    2186 </span>            :     projectionInfo(4,0)=1;  projectionInfo(4,1)=5;  projectionInfo(4,2)=20;
<span class="lineNum">    2187 </span>            :     MakeDistortionMap(histof, pcstream, projectionInfo); 
<span class="lineNum">    2188 </span>            :     delete pcstream;
<span class="lineNum">    2189 </span>            :   */
<span class="lineNum">    2190 </span>            :   //
<span class="lineNum">    2191 </span>            :   const Double_t kMinEntries=30, kUseLLFrom=20;
<span class="lineNum">    2192 </span><span class="lineNoCov">          0 :   const Float_t  kDumpHistoFraction = TString(gSystem-&gt;Getenv(&quot;gDumpHistoFraction&quot;)).Atof();  // in debug mode - controlled by env variable &quot;gDumpHistoFraction&quot; fractio of histogram + fits dumped to the file </span>
<span class="lineNum">    2193 </span><span class="lineNoCov">          0 :   char tname[100];</span>
<span class="lineNum">    2194 </span><span class="lineNoCov">          0 :   char aname[100];</span>
<span class="lineNum">    2195 </span><span class="lineNoCov">          0 :   char bname[100];</span>
<span class="lineNum">    2196 </span><span class="lineNoCov">          0 :   char cname[100];</span>
<span class="lineNum">    2197 </span><span class="lineNoCov">          0 :   Float_t fractionLTM[100]={0.8};</span>
<span class="lineNum">    2198 </span><span class="lineNoCov">          0 :   TVectorF *vecLTM[100]={0};</span>
<span class="lineNum">    2199 </span>            :   Int_t nestimators=1;
<span class="lineNum">    2200 </span><span class="lineNoCov">          0 :   if (estimators!=NULL){</span>
<span class="lineNum">    2201 </span><span class="lineNoCov">          0 :     TObjArray * array=TString(estimators).Tokenize(&quot;:&quot;);</span>
<span class="lineNum">    2202 </span><span class="lineNoCov">          0 :     nestimators=array-&gt;GetEntries();</span>
<span class="lineNum">    2203 </span><span class="lineNoCov">          0 :     for (Int_t iest=0; iest&lt;nestimators; iest++){</span>
<span class="lineNum">    2204 </span><span class="lineNoCov">          0 :       fractionLTM[iest]=TString(array-&gt;At(iest)-&gt;GetName()).Atof();</span>
<span class="lineNum">    2205 </span>            :     }
<span class="lineNum">    2206 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2207 </span><span class="lineNoCov">          0 :   for (Int_t iest=0; iest&lt;nestimators; iest++) {</span>
<span class="lineNum">    2208 </span><span class="lineNoCov">          0 :     vecLTM[iest]=new TVectorF(10);</span>
<span class="lineNum">    2209 </span><span class="lineNoCov">          0 :     (*(vecLTM[iest]))[9]= fractionLTM[iest];</span>
<span class="lineNum">    2210 </span>            :   }
<span class="lineNum">    2211 </span>            : 
<span class="lineNum">    2212 </span>            :   //
<span class="lineNum">    2213 </span><span class="lineNoCov">          0 :   int ndim = histo-&gt;GetNdimensions();</span>
<span class="lineNum">    2214 </span><span class="lineNoCov">          0 :   int nbins[ndim],idx[ndim],idxmin[ndim],idxmax[ndim],idxSav[ndim];</span>
<span class="lineNum">    2215 </span><span class="lineNoCov">          0 :   for (int id=0;id&lt;ndim;id++) nbins[id] = histo-&gt;GetAxis(id)-&gt;GetNbins();</span>
<span class="lineNum">    2216 </span>            :   //
<span class="lineNum">    2217 </span><span class="lineNoCov">          0 :   int axOrd[ndim],binSt[ndim],binGr[ndim];</span>
<span class="lineNum">    2218 </span><span class="lineNoCov">          0 :   for (int i=0;i&lt;ndim;i++) {</span>
<span class="lineNum">    2219 </span><span class="lineNoCov">          0 :     axOrd[i] = TMath::Nint(projectionInfo(i,0));</span>
<span class="lineNum">    2220 </span><span class="lineNoCov">          0 :     binGr[i] = TMath::Nint(projectionInfo(i,1));</span>
<span class="lineNum">    2221 </span><span class="lineNoCov">          0 :     binSt[i] = TMath::Max(1,TMath::Nint(projectionInfo(i,2)));</span>
<span class="lineNum">    2222 </span>            :   }
<span class="lineNum">    2223 </span><span class="lineNoCov">          0 :   int tgtDim = axOrd[0],tgtStep=binSt[0],tgtNb=nbins[tgtDim],tgtNb1=tgtNb+1;</span>
<span class="lineNum">    2224 </span><span class="lineNoCov">          0 :   double binY[tgtNb],binX[tgtNb],meanVector[ndim],centerVector[ndim];</span>
<span class="lineNum">    2225 </span><span class="lineNoCov">          0 :   Int_t binVector[ndim];</span>
<span class="lineNum">    2226 </span>            :   // prepare X axis
<span class="lineNum">    2227 </span><span class="lineNoCov">          0 :   TAxis* xax = histo-&gt;GetAxis(tgtDim);</span>
<span class="lineNum">    2228 </span><span class="lineNoCov">          0 :   for (int i=tgtNb;i--;) binX[i] = xax-&gt;GetBinCenter(i+1);</span>
<span class="lineNum">    2229 </span><span class="lineNoCov">          0 :   for (int i=ndim;i--;) idx[i]=1;</span>
<span class="lineNum">    2230 </span>            :   Bool_t grpOn = kFALSE;
<span class="lineNum">    2231 </span><span class="lineNoCov">          0 :   for (int i=1;i&lt;ndim;i++) if (binGr[i]) grpOn = kTRUE;</span>
<span class="lineNum">    2232 </span>            :   //
<span class="lineNum">    2233 </span>            :   // estimate number of output fits
<span class="lineNum">    2234 </span><span class="lineNoCov">          0 :   histo-&gt;GetListOfAxes()-&gt;Print();</span>
<span class="lineNum">    2235 </span>            :   ULong64_t nfits = 1, fitCount=0;
<span class="lineNum">    2236 </span><span class="lineNoCov">          0 :   printf(&quot;index\tdim\t|\tnbins\tgrouping\tstep\tnfits\n&quot;);</span>
<span class="lineNum">    2237 </span><span class="lineNoCov">          0 :   for (int i=1;i&lt;ndim;i++) {</span>
<span class="lineNum">    2238 </span><span class="lineNoCov">          0 :     int idim = axOrd[i];</span>
<span class="lineNum">    2239 </span><span class="lineNoCov">          0 :     nfits *= TMath::Max(1,nbins[idim]/binSt[idim]);</span>
<span class="lineNum">    2240 </span><span class="lineNoCov">          0 :     printf(&quot;%d %d | %d %d %d %lld\n&quot;,i,idim,nbins[idim],binGr[idim], binSt[idim],nfits);</span>
<span class="lineNum">    2241 </span>            :   }
<span class="lineNum">    2242 </span><span class="lineNoCov">          0 :   printf(&quot;Expect %lld nfits\n&quot;,nfits);</span>
<span class="lineNum">    2243 </span><span class="lineNoCov">          0 :   ULong64_t fitProgress = nfits/100;</span>
<span class="lineNum">    2244 </span>            :   //
<span class="lineNum">    2245 </span>            :   // setup fit function, at the moment full root fit
<span class="lineNum">    2246 </span><span class="lineNoCov">          0 :   static TF1 fgaus(&quot;fgaus&quot;,&quot;gaus&quot;,-10,10);</span>
<span class="lineNum">    2247 </span><span class="lineNoCov">          0 :   fgaus.SetRange(xax-&gt;GetXmin(),xax-&gt;GetXmax());</span>
<span class="lineNum">    2248 </span>            :   //  TGraph grafFit(tgtNb);
<span class="lineNum">    2249 </span><span class="lineNoCov">          0 :   TH1F* hfit = new TH1F(&quot;hfit&quot;,&quot;hfit&quot;,tgtNb,xax-&gt;GetXmin(),xax-&gt;GetXmax());</span>
<span class="lineNum">    2250 </span>            :   //
<span class="lineNum">    2251 </span><span class="lineNoCov">          0 :   snprintf(tname, 100, &quot;%sDist&quot;,histo-&gt;GetName());</span>
<span class="lineNum">    2252 </span><span class="lineNoCov">          0 :   TStopwatch sw;</span>
<span class="lineNum">    2253 </span><span class="lineNoCov">          0 :   sw.Start();</span>
<span class="lineNum">    2254 </span><span class="lineNoCov">          0 :   int dimVar=1, dimVarID = axOrd[dimVar];</span>
<span class="lineNum">    2255 </span>            :   //
<span class="lineNum">    2256 </span>            :   //  TVectorF  vecLTM(9);
<span class="lineNum">    2257 </span><span class="lineNoCov">          0 :   while(1) {</span>
<span class="lineNum">    2258 </span>            :     //
<span class="lineNum">    2259 </span><span class="lineNoCov">          0 :     double dimVarCen = histo-&gt;GetAxis(dimVarID)-&gt;GetBinCenter(idx[dimVarID]); // center of currently varied bin</span>
<span class="lineNum">    2260 </span>            :     //
<span class="lineNum">    2261 </span><span class="lineNoCov">          0 :     if (grpOn) { //&gt;&gt; grouping requested?</span>
<span class="lineNum">    2262 </span><span class="lineNoCov">          0 :       memset(binY,0,tgtNb*sizeof(double)); // need to accumulate</span>
<span class="lineNum">    2263 </span>            :       //
<span class="lineNum">    2264 </span><span class="lineNoCov">          0 :       for (int idim=1;idim&lt;ndim;idim++) {</span>
<span class="lineNum">    2265 </span><span class="lineNoCov">          0 :         int grp = binGr[idim];</span>
<span class="lineNum">    2266 </span><span class="lineNoCov">          0 :         int idimR = axOrd[idim]; // real axis id</span>
<span class="lineNum">    2267 </span><span class="lineNoCov">          0 :         idxSav[idimR]=idx[idimR]; // save central bins</span>
<span class="lineNum">    2268 </span><span class="lineNoCov">          0 :         idxmax[idimR] = TMath::Min(idx[idimR]+grp,nbins[idimR]);</span>
<span class="lineNum">    2269 </span><span class="lineNoCov">          0 :         idx[idimR] = idxmin[idimR] = TMath::Max(1,idx[idimR]-grp);</span>
<span class="lineNum">    2270 </span>            :         // 
<span class="lineNum">    2271 </span>            :         // effective bin center
<span class="lineNum">    2272 </span><span class="lineNoCov">          0 :         meanVector[idimR] = 0;</span>
<span class="lineNum">    2273 </span><span class="lineNoCov">          0 :         TAxis* ax = histo-&gt;GetAxis(idimR);</span>
<span class="lineNum">    2274 </span><span class="lineNoCov">          0 :         if (grp&gt;0) {</span>
<span class="lineNum">    2275 </span><span class="lineNoCov">          0 :           for (int k=idxmin[idimR];k&lt;=idxmax[idimR];k++) meanVector[idimR] += ax-&gt;GetBinCenter(k);</span>
<span class="lineNum">    2276 </span><span class="lineNoCov">          0 :           meanVector[idimR] /= (1+(grp&lt;&lt;1));</span>
<span class="lineNum">    2277 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2278 </span><span class="lineNoCov">          0 :         else meanVector[idimR] = ax-&gt;GetBinCenter(idxSav[idimR]);</span>
<span class="lineNum">    2279 </span>            :       } // set limits for grouping
<span class="lineNum">    2280 </span><span class="lineNoCov">          0 :       if (verbose&gt;0) {</span>
<span class="lineNum">    2281 </span><span class="lineNoCov">          0 :         printf(&quot;output bin: &quot;); </span>
<span class="lineNum">    2282 </span><span class="lineNoCov">          0 :         for (int i=0;i&lt;ndim;i++) if (i!=tgtDim) printf(&quot;[D:%d]:%d &quot;,i,idxSav[i]); printf(&quot;\n&quot;);</span>
<span class="lineNum">    2283 </span><span class="lineNoCov">          0 :         printf(&quot;integrates: &quot;);</span>
<span class="lineNum">    2284 </span><span class="lineNoCov">          0 :         for (int i=0;i&lt;ndim;i++) if (i!=tgtDim) printf(&quot;[D:%d]:%d-%d &quot;,i,idxmin[i],idxmax[i]); printf(&quot;\n&quot;);</span>
<span class="lineNum">    2285 </span>            :       }
<span class="lineNum">    2286 </span>            :       //
<span class="lineNum">    2287 </span>            :       while(1) {
<span class="lineNum">    2288 </span>            :         // loop over target dimension: accumulation
<span class="lineNum">    2289 </span><span class="lineNoCov">          0 :         int &amp;it = idx[tgtDim];</span>
<span class="lineNum">    2290 </span><span class="lineNoCov">          0 :         for (it=1;it&lt;tgtNb1;it+=tgtStep) {</span>
<span class="lineNum">    2291 </span><span class="lineNoCov">          0 :           binY[it-1] += histo-&gt;GetBinContent(idx);</span>
<span class="lineNum">    2292 </span><span class="lineNoCov">          0 :           if (verbose&gt;1) {for (int i=0;i&lt;ndim;i++) printf(&quot;%d &quot;,idx[i]); printf(&quot; | accumulation\n&quot;);}</span>
<span class="lineNum">    2293 </span>            :         }
<span class="lineNum">    2294 </span>            :         //
<span class="lineNum">    2295 </span>            :         int idim;
<span class="lineNum">    2296 </span><span class="lineNoCov">          0 :         for (idim=1;idim&lt;ndim;idim++) { // dimension being groupped</span>
<span class="lineNum">    2297 </span><span class="lineNoCov">          0 :           int idimR = axOrd[idim]; // real axis id in the histo</span>
<span class="lineNum">    2298 </span><span class="lineNoCov">          0 :           if ( (++idx[idimR]) &gt; idxmax[idimR] ) idx[idimR]=idxmin[idimR];</span>
<span class="lineNum">    2299 </span><span class="lineNoCov">          0 :           else break;</span>
<span class="lineNum">    2300 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2301 </span><span class="lineNoCov">          0 :         if (idim==ndim) break;</span>
<span class="lineNum">    2302 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    2303 </span>            :     } // &lt;&lt;grouping requested
<span class="lineNum">    2304 </span>            :     else {
<span class="lineNum">    2305 </span><span class="lineNoCov">          0 :       int &amp;it = idx[tgtDim];</span>
<span class="lineNum">    2306 </span><span class="lineNoCov">          0 :       for (it=1;it&lt;tgtNb1;it+=tgtStep) {</span>
<span class="lineNum">    2307 </span><span class="lineNoCov">          0 :         binY[it-1] = histo-&gt;GetBinContent(idx);</span>
<span class="lineNum">    2308 </span>            :         //
<span class="lineNum">    2309 </span>            :         //for (int i=0;i&lt;ndim;i++) printf(&quot;%d &quot;,idx[i]); printf(&quot; | \n&quot;);
<span class="lineNum">    2310 </span>            :       }
<span class="lineNum">    2311 </span><span class="lineNoCov">          0 :       for (int idim=1;idim&lt;ndim;idim++) {</span>
<span class="lineNum">    2312 </span><span class="lineNoCov">          0 :         int idimR = axOrd[idim]; // real axis id</span>
<span class="lineNum">    2313 </span><span class="lineNoCov">          0 :         meanVector[idimR] = histo-&gt;GetAxis(idimR)-&gt;GetBinCenter(idx[idimR]);</span>
<span class="lineNum">    2314 </span>            :       }
<span class="lineNum">    2315 </span>            :     }
<span class="lineNum">    2316 </span><span class="lineNoCov">          0 :     if (grpOn) for (int i=ndim;i--;) idx[i]=idxSav[i]; // restore central bins</span>
<span class="lineNum">    2317 </span><span class="lineNoCov">          0 :     idx[tgtDim] = 0;</span>
<span class="lineNum">    2318 </span><span class="lineNoCov">          0 :     if (verbose&gt;0) {for (int i=0;i&lt;ndim;i++) printf(&quot;%d &quot;,idx[i]); printf(&quot; | central bin fit\n&quot;);}</span>
<span class="lineNum">    2319 </span>            :     // 
<span class="lineNum">    2320 </span>            :     // &gt;&gt; ------------- do fit
<span class="lineNum">    2321 </span><span class="lineNoCov">          0 :     float mean=0,mom2=0,rms=0,m3=0, m4=0, nrm=0,meanG=0,rmsG=0,chi2G=0,maxVal=0,entriesG=0,mean0=0, rms0=0, curt0=0;</span>
<span class="lineNum">    2322 </span><span class="lineNoCov">          0 :     hfit-&gt;Reset();</span>
<span class="lineNum">    2323 </span><span class="lineNoCov">          0 :     for (int ip=tgtNb;ip--;) {</span>
<span class="lineNum">    2324 </span>            :       //grafFit.SetPoint(ip,binX[ip],binY[ip]);
<span class="lineNum">    2325 </span><span class="lineNoCov">          0 :       hfit-&gt;SetBinContent(ip+1,binY[ip]);</span>
<span class="lineNum">    2326 </span><span class="lineNoCov">          0 :       nrm  += binY[ip];</span>
<span class="lineNum">    2327 </span><span class="lineNoCov">          0 :       mean += binX[ip]*binY[ip];</span>
<span class="lineNum">    2328 </span><span class="lineNoCov">          0 :       mom2 += binX[ip]*binX[ip]*binY[ip];</span>
<span class="lineNum">    2329 </span><span class="lineNoCov">          0 :       if (maxVal&lt;binY[ip]) maxVal = binY[ip];</span>
<span class="lineNum">    2330 </span>            :     }
<span class="lineNum">    2331 </span><span class="lineNoCov">          0 :     if (nrm&gt;0) {</span>
<span class="lineNum">    2332 </span><span class="lineNoCov">          0 :       mean /= nrm;</span>
<span class="lineNum">    2333 </span><span class="lineNoCov">          0 :       mom2 /= nrm;</span>
<span class="lineNum">    2334 </span><span class="lineNoCov">          0 :       rms = mom2 - mean*mean;</span>
<span class="lineNum">    2335 </span><span class="lineNoCov">          0 :       rms = rms&gt;0 ? TMath::Sqrt(rms):0;</span>
<span class="lineNum">    2336 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2337 </span><span class="lineNoCov">          0 :     mean0=mean;</span>
<span class="lineNum">    2338 </span><span class="lineNoCov">          0 :     rms0=rms;</span>
<span class="lineNum">    2339 </span>            :     
<span class="lineNum">    2340 </span>            : 
<span class="lineNum">    2341 </span><span class="lineNoCov">          0 :     Int_t nbins1D=hfit-&gt;GetNbinsX();</span>
<span class="lineNum">    2342 </span><span class="lineNoCov">          0 :     Float_t binMedian=0;</span>
<span class="lineNum">    2343 </span><span class="lineNoCov">          0 :     Double_t limits[2]={hfit-&gt;GetBinCenter(1), hfit-&gt;GetBinCenter(nbins1D)};</span>
<span class="lineNum">    2344 </span><span class="lineNoCov">          0 :     if (nrm&gt;5) {</span>
<span class="lineNum">    2345 </span><span class="lineNoCov">          0 :       for (Int_t iest=0; iest&lt;nestimators; iest++){</span>
<span class="lineNum">    2346 </span><span class="lineNoCov">          0 :         TStatToolkit::LTMHisto(hfit, *(vecLTM[iest]), fractionLTM[iest]); </span>
<span class="lineNum">    2347 </span>            :       }
<span class="lineNum">    2348 </span><span class="lineNoCov">          0 :       Double_t* integral=hfit-&gt;GetIntegral();      </span>
<span class="lineNum">    2349 </span><span class="lineNoCov">          0 :       for (Int_t i=1; i&lt;nbins1D-1; i++){</span>
<span class="lineNum">    2350 </span><span class="lineNoCov">          0 :         if (integral[i-1]&lt;0.5 &amp;&amp; integral[i]&gt;=0.5){</span>
<span class="lineNum">    2351 </span><span class="lineNoCov">          0 :           if (hfit-&gt;GetBinContent(i-1)+hfit-&gt;GetBinContent(i)&gt;0){</span>
<span class="lineNum">    2352 </span><span class="lineNoCov">          0 :             binMedian=hfit-&gt;GetBinCenter(i);</span>
<span class="lineNum">    2353 </span><span class="lineNoCov">          0 :             Double_t dIdx=-(integral[i-1]-integral[i]);</span>
<span class="lineNum">    2354 </span><span class="lineNoCov">          0 :             Double_t dx=(0.5+(0.5-integral[i])/dIdx)*hfit-&gt;GetBinWidth(i);</span>
<span class="lineNum">    2355 </span><span class="lineNoCov">          0 :             binMedian+=dx;</span>
<span class="lineNum">    2356 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    2357 </span>            :         }
<span class="lineNum">    2358 </span><span class="lineNoCov">          0 :         if (integral[i-1]&lt;fractionCut &amp;&amp; integral[i]&gt;=fractionCut){</span>
<span class="lineNum">    2359 </span><span class="lineNoCov">          0 :           limits[0]=hfit-&gt;GetBinCenter(i-1)-hfit-&gt;GetBinWidth(i);</span>
<span class="lineNum">    2360 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2361 </span><span class="lineNoCov">          0 :         if (integral[i]&lt;1-fractionCut &amp;&amp; integral[i+1]&gt;=1-fractionCut){</span>
<span class="lineNum">    2362 </span><span class="lineNoCov">          0 :           limits[1]=hfit-&gt;GetBinCenter(i+1)+hfit-&gt;GetBinWidth(i);</span>
<span class="lineNum">    2363 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2364 </span>            :       }
<span class="lineNum">    2365 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2366 </span><span class="lineNoCov">          0 :     if (nrm&gt;5&amp;&amp;fractionCut&gt;0 &amp;&amp;rms&gt;0) {</span>
<span class="lineNum">    2367 </span><span class="lineNoCov">          0 :       hfit-&gt;GetXaxis()-&gt;SetRangeUser(limits[0], limits[1]);</span>
<span class="lineNum">    2368 </span><span class="lineNoCov">          0 :       mean=hfit-&gt;GetMean();</span>
<span class="lineNum">    2369 </span><span class="lineNoCov">          0 :       rms=hfit-&gt;GetRMS();</span>
<span class="lineNum">    2370 </span><span class="lineNoCov">          0 :       if (nrm&gt;0 &amp;&amp; rms&gt;0) {</span>
<span class="lineNum">    2371 </span><span class="lineNoCov">          0 :         m3=hfit-&gt;GetSkewness();</span>
<span class="lineNum">    2372 </span><span class="lineNoCov">          0 :         m4=hfit-&gt;GetKurtosis();</span>
<span class="lineNum">    2373 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    2374 </span><span class="lineNoCov">          0 :       fgaus.SetRange(limits[0]-rms, limits[1]+rms);</span>
<span class="lineNum">    2375 </span>            :     }else{
<span class="lineNum">    2376 </span><span class="lineNoCov">          0 :       fgaus.SetRange(xax-&gt;GetXmin(),xax-&gt;GetXmax());</span>
<span class="lineNum">    2377 </span>            :     }
<span class="lineNum">    2378 </span>            : 
<span class="lineNum">    2379 </span>            : 
<span class="lineNum">    2380 </span><span class="lineNoCov">          0 :     Bool_t isFitValid=kFALSE; </span>
<span class="lineNum">    2381 </span><span class="lineNoCov">          0 :     if (nrm&gt;=kMinEntries &amp;&amp; rms&gt;0) {      </span>
<span class="lineNum">    2382 </span><span class="lineNoCov">          0 :       fgaus.SetParameters(nrm/(rms/hfit-&gt;GetBinWidth(nbins1D)),mean,rms);</span>
<span class="lineNum">    2383 </span>            :       //grafFit.Fit(&amp;fgaus,/*maxVal&lt;kUseLLFrom ? &quot;qnrl&quot;:*/&quot;qnr&quot;);
<span class="lineNum">    2384 </span><span class="lineNoCov">          0 :       TFitResultPtr fitPtr= hfit-&gt;Fit(&amp;fgaus,maxVal&lt;kUseLLFrom ? &quot;qnrlS&quot;:&quot;qnrS&quot;);</span>
<span class="lineNum">    2385 </span><span class="lineNoCov">          0 :       entriesG = fgaus.GetParameter(0);</span>
<span class="lineNum">    2386 </span><span class="lineNoCov">          0 :       meanG = fgaus.GetParameter(1);</span>
<span class="lineNum">    2387 </span><span class="lineNoCov">          0 :       rmsG  = fgaus.GetParameter(2);</span>
<span class="lineNum">    2388 </span><span class="lineNoCov">          0 :       chi2G = fgaus.GetChisquare()/fgaus.GetNumberFreeParameters();</span>
<span class="lineNum">    2389 </span><span class="lineNoCov">          0 :       TFitResult * result = fitPtr.Get();</span>
<span class="lineNum">    2390 </span><span class="lineNoCov">          0 :       if (result!=NULL){</span>
<span class="lineNum">    2391 </span><span class="lineNoCov">          0 :         isFitValid = result-&gt;IsValid();</span>
<span class="lineNum">    2392 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    2393 </span>            :       //
<span class="lineNum">    2394 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2395 </span>            :     TH1 * hDump=0;
<span class="lineNum">    2396 </span><span class="lineNoCov">          0 :     if (nrm&gt;=kMinEntries&amp;&amp; kDumpHistoFraction&gt;0 &amp;&amp; (gRandom-&gt;Rndm()&lt;kDumpHistoFraction ||  isFitValid!=kTRUE)){</span>
<span class="lineNum">    2397 </span>            :       hDump=hfit;
<span class="lineNum">    2398 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2399 </span><span class="lineNoCov">          0 :     if (hDump){</span>
<span class="lineNum">    2400 </span><span class="lineNoCov">          0 :       (*pcstream)&lt;&lt;TString::Format(&quot;%sDump&quot;, tname).Data()&lt;&lt;</span>
<span class="lineNum">    2401 </span><span class="lineNoCov">          0 :         &quot;entries=&quot;&lt;&lt;nrm&lt;&lt;     // number of entries</span>
<span class="lineNum">    2402 </span><span class="lineNoCov">          0 :         &quot;isFitValid=&quot;&lt;&lt;isFitValid&lt;&lt; // true if the gaus fit converged</span>
<span class="lineNum">    2403 </span><span class="lineNoCov">          0 :         &quot;hDump.=&quot;&lt;&lt;hDump&lt;&lt;    // histogram  - by default not filled</span>
<span class="lineNum">    2404 </span><span class="lineNoCov">          0 :         &quot;mean0=&quot;&lt;&lt;mean0&lt;&lt;       // mean value of the last dimension - without fraction cut</span>
<span class="lineNum">    2405 </span><span class="lineNoCov">          0 :         &quot;rms0=&quot;&lt;&lt;rms0&lt;&lt;         // rms value of the last dimension - without fraction cut</span>
<span class="lineNum">    2406 </span><span class="lineNoCov">          0 :         &quot;mean=&quot;&lt;&lt;mean&lt;&lt;       // mean value of the last dimension</span>
<span class="lineNum">    2407 </span><span class="lineNoCov">          0 :         &quot;rms=&quot;&lt;&lt;rms&lt;&lt;         // rms value of the last dimension</span>
<span class="lineNum">    2408 </span><span class="lineNoCov">          0 :         &quot;m3=&quot;&lt;&lt;m3&lt;&lt;            // m3 (skewnes) of the last dimension</span>
<span class="lineNum">    2409 </span><span class="lineNoCov">          0 :         &quot;m4=&quot;&lt;&lt;m4&lt;&lt;            // m4 (kurtosis) of the last dimension</span>
<span class="lineNum">    2410 </span><span class="lineNoCov">          0 :         &quot;binMedian=&quot;&lt;&lt;binMedian&lt;&lt; //binned median value of 1D histogram</span>
<span class="lineNum">    2411 </span><span class="lineNoCov">          0 :         &quot;entriesG=&quot;&lt;&lt;entriesG&lt;&lt; </span>
<span class="lineNum">    2412 </span><span class="lineNoCov">          0 :         &quot;meanG=&quot;&lt;&lt;meanG&lt;&lt;     // mean of the gaus fit</span>
<span class="lineNum">    2413 </span><span class="lineNoCov">          0 :         &quot;rmsG=&quot;&lt;&lt;rmsG&lt;&lt;       // rms of the gaus fit      </span>
<span class="lineNum">    2414 </span><span class="lineNoCov">          0 :         &quot;vecLTM.=&quot;&lt;&lt;vecLTM[0]&lt;&lt;   // LTM  frac% statistic</span>
<span class="lineNum">    2415 </span><span class="lineNoCov">          0 :         &quot;chi2G=&quot;&lt;&lt;chi2G;      // chi2 of the gaus fit      </span>
<span class="lineNum">    2416 </span><span class="lineNoCov">          0 :       for (Int_t iest=1; iest&lt;nestimators; iest++) </span>
<span class="lineNum">    2417 </span><span class="lineNoCov">          0 :         (*pcstream)&lt;&lt;TString::Format(&quot;%sDump&quot;, tname).Data()&lt;&lt;TString::Format(&quot;vecLTM%d.=&quot;,iest)&lt;&lt;vecLTM[iest];   // LTM  frac% statistic</span>
<span class="lineNum">    2418 </span>            :       
<span class="lineNum">    2419 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2420 </span>            : 
<span class="lineNum">    2421 </span><span class="lineNoCov">          0 :     (*pcstream)&lt;&lt;tname&lt;&lt;</span>
<span class="lineNum">    2422 </span><span class="lineNoCov">          0 :       &quot;entries=&quot;&lt;&lt;nrm&lt;&lt;     // number of entries</span>
<span class="lineNum">    2423 </span><span class="lineNoCov">          0 :       &quot;isFitValid=&quot;&lt;&lt;isFitValid&lt;&lt; // true if the gaus fit converged</span>
<span class="lineNum">    2424 </span><span class="lineNoCov">          0 :       &quot;mean0=&quot;&lt;&lt;mean0&lt;&lt;       // mean value of the last dimension - without fraction cut</span>
<span class="lineNum">    2425 </span><span class="lineNoCov">          0 :       &quot;rms0=&quot;&lt;&lt;rms0&lt;&lt;         // rms value of the last dimension - without fraction cut</span>
<span class="lineNum">    2426 </span><span class="lineNoCov">          0 :       &quot;mean=&quot;&lt;&lt;mean&lt;&lt;       // mean value of the last dimension</span>
<span class="lineNum">    2427 </span><span class="lineNoCov">          0 :       &quot;rms=&quot;&lt;&lt;rms&lt;&lt;         // rms value of the last dimension</span>
<span class="lineNum">    2428 </span><span class="lineNoCov">          0 :       &quot;m3=&quot;&lt;&lt;m3&lt;&lt;            // m3 (skewnes) of the last dimension</span>
<span class="lineNum">    2429 </span><span class="lineNoCov">          0 :       &quot;m4=&quot;&lt;&lt;m4&lt;&lt;            // m4 (kurtosis) of the last dimension</span>
<span class="lineNum">    2430 </span><span class="lineNoCov">          0 :       &quot;binMedian=&quot;&lt;&lt;binMedian&lt;&lt; //binned median value of 1D histogram</span>
<span class="lineNum">    2431 </span><span class="lineNoCov">          0 :       &quot;entriesG=&quot;&lt;&lt;entriesG&lt;&lt;   // </span>
<span class="lineNum">    2432 </span><span class="lineNoCov">          0 :       &quot;meanG=&quot;&lt;&lt;meanG&lt;&lt;     // mean of the gaus fit</span>
<span class="lineNum">    2433 </span><span class="lineNoCov">          0 :       &quot;rmsG=&quot;&lt;&lt;rmsG&lt;&lt;       // rms of the gaus fit</span>
<span class="lineNum">    2434 </span><span class="lineNoCov">          0 :       &quot;vecLTM.=&quot;&lt;&lt;vecLTM[0]&lt;&lt;   // LTM  frac% statistic</span>
<span class="lineNum">    2435 </span><span class="lineNoCov">          0 :       &quot;chi2G=&quot;&lt;&lt;chi2G;      // chi2 of the gaus fit</span>
<span class="lineNum">    2436 </span><span class="lineNoCov">          0 :     for (Int_t iest=1; iest&lt;nestimators; iest++) </span>
<span class="lineNum">    2437 </span><span class="lineNoCov">          0 :       (*pcstream)&lt;&lt;tname&lt;&lt;TString::Format(&quot;vecLTM%d.=&quot;,iest)&lt;&lt;vecLTM[iest];   // LTM  frac% statistic</span>
<span class="lineNum">    2438 </span>            : 
<span class="lineNum">    2439 </span>            : 
<span class="lineNum">    2440 </span>            :     //
<span class="lineNum">    2441 </span><span class="lineNoCov">          0 :     meanVector[tgtDim] = mean; // what's a point of this?</span>
<span class="lineNum">    2442 </span><span class="lineNoCov">          0 :     for (Int_t idim=0; idim&lt;ndim; idim++){</span>
<span class="lineNum">    2443 </span><span class="lineNoCov">          0 :       snprintf(aname, 100, &quot;%sMean=&quot;,histo-&gt;GetAxis(idim)-&gt;GetName());</span>
<span class="lineNum">    2444 </span><span class="lineNoCov">          0 :       (*pcstream)&lt;&lt;tname&lt;&lt;</span>
<span class="lineNum">    2445 </span><span class="lineNoCov">          0 :         aname&lt;&lt;meanVector[idim];      // current bin means</span>
<span class="lineNum">    2446 </span>            :     }
<span class="lineNum">    2447 </span>            :     //
<span class="lineNum">    2448 </span><span class="lineNoCov">          0 :     for (Int_t iIter=0; iIter&lt;ndim; iIter++){</span>
<span class="lineNum">    2449 </span><span class="lineNoCov">          0 :       Int_t idim = axOrd[iIter];</span>
<span class="lineNum">    2450 </span><span class="lineNoCov">          0 :       binVector[idim] = idx[idim];</span>
<span class="lineNum">    2451 </span><span class="lineNoCov">          0 :       centerVector[idim] = histo-&gt;GetAxis(idim)-&gt;GetBinCenter(idx[idim]);</span>
<span class="lineNum">    2452 </span><span class="lineNoCov">          0 :       snprintf(bname, 100, &quot;%sBin=&quot;,histo-&gt;GetAxis(idim)-&gt;GetName());</span>
<span class="lineNum">    2453 </span><span class="lineNoCov">          0 :       snprintf(cname, 100, &quot;%sCenter=&quot;,histo-&gt;GetAxis(idim)-&gt;GetName());</span>
<span class="lineNum">    2454 </span><span class="lineNoCov">          0 :       (*pcstream)&lt;&lt;tname&lt;&lt;</span>
<span class="lineNum">    2455 </span><span class="lineNoCov">          0 :         bname&lt;&lt;binVector[idim]&lt;&lt;      // current bin values</span>
<span class="lineNum">    2456 </span><span class="lineNoCov">          0 :         cname&lt;&lt;centerVector[idim];    // current bin centers</span>
<span class="lineNum">    2457 </span><span class="lineNoCov">          0 :       if (hDump){</span>
<span class="lineNum">    2458 </span><span class="lineNoCov">          0 :         (*pcstream)&lt;&lt;TString::Format(&quot;%sDump&quot;, tname).Data()&lt;&lt;</span>
<span class="lineNum">    2459 </span><span class="lineNoCov">          0 :           bname&lt;&lt;binVector[idim]&lt;&lt;      // current bin values</span>
<span class="lineNum">    2460 </span><span class="lineNoCov">          0 :           cname&lt;&lt;centerVector[idim];    // current bin centers</span>
<span class="lineNum">    2461 </span><span class="lineNoCov">          0 :        }      </span>
<span class="lineNum">    2462 </span>            :     }
<span class="lineNum">    2463 </span><span class="lineNoCov">          0 :     (*pcstream)&lt;&lt;tname&lt;&lt;&quot;\n&quot;;</span>
<span class="lineNum">    2464 </span><span class="lineNoCov">          0 :     if (hDump)  (*pcstream)&lt;&lt;TString::Format(&quot;%sDump&quot;, tname).Data()&lt;&lt;&quot;\n&quot;;</span>
<span class="lineNum">    2465 </span>            :     // &lt;&lt; ------------- do fit
<span class="lineNum">    2466 </span>            :     //
<span class="lineNum">    2467 </span><span class="lineNoCov">          0 :     if (((++fitCount)%fitProgress)==0) {</span>
<span class="lineNum">    2468 </span><span class="lineNoCov">          0 :       printf(&quot;fit %lld %4.1f%% done\n&quot;,fitCount,100*double(fitCount)/nfits); </span>
<span class="lineNum">    2469 </span><span class="lineNoCov">          0 :       AliSysInfo::AddStamp(&quot;fitCout&quot;, 1,fitCount,100*double(fitCount)/nfits);</span>
<span class="lineNum">    2470 </span>            :     }
<span class="lineNum">    2471 </span>            :     //
<span class="lineNum">    2472 </span>            :     //next global bin in which target dimention will be looped
<span class="lineNum">    2473 </span><span class="lineNoCov">          0 :     for (dimVar=1;dimVar&lt;ndim;dimVar++) { // varying dimension</span>
<span class="lineNum">    2474 </span><span class="lineNoCov">          0 :       dimVarID = axOrd[dimVar]; // real axis id in the histo</span>
<span class="lineNum">    2475 </span><span class="lineNoCov">          0 :       if ( (idx[dimVarID]+=binSt[dimVar]) &gt; nbins[dimVarID] ) idx[dimVarID]=1;</span>
<span class="lineNum">    2476 </span>            :       else break;
<span class="lineNum">    2477 </span>            :     }
<span class="lineNum">    2478 </span><span class="lineNoCov">          0 :     if (dimVar==ndim) break;</span>
<span class="lineNum">    2479 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2480 </span><span class="lineNoCov">          0 :   delete hfit;</span>
<span class="lineNum">    2481 </span><span class="lineNoCov">          0 :   sw.Stop();</span>
<span class="lineNum">    2482 </span><span class="lineNoCov">          0 :   sw.Print();</span>
<span class="lineNum">    2483 </span>            :   /*
<span class="lineNum">    2484 </span>            :   int nb = histo-&gt;GetNbins();
<span class="lineNum">    2485 </span>            :   int prc = nb/100;
<span class="lineNum">    2486 </span>            :   for (int i=0;i&lt;nb;i++) {
<span class="lineNum">    2487 </span>            :     histo-&gt;GetBinContent(i);
<span class="lineNum">    2488 </span>            :     if (i &amp;&amp; (i%prc)==0) printf(&quot;Done %d%%\n&quot;,int(float(100*i)/prc));
<span class="lineNum">    2489 </span>            :   }
<span class="lineNum">    2490 </span>            :   */
<span class="lineNum">    2491 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
