<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - STEER/AOD/AliAODTrack.cxx</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">STEER/AOD</a> - AliAODTrack.cxx<span style="font-size: 80%;"> (source / <a href="AliAODTrack.cxx.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">111</td>
            <td class="headerCovTableEntry">610</td>
            <td class="headerCovTableEntryLo">18.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">12</td>
            <td class="headerCovTableEntry">55</td>
            <td class="headerCovTableEntryLo">21.8 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**************************************************************************</a>
<span class="lineNum">       2 </span>            :  * Copyright(c) 1998-2007, ALICE Experiment at CERN, All rights reserved. *
<span class="lineNum">       3 </span>            :  *                                                                        *
<span class="lineNum">       4 </span>            :  * Author: The ALICE Off-line Project.                                    *
<span class="lineNum">       5 </span>            :  * Contributors are mentioned in the code where appropriate.              *
<span class="lineNum">       6 </span>            :  *                                                                        *
<span class="lineNum">       7 </span>            :  * Permission to use, copy, modify and distribute this software and its   *
<span class="lineNum">       8 </span>            :  * documentation strictly for non-commercial purposes is hereby granted   *
<span class="lineNum">       9 </span>            :  * without fee, provided that the above copyright notice appears in all   *
<span class="lineNum">      10 </span>            :  * copies and that both the copyright notice and this permission notice   *
<span class="lineNum">      11 </span>            :  * appear in the supporting documentation. The authors make no claims     *
<span class="lineNum">      12 </span>            :  * about the suitability of this software for any purpose. It is          *
<span class="lineNum">      13 </span>            :  * provided &quot;as is&quot; without express or implied warranty.                  *
<span class="lineNum">      14 </span>            :  **************************************************************************/
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : /* $Id$ */
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : //-------------------------------------------------------------------------
<span class="lineNum">      19 </span>            : //     AOD track implementation of AliVTrack
<span class="lineNum">      20 </span>            : //     Author: Markus Oldenburg, CERN
<span class="lineNum">      21 </span>            : //     Markus.Oldenburg@cern.ch
<span class="lineNum">      22 </span>            : //-------------------------------------------------------------------------
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : #include &lt;TVector3.h&gt;
<span class="lineNum">      25 </span>            : #include &quot;AliLog.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;AliExternalTrackParam.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;AliVVertex.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;AliDetectorPID.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;AliAODEvent.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;AliAODHMPIDrings.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;AliTOFHeader.h&quot;
<span class="lineNum">      32 </span>            : 
<a name="33"><span class="lineNum">      33 </span>            : #include &quot;AliAODTrack.h&quot;</a>
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span><span class="lineCov">        170 : ClassImp(AliAODTrack)</span>
<a name="36"><span class="lineNum">      36 </span>            : </a>
<span class="lineNum">      37 </span>            : //______________________________________________________________________________
<span class="lineNum">      38 </span>            : AliAODTrack::AliAODTrack() : 
<span class="lineNum">      39 </span><span class="lineCov">          2 :   AliVTrack(),</span>
<span class="lineNum">      40 </span><span class="lineCov">          2 :   fRAtAbsorberEnd(0.),</span>
<span class="lineNum">      41 </span><span class="lineCov">          2 :   fChi2perNDF(-999.),</span>
<span class="lineNum">      42 </span><span class="lineCov">          2 :   fChi2MatchTrigger(0.),</span>
<span class="lineNum">      43 </span><span class="lineCov">          2 :   fPID(0),</span>
<span class="lineNum">      44 </span><span class="lineCov">          2 :   fITSchi2(0),</span>
<span class="lineNum">      45 </span><span class="lineCov">          2 :   fFlags(0),</span>
<span class="lineNum">      46 </span><span class="lineCov">          2 :   fLabel(-999),</span>
<span class="lineNum">      47 </span><span class="lineCov">          2 :   fTOFLabel(),</span>
<span class="lineNum">      48 </span><span class="lineCov">          2 :   fTrackLength(0),</span>
<span class="lineNum">      49 </span><span class="lineCov">          2 :   fITSMuonClusterMap(0),</span>
<span class="lineNum">      50 </span><span class="lineCov">          2 :   fMUONtrigHitsMapTrg(0),</span>
<span class="lineNum">      51 </span><span class="lineCov">          2 :   fMUONtrigHitsMapTrk(0),</span>
<span class="lineNum">      52 </span><span class="lineCov">          2 :   fFilterMap(0),</span>
<span class="lineNum">      53 </span><span class="lineCov">          2 :   fTPCFitMap(),</span>
<span class="lineNum">      54 </span><span class="lineCov">          2 :   fTPCClusterMap(),</span>
<span class="lineNum">      55 </span><span class="lineCov">          2 :   fTPCSharedMap(),</span>
<span class="lineNum">      56 </span><span class="lineCov">          2 :   fTPCnclsF(0),</span>
<span class="lineNum">      57 </span><span class="lineCov">          2 :   fTPCNCrossedRows(0),</span>
<span class="lineNum">      58 </span><span class="lineCov">          2 :   fID(-999),</span>
<span class="lineNum">      59 </span><span class="lineCov">          2 :   fCharge(-99),</span>
<span class="lineNum">      60 </span><span class="lineCov">          2 :   fType(kUndef),</span>
<span class="lineNum">      61 </span><span class="lineCov">          2 :   fPIDForTracking(AliPID::kPion),</span>
<span class="lineNum">      62 </span><span class="lineCov">          2 :   fCaloIndex(kEMCALNoMatch),</span>
<span class="lineNum">      63 </span><span class="lineCov">          2 :   fCovMatrix(NULL),</span>
<span class="lineNum">      64 </span><span class="lineCov">          2 :   fDetPid(NULL),</span>
<span class="lineNum">      65 </span><span class="lineCov">          2 :   fDetectorPID(NULL),</span>
<span class="lineNum">      66 </span><span class="lineCov">          2 :   fProdVertex(NULL),</span>
<span class="lineNum">      67 </span><span class="lineCov">          2 :   fTrackPhiOnEMCal(-999),</span>
<span class="lineNum">      68 </span><span class="lineCov">          2 :   fTrackEtaOnEMCal(-999),</span>
<span class="lineNum">      69 </span><span class="lineCov">          2 :   fTrackPtOnEMCal(-999),</span>
<span class="lineNum">      70 </span><span class="lineCov">          2 :   fIsMuonGlobalTrack(kFALSE),    // AU</span>
<span class="lineNum">      71 </span><span class="lineCov">          2 :   fITSsignalTuned(0.),</span>
<span class="lineNum">      72 </span><span class="lineCov">          2 :   fTPCsignalTuned(0),</span>
<span class="lineNum">      73 </span><span class="lineCov">          2 :   fTOFsignalTuned(99999),</span>
<span class="lineNum">      74 </span><span class="lineCov">          2 :   fMFTClusterPattern(0),         // AU</span>
<span class="lineNum">      75 </span><span class="lineCov">          2 :   fAODEvent(NULL)</span>
<span class="lineNum">      76 </span><span class="lineCov">         10 : {</span>
<span class="lineNum">      77 </span>            :   // default constructor
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span><span class="lineCov">          2 :   SetP();</span>
<span class="lineNum">      80 </span><span class="lineCov">          2 :   SetPosition((Float_t*)NULL);</span>
<span class="lineNum">      81 </span><span class="lineCov">          2 :   SetXYAtDCA(-999., -999.);</span>
<span class="lineNum">      82 </span><span class="lineCov">          2 :   SetPxPyPzAtDCA(-999., -999., -999.);</span>
<span class="lineNum">      83 </span><span class="lineCov">         16 :   for (Int_t i = 0; i &lt; 3; i++) {fTOFLabel[i] = -1;}</span>
<span class="lineNum">      84 </span><span class="lineCov">          4 : }</span>
<a name="85"><span class="lineNum">      85 </span>            : </a>
<span class="lineNum">      86 </span>            : //______________________________________________________________________________
<span class="lineNum">      87 </span>            : AliAODTrack::AliAODTrack(Short_t id,
<span class="lineNum">      88 </span>            :                          Int_t label, 
<span class="lineNum">      89 </span>            :                          Double_t p[3],
<span class="lineNum">      90 </span>            :                          Bool_t cartesian,
<span class="lineNum">      91 </span>            :                          Double_t x[3],
<span class="lineNum">      92 </span>            :                          Bool_t isDCA,
<span class="lineNum">      93 </span>            :                          Double_t covMatrix[21],
<span class="lineNum">      94 </span>            :                          Short_t charge,
<span class="lineNum">      95 </span>            :                          UChar_t itsClusMap,
<span class="lineNum">      96 </span>            :                          AliAODVertex *prodVertex,
<span class="lineNum">      97 </span>            :                          Bool_t usedForVtxFit,
<span class="lineNum">      98 </span>            :                          Bool_t usedForPrimVtxFit,
<span class="lineNum">      99 </span>            :                          AODTrk_t ttype,
<span class="lineNum">     100 </span>            :                          UInt_t selectInfo,
<span class="lineNum">     101 </span>            :                          Float_t chi2perNDF) :
<span class="lineNum">     102 </span><span class="lineCov">        137 :   AliVTrack(),</span>
<span class="lineNum">     103 </span><span class="lineCov">        137 :   fRAtAbsorberEnd(0.),</span>
<span class="lineNum">     104 </span><span class="lineCov">        137 :   fChi2perNDF(chi2perNDF),</span>
<span class="lineNum">     105 </span><span class="lineCov">        137 :   fChi2MatchTrigger(0.),</span>
<span class="lineNum">     106 </span><span class="lineCov">        137 :   fPID(0),</span>
<span class="lineNum">     107 </span><span class="lineCov">        137 :   fITSchi2(0),</span>
<span class="lineNum">     108 </span><span class="lineCov">        137 :   fFlags(0),</span>
<span class="lineNum">     109 </span><span class="lineCov">        137 :   fLabel(label),</span>
<span class="lineNum">     110 </span><span class="lineCov">        137 :   fTOFLabel(),</span>
<span class="lineNum">     111 </span><span class="lineCov">        137 :   fTrackLength(0),</span>
<span class="lineNum">     112 </span><span class="lineCov">        137 :   fITSMuonClusterMap(0),</span>
<span class="lineNum">     113 </span><span class="lineCov">        137 :   fMUONtrigHitsMapTrg(0),</span>
<span class="lineNum">     114 </span><span class="lineCov">        137 :   fMUONtrigHitsMapTrk(0),</span>
<span class="lineNum">     115 </span><span class="lineCov">        137 :   fFilterMap(selectInfo),</span>
<span class="lineNum">     116 </span><span class="lineCov">        137 :   fTPCFitMap(),</span>
<span class="lineNum">     117 </span><span class="lineCov">        137 :   fTPCClusterMap(),</span>
<span class="lineNum">     118 </span><span class="lineCov">        137 :   fTPCSharedMap(),</span>
<span class="lineNum">     119 </span><span class="lineCov">        137 :   fTPCnclsF(0),</span>
<span class="lineNum">     120 </span><span class="lineCov">        137 :   fTPCNCrossedRows(0),</span>
<span class="lineNum">     121 </span><span class="lineCov">        137 :   fID(id),</span>
<span class="lineNum">     122 </span><span class="lineCov">        137 :   fCharge(charge),</span>
<span class="lineNum">     123 </span><span class="lineCov">        137 :   fType(ttype),</span>
<span class="lineNum">     124 </span><span class="lineCov">        137 :   fPIDForTracking(AliPID::kPion),</span>
<span class="lineNum">     125 </span><span class="lineCov">        137 :   fCaloIndex(kEMCALNoMatch),</span>
<span class="lineNum">     126 </span><span class="lineCov">        137 :   fCovMatrix(NULL),</span>
<span class="lineNum">     127 </span><span class="lineCov">        137 :   fDetPid(NULL),</span>
<span class="lineNum">     128 </span><span class="lineCov">        137 :   fDetectorPID(NULL),</span>
<span class="lineNum">     129 </span><span class="lineCov">        137 :   fProdVertex(prodVertex),</span>
<span class="lineNum">     130 </span><span class="lineCov">        137 :   fTrackPhiOnEMCal(-999),</span>
<span class="lineNum">     131 </span><span class="lineCov">        137 :   fTrackEtaOnEMCal(-999),</span>
<span class="lineNum">     132 </span><span class="lineCov">        137 :   fTrackPtOnEMCal(-999),</span>
<span class="lineNum">     133 </span><span class="lineCov">        137 :   fIsMuonGlobalTrack(kFALSE),    // AU</span>
<span class="lineNum">     134 </span><span class="lineCov">        137 :   fITSsignalTuned(0),</span>
<span class="lineNum">     135 </span><span class="lineCov">        137 :   fTPCsignalTuned(0),</span>
<span class="lineNum">     136 </span><span class="lineCov">        137 :   fTOFsignalTuned(99999),</span>
<span class="lineNum">     137 </span><span class="lineCov">        137 :   fMFTClusterPattern(0),         // AU</span>
<span class="lineNum">     138 </span><span class="lineCov">        137 :   fAODEvent(NULL)</span>
<span class="lineNum">     139 </span><span class="lineCov">        411 : {</span>
<span class="lineNum">     140 </span>            :   // constructor
<span class="lineNum">     141 </span>            :  
<span class="lineNum">     142 </span><span class="lineCov">        137 :   SetP(p, cartesian);</span>
<span class="lineNum">     143 </span><span class="lineCov">        137 :   SetPosition(x, isDCA);</span>
<span class="lineNum">     144 </span><span class="lineCov">        137 :   SetXYAtDCA(-999., -999.);</span>
<span class="lineNum">     145 </span><span class="lineCov">        137 :   SetPxPyPzAtDCA(-999., -999., -999.);</span>
<span class="lineNum">     146 </span><span class="lineCov">        137 :   SetUsedForVtxFit(usedForVtxFit);</span>
<span class="lineNum">     147 </span><span class="lineCov">        137 :   SetUsedForPrimVtxFit(usedForPrimVtxFit);</span>
<span class="lineNum">     148 </span><span class="lineCov">        258 :   if(covMatrix) SetCovMatrix(covMatrix);</span>
<span class="lineNum">     149 </span><span class="lineCov">        137 :   SetITSClusterMap(itsClusMap);</span>
<span class="lineNum">     150 </span><span class="lineCov">       1096 :   for (Int_t i=0;i&lt;3;i++) {fTOFLabel[i]=-1;}</span>
<span class="lineNum">     151 </span><span class="lineCov">        274 : }</span>
<a name="152"><span class="lineNum">     152 </span>            : </a>
<span class="lineNum">     153 </span>            : //______________________________________________________________________________
<span class="lineNum">     154 </span>            : AliAODTrack::AliAODTrack(Short_t id,
<span class="lineNum">     155 </span>            :                          Int_t label, 
<span class="lineNum">     156 </span>            :                          Float_t p[3],
<span class="lineNum">     157 </span>            :                          Bool_t cartesian,
<span class="lineNum">     158 </span>            :                          Float_t x[3],
<span class="lineNum">     159 </span>            :                          Bool_t isDCA,
<span class="lineNum">     160 </span>            :                          Float_t covMatrix[21],
<span class="lineNum">     161 </span>            :                          Short_t charge,
<span class="lineNum">     162 </span>            :                          UChar_t itsClusMap,
<span class="lineNum">     163 </span>            :                          AliAODVertex *prodVertex,
<span class="lineNum">     164 </span>            :                          Bool_t usedForVtxFit,
<span class="lineNum">     165 </span>            :                          Bool_t usedForPrimVtxFit,
<span class="lineNum">     166 </span>            :                          AODTrk_t ttype,
<span class="lineNum">     167 </span>            :                          UInt_t selectInfo,
<span class="lineNum">     168 </span>            :                          Float_t chi2perNDF ) :
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :   AliVTrack(),</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :   fRAtAbsorberEnd(0.),</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :   fChi2perNDF(chi2perNDF),</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :   fChi2MatchTrigger(0.),</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :   fPID(0),</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :   fITSchi2(0),</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :   fFlags(0),</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :   fLabel(label),</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :   fTOFLabel(),</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :   fTrackLength(0),</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :   fITSMuonClusterMap(0),</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :   fMUONtrigHitsMapTrg(0),</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :   fMUONtrigHitsMapTrk(0),</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :   fFilterMap(selectInfo),</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :   fTPCFitMap(),</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :   fTPCClusterMap(),</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :   fTPCSharedMap(),</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :   fTPCnclsF(0),</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :   fTPCNCrossedRows(0),</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :   fID(id),</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :   fCharge(charge),</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :   fType(ttype),</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :   fPIDForTracking(AliPID::kPion),</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :   fCaloIndex(kEMCALNoMatch),</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :   fCovMatrix(NULL),</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :   fDetPid(NULL),</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :   fDetectorPID(NULL),</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :   fProdVertex(prodVertex),</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :   fTrackPhiOnEMCal(-999),</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :   fTrackEtaOnEMCal(-999),</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :   fTrackPtOnEMCal(-999),</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :   fIsMuonGlobalTrack(kFALSE),    // AU</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :   fITSsignalTuned(0),</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :   fTPCsignalTuned(0),</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :   fTOFsignalTuned(99999),</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :   fMFTClusterPattern(0),         // AU</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :   fAODEvent(NULL)</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">     207 </span>            :   // constructor
<span class="lineNum">     208 </span>            :  
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :   SetP(p, cartesian);</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :   SetPosition(x, isDCA);</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :   SetXYAtDCA(-999., -999.);</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :   SetPxPyPzAtDCA(-999., -999., -999.);</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :   SetUsedForVtxFit(usedForVtxFit);</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :   SetUsedForPrimVtxFit(usedForPrimVtxFit);</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :   if(covMatrix) SetCovMatrix(covMatrix);</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :   SetITSClusterMap(itsClusMap);</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :   for (Int_t i=0;i&lt;3;i++) {fTOFLabel[i]=-1;}</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 : }</span>
<a name="219"><span class="lineNum">     219 </span>            : </a>
<span class="lineNum">     220 </span>            : //______________________________________________________________________________
<span class="lineNum">     221 </span>            : AliAODTrack::~AliAODTrack() 
<span class="lineNum">     222 </span><span class="lineCov">        834 : {</span>
<span class="lineNum">     223 </span>            :   // destructor
<span class="lineNum">     224 </span><span class="lineCov">        260 :   delete fCovMatrix;</span>
<span class="lineNum">     225 </span><span class="lineCov">        259 :   delete fDetPid;</span>
<span class="lineNum">     226 </span><span class="lineCov">        139 :   delete fDetectorPID;</span>
<span class="lineNum">     227 </span><span class="lineCov">        139 :   if (fPID) {delete[] fPID; fPID = 0;}</span>
<span class="lineNum">     228 </span><span class="lineCov">        417 : }</span>
<span class="lineNum">     229 </span>            : 
<a name="230"><span class="lineNum">     230 </span>            : </a>
<span class="lineNum">     231 </span>            : //______________________________________________________________________________
<span class="lineNum">     232 </span>            : AliAODTrack::AliAODTrack(const AliAODTrack&amp; trk) :
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :   AliVTrack(trk),</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :   fRAtAbsorberEnd(trk.fRAtAbsorberEnd),</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :   fChi2perNDF(trk.fChi2perNDF),</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :   fChi2MatchTrigger(trk.fChi2MatchTrigger),</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :   fPID(0),</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :   fITSchi2(trk.fITSchi2),</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :   fFlags(trk.fFlags),</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :   fLabel(trk.fLabel),</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :   fTOFLabel(),</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :   fTrackLength(trk.fTrackLength),</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :   fITSMuonClusterMap(trk.fITSMuonClusterMap),</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :   fMUONtrigHitsMapTrg(trk.fMUONtrigHitsMapTrg),</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :   fMUONtrigHitsMapTrk(trk.fMUONtrigHitsMapTrk),</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :   fFilterMap(trk.fFilterMap),</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :   fTPCFitMap(trk.fTPCFitMap),</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :   fTPCClusterMap(trk.fTPCClusterMap),</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :   fTPCSharedMap(trk.fTPCSharedMap),</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :   fTPCnclsF(trk.fTPCnclsF),</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :   fTPCNCrossedRows(trk.fTPCNCrossedRows),</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :   fID(trk.fID),</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :   fCharge(trk.fCharge),</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :   fType(trk.fType),</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :   fPIDForTracking(trk.fPIDForTracking),</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :   fCaloIndex(trk.fCaloIndex),</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :   fCovMatrix(NULL),</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :   fDetPid(NULL),</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :   fDetectorPID(NULL),</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :   fProdVertex(trk.fProdVertex),</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :   fTrackPhiOnEMCal(trk.fTrackPhiOnEMCal),</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :   fTrackEtaOnEMCal(trk.fTrackEtaOnEMCal),</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :   fTrackPtOnEMCal(trk.fTrackPtOnEMCal),</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :   fIsMuonGlobalTrack(trk.fIsMuonGlobalTrack),    // AU</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :   fITSsignalTuned(trk.fITSsignalTuned),</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :   fTPCsignalTuned(trk.fTPCsignalTuned),</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :   fTOFsignalTuned(trk.fTOFsignalTuned),</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :   fMFTClusterPattern(trk.fMFTClusterPattern),    // AU</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :   fAODEvent(trk.fAODEvent)</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">     271 </span>            :   // Copy constructor
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :   trk.GetP(fMomentum);</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :   trk.GetPosition(fPosition);</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :   SetXYAtDCA(trk.XAtDCA(), trk.YAtDCA());</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :   SetPxPyPzAtDCA(trk.PxAtDCA(), trk.PyAtDCA(), trk.PzAtDCA());</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :   SetUsedForVtxFit(trk.GetUsedForVtxFit());</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :   SetUsedForPrimVtxFit(trk.GetUsedForPrimVtxFit());</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :   if(trk.fCovMatrix) fCovMatrix=new AliAODRedCov&lt;6&gt;(*trk.fCovMatrix);</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :   if(trk.fDetPid) fDetPid=new AliAODPid(*trk.fDetPid);</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :   SetPID(trk.fPID);</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :   if (trk.fDetectorPID) fDetectorPID = new AliDetectorPID(*trk.fDetectorPID);</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :   for (Int_t i = 0; i &lt; 3; i++) {fTOFLabel[i] = trk.fTOFLabel[i];}  </span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 : }</span>
<a name="285"><span class="lineNum">     285 </span>            : </a>
<span class="lineNum">     286 </span>            : //______________________________________________________________________________
<span class="lineNum">     287 </span>            : AliAODTrack&amp; AliAODTrack::operator=(const AliAODTrack&amp; trk)
<span class="lineNum">     288 </span>            : {
<span class="lineNum">     289 </span>            :   // Assignment operator
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :   if(this!=&amp;trk) {</span>
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :     AliVTrack::operator=(trk);</span>
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :     trk.GetP(fMomentum);</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :     trk.GetPosition(fPosition);</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :     SetXYAtDCA(trk.XAtDCA(), trk.YAtDCA());</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :     SetPxPyPzAtDCA(trk.PxAtDCA(), trk.PyAtDCA(), trk.PzAtDCA());</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :     fRAtAbsorberEnd    = trk.fRAtAbsorberEnd;</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :     fChi2perNDF        = trk.fChi2perNDF;</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :     fChi2MatchTrigger  = trk.fChi2MatchTrigger;</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :     SetPID( trk.fPID );</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :     fITSchi2           = trk.fITSchi2;</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :     fFlags             = trk.fFlags;</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :     fLabel             = trk.fLabel;    </span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :     fTrackLength       = trk.fTrackLength;</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :     fITSMuonClusterMap = trk.fITSMuonClusterMap;</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :     fMUONtrigHitsMapTrg = trk.fMUONtrigHitsMapTrg;</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :     fMUONtrigHitsMapTrk = trk.fMUONtrigHitsMapTrk;</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :     fFilterMap         = trk.fFilterMap;</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :     fTPCFitMap         = trk.fTPCFitMap;</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :     fTPCClusterMap     = trk.fTPCClusterMap;</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :     fTPCSharedMap      = trk.fTPCSharedMap;</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :     fTPCnclsF          = trk.fTPCnclsF;</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :     fTPCNCrossedRows   = trk.fTPCNCrossedRows;</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :     fID                = trk.fID;</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :     fCharge            = trk.fCharge;</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :     fType              = trk.fType;</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :     fPIDForTracking    = trk.fPIDForTracking;</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :     fCaloIndex         = trk.fCaloIndex;</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :     fTrackPhiOnEMCal   = trk.fTrackPhiOnEMCal;</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :     fTrackEtaOnEMCal   = trk.fTrackEtaOnEMCal;</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :     fTrackPtOnEMCal    = trk.fTrackPtOnEMCal;</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :     fIsMuonGlobalTrack = trk.fIsMuonGlobalTrack;     // AU</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :     fITSsignalTuned    = trk.fITSsignalTuned;</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :     fTPCsignalTuned    = trk.fTPCsignalTuned;</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :     fTOFsignalTuned    = trk.fTOFsignalTuned;</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :     fMFTClusterPattern = trk.fMFTClusterPattern;     // AU</span>
<span class="lineNum">     328 </span>            :     
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :     delete fCovMatrix;</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :     if(trk.fCovMatrix) fCovMatrix=new AliAODRedCov&lt;6&gt;(*trk.fCovMatrix);</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :     else fCovMatrix=NULL;</span>
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :     fProdVertex        = trk.fProdVertex;</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :     SetUsedForVtxFit(trk.GetUsedForVtxFit());</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :     SetUsedForPrimVtxFit(trk.GetUsedForPrimVtxFit());</span>
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span>            :     //detector raw signals
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :     delete fDetPid;</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :     if(trk.fDetPid) fDetPid=new AliAODPid(*trk.fDetPid);</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :     else fDetPid=NULL;</span>
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span>            :     //calibrated PID cache
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :     delete fDetectorPID;</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :     fDetectorPID=0x0;</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :     if (trk.fDetectorPID) fDetectorPID = new AliDetectorPID(*trk.fDetectorPID);</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :     for (Int_t i = 0; i &lt; 3; i++) {fTOFLabel[i] = trk.fTOFLabel[i];}  </span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :   return *this;</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 : }</span>
<a name="352"><span class="lineNum">     352 </span>            : </a>
<span class="lineNum">     353 </span>            : //______________________________________________________________________________
<span class="lineNum">     354 </span>            : Double_t AliAODTrack::M(AODTrkPID_t pid) const
<span class="lineNum">     355 </span>            : {
<span class="lineNum">     356 </span>            :   // Returns the mass.
<span class="lineNum">     357 </span>            :   // Masses for nuclei don't exist in the PDG tables, therefore they were put by hand.
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :   switch (pid) {</span>
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            :   case kElectron :
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :     return 0.000510999; //TDatabasePDG::Instance()-&gt;GetParticle(11/*::kElectron*/)-&gt;Mass();</span>
<span class="lineNum">     363 </span>            :     break;
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span>            :   case kMuon :
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :     return 0.1056584; //TDatabasePDG::Instance()-&gt;GetParticle(13/*::kMuonMinus*/)-&gt;Mass();</span>
<span class="lineNum">     367 </span>            :     break;
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span>            :   case kPion :
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :     return 0.13957; //TDatabasePDG::Instance()-&gt;GetParticle(211/*::kPiPlus*/)-&gt;Mass();</span>
<span class="lineNum">     371 </span>            :     break;
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            :   case kKaon :
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :     return 0.4937; //TDatabasePDG::Instance()-&gt;GetParticle(321/*::kKPlus*/)-&gt;Mass();</span>
<span class="lineNum">     375 </span>            :     break;
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span>            :   case kProton :
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :     return 0.9382720; //TDatabasePDG::Instance()-&gt;GetParticle(2212/*::kProton*/)-&gt;Mass();</span>
<span class="lineNum">     379 </span>            :     break;
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            :   case kDeuteron :
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     return 1.8756; //TDatabasePDG::Instance()-&gt;GetParticle(1000010020)-&gt;Mass();</span>
<span class="lineNum">     383 </span>            :     break;
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            :   case kTriton :
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :     return 2.8089; //TDatabasePDG::Instance()-&gt;GetParticle(1000010030)-&gt;Mass();</span>
<span class="lineNum">     387 </span>            :     break;
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span>            :   case kHelium3 :
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :     return 2.8084; //TDatabasePDG::Instance()-&gt;GetParticle(1000020030)-&gt;Mass();</span>
<span class="lineNum">     391 </span>            :     break;
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span>            :   case kAlpha :
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :     return 3.7274; //TDatabasePDG::Instance()-&gt;GetParticle(1000020040)-&gt;Mass();</span>
<span class="lineNum">     395 </span>            :     break;
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            :   case kUnknown :
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :     return -999.;</span>
<span class="lineNum">     399 </span>            :     break;
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span>            :   default :
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :     return -999.;</span>
<span class="lineNum">     403 </span>            :   }
<span class="lineNum">     404 </span><span class="lineNoCov">          0 : }</span>
<a name="405"><span class="lineNum">     405 </span>            : </a>
<span class="lineNum">     406 </span>            : //______________________________________________________________________________
<span class="lineNum">     407 </span>            : Double_t AliAODTrack::E(AODTrkPID_t pid) const
<span class="lineNum">     408 </span>            : {
<span class="lineNum">     409 </span>            :   // Returns the energy of the particle of a given pid.
<span class="lineNum">     410 </span>            :   
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :   if (pid != kUnknown) { // particle was identified</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :     Double_t m = M(pid);</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :     return TMath::Sqrt(P()*P() + m*m);</span>
<span class="lineNum">     414 </span>            :   } else { // pid unknown
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :     return -999.;</span>
<span class="lineNum">     416 </span>            :   }
<span class="lineNum">     417 </span><span class="lineNoCov">          0 : }</span>
<a name="418"><span class="lineNum">     418 </span>            : </a>
<span class="lineNum">     419 </span>            : //______________________________________________________________________________
<span class="lineNum">     420 </span>            : Double_t AliAODTrack::Y(AODTrkPID_t pid) const
<span class="lineNum">     421 </span>            : {
<span class="lineNum">     422 </span>            :   // Returns the rapidity of a particle of a given pid.
<span class="lineNum">     423 </span>            :   
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :   if (pid != kUnknown) { // particle was identified</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :     Double_t e = E(pid);</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :     Double_t pz = Pz();</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :     if (e&gt;=0 &amp;&amp; e!=pz) { // energy was positive (e.g. not -999.) and not equal to pz</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :       return 0.5*TMath::Log((e+pz)/(e-pz));</span>
<span class="lineNum">     429 </span>            :     } else { // energy not known or equal to pz
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :       return -999.;</span>
<span class="lineNum">     431 </span>            :     }
<span class="lineNum">     432 </span>            :   } else { // pid unknown
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :     return -999.;</span>
<span class="lineNum">     434 </span>            :   }
<span class="lineNum">     435 </span><span class="lineNoCov">          0 : }</span>
<a name="436"><span class="lineNum">     436 </span>            : </a>
<span class="lineNum">     437 </span>            : //______________________________________________________________________________
<span class="lineNum">     438 </span>            : Double_t AliAODTrack::Y(Double_t m) const
<span class="lineNum">     439 </span>            : {
<span class="lineNum">     440 </span>            :   // Returns the rapidity of a particle of a given mass.
<span class="lineNum">     441 </span>            :   
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :   if (m &gt;= 0.) { // mass makes sense</span>
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :     Double_t e = E(m);</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :     Double_t pz = Pz();</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :     if (e&gt;=0 &amp;&amp; e!=pz) { // energy was positive (e.g. not -999.) and not equal to pz</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :       return 0.5*TMath::Log((e+pz)/(e-pz));</span>
<span class="lineNum">     447 </span>            :     } else { // energy not known or equal to pz
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :       return -999.;</span>
<span class="lineNum">     449 </span>            :     }
<span class="lineNum">     450 </span>            :   } else { // pid unknown
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :     return -999.;</span>
<span class="lineNum">     452 </span>            :   }
<a name="453"><span class="lineNum">     453 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     454 </span>            : 
<span class="lineNum">     455 </span>            : void AliAODTrack::SetTOFLabel(const Int_t *p) {  
<span class="lineNum">     456 </span>            :   // Sets  (in TOF)
<span class="lineNum">     457 </span><span class="lineCov">       1629 :   for (Int_t i = 0; i &lt; 3; i++) fTOFLabel[i]=p[i];</span>
<span class="lineNum">     458 </span><span class="lineCov">        181 : }</span>
<a name="459"><span class="lineNum">     459 </span>            : </a>
<span class="lineNum">     460 </span>            : //_______________________________________________________________________
<span class="lineNum">     461 </span>            : void AliAODTrack::GetTOFLabel(Int_t *p) const {
<span class="lineNum">     462 </span>            :   // Gets (in TOF)
<span class="lineNum">     463 </span><span class="lineCov">        549 :   for (Int_t i=0; i&lt;3; i++) p[i]=fTOFLabel[i];</span>
<span class="lineNum">     464 </span><span class="lineCov">         61 : }</span>
<a name="465"><span class="lineNum">     465 </span>            : </a>
<span class="lineNum">     466 </span>            : //______________________________________________________________________________
<span class="lineNum">     467 </span>            : AliAODTrack::AODTrkPID_t AliAODTrack::GetMostProbablePID() const 
<span class="lineNum">     468 </span>            : {
<span class="lineNum">     469 </span>            :   // Returns the most probable PID array element.
<span class="lineNum">     470 </span>            :   
<span class="lineNum">     471 </span>            :   Int_t nPID = 10;
<span class="lineNum">     472 </span>            :   AODTrkPID_t loc = kUnknown;
<span class="lineNum">     473 </span>            :   Bool_t allTheSame = kTRUE;
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :   if (fPID) {</span>
<span class="lineNum">     475 </span>            :     Double_t max = 0.;
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :     for (Int_t iPID = 0; iPID &lt; nPID; iPID++) {</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :       if (fPID[iPID] &gt;= max) {</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :         if (fPID[iPID] &gt; max) {</span>
<span class="lineNum">     479 </span>            :           allTheSame = kFALSE;
<span class="lineNum">     480 </span>            :           max = fPID[iPID];
<span class="lineNum">     481 </span>            :           loc = (AODTrkPID_t)iPID;
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">     483 </span>            :           allTheSame = kTRUE;
<span class="lineNum">     484 </span>            :         }
<span class="lineNum">     485 </span>            :       }
<span class="lineNum">     486 </span>            :     }
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :   return allTheSame ? AODTrkPID_t(GetPIDForTracking()) : loc;</span>
<span class="lineNum">     489 </span>            : }
<a name="490"><span class="lineNum">     490 </span>            : </a>
<span class="lineNum">     491 </span>            : //______________________________________________________________________________
<span class="lineNum">     492 </span>            : void AliAODTrack::ConvertAliPIDtoAODPID()
<span class="lineNum">     493 </span>            : {
<span class="lineNum">     494 </span>            :   // Converts AliPID array.
<span class="lineNum">     495 </span>            :   // The numbering scheme is the same for electrons, muons, pions, kaons, and protons.
<span class="lineNum">     496 </span>            :   // Everything else has to be set to zero.
<span class="lineNum">     497 </span><span class="lineCov">        282 :   if (fPID) {</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :     fPID[kDeuteron] = 0.;</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :     fPID[kTriton]   = 0.;</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :     fPID[kHelium3]  = 0.;</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :     fPID[kAlpha]    = 0.;</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :     fPID[kUnknown]  = 0.;</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     504 </span><span class="lineCov">        141 :   return;</span>
<span class="lineNum">     505 </span>            : }
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span>            : /*
<span class="lineNum">     508 </span>            : //______________________________________________________________________________
<span class="lineNum">     509 </span>            : template &lt;typename T&gt; void AliAODTrack::SetPosition(const T *x, const Bool_t dca) 
<span class="lineNum">     510 </span>            : {
<span class="lineNum">     511 </span>            :   // set the position
<span class="lineNum">     512 </span>            : 
<span class="lineNum">     513 </span>            :   if (x) {
<span class="lineNum">     514 </span>            :     if (!dca) {
<span class="lineNum">     515 </span>            :       ResetBit(kIsDCA);
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span>            :       fPosition[0] = x[0];
<span class="lineNum">     518 </span>            :       fPosition[1] = x[1];
<span class="lineNum">     519 </span>            :       fPosition[2] = x[2];
<span class="lineNum">     520 </span>            :     } else {
<span class="lineNum">     521 </span>            :       SetBit(kIsDCA);
<span class="lineNum">     522 </span>            :       // don't know any better yet
<span class="lineNum">     523 </span>            :       fPosition[0] = -999.;
<span class="lineNum">     524 </span>            :       fPosition[1] = -999.;
<span class="lineNum">     525 </span>            :       fPosition[2] = -999.;
<span class="lineNum">     526 </span>            :     }
<span class="lineNum">     527 </span>            :   } else {
<span class="lineNum">     528 </span>            :     ResetBit(kIsDCA);
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span>            :     fPosition[0] = -999.;
<span class="lineNum">     531 </span>            :     fPosition[1] = -999.;
<span class="lineNum">     532 </span>            :     fPosition[2] = -999.;
<span class="lineNum">     533 </span>            :   }
<span class="lineNum">     534 </span>            : }
<a name="535"><span class="lineNum">     535 </span>            : */</a>
<span class="lineNum">     536 </span>            : //______________________________________________________________________________
<span class="lineNum">     537 </span>            : void AliAODTrack::SetDCA(Double_t d, Double_t z) 
<span class="lineNum">     538 </span>            : {
<span class="lineNum">     539 </span>            :   // set the dca
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :   fPosition[0] = d;</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :   fPosition[1] = z;</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :   fPosition[2] = 0.;</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :   SetBit(kIsDCA);</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 : }</span>
<a name="545"><span class="lineNum">     545 </span>            : </a>
<span class="lineNum">     546 </span>            : //______________________________________________________________________________
<span class="lineNum">     547 </span>            : void AliAODTrack::Print(Option_t* /* option */) const
<span class="lineNum">     548 </span>            : {
<span class="lineNum">     549 </span>            :   // prints information about AliAODTrack
<span class="lineNum">     550 </span>            : 
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :   printf(&quot;Object name: %s   Track type: %s\n&quot;, GetName(), GetTitle()); </span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :   printf(&quot;        px = %f\n&quot;, Px());</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :   printf(&quot;        py = %f\n&quot;, Py());</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :   printf(&quot;        pz = %f\n&quot;, Pz());</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :   printf(&quot;        pt = %f\n&quot;, Pt());</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :   printf(&quot;      1/pt = %f\n&quot;, OneOverPt());</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :   printf(&quot;     theta = %f\n&quot;, Theta());</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :   printf(&quot;       phi = %f\n&quot;, Phi());</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :   printf(&quot;  chi2/NDF = %f\n&quot;, Chi2perNDF());</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :   printf(&quot;    charge = %d\n&quot;, Charge());</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 : }</span>
<a name="562"><span class="lineNum">     562 </span>            : </a>
<span class="lineNum">     563 </span>            : //______________________________________________________________________________
<span class="lineNum">     564 </span>            : void AliAODTrack::SetMatchTrigger(Int_t matchTrig)
<span class="lineNum">     565 </span>            : {
<span class="lineNum">     566 </span>            :   // Set the MUON trigger information
<span class="lineNum">     567 </span><span class="lineCov">         32 :   switch(matchTrig){</span>
<span class="lineNum">     568 </span>            :     case 0: // 0 track does not match trigger
<span class="lineNum">     569 </span><span class="lineCov">          4 :       fITSMuonClusterMap=fITSMuonClusterMap&amp;0x3fffffff;</span>
<span class="lineNum">     570 </span><span class="lineCov">          4 :       break;</span>
<span class="lineNum">     571 </span>            :     case 1: // 1 track match but does not pass pt cut
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :       fITSMuonClusterMap=(fITSMuonClusterMap&amp;0x3fffffff)|0x40000000;</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     574 </span>            :     case 2: // 2 track match Low pt cut
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :       fITSMuonClusterMap=(fITSMuonClusterMap&amp;0x3fffffff)|0x80000000;</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     577 </span>            :     case 3: // 3 track match High pt cut
<span class="lineNum">     578 </span><span class="lineCov">         12 :       fITSMuonClusterMap=fITSMuonClusterMap|0xc0000000;</span>
<span class="lineNum">     579 </span><span class="lineCov">         12 :       break;</span>
<span class="lineNum">     580 </span>            :     default:
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :       fITSMuonClusterMap=fITSMuonClusterMap&amp;0x3fffffff;</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :       AliWarning(Form(&quot;unknown case for matchTrig: %d\n&quot;,matchTrig));</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     584 </span><span class="lineCov">         16 : }</span>
<a name="585"><span class="lineNum">     585 </span>            : </a>
<span class="lineNum">     586 </span>            : //______________________________________________________________________________
<span class="lineNum">     587 </span>            : Bool_t AliAODTrack::HitsMuonChamber(Int_t MuonChamber, Int_t cathode) const
<span class="lineNum">     588 </span>            : {
<span class="lineNum">     589 </span>            :   // return kTRUE if the track fires the given tracking or trigger chamber.
<span class="lineNum">     590 </span>            :   // If the chamber is a trigger one:
<span class="lineNum">     591 </span>            :   // - if cathode = 0 or 1, the track matches the corresponding cathode
<span class="lineNum">     592 </span>            :   // - if cathode = -1, the track matches both cathodes
<span class="lineNum">     593 </span>            :   
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :   if (MuonChamber &lt; 0) return kFALSE;</span>
<span class="lineNum">     595 </span>            :   
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :   if (MuonChamber &lt; 10) return TESTBIT(GetMUONClusterMap(), MuonChamber);</span>
<span class="lineNum">     597 </span>            :   
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :   if (MuonChamber &lt; 14) {</span>
<span class="lineNum">     599 </span>            :     
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :     if (cathode &lt; 0) return TESTBIT(GetMUONTrigHitsMapTrg(), 13-MuonChamber) &amp;&amp;</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :                             TESTBIT(GetMUONTrigHitsMapTrg(), 13-MuonChamber+4);</span>
<span class="lineNum">     602 </span>            :     
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :     if (cathode &lt; 2) return TESTBIT(GetMUONTrigHitsMapTrg(), 13-MuonChamber+(1-cathode)*4);</span>
<span class="lineNum">     604 </span>            :     
<span class="lineNum">     605 </span>            :   }
<span class="lineNum">     606 </span>            :   
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :   return kFALSE;</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 : }</span>
<a name="609"><span class="lineNum">     609 </span>            : </a>
<span class="lineNum">     610 </span>            : //______________________________________________________________________________
<span class="lineNum">     611 </span>            : Bool_t AliAODTrack::MatchTriggerDigits() const
<span class="lineNum">     612 </span>            : {
<span class="lineNum">     613 </span>            :   // return kTRUE if the track matches a digit on both planes of at least 2 trigger chambers
<span class="lineNum">     614 </span>            :   
<span class="lineNum">     615 </span>            :   Int_t nMatchedChambers = 0;
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :   for (Int_t ich=10; ich&lt;14; ich++) if (HitsMuonChamber(ich)) nMatchedChambers++;</span>
<span class="lineNum">     617 </span>            :   
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :   return (nMatchedChambers &gt;= 2);</span>
<span class="lineNum">     619 </span>            : }
<a name="620"><span class="lineNum">     620 </span>            : </a>
<span class="lineNum">     621 </span>            : //______________________________________________________________________________
<span class="lineNum">     622 </span>            : Int_t AliAODTrack::GetMuonTrigDevSign() const
<span class="lineNum">     623 </span>            : {
<span class="lineNum">     624 </span>            :   /// Return the sign of the  MTR deviation
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :   Int_t signInfo = (Int_t)((fMUONtrigHitsMapTrg&gt;&gt;30)&amp;0x3);</span>
<span class="lineNum">     627 </span>            :   // Dummy value for old AODs which do not have the info
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :   if ( signInfo == 0 ) return -999;</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :   return signInfo - 2;</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 : }</span>
<a name="631"><span class="lineNum">     631 </span>            : </a>
<span class="lineNum">     632 </span>            : //______________________________________________________________________________
<span class="lineNum">     633 </span>            : Bool_t AliAODTrack::PropagateToDCA(const AliVVertex *vtx, 
<span class="lineNum">     634 </span>            :     Double_t b, Double_t maxd, Double_t dz[2], Double_t covar[3])
<span class="lineNum">     635 </span>            : {
<span class="lineNum">     636 </span>            :   // compute impact parameters to the vertex vtx and their covariance matrix
<span class="lineNum">     637 </span>            :   // b is the Bz, needed to propagate correctly the track to vertex 
<span class="lineNum">     638 </span>            :   // only the track parameters are update after the propagation (pos and mom),
<span class="lineNum">     639 </span>            :   // not the covariance matrix. This is OK for propagation over short distance
<span class="lineNum">     640 </span>            :   // inside the beam pipe.
<span class="lineNum">     641 </span>            :   // return kFALSE is something went wrong
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span>            :   // allowed only for tracks inside the beam pipe
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :   Float_t xstart2 = fPosition[0]*fPosition[0]+fPosition[1]*fPosition[1];</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :   if(xstart2 &gt; 3.*3.) { // outside beampipe radius</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :     AliError(&quot;This method can be used only for propagation inside the beam pipe&quot;);</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :     return kFALSE; </span>
<span class="lineNum">     648 </span>            :   }
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span>            :   // convert to AliExternalTrackParam
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :   AliExternalTrackParam etp; etp.CopyFromVTrack(this);  </span>
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span>            :   // propagate
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :   if(!etp.PropagateToDCA(vtx,b,maxd,dz,covar)) return kFALSE;</span>
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span>            :   // update track position and momentum
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :   Double_t mom[3];</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :   etp.GetPxPyPz(mom);</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :   SetP(mom,kTRUE);</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :   etp.GetXYZ(mom);</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :   SetPosition(mom,kFALSE);</span>
<span class="lineNum">     662 </span>            : 
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span>            :   return kTRUE;
<span class="lineNum">     665 </span><span class="lineNoCov">          0 : }</span>
<a name="666"><span class="lineNum">     666 </span>            : </a>
<span class="lineNum">     667 </span>            : //______________________________________________________________________________
<span class="lineNum">     668 </span>            : Bool_t AliAODTrack::GetPxPyPz(Double_t p[3]) const 
<span class="lineNum">     669 </span>            : {
<span class="lineNum">     670 </span>            :     //---------------------------------------------------------------------
<span class="lineNum">     671 </span>            :     // This function returns the global track momentum components
<span class="lineNum">     672 </span>            :     //---------------------------------------------------------------------
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :   p[0]=Px(); p[1]=Py(); p[2]=Pz();</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :   return kTRUE;</span>
<span class="lineNum">     675 </span>            : }
<span class="lineNum">     676 </span>            : 
<a name="677"><span class="lineNum">     677 </span>            : </a>
<span class="lineNum">     678 </span>            : //_______________________________________________________________________
<span class="lineNum">     679 </span>            : Float_t AliAODTrack::GetTPCClusterInfo(Int_t nNeighbours/*=3*/, Int_t type/*=0*/, Int_t row0, Int_t row1, Int_t bitType ) const
<span class="lineNum">     680 </span>            : {
<span class="lineNum">     681 </span>            :   //
<span class="lineNum">     682 </span>            :   // TPC cluster information 
<span class="lineNum">     683 </span>            :   // type 0: get fraction of found/findable clusters with neighbourhood definition
<span class="lineNum">     684 </span>            :   //      1: findable clusters with neighbourhood definition
<span class="lineNum">     685 </span>            :   //      2: found clusters
<span class="lineNum">     686 </span>            :   // bitType:
<span class="lineNum">     687 </span>            :   //      0 - all cluster used
<span class="lineNum">     688 </span>            :   //      1 - clusters  used for the kalman update
<span class="lineNum">     689 </span>            :   // definition of findable clusters:
<span class="lineNum">     690 </span>            :   //            a cluster is defined as findable if there is another cluster
<span class="lineNum">     691 </span>            :   //           within +- nNeighbours pad rows. The idea is to overcome threshold
<span class="lineNum">     692 </span>            :   //           effects with a very simple algorithm.
<span class="lineNum">     693 </span>            :   //
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span>            :   
<span class="lineNum">     696 </span>            :   Int_t found=0;
<span class="lineNum">     697 </span>            :   Int_t findable=0;
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :   Int_t last=-nNeighbours;</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :   const TBits &amp; clusterMap = (bitType%2==0) ? fTPCClusterMap : fTPCFitMap;</span>
<span class="lineNum">     700 </span>            :   
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :   Int_t upperBound=clusterMap.GetNbits();</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :   if (upperBound&gt;row1) upperBound=row1;</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :   for (Int_t i=row0; i&lt;upperBound; ++i){</span>
<span class="lineNum">     704 </span>            :     //look to current row
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :     if (clusterMap[i]) {</span>
<span class="lineNum">     706 </span>            :       last=i;
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :       ++found;</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :       ++findable;</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">     710 </span>            :     }
<span class="lineNum">     711 </span>            :     //look to nNeighbours before
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :     if ((i-last)&lt;=nNeighbours) {</span>
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :       ++findable;</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">     715 </span>            :     }
<span class="lineNum">     716 </span>            :     //look to nNeighbours after
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :     for (Int_t j=i+1; j&lt;i+1+nNeighbours; ++j){</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :       if (clusterMap[j]){</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :         ++findable;</span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     721 </span>            :       }
<span class="lineNum">     722 </span>            :     }
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :   if (type==2) return found;</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :   if (type==1) return findable;</span>
<span class="lineNum">     726 </span>            :   
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :   if (type==0){</span>
<span class="lineNum">     728 </span>            :     Float_t fraction=0;
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :     if (findable&gt;0) </span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :       fraction=(Float_t)found/(Float_t)findable;</span>
<span class="lineNum">     731 </span>            :     else 
<span class="lineNum">     732 </span>            :       fraction=0;
<span class="lineNum">     733 </span>            :     return fraction;
<span class="lineNum">     734 </span>            :   }  
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :   return 0;  // undefined type - default value</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     737 </span>            : 
<a name="738"><span class="lineNum">     738 </span>            : </a>
<span class="lineNum">     739 </span>            : //______________________________________________________________________________
<span class="lineNum">     740 </span>            : Double_t  AliAODTrack::GetTRDslice(Int_t plane, Int_t slice) const {
<span class="lineNum">     741 </span>            :   //
<span class="lineNum">     742 </span>            :   // return TRD Pid information
<span class="lineNum">     743 </span>            :   //
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :   if (!fDetPid) return -1;</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :   Double32_t *trdSlices=fDetPid-&gt;GetTRDslices();</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :   if (!trdSlices) return -1;</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :   if ((plane&lt;0) || (plane&gt;=kTRDnPlanes)) {</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :     return -1.;</span>
<span class="lineNum">     749 </span>            :   }
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :   Int_t ns=fDetPid-&gt;GetTRDnSlices();</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :   if ((slice&lt;-1) || (slice&gt;=ns)) {</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :     return -1.;</span>
<span class="lineNum">     754 </span>            :   }
<span class="lineNum">     755 </span>            : 
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :   if(slice&gt;=0) return trdSlices[plane*ns + slice];</span>
<span class="lineNum">     757 </span>            : 
<span class="lineNum">     758 </span>            :   // return average of the dEdx measurements
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :   Double_t q=0.; Double32_t *s = &amp;trdSlices[plane*ns];</span>
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;ns; i++, s++) if((*s)&gt;0.) q+=(*s);</span>
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :   return q/ns;</span>
<span class="lineNum">     762 </span><span class="lineNoCov">          0 : }</span>
<a name="763"><span class="lineNum">     763 </span>            : </a>
<span class="lineNum">     764 </span>            : //______________________________________________________________________________
<span class="lineNum">     765 </span>            : UChar_t AliAODTrack::GetTRDntrackletsPID() const{
<span class="lineNum">     766 </span>            :   //
<span class="lineNum">     767 </span>            :   // return number of tracklets calculated from the slices
<span class="lineNum">     768 </span>            :   //
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :   if(!fDetPid) return -1;</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :   return fDetPid-&gt;GetTRDntrackletsPID();</span>
<span class="lineNum">     771 </span><span class="lineNoCov">          0 : }</span>
<a name="772"><span class="lineNum">     772 </span>            : </a>
<span class="lineNum">     773 </span>            : //______________________________________________________________________________
<span class="lineNum">     774 </span>            : UChar_t AliAODTrack::GetTRDncls(Int_t layer) const {
<span class="lineNum">     775 </span>            :   // 
<span class="lineNum">     776 </span>            :   // return number of TRD clusters
<span class="lineNum">     777 </span>            :   //
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :   if(!fDetPid || layer &gt; 5) return -1;</span>
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :   if(layer &lt; 0) return fDetPid-&gt;GetTRDncls();</span>
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :   else return fDetPid-&gt;GetTRDncls(layer);</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 : }</span>
<a name="782"><span class="lineNum">     782 </span>            : </a>
<span class="lineNum">     783 </span>            : //______________________________________________________________________________
<span class="lineNum">     784 </span>            : Double_t AliAODTrack::GetTRDmomentum(Int_t plane, Double_t */*sp*/) const
<span class="lineNum">     785 </span>            : {
<span class="lineNum">     786 </span>            :   //Returns momentum estimation
<span class="lineNum">     787 </span>            :   // in TRD layer &quot;plane&quot;.
<span class="lineNum">     788 </span>            : 
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :   if (!fDetPid) return -1;</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :   const Double_t *trdMomentum=fDetPid-&gt;GetTRDmomentum();</span>
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :   if (!trdMomentum) {</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :     return -1.;</span>
<span class="lineNum">     794 </span>            :   }
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :   if ((plane&lt;0) || (plane&gt;=kTRDnPlanes)) {</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :     return -1.;</span>
<span class="lineNum">     797 </span>            :   }
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :   return trdMomentum[plane];</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 : }</span>
<a name="801"><span class="lineNum">     801 </span>            : </a>
<span class="lineNum">     802 </span>            : //_______________________________________________________________________
<span class="lineNum">     803 </span>            : Int_t AliAODTrack::GetTOFBunchCrossing(Double_t b, Bool_t) const 
<span class="lineNum">     804 </span>            : {
<span class="lineNum">     805 </span>            :   // Returns the number of bunch crossings after trigger (assuming 25ns spacing)
<span class="lineNum">     806 </span>            :   const double kSpacing = 25e3; // min interbanch spacing
<span class="lineNum">     807 </span>            :   const double kShift = 0;
<span class="lineNum">     808 </span>            :   Int_t bcid = kTOFBCNA; // defualt one
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :   if (!IsOn(kTOFout) || !IsOn(kESDpid)) return bcid; // no info</span>
<span class="lineNum">     810 </span>            :   //
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :   double tdif = GetTOFsignal();</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :   if (IsOn(kTIME)) { // integrated time info is there</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :     int pid = (int)GetMostProbablePID();</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :     double ttimes[10]; </span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :     GetIntegratedTimes(ttimes, pid&gt;=AliPID::kSPECIES ? AliPID::kSPECIESC : AliPID::kSPECIES);</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :     tdif -= ttimes[pid];</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     818 </span>            :   else { // assume integrated time info from TOF radius and momentum
<span class="lineNum">     819 </span>            :     const double kRTOF = 385.;
<span class="lineNum">     820 </span>            :     const double kCSpeed = 3.e-2; // cm/ps
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :     double p = P();</span>
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :     if (p&lt;0.001) p = 1.0;</span>
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :     double m = M();</span>
<span class="lineNum">     824 </span>            :     double path =  kRTOF;     // mean TOF radius
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :     if (TMath::Abs(b)&gt;kAlmost0) {  // account for curvature</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :       double curv = Pt()/(b*kB2C);</span>
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :       if (curv&gt;kAlmost0) {</span>
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :         double tgl = Pz()/Pt();</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :         path = 2./curv*TMath::ASin(kRTOF*curv/2.)*TMath::Sqrt(1.+tgl*tgl);</span>
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :     tdif -= path/kCSpeed*TMath::Sqrt(1.+m*m/(p*p));</span>
<span class="lineNum">     833 </span>            :   }
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :   bcid = TMath::Nint((tdif - kShift)/kSpacing);</span>
<span class="lineNum">     835 </span>            :   return bcid;
<a name="836"><span class="lineNum">     836 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     837 </span>            : 
<span class="lineNum">     838 </span>            : void AliAODTrack::SetDetectorPID(const AliDetectorPID *pid)
<span class="lineNum">     839 </span>            : {
<span class="lineNum">     840 </span>            :   //
<span class="lineNum">     841 </span>            :   // Set the detector PID
<span class="lineNum">     842 </span>            :   //
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :   if (fDetectorPID) delete fDetectorPID;</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :   fDetectorPID=pid;</span>
<span class="lineNum">     845 </span>            :   
<span class="lineNum">     846 </span><span class="lineNoCov">          0 : }</span>
<a name="847"><span class="lineNum">     847 </span>            : </a>
<span class="lineNum">     848 </span>            : //_____________________________________________________________________________
<span class="lineNum">     849 </span>            : Double_t AliAODTrack::GetHMPIDsignal() const
<span class="lineNum">     850 </span>            : {
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :   if(fAODEvent-&gt;GetHMPIDringForTrackID(fID)) return fAODEvent-&gt;GetHMPIDringForTrackID(fID)-&gt;GetHmpSignal();</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :   else return -999.;</span>
<span class="lineNum">     853 </span><span class="lineNoCov">          0 : }</span>
<a name="854"><span class="lineNum">     854 </span>            : </a>
<span class="lineNum">     855 </span>            : //_____________________________________________________________________________
<span class="lineNum">     856 </span>            : Double_t AliAODTrack::GetHMPIDoccupancy() const
<span class="lineNum">     857 </span>            : {
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :   if(fAODEvent-&gt;GetHMPIDringForTrackID(fID)) return fAODEvent-&gt;GetHMPIDringForTrackID(fID)-&gt;GetHmpOccupancy();</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :   else return -999.;</span>
<span class="lineNum">     860 </span><span class="lineNoCov">          0 : }</span>
<a name="861"><span class="lineNum">     861 </span>            : </a>
<span class="lineNum">     862 </span>            : //_____________________________________________________________________________
<span class="lineNum">     863 </span>            : Int_t AliAODTrack::GetHMPIDcluIdx() const
<span class="lineNum">     864 </span>            : {
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :   if(fAODEvent-&gt;GetHMPIDringForTrackID(fID)) return fAODEvent-&gt;GetHMPIDringForTrackID(fID)-&gt;GetHmpCluIdx();</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :   else return -999;</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 : }</span>
<a name="868"><span class="lineNum">     868 </span>            : </a>
<span class="lineNum">     869 </span>            : //_____________________________________________________________________________
<span class="lineNum">     870 </span>            : void AliAODTrack::GetHMPIDtrk(Float_t &amp;x, Float_t &amp;y, Float_t &amp;th, Float_t &amp;ph) const
<span class="lineNum">     871 </span>            : {
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :   x = -999; y = -999.; th = -999.; ph = -999.;</span>
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :   const AliAODHMPIDrings *ring=fAODEvent-&gt;GetHMPIDringForTrackID(fID);</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :   if(ring){</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :     x  = ring-&gt;GetHmpTrackX();</span>
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :     y  = ring-&gt;GetHmpTrackY();</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :     th = ring-&gt;GetHmpTrackTheta();</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :     ph = ring-&gt;GetHmpTrackPhi();</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 : }</span>
<a name="882"><span class="lineNum">     882 </span>            : </a>
<span class="lineNum">     883 </span>            : //_____________________________________________________________________________
<span class="lineNum">     884 </span>            : void AliAODTrack::GetHMPIDmip(Float_t &amp;x,Float_t &amp;y,Int_t &amp;q, Int_t &amp;nph) const
<span class="lineNum">     885 </span>            : {
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :   x = -999; y = -999.; q = -999; nph = -999;</span>
<span class="lineNum">     887 </span>            :   
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :   const AliAODHMPIDrings *ring=fAODEvent-&gt;GetHMPIDringForTrackID(fID);</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :   if(ring){</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :     x   = ring-&gt;GetHmpMipX();</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :     y   = ring-&gt;GetHmpMipY();</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :     q   = (Int_t)ring-&gt;GetHmpMipCharge();</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :     nph = (Int_t)ring-&gt;GetHmpNumOfPhotonClusters();</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 : }</span>
<a name="896"><span class="lineNum">     896 </span>            : </a>
<span class="lineNum">     897 </span>            : //_____________________________________________________________________________
<span class="lineNum">     898 </span>            : Bool_t AliAODTrack::GetOuterHmpPxPyPz(Double_t *p) const 
<span class="lineNum">     899 </span>            : { 
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :  if(fAODEvent-&gt;GetHMPIDringForTrackID(fID)) {fAODEvent-&gt;GetHMPIDringForTrackID(fID)-&gt;GetHmpMom(p); return kTRUE;}</span>
<span class="lineNum">     901 </span>            :  
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :  else return kFALSE;      </span>
<a name="903"><span class="lineNum">     903 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     904 </span>            : //_____________________________________________________________________________
<span class="lineNum">     905 </span>            : Bool_t AliAODTrack::GetXYZAt(Double_t x, Double_t b, Double_t *r) const
<span class="lineNum">     906 </span>            : {
<span class="lineNum">     907 </span>            :   //---------------------------------------------------------------------
<span class="lineNum">     908 </span>            :   // This function returns the global track position extrapolated to
<span class="lineNum">     909 </span>            :   // the radial position &quot;x&quot; (cm) in the magnetic field &quot;b&quot; (kG)
<span class="lineNum">     910 </span>            :   //---------------------------------------------------------------------
<span class="lineNum">     911 </span>            : 
<span class="lineNum">     912 </span>            :   //conversion of track parameter representation is
<span class="lineNum">     913 </span>            :   //based on the implementation of AliExternalTrackParam::Set(...)
<span class="lineNum">     914 </span>            :   //maybe some of this code can be moved to AliVTrack to avoid code duplication
<span class="lineNum">     915 </span>            :   Double_t alpha=0.0;
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :   Double_t radPos2 = fPosition[0]*fPosition[0]+fPosition[1]*fPosition[1];  </span>
<span class="lineNum">     917 </span>            :   Double_t radMax  = 45.; // approximately ITS outer radius
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :   if (radPos2 &lt; radMax*radMax) { // inside the ITS     </span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :     alpha = fMomentum[1]; //TMath::ATan2(fMomentum[1],fMomentum[0]); // fMom is pt,phi,theta!</span>
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :   } else { // outside the ITS</span>
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :      Float_t phiPos = TMath::Pi()+TMath::ATan2(-fPosition[1], -fPosition[0]);</span>
<span class="lineNum">     922 </span>            :      alpha = 
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :      TMath::DegToRad()*(20*((((Int_t)(phiPos*TMath::RadToDeg()))/20))+10);</span>
<span class="lineNum">     924 </span>            :   }
<span class="lineNum">     925 </span>            :   //
<span class="lineNum">     926 </span>            :   // Get the vertex of origin and the momentum
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :   TVector3 ver(fPosition[0],fPosition[1],fPosition[2]);</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :   TVector3 mom(Px(),Py(),Pz());</span>
<span class="lineNum">     929 </span>            :   //
<span class="lineNum">     930 </span>            :   // Rotate to the local coordinate system
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :   ver.RotateZ(-alpha);</span>
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :   mom.RotateZ(-alpha);</span>
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :   Double_t param0 = ver.Y();</span>
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :   Double_t param1 = ver.Z();</span>
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :   Double_t param2 = TMath::Sin(mom.Phi());</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :   Double_t param3 = mom.Pz()/mom.Pt();</span>
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :   Double_t param4 = TMath::Sign(1/mom.Pt(),(Double_t)fCharge);</span>
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span>            :   //calculate the propagated coordinates
<span class="lineNum">     941 </span>            :   //this is based on AliExternalTrackParam::GetXYZAt(Double_t x, Double_t b, Double_t *r)
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :   Double_t dx=x-ver.X();</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :   if(TMath::Abs(dx)&lt;=kAlmost0) return GetXYZ(r);</span>
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span>            :   Double_t f1=param2;
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :   Double_t f2=f1 + dx*param4*b*kB2C;</span>
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :   if (TMath::Abs(f1) &gt;= kAlmost1) return kFALSE;</span>
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :   if (TMath::Abs(f2) &gt;= kAlmost1) return kFALSE;</span>
<span class="lineNum">     950 </span>            :   
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :   Double_t r1=TMath::Sqrt((1.-f1)*(1.+f1)), r2=TMath::Sqrt((1.-f2)*(1.+f2));</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :   r[0] = x;</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :   r[1] = param0 + dx*(f1+f2)/(r1+r2);</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :   r[2] = param1 + dx*(r2 + f2*(f1+f2)/(r1+r2))*param3;//Thanks to Andrea &amp; Peter</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :   return Local2GlobalPosition(r,alpha);</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 : }</span>
<a name="957"><span class="lineNum">     957 </span>            : </a>
<span class="lineNum">     958 </span>            : //_____________________________________________________________________________
<span class="lineNum">     959 </span>            : Bool_t AliAODTrack::GetXYZatR(Double_t xr,Double_t bz, Double_t *xyz, Double_t* alpSect) const
<span class="lineNum">     960 </span>            : {
<span class="lineNum">     961 </span>            :   // This method has 3 modes of behaviour
<span class="lineNum">     962 </span>            :   // 1) xyz[3] array is provided but alpSect pointer is 0: calculate the position of track intersection 
<span class="lineNum">     963 </span>            :   //    with circle of radius xr and fill it in xyz array
<span class="lineNum">     964 </span>            :   // 2) alpSect pointer is provided: find alpha of the sector where the track reaches local coordinate xr
<span class="lineNum">     965 </span>            :   //    Note that in this case xr is NOT the radius but the local coordinate.
<span class="lineNum">     966 </span>            :   //    If the xyz array is provided, it will be filled by track lab coordinates at local X in this sector
<span class="lineNum">     967 </span>            :   // 3) Neither alpSect nor xyz pointers are provided: just check if the track reaches radius xr
<span class="lineNum">     968 </span>            :   //
<span class="lineNum">     969 </span>            :   //
<span class="lineNum">     970 </span>            :   Double_t alpha=0.0;
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :   Double_t radPos2 = fPosition[0]*fPosition[0]+fPosition[1]*fPosition[1];  </span>
<span class="lineNum">     972 </span>            :   Double_t radMax  = 45.; // approximately ITS outer radius
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :   if (radPos2 &lt; radMax*radMax) { // inside the ITS     </span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :     alpha = fMomentum[1]; //TMath::ATan2(fMomentum[1],fMomentum[0]); // fMom is pt,phi,theta!</span>
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :   } else { // outside the ITS</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :      Float_t phiPos = TMath::Pi()+TMath::ATan2(-fPosition[1], -fPosition[0]);</span>
<span class="lineNum">     977 </span>            :      alpha = 
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :      TMath::DegToRad()*(20*((((Int_t)(phiPos*TMath::RadToDeg()))/20))+10);</span>
<span class="lineNum">     979 </span>            :   }
<span class="lineNum">     980 </span>            :   //  
<span class="lineNum">     981 </span>            :   // Get the vertex of origin and the momentum
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :   TVector3 ver(fPosition[0],fPosition[1],fPosition[2]);</span>
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :   TVector3 mom(Px(),Py(),Pz());</span>
<span class="lineNum">     984 </span>            :   //
<span class="lineNum">     985 </span>            :   // Rotate to the local coordinate system
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :   ver.RotateZ(-alpha);</span>
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :   mom.RotateZ(-alpha);</span>
<span class="lineNum">     988 </span>            :   //
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :   Double_t fx = ver.X();</span>
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :   Double_t fy = ver.Y();</span>
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :   Double_t fz = ver.Z();</span>
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :   Double_t sn = TMath::Sin(mom.Phi());</span>
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :   Double_t tgl = mom.Pz()/mom.Pt();</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :   Double_t crv = TMath::Sign(1/mom.Pt(),(Double_t)fCharge)*bz*kB2C;</span>
<span class="lineNum">     995 </span>            :   //
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :   if ( (TMath::Abs(bz))&lt;kAlmost0Field ) crv=0.;</span>
<span class="lineNum">     997 </span>            :   //
<span class="lineNum">     998 </span>            :   // general circle parameterization:
<span class="lineNum">     999 </span>            :   // x = (r0+tR)cos(phi0) - tR cos(t+phi0)
<span class="lineNum">    1000 </span>            :   // y = (r0+tR)sin(phi0) - tR sin(t+phi0)
<span class="lineNum">    1001 </span>            :   // where qb is the sign of the curvature, tR is the track's signed radius and r0 
<span class="lineNum">    1002 </span>            :   // is the DCA of helix to origin
<span class="lineNum">    1003 </span>            :   //
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :   double tR = 1./crv;            // track radius signed</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :   double cs = TMath::Sqrt((1-sn)*(1+sn));</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :   double x0 = fx - sn*tR;        // helix center coordinates</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :   double y0 = fy + cs*tR;</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :   double phi0 = TMath::ATan2(y0,x0);  // angle of PCA wrt to the origin</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :   if (tR&lt;0) phi0 += TMath::Pi();</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :   if      (phi0 &gt; TMath::Pi()) phi0 -= 2.*TMath::Pi();</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :   else if (phi0 &lt;-TMath::Pi()) phi0 += 2.*TMath::Pi();</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :   double cs0 = TMath::Cos(phi0);</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :   double sn0 = TMath::Sin(phi0);</span>
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :   double r0 = x0*cs0 + y0*sn0 - tR; // DCA to origin</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :   double r2R = 1.+r0/tR;</span>
<span class="lineNum">    1016 </span>            :   //
<span class="lineNum">    1017 </span>            :   //
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :   if (r2R&lt;kAlmost0) return kFALSE;  // helix is centered at the origin, no specific intersection with other concetric circle</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :   if (!xyz &amp;&amp; !alpSect) return kTRUE;</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :   double xr2R = xr/tR;</span>
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :   double r2Ri = 1./r2R;</span>
<span class="lineNum">    1022 </span>            :   // the intersection cos(t) = [1 + (r0/tR+1)^2 - (r0/tR)^2]/[2(1+r0/tR)]
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :   double cosT = 0.5*(r2R + (1-xr2R*xr2R)*r2Ri);</span>
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :   if ( TMath::Abs(cosT)&gt;kAlmost1 ) {</span>
<span class="lineNum">    1025 </span>            :     //    printf(&quot;Does not reach : %f %f\n&quot;,r0,tR);
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :     return kFALSE; // track does not reach the radius xr</span>
<span class="lineNum">    1027 </span>            :   }
<span class="lineNum">    1028 </span>            :   //
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :   double t = TMath::ACos(cosT);</span>
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :   if (tR&lt;0) t = -t;</span>
<span class="lineNum">    1031 </span>            :   // intersection point
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :   double xyzi[3];</span>
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :   xyzi[0] = x0 - tR*TMath::Cos(t+phi0);</span>
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :   xyzi[1] = y0 - tR*TMath::Sin(t+phi0);</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :   if (xyz) { // if postition is requested, then z is needed:</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :     double t0 = TMath::ATan2(cs,-sn) - phi0;</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :     double z0 = fz - t0*tR*tgl;    </span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :     xyzi[2] = z0 + tR*t*tgl;</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :   else xyzi[2] = 0;</span>
<span class="lineNum">    1041 </span>            :   //
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :   Local2GlobalPosition(xyzi,alpha);</span>
<span class="lineNum">    1043 </span>            :   //
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :   if (xyz) {</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :     xyz[0] = xyzi[0];</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :     xyz[1] = xyzi[1];</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :     xyz[2] = xyzi[2];</span>
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1049 </span>            :   //
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :   if (alpSect) {</span>
<span class="lineNum">    1051 </span>            :     double &amp;alp = *alpSect;
<span class="lineNum">    1052 </span>            :     // determine the sector of crossing
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :     double phiPos = TMath::Pi()+TMath::ATan2(-xyzi[1],-xyzi[0]);</span>
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :     int sect = ((Int_t)(phiPos*TMath::RadToDeg()))/20;</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :     alp = TMath::DegToRad()*(20*sect+10);</span>
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :     double x2r,f1,f2,r1,r2,dx,dy2dx,yloc=0, ylocMax = xr*TMath::Tan(TMath::Pi()/18); // min max Y within sector at given X</span>
<span class="lineNum">    1057 </span>            :     //
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :     while(1) {</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :       Double_t ca=TMath::Cos(alp-alpha), sa=TMath::Sin(alp-alpha);</span>
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :       if ((cs*ca+sn*sa)&lt;0) {</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :         AliDebug(1,Form(&quot;Rotation to target sector impossible: local cos(phi) would become %.2f&quot;,cs*ca+sn*sa));</span>
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :         return kFALSE;</span>
<span class="lineNum">    1063 </span>            :       }
<span class="lineNum">    1064 </span>            :       //
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :       f1 = sn*ca - cs*sa;</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :       if (TMath::Abs(f1) &gt;= kAlmost1) {</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :         AliDebug(1,Form(&quot;Rotation to target sector impossible: local sin(phi) would become %.2f&quot;,f1));</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :         return kFALSE;</span>
<span class="lineNum">    1069 </span>            :       }
<span class="lineNum">    1070 </span>            :       //
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :       double tmpX =  fx*ca + fy*sa;</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :       double tmpY = -fx*sa + fy*ca;</span>
<span class="lineNum">    1073 </span>            :       //
<span class="lineNum">    1074 </span>            :       // estimate Y at X=xr
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :       dx=xr-tmpX;</span>
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :       x2r = crv*dx;</span>
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :       f2=f1 + x2r;</span>
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :       if (TMath::Abs(f2) &gt;= kAlmost1) {</span>
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :         AliDebug(1,Form(&quot;Propagation in target sector failed ! %.10e&quot;,f2));</span>
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :         return kFALSE;</span>
<span class="lineNum">    1081 </span>            :       }
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :       r1 = TMath::Sqrt((1.-f1)*(1.+f1));</span>
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :       r2 = TMath::Sqrt((1.-f2)*(1.+f2));</span>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :       dy2dx = (f1+f2)/(r1+r2);</span>
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :       yloc = tmpY + dx*dy2dx;</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :       if      (yloc&gt;ylocMax)  {alp += 2*TMath::Pi()/18; sect++;}</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :       else if (yloc&lt;-ylocMax) {alp -= 2*TMath::Pi()/18; sect--;}</span>
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :       else break;</span>
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :       if      (alp &gt;= TMath::Pi()) alp -= 2*TMath::Pi();</span>
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :       else if (alp &lt; -TMath::Pi()) alp += 2*TMath::Pi();</span>
<span class="lineNum">    1091 </span>            :       //      if (sect&gt;=18) sect = 0;
<span class="lineNum">    1092 </span>            :       //      if (sect&lt;=0) sect = 17;
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1094 </span>            :     //
<span class="lineNum">    1095 </span>            :     // if alpha was requested, then recalculate the position at intersection in sector
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :     if (xyz) {</span>
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :       xyz[0] = xr;</span>
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :       xyz[1] = yloc;</span>
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :       if (TMath::Abs(x2r)&lt;0.05) xyz[2] = fz + dx*(r2 + f2*dy2dx)*tgl;</span>
<span class="lineNum">    1100 </span>            :       else {
<span class="lineNum">    1101 </span>            :         // for small dx/R the linear apporximation of the arc by the segment is OK,
<span class="lineNum">    1102 </span>            :         // but at large dx/R the error is very large and leads to incorrect Z propagation
<span class="lineNum">    1103 </span>            :         // angle traversed delta = 2*asin(dist_start_end / R / 2), hence the arc is: R*deltaPhi
<span class="lineNum">    1104 </span>            :         // The dist_start_end is obtained from sqrt(dx^2+dy^2) = x/(r1+r2)*sqrt(2+f1*f2+r1*r2)
<span class="lineNum">    1105 </span>            :         // Similarly, the rotation angle in linear in dx only for dx&lt;&lt;R
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :         double chord = dx*TMath::Sqrt(1+dy2dx*dy2dx);   // distance from old position to new one</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :         double rot = 2*TMath::ASin(0.5*chord*crv); // angular difference seen from the circle center</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :         xyz[2] = fz + rot/crv*tgl;</span>
<span class="lineNum">    1109 </span>            :       }
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :       Local2GlobalPosition(xyz,alp);</span>
<span class="lineNum">    1111 </span>            :     }
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :   return kTRUE;    </span>
<span class="lineNum">    1114 </span>            :   //
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 : }</span>
<a name="1116"><span class="lineNum">    1116 </span>            : </a>
<span class="lineNum">    1117 </span>            : //_______________________________________________________
<span class="lineNum">    1118 </span>            : void  AliAODTrack::GetITSdEdxSamples(Double_t s[4]) const
<span class="lineNum">    1119 </span>            : {
<span class="lineNum">    1120 </span>            :   // get ITS dedx samples
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :   if (!fDetPid) for (int i=4;i--;) s[i]=0;</span>
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :   else          for (int i=4;i--;) s[i] = fDetPid-&gt;GetITSdEdxSample(i);</span>
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 : }</span>
<a name="1124"><span class="lineNum">    1124 </span>            : </a>
<span class="lineNum">    1125 </span>            : //_____________________________________________
<span class="lineNum">    1126 </span>            : Double_t AliAODTrack::GetMassForTracking() const
<span class="lineNum">    1127 </span>            : {
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :   int pid = fPIDForTracking;</span>
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :   if (pid&lt;AliPID::kPion) pid = AliPID::kPion;</span>
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :   double m = AliPID::ParticleMass(fPIDForTracking);</span>
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :   return (fPIDForTracking==AliPID::kHe3 || fPIDForTracking==AliPID::kAlpha) ? -m : m;</span>
<a name="1132"><span class="lineNum">    1132 </span>            : }</a>
<span class="lineNum">    1133 </span>            : //_______________________________________________________
<span class="lineNum">    1134 </span>            : const AliTOFHeader* AliAODTrack::GetTOFHeader() const {
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :   return fAODEvent-&gt;GetTOFHeader();</span>
<span class="lineNum">    1136 </span>            : }
<a name="1137"><span class="lineNum">    1137 </span>            :   </a>
<span class="lineNum">    1138 </span>            : //_______________________________________________________
<span class="lineNum">    1139 </span>            : Int_t AliAODTrack::GetNcls(Int_t idet) const
<span class="lineNum">    1140 </span>            : {
<span class="lineNum">    1141 </span>            :   // Get number of clusters by subdetector index
<span class="lineNum">    1142 </span>            :   //
<span class="lineNum">    1143 </span>            :   Int_t ncls = 0;
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :   switch(idet){</span>
<span class="lineNum">    1145 </span>            :   case 0:
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :     ncls = GetITSNcls();</span>
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    1148 </span>            :   case 1:
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :     ncls = (Int_t)GetTPCNcls();</span>
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    1151 </span>            :   case 2:
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :     ncls = (Int_t)GetTRDncls();</span>
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    1154 </span>            :   case 3:
<span class="lineNum">    1155 </span>            :     break;
<span class="lineNum">    1156 </span>            :     /*if (fTOFindex != -1)
<span class="lineNum">    1157 </span>            :       ncls = 1;*/
<span class="lineNum">    1158 </span>            :     break;
<span class="lineNum">    1159 </span>            :   case 4: //PHOS
<span class="lineNum">    1160 </span>            :     break;
<span class="lineNum">    1161 </span>            :   case 5: //HMPID
<span class="lineNum">    1162 </span>            :     break;
<span class="lineNum">    1163 </span>            :     if ((GetHMPIDcluIdx() &gt;= 0) &amp;&amp; (GetHMPIDcluIdx() &lt; 7000000)) {
<span class="lineNum">    1164 </span>            :       if ((GetHMPIDcluIdx()%1000000 != 9999) &amp;&amp; (GetHMPIDcluIdx()%1000000 != 99999)) {
<span class="lineNum">    1165 </span>            :         ncls = 1;
<span class="lineNum">    1166 </span>            :         }
<span class="lineNum">    1167 </span>            :     }    
<span class="lineNum">    1168 </span>            :     break;
<span class="lineNum">    1169 </span>            :   default:
<span class="lineNum">    1170 </span>            :     break;
<span class="lineNum">    1171 </span>            :   }
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :   return ncls;</span>
<a name="1173"><span class="lineNum">    1173 </span>            : }</a>
<a name="1174"><span class="lineNum">    1174 </span>            : </a>
<a name="1175"><span class="lineNum">    1175 </span><span class="lineNoCov">          0 : Int_t AliAODTrack::GetTrackParam         ( AliExternalTrackParam &amp; ) const {return 0;} </span></a>
<a name="1176"><span class="lineNum">    1176 </span><span class="lineNoCov">          0 : Int_t AliAODTrack::GetTrackParamRefitted ( AliExternalTrackParam &amp; ) const {return 0;} </span></a>
<a name="1177"><span class="lineNum">    1177 </span><span class="lineNoCov">          0 : Int_t AliAODTrack::GetTrackParamIp       ( AliExternalTrackParam &amp; ) const {return 0;} </span></a>
<a name="1178"><span class="lineNum">    1178 </span><span class="lineNoCov">          0 : Int_t AliAODTrack::GetTrackParamTPCInner ( AliExternalTrackParam &amp; ) const {return 0;} </span></a>
<a name="1179"><span class="lineNum">    1179 </span><span class="lineNoCov">          0 : Int_t AliAODTrack::GetTrackParamOp       ( AliExternalTrackParam &amp; ) const {return 0;} </span></a>
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 : Int_t AliAODTrack::GetTrackParamCp       ( AliExternalTrackParam &amp; ) const {return 0;} </span>
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 : Int_t AliAODTrack::GetTrackParamITSOut   ( AliExternalTrackParam &amp; ) const {return 0;} </span>
<span class="lineNum">    1182 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
