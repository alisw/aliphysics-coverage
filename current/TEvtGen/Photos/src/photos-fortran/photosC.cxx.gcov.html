<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - TEvtGen/Photos/src/photos-fortran/photosC.cxx</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">TEvtGen/Photos/src/photos-fortran</a> - photosC.cxx<span style="font-size: 80%;"> (source / <a href="photosC.cxx.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">832</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">24</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : #include &quot;Photos.h&quot;</a>
<span class="lineNum">       2 </span>            : #include &quot;forW-MEc.h&quot;
<span class="lineNum">       3 </span>            : #include &quot;forZ-MEc.h&quot;
<span class="lineNum">       4 </span>            : #include &quot;Log.h&quot;
<span class="lineNum">       5 </span>            : #include &lt;cstdio&gt;
<span class="lineNum">       6 </span>            : #include &lt;cmath&gt;
<span class="lineNum">       7 </span>            : #include &lt;iostream&gt;
<span class="lineNum">       8 </span>            : #include &quot;f_Init.h&quot;
<span class="lineNum">       9 </span>            : #include &quot;PH_HEPEVT_Interface.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;PhotosUtilities.h&quot;
<span class="lineNum">      11 </span>            : using std::cout;
<span class="lineNum">      12 </span>            : using std::endl;
<span class="lineNum">      13 </span>            : using std::max;
<span class="lineNum">      14 </span>            : using namespace Photospp;
<span class="lineNum">      15 </span>            : using namespace PhotosUtilities;
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : namespace Photospp
<span class="lineNum">      18 </span>            : {
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : // Declaration of structs defined in f_Init.h
<span class="lineNum">      21 </span>            : struct PHOSTA phosta_;
<span class="lineNum">      22 </span>            : struct PHLUPY phlupy_;
<span class="lineNum">      23 </span>            : struct TOFROM tofrom_;
<span class="lineNum">      24 </span>            : struct PHNUM  phnum_;
<span class="lineNum">      25 </span>            : struct PHOLUN pholun_;
<span class="lineNum">      26 </span>            : struct PHOREST phorest_;
<span class="lineNum">      27 </span>            : struct PHOCMS  phocms_;
<span class="lineNum">      28 </span>            : struct PHOMOM  phomom_;
<span class="lineNum">      29 </span>            : struct PHOPHS  phophs_;
<span class="lineNum">      30 </span>            : struct PHOCORWT phocorwt_;
<span class="lineNum">      31 </span>            : struct PHOPRO  phopro_;
<span class="lineNum">      32 </span>            : struct PHOCOP  phocop_;
<span class="lineNum">      33 </span>            : struct PHWT    phwt_;
<span class="lineNum">      34 </span>            : struct PHOKEY  phokey_;
<span class="lineNum">      35 </span>            : struct PHOEXP  phoexp_;
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : struct HEPEVT hep;
<span class="lineNum">      39 </span>            : struct HEPEVT pho;
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            : /** Logical function used deep inside algorithm to check if emitted
<span class="lineNum">      42 </span>            :     particles are to emit. For mother it blocks the vertex, 
<a name="43"><span class="lineNum">      43 </span>            :     but for daughters individually: bad sisters will not prevent electron to emit.</a>
<span class="lineNum">      44 </span>            :     top quark has further exception method. */
<span class="lineNum">      45 </span>            : bool F(int m, int i)
<span class="lineNum">      46 </span>            : { 
<span class="lineNum">      47 </span><span class="lineNoCov">          0 :   return Photos::IPHQRK_setQarknoEmission(0,i) &amp;&amp; (i&lt;= 41 || i&gt;100)</span>
<span class="lineNum">      48 </span><span class="lineNoCov">          0 :      &amp;&amp; i != 21 </span>
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :      &amp;&amp; i != 2101 &amp;&amp; i !=3101 &amp;&amp; i !=3201 </span>
<span class="lineNum">      50 </span><span class="lineNoCov">          0 :      &amp;&amp; i != 1103 &amp;&amp; i !=2103 &amp;&amp; i !=2203 </span>
<span class="lineNum">      51 </span><span class="lineNoCov">          0 :      &amp;&amp; i != 3103 &amp;&amp; i !=3203 &amp;&amp; i !=3303;</span>
<span class="lineNum">      52 </span>            : }
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : // --- can be used with  VARIANT A. For B use  PHINT1 or 2 --------------
<span class="lineNum">      56 </span>            : //----------------------------------------------------------------------
<span class="lineNum">      57 </span>            : //
<span class="lineNum">      58 </span>            : //    PHINT:   PHotos universal INTerference correction weight
<span class="lineNum">      59 </span>            : //
<span class="lineNum">      60 </span>            : //    Purpose:  calculates correction weight as expressed by
<span class="lineNum">      61 </span>            : //               formula (17) from CPC 79 (1994), 291. 
<span class="lineNum">      62 </span>            : //
<span class="lineNum">      63 </span>            : //    Input Parameters:  Common /PHOEVT/, with photon added.
<span class="lineNum">      64 </span>            : //                                          
<span class="lineNum">      65 </span>            : //    Output Parameters: correction weight
<span class="lineNum">      66 </span>            : //
<span class="lineNum">      67 </span>            : //    Author(s):  Z. Was, P.Golonka               Created at:  19/01/05
<span class="lineNum">      68 </span>            : //                                                Last Update: 23/06/13
<span class="lineNum">      69 </span>            : //
<a name="70"><span class="lineNum">      70 </span>            : //----------------------------------------------------------------------</a>
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            : double PHINT(int IDUM){
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            :   double PHINT2;
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :   double EPS1[4],EPS2[4],PH[4],PL[4];</span>
<span class="lineNum">      76 </span>            :   static int i=1;
<span class="lineNum">      77 </span>            :   int K,L;
<span class="lineNum">      78 </span>            :   //      DOUBLE PRECISION EMU,MCHREN,BETA,phophs_.costhg,MPASQR,XPH, XC1, XC2
<span class="lineNum">      79 </span>            :   double  XNUM1,XNUM2,XDENO,XC1,XC2;
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span>            :   //      REAL*8 PHOCHA
<span class="lineNum">      82 </span>            :   //--
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span>            :   //       Calculate polarimetric vector: ph, eps1, eps2 are orthogonal
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :   for( K=1;K&lt;=4;K++){</span>
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :     PH[K-i]= pho.phep[pho.nhep-i][K-i];</span>
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :     EPS2[K-i]=1.0;</span>
<span class="lineNum">      89 </span>            :   }
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :   PHOEPS(PH,EPS2,EPS1);</span>
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :   PHOEPS(PH,EPS1,EPS2);</span>
<span class="lineNum">      94 </span>            :     
<span class="lineNum">      95 </span>            :  
<span class="lineNum">      96 </span>            :   XNUM1=0.0;
<span class="lineNum">      97 </span>            :   XNUM2=0.0;
<span class="lineNum">      98 </span>            :   XDENO=0.0;
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :   for( K=pho.jdahep[1-i][1-i]; K&lt;=pho.nhep-1;K++){  //! or jdahep[1-i][2-i]</span>
<span class="lineNum">     101 </span>            :       
<span class="lineNum">     102 </span>            :     // momenta of charged particle in PL
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :     for( L=1;L&lt;=4;L++) PL[L-i]=pho.phep[K-i][L-i]; </span>
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            :     // scalar products: epsilon*p/k*p
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :     XC1 = - PHOCHA(pho.idhep[K-i]) * </span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :          ( PL[1-i]*EPS1[1-i] + PL[2-i]*EPS1[2-i] + PL[3-i]*EPS1[3-i] ) / </span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :          ( PH[4-i]*PL[4-i]   - PH[1-i]*PL[1-i]   - PH[2-i]*PL[2-i] - PH[3-i]*PL[3-i] );</span>
<span class="lineNum">     111 </span>            :      
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :     XC2 = - PHOCHA(pho.idhep[K-i]) * </span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :          ( PL[1-i]*EPS2[1-i] + PL[2-i]*EPS2[2-i] + PL[3-i]*EPS2[3-i] ) / </span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :          ( PH[4-i]*PL[4-i]   - PH[1-i]*PL[1-i]   - PH[2-i]*PL[2-i] - PH[3-i]*PL[3-i] );</span>
<span class="lineNum">     115 </span>            :         
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            :     // accumulate the currents
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :     XNUM1  = XNUM1+XC1;</span>
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :     XNUM2  = XNUM2+XC2;</span>
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :     XDENO = XDENO + XC1*XC1 + XC2*XC2;</span>
<span class="lineNum">     122 </span>            :   }
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :   PHINT2=(XNUM1*XNUM1 + XNUM2*XNUM2) / XDENO;</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :   return (XNUM1*XNUM1 + XNUM2*XNUM2) / XDENO;</span>
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span>            : //----------------------------------------------------------------------
<span class="lineNum">     132 </span>            : //
<span class="lineNum">     133 </span>            : //    PHINT:   PHotos INTerference (Old version kept for tests only.
<span class="lineNum">     134 </span>            : //
<span class="lineNum">     135 </span>            : //    Purpose:  Calculates interference between emission of photons from
<span class="lineNum">     136 </span>            : //              different possible chaged daughters stored in
<span class="lineNum">     137 </span>            : //              the  HEP common /PHOEVT/.  
<span class="lineNum">     138 </span>            : //
<span class="lineNum">     139 </span>            : //    Input Parameter:    commons /PHOEVT/ /PHOMOM/ /PHOPHS/
<span class="lineNum">     140 </span>            : //    
<span class="lineNum">     141 </span>            : //
<span class="lineNum">     142 </span>            : //    Output Parameters:  
<span class="lineNum">     143 </span>            : //                        
<span class="lineNum">     144 </span>            : //
<span class="lineNum">     145 </span>            : //    Author(s):  Z. Was,                         Created at:  10/08/93
<span class="lineNum">     146 </span>            : //                                                Last Update: 15/03/99
<span class="lineNum">     147 </span>            : //
<a name="148"><span class="lineNum">     148 </span>            : //----------------------------------------------------------------------</a>
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span>            : double PHINT1(int IDUM){
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            :   double PHINT;
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            :   /*
<span class="lineNum">     155 </span>            :       DOUBLE PRECISION phomom_.mchsqr,phomom_.mnesqr
<span class="lineNum">     156 </span>            :       REAL*8 PNEUTR
<span class="lineNum">     157 </span>            :       COMMON/PHOMOM/phomom_.mchsqr,phomom_.mnesqr,PNEUTR(5)
<span class="lineNum">     158 </span>            :       DOUBLE PRECISION phophs_.costhg,SINTHG
<span class="lineNum">     159 </span>            :       REAL*8 XPHMAX,phophs_.xphoto
<span class="lineNum">     160 </span>            :       COMMON/PHOPHS/XPHMAX,phophs_.xphoto,phophs_.costhg,SINTHG
<span class="lineNum">     161 </span>            : 
<span class="lineNum">     162 </span>            :   */
<span class="lineNum">     163 </span>            :   double MPASQR,XX,BETA;
<span class="lineNum">     164 </span>            :   bool IFINT;
<span class="lineNum">     165 </span>            :   int K,IDENT; 
<span class="lineNum">     166 </span>            :   static int i=1;
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :   IDENT=pho.nhep;</span>
<span class="lineNum">     168 </span>            :   //
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :   for(K=pho.jdahep[1-i][2-i]; K&gt;=pho.jdahep[1-i][1-i];K--){</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :     if(pho.idhep[K-i]!=22){</span>
<span class="lineNum">     171 </span>            :       IDENT=K;
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     173 </span>            :     }
<span class="lineNum">     174 </span>            :   }
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            :   // check if there is a photon
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :   IFINT= pho.nhep&gt;IDENT;</span>
<span class="lineNum">     178 </span>            :   // check if it is two body + gammas reaction
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :   IFINT= IFINT &amp;&amp; (IDENT-pho.jdahep[1-i][1-i])==1;</span>
<span class="lineNum">     180 </span>            :   // check if two body was particle antiparticle
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :   IFINT= IFINT &amp;&amp; pho.idhep[pho.jdahep[1-i][1-i]-i] == -pho.idhep[IDENT-i];</span>
<span class="lineNum">     182 </span>            :   // check if particles were charged
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :   IFINT= IFINT &amp;&amp; PHOCHA(pho.idhep[IDENT-i]) != 0;</span>
<span class="lineNum">     184 </span>            :   // calculates interference weight contribution
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :   if(IFINT){</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :     MPASQR = pho.phep[1-i][5-i]*pho.phep[1-i][5-i];</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :     XX=4.0*phomom_.mchsqr/MPASQR*(1.0-phophs_.xphoto)/(1.0-phophs_.xphoto+(phomom_.mchsqr-phomom_.mnesqr)/MPASQR)/(1.0-phophs_.xphoto+(phomom_.mchsqr-phomom_.mnesqr)/MPASQR);</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :     BETA=sqrt(1.0-XX);</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :     PHINT  = 2.0/(1.0+phophs_.costhg*phophs_.costhg*BETA*BETA);</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     191 </span>            :   else{
<span class="lineNum">     192 </span>            :     PHINT  = 1.0;
<span class="lineNum">     193 </span>            :   }
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :   return  PHINT;</span>
<span class="lineNum">     196 </span>            : }
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span>            : //----------------------------------------------------------------------
<span class="lineNum">     200 </span>            : //
<span class="lineNum">     201 </span>            : //    PHINT:   PHotos INTerference
<span class="lineNum">     202 </span>            : //
<span class="lineNum">     203 </span>            : //    Purpose:  Calculates interference between emission of photons from
<span class="lineNum">     204 </span>            : //              different possible chaged daughters stored in
<span class="lineNum">     205 </span>            : //              the  HEP common /PHOEVT/. 
<span class="lineNum">     206 </span>            : //
<span class="lineNum">     207 </span>            : //    Input Parameter:    commons /PHOEVT/ /PHOMOM/ /PHOPHS/
<span class="lineNum">     208 </span>            : //    
<span class="lineNum">     209 </span>            : //
<span class="lineNum">     210 </span>            : //    Output Parameters:  
<span class="lineNum">     211 </span>            : //                        
<span class="lineNum">     212 </span>            : //
<span class="lineNum">     213 </span>            : //    Author(s):  Z. Was,                         Created at:  10/08/93
<span class="lineNum">     214 </span>            : //                                                Last Update: 
<span class="lineNum">     215 </span>            : //
<a name="216"><span class="lineNum">     216 </span>            : //----------------------------------------------------------------------</a>
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span>            : double PHINT2(int IDUM){
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span>            :   /*
<span class="lineNum">     222 </span>            :       DOUBLE PRECISION phomom_.mchsqr,phomom_.mnesqr
<span class="lineNum">     223 </span>            :       REAL*8 PNEUTR
<span class="lineNum">     224 </span>            :       COMMON/PHOMOM/phomom_.mchsqr,phomom_.mnesqr,PNEUTR(5)
<span class="lineNum">     225 </span>            :       DOUBLE PRECISION phophs_.costhg,SINTHG
<span class="lineNum">     226 </span>            :       REAL*8 XPHMAX,phophs_.xphoto
<span class="lineNum">     227 </span>            :       COMMON/PHOPHS/XPHMAX,phophs_.xphoto,phophs_.costhg,SINTHG
<span class="lineNum">     228 </span>            :   */
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :   double MPASQR,XX,BETA,pq1[4],pq2[4],pphot[4];</span>
<span class="lineNum">     230 </span>            :   double SS,PP2,PP,E1,E2,q1,q2,costhe,PHINT;
<span class="lineNum">     231 </span>            :   bool IFINT;
<span class="lineNum">     232 </span>            :   int K,k,IDENT; 
<span class="lineNum">     233 </span>            :   static int i=1;
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :   IDENT=pho.nhep;</span>
<span class="lineNum">     235 </span>            :   //
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :   for(K=pho.jdahep[1-i][2-i]; K&gt;=pho.jdahep[1-i][1-i];K--){</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :     if(pho.idhep[K-i]!=22){</span>
<span class="lineNum">     238 </span>            :       IDENT=K;
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     240 </span>            :     }
<span class="lineNum">     241 </span>            :   }
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            :   // check if there is a photon
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :   IFINT= pho.nhep&gt;IDENT;</span>
<span class="lineNum">     245 </span>            :   // check if it is two body + gammas reaction
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :   IFINT= IFINT&amp;&amp;(IDENT-pho.jdahep[1-i][1-i])==1;</span>
<span class="lineNum">     247 </span>            :   // check if two body was particle antiparticle (we improve on it !
<span class="lineNum">     248 </span>            :   //      IFINT= IFINT.AND.pho.idhep(JDAPHO(1,1)).EQ.-pho.idhep(IDENT)
<span class="lineNum">     249 </span>            :   // check if particles were charged
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :   IFINT= IFINT&amp;&amp;fabs(PHOCHA(pho.idhep[IDENT-i]))&gt;0.01;</span>
<span class="lineNum">     251 </span>            :   // check if they have both charge
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :   IFINT= IFINT&amp;&amp;fabs(PHOCHA(pho.idhep[pho.jdahep[1-i][1-i]-i]))&gt;0.01;</span>
<span class="lineNum">     253 </span>            :   // calculates interference weight contribution
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :   if(IFINT){</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :     MPASQR = pho.phep[1-i][5-i]*pho.phep[1-i][5-i];</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :     XX=4.0*phomom_.mchsqr/MPASQR*(1.0-phophs_.xphoto)/pow(1.-phophs_.xphoto+(phomom_.mchsqr-phomom_.mnesqr)/MPASQR,2);</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :     BETA=sqrt(1.0-XX);</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :     PHINT  = 2.0/(1.0+phophs_.costhg*phophs_.costhg*BETA*BETA);</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :     SS =MPASQR*(1.0-phophs_.xphoto);</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :     PP2=((SS-phomom_.mchsqr-phomom_.mnesqr)*(SS-phomom_.mchsqr-phomom_.mnesqr)-4*phomom_.mchsqr*phomom_.mnesqr)/SS/4;</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :     PP =sqrt(PP2);</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :     E1 =sqrt(PP2+phomom_.mchsqr);</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :     E2 =sqrt(PP2+phomom_.mnesqr);</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :     PHINT= (E1+E2)*(E1+E2)/((E2+phophs_.costhg*PP)*(E2+phophs_.costhg*PP)+(E1-phophs_.costhg*PP)*(E1-phophs_.costhg*PP));</span>
<span class="lineNum">     265 </span>            :     // return PHINT;
<span class="lineNum">     266 </span>            :     //
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :     q1=PHOCHA(pho.idhep[pho.jdahep[1-i][1-i]-i]);</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :     q2=PHOCHA(pho.idhep[IDENT-i]);</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :     for( k=1;k&lt;=4;k++){</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :       pq1[k-i]=pho.phep[pho.jdahep[1-i][1-i]-i][k-i];</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :       pq2[k-i]=pho.phep[pho.jdahep[1-i][1-i]+1-i][k-i];</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :       pphot[k-i]=pho.phep[pho.nhep-i][k-i];</span>
<span class="lineNum">     273 </span>            :     }
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :     costhe=(pphot[1-i]*pq1[1-i]+pphot[2-i]*pq1[2-i]+pphot[3-i]*pq1[3-i]);</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :     costhe=costhe/sqrt(pq1[1-i]*pq1[1-i]+pq1[2-i]*pq1[2-i]+pq1[3-i]*pq1[3-i]);</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :     costhe=costhe/sqrt(pphot[1-i]*pphot[1-i]+pphot[2-i]*pphot[2-i]+pphot[3-i]*pphot[3-i]);</span>
<span class="lineNum">     277 </span>            :     //
<span class="lineNum">     278 </span>            :     // --- this IF checks whether JDAPHO(1,1) was MCH or MNE. 
<span class="lineNum">     279 </span>            :     // --- phophs_.costhg angle (and in-generation variables) may be better choice 
<span class="lineNum">     280 </span>            :     // --- than costhe. note that in the formulae below amplitudes were 
<span class="lineNum">     281 </span>            :     // --- multiplied by (E2+phophs_.costhg*PP)*(E1-phophs_.costhg*PP). 
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :     if(phophs_.costhg*costhe&gt;0){</span>
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :       PHINT= pow(q1*(E2+phophs_.costhg*PP)-q2*(E1-phophs_.costhg*PP),2)/(q1*q1*(E2+phophs_.costhg*PP)*(E2+phophs_.costhg*PP)+q2*q2*(E1-phophs_.costhg*PP)*(E1-phophs_.costhg*PP));</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     286 </span>            :     else{
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :       PHINT= pow(q1*(E1-phophs_.costhg*PP)-q2*(E2+phophs_.costhg*PP),2)/(q1*q1*(E1-phophs_.costhg*PP)*(E1-phophs_.costhg*PP)+q2*q2*(E2+phophs_.costhg*PP)*(E2+phophs_.costhg*PP));</span>
<span class="lineNum">     289 </span>            :     }
<span class="lineNum">     290 </span>            :   }
<span class="lineNum">     291 </span>            :   else{
<span class="lineNum">     292 </span>            :     PHINT  = 1.0;
<span class="lineNum">     293 </span>            :   }
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :   return PHINT;</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            : //*****************************************************************
<span class="lineNum">     299 </span>            : //*****************************************************************
<span class="lineNum">     300 </span>            : //*****************************************************************
<span class="lineNum">     301 </span>            : // beginning of the class of methods reading from  PH_HEPEVT
<span class="lineNum">     302 </span>            : //*****************************************************************
<span class="lineNum">     303 </span>            : //*****************************************************************
<span class="lineNum">     304 </span>            : //*****************************************************************
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            : //----------------------------------------------------------------------
<span class="lineNum">     308 </span>            : //
<span class="lineNum">     309 </span>            : //    PHOTOS:   PHOton radiation in decays event DuMP routine
<span class="lineNum">     310 </span>            : //
<span class="lineNum">     311 </span>            : //    Purpose:  Print event record.
<span class="lineNum">     312 </span>            : //
<span class="lineNum">     313 </span>            : //    Input Parameters:   Common /PH_HEPEVT/
<span class="lineNum">     314 </span>            : //
<span class="lineNum">     315 </span>            : //    Output Parameters:  None
<span class="lineNum">     316 </span>            : //
<span class="lineNum">     317 </span>            : //    Author(s):  B. van Eijk                     Created at:  05/06/90
<span class="lineNum">     318 </span>            : //                                                Last Update: 20/06/13
<a name="319"><span class="lineNum">     319 </span>            : //</a>
<span class="lineNum">     320 </span>            : //----------------------------------------------------------------------
<span class="lineNum">     321 </span>            : void PHODMP(){
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :   double  SUMVEC[5];</span>
<span class="lineNum">     324 </span>            :   int I,J;
<span class="lineNum">     325 </span>            :   static int i=1;
<span class="lineNum">     326 </span>            :   const char eq80[81]  = &quot;================================================================================&quot;;
<span class="lineNum">     327 </span>            :   const char X29[30] = &quot;                             &quot;;
<span class="lineNum">     328 </span>            :   const char X23[24 ]= &quot;                       &quot;;
<span class="lineNum">     329 </span>            :   const char X1[2] = &quot; &quot;;
<span class="lineNum">     330 </span>            :   const char X2[3] = &quot;  &quot;;
<span class="lineNum">     331 </span>            :   const char X3[4] = &quot;   &quot;;
<span class="lineNum">     332 </span>            :   const char X4[5] = &quot;    &quot;;
<span class="lineNum">     333 </span>            :   const char X6[7] = &quot;      &quot;;
<span class="lineNum">     334 </span>            :   const char X7[8] = &quot;       &quot;;
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :   FILE *PHLUN = stdout;</span>
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :   for(I=0;I&lt;5;I++)  SUMVEC[I]=0.0;</span>
<span class="lineNum">     338 </span>            :   //--
<span class="lineNum">     339 </span>            :   //--   Print event number...
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :   fprintf(PHLUN,&quot;%s&quot;,eq80);</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :   fprintf(PHLUN,&quot;%s Event No.: %10i\n&quot;,X29,hep.nevhep);</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :   fprintf(PHLUN,&quot;%s Particle Parameters\n&quot;,X6);</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :   fprintf(PHLUN,&quot;%s Nr %s Type %s Parent(s) %s Daughter(s) %s Px %s Py %s Pz %s E %s Inv. M.\n&quot;,X1,X3,X3,X2,X6,X7,X7,X7,X4);</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :   for(I=1;I&lt;=hep.nhep;I++){ </span>
<span class="lineNum">     345 </span>            :     //--
<span class="lineNum">     346 </span>            :     //--   For 'stable particle' calculate vector momentum sum
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :     if (hep.jdahep[I-i][1-i]==0){</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :       for(J=1; J&lt;=4;J++){</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :         SUMVEC[J-i]=SUMVEC[J-i]+hep.phep[I-i][J-i];</span>
<span class="lineNum">     350 </span>            :       }
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :       if (hep.jmohep[I-i][2-i]==0){</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :         fprintf(PHLUN,&quot;%4i %7i %s %4i %s Stable %9.2f %9.2f %9.2f %9.2f %9.2f\n&quot; ,  I,hep.idhep[I-i],X3,hep.jmohep[I-i][1-i],X7,hep.phep[I-i][1-i],hep.phep[I-i][2-i],hep.phep[I-i][3-i],hep.phep[I-i][4-i],hep.phep[I-i][5-i]);</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     354 </span>            :       else{
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :         fprintf(PHLUN,&quot;%4i %7i %4i - %4i %s Stable %9.2f %9.2f %9.2f %9.2f %9.2f\n&quot;,I,hep.idhep[I-i],hep.jmohep[I-i][1-i],hep.jmohep[I-i][2-i], X4,hep.phep[I-i][1-i],hep.phep[I-i][2-i],hep.phep[I-i][3-i],hep.phep[I-i][4-i],hep.phep[I-i][5-i]);</span>
<span class="lineNum">     356 </span>            :       }
<span class="lineNum">     357 </span>            :     }
<span class="lineNum">     358 </span>            :     else{
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :       if(hep.jmohep[I-i][2-i]==0){</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :         fprintf(PHLUN,&quot;%4i %7i %s %4i %s %4i - %4i %9.2f %9.2f %9.2f %9.2f %9.2f\n&quot; ,  I,hep.idhep[I-i],X3,hep.jmohep[I-i][1-i],X2,hep.jdahep[I-i][1-i],hep.jdahep[I-i][2-i],hep.phep[I-i][1-i],hep.phep[I-i][2-i],hep.phep[I-i][3-i],hep.phep[I-i][4-i],hep.phep[I-i][5-i]);</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     362 </span>            :       else{
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :         fprintf(PHLUN,&quot;%4i %7i %4i - %4i %4i - %4i %9.2f %9.2f %9.2f %9.2f %9.2f\n&quot;,  I,hep.idhep[I-i],hep.jmohep[I-i][1-i],hep.jmohep[I-i][2-i],hep.jdahep[I-i][1-i],hep.jdahep[I-i][2-i],hep.phep[I-i][1-i],hep.phep[I-i][2-i],hep.phep[I-i][3-i],hep.phep[I-i][4-i],hep.phep[I-i][5-i]);</span>
<span class="lineNum">     364 </span>            :       }
<span class="lineNum">     365 </span>            :     }
<span class="lineNum">     366 </span>            :   }
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :   SUMVEC[5-i]=sqrt(SUMVEC[4-i]*SUMVEC[4-i]-SUMVEC[1-i]*SUMVEC[1-i]-SUMVEC[2-i]*SUMVEC[2-i]-SUMVEC[3-i]*SUMVEC[3-i]);</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :   fprintf(PHLUN,&quot;%s  Vector Sum: %9.2f %9.2f %9.2f %9.2f %9.2f\n&quot;,X23,SUMVEC[1-i],SUMVEC[2-i],SUMVEC[3-i],SUMVEC[4-i],SUMVEC[5-i]);</span>
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            : // 9030 FORMAT(1H ,I4,I7,3X,I4,9X,'Stable',2X,5F9.2)
<span class="lineNum">     374 </span>            : //&quot;%4i %7i %s  %4i %s Stable %s  %9.2f %9.2f %9.2f %9.2f %9.2f &quot;  X3,9X,X2
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span>            :   // 9050 FORMAT(1H ,I4,I7,3X,I4,6X,I4,' - ',I4,5F9.2)
<span class="lineNum">     377 </span>            :   //&quot;%4i %7i %s  %4i %s %4i  -  %4i  %9.2f %9.2f %9.2f %9.2f %9.2f &quot;  X3,X6
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span>            :  
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span>            :   //&quot;%4i %7i %4i  -  %4i %s Stable %s  %9.2f %9.2f %9.2f %9.2f %9.2f &quot;  X5,X2
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            :  //9060 FORMAT(1H ,I4,I7,I4,' - ',I4,2X,I4,' - ',I4,5F9.2)
<span class="lineNum">     386 </span>            :   //&quot;%4i %7i %4i  -  %4i %s %4i -   %4i %9.2f %9.2f %9.2f %9.2f %9.2f &quot;  X2,
<span class="lineNum">     387 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span>            : //----------------------------------------------------------------------
<span class="lineNum">     392 </span>            : //
<span class="lineNum">     393 </span>            : //    PHLUPAB:   debugging tool
<span class="lineNum">     394 </span>            : //
<span class="lineNum">     395 </span>            : //    Purpose:  NONE, eventually may printout content of the 
<span class="lineNum">     396 </span>            : //              /PH_HEPEVT/ common
<span class="lineNum">     397 </span>            : //
<span class="lineNum">     398 </span>            : //    Input Parameters:   Common /PH_HEPEVT/ and /PHNUM/ 
<span class="lineNum">     399 </span>            : //                        latter may have number of the event. 
<span class="lineNum">     400 </span>            : //
<span class="lineNum">     401 </span>            : //    Output Parameters:  None
<span class="lineNum">     402 </span>            : //
<span class="lineNum">     403 </span>            : //    Author(s):  Z. Was                          Created at:  30/05/93
<span class="lineNum">     404 </span>            : //                                                Last Update: 20/06/13
<span class="lineNum">     405 </span>            : //
<a name="406"><span class="lineNum">     406 </span>            : //----------------------------------------------------------------------</a>
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            : void PHLUPAB(int IPOINT){
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :   char name[12] = &quot;/PH_HEPEVT/&quot;;</span>
<span class="lineNum">     410 </span>            :   int I,J;
<span class="lineNum">     411 </span>            :   static int IPOIN0=-5;
<span class="lineNum">     412 </span>            :   static int i=1;
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :   double  SUM[5];</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :   FILE *PHLUN = stdout;</span>
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :   if (IPOIN0&lt;0){</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :     IPOIN0=400000; //  ! maximal no-print point</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :     phlupy_.ipoin =IPOIN0;</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :     phlupy_.ipoinm=400001; // ! minimal no-print point</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     421 </span>            :   
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :   if (IPOINT&lt;=phlupy_.ipoinm||IPOINT&gt;=phlupy_.ipoin ) return;</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :   if ((int)phnum_.iev&lt;1000){</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :     for(I=1; I&lt;=5;I++) SUM[I-i]=0.0;</span>
<span class="lineNum">     425 </span>            :      
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :     fprintf(PHLUN,&quot;EVENT NR= %i WE ARE TESTING %s at IPOINT=%i \n&quot;,(int)phnum_.iev,name,IPOINT);</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :     fprintf(PHLUN,&quot;  ID      p_x      p_y      p_z      E        m        ID-MO_DA1 ID-MO_DA2\n&quot;);</span>
<span class="lineNum">     428 </span>            :     I=1;
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :     fprintf(PHLUN,&quot;%4i %14.9f %14.9f %14.9f %14.9f %14.9f %9i %9i\n&quot;, hep.idhep[I-i],hep.phep[1-i][I-i],hep.phep[2-i][I-i],hep.phep[3-i][I-i],hep.phep[4-i][I-i],hep.phep[5-i][I-i],hep.jdahep[1-i][I-i],hep.jdahep[2-i][I-i]);</span>
<span class="lineNum">     430 </span>            :     I=2;
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :     fprintf(PHLUN,&quot;%4i %14.9f %14.9f %14.9f %14.9f %14.9f %9i %9i\n&quot;, hep.idhep[I-i],hep.phep[1-i][I-i],hep.phep[2-i][I-i],hep.phep[3-i][I-i],hep.phep[4-i][I-i],hep.phep[5-i][I-i],hep.jdahep[1-i][I-i],hep.jdahep[2-i][I-i]);</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :     fprintf(PHLUN,&quot; \n&quot;);</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :     for(I=3;I&lt;=hep.nhep;I++){</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :       fprintf(PHLUN,&quot;%4i %14.9f %14.9f %14.9f %14.9f %14.9f %9i %9i\n&quot;, hep.idhep[I-i],hep.phep[1-i][I-i],hep.phep[2-i][I-i],hep.phep[3-i][I-i],hep.phep[4-i][I-i],hep.phep[5-i][I-i],hep.jmohep[1-i][I-i],hep.jmohep[2-i][I-i]);</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :       for(J=1;J&lt;=4;J++) SUM[J-i]=SUM[J-i]+hep.phep[J-i][I-i];</span>
<span class="lineNum">     436 </span>            :     }
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :     SUM[5-i]=sqrt(fabs(SUM[4-i]*SUM[4-i]-SUM[1-i]*SUM[1-i]-SUM[2-i]*SUM[2-i]-SUM[3-i]*SUM[3-i]));</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :     fprintf(PHLUN,&quot; SUM %14.9f %14.9f %14.9f %14.9f %14.9f\n&quot;,SUM[1-i],SUM[2-i],SUM[3-i],SUM[4-i],SUM[5-i]);</span>
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span>            :         // 10   FORMAT(1X,'  ID      ','p_x      ','p_y      ','p_z      ',
<span class="lineNum">     446 </span>            :         //$                   'E        ','m        ',
<span class="lineNum">     447 </span>            :         //$                   'ID-MO_DA1','ID-MO DA2' )
<span class="lineNum">     448 </span>            :   // 20   FORMAT(1X,I4,5(F14.9),2I9)
<span class="lineNum">     449 </span>            :   //&quot;%i4 %14.9f %14.9f %14.9f %14.9f %i9 i9&quot;
<span class="lineNum">     450 </span>            :         // 30   FORMAT(1X,' SUM',5(F14.9))
<span class="lineNum">     451 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            : 
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span>            : //----------------------------------------------------------------------
<span class="lineNum">     462 </span>            : //
<span class="lineNum">     463 </span>            : //    PHLUPA:   debugging tool
<span class="lineNum">     464 </span>            : //
<span class="lineNum">     465 </span>            : //    Purpose:  NONE, eventually may printout content of the 
<span class="lineNum">     466 </span>            : //              /PHOEVT/ common
<span class="lineNum">     467 </span>            : //
<span class="lineNum">     468 </span>            : //    Input Parameters:   Common /PHOEVT/ and /PHNUM/ 
<span class="lineNum">     469 </span>            : //                        latter may have number of the event. 
<span class="lineNum">     470 </span>            : //
<span class="lineNum">     471 </span>            : //    Output Parameters:  None
<span class="lineNum">     472 </span>            : //
<span class="lineNum">     473 </span>            : //    Author(s):  Z. Was                          Created at:  30/05/93
<span class="lineNum">     474 </span>            : //                                                Last Update: 21/06/13
<span class="lineNum">     475 </span>            : //
<a name="476"><span class="lineNum">     476 </span>            : //----------------------------------------------------------------------</a>
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            : void PHLUPA(int IPOINT){
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :   char name[9] = &quot;/PHOEVT/&quot;;</span>
<span class="lineNum">     480 </span>            :   int I,J;
<span class="lineNum">     481 </span>            :   static int IPOIN0=-5;
<span class="lineNum">     482 </span>            :   static int i=1;
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :   double  SUM[5];</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :   FILE *PHLUN = stdout;</span>
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :   if (IPOIN0&lt;0){</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :     IPOIN0=400000; //  ! maximal no-print point</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :     phlupy_.ipoin =IPOIN0;</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :     phlupy_.ipoinm=400001; // ! minimal no-print point</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     491 </span>            :   
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :   if (IPOINT&lt;=phlupy_.ipoinm||IPOINT&gt;=phlupy_.ipoin ) return;</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :   if ((int)phnum_.iev&lt;1000){</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :     for(I=1; I&lt;=5;I++) SUM[I-i]=0.0;</span>
<span class="lineNum">     495 </span>            :      
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :     fprintf(PHLUN,&quot;EVENT NR= %i WE ARE TESTING %s at IPOINT=%i \n&quot;,(int)phnum_.iev,name,IPOINT);</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :     fprintf(PHLUN,&quot;  ID      p_x      p_y      p_z      E        m        ID-MO_DA1 ID-MO_DA2\n&quot;);</span>
<span class="lineNum">     498 </span>            :     I=1;
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :     fprintf(PHLUN,&quot;%4i %14.9f %14.9f %14.9f %14.9f %14.9f %9i %9i\n&quot;, pho.idhep[I-i],pho.phep[1-i][I-i],pho.phep[2-i][I-i],pho.phep[3-i][I-i],pho.phep[4-i][I-i],pho.phep[5-i][I-i],pho.jdahep[1-i][I-i],pho.jdahep[2-i][I-i]);</span>
<span class="lineNum">     500 </span>            :     I=2;
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :     fprintf(PHLUN,&quot;%4i %14.9f %14.9f %14.9f %14.9f %14.9f %9i %9i\n&quot;, pho.idhep[I-i],pho.phep[1-i][I-i],pho.phep[2-i][I-i],pho.phep[3-i][I-i],pho.phep[4-i][I-i],pho.phep[5-i][I-i],pho.jdahep[1-i][I-i],pho.jdahep[2-i][I-i]);</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :     fprintf(PHLUN,&quot; \n&quot;);</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :     for(I=3;I&lt;=pho.nhep;I++){</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :       fprintf(PHLUN,&quot;%4i %14.9f %14.9f %14.9f %14.9f %14.9f %9i %9i\n&quot;, pho.idhep[I-i],pho.phep[1-i][I-i],pho.phep[2-i][I-i],pho.phep[3-i][I-i],pho.phep[4-i][I-i],pho.phep[5-i][I-i],pho.jmohep[1-i][I-i],pho.jmohep[2-i][I-i]);</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :       for(J=1;J&lt;=4;J++) SUM[J-i]=SUM[J-i]+pho.phep[J-i][I-i];</span>
<span class="lineNum">     506 </span>            :     }
<span class="lineNum">     507 </span>            :   
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :     SUM[5-i]=sqrt(fabs(SUM[4-i]*SUM[4-i]-SUM[1-i]*SUM[1-i]-SUM[2-i]*SUM[2-i]-SUM[3-i]*SUM[3-i]));</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :     fprintf(PHLUN,&quot; SUM %14.9f %14.9f %14.9f %14.9f %14.9f\n&quot;,SUM[1-i],SUM[2-i],SUM[3-i],SUM[4-i],SUM[5-i]);</span>
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span>            : 
<span class="lineNum">     515 </span>            :         // 10   FORMAT(1X,'  ID      ','p_x      ','p_y      ','p_z      ',
<span class="lineNum">     516 </span>            :         //$                   'E        ','m        ',
<span class="lineNum">     517 </span>            :         //$                   'ID-MO_DA1','ID-MO DA2' )
<span class="lineNum">     518 </span>            :   // 20   FORMAT(1X,I4,5(F14.9),2I9)
<span class="lineNum">     519 </span>            :   //&quot;%4i %14.9f %14.9f %14.9f %14.9f %9i %9i&quot;
<span class="lineNum">     520 </span>            :         // 30   FORMAT(1X,' SUM',5(F14.9))
<span class="lineNum">     521 </span><span class="lineNoCov">          0 : }</span>
<a name="522"><span class="lineNum">     522 </span>            : </a>
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span>            : void PHOtoRF(){
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span>            :   //      COMMON /PH_TOFROM/ QQ[4],XM,th1,fi1
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :   double PP[4],RR[4];</span>
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span>            :   int K,L;
<span class="lineNum">     531 </span>            :   static int i=1;
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :   for(K=1;K&lt;=4;K++){</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :     tofrom_.QQ[K-i]=0.0;</span>
<span class="lineNum">     535 </span>            :   }
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :   for( L=hep.jdahep[hep.jmohep[hep.nhep-i][1-i]-i][1-i];L&lt;=hep.jdahep[hep.jmohep[hep.nhep-i][1-i]-i][2-i];L++){</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :     for(K=1;K&lt;=4;K++){</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :       tofrom_.QQ[K-i]=tofrom_.QQ[K-i]+hep.phep[L-i][K-i];</span>
<span class="lineNum">     539 </span>            :     }
<span class="lineNum">     540 </span>            :   }
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :   tofrom_.XM =tofrom_.QQ[4-i]*tofrom_.QQ[4-i]-tofrom_.QQ[3-i]*tofrom_.QQ[3-i]-tofrom_.QQ[2-i]*tofrom_.QQ[2-i]-tofrom_.QQ[1-i]*tofrom_.QQ[1-i];</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :   if(tofrom_.XM&gt;0.0) tofrom_.XM=sqrt(tofrom_.XM);</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :   if(tofrom_.XM&lt;=0.0) return;</span>
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :   for(L=1;L&lt;=hep.nhep;L++){</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :     for(K=1;K&lt;=4;K++){       </span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :       PP[K-i]=hep.phep[L-i][K-i];</span>
<span class="lineNum">     548 </span>            :     }
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :     bostdq(1,tofrom_.QQ,PP,RR);</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :     for(K=1;K&lt;=4;K++){     </span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :       hep.phep[L-i][K-i]=RR[K-i];</span>
<span class="lineNum">     552 </span>            :     }
<span class="lineNum">     553 </span>            :   }
<span class="lineNum">     554 </span>            : 
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :   tofrom_.fi1=0.0;</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :   tofrom_.th1=0.0;</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :   if(fabs(hep.phep[1-i][1-i])+fabs(hep.phep[1-i][2-i])&gt;0.0) tofrom_.fi1=PHOAN1(hep.phep[1-i][1-i],hep.phep[1-i][2-i]);</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :   if(fabs(hep.phep[1-i][1-i])+fabs(hep.phep[1-i][2-i])+fabs(hep.phep[1-i][3-i])&gt;0.0)  </span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :     tofrom_.th1=PHOAN2(hep.phep[1-i][3-i],sqrt(hep.phep[1-i][1-i]*hep.phep[1-i][1-i]+hep.phep[1-i][2-i]*hep.phep[1-i][2-i]));</span>
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :   for(L=1;L&lt;=hep.nhep;L++){ </span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :     for(K=1;K&lt;=4;K++){       </span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :       RR[K-i]=hep.phep[L-i][K-i];</span>
<span class="lineNum">     564 </span>            :     }
<span class="lineNum">     565 </span>            :      
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :     PHORO3(-tofrom_.fi1,RR);</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :     PHORO2(-tofrom_.th1,RR);</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :     for(K=1;K&lt;=4;K++){     </span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :       hep.phep[L-i][K-i]=RR[K-i];</span>
<span class="lineNum">     570 </span>            :     }
<span class="lineNum">     571 </span>            :   }
<span class="lineNum">     572 </span>            :   
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :   return;</span>
<a name="574"><span class="lineNum">     574 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     575 </span>            : 
<span class="lineNum">     576 </span>            : void PHOtoLAB(){
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span>            :   //  //      REAL*8 QQ(4),XM,th1,fi1
<span class="lineNum">     579 </span>            :   //     COMMON /PH_TOFROM/ QQ,XM,th1,fi1
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :   double PP[4],RR[4];</span>
<span class="lineNum">     581 </span>            :   int K,L;
<span class="lineNum">     582 </span>            :   static int i=1;
<span class="lineNum">     583 </span>            :   
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :   if(tofrom_.XM&lt;=0.0) return;</span>
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :   for(L=1;L&lt;=hep.nhep;L++){</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :     for(K=1;K&lt;=4;K++){</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :       PP[K-i]=hep.phep[L-i][K-i];</span>
<span class="lineNum">     590 </span>            :     }
<span class="lineNum">     591 </span>            : 
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :     PHORO2( tofrom_.th1,PP);</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :     PHORO3( tofrom_.fi1,PP);</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :     bostdq(-1,tofrom_.QQ,PP,RR);</span>
<span class="lineNum">     595 </span>            : 
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :     for(K=1;K&lt;=4;K++){</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :       hep.phep[L-i][K-i]=RR[K-i];</span>
<span class="lineNum">     598 </span>            :     }
<span class="lineNum">     599 </span>            :   }
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :   return;</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span>            : 
<span class="lineNum">     607 </span>            : //             2) GENERAL INTERFACE:
<span class="lineNum">     608 </span>            : //                                      PHOTOS_GET
<span class="lineNum">     609 </span>            : //                                      PHOTOS_MAKE
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span>            : //   COMMONS:
<span class="lineNum">     613 </span>            : //   NAME     USED IN SECT. # OF OC//     Comment
<span class="lineNum">     614 </span>            : //   PHOQED   1) 2)            3      Flags whether emisson to be gen. 
<span class="lineNum">     615 </span>            : //   PHOLUN   1) 4)            6      Output device number
<span class="lineNum">     616 </span>            : //   PHOCOP   1) 3)            4      photon coupling &amp; min energy
<span class="lineNum">     617 </span>            : //   PHPICO   1) 3) 4)         5      PI &amp; 2*PI
<span class="lineNum">     618 </span>            : //   PHSEED   1) 4)            3      RN seed 
<span class="lineNum">     619 </span>            : //   PHOSTA   1) 4)            3      Status information
<span class="lineNum">     620 </span>            : //   PHOKEY   1) 2) 3)         7      Keys for nonstandard application
<span class="lineNum">     621 </span>            : //   PHOVER   1)               1      Version info for outside
<span class="lineNum">     622 </span>            : //   HEPEVT   2)               2      PDG common
<span class="lineNum">     623 </span>            : //   PH_HEPEVT2)               8      PDG common internal
<span class="lineNum">     624 </span>            : //   PHOEVT   2) 3)           10      PDG branch
<span class="lineNum">     625 </span>            : //   PHOIF    2) 3)            2      emission flags for PDG branch 
<span class="lineNum">     626 </span>            : //   PHOMOM   3)               5      param of char-neutr system
<span class="lineNum">     627 </span>            : //   PHOPHS   3)               5      photon momentum parameters
<span class="lineNum">     628 </span>            : //   PHOPRO   3)               4      var. for photon rep. (in branch)
<span class="lineNum">     629 </span>            : //   PHOCMS   2)               3      parameters of boost to branch CMS
<span class="lineNum">     630 </span>            : //   PHNUM    4)               1      event number from outside         
<span class="lineNum">     631 </span>            : //----------------------------------------------------------------------
<span class="lineNum">     632 </span>            : 
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span>            : //----------------------------------------------------------------------
<span class="lineNum">     635 </span>            : //
<span class="lineNum">     636 </span>            : //    PHOTOS_MAKE:   General search routine
<span class="lineNum">     637 </span>            : //
<span class="lineNum">     638 </span>            : //    Purpose:  Search through the /PH_HEPEVT/ standard HEP common, sta-
<span class="lineNum">     639 </span>            : //              rting from  the IPPAR-th  particle.  Whenevr  branching 
<span class="lineNum">     640 </span>            : //              point is found routine PHTYPE(IP) is called.
<span class="lineNum">     641 </span>            : //              Finally if calls on PHTYPE(IP) modified entries, common
<span class="lineNum">     642 </span>            : //               /PH_HEPEVT/ is ordered.
<span class="lineNum">     643 </span>            : //
<span class="lineNum">     644 </span>            : //    Input Parameter:    IPPAR:  Pointer   to   decaying  particle  in
<span class="lineNum">     645 </span>            : //                                /PH_HEPEVT/ and the common itself,
<span class="lineNum">     646 </span>            : //
<span class="lineNum">     647 </span>            : //    Output Parameters:  Common  /PH_HEPEVT/, either with or without 
<span class="lineNum">     648 </span>            : //                                new particles added.
<span class="lineNum">     649 </span>            : //
<span class="lineNum">     650 </span>            : //    Author(s):  Z. Was, B. van Eijk             Created at:  26/11/89
<span class="lineNum">     651 </span>            : //                                                Last Update: 30/08/93
<span class="lineNum">     652 </span>            : //
<a name="653"><span class="lineNum">     653 </span>            : //----------------------------------------------------------------------</a>
<span class="lineNum">     654 </span>            : 
<span class="lineNum">     655 </span>            : void PHOTOS_MAKE_C(int IPARR){
<span class="lineNum">     656 </span>            :   static int i=1;
<span class="lineNum">     657 </span>            :   int IPPAR,I,J,NLAST,MOTHER;
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span>            :   //--
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :   PHLUPAB(3);</span>
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span>            :   //      write(*,*) 'at poczatek'
<span class="lineNum">     663 </span>            :   //       PHODMP();
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :   IPPAR=abs(IPARR);</span>
<span class="lineNum">     665 </span>            :   //--   Store pointers for cascade treatement...
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :   NLAST=hep.nhep;</span>
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span>            : 
<span class="lineNum">     669 </span>            :   //--
<span class="lineNum">     670 </span>            :   //--   Check decay multiplicity and minimum of correctness..
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :   if ((hep.jdahep[IPPAR-i][1-i]==0)||(hep.jmohep[hep.jdahep[IPPAR-i][1-i]-i][1-i]!=IPPAR)) return;</span>
<span class="lineNum">     672 </span>            : 
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :   PHOtoRF();</span>
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span>            :   //      write(*,*) 'at przygotowany'
<span class="lineNum">     676 </span>            :   //       PHODMP();
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span>            :   //--
<span class="lineNum">     679 </span>            :   //-- single branch mode 
<span class="lineNum">     680 </span>            :   //-- IPPAR is original position where the program was called
<span class="lineNum">     681 </span>            : 
<span class="lineNum">     682 </span>            :   //-- let-s do generation
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :   PHTYPE(IPPAR);</span>
<span class="lineNum">     684 </span>            : 
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span>            :   //--   rearrange  /PH_HEPEVT/  for added particles.
<span class="lineNum">     687 </span>            :   //--   at present this may be not needed as information 
<span class="lineNum">     688 </span>            :   //--   is set at HepMC level.
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :   if (hep.nhep&gt;NLAST){</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :     for(I=NLAST+1;I&lt;=hep.nhep;I++){</span>
<span class="lineNum">     691 </span>            :       //--
<span class="lineNum">     692 </span>            :       //--   Photon mother and vertex...
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :       MOTHER=hep.jmohep[I-i][1-i];</span>
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :       hep.jdahep[MOTHER-i][2-i]=I;</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :       for( J=1;J&lt;=4;J++){</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :         hep.vhep[I-i][J-i]=hep.vhep[I-1-i][J-i];</span>
<span class="lineNum">     697 </span>            :       }
<span class="lineNum">     698 </span>            :     }
<span class="lineNum">     699 </span>            :   }
<span class="lineNum">     700 </span>            :   //      write(*,*) 'at po dzialaniu '
<span class="lineNum">     701 </span>            :   //      PHODMP();
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :   PHOtoLAB();</span>
<span class="lineNum">     703 </span>            :   //      write(*,*) 'at koniec'
<span class="lineNum">     704 </span>            :   //      PHODMP();
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :   return;</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span>            : 
<span class="lineNum">     710 </span>            : 
<span class="lineNum">     711 </span>            : //----------------------------------------------------------------------
<span class="lineNum">     712 </span>            : //
<span class="lineNum">     713 </span>            : //    PHCORK: corrects kinmatics of subbranch needed if host program
<span class="lineNum">     714 </span>            : //            produces events with the shaky momentum conservation
<span class="lineNum">     715 </span>            : //
<span class="lineNum">     716 </span>            : //    Input Parameters:   Common /PHOEVT/, MODCOR
<span class="lineNum">     717 </span>            : //                        MODCOR &gt;0 type of action
<span class="lineNum">     718 </span>            : //                               =1 no action
<span class="lineNum">     719 </span>            : //                               =2 corrects energy from mass
<span class="lineNum">     720 </span>            : //                               =3 corrects mass from energy
<span class="lineNum">     721 </span>            : //                               =4 corrects energy from mass for 
<span class="lineNum">     722 </span>            : //                                  particles up to .4 GeV mass, 
<span class="lineNum">     723 </span>            : //                                  for heavier ones corrects mass,
<span class="lineNum">     724 </span>            : //                               =5 most complete correct also of mother
<span class="lineNum">     725 </span>            : //                                  often necessary for exponentiation.
<span class="lineNum">     726 </span>            : //                               =0 execution mode 
<span class="lineNum">     727 </span>            : //
<span class="lineNum">     728 </span>            : //    Output Parameters:  corrected /PHOEVT/
<span class="lineNum">     729 </span>            : //
<span class="lineNum">     730 </span>            : //    Author(s):  P.Golonka, Z. Was               Created at:  01/02/99
<span class="lineNum">     731 </span>            : //                                                Modified  :  07/07/13
<a name="732"><span class="lineNum">     732 </span>            : //----------------------------------------------------------------------</a>
<span class="lineNum">     733 </span>            : 
<span class="lineNum">     734 </span>            : void PHCORK(int MODCOR){
<span class="lineNum">     735 </span>            :       
<span class="lineNum">     736 </span>            :   double M,P2,PX,PY,PZ,E,EN,XMS;
<span class="lineNum">     737 </span>            :   int I,K;
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :   FILE *PHLUN = stdout;</span>
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span>            :   static int MODOP=0;
<span class="lineNum">     742 </span>            :   static int IPRINT=0;
<span class="lineNum">     743 </span>            :   static double  MCUT=0.4;
<span class="lineNum">     744 </span>            :   static int i=1;
<span class="lineNum">     745 </span>            : 
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :   if(MODCOR !=0){</span>
<span class="lineNum">     747 </span>            :     //       INITIALIZATION
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :     MODOP=MODCOR;</span>
<span class="lineNum">     749 </span>            : 
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :     fprintf(PHLUN,&quot;Message from PHCORK(MODCOR):: initialization\n&quot;);</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :     if(MODOP==1) fprintf(PHLUN,&quot;MODOP=1 -- no corrections on event: DEFAULT\n&quot;);</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :     else if(MODOP==2) fprintf(PHLUN,&quot;MODOP=2 -- corrects Energy from mass\n&quot;);</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :     else if(MODOP==3) fprintf(PHLUN,&quot;MODOP=3 -- corrects mass from Energy\n&quot;);</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :     else if(MODOP==4){</span>
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :       fprintf(PHLUN,&quot;MODOP=4 -- corrects Energy from mass to Mcut\n&quot;);</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :       fprintf(PHLUN,&quot;           and mass from  energy above  Mcut\n&quot;);</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :       fprintf(PHLUN,&quot; Mcut=%6.3f GeV&quot;,MCUT);</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :     else if(MODOP==5) fprintf(PHLUN,&quot;MODOP=5 -- corrects Energy from mass+flow\n&quot;);</span>
<span class="lineNum">     760 </span>            : 
<span class="lineNum">     761 </span>            :     else{
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :       fprintf(PHLUN,&quot;PHCORK wrong MODCOR=%4i\n&quot;,MODCOR);</span>
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :       exit(-1);</span>
<span class="lineNum">     764 </span>            :     }
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     766 </span>            :   }
<span class="lineNum">     767 </span>            : 
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :   if(MODOP==0&amp;&amp;MODCOR==0){</span>
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :     fprintf(PHLUN,&quot;PHCORK lack of initialization\n&quot;);</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :     exit(-1);</span>
<span class="lineNum">     771 </span>            :   }
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span>            :   // execution mode
<span class="lineNum">     774 </span>            :   // ==============
<span class="lineNum">     775 </span>            :   // ============== 
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span>            :      
<span class="lineNum">     778 </span>            :   PX=0.0;
<span class="lineNum">     779 </span>            :   PY=0.0;
<span class="lineNum">     780 </span>            :   PZ=0.0;
<span class="lineNum">     781 </span>            :   E =0.0;
<span class="lineNum">     782 </span>            : 
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :   if    (MODOP==1){</span>
<span class="lineNum">     784 </span>            :     //     -----------------------
<span class="lineNum">     785 </span>            :     //       In this case we do nothing
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     787 </span>            :   }
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :   else if(MODOP==2){</span>
<span class="lineNum">     789 </span>            :     //     -----------------------
<span class="lineNum">     790 </span>            :     //      lets loop thru all daughters and correct their energies 
<span class="lineNum">     791 </span>            :     //      according to E^2=p^2+m^2
<span class="lineNum">     792 </span>            : 
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :     for( I=3;I&lt;=pho.nhep;I++){</span>
<span class="lineNum">     794 </span>            :          
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :       PX=PX+pho.phep[I-i][1-i];</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :       PY=PY+pho.phep[I-i][2-i];</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :       PZ=PZ+pho.phep[I-i][3-i];</span>
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :       P2=pho.phep[I-i][1-i]*pho.phep[I-i][1-i]+pho.phep[I-i][2-i]*pho.phep[I-i][2-i]+pho.phep[I-i][3-i]*pho.phep[I-i][3-i];</span>
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :       EN=sqrt( pho.phep[I-i][5-i]*pho.phep[I-i][5-i] + P2);</span>
<span class="lineNum">     802 </span>            :          
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :       if (IPRINT==1)fprintf(PHLUN,&quot;CORRECTING ENERGY OF %6i: %14.9f =&gt; %14.9f\n&quot;,I,pho.phep[I-i][4-i],EN);</span>
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :       pho.phep[I-i][4-i]=EN;</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :       E = E+pho.phep[I-i][4-i];</span>
<span class="lineNum">     807 </span>            : 
<span class="lineNum">     808 </span>            :     }
<span class="lineNum">     809 </span>            :   }
<span class="lineNum">     810 </span>            : 
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :   else if (MODOP==5){</span>
<span class="lineNum">     812 </span>            :     //     -----------------------
<span class="lineNum">     813 </span>            :     //C      lets loop thru all daughters and correct their energies 
<span class="lineNum">     814 </span>            :     //C      according to E^2=p^2+m^2
<span class="lineNum">     815 </span>            : 
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :     for( I=3;I&lt;=pho.nhep;I++){</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :       PX=PX+pho.phep[I-i][1-i];</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :       PY=PY+pho.phep[I-i][2-i];</span>
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :       PZ=PZ+pho.phep[I-i][3-i];</span>
<span class="lineNum">     820 </span>            : 
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :       P2=pho.phep[I-i][1-i]*pho.phep[I-i][1-i]+pho.phep[I-i][2-i]*pho.phep[I-i][2-i]+pho.phep[I-i][3-i]*pho.phep[I-i][3-i];</span>
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :       EN=sqrt( pho.phep[I-i][5-i]*pho.phep[I-i][5-i] + P2);</span>
<span class="lineNum">     824 </span>            :          
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :       if (IPRINT==1)fprintf(PHLUN,&quot;CORRECTING ENERGY OF %6i: %14.9f =&gt; %14.9f\n&quot;,I,pho.phep[I-i][4-i],EN);</span>
<span class="lineNum">     826 </span>            : 
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :       pho.phep[I-i][4-i]=EN;</span>
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :       E = E+pho.phep[I-i][4-i];</span>
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span>            :     }
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :     for( K=1;K&lt;=4;K++){</span>
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :       pho.phep[1-i][K-i]=0.0;</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :       for( I=3;I&lt;=pho.nhep;I++){</span>
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :         pho.phep[1-i][K-i]=pho.phep[1-i][K-i]+pho.phep[I-i][K-i];</span>
<span class="lineNum">     835 </span>            :       }
<span class="lineNum">     836 </span>            :     }
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :     XMS=sqrt(pho.phep[1-i][4-i]*pho.phep[1-i][4-i]-pho.phep[1-i][3-i]*pho.phep[1-i][3-i]-pho.phep[1-i][2-i]*pho.phep[1-i][2-i]-pho.phep[1-i][1-i]*pho.phep[1-i][1-i]);</span>
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :     pho.phep[1-i][5-i]=XMS;</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :   else if(MODOP==3){</span>
<span class="lineNum">     841 </span>            :     //     -----------------------
<span class="lineNum">     842 </span>            : 
<span class="lineNum">     843 </span>            :     //      lets loop thru all daughters and correct their masses 
<span class="lineNum">     844 </span>            :     //     according to E^2=p^2+m^2
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :     for (I=3;I&lt;=pho.nhep;I++){</span>
<span class="lineNum">     847 </span>            :          
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :       PX=PX+pho.phep[I-i][1-i];</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :       PY=PY+pho.phep[I-i][2-i];</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :       PZ=PZ+pho.phep[I-i][3-i];</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :       E = E+pho.phep[I-i][4-i];</span>
<span class="lineNum">     852 </span>            : 
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :       P2=pho.phep[I-i][1-i]*pho.phep[I-i][1-i]+pho.phep[I-i][2-i]*pho.phep[I-i][2-i]+pho.phep[I-i][3-i]*pho.phep[I-i][3-i];</span>
<span class="lineNum">     854 </span>            : 
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :       M=sqrt(fabs( pho.phep[I-i][4-i]*pho.phep[I-i][4-i] - P2));</span>
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :       if (IPRINT==1) fprintf(PHLUN,&quot;CORRECTING MASS OF %6i: %14.9f =&gt; %14.9f\n&quot;,I,pho.phep[I-i][5-i],M);</span>
<span class="lineNum">     858 </span>            : 
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :       pho.phep[I-i][5-i]=M;</span>
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span>            :     }
<span class="lineNum">     862 </span>            :       
<span class="lineNum">     863 </span>            :   }
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :  else if(MODOP==4){</span>
<span class="lineNum">     865 </span>            :    //     -----------------------
<span class="lineNum">     866 </span>            :             
<span class="lineNum">     867 </span>            :    //      lets loop thru all daughters and correct their masses 
<span class="lineNum">     868 </span>            :    //      or energies according to E^2=p^2+m^2
<span class="lineNum">     869 </span>            : 
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :     for (I=3;I&lt;=pho.nhep;I++){</span>
<span class="lineNum">     871 </span>            :          
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :       PX=PX+pho.phep[I-i][1-i];</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :       PY=PY+pho.phep[I-i][2-i];</span>
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :       PZ=PZ+pho.phep[I-i][3-i];</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :       P2=pho.phep[I-i][1-i]*pho.phep[I-i][1-i]+pho.phep[I-i][2-i]*pho.phep[I-i][2-i]+pho.phep[I-i][3-i]*pho.phep[I-i][3-i];</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :       M=sqrt(fabs( pho.phep[I-i][4-i]*pho.phep[I-i][4-i] - P2));</span>
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span>            : 
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :       if(M&gt;MCUT){</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :         if(IPRINT==1) fprintf(PHLUN,&quot;CORRECTING MASS OF %6i: %14.9f =&gt; %14.9f\n&quot;,I,pho.phep[I-i][5-i],M);</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :         pho.phep[I-i][5-i]=M;</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :         E = E+pho.phep[I-i][4-i];</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     884 </span>            :       else{
<span class="lineNum">     885 </span>            : 
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :       EN=sqrt( pho.phep[I-i][5-i]*pho.phep[I-i][5-i] + P2);</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :       if(IPRINT==1) fprintf(PHLUN,&quot;CORRECTING ENERGY OF %6i: %14.9f =&gt;% 14.9f\n&quot;,I ,pho.phep[I-i][4-i],EN);</span>
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :       pho.phep[I-i][4-i]=EN;</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :       E = E+pho.phep[I-i][4-i];</span>
<span class="lineNum">     891 </span>            :       }
<span class="lineNum">     892 </span>            :          
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span>            :     }
<span class="lineNum">     895 </span>            :  }
<span class="lineNum">     896 </span>            : 
<span class="lineNum">     897 </span>            :   //     -----
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :   if(IPRINT==1){</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :     fprintf(PHLUN,&quot;CORRECTING MOTHER&quot;);</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :     fprintf(PHLUN,&quot;PX:%14.9f =&gt;%14.9f&quot;,pho.phep[1-i][1-i],PX-pho.phep[2-i][1-i]);</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :     fprintf(PHLUN,&quot;PY:%14.9f =&gt;%14.9f&quot;,pho.phep[1-i][2-i],PY-pho.phep[2-i][2-i]);</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :     fprintf(PHLUN,&quot;PZ:%14.9f =&gt;%14.9f&quot;,pho.phep[1-i][3-i],PZ-pho.phep[2-i][3-i]);</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :     fprintf(PHLUN,&quot; E:%14.9f =&gt;%14.9f&quot;,pho.phep[1-i][4-i], E-pho.phep[2-i][4-i]);</span>
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     906 </span>            : 
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :   pho.phep[1-i][1-i]=PX-pho.phep[2-i][1-i];</span>
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :   pho.phep[1-i][2-i]=PY-pho.phep[2-i][2-i];</span>
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :   pho.phep[1-i][3-i]=PZ-pho.phep[2-i][3-i];</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :   pho.phep[1-i][4-i]=E -pho.phep[2-i][4-i];</span>
<span class="lineNum">     911 </span>            : 
<span class="lineNum">     912 </span>            : 
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :   P2=pho.phep[1-i][1-i]*pho.phep[1-i][1-i]+pho.phep[1-i][2-i]*pho.phep[1-i][2-i]+pho.phep[1-i][3-i]*pho.phep[1-i][3-i];</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :   if(pho.phep[1-i][4-i]*pho.phep[1-i][4-i]&gt;P2){</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :     M=sqrt(pho.phep[1-i][4-i]*pho.phep[1-i][4-i] - P2 );</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :     if(IPRINT==1)fprintf(PHLUN,&quot; M: %14.9f =&gt; %14.9f\n&quot;,pho.phep[1-i][5-i],M);</span>
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :     pho.phep[1-i][5-i]=M;</span>
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     919 </span>            : 
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :   PHLUPA(25);</span>
<span class="lineNum">     921 </span>            : 
<span class="lineNum">     922 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     923 </span>            : 
<span class="lineNum">     924 </span>            : 
<span class="lineNum">     925 </span>            : 
<span class="lineNum">     926 </span>            : 
<span class="lineNum">     927 </span>            : 
<span class="lineNum">     928 </span>            : 
<span class="lineNum">     929 </span>            : //----------------------------------------------------------------------
<span class="lineNum">     930 </span>            : //
<span class="lineNum">     931 </span>            : //    PHOTOS:   PHOton radiation in  decays DOing of KINematics
<span class="lineNum">     932 </span>            : //
<span class="lineNum">     933 </span>            : //    Purpose:  Starting  from   the  charged  particle energy/momentum,
<span class="lineNum">     934 </span>            : //              PNEUTR, photon  energy  fraction and photon  angle  with
<span class="lineNum">     935 </span>            : //              respect  to  the axis formed by charged particle energy/
<span class="lineNum">     936 </span>            : //              momentum  vector  and PNEUTR, scale the energy/momentum,
<span class="lineNum">     937 </span>            : //              keeping the original direction of the neutral system  in
<span class="lineNum">     938 </span>            : //              the lab. frame untouched.
<span class="lineNum">     939 </span>            : //
<span class="lineNum">     940 </span>            : //    Input Parameters:   IP:      Pointer  to   decaying  particle   in
<span class="lineNum">     941 </span>            : //                                 /PHOEVT/  and   the   common   itself
<span class="lineNum">     942 </span>            : //                        NCHARB:  pointer to the charged radiating
<span class="lineNum">     943 </span>            : //                                 daughter in /PHOEVT/.
<span class="lineNum">     944 </span>            : //                        NEUDAU:  pointer to the first neutral daughter
<span class="lineNum">     945 </span>            : //    Output Parameters:  Common /PHOEVT/, with photon added.
<span class="lineNum">     946 </span>            : //
<span class="lineNum">     947 </span>            : //    Author(s):  Z. Was, B. van Eijk             Created at:  26/11/89
<span class="lineNum">     948 </span>            : //                                                Last Update: 27/05/93
<span class="lineNum">     949 </span>            : //
<a name="950"><span class="lineNum">     950 </span>            : //----------------------------------------------------------------------</a>
<span class="lineNum">     951 </span>            : 
<span class="lineNum">     952 </span>            : void PHODO(int IP,int NCHARB,int NEUDAU){
<span class="lineNum">     953 </span>            :   static int i=1;
<span class="lineNum">     954 </span>            :   double QNEW,QOLD,EPHOTO,PMAVIR;
<span class="lineNum">     955 </span>            :   double GNEUT,DATA;
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :   double CCOSTH,SSINTH,PVEC[4],PARNE;</span>
<span class="lineNum">     957 </span>            :   double TH3,FI3,TH4,FI4,FI5,ANGLE;
<span class="lineNum">     958 </span>            :   int I,J,FIRST,LAST;
<span class="lineNum">     959 </span>            : 
<span class="lineNum">     960 </span>            :   //--
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :   EPHOTO=phophs_.xphoto*pho.phep[IP-i][5-i]/2.0;</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :   PMAVIR=sqrt(pho.phep[IP-i][5-i]*(pho.phep[IP-i][5-i]-2.0*EPHOTO));</span>
<span class="lineNum">     963 </span>            :   //--
<span class="lineNum">     964 </span>            :   //--   Reconstruct  kinematics  of  charged particle  and  neutral system
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :   phorest_.fi1=PHOAN1(phomom_.pneutr[1-i],phomom_.pneutr[2-i]);</span>
<span class="lineNum">     966 </span>            :   //--
<span class="lineNum">     967 </span>            :   //--   Choose axis along  z of  PNEUTR, calculate  angle  between x and y
<span class="lineNum">     968 </span>            :   //--   components  and z  and x-y plane and  perform Lorentz transform...
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :   phorest_.th1=PHOAN2(phomom_.pneutr[3-i],sqrt(phomom_.pneutr[1-i]*phomom_.pneutr[1-i]+phomom_.pneutr[2-i]*phomom_.pneutr[2-i]));</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :   PHORO3(-phorest_.fi1,phomom_.pneutr);</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :   PHORO2(-phorest_.th1,phomom_.pneutr);</span>
<span class="lineNum">     972 </span>            :   //--
<span class="lineNum">     973 </span>            :   //--   Take  away  photon energy from charged particle and PNEUTR !  Thus
<span class="lineNum">     974 </span>            :   //--   the onshell charged particle  decays into virtual charged particle
<span class="lineNum">     975 </span>            :   //--   and photon.  The virtual charged  particle mass becomes:
<span class="lineNum">     976 </span>            :   //--   SQRT(pho.phep[5,IP)*(pho.phep[5,IP)-2*EPHOTO)).  Construct  new PNEUTR mo-
<span class="lineNum">     977 </span>            :   //--   mentum in the rest frame of the parent:
<span class="lineNum">     978 </span>            :   //--   1) Scaling parameters...
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :   QNEW=PHOTRI(PMAVIR,phomom_.pneutr[5-i],pho.phep[NCHARB-i][5-i]);</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :   QOLD=phomom_.pneutr[3-i];</span>
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :   GNEUT=(QNEW*QNEW+QOLD*QOLD+phomom_.mnesqr)/(QNEW*QOLD+sqrt((QNEW*QNEW+phomom_.mnesqr)*(QOLD*QOLD+phomom_.mnesqr)));</span>
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :   if(GNEUT&lt;1.0){</span>
<span class="lineNum">     983 </span>            :     DATA=0.0;
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :     PHOERR(4,&quot;PHOKIN&quot;,DATA);</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :   PARNE=GNEUT-sqrt(max(GNEUT*GNEUT-1.0,0.0));</span>
<span class="lineNum">     987 </span>            :   //--
<span class="lineNum">     988 </span>            :   //--   2) ...reductive boost...
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :   PHOBO3(PARNE,phomom_.pneutr);</span>
<span class="lineNum">     990 </span>            :   //--
<span class="lineNum">     991 </span>            :   //--   ...calculate photon energy in the reduced system...
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :   pho.nhep=pho.nhep+1;</span>
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :   pho.isthep[pho.nhep-i]=1;</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :   pho.idhep[pho.nhep-i] =22;</span>
<span class="lineNum">     995 </span>            :   //--   Photon mother and daughter pointers !
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :   pho.jmohep[pho.nhep-i][1-i]=IP;</span>
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :   pho.jmohep[pho.nhep-i][2-i]=0;</span>
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :   pho.jdahep[pho.nhep-i][1-i]=0;</span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :   pho.jdahep[pho.nhep-i][2-i]=0;</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :   pho.phep[pho.nhep-i][4-i]=EPHOTO*pho.phep[IP-i][5-i]/PMAVIR;</span>
<span class="lineNum">    1001 </span>            :   //--
<span class="lineNum">    1002 </span>            :   //--   ...and photon momenta
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :   CCOSTH=-phophs_.costhg;</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :   SSINTH=phophs_.sinthg;</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :   TH3=PHOAN2(CCOSTH,SSINTH);</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :   FI3=TWOPI*Photos::randomDouble();</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :   pho.phep[pho.nhep-i][1-i]=pho.phep[pho.nhep-i][4-i]*phophs_.sinthg*cos(FI3);</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :   pho.phep[pho.nhep-i][2-i]=pho.phep[pho.nhep-i][4-i]*phophs_.sinthg*sin(FI3);</span>
<span class="lineNum">    1009 </span>            :   //--
<span class="lineNum">    1010 </span>            :   //--   Minus sign because axis opposite direction of charged particle !
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :   pho.phep[pho.nhep-i][3-i]=-pho.phep[pho.nhep-i][4-i]*phophs_.costhg;</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :   pho.phep[pho.nhep-i][5-i]=0.0;</span>
<span class="lineNum">    1013 </span>            :   //--
<span class="lineNum">    1014 </span>            :   //--   Rotate in order to get photon along z-axis
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :   PHORO3(-FI3,phomom_.pneutr);</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :   PHORO3(-FI3,pho.phep[pho.nhep-i]);</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :   PHORO2(-TH3,phomom_.pneutr);</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :   PHORO2(-TH3,pho.phep[pho.nhep-i]);</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :   ANGLE=EPHOTO/pho.phep[pho.nhep-i][4-i];</span>
<span class="lineNum">    1020 </span>            :   //--
<span class="lineNum">    1021 </span>            :   //--   Boost to the rest frame of decaying particle
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :   PHOBO3(ANGLE,phomom_.pneutr);</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :   PHOBO3(ANGLE,pho.phep[pho.nhep-i]);</span>
<span class="lineNum">    1024 </span>            :   //--
<span class="lineNum">    1025 </span>            :   //--   Back in the parent rest frame but PNEUTR not yet oriented !
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :   FI4=PHOAN1(phomom_.pneutr[1-i],phomom_.pneutr[2-i]);</span>
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :   TH4=PHOAN2(phomom_.pneutr[3-i],sqrt(phomom_.pneutr[1-i]*phomom_.pneutr[1-i]+phomom_.pneutr[2-i]*phomom_.pneutr[2-i]));</span>
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :   PHORO3(FI4,phomom_.pneutr);</span>
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :   PHORO3(FI4,pho.phep[pho.nhep-i]);</span>
<span class="lineNum">    1030 </span>            :   //--
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :   for(I=2; I&lt;=4;I++) PVEC[I-i]=0.0;</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :   PVEC[1-i]=1.0;</span>
<span class="lineNum">    1033 </span>            : 
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :   PHORO3(-FI3,PVEC);</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :   PHORO2(-TH3,PVEC);</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :   PHOBO3(ANGLE,PVEC);</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :   PHORO3(FI4,PVEC);</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :   PHORO2(-TH4,phomom_.pneutr);</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :   PHORO2(-TH4,pho.phep[pho.nhep-i]);</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :   PHORO2(-TH4,PVEC);</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :   FI5=PHOAN1(PVEC[1-i],PVEC[2-i]);</span>
<span class="lineNum">    1042 </span>            :   //--
<span class="lineNum">    1043 </span>            :   //--   Charged particle restores original direction
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :   PHORO3(-FI5,phomom_.pneutr);</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :   PHORO3(-FI5,pho.phep[pho.nhep-i]);</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :   PHORO2(phorest_.th1,phomom_.pneutr);</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :   PHORO2(phorest_.th1,pho.phep[pho.nhep-i]);</span>
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :   PHORO3(phorest_.fi1,phomom_.pneutr);</span>
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :   PHORO3(phorest_.fi1,pho.phep[pho.nhep-i]);</span>
<span class="lineNum">    1050 </span>            :   //--   See whether neutral system has multiplicity larger than 1...
<span class="lineNum">    1051 </span>            : 
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :   if((pho.jdahep[IP-i][2-i]-pho.jdahep[IP-i][1-i])&gt;1){</span>
<span class="lineNum">    1053 </span>            :     //--   Find pointers to components of 'neutral' system
<span class="lineNum">    1054 </span>            :     //--
<span class="lineNum">    1055 </span>            :     FIRST=NEUDAU;
<span class="lineNum">    1056 </span>            :     LAST=pho.jdahep[IP-i][2-i];
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :     for(I=FIRST;I&lt;=LAST;I++){</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :       if(I!=NCHARB &amp;&amp; ( pho.jmohep[I-i][1-i]==IP)){</span>
<span class="lineNum">    1059 </span>            :         //--
<span class="lineNum">    1060 </span>            :         //--   Reconstruct kinematics...
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :         PHORO3(-phorest_.fi1,pho.phep[I-i]);</span>
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :         PHORO2(-phorest_.th1,pho.phep[I-i]);</span>
<span class="lineNum">    1063 </span>            :         //--
<span class="lineNum">    1064 </span>            :         //--   ...reductive boost
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :         PHOBO3(PARNE,pho.phep[I-i]);</span>
<span class="lineNum">    1066 </span>            :         //--
<span class="lineNum">    1067 </span>            :         //--   Rotate in order to get photon along z-axis
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :         PHORO3(-FI3,pho.phep[I-i]);</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :         PHORO2(-TH3,pho.phep[I-i]);</span>
<span class="lineNum">    1070 </span>            :         //--
<span class="lineNum">    1071 </span>            :         //--   Boost to the rest frame of decaying particle
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :         PHOBO3(ANGLE,pho.phep[I-i]);</span>
<span class="lineNum">    1073 </span>            :         //--
<span class="lineNum">    1074 </span>            :         //--   Back in the parent rest-frame but PNEUTR not yet oriented.
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :         PHORO3(FI4,pho.phep[I-i]);</span>
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :         PHORO2(-TH4,pho.phep[I-i]);</span>
<span class="lineNum">    1077 </span>            :         //--
<span class="lineNum">    1078 </span>            :         //--   Charged particle restores original direction
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :         PHORO3(-FI5,pho.phep[I-i]);</span>
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :         PHORO2(phorest_.th1,pho.phep[I-i]);</span>
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :         PHORO3(phorest_.fi1,pho.phep[I-i]);</span>
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1083 </span>            :     }
<span class="lineNum">    1084 </span>            :   }
<span class="lineNum">    1085 </span>            :   else{
<span class="lineNum">    1086 </span>            :     //--
<span class="lineNum">    1087 </span>            :     //   ...only one 'neutral' particle in addition to photon!
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :     for(J=1;J&lt;=4;J++) pho.phep[NEUDAU-i][J-i]=phomom_.pneutr[J-i];</span>
<span class="lineNum">    1089 </span>            :   }
<span class="lineNum">    1090 </span>            :   //--
<span class="lineNum">    1091 </span>            :   //--   All 'neutrals' treated, fill /PHOEVT/ for charged particle...
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :   for (J=1;J&lt;=3;J++) pho.phep[NCHARB-i][J-i]=-(pho.phep[pho.nhep-i][J-i]+phomom_.pneutr[J-i]);</span>
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :                      pho.phep[NCHARB-i][4-i]=pho.phep[IP-i][5-i]-(pho.phep[pho.nhep-i][4-i]+phomom_.pneutr[4-i]);</span>
<span class="lineNum">    1094 </span>            :   //--
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1096 </span>            : 
<span class="lineNum">    1097 </span>            : 
<span class="lineNum">    1098 </span>            : //----------------------------------------------------------------------
<span class="lineNum">    1099 </span>            : //
<span class="lineNum">    1100 </span>            : //    PHOTOS:   PHOtos Boson W correction weight
<span class="lineNum">    1101 </span>            : //
<span class="lineNum">    1102 </span>            : //    Purpose:  calculates correction weight due to amplitudes of 
<span class="lineNum">    1103 </span>            : //              emission from W boson.
<span class="lineNum">    1104 </span>            : //              
<span class="lineNum">    1105 </span>            : //              
<span class="lineNum">    1106 </span>            : //              
<span class="lineNum">    1107 </span>            : //              
<span class="lineNum">    1108 </span>            : //
<span class="lineNum">    1109 </span>            : //    Input Parameters:  Common /PHOEVT/, with photon added.
<span class="lineNum">    1110 </span>            : //                       wt  to be corrected
<span class="lineNum">    1111 </span>            : //                       
<span class="lineNum">    1112 </span>            : //                       
<span class="lineNum">    1113 </span>            : //                       
<span class="lineNum">    1114 </span>            : //    Output Parameters: wt
<span class="lineNum">    1115 </span>            : //
<span class="lineNum">    1116 </span>            : //    Author(s):  G. Nanava, Z. Was               Created at:  13/03/03
<span class="lineNum">    1117 </span>            : //                                                Last Update: 08/07/13
<span class="lineNum">    1118 </span>            : //
<a name="1119"><span class="lineNum">    1119 </span>            : //----------------------------------------------------------------------</a>
<span class="lineNum">    1120 </span>            : 
<span class="lineNum">    1121 </span>            : void PHOBW(double *WT){
<span class="lineNum">    1122 </span>            :   static int i=1;
<span class="lineNum">    1123 </span>            :   int I;
<span class="lineNum">    1124 </span>            :   double EMU,MCHREN,BETA,COSTHG,MPASQR,XPH;
<span class="lineNum">    1125 </span>            :   //--
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :   if(abs(pho.idhep[1-i])==24 &amp;&amp;</span>
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :      abs(pho.idhep[pho.jdahep[1-i][1-i]-i])  &gt;=11 &amp;&amp;</span>
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :      abs(pho.idhep[pho.jdahep[1-i][1-i]-i])  &lt;=16 &amp;&amp;</span>
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :      abs(pho.idhep[pho.jdahep[1-i][1-i]+1-i])&gt;=11 &amp;&amp;</span>
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :      abs(pho.idhep[pho.jdahep[1-i][1-i]+1-i])&lt;=16   ){</span>
<span class="lineNum">    1131 </span>            : 
<span class="lineNum">    1132 </span>            :      if(
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :         abs(pho.idhep[pho.jdahep[1-i][1-i]-i])==11 ||</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :         abs(pho.idhep[pho.jdahep[1-i][1-i]-i])==13 ||</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :         abs(pho.idhep[pho.jdahep[1-i][1-i]-i])==15    ){ </span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :         I=pho.jdahep[1-i][1-i];</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :      }</span>
<span class="lineNum">    1138 </span>            :      else{
<span class="lineNum">    1139 </span>            :        I=pho.jdahep[1-i][1-i]+1;
<span class="lineNum">    1140 </span>            :      }
<span class="lineNum">    1141 </span>            :           
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :      EMU=pho.phep[I-i][4-i];</span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :      MCHREN=fabs(pow(pho.phep[I-i][4-i],2)-pow(pho.phep[I-i][3-i],2)</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :                 -pow(pho.phep[I-i][2-i],2)-pow(pho.phep[I-i][1-i],2));</span>
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :      BETA=sqrt(1.0- MCHREN/ pho.phep[I-i][4-i]/pho.phep[I-i][4-i]);</span>
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :      COSTHG=(pho.phep[I-i][3-i]*pho.phep[pho.nhep-i][3-i]+pho.phep[I-i][2-i]*pho.phep[pho.nhep-i][2-i]</span>
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :             +pho.phep[I-i][1-i]*pho.phep[pho.nhep-i][1-i])/</span>
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :      sqrt(pho.phep[I-i][3-i]*pho.phep[I-i][3-i]+pho.phep[I-i][2-i]*pho.phep[I-i][2-i]+pho.phep[I-i][1-i]*pho.phep[I-i][1-i])/</span>
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :      sqrt(pho.phep[pho.nhep-i][3-i]*pho.phep[pho.nhep-i][3-i]+pho.phep[pho.nhep-i][2-i]*pho.phep[pho.nhep-i][2-i]+pho.phep[pho.nhep-i][1-i]*pho.phep[pho.nhep-i][1-i]);</span>
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :      MPASQR=pho.phep[1-i][4-i]*pho.phep[1-i][4-i];    </span>
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :      XPH=pho.phep[pho.nhep-i][4-i];</span>
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :      *WT=(*WT)*(1-8*EMU*XPH*(1-COSTHG*BETA)*     </span>
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :            (MCHREN+2*XPH*sqrt(MPASQR))/</span>
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :             (MPASQR*MPASQR)/(1-MCHREN/MPASQR)/(4-MCHREN/MPASQR));</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1156 </span>            :   //        write(*,*) pho.idhep[1),pho.idhep[pho.jdahep[1,1)),pho.idhep[pho.jdahep[1,1)+1)
<span class="lineNum">    1157 </span>            :   //        write(*,*) emu,xph,costhg,beta,mpasqr,mchren
<span class="lineNum">    1158 </span>            : 
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1160 </span>            : 
<span class="lineNum">    1161 </span>            : 
<span class="lineNum">    1162 </span>            : 
<span class="lineNum">    1163 </span>            : //----------------------------------------------------------------------
<span class="lineNum">    1164 </span>            : //
<span class="lineNum">    1165 </span>            : //    PHOTOS:   PHOton radiation in decays control FACtor
<span class="lineNum">    1166 </span>            : //
<span class="lineNum">    1167 </span>            : //    Purpose:  This is the control function for the photon spectrum and
<span class="lineNum">    1168 </span>            : //              final weighting.  It is  called  from PHOENE for genera-
<span class="lineNum">    1169 </span>            : //              ting the raw photon energy spectrum (MODE=0) and in PHO-
<span class="lineNum">    1170 </span>            : //              COR to scale the final weight (MODE=1).  The factor con-
<span class="lineNum">    1171 </span>            : //              sists of 3 terms.  Addition of  the factor FF which mul-
<span class="lineNum">    1172 </span>            : //              tiplies PHOFAC for MODE=0 and divides PHOFAC for MODE=1,
<span class="lineNum">    1173 </span>            : //              does not affect  the results for  the MC generation.  An
<span class="lineNum">    1174 </span>            : //              appropriate choice  for FF can speed up the calculation.
<span class="lineNum">    1175 </span>            : //              Note that a too small value of FF may cause weight over-
<span class="lineNum">    1176 </span>            : //              flow in PHOCOR  and will generate a warning, halting the
<span class="lineNum">    1177 </span>            : //              execution.  PRX  should  be  included for repeated calls
<span class="lineNum">    1178 </span>            : //              for  the  same event, allowing more particles to radiate
<span class="lineNum">    1179 </span>            : //              photons.  At  the  first  call IREP=0, for  more  than 1
<span class="lineNum">    1180 </span>            : //              charged  decay  products, IREP &gt;= 1.  Thus,  PRSOFT  (no
<span class="lineNum">    1181 </span>            : //              photon radiation  probability  in  the  previous  calls)
<span class="lineNum">    1182 </span>            : //              appropriately scales the strength of the bremsstrahlung.
<span class="lineNum">    1183 </span>            : //
<span class="lineNum">    1184 </span>            : //    Input Parameters:  MODE, PROBH, XF
<span class="lineNum">    1185 </span>            : //
<span class="lineNum">    1186 </span>            : //    Output Parameter:  Function value
<span class="lineNum">    1187 </span>            : //
<span class="lineNum">    1188 </span>            : //    Author(s):  S. Jadach, Z. Was               Created at:  01/01/89
<span class="lineNum">    1189 </span>            : //                B. van Eijk, P.Golonka          Last Update: 09/07/13
<span class="lineNum">    1190 </span>            : //
<a name="1191"><span class="lineNum">    1191 </span>            : //----------------------------------------------------------------------</a>
<span class="lineNum">    1192 </span>            :  
<span class="lineNum">    1193 </span>            : double PHOFAC(int MODE){
<span class="lineNum">    1194 </span>            :   static  double FF=0.0,PRX=0.0;
<span class="lineNum">    1195 </span>            : 
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :   if(phokey_.iexp)  return 1.0;  // In case of exponentiation this routine is useles</span>
<span class="lineNum">    1197 </span>            : 
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :   if(MODE==-1){</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :     PRX=1.0;</span>
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :     FF=1.0;</span>
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :     phopro_.probh=0.0;</span>
<span class="lineNum">    1202 </span>            :   }
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :   else if (MODE==0){</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :     if(phopro_.irep==0) PRX=1.0;</span>
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 :     PRX=PRX/(1.0-phopro_.probh);</span>
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :     FF=1.0;</span>
<span class="lineNum">    1207 </span>            :     //--
<span class="lineNum">    1208 </span>            :     //--   Following options are not considered for the time being...
<span class="lineNum">    1209 </span>            :     //--   (1) Good choice, but does not save very much time:
<span class="lineNum">    1210 </span>            :     //--       FF=(1.0-sqrt(phopro_.xf)/2.0)/(1.0+sqrt(phopro_.xf)/2.0)
<span class="lineNum">    1211 </span>            :     //--   (2) Taken from the blue, but works without weight overflows...
<span class="lineNum">    1212 </span>            :     //--       FF=(1.0-phopro_.xf/(1-pow((1-sqrt(phopro_.xf)),2)))*(1+(1-sqrt(phopro_.xf))/sqrt(1-phopro_.xf))/2.0
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :     return FF*PRX;</span>
<span class="lineNum">    1214 </span>            :   }
<span class="lineNum">    1215 </span>            :   else{
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :     return 1.0/FF;</span>
<span class="lineNum">    1217 </span>            :   }
<span class="lineNum">    1218 </span>            :   
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :   return NAN;</span>
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1221 </span>            : 
<span class="lineNum">    1222 </span>            : 
<span class="lineNum">    1223 </span>            : 
<span class="lineNum">    1224 </span>            : // ###### 
<span class="lineNum">    1225 </span>            : //  replace with, 
<span class="lineNum">    1226 </span>            : // ######
<span class="lineNum">    1227 </span>            : 
<span class="lineNum">    1228 </span>            : //----------------------------------------------------------------------
<span class="lineNum">    1229 </span>            : //
<span class="lineNum">    1230 </span>            : //    PHOTOS:   PHOton radiation in decays CORrection weight from
<span class="lineNum">    1231 </span>            : //              matrix elements This version for spin 1/2 is verified for
<span class="lineNum">    1232 </span>            : //              W decay only
<span class="lineNum">    1233 </span>            : //    Purpose:  Calculate  photon  angle.  The reshaping functions  will
<span class="lineNum">    1234 </span>            : //              have  to  depend  on the spin S of the charged particle.
<span class="lineNum">    1235 </span>            : //              We define:  ME = 2 * S + 1 !
<span class="lineNum">    1236 </span>            : //              THIS IS POSSIBLY ALWAYS BETTER THAN PHOCOR()
<span class="lineNum">    1237 </span>            : //
<span class="lineNum">    1238 </span>            : //    Input Parameters:  MPASQR:  Parent mass squared,
<span class="lineNum">    1239 </span>            : //                       MCHREN:  Renormalised mass of charged system,
<span class="lineNum">    1240 </span>            : //                       ME:      2 * spin + 1 determines matrix element
<span class="lineNum">    1241 </span>            : //
<span class="lineNum">    1242 </span>            : //    Output Parameter:  Function value.
<span class="lineNum">    1243 </span>            : //
<span class="lineNum">    1244 </span>            : //    Author(s):  Z. Was, B. van Eijk, G. Nanava  Created at:  26/11/89
<span class="lineNum">    1245 </span>            : //                                                Last Update: 01/11/12
<span class="lineNum">    1246 </span>            : //
<a name="1247"><span class="lineNum">    1247 </span>            : //----------------------------------------------------------------------</a>
<span class="lineNum">    1248 </span>            : 
<span class="lineNum">    1249 </span>            : double PHOCORN(double MPASQR,double MCHREN,int ME){
<span class="lineNum">    1250 </span>            :   double wt1,wt2,wt3;
<span class="lineNum">    1251 </span>            :   double  beta0,beta1,XX,YY,DATA;
<span class="lineNum">    1252 </span>            :   double S1,PHOCOR;
<span class="lineNum">    1253 </span>            : 
<span class="lineNum">    1254 </span>            : 
<span class="lineNum">    1255 </span>            : 
<span class="lineNum">    1256 </span>            :   //--
<span class="lineNum">    1257 </span>            :   //--   Shaping (modified by ZW)...
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :   XX=4.0*phomom_.mchsqr/MPASQR*(1.0-phophs_.xphoto)/pow(1.0-phophs_.xphoto+(phomom_.mchsqr-phomom_.mnesqr)/MPASQR,2);</span>
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :   if(ME==1){</span>
<span class="lineNum">    1260 </span><span class="lineNoCov">          0 :     S1=MPASQR  * (1.0-phophs_.xphoto);</span>
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :     beta0=2*PHOTRI(1.0,sqrt(phomom_.mchsqr/MPASQR),sqrt(phomom_.mnesqr/MPASQR));</span>
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :     beta1=2*PHOTRI(1.0,sqrt(phomom_.mchsqr/S1),sqrt(phomom_.mnesqr/S1));</span>
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :     wt1= (1.0-phophs_.costhg*sqrt(1.0-MCHREN))</span>
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :        /((1.0+pow(1.0-phophs_.xphoto/phophs_.xphmax,2))/2.0)*phophs_.xphoto;             // de-presampler</span>
<span class="lineNum">    1265 </span>            :            
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :     wt2= beta1/beta0*phophs_.xphoto;                                                        //phase space jacobians</span>
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :     wt3=  beta1*beta1* (1.0-phophs_.costhg*phophs_.costhg) * (1.0-phophs_.xphoto)/phophs_.xphoto/phophs_.xphoto </span>
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :       /pow(1.0 +phomom_.mchsqr/S1-phomom_.mnesqr/S1-beta1*phophs_.costhg,2)/2.0;             // matrix element</span>
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :   else if (ME==2){</span>
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :     S1=MPASQR  * (1.0-phophs_.xphoto);</span>
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :     beta0=2*PHOTRI(1.0,sqrt(phomom_.mchsqr/MPASQR),sqrt(phomom_.mnesqr/MPASQR));</span>
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :     beta1=2*PHOTRI(1.0,sqrt(phomom_.mchsqr/S1),sqrt(phomom_.mnesqr/S1));</span>
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 :     wt1= (1.0-phophs_.costhg*sqrt(1.0-MCHREN))</span>
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :       /((1.0+pow(1.0-phophs_.xphoto/phophs_.xphmax,2))/2.0)*phophs_.xphoto;          // de-presampler</span>
<span class="lineNum">    1276 </span>            :          
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :     wt2= beta1/beta0*phophs_.xphoto;                                  // phase space jacobians</span>
<span class="lineNum">    1278 </span>            : 
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :     wt3= beta1*beta1* (1.0-phophs_.costhg*phophs_.costhg) * (1.0-phophs_.xphoto)/phophs_.xphoto/phophs_.xphoto  // matrix element</span>
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :     /pow(1.0 +phomom_.mchsqr/S1-phomom_.mnesqr/S1-beta1*phophs_.costhg,2)/2.0 ;</span>
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :     wt3=wt3*(1-phophs_.xphoto/phophs_.xphmax+0.5*pow(phophs_.xphoto/phophs_.xphmax,2))/(1-phophs_.xphoto/phophs_.xphmax);</span>
<span class="lineNum">    1282 </span>            :     //       print*,&quot;wt3=&quot;,wt3
<span class="lineNum">    1283 </span><span class="lineNoCov">          0 :     phocorwt_.phocorwt3=wt3;</span>
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :     phocorwt_.phocorwt2=wt2;</span>
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :     phocorwt_.phocorwt1=wt1;</span>
<span class="lineNum">    1286 </span>            : 
<span class="lineNum">    1287 </span>            :     //       YY=0.5D0*(1.D0-phophs_.xphoto/phophs_.xphmax+1.D0/(1.D0-phophs_.xphoto/phophs_.xphmax))
<span class="lineNum">    1288 </span>            :     //       phwt_.beta=SQRT(1.D0-XX)
<span class="lineNum">    1289 </span>            :     //       wt1=(1.D0-phophs_.costhg*SQRT(1.D0-MCHREN))/(1.D0-phophs_.costhg*phwt_.beta)
<span class="lineNum">    1290 </span>            :     //       wt2=(1.D0-XX/YY/(1.D0-phwt_.beta**2*phophs_.costhg**2))*(1.D0+phophs_.costhg*phwt_.beta)/2.D0
<span class="lineNum">    1291 </span>            :     //       wt3=1.D0
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :   else if  ((ME==3) || (ME==4) || (ME==5)){</span>
<span class="lineNum">    1294 </span>            :     YY=1.0;
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 :     phwt_.beta=sqrt(1.0-XX);</span>
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :     wt1=(1.0-phophs_.costhg*sqrt(1.0-MCHREN))/(1.0-phophs_.costhg*phwt_.beta);</span>
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 :     wt2=(1.0-XX/YY/(1.0-phwt_.beta*phwt_.beta*phophs_.costhg*phophs_.costhg))*(1.0+phophs_.costhg*phwt_.beta)/2.0;</span>
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :     wt3=(1.0+pow(1.0-phophs_.xphoto/phophs_.xphmax,2)-pow(phophs_.xphoto/phophs_.xphmax,3))/</span>
<span class="lineNum">    1299 </span>            :         (1.0+pow(1.0-phophs_.xphoto/phophs_.xphmax,2));
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1301 </span>            :   else{
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 :     DATA=(ME-1.0)/2.0;</span>
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :     PHOERR(6,&quot;PHOCORN&quot;,DATA);</span>
<span class="lineNum">    1304 </span>            :     YY=1.0;
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 :     phwt_.beta=sqrt(1.0-XX);</span>
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :     wt1=(1.0-phophs_.costhg*sqrt(1.0-MCHREN))/(1.0-phophs_.costhg*phwt_.beta);</span>
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :     wt2=(1.0-XX/YY/(1.0-phwt_.beta*phwt_.beta*phophs_.costhg*phophs_.costhg))*(1.0+phophs_.costhg*phwt_.beta)/2.0;</span>
<span class="lineNum">    1308 </span>            :     wt3=1.0;
<span class="lineNum">    1309 </span>            :   }
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :   wt2=wt2*PHOFAC(1);</span>
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 :   PHOCOR=wt1*wt2*wt3;</span>
<span class="lineNum">    1312 </span>            : 
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :   phopro_.corwt=PHOCOR;</span>
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :   if(PHOCOR&gt;1.0){</span>
<span class="lineNum">    1315 </span>            :     DATA=PHOCOR;
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :     PHOERR(3,&quot;PHOCOR&quot;,DATA);</span>
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :   return PHOCOR;</span>
<span class="lineNum">    1319 </span>            : }
<span class="lineNum">    1320 </span>            : 
<span class="lineNum">    1321 </span>            : 
<span class="lineNum">    1322 </span>            : 
<span class="lineNum">    1323 </span>            : 
<span class="lineNum">    1324 </span>            : 
<span class="lineNum">    1325 </span>            : //----------------------------------------------------------------------
<span class="lineNum">    1326 </span>            : //
<span class="lineNum">    1327 </span>            : //    PHOTOS:   PHOton radiation in decays CORrection weight from
<span class="lineNum">    1328 </span>            : //              matrix elements
<span class="lineNum">    1329 </span>            : //
<span class="lineNum">    1330 </span>            : //    Purpose:  Calculate  photon  angle.  The reshaping functions  will
<span class="lineNum">    1331 </span>            : //              have  to  depend  on the spin S of the charged particle.
<span class="lineNum">    1332 </span>            : //              We define:  ME = 2 * S + 1 !
<span class="lineNum">    1333 </span>            : //
<span class="lineNum">    1334 </span>            : //    Input Parameters:  MPASQR:  Parent mass squared,
<span class="lineNum">    1335 </span>            : //                       MCHREN:  Renormalised mass of charged system,
<span class="lineNum">    1336 </span>            : //                       ME:      2 * spin + 1 determines matrix element
<span class="lineNum">    1337 </span>            : //
<span class="lineNum">    1338 </span>            : //    Output Parameter:  Function value.
<span class="lineNum">    1339 </span>            : //
<span class="lineNum">    1340 </span>            : //    Author(s):  Z. Was, B. van Eijk             Created at:  26/11/89
<span class="lineNum">    1341 </span>            : //                                                Last Update: 21/03/93
<span class="lineNum">    1342 </span>            : //
<a name="1343"><span class="lineNum">    1343 </span>            : //----------------------------------------------------------------------</a>
<span class="lineNum">    1344 </span>            : 
<span class="lineNum">    1345 </span>            : double  PHOCOR(double MPASQR,double MCHREN,int ME){
<span class="lineNum">    1346 </span>            :   double XX,YY,DATA;
<span class="lineNum">    1347 </span>            :   double PHOC;
<span class="lineNum">    1348 </span>            :   int IscaNLO;
<span class="lineNum">    1349 </span>            : 
<span class="lineNum">    1350 </span>            :   //--
<span class="lineNum">    1351 </span>            :   //--   Shaping (modified by ZW)...
<span class="lineNum">    1352 </span><span class="lineNoCov">          0 :   XX=4.0*phomom_.mchsqr/MPASQR*(1.0-phophs_.xphoto)/pow((1.0-phophs_.xphoto+(phomom_.mchsqr-phomom_.mnesqr)/MPASQR),2);</span>
<span class="lineNum">    1353 </span><span class="lineNoCov">          0 :   if(ME==1){</span>
<span class="lineNum">    1354 </span>            :     YY=1.0;
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :     phwt_.wt3=(1.0-phophs_.xphoto/phophs_.xphmax)/((1.0+pow((1.0-phophs_.xphoto/phophs_.xphmax),2))/2.0);</span>
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1357 </span><span class="lineNoCov">          0 :   else if(ME==2){</span>
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 :     YY=0.5*(1.0-phophs_.xphoto/phophs_.xphmax+1.0/(1.0-phophs_.xphoto/phophs_.xphmax));</span>
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :     phwt_.wt3=1.0;</span>
<span class="lineNum">    1360 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1361 </span><span class="lineNoCov">          0 :   else if((ME==3)||(ME==4)||(ME==5)){</span>
<span class="lineNum">    1362 </span>            :     YY=1.0;
<span class="lineNum">    1363 </span><span class="lineNoCov">          0 :     phwt_.wt3=(1.0+pow(1.0-phophs_.xphoto/phophs_.xphmax,2)-pow(phophs_.xphoto/phophs_.xphmax,3))/</span>
<span class="lineNum">    1364 </span>            :               (1.0+pow(1.0-phophs_.xphoto/phophs_.xphmax,2)  );
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1366 </span>            :   else{
<span class="lineNum">    1367 </span><span class="lineNoCov">          0 :     DATA=(ME-1.0)/2.0;</span>
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :     PHOERR(6,&quot;PHOCOR&quot;,DATA);</span>
<span class="lineNum">    1369 </span>            :     YY=1.0;
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :     phwt_.wt3=1.0;</span>
<span class="lineNum">    1371 </span>            :   }
<span class="lineNum">    1372 </span>            : 
<span class="lineNum">    1373 </span>            : 
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :   phwt_.beta=sqrt(1.0-XX);</span>
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :   phwt_.wt1=(1.0-phophs_.costhg*sqrt(1.0-MCHREN))/(1.0-phophs_.costhg*phwt_.beta);</span>
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 :   phwt_.wt2=(1.0-XX/YY/(1.0-phwt_.beta*phwt_.beta*phophs_.costhg*phophs_.costhg))*(1.0+phophs_.costhg*phwt_.beta)/2.0;</span>
<span class="lineNum">    1377 </span>            :       
<span class="lineNum">    1378 </span>            : 
<span class="lineNum">    1379 </span><span class="lineNoCov">          0 :   IscaNLO=Photos::meCorrectionWtForScalar;</span>
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :   if(ME==1 &amp;&amp; IscaNLO ==1){  // this  switch NLO in scalar decays. </span>
<span class="lineNum">    1381 </span>            :                              // overrules default calculation.
<span class="lineNum">    1382 </span>            :                              // Need tests including basic ones
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 :     PHOC=PHOCORN(MPASQR,MCHREN,ME);</span>
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 :     phwt_.wt1=1.0;</span>
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :     phwt_.wt2=1.0;</span>
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 :     phwt_.wt3=PHOC;</span>
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1388 </span>            :   else{
<span class="lineNum">    1389 </span><span class="lineNoCov">          0 :     phwt_.wt2=phwt_.wt2*PHOFAC(1);</span>
<span class="lineNum">    1390 </span>            :   }
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :   PHOC=phwt_.wt1*phwt_.wt2*phwt_.wt3;</span>
<span class="lineNum">    1392 </span>            : 
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :   phopro_.corwt=PHOC;</span>
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 :   if(PHOC&gt;1.0){</span>
<span class="lineNum">    1395 </span>            :     DATA=PHOC;
<span class="lineNum">    1396 </span><span class="lineNoCov">          0 :     PHOERR(3,&quot;PHOCOR&quot;,DATA);</span>
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :   return PHOC;</span>
<span class="lineNum">    1399 </span>            : }
<span class="lineNum">    1400 </span>            : 
<span class="lineNum">    1401 </span>            : 
<span class="lineNum">    1402 </span>            : //----------------------------------------------------------------------
<span class="lineNum">    1403 </span>            : //
<span class="lineNum">    1404 </span>            : //    PHOTWO:   PHOtos but TWO mothers allowed
<span class="lineNum">    1405 </span>            : //
<span class="lineNum">    1406 </span>            : //    Purpose:  Combines two mothers into one in /PHOEVT/
<span class="lineNum">    1407 </span>            : //              necessary eg in case of g g (q qbar) --&gt; t tbar 
<span class="lineNum">    1408 </span>            : //
<span class="lineNum">    1409 </span>            : //    Input Parameters: Common /PHOEVT/ (/PHOCMS/)
<span class="lineNum">    1410 </span>            : //
<span class="lineNum">    1411 </span>            : //    Output Parameters:  Common /PHOEVT/, (stored mothers)
<span class="lineNum">    1412 </span>            : //
<span class="lineNum">    1413 </span>            : //    Author(s):  Z. Was                          Created at:  5/08/93
<span class="lineNum">    1414 </span>            : //                                                Last Update:10/08/93
<span class="lineNum">    1415 </span>            : //
<a name="1416"><span class="lineNum">    1416 </span>            : //----------------------------------------------------------------------</a>
<span class="lineNum">    1417 </span>            : 
<span class="lineNum">    1418 </span>            : void PHOTWO(int MODE){
<span class="lineNum">    1419 </span>            : 
<span class="lineNum">    1420 </span>            :   int I;
<span class="lineNum">    1421 </span>            :   static int i=1;
<span class="lineNum">    1422 </span>            :   double MPASQR;
<span class="lineNum">    1423 </span>            :   bool  IFRAD;
<span class="lineNum">    1424 </span>            :   // logical IFRAD is used to tag cases when two mothers may be 
<span class="lineNum">    1425 </span>            :   // merged to the sole one. 
<span class="lineNum">    1426 </span>            :   // So far used in case:
<span class="lineNum">    1427 </span>            :   //                      1) of t tbar production
<span class="lineNum">    1428 </span>            :   //
<span class="lineNum">    1429 </span>            :   // t tbar case
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :   if(MODE==0){</span>
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 :     IFRAD=(pho.idhep[1-i]==21) &amp;&amp; (pho.idhep[2-i]==21);</span>
<span class="lineNum">    1432 </span><span class="lineNoCov">          0 :     IFRAD=IFRAD || (pho.idhep[1-i]==-pho.idhep[2-i] &amp;&amp; abs(pho.idhep[1-i])&lt;=6);</span>
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :     IFRAD=IFRAD &amp;&amp; (abs(pho.idhep[3-i])==6) &amp;&amp; (abs(pho.idhep[4-i])==6);</span>
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :     MPASQR=  pow(pho.phep[1-i][4-i]+pho.phep[2-i][4-i],2)-pow(pho.phep[1-i][3-i]+pho.phep[2-i][3-i],2)</span>
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :             -pow(pho.phep[1-i][2-i]+pho.phep[2-i][2-i],2)-pow(pho.phep[1-i][1-i]+pho.phep[2-i][1-i],2);</span>
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :     IFRAD=IFRAD &amp;&amp; (MPASQR&gt;0.0);</span>
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :     if(IFRAD){</span>
<span class="lineNum">    1438 </span>            :       //.....combining first and second mother
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :       for(I=1;I&lt;=4;I++){</span>
<span class="lineNum">    1440 </span><span class="lineNoCov">          0 :         pho.phep[1-i][I-i]=pho.phep[1-i][I-i]+pho.phep[2-i][I-i];</span>
<span class="lineNum">    1441 </span>            :       }
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :       pho.phep[1-i][5-i]=sqrt(MPASQR);</span>
<span class="lineNum">    1443 </span>            :       //.....removing second mother,
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :        for(I=1;I&lt;=5;I++){</span>
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :          pho.phep[2-i][I-i]=0.0;</span>
<span class="lineNum">    1446 </span>            :        }
<span class="lineNum">    1447 </span>            :     }
<span class="lineNum">    1448 </span>            :   }
<span class="lineNum">    1449 </span>            :   else{
<span class="lineNum">    1450 </span>            :       // boosting of the mothers to the reaction frame not implemented yet.
<span class="lineNum">    1451 </span>            :       // to do it in mode 0 original mothers have to be stored in new comon (?)
<span class="lineNum">    1452 </span>            :       // and in mode 1 boosted to cms. 
<span class="lineNum">    1453 </span>            :   }
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 : } </span>
<span class="lineNum">    1455 </span>            : 
<span class="lineNum">    1456 </span>            : 
<span class="lineNum">    1457 </span>            : 
<span class="lineNum">    1458 </span>            : //----------------------------------------------------------------------
<span class="lineNum">    1459 </span>            : //
<span class="lineNum">    1460 </span>            : //    PHOTOS:   PHOtos CDE-s
<span class="lineNum">    1461 </span>            : //
<span class="lineNum">    1462 </span>            : //    Purpose:  Keep definitions  for PHOTOS QED correction Monte Carlo.
<span class="lineNum">    1463 </span>            : //
<span class="lineNum">    1464 </span>            : //    Input Parameters:   None
<span class="lineNum">    1465 </span>            : //
<span class="lineNum">    1466 </span>            : //    Output Parameters:  None
<span class="lineNum">    1467 </span>            : //
<span class="lineNum">    1468 </span>            : //    Author(s):  Z. Was, B. van Eijk             Created at:  29/11/89
<span class="lineNum">    1469 </span>            : //                                                Last Update: 10/08/93
<span class="lineNum">    1470 </span>            : //
<span class="lineNum">    1471 </span>            : // =========================================================
<span class="lineNum">    1472 </span>            : //    General Structure Information:                       =
<span class="lineNum">    1473 </span>            : // =========================================================
<span class="lineNum">    1474 </span>            : //:   ROUTINES:
<span class="lineNum">    1475 </span>            : //             1) INITIALIZATION (all in C++ now)
<span class="lineNum">    1476 </span>            : //             2) GENERAL INTERFACE:
<span class="lineNum">    1477 </span>            : //                                      PHOBOS
<span class="lineNum">    1478 </span>            : //                                      PHOIN
<span class="lineNum">    1479 </span>            : //                                      PHOTWO (specific interface
<span class="lineNum">    1480 </span>            : //                                      PHOOUT
<span class="lineNum">    1481 </span>            : //                                      PHOCHK
<span class="lineNum">    1482 </span>            : //                                      PHTYPE (specific interface
<span class="lineNum">    1483 </span>            : //                                      PHOMAK (specific interface
<span class="lineNum">    1484 </span>            : //             3) QED PHOTON GENERATION:
<span class="lineNum">    1485 </span>            : //                                      PHINT
<span class="lineNum">    1486 </span>            : //                                      PHOBW
<span class="lineNum">    1487 </span>            : //                                      PHOPRE
<span class="lineNum">    1488 </span>            : //                                      PHOOMA
<span class="lineNum">    1489 </span>            : //                                      PHOENE
<span class="lineNum">    1490 </span>            : //                                      PHOCOR
<span class="lineNum">    1491 </span>            : //                                      PHOFAC
<span class="lineNum">    1492 </span>            : //                                      PHODO
<span class="lineNum">    1493 </span>            : //             4) UTILITIES:
<span class="lineNum">    1494 </span>            : //                                      PHOTRI
<span class="lineNum">    1495 </span>            : //                                      PHOAN1
<span class="lineNum">    1496 </span>            : //                                      PHOAN2
<span class="lineNum">    1497 </span>            : //                                      PHOBO3
<span class="lineNum">    1498 </span>            : //                                      PHORO2
<span class="lineNum">    1499 </span>            : //                                      PHORO3
<span class="lineNum">    1500 </span>            : //                                      PHOCHA
<span class="lineNum">    1501 </span>            : //                                      PHOSPI
<span class="lineNum">    1502 </span>            : //                                      PHOERR
<span class="lineNum">    1503 </span>            : //                                      PHOREP
<span class="lineNum">    1504 </span>            : //                                      PHLUPA
<span class="lineNum">    1505 </span>            : //                                      PHCORK
<span class="lineNum">    1506 </span>            : //                                      IPHQRK
<span class="lineNum">    1507 </span>            : //                                      IPHEKL
<span class="lineNum">    1508 </span>            : //   COMMONS:
<span class="lineNum">    1509 </span>            : //   NAME     USED IN SECT. # OF OC//     Comment
<span class="lineNum">    1510 </span>            : //   PHOQED   1) 2)            3      Flags whether emisson to be gen. 
<span class="lineNum">    1511 </span>            : //   PHOLUN   1) 4)            6      Output device number
<span class="lineNum">    1512 </span>            : //   PHOCOP   1) 3)            4      photon coupling &amp; min energy
<span class="lineNum">    1513 </span>            : //   PHPICO   1) 3) 4)         5      PI &amp; 2*PI
<span class="lineNum">    1514 </span>            : //   PHOSTA   1) 4)            3      Status information
<span class="lineNum">    1515 </span>            : //   PHOKEY   1) 2) 3)         7      Keys for nonstandard application
<span class="lineNum">    1516 </span>            : //   PHOVER   1)               1      Version info for outside
<span class="lineNum">    1517 </span>            : //   HEPEVT   2)               2      PDG common
<span class="lineNum">    1518 </span>            : //   PH_HEPEVT2)               8      PDG common internal
<span class="lineNum">    1519 </span>            : //   PHOEVT   2) 3)           10      PDG branch
<span class="lineNum">    1520 </span>            : //   PHOIF    2) 3)            2      emission flags for PDG branch 
<span class="lineNum">    1521 </span>            : //   PHOMOM   3)               5      param of char-neutr system
<span class="lineNum">    1522 </span>            : //   PHOPHS   3)               5      photon momentum parameters
<span class="lineNum">    1523 </span>            : //   PHOPRO   3)               4      var. for photon rep. (in branch)
<span class="lineNum">    1524 </span>            : //   PHOCMS   2)               3      parameters of boost to branch CMS
<span class="lineNum">    1525 </span>            : //   PHNUM    4)               1      event number from outside         
<span class="lineNum">    1526 </span>            : //----------------------------------------------------------------------
<span class="lineNum">    1527 </span>            : 
<span class="lineNum">    1528 </span>            : 
<span class="lineNum">    1529 </span>            : //----------------------------------------------------------------------
<span class="lineNum">    1530 </span>            : //
<span class="lineNum">    1531 </span>            : //    PHOIN:   PHOtos INput
<span class="lineNum">    1532 </span>            : //
<span class="lineNum">    1533 </span>            : //    Purpose:  copies IP branch of the common /PH_HEPEVT/ into /PHOEVT/
<span class="lineNum">    1534 </span>            : //              moves branch into its CMS system.
<span class="lineNum">    1535 </span>            : //
<span class="lineNum">    1536 </span>            : //    Input Parameters:       IP:  pointer of particle starting branch
<span class="lineNum">    1537 </span>            : //                                 to be copied
<span class="lineNum">    1538 </span>            : //                        BOOST:   Flag whether boost to CMS was or was 
<span class="lineNum">    1539 </span>            : //     .                          replace stri  not performed.
<span class="lineNum">    1540 </span>            : //
<span class="lineNum">    1541 </span>            : //    Output Parameters:  Commons: /PHOEVT/, /PHOCMS/
<span class="lineNum">    1542 </span>            : //
<span class="lineNum">    1543 </span>            : //    Author(s):  Z. Was                          Created at:  24/05/93
<span class="lineNum">    1544 </span>            : //                                                Last Update: 16/11/93
<a name="1545"><span class="lineNum">    1545 </span>            : //</a>
<span class="lineNum">    1546 </span>            : //----------------------------------------------------------------------
<span class="lineNum">    1547 </span>            : void PHOIN(int IP,bool *BOOST,int *NHEP0){
<span class="lineNum">    1548 </span>            :   int FIRST,LAST,I,LL,IP2,J,NA;
<span class="lineNum">    1549 </span>            :   double PB;
<span class="lineNum">    1550 </span>            :   static int i=1;
<span class="lineNum">    1551 </span>            :   int &amp;nhep0 = *NHEP0;
<span class="lineNum">    1552 </span>            : 
<span class="lineNum">    1553 </span>            :   //--
<span class="lineNum">    1554 </span>            :   // let-s calculate size of the little common entry
<span class="lineNum">    1555 </span><span class="lineNoCov">          0 :   FIRST=hep.jdahep[IP-i][1-i];</span>
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 :   LAST =hep.jdahep[IP-i][2-i];</span>
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :   pho.nhep=3+LAST-FIRST+hep.nhep-nhep0;</span>
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 :   pho.nevhep=pho.nhep;</span>
<span class="lineNum">    1559 </span>            : 
<span class="lineNum">    1560 </span>            :   // let-s take in decaying particle
<span class="lineNum">    1561 </span><span class="lineNoCov">          0 :   pho.idhep[1-i]=hep.idhep[IP-i];</span>
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 :   pho.jdahep[1-i][1-i]=3;</span>
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :   pho.jdahep[1-i][2-i]=3+LAST-FIRST;</span>
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :   for(I=1;I&lt;=5;I++) pho.phep[1-i][I-i]=hep.phep[IP-i][I-i];</span>
<span class="lineNum">    1565 </span>            :            
<span class="lineNum">    1566 </span>            :   // let-s take in eventual second mother
<span class="lineNum">    1567 </span><span class="lineNoCov">          0 :   IP2=hep.jmohep[hep.jdahep[IP-i][1-i]-i][2-i];</span>
<span class="lineNum">    1568 </span><span class="lineNoCov">          0 :   if((IP2!=0) &amp;&amp; (IP2!=IP)){</span>
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :     pho.idhep[2-i]=hep.idhep[IP2-i];</span>
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :     pho.jdahep[2-i][1-i]=3;</span>
<span class="lineNum">    1571 </span><span class="lineNoCov">          0 :     pho.jdahep[2-i][2-i]=3+LAST-FIRST;</span>
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :     for(I=1;I&lt;=5;I++)</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :       pho.phep[2-i][I-i]=hep.phep[IP2-i][I-i];</span>
<span class="lineNum">    1574 </span>            :   }
<span class="lineNum">    1575 </span>            :   else{
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 :     pho.idhep[2-i]=0;</span>
<span class="lineNum">    1577 </span><span class="lineNoCov">          0 :     for(I=1;I&lt;=5;I++)  pho.phep[2-i][I-i]=0.0;</span>
<span class="lineNum">    1578 </span>            :   }            
<span class="lineNum">    1579 </span>            :         
<span class="lineNum">    1580 </span>            :   // let-s take in daughters
<span class="lineNum">    1581 </span><span class="lineNoCov">          0 :   for(LL=0;LL&lt;=LAST-FIRST;LL++){</span>
<span class="lineNum">    1582 </span><span class="lineNoCov">          0 :     pho.idhep[3+LL-i]=hep.idhep[FIRST+LL-i];</span>
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :     pho.jmohep[3+LL-i][1-i]=hep.jmohep[FIRST+LL-i][1-i];</span>
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :     if(hep.jmohep[FIRST+LL-i][1-i]==IP) pho.jmohep[3+LL-i][1-i]=1;</span>
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :     for(I=1;I&lt;=5;I++) pho.phep[3+LL-i][I-i]=hep.phep[FIRST+LL-i][I-i];</span>
<span class="lineNum">    1586 </span>            :           
<span class="lineNum">    1587 </span>            :   }
<span class="lineNum">    1588 </span><span class="lineNoCov">          0 :   if(hep.nhep&gt;nhep0){</span>
<span class="lineNum">    1589 </span>            :     // let-s take in illegitimate daughters
<span class="lineNum">    1590 </span>            :     NA=3+LAST-FIRST; 
<span class="lineNum">    1591 </span><span class="lineNoCov">          0 :     for(LL=1;LL&lt;=hep.nhep-nhep0;LL++){</span>
<span class="lineNum">    1592 </span><span class="lineNoCov">          0 :       pho.idhep[NA+LL-i]=hep.idhep[nhep0+LL-i];</span>
<span class="lineNum">    1593 </span><span class="lineNoCov">          0 :       pho.jmohep[NA+LL-i][1-i]=hep.jmohep[nhep0+LL-i][1-i];</span>
<span class="lineNum">    1594 </span><span class="lineNoCov">          0 :       if(hep.jmohep[nhep0+LL-i][1-i]==IP) pho.jmohep[NA+LL-i][1-i]=1;</span>
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 :       for(I=1;I&lt;=5;I++) pho.phep[NA+LL-i][I-i]=hep.phep[nhep0+LL-i][I-i];</span>
<span class="lineNum">    1596 </span>            :           
<span class="lineNum">    1597 </span>            :     }
<span class="lineNum">    1598 </span>            :     //--        there is hep.nhep-nhep0 daugters more.
<span class="lineNum">    1599 </span><span class="lineNoCov">          0 :     pho.jdahep[1-i][2-i]=3+LAST-FIRST+hep.nhep-nhep0;</span>
<span class="lineNum">    1600 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1601 </span><span class="lineNoCov">          0 :   if (pho.idhep[pho.nhep-i]==22) PHLUPA(100001);</span>
<span class="lineNum">    1602 </span>            :   // if (pho.idhep[pho.nhep-i]==22) exit(-1);
<span class="lineNum">    1603 </span><span class="lineNoCov">          0 :   PHCORK(0);</span>
<span class="lineNum">    1604 </span><span class="lineNoCov">          0 :   if(pho.idhep[pho.nhep-i]==22) PHLUPA(100002);</span>
<span class="lineNum">    1605 </span>            : 
<span class="lineNum">    1606 </span>            :   // special case of t tbar production process
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 :   if(phokey_.iftop) PHOTWO(0);</span>
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 :   *BOOST=false;</span>
<span class="lineNum">    1609 </span>            : 
<span class="lineNum">    1610 </span>            :   //--   Check whether parent is in its rest frame...
<span class="lineNum">    1611 </span>            :   // ZBW ND  27.07.2009:
<span class="lineNum">    1612 </span>            :   // bug reported by Vladimir Savinov localized and fixed.
<span class="lineNum">    1613 </span>            :   // protection against rounding error was back-firing if soft
<span class="lineNum">    1614 </span>            :   // momentum of mother was physical. Consequence was that PHCORK was
<span class="lineNum">    1615 </span>            :   // messing up masses of final state particles in vertex of the decay.
<span class="lineNum">    1616 </span>            :   // Only configurations with previously generated photons of energy fraction
<span class="lineNum">    1617 </span>            :   // smaller than 0.0001 were affected. Effect was numerically insignificant. 
<span class="lineNum">    1618 </span>            : 
<span class="lineNum">    1619 </span>            :   //      IF (     (ABS(pho.phep[4,1)-pho.phep[5,1)).GT.pho.phep[5,1)*1.D-8)
<span class="lineNum">    1620 </span>            :   //     $    .AND.(pho.phep[5,1).NE.0))                            THEN
<span class="lineNum">    1621 </span>            : 
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 :   if((fabs(pho.phep[1-i][1-i]+fabs(pho.phep[1-i][2-i])+fabs(pho.phep[1-i][3-i]))&gt;</span>
<span class="lineNum">    1623 </span><span class="lineNoCov">          0 :       pho.phep[1-i][5-i]*1.E-8) &amp;&amp; (pho.phep[1-i][5-i]!=0)){</span>
<span class="lineNum">    1624 </span>            : 
<span class="lineNum">    1625 </span><span class="lineNoCov">          0 :     *BOOST=true;</span>
<span class="lineNum">    1626 </span>            :     //PHOERR(404,&quot;PHOIN&quot;,1.0);  // we need to improve this warning:  program should never
<span class="lineNum">    1627 </span>            :                               // enter this place  
<span class="lineNum">    1628 </span>            :     //  may be   exit(-1);
<span class="lineNum">    1629 </span>            :     //--
<span class="lineNum">    1630 </span>            :     //--   Boost daughter particles to rest frame of parent...
<span class="lineNum">    1631 </span>            :     //--   Resultant neutral system already calculated in rest frame !
<span class="lineNum">    1632 </span><span class="lineNoCov">          0 :     for(J=1;J&lt;=3;J++) phocms_.bet[J-i]=-pho.phep[1-i][J-i]/pho.phep[1-i][5-i];</span>
<span class="lineNum">    1633 </span><span class="lineNoCov">          0 :     phocms_.gam=pho.phep[1-i][4-i]/pho.phep[1-i][5-i];</span>
<span class="lineNum">    1634 </span><span class="lineNoCov">          0 :     for(I=pho.jdahep[1-i][1-i];I&lt;=pho.jdahep[1-i][2-i];I++){</span>
<span class="lineNum">    1635 </span><span class="lineNoCov">          0 :       PB=phocms_.bet[1-i]*pho.phep[I-i][1-i]+phocms_.bet[2-i]*pho.phep[I-i][2-i]+phocms_.bet[3-i]*pho.phep[I-i][3-i];</span>
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :       for(J=1;J&lt;=3;J++)   pho.phep[I-i][J-i]=pho.phep[I-i][J-i]+phocms_.bet[J-i]*(pho.phep[I-i][4-i]+PB/(phocms_.gam+1.0));</span>
<span class="lineNum">    1637 </span><span class="lineNoCov">          0 :       pho.phep[I-i][4-i]=phocms_.gam*pho.phep[I-i][4-i]+PB;</span>
<span class="lineNum">    1638 </span>            :     }
<span class="lineNum">    1639 </span>            :     //--    Finally boost mother as well
<span class="lineNum">    1640 </span>            :     I=1;   
<span class="lineNum">    1641 </span><span class="lineNoCov">          0 :     PB=phocms_.bet[1-i]*pho.phep[I-i][1-i]+phocms_.bet[2-i]*pho.phep[I-i][2-i]+phocms_.bet[3-i]*pho.phep[I-i][3-i];</span>
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 :     for(J=1;J&lt;=3;J++) pho.phep[I-i][J-i]=pho.phep[I-i][J-i]+phocms_.bet[J-i]*(pho.phep[I-i][4-i]+PB/(phocms_.gam+1.0));</span>
<span class="lineNum">    1643 </span>            :  
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :     pho.phep[I-i][4-i]=phocms_.gam*pho.phep[I-i][4-i]+PB;</span>
<span class="lineNum">    1645 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1646 </span>            : 
<span class="lineNum">    1647 </span>            : 
<span class="lineNum">    1648 </span>            :   // special case of t tbar production process
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 :   if(phokey_.iftop) PHOTWO(1);</span>
<span class="lineNum">    1650 </span><span class="lineNoCov">          0 :   PHLUPA(2);</span>
<span class="lineNum">    1651 </span><span class="lineNoCov">          0 :   if(pho.idhep[pho.nhep-i]==22) PHLUPA(10000);</span>
<span class="lineNum">    1652 </span>            :   //if (pho.idhep[pho.nhep-1-i]==22) exit(-1);  // this is probably form very old times ...
<span class="lineNum">    1653 </span>            :   return;
<span class="lineNum">    1654 </span><span class="lineNoCov">          0 : } </span>
<span class="lineNum">    1655 </span>            : 
<span class="lineNum">    1656 </span>            : 
<span class="lineNum">    1657 </span>            : //----------------------------------------------------------------------
<span class="lineNum">    1658 </span>            : //
<span class="lineNum">    1659 </span>            : //    PHOOUT:   PHOtos OUTput
<span class="lineNum">    1660 </span>            : //
<span class="lineNum">    1661 </span>            : //    Purpose:  copies back IP branch of the common /PH_HEPEVT/ from 
<span class="lineNum">    1662 </span>            : //              /PHOEVT/ moves branch back from its CMS system.
<span class="lineNum">    1663 </span>            : //
<span class="lineNum">    1664 </span>            : //    Input Parameters:       IP:  pointer of particle starting branch
<span class="lineNum">    1665 </span>            : //                                 to be given back.
<span class="lineNum">    1666 </span>            : //                        BOOST:   Flag whether boost to CMS was or was 
<span class="lineNum">    1667 </span>            : //     .                            not performed.
<span class="lineNum">    1668 </span>            : //
<span class="lineNum">    1669 </span>            : //    Output Parameters:  Common /PHOEVT/, 
<span class="lineNum">    1670 </span>            : //
<span class="lineNum">    1671 </span>            : //    Author(s):  Z. Was                          Created at:  24/05/93
<span class="lineNum">    1672 </span>            : //                                                Last Update:
<a name="1673"><span class="lineNum">    1673 </span>            : //</a>
<span class="lineNum">    1674 </span>            : //----------------------------------------------------------------------
<span class="lineNum">    1675 </span>            : void PHOOUT(int IP, bool BOOST, int nhep0){
<span class="lineNum">    1676 </span>            :   int LL,FIRST,LAST,I;
<span class="lineNum">    1677 </span>            :   int NN,J,K,NA;
<span class="lineNum">    1678 </span>            :   double PB;
<span class="lineNum">    1679 </span>            :   static int i=1;
<span class="lineNum">    1680 </span><span class="lineNoCov">          0 :   if(pho.nhep==pho.nevhep) return;</span>
<span class="lineNum">    1681 </span>            :   //--   When parent was not in its rest-frame, boost back...
<span class="lineNum">    1682 </span><span class="lineNoCov">          0 :   PHLUPA(10);</span>
<span class="lineNum">    1683 </span><span class="lineNoCov">          0 :   if (BOOST){</span>
<span class="lineNum">    1684 </span>            :     //PHOERR(404,&quot;PHOOUT&quot;,1.0);  // we need to improve this warning:  program should never
<span class="lineNum">    1685 </span>            :                                // enter this place
<span class="lineNum">    1686 </span>            : 
<span class="lineNum">    1687 </span><span class="lineNoCov">          0 :     double phocms_check = fabs(1 - phocms_.gam) + fabs(phocms_.bet[1-i]) + fabs(phocms_.bet[2-i]) + fabs(phocms_.bet[3-i]);</span>
<span class="lineNum">    1688 </span><span class="lineNoCov">          0 :     if( phocms_check &gt; 0.001 ) {</span>
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 :         Log::Error() &lt;&lt; &quot;Msg. from PHOOUT: possible problems with boosting due to the rounding errors.&quot; &lt;&lt; endl</span>
<span class="lineNum">    1690 </span><span class="lineNoCov">          0 :                      &lt;&lt; &quot;Boost parameters:   (&quot;&lt;&lt; phocms_.gam &lt;&lt; &quot;,&quot;</span>
<span class="lineNum">    1691 </span><span class="lineNoCov">          0 :                      &lt;&lt; phocms_.bet[1-i] &lt;&lt; &quot;,&quot; &lt;&lt; phocms_.bet[2-i] &lt;&lt; &quot;,&quot; &lt;&lt; phocms_.bet[3-i] &lt;&lt; &quot;)&quot;&lt;&lt;endl</span>
<span class="lineNum">    1692 </span><span class="lineNoCov">          0 :                      &lt;&lt; &quot;should be equal to: (1,0,0,0) up to at least several digits.&quot; &lt;&lt; endl;</span>
<span class="lineNum">    1693 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1694 </span>            :     else{
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :         Log::Warning() &lt;&lt; &quot;Msg. from PHOOUT: possible problems with boosting due to the rounding errors.&quot; &lt;&lt; endl</span>
<span class="lineNum">    1696 </span><span class="lineNoCov">          0 :                        &lt;&lt; &quot;Boost parameters:   (&quot;&lt;&lt; phocms_.gam &lt;&lt; &quot;,&quot;</span>
<span class="lineNum">    1697 </span><span class="lineNoCov">          0 :                        &lt;&lt; phocms_.bet[1-i] &lt;&lt; &quot;,&quot; &lt;&lt; phocms_.bet[2-i] &lt;&lt; &quot;,&quot; &lt;&lt; phocms_.bet[3-i] &lt;&lt; &quot;)&quot;&lt;&lt;endl</span>
<span class="lineNum">    1698 </span><span class="lineNoCov">          0 :                        &lt;&lt; &quot;should be equal to: (1,0,0,0) up to at least several digits.&quot; &lt;&lt; endl;</span>
<span class="lineNum">    1699 </span>            :     }
<span class="lineNum">    1700 </span>            : 
<span class="lineNum">    1701 </span><span class="lineNoCov">          0 :     for (J=pho.jdahep[1-i][1-i];J&lt;=pho.jdahep[1-i][2-i];J++){</span>
<span class="lineNum">    1702 </span><span class="lineNoCov">          0 :       PB=-phocms_.bet[1-i]*pho.phep[J-i][1-i]-phocms_.bet[2-i]*pho.phep[J-i][2-i]-phocms_.bet[3-i]*pho.phep[J-i][3-i];</span>
<span class="lineNum">    1703 </span><span class="lineNoCov">          0 :       for(K=1;K&lt;=3;K++) pho.phep[J-i][K-i]=pho.phep[J-i][K-i]-phocms_.bet[K-i]*(pho.phep[J-i][4-i]+PB/(phocms_.gam+1.0));</span>
<span class="lineNum">    1704 </span><span class="lineNoCov">          0 :       pho.phep[J-i][4-i]=phocms_.gam*pho.phep[J-i][4-i]+PB;</span>
<span class="lineNum">    1705 </span>            :     }
<span class="lineNum">    1706 </span>            : 
<span class="lineNum">    1707 </span>            :     //--   ...boost photon, or whatever else has shown up
<span class="lineNum">    1708 </span><span class="lineNoCov">          0 :     for(NN=pho.nevhep+1;NN&lt;=pho.nhep;NN++){</span>
<span class="lineNum">    1709 </span><span class="lineNoCov">          0 :       PB=-phocms_.bet[1-i]*pho.phep[NN-i][1-i]-phocms_.bet[2-i]*pho.phep[NN-i][2-i]-phocms_.bet[3-i]*pho.phep[NN-i][3-i];</span>
<span class="lineNum">    1710 </span><span class="lineNoCov">          0 :       for(K=1;K&lt;=3;K++) pho.phep[NN-i][K-i]=pho.phep[NN-i][K-i]-phocms_.bet[K-i]*(pho.phep[NN-i][4-i]+PB/(phocms_.gam+1.0));</span>
<span class="lineNum">    1711 </span><span class="lineNoCov">          0 :       pho.phep[NN-i][4-i]=phocms_.gam*pho.phep[NN][4-i]+PB;</span>
<span class="lineNum">    1712 </span>            :     }
<span class="lineNum">    1713 </span><span class="lineNoCov">          0 :                                           }</span>
<span class="lineNum">    1714 </span><span class="lineNoCov">          0 :   PHCORK(0);   // we have to use it because it clears input </span>
<span class="lineNum">    1715 </span>            :                // for grandaughters modified in C++
<span class="lineNum">    1716 </span><span class="lineNoCov">          0 :   FIRST=hep.jdahep[IP-i][1-i];</span>
<span class="lineNum">    1717 </span><span class="lineNoCov">          0 :   LAST =hep.jdahep[IP-i][2-i];</span>
<span class="lineNum">    1718 </span>            :   // let-s take in original daughters
<span class="lineNum">    1719 </span><span class="lineNoCov">          0 :   for(LL=0;LL&lt;=LAST-FIRST;LL++){</span>
<span class="lineNum">    1720 </span><span class="lineNoCov">          0 :     hep.idhep[FIRST+LL-i] = pho.idhep[3+LL-i];</span>
<span class="lineNum">    1721 </span><span class="lineNoCov">          0 :     for(I=1;I&lt;=5;I++) hep.phep[FIRST+LL-i][I-i] = pho.phep[3+LL-i][I-i];         </span>
<span class="lineNum">    1722 </span>            :   }
<span class="lineNum">    1723 </span>            : 
<span class="lineNum">    1724 </span>            :   // let-s take newcomers to the end of HEPEVT.
<span class="lineNum">    1725 </span><span class="lineNoCov">          0 :   NA=3+LAST-FIRST;</span>
<span class="lineNum">    1726 </span><span class="lineNoCov">          0 :   for (LL=1;LL&lt;=pho.nhep-NA;LL++){</span>
<span class="lineNum">    1727 </span><span class="lineNoCov">          0 :     hep.idhep[nhep0+LL-i] = pho.idhep[NA+LL-i];</span>
<span class="lineNum">    1728 </span><span class="lineNoCov">          0 :     hep.isthep[nhep0+LL-i]=pho.isthep[NA+LL-i];</span>
<span class="lineNum">    1729 </span><span class="lineNoCov">          0 :     hep.jmohep[nhep0+LL-i][1-i]=IP;</span>
<span class="lineNum">    1730 </span><span class="lineNoCov">          0 :     hep.jmohep[nhep0+LL-i][2-i]=hep.jmohep[hep.jdahep[IP-i][1-i]-i][2-i];</span>
<span class="lineNum">    1731 </span><span class="lineNoCov">          0 :     hep.jdahep[nhep0+LL-i][1-i]=0;</span>
<span class="lineNum">    1732 </span><span class="lineNoCov">          0 :     hep.jdahep[nhep0+LL-i][2-i]=0;</span>
<span class="lineNum">    1733 </span><span class="lineNoCov">          0 :     for(I=1;I&lt;=5;I++) hep.phep[nhep0+LL-i][I-i] = pho.phep[NA+LL-i][I-i];</span>
<span class="lineNum">    1734 </span>            :   }
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 :   hep.nhep=hep.nhep+pho.nhep-pho.nevhep;</span>
<span class="lineNum">    1736 </span><span class="lineNoCov">          0 :   PHLUPA(20);</span>
<span class="lineNum">    1737 </span><span class="lineNoCov">          0 :   return;</span>
<span class="lineNum">    1738 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1739 </span>            : 
<span class="lineNum">    1740 </span>            : //----------------------------------------------------------------------
<span class="lineNum">    1741 </span>            : //
<span class="lineNum">    1742 </span>            : //    PHOCHK:   checking branch.
<span class="lineNum">    1743 </span>            : //
<span class="lineNum">    1744 </span>            : //    Purpose:  checks whether particles in the common block /PHOEVT/
<span class="lineNum">    1745 </span>            : //              can be served by PHOMAK. 
<span class="lineNum">    1746 </span>            : //              JFIRST is the position in /PH_HEPEVT/ (!) of the first 
<span class="lineNum">    1747 </span>            : //              daughter of sub-branch under action.
<span class="lineNum">    1748 </span>            : //
<span class="lineNum">    1749 </span>            : //
<span class="lineNum">    1750 </span>            : //    Author(s):  Z. Was                           Created at: 22/10/92
<span class="lineNum">    1751 </span>            : //                                                Last Update: 11/12/00
<span class="lineNum">    1752 </span>            : //
<span class="lineNum">    1753 </span>            : //----------------------------------------------------------------------
<a name="1754"><span class="lineNum">    1754 </span>            : //     ********************</a>
<span class="lineNum">    1755 </span>            : 
<span class="lineNum">    1756 </span>            : void PHOCHK(int JFIRST){
<span class="lineNum">    1757 </span>            : 
<span class="lineNum">    1758 </span>            :   int IDABS,NLAST,I;
<span class="lineNum">    1759 </span>            :   bool IFRAD;
<span class="lineNum">    1760 </span>            :   int IDENT,K;
<span class="lineNum">    1761 </span>            :   static int i=1, IPPAR=1;
<span class="lineNum">    1762 </span>            : 
<span class="lineNum">    1763 </span><span class="lineNoCov">          0 :   NLAST = pho.nhep;</span>
<span class="lineNum">    1764 </span>            :   //
<span class="lineNum">    1765 </span>            :  
<span class="lineNum">    1766 </span><span class="lineNoCov">          0 :   for (I=IPPAR;I&lt;=NLAST;I++){</span>
<span class="lineNum">    1767 </span><span class="lineNoCov">          0 :     IDABS    = abs(pho.idhep[I-i]);</span>
<span class="lineNum">    1768 </span>            :     // possibly call on PHZODE is a dead (to be omitted) code. 
<span class="lineNum">    1769 </span><span class="lineNoCov">          0 :     pho.qedrad[I-i]= F(0,IDABS)  &amp;&amp; F(0,abs(pho.idhep[1-i]))</span>
<span class="lineNum">    1770 </span><span class="lineNoCov">          0 :                                  &amp;&amp;  (pho.idhep[2-i]==0);</span>
<span class="lineNum">    1771 </span>            : 
<span class="lineNum">    1772 </span><span class="lineNoCov">          0 :     if(I&gt;2) pho.qedrad[I-i]=pho.qedrad[I-i] &amp;&amp; hep.qedrad[JFIRST+I-IPPAR-2-i];</span>
<span class="lineNum">    1773 </span>            :   }
<span class="lineNum">    1774 </span>            : 
<span class="lineNum">    1775 </span>            :   //--
<span class="lineNum">    1776 </span>            :   // now we go to special cases, where pho.qedrad[I) will be overwritten
<span class="lineNum">    1777 </span>            :   //--
<span class="lineNum">    1778 </span><span class="lineNoCov">          0 :   IDENT=pho.nhep;</span>
<span class="lineNum">    1779 </span><span class="lineNoCov">          0 :   if(phokey_.iftop){</span>
<span class="lineNum">    1780 </span>            :     // special case of top pair production
<span class="lineNum">    1781 </span><span class="lineNoCov">          0 :     for(K=pho.jdahep[1-i][2-i];K&gt;=pho.jdahep[1-i][1-i];K--){</span>
<span class="lineNum">    1782 </span><span class="lineNoCov">          0 :       if(pho.idhep[K-i]!=22){</span>
<span class="lineNum">    1783 </span>            :         IDENT=K;
<span class="lineNum">    1784 </span><span class="lineNoCov">          0 :         break;   // from loop over K</span>
<span class="lineNum">    1785 </span>            :       }
<span class="lineNum">    1786 </span>            :     }
<span class="lineNum">    1787 </span>            : 
<span class="lineNum">    1788 </span><span class="lineNoCov">          0 :     IFRAD=((pho.idhep[1-i]==21)      &amp;&amp; (pho.idhep[2-i]== 21))</span>
<span class="lineNum">    1789 </span><span class="lineNoCov">          0 :       ||  ((abs(pho.idhep[1-i])&lt;=6)  &amp;&amp; (pho.idhep[2-i]==(-pho.idhep[1-i])));</span>
<span class="lineNum">    1790 </span><span class="lineNoCov">          0 :         IFRAD=IFRAD</span>
<span class="lineNum">    1791 </span><span class="lineNoCov">          0 :           &amp;&amp; (abs(pho.idhep[3-i])==6)&amp;&amp; (pho.idhep[4-i]==(-pho.idhep[3-i]))</span>
<span class="lineNum">    1792 </span><span class="lineNoCov">          0 :           &amp;&amp; (IDENT==4);   </span>
<span class="lineNum">    1793 </span><span class="lineNoCov">          0 :         if(IFRAD){    </span>
<span class="lineNum">    1794 </span><span class="lineNoCov">          0 :           for(I=IPPAR;I&lt;=NLAST;I++){</span>
<span class="lineNum">    1795 </span><span class="lineNoCov">          0 :             pho.qedrad[I-i]= true;</span>
<span class="lineNum">    1796 </span><span class="lineNoCov">          0 :             if(I&gt;2) pho.qedrad[I-i]=pho.qedrad[I-i] &amp;&amp; hep.qedrad[JFIRST+I-IPPAR-2-i];</span>
<span class="lineNum">    1797 </span>            :           }
<span class="lineNum">    1798 </span>            :         }
<span class="lineNum">    1799 </span>            :   }
<span class="lineNum">    1800 </span>            :   //--
<span class="lineNum">    1801 </span>            :   //--
<span class="lineNum">    1802 </span><span class="lineNoCov">          0 :   if(phokey_.iftop){</span>
<span class="lineNum">    1803 </span>            :     // special case of top decay
<span class="lineNum">    1804 </span><span class="lineNoCov">          0 :     for (K=pho.jdahep[1-i][2-i];K&gt;=pho.jdahep[1-i][1-i];K--){</span>
<span class="lineNum">    1805 </span><span class="lineNoCov">          0 :       if(pho.idhep[K-i]!=22){</span>
<span class="lineNum">    1806 </span>            :         IDENT=K;
<span class="lineNum">    1807 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1808 </span>            :       }
<span class="lineNum">    1809 </span>            :     }
<span class="lineNum">    1810 </span><span class="lineNoCov">          0 :     IFRAD=((abs(pho.idhep[1-i])==6) &amp;&amp; (pho.idhep[2-i]==0));</span>
<span class="lineNum">    1811 </span><span class="lineNoCov">          0 :     IFRAD=IFRAD</span>
<span class="lineNum">    1812 </span><span class="lineNoCov">          0 :       &amp;&amp;    ((abs(pho.idhep[3-i])==24) &amp;&amp;(abs(pho.idhep[4-i])== 5)</span>
<span class="lineNum">    1813 </span><span class="lineNoCov">          0 :           || (abs(pho.idhep[3-i])== 5) &amp;&amp;(abs(pho.idhep[4-i])==24) )</span>
<span class="lineNum">    1814 </span><span class="lineNoCov">          0 :       &amp;&amp;  (IDENT==4);</span>
<span class="lineNum">    1815 </span>            :   
<span class="lineNum">    1816 </span><span class="lineNoCov">          0 :     if(IFRAD){    </span>
<span class="lineNum">    1817 </span><span class="lineNoCov">          0 :       for(I=IPPAR;I&lt;=NLAST;I++){</span>
<span class="lineNum">    1818 </span><span class="lineNoCov">          0 :         pho.qedrad[I-i]= true;</span>
<span class="lineNum">    1819 </span><span class="lineNoCov">          0 :         if(I&gt;2) pho.qedrad[I-i] = (pho.qedrad[I-i] &amp;&amp; hep.qedrad[JFIRST+I-IPPAR-2-i]);</span>
<span class="lineNum">    1820 </span>            :       }
<span class="lineNum">    1821 </span>            :     }
<span class="lineNum">    1822 </span>            :   }
<span class="lineNum">    1823 </span>            :   //--
<span class="lineNum">    1824 </span>            :   //--
<span class="lineNum">    1825 </span>            :   return;
<span class="lineNum">    1826 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1827 </span>            : 
<span class="lineNum">    1828 </span>            : 
<span class="lineNum">    1829 </span>            : 
<span class="lineNum">    1830 </span>            : //----------------------------------------------------------------------
<span class="lineNum">    1831 </span>            : //
<span class="lineNum">    1832 </span>            : //    PHOTOS:   PHOton radiation in decays calculation  of photon ENErgy
<span class="lineNum">    1833 </span>            : //              fraction
<span class="lineNum">    1834 </span>            : //
<span class="lineNum">    1835 </span>            : //    Purpose:  Subroutine  returns  photon  energy fraction (in (parent
<span class="lineNum">    1836 </span>            : //              mass)/2 units) for the decay bremsstrahlung.
<span class="lineNum">    1837 </span>            : //
<span class="lineNum">    1838 </span>            : //    Input Parameters:  MPASQR:  Mass of decaying system squared,
<span class="lineNum">    1839 </span>            : //                       XPHCUT:  Minimum energy fraction of photon,
<span class="lineNum">    1840 </span>            : //                       XPHMAX:  Maximum energy fraction of photon.
<span class="lineNum">    1841 </span>            : //
<span class="lineNum">    1842 </span>            : //    Output Parameter:  MCHREN:  Renormalised mass squared,
<span class="lineNum">    1843 </span>            : //                       BETA:    Beta factor due to renormalisation,
<span class="lineNum">    1844 </span>            : //                       XPHOTO:  Photon energy fraction,
<span class="lineNum">    1845 </span>            : //                       XF:      Correction factor for PHOFA//
<span class="lineNum">    1846 </span>            : //
<span class="lineNum">    1847 </span>            : //    Author(s):  S. Jadach, Z. Was               Created at:  01/01/89
<span class="lineNum">    1848 </span>            : //                B. van Eijk, P.Golonka          Last Update: 11/07/13
<span class="lineNum">    1849 </span>            : //
<a name="1850"><span class="lineNum">    1850 </span>            : //----------------------------------------------------------------------</a>
<span class="lineNum">    1851 </span>            : 
<span class="lineNum">    1852 </span>            : void PHOENE(double MPASQR,double *pMCHREN,double *pBETA,double *pBIGLOG,int IDENT){
<span class="lineNum">    1853 </span>            :   double  DATA;
<span class="lineNum">    1854 </span>            :   double PRSOFT,PRHARD;
<span class="lineNum">    1855 </span>            :   double PRKILL,RRR;
<span class="lineNum">    1856 </span>            :   int K,IDME;
<span class="lineNum">    1857 </span>            :   double PRSUM;
<span class="lineNum">    1858 </span>            :   static int i=1;
<span class="lineNum">    1859 </span>            :   double &amp;MCHREN = *pMCHREN;
<span class="lineNum">    1860 </span>            :   double &amp;BETA   = *pBETA;
<span class="lineNum">    1861 </span>            :   double &amp;BIGLOG = *pBIGLOG;
<span class="lineNum">    1862 </span>            :   //--
<span class="lineNum">    1863 </span><span class="lineNoCov">          0 :   if(phophs_.xphmax&lt;=phocop_.xphcut){</span>
<span class="lineNum">    1864 </span><span class="lineNoCov">          0 :     BETA=PHOFAC(-1);    // to zero counter, here beta is dummy</span>
<span class="lineNum">    1865 </span><span class="lineNoCov">          0 :     phophs_.xphoto=0.0;</span>
<span class="lineNum">    1866 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1867 </span>            :   }
<span class="lineNum">    1868 </span>            :   //--   Probabilities for hard and soft bremstrahlung...
<span class="lineNum">    1869 </span><span class="lineNoCov">          0 :   MCHREN=4.0* phomom_.mchsqr/MPASQR/pow(1.0+ phomom_.mchsqr/MPASQR,2);</span>
<span class="lineNum">    1870 </span><span class="lineNoCov">          0 :   BETA=sqrt(1.0-MCHREN);</span>
<span class="lineNum">    1871 </span>            : 
<span class="lineNum">    1872 </span>            : #ifdef VARIANTB
<span class="lineNum">    1873 </span>            :   // ----------- VARIANT B ------------------
<span class="lineNum">    1874 </span>            :   // we replace 1D0/BETA*BIGLOG with (1.0/BETA*BIGLOG+2*phokey_.fint) 
<span class="lineNum">    1875 </span>            :   // for integral of new crude
<span class="lineNum">    1876 </span>            :   BIGLOG=log(MPASQR/ phomom_.mchsqr*(1.0+BETA)*(1.0+BETA)/4.0*
<span class="lineNum">    1877 </span>            :              pow(1.0+ phomom_.mchsqr/MPASQR,2));
<span class="lineNum">    1878 </span>            :   PRHARD=phocop_.alpha/PI*(1.0/BETA*BIGLOG+2*phokey_.fint)
<span class="lineNum">    1879 </span>            :         *(log(phophs_.xphmax/phocop_.xphcut)-.75+phocop_.xphcut/phophs_.xphmax-.25*phocop_.xphcut*phocop_.xphcut/phophs_.xphmax/phophs_.xphmax);
<span class="lineNum">    1880 </span>            :   PRHARD=PRHARD*PHOCHA(IDENT)*PHOCHA(IDENT)*phokey_.fsec;
<span class="lineNum">    1881 </span>            :   // ----------- END OF VARIANT B ------------------
<span class="lineNum">    1882 </span>            : #else
<span class="lineNum">    1883 </span>            :   // ----------- VARIANT A ------------------
<span class="lineNum">    1884 </span><span class="lineNoCov">          0 :   BIGLOG=log(MPASQR/ phomom_.mchsqr*(1.0+BETA)*(1.0+BETA)/4.0*</span>
<span class="lineNum">    1885 </span><span class="lineNoCov">          0 :              pow(1.0+ phomom_.mchsqr/MPASQR,2));</span>
<span class="lineNum">    1886 </span><span class="lineNoCov">          0 :   PRHARD=phocop_.alpha/PI*(1.0/BETA*BIGLOG)*</span>
<span class="lineNum">    1887 </span><span class="lineNoCov">          0 :     (log(phophs_.xphmax/phocop_.xphcut)-.75+phocop_.xphcut/phophs_.xphmax-.25*phocop_.xphcut*phocop_.xphcut/phophs_.xphmax/phophs_.xphmax);</span>
<span class="lineNum">    1888 </span><span class="lineNoCov">          0 :   PRHARD=PRHARD*PHOCHA(IDENT)*PHOCHA(IDENT)*phokey_.fsec*phokey_.fint;</span>
<span class="lineNum">    1889 </span>            :   //me_channel_(&amp;IDME);
<span class="lineNum">    1890 </span><span class="lineNoCov">          0 :   IDME=PH_HEPEVT_Interface::ME_channel;</span>
<span class="lineNum">    1891 </span>            :   //        write(*,*) 'KANALIK IDME=',IDME
<span class="lineNum">    1892 </span><span class="lineNoCov">          0 :   if(IDME==0){  </span>
<span class="lineNum">    1893 </span>            :     // do nothing
<span class="lineNum">    1894 </span>            :   }
<span class="lineNum">    1895 </span>            : 
<span class="lineNum">    1896 </span><span class="lineNoCov">          0 :   else if(IDME==1){</span>
<span class="lineNum">    1897 </span><span class="lineNoCov">          0 :     PRHARD=PRHARD/(1.0+0.75*phocop_.alpha/PI); //  NLO</span>
<span class="lineNum">    1898 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1899 </span><span class="lineNoCov">          0 :   else if (IDME==2){</span>
<span class="lineNum">    1900 </span>            :     // work on virtual crrections in W decay to be done.
<span class="lineNum">    1901 </span>            :   }
<span class="lineNum">    1902 </span>            :   else{
<span class="lineNum">    1903 </span><span class="lineNoCov">          0 :     cout &lt;&lt; &quot;problem with ME_CHANNEL  IDME= &quot; &lt;&lt; IDME &lt;&lt; endl;</span>
<span class="lineNum">    1904 </span><span class="lineNoCov">          0 :            exit(-1);</span>
<span class="lineNum">    1905 </span>            :   }
<span class="lineNum">    1906 </span>            : 
<span class="lineNum">    1907 </span>            :   //----------- END OF VARIANT A ------------------
<span class="lineNum">    1908 </span>            : #endif
<span class="lineNum">    1909 </span><span class="lineNoCov">          0 :   if(phopro_.irep==0) phopro_.probh=0.0;</span>
<span class="lineNum">    1910 </span>            :   PRKILL=0.0;
<span class="lineNum">    1911 </span><span class="lineNoCov">          0 :   if(phokey_.iexp){           // IEXP</span>
<span class="lineNum">    1912 </span><span class="lineNoCov">          0 :     phoexp_.nchan=phoexp_.nchan+1;</span>
<span class="lineNum">    1913 </span><span class="lineNoCov">          0 :     if(phoexp_.expini){    // EXPINI</span>
<span class="lineNum">    1914 </span><span class="lineNoCov">          0 :       phoexp_.pro[phoexp_.nchan-i]=PRHARD+0.05*(1.0+phokey_.fint); // we store hard photon emission prob </span>
<span class="lineNum">    1915 </span>            :                                                                    //for leg phoexp_.nchan
<span class="lineNum">    1916 </span>            :       PRHARD=0.0;                                                // to kill emission at initialization call
<span class="lineNum">    1917 </span><span class="lineNoCov">          0 :       phopro_.probh=PRHARD;</span>
<span class="lineNum">    1918 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1919 </span>            :     else{                // EXPINI
<span class="lineNum">    1920 </span>            :       PRSUM=0.0;
<span class="lineNum">    1921 </span><span class="lineNoCov">          0 :       for(K=phoexp_.nchan;K&lt;=phoexp_.NX;K++) PRSUM=PRSUM+phoexp_.pro[K-i];</span>
<span class="lineNum">    1922 </span><span class="lineNoCov">          0 :       PRHARD=PRHARD/PRSUM;  // note that PRHARD may be smaller than </span>
<span class="lineNum">    1923 </span>            :                             //phoexp_.pro[phoexp_.nchan) because it is calculated
<span class="lineNum">    1924 </span>            :                             // for kinematical configuartion as is 
<span class="lineNum">    1925 </span>            :                             // (with effects of previous photons)
<span class="lineNum">    1926 </span><span class="lineNoCov">          0 :       PRKILL=phoexp_.pro[phoexp_.nchan-i]/PRSUM-PRHARD;</span>
<span class="lineNum">    1927 </span>            : 
<span class="lineNum">    1928 </span>            :     }                     // EXPINI
<span class="lineNum">    1929 </span>            :     PRSOFT=1.0-PRHARD;
<span class="lineNum">    1930 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1931 </span>            :   else{                       // IEXP
<span class="lineNum">    1932 </span><span class="lineNoCov">          0 :     PRHARD=PRHARD*PHOFAC(0); // PHOFAC is used to control eikonal </span>
<span class="lineNum">    1933 </span>            :                              // formfactors for non exp version only
<span class="lineNum">    1934 </span>            :                              // here PHOFAC(0)=1 at least now.
<span class="lineNum">    1935 </span><span class="lineNoCov">          0 :     phopro_.probh=PRHARD;</span>
<span class="lineNum">    1936 </span>            :   }                         // IEXP
<span class="lineNum">    1937 </span><span class="lineNoCov">          0 :   PRSOFT=1.0-PRHARD;</span>
<span class="lineNum">    1938 </span>            :   //--
<span class="lineNum">    1939 </span>            :   //--   Check on kinematical bounds
<span class="lineNum">    1940 </span><span class="lineNoCov">          0 :   if (phokey_.iexp){</span>
<span class="lineNum">    1941 </span><span class="lineNoCov">          0 :     if(PRSOFT&lt;-5.0E-8){</span>
<span class="lineNum">    1942 </span>            :       DATA=PRSOFT;
<span class="lineNum">    1943 </span><span class="lineNoCov">          0 :       PHOERR(2,&quot;PHOENE&quot;,DATA);</span>
<span class="lineNum">    1944 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1945 </span>            :   }
<span class="lineNum">    1946 </span>            :   else{
<span class="lineNum">    1947 </span><span class="lineNoCov">          0 :     if (PRSOFT&lt;0.1){</span>
<span class="lineNum">    1948 </span>            :       DATA=PRSOFT;
<span class="lineNum">    1949 </span><span class="lineNoCov">          0 :       PHOERR(2,&quot;PHOENE&quot;,DATA);</span>
<span class="lineNum">    1950 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1951 </span>            :   }
<span class="lineNum">    1952 </span>            : 
<span class="lineNum">    1953 </span><span class="lineNoCov">          0 :   RRR=Photos::randomDouble();</span>
<span class="lineNum">    1954 </span><span class="lineNoCov">          0 :   if (RRR&lt;PRSOFT){</span>
<span class="lineNum">    1955 </span>            :     //--
<span class="lineNum">    1956 </span>            :     //--   No photon... (ie. photon too soft)
<span class="lineNum">    1957 </span><span class="lineNoCov">          0 :     phophs_.xphoto=0.0;</span>
<span class="lineNum">    1958 </span><span class="lineNoCov">          0 :     if (RRR&lt;PRKILL) phophs_.xphoto=-5.0;  //No photon...no further trials</span>
<span class="lineNum">    1959 </span>            :   }
<span class="lineNum">    1960 </span>            :   else{
<span class="lineNum">    1961 </span>            :   //--
<span class="lineNum">    1962 </span>            :   //--   Hard  photon... (ie.  photon  hard enough).
<span class="lineNum">    1963 </span>            :   //--   Calculate  Altarelli-Parisi Kernel
<span class="lineNum">    1964 </span>            :   do{
<span class="lineNum">    1965 </span><span class="lineNoCov">          0 :     phophs_.xphoto=exp(Photos::randomDouble()*log(phocop_.xphcut/phophs_.xphmax));</span>
<span class="lineNum">    1966 </span><span class="lineNoCov">          0 :     phophs_.xphoto=phophs_.xphoto*phophs_.xphmax;}</span>
<span class="lineNum">    1967 </span><span class="lineNoCov">          0 :   while(Photos::randomDouble()&gt;((1.0+pow(1.0-phophs_.xphoto/phophs_.xphmax,2))/2.0));</span>
<span class="lineNum">    1968 </span>            :   }
<span class="lineNum">    1969 </span>            : 
<span class="lineNum">    1970 </span>            :   //--
<span class="lineNum">    1971 </span>            :   //--   Calculate parameter for PHOFAC function
<span class="lineNum">    1972 </span><span class="lineNoCov">          0 :   phopro_.xf=4.0* phomom_.mchsqr*MPASQR/pow(MPASQR+ phomom_.mchsqr-phomom_.mnesqr,2);</span>
<span class="lineNum">    1973 </span><span class="lineNoCov">          0 :   return;</span>
<span class="lineNum">    1974 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1975 </span>            : 
<span class="lineNum">    1976 </span>            : 
<span class="lineNum">    1977 </span>            : //----------------------------------------------------------------------
<span class="lineNum">    1978 </span>            : //
<span class="lineNum">    1979 </span>            : //    PHOTOS:   Photon radiation in decays
<span class="lineNum">    1980 </span>            : //
<span class="lineNum">    1981 </span>            : //    Purpose:  Order (alpha) radiative corrections  are  generated  in
<span class="lineNum">    1982 </span>            : //              the decay of the IPPAR-th particle in the HEP-like
<span class="lineNum">    1983 </span>            : //              common /PHOEVT/.  Photon radiation takes place from one
<span class="lineNum">    1984 </span>            : //              of the charged daughters of the decaying particle IPPAR
<span class="lineNum">    1985 </span>            : //              WT is calculated, eventual rejection will be performed
<span class="lineNum">    1986 </span>            : //              later after inclusion of interference weight.
<span class="lineNum">    1987 </span>            : //
<span class="lineNum">    1988 </span>            : //    Input Parameter:    IPPAR:  Pointer   to   decaying  particle  in
<span class="lineNum">    1989 </span>            : //                                /PHOEVT/ and the common itself,
<span class="lineNum">    1990 </span>            : //
<span class="lineNum">    1991 </span>            : //    Output Parameters:  Common  /PHOEVT/, either  with  or  without a
<span class="lineNum">    1992 </span>            : //                                photon(s) added.
<span class="lineNum">    1993 </span>            : //                        WT      weight of the configuration 
<span class="lineNum">    1994 </span>            : //
<span class="lineNum">    1995 </span>            : //    Author(s):  Z. Was, B. van Eijk             Created at:  26/11/89
<span class="lineNum">    1996 </span>            : //                                                Last Update: 12/07/13
<span class="lineNum">    1997 </span>            : //
<a name="1998"><span class="lineNum">    1998 </span>            : //----------------------------------------------------------------------</a>
<span class="lineNum">    1999 </span>            : 
<span class="lineNum">    2000 </span>            : void PHOPRE(int IPARR,double *pWT,int *pNEUDAU,int *pNCHARB){
<span class="lineNum">    2001 </span><span class="lineNoCov">          0 :   int CHAPOI[pho.nmxhep];</span>
<span class="lineNum">    2002 </span><span class="lineNoCov">          0 :   double MINMAS,MPASQR,MCHREN;</span>
<span class="lineNum">    2003 </span><span class="lineNoCov">          0 :   double EPS,DEL1,DEL2,DATA,BIGLOG;</span>
<span class="lineNum">    2004 </span>            :   double MASSUM;
<span class="lineNum">    2005 </span>            :   int IP,IPPAR,I,J,ME,NCHARG,NEUPOI,NLAST;
<span class="lineNum">    2006 </span>            :   int IDABS;
<span class="lineNum">    2007 </span>            :   double WGT;
<span class="lineNum">    2008 </span>            :   int IDME;
<span class="lineNum">    2009 </span>            :   double a,b;
<span class="lineNum">    2010 </span>            :   double &amp;WT = *pWT;
<span class="lineNum">    2011 </span>            :   int &amp;NEUDAU = *pNEUDAU;
<span class="lineNum">    2012 </span>            :   int &amp;NCHARB = *pNCHARB;
<span class="lineNum">    2013 </span>            : 
<span class="lineNum">    2014 </span>            :   static int i=1;
<span class="lineNum">    2015 </span>            : 
<span class="lineNum">    2016 </span>            :   //--
<span class="lineNum">    2017 </span>            :   IPPAR=IPARR;
<span class="lineNum">    2018 </span>            :   //--   Store pointers for cascade treatement...
<span class="lineNum">    2019 </span>            :   IP=IPPAR;
<span class="lineNum">    2020 </span>            :   NLAST=pho.nhep;
<span class="lineNum">    2021 </span>            : 
<span class="lineNum">    2022 </span>            :   //--
<span class="lineNum">    2023 </span>            :   //--   Check decay multiplicity..
<span class="lineNum">    2024 </span><span class="lineNoCov">          0 :   if (pho.jdahep[IP-i][1-i]==0) return;</span>
<span class="lineNum">    2025 </span>            : 
<span class="lineNum">    2026 </span>            :   //--
<span class="lineNum">    2027 </span>            :   //--   Loop over daughters, determine charge multiplicity
<span class="lineNum">    2028 </span>            : 
<span class="lineNum">    2029 </span>            :   NCHARG=0;
<span class="lineNum">    2030 </span><span class="lineNoCov">          0 :   phopro_.irep=0;</span>
<span class="lineNum">    2031 </span>            :   MINMAS=0.0;
<span class="lineNum">    2032 </span>            :   MASSUM=0.0;
<span class="lineNum">    2033 </span><span class="lineNoCov">          0 :   for (I=pho.jdahep[IP-i][1-i];I&lt;=pho.jdahep[IP-i][2-i];I++){</span>
<span class="lineNum">    2034 </span>            :     //--
<span class="lineNum">    2035 </span>            :     //--
<span class="lineNum">    2036 </span>            :     //--   Exclude marked particles, quarks and gluons etc...
<span class="lineNum">    2037 </span><span class="lineNoCov">          0 :     IDABS=abs(pho.idhep[I-i]);</span>
<span class="lineNum">    2038 </span><span class="lineNoCov">          0 :     if (pho.qedrad[I-pho.jdahep[IP-i][1-i]+3-i]){</span>
<span class="lineNum">    2039 </span><span class="lineNoCov">          0 :       if(PHOCHA(pho.idhep[I-i])!=0){</span>
<span class="lineNum">    2040 </span><span class="lineNoCov">          0 :         NCHARG=NCHARG+1;</span>
<span class="lineNum">    2041 </span><span class="lineNoCov">          0 :         if(NCHARG&gt;pho.nmxhep){</span>
<span class="lineNum">    2042 </span><span class="lineNoCov">          0 :           DATA=NCHARG;</span>
<span class="lineNum">    2043 </span><span class="lineNoCov">          0 :           PHOERR(1,&quot;PHOTOS&quot;,DATA);</span>
<span class="lineNum">    2044 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2045 </span><span class="lineNoCov">          0 :         CHAPOI[NCHARG-i]=I;</span>
<span class="lineNum">    2046 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    2047 </span><span class="lineNoCov">          0 :       MINMAS=MINMAS+pho.phep[I-i][5-i]*pho.phep[I-i][5-i];</span>
<span class="lineNum">    2048 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2049 </span><span class="lineNoCov">          0 :     MASSUM=MASSUM+pho.phep[I-i][5-i];</span>
<span class="lineNum">    2050 </span>            :   }
<span class="lineNum">    2051 </span>            : 
<span class="lineNum">    2052 </span><span class="lineNoCov">          0 :   if (NCHARG!=0){</span>
<span class="lineNum">    2053 </span>            :     //--
<span class="lineNum">    2054 </span>            :     //--   Check that sum of daughter masses does not exceed parent mass
<span class="lineNum">    2055 </span><span class="lineNoCov">          0 :     if ((pho.phep[IP-i][5-i]-MASSUM)/pho.phep[IP-i][5-i]&gt;2.0*phocop_.xphcut){</span>
<span class="lineNum">    2056 </span>            :       //--
<span class="lineNum">    2057 </span>            :       label30:
<span class="lineNum">    2058 </span>            : 
<span class="lineNum">    2059 </span>            : //  do{
<span class="lineNum">    2060 </span>            :     
<span class="lineNum">    2061 </span><span class="lineNoCov">          0 :       for (J=1;J&lt;=3;J++) phomom_.pneutr[J-i] =-pho.phep[CHAPOI[NCHARG-i]-i][J-i];</span>
<span class="lineNum">    2062 </span><span class="lineNoCov">          0 :       phomom_.pneutr[4-i]=pho.phep[IP-i][5-i]-pho.phep[CHAPOI[NCHARG-i]-i][4-i];</span>
<span class="lineNum">    2063 </span>            :       //--
<span class="lineNum">    2064 </span>            :       //--   Calculate  invariant  mass of 'neutral' etc. systems
<span class="lineNum">    2065 </span><span class="lineNoCov">          0 :       MPASQR=pho.phep[IP-i][5-i]*pho.phep[IP-i][5-i];</span>
<span class="lineNum">    2066 </span><span class="lineNoCov">          0 :       phomom_.mchsqr=pow(pho.phep[CHAPOI[NCHARG-i]-i][5-i],2);</span>
<span class="lineNum">    2067 </span><span class="lineNoCov">          0 :       if((pho.jdahep[IP-i][2-i]-pho.jdahep[IP-i][1-i])==1){</span>
<span class="lineNum">    2068 </span>            :         NEUPOI=pho.jdahep[IP-i][1-i];
<span class="lineNum">    2069 </span><span class="lineNoCov">          0 :         if(NEUPOI==CHAPOI[NCHARG-i]) NEUPOI=pho.jdahep[IP-i][2-i];</span>
<span class="lineNum">    2070 </span><span class="lineNoCov">          0 :         phomom_.mnesqr=pho.phep[NEUPOI-i][5-i]*pho.phep[NEUPOI-i][5-i];</span>
<span class="lineNum">    2071 </span><span class="lineNoCov">          0 :         phomom_.pneutr[5-i]=pho.phep[NEUPOI-i][5-i];</span>
<span class="lineNum">    2072 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    2073 </span>            :       else{
<span class="lineNum">    2074 </span><span class="lineNoCov">          0 :         phomom_.mnesqr=pow(phomom_.pneutr[4-i],2)-pow(phomom_.pneutr[1-i],2)-pow(phomom_.pneutr[2-i],2)-pow(phomom_.pneutr[3-i],2);</span>
<span class="lineNum">    2075 </span><span class="lineNoCov">          0 :         phomom_.mnesqr=max(phomom_.mnesqr,MINMAS-phomom_.mchsqr);</span>
<span class="lineNum">    2076 </span><span class="lineNoCov">          0 :         phomom_.pneutr[5-i]=sqrt(phomom_.mnesqr);</span>
<span class="lineNum">    2077 </span>            :       }
<span class="lineNum">    2078 </span>            : 
<span class="lineNum">    2079 </span>            :       //--
<span class="lineNum">    2080 </span>            :       //--   Determine kinematical limit...
<span class="lineNum">    2081 </span><span class="lineNoCov">          0 :       phophs_.xphmax=(MPASQR-pow(phomom_.pneutr[5-i]+pho.phep[CHAPOI[NCHARG-i]-i][5-i],2))/MPASQR;</span>
<span class="lineNum">    2082 </span>            : 
<span class="lineNum">    2083 </span>            :       //--
<span class="lineNum">    2084 </span>            :       //--   Photon energy fraction...
<span class="lineNum">    2085 </span><span class="lineNoCov">          0 :       PHOENE(MPASQR,&amp;MCHREN,&amp;phwt_.beta,&amp;BIGLOG,pho.idhep[CHAPOI[NCHARG-i]-i]);</span>
<span class="lineNum">    2086 </span>            :      //--
<span class="lineNum">    2087 </span>            : 
<span class="lineNum">    2088 </span><span class="lineNoCov">          0 :       if (phophs_.xphoto&lt;-4.0) {</span>
<span class="lineNum">    2089 </span>            :         NCHARG=0;                 // we really stop trials
<span class="lineNum">    2090 </span><span class="lineNoCov">          0 :         phophs_.xphoto=0.0;       // in this case !!</span>
<span class="lineNum">    2091 </span>            :         //--   Energy fraction not too large (very seldom) ? Define angle.
<span class="lineNum">    2092 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    2093 </span><span class="lineNoCov">          0 :       else if ((phophs_.xphoto&lt;phocop_.xphcut) || (phophs_.xphoto &gt; phophs_.xphmax)){</span>
<span class="lineNum">    2094 </span>            :         //--
<span class="lineNum">    2095 </span>            :         //--   No radiation was accepted, check  for more daughters  that may ra-
<span class="lineNum">    2096 </span>            :         //--   diate and correct radiation probability...
<span class="lineNum">    2097 </span><span class="lineNoCov">          0 :         NCHARG=NCHARG-1;</span>
<span class="lineNum">    2098 </span><span class="lineNoCov">          0 :         if(NCHARG&gt;0)  phopro_.irep=phopro_.irep+1;</span>
<span class="lineNum">    2099 </span><span class="lineNoCov">          0 :         if(NCHARG&gt;0) goto label30;</span>
<span class="lineNum">    2100 </span>            :       }
<span class="lineNum">    2101 </span>            :       else{    
<span class="lineNum">    2102 </span>            :         //--
<span class="lineNum">    2103 </span>            :         //--   Angle is generated  in  the  frame defined  by  charged vector and
<span class="lineNum">    2104 </span>            :         //--   PNEUTR, distribution is taken in the infrared limit...
<span class="lineNum">    2105 </span><span class="lineNoCov">          0 :         EPS=MCHREN/(1.0+phwt_.beta);</span>
<span class="lineNum">    2106 </span>            :         //--
<span class="lineNum">    2107 </span>            :         //--   Calculate sin(theta) and cos(theta) from interval variables
<span class="lineNum">    2108 </span><span class="lineNoCov">          0 :         DEL1=(2.0-EPS)*pow(EPS/(2.0-EPS),Photos::randomDouble());</span>
<span class="lineNum">    2109 </span><span class="lineNoCov">          0 :         DEL2=2.0-DEL1;</span>
<span class="lineNum">    2110 </span>            : 
<span class="lineNum">    2111 </span>            : #ifdef VARIANTB
<span class="lineNum">    2112 </span>            :         // ----------- VARIANT B ------------------
<span class="lineNum">    2113 </span>            :         // corrections for more efiicient interference correction,
<span class="lineNum">    2114 </span>            :         // instead of doubling crude distribution, we add flat parallel channel
<span class="lineNum">    2115 </span>            :         if(Photos::randomDouble()&lt;BIGLOG/phwt_.beta/(BIGLOG/phwt_.beta+2*phokey_.fint)){
<span class="lineNum">    2116 </span>            :           phophs_.costhg=(1.0-DEL1)/phwt_.beta;
<span class="lineNum">    2117 </span>            :           phophs_.sinthg=sqrt(DEL1*DEL2-MCHREN)/phwt_.beta;
<span class="lineNum">    2118 </span>            :         }
<span class="lineNum">    2119 </span>            :         else{
<span class="lineNum">    2120 </span>            :           phophs_.costhg=-1.0+2*Photos::randomDouble();
<span class="lineNum">    2121 </span>            :           phophs_.sinthg= sqrt(1.0-phophs_.costhg*phophs_.costhg);
<span class="lineNum">    2122 </span>            :         }
<span class="lineNum">    2123 </span>            :  
<span class="lineNum">    2124 </span>            :         if (phokey_.fint&gt;1.0){
<span class="lineNum">    2125 </span>            :  
<span class="lineNum">    2126 </span>            :           WGT=1.0/(1.0-phwt_.beta*phophs_.costhg);
<span class="lineNum">    2127 </span>            :           WGT=WGT/(WGT+phokey_.fint);
<span class="lineNum">    2128 </span>            :           //       WGT=1.0   // ??
<span class="lineNum">    2129 </span>            :         }
<span class="lineNum">    2130 </span>            :         else{
<span class="lineNum">    2131 </span>            :           WGT=1.0;
<span class="lineNum">    2132 </span>            :         }
<span class="lineNum">    2133 </span>            :         //
<span class="lineNum">    2134 </span>            :         // ----------- END OF VARIANT B ------------------
<span class="lineNum">    2135 </span>            : #else
<span class="lineNum">    2136 </span>            :         // ----------- VARIANT A ------------------
<span class="lineNum">    2137 </span><span class="lineNoCov">          0 :         phophs_.costhg=(1.0-DEL1)/phwt_.beta;</span>
<span class="lineNum">    2138 </span><span class="lineNoCov">          0 :         phophs_.sinthg=sqrt(DEL1*DEL2-MCHREN)/phwt_.beta;</span>
<span class="lineNum">    2139 </span>            :         WGT=1.0;
<span class="lineNum">    2140 </span>            :         // ----------- END OF VARIANT A ------------------
<span class="lineNum">    2141 </span>            : #endif
<span class="lineNum">    2142 </span>            :         //--
<span class="lineNum">    2143 </span>            :         //--   Determine spin of  particle and construct code  for matrix element
<span class="lineNum">    2144 </span><span class="lineNoCov">          0 :         ME=(int) (2.0*PHOSPI(pho.idhep[CHAPOI[NCHARG-i]-i])+1.0);</span>
<span class="lineNum">    2145 </span>            :         //--
<span class="lineNum">    2146 </span>            :         //--   Weighting procedure with 'exact' matrix element, reconstruct kine-
<span class="lineNum">    2147 </span>            :         //--   matics for photon, neutral and charged system and update /PHOEVT/.
<span class="lineNum">    2148 </span>            :         //--   Find pointer to the first component of 'neutral' system
<span class="lineNum">    2149 </span><span class="lineNoCov">          0 :         for  (I=pho.jdahep[IP-i][1-i];I&lt;=pho.jdahep[IP-i][2-i];I++){</span>
<span class="lineNum">    2150 </span><span class="lineNoCov">          0 :           if(I!=CHAPOI[NCHARG-i]){</span>
<span class="lineNum">    2151 </span><span class="lineNoCov">          0 :             NEUDAU=I;</span>
<span class="lineNum">    2152 </span><span class="lineNoCov">          0 :             goto label51;   //break; // to 51</span>
<span class="lineNum">    2153 </span>            :           }
<span class="lineNum">    2154 </span>            :         }
<span class="lineNum">    2155 </span>            :         //--
<span class="lineNum">    2156 </span>            :         //--   Pointer not found...
<span class="lineNum">    2157 </span><span class="lineNoCov">          0 :         DATA=NCHARG;</span>
<span class="lineNum">    2158 </span><span class="lineNoCov">          0 :         PHOERR(5,&quot;PHOKIN&quot;,DATA);</span>
<span class="lineNum">    2159 </span>            :         label51:
<span class="lineNum">    2160 </span>            :  
<span class="lineNum">    2161 </span><span class="lineNoCov">          0 :         NCHARB=CHAPOI[NCHARG-i];</span>
<span class="lineNum">    2162 </span><span class="lineNoCov">          0 :         NCHARB=NCHARB-pho.jdahep[IP-i][1-i]+3;</span>
<span class="lineNum">    2163 </span><span class="lineNoCov">          0 :         NEUDAU=NEUDAU-pho.jdahep[IP-i][1-i]+3;</span>
<span class="lineNum">    2164 </span>            : 
<span class="lineNum">    2165 </span><span class="lineNoCov">          0 :         IDME=PH_HEPEVT_Interface::ME_channel;</span>
<span class="lineNum">    2166 </span>            :         //  two options introduced temporarily. 
<span class="lineNum">    2167 </span>            :         //  In future always PHOCOR--&gt;PHOCORN
<span class="lineNum">    2168 </span>            :         //  Tests and adjustment of wts for Znlo needed.
<span class="lineNum">    2169 </span>            :         //  otherwise simple change. PHOCORN implements
<span class="lineNum">    2170 </span>            :         //  exact ME for scalar to 2 scalar decays.
<span class="lineNum">    2171 </span><span class="lineNoCov">          0 :         if(IDME==2){</span>
<span class="lineNum">    2172 </span><span class="lineNoCov">          0 :           b=PHOCORN(MPASQR,MCHREN,ME);</span>
<span class="lineNum">    2173 </span><span class="lineNoCov">          0 :           WT=b*WGT;</span>
<span class="lineNum">    2174 </span><span class="lineNoCov">          0 :           WT=WT/(1-phophs_.xphoto/phophs_.xphmax+0.5*pow(phophs_.xphoto/phophs_.xphmax,2))*(1-phophs_.xphoto/phophs_.xphmax)/2; // factor to go to WnloWT</span>
<span class="lineNum">    2175 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2176 </span><span class="lineNoCov">          0 :         else if(IDME==1){</span>
<span class="lineNum">    2177 </span>            : 
<span class="lineNum">    2178 </span><span class="lineNoCov">          0 :           a=PHOCOR(MPASQR,MCHREN,ME);</span>
<span class="lineNum">    2179 </span><span class="lineNoCov">          0 :           b=PHOCORN(MPASQR,MCHREN,ME);</span>
<span class="lineNum">    2180 </span><span class="lineNoCov">          0 :           WT=b*WGT ;</span>
<span class="lineNum">    2181 </span><span class="lineNoCov">          0 :         WT=WT*phwt_.wt1*phwt_.wt2*phwt_.wt3/phocorwt_.phocorwt1/phocorwt_.phocorwt2/phocorwt_.phocorwt3; // factor to go to ZnloWT</span>
<span class="lineNum">    2182 </span>            :           //        write(*,*) ' -----------'
<span class="lineNum">    2183 </span>            :           //        write(*,*)   phwt_.wt1,' ',phwt_.wt2,' ',phwt_.wt3
<span class="lineNum">    2184 </span>            :           //        write(*,*)   phocorwt_.phocorwt1,' ',phocorwt_.phocorwt2,' ',phocorwt_.phocorwt3
<span class="lineNum">    2185 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2186 </span>            :         else{
<span class="lineNum">    2187 </span>            :           a=PHOCOR(MPASQR,MCHREN,ME);
<span class="lineNum">    2188 </span><span class="lineNoCov">          0 :           WT=a*WGT;</span>
<span class="lineNum">    2189 </span>            : //          WT=b*WGT; // /(1-phophs_.xphoto/phophs_.xphmax+0.5*pow(phophs_.xphoto/phophs_.xphmax,2))*(1-phophs_.xphoto/phophs_.xphmax)/2;
<span class="lineNum">    2190 </span>            :         }
<span class="lineNum">    2191 </span>            :       
<span class="lineNum">    2192 </span>            : 
<span class="lineNum">    2193 </span>            : 
<span class="lineNum">    2194 </span>            :       }
<span class="lineNum">    2195 </span>            :     }
<span class="lineNum">    2196 </span>            :     else{
<span class="lineNum">    2197 </span>            :       DATA=pho.phep[IP-i][5-i]-MASSUM;
<span class="lineNum">    2198 </span><span class="lineNoCov">          0 :       PHOERR(10,&quot;PHOTOS&quot;,DATA);</span>
<span class="lineNum">    2199 </span>            :     }
<span class="lineNum">    2200 </span>            :   }   
<span class="lineNum">    2201 </span>            :      
<span class="lineNum">    2202 </span>            :   //--
<span class="lineNum">    2203 </span><span class="lineNoCov">          0 :   return;</span>
<span class="lineNum">    2204 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2205 </span>            : 
<span class="lineNum">    2206 </span>            : 
<span class="lineNum">    2207 </span>            : //----------------------------------------------------------------------
<span class="lineNum">    2208 </span>            : //
<span class="lineNum">    2209 </span>            : //    PHOMAK:   PHOtos MAKe
<span class="lineNum">    2210 </span>            : //
<span class="lineNum">    2211 </span>            : //    Purpose:  Single or double bremstrahlung radiative corrections  
<span class="lineNum">    2212 </span>            : //              are generated in  the decay of the IPPAR-th particle in 
<span class="lineNum">    2213 </span>            : //              the  HEP common /PH_HEPEVT/. Example of the use of 
<span class="lineNum">    2214 </span>            : //              general tools.
<span class="lineNum">    2215 </span>            : //
<span class="lineNum">    2216 </span>            : //    Input Parameter:    IPPAR:  Pointer   to   decaying  particle  in
<span class="lineNum">    2217 </span>            : //                                /PH_HEPEVT/ and the common itself
<span class="lineNum">    2218 </span>            : //
<span class="lineNum">    2219 </span>            : //    Output Parameters:  Common  /PH_HEPEVT/, either  with  or  without
<span class="lineNum">    2220 </span>            : //                                particles added.
<span class="lineNum">    2221 </span>            : //
<span class="lineNum">    2222 </span>            : //    Author(s):  Z. Was,                         Created at:  26/05/93
<span class="lineNum">    2223 </span>            : //                                                Last Update: 29/01/05
<span class="lineNum">    2224 </span>            : //
<a name="2225"><span class="lineNum">    2225 </span>            : //----------------------------------------------------------------------</a>
<span class="lineNum">    2226 </span>            : 
<span class="lineNum">    2227 </span>            : void PHOMAK(int IPPAR,int NHEP0){
<span class="lineNum">    2228 </span>            : 
<span class="lineNum">    2229 </span>            :   double DATA;
<span class="lineNum">    2230 </span>            :   int IP,NCHARG,IDME;
<span class="lineNum">    2231 </span>            :   int IDUM;
<span class="lineNum">    2232 </span><span class="lineNoCov">          0 :   int NCHARB,NEUDAU;</span>
<span class="lineNum">    2233 </span><span class="lineNoCov">          0 :   double RN,WT;</span>
<span class="lineNum">    2234 </span><span class="lineNoCov">          0 :   bool BOOST;</span>
<span class="lineNum">    2235 </span>            :   static int i=1;
<span class="lineNum">    2236 </span>            :   //--
<span class="lineNum">    2237 </span>            :   IP=IPPAR;
<span class="lineNum">    2238 </span>            :   IDUM=1;
<span class="lineNum">    2239 </span>            :   NCHARG=0;
<span class="lineNum">    2240 </span>            :   //--
<span class="lineNum">    2241 </span><span class="lineNoCov">          0 :   PHOIN(IP,&amp;BOOST,&amp;NHEP0);</span>
<span class="lineNum">    2242 </span><span class="lineNoCov">          0 :   PHOCHK(hep.jdahep[IP-i][1-i]);</span>
<span class="lineNum">    2243 </span><span class="lineNoCov">          0 :   WT=0.0;</span>
<span class="lineNum">    2244 </span><span class="lineNoCov">          0 :   PHOPRE(1,&amp;WT,&amp;NEUDAU,&amp;NCHARB);</span>
<span class="lineNum">    2245 </span>            : 
<span class="lineNum">    2246 </span><span class="lineNoCov">          0 :   if(WT==0.0) return;</span>
<span class="lineNum">    2247 </span><span class="lineNoCov">          0 :   RN=Photos::randomDouble();</span>
<span class="lineNum">    2248 </span>            :   // PHODO is caling randomDouble(), thus change of series if it is moved before if
<span class="lineNum">    2249 </span><span class="lineNoCov">          0 :   PHODO(1,NCHARB,NEUDAU);</span>
<span class="lineNum">    2250 </span>            : 
<span class="lineNum">    2251 </span>            : #ifdef VARIANTB
<span class="lineNum">    2252 </span>            :   // we eliminate divisions  /phokey_.fint in variant B.  ???
<span class="lineNum">    2253 </span>            : #endif
<span class="lineNum">    2254 </span>            :   // get ID of channel dependent ME, ID=0 means no 
<span class="lineNum">    2255 </span>            : 
<span class="lineNum">    2256 </span><span class="lineNoCov">          0 :   IDME=PH_HEPEVT_Interface::ME_channel;</span>
<span class="lineNum">    2257 </span>            :   // corrections for matrix elements
<span class="lineNum">    2258 </span>            :   // controlled by IDME
<span class="lineNum">    2259 </span>            :   // write(*,*) 'KANALIK IDME=',IDME
<span class="lineNum">    2260 </span>            : 
<span class="lineNum">    2261 </span><span class="lineNoCov">          0 :   if(     IDME==0) {                                    // default </span>
<span class="lineNum">    2262 </span>            : 
<span class="lineNum">    2263 </span><span class="lineNoCov">          0 :     if(phokey_.interf) WT=WT*PHINT(IDUM);</span>
<span class="lineNum">    2264 </span><span class="lineNoCov">          0 :     if(phokey_.ifw) PHOBW(&amp;WT);                          // extra weight for leptonic W decay </span>
<span class="lineNum">    2265 </span>            :   }
<span class="lineNum">    2266 </span><span class="lineNoCov">          0 :   else if (IDME==2){                                    // ME weight for leptonic W decay</span>
<span class="lineNum">    2267 </span>            : 
<span class="lineNum">    2268 </span><span class="lineNoCov">          0 :     PhotosMEforW::PHOBWnlo(&amp;WT);</span>
<span class="lineNum">    2269 </span><span class="lineNoCov">          0 :     WT=WT*2.0;</span>
<span class="lineNum">    2270 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2271 </span><span class="lineNoCov">          0 :   else if (IDME==1){                                     //  ME weight for leptonic Z decay</span>
<span class="lineNum">    2272 </span>            : 
<span class="lineNum">    2273 </span><span class="lineNoCov">          0 :     WT=WT*PhotosMEforZ::phwtnlo();</span>
<span class="lineNum">    2274 </span>            :   }
<span class="lineNum">    2275 </span>            :   else{
<span class="lineNum">    2276 </span><span class="lineNoCov">          0 :     cout &lt;&lt; &quot;problem with ME_CHANNEL  IDME= &quot; &lt;&lt; IDME &lt;&lt; endl;</span>
<span class="lineNum">    2277 </span><span class="lineNoCov">          0 :     exit(-1);</span>
<span class="lineNum">    2278 </span>            :   }
<span class="lineNum">    2279 </span>            : 
<span class="lineNum">    2280 </span>            : #ifndef VARIANTB
<span class="lineNum">    2281 </span><span class="lineNoCov">          0 :   WT = WT/phokey_.fint; // FINT must be in variant A</span>
<span class="lineNum">    2282 </span>            : #endif
<span class="lineNum">    2283 </span>            : 
<span class="lineNum">    2284 </span>            :   DATA=WT; 
<span class="lineNum">    2285 </span><span class="lineNoCov">          0 :   if (WT&gt;1.0) PHOERR(3,&quot;WT_INT&quot;,DATA);</span>
<span class="lineNum">    2286 </span>            :   // weighting
<span class="lineNum">    2287 </span><span class="lineNoCov">          0 :   if (RN&lt;=WT){</span>
<span class="lineNum">    2288 </span><span class="lineNoCov">          0 :     PHOOUT(IP,BOOST,NHEP0);</span>
<span class="lineNum">    2289 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2290 </span><span class="lineNoCov">          0 :   return;</span>
<span class="lineNum">    2291 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2292 </span>            : 
<span class="lineNum">    2293 </span>            : //----------------------------------------------------------------------
<span class="lineNum">    2294 </span>            : //
<span class="lineNum">    2295 </span>            : //    PHTYPE:   Central manadgement routine.              
<span class="lineNum">    2296 </span>            : //
<span class="lineNum">    2297 </span>            : //    Purpose:   defines what kind of the 
<span class="lineNum">    2298 </span>            : //              actions will be performed at point ID. 
<span class="lineNum">    2299 </span>            : //
<span class="lineNum">    2300 </span>            : //    Input Parameters:       ID:  pointer of particle starting branch
<span class="lineNum">    2301 </span>            : //                                 in /PH_HEPEVT/ to be treated.
<span class="lineNum">    2302 </span>            : //
<span class="lineNum">    2303 </span>            : //    Output Parameters:  Common /PH_HEPEVT/.
<span class="lineNum">    2304 </span>            : //
<span class="lineNum">    2305 </span>            : //    Author(s):  Z. Was                          Created at:  24/05/93
<span class="lineNum">    2306 </span>            : //                P. Golonka                      Last Update: 27/06/04
<a name="2307"><span class="lineNum">    2307 </span>            : //</a>
<span class="lineNum">    2308 </span>            : //----------------------------------------------------------------------
<span class="lineNum">    2309 </span>            : void PHTYPE(int ID){
<span class="lineNum">    2310 </span>            : 
<span class="lineNum">    2311 </span>            :   int K;
<span class="lineNum">    2312 </span>            :   double PRSUM,ESU;
<span class="lineNum">    2313 </span>            :   int NHEP0;
<span class="lineNum">    2314 </span>            :   bool IPAIR;
<span class="lineNum">    2315 </span>            :   double RN,SUM;
<span class="lineNum">    2316 </span>            :   bool IFOUR;
<span class="lineNum">    2317 </span>            :   static int i=1;
<span class="lineNum">    2318 </span>            : 
<span class="lineNum">    2319 </span>            :   //--
<span class="lineNum">    2320 </span><span class="lineNoCov">          0 :   IFOUR=          phokey_.itre; // we can make internal choice whether </span>
<span class="lineNum">    2321 </span>            :                                 // we want 3 or four photons at most.
<span class="lineNum">    2322 </span>            :   IPAIR=true;
<span class="lineNum">    2323 </span>            :   //--   Check decay multiplicity..
<span class="lineNum">    2324 </span><span class="lineNoCov">          0 :   if(hep.jdahep[ID-i][1-i]==0) return;</span>
<span class="lineNum">    2325 </span>            :   //      if (hep.jdahep[ID-i][1-i]==hep.jdahep[ID-i][2-i]) return;
<span class="lineNum">    2326 </span>            :   //--
<span class="lineNum">    2327 </span><span class="lineNoCov">          0 :   NHEP0=hep.nhep;</span>
<span class="lineNum">    2328 </span>            :   //--
<span class="lineNum">    2329 </span><span class="lineNoCov">          0 :   if(phokey_.iexp){</span>
<span class="lineNum">    2330 </span><span class="lineNoCov">          0 :     phoexp_.expini=true;      // Initialization/cleaning</span>
<span class="lineNum">    2331 </span><span class="lineNoCov">          0 :     for(phoexp_.nchan=1;phoexp_.nchan&lt;=phoexp_.NX;phoexp_.nchan++)</span>
<span class="lineNum">    2332 </span><span class="lineNoCov">          0 :         phoexp_.pro[phoexp_.nchan-i]=0.0;        </span>
<span class="lineNum">    2333 </span><span class="lineNoCov">          0 :     phoexp_.nchan=0;</span>
<span class="lineNum">    2334 </span>            :          
<span class="lineNum">    2335 </span><span class="lineNoCov">          0 :     phokey_.fsec=1.0;</span>
<span class="lineNum">    2336 </span><span class="lineNoCov">          0 :     PHOMAK(ID,NHEP0);          // Initialization/crude formfactors into </span>
<span class="lineNum">    2337 </span>            :                                // phoexp_.pro[phoexp_.nchan)
<span class="lineNum">    2338 </span><span class="lineNoCov">          0 :     phoexp_.expini=false;</span>
<span class="lineNum">    2339 </span><span class="lineNoCov">          0 :     RN=Photos::randomDouble();</span>
<span class="lineNum">    2340 </span>            :     PRSUM=0.0;
<span class="lineNum">    2341 </span><span class="lineNoCov">          0 :     for(K=1;K&lt;=phoexp_.NX;K++)PRSUM=PRSUM+phoexp_.pro[K-i];</span>
<span class="lineNum">    2342 </span>            :       
<span class="lineNum">    2343 </span><span class="lineNoCov">          0 :     ESU=exp(-PRSUM);    </span>
<span class="lineNum">    2344 </span>            :     // exponent for crude Poissonian multiplicity 
<span class="lineNum">    2345 </span>            :     // distribution, will be later overwritten 
<span class="lineNum">    2346 </span>            :     // to give probability for k
<span class="lineNum">    2347 </span>            :     SUM=ESU;         
<span class="lineNum">    2348 </span>            :     // distribuant for the crude Poissonian 
<span class="lineNum">    2349 </span>            :     // at first for k=0
<span class="lineNum">    2350 </span><span class="lineNoCov">          0 :     for(K=1;K&lt;=100;K++){      // hard coded max (photon) multiplicity is 100</span>
<span class="lineNum">    2351 </span><span class="lineNoCov">          0 :       if(RN&lt;SUM) break;</span>
<span class="lineNum">    2352 </span><span class="lineNoCov">          0 :       ESU=ESU*PRSUM/K;        // we get at K ESU=EXP(-PRSUM)*PRSUM**K/K!</span>
<span class="lineNum">    2353 </span><span class="lineNoCov">          0 :       SUM=SUM+ESU;            // thus we get distribuant at K.</span>
<span class="lineNum">    2354 </span><span class="lineNoCov">          0 :       phoexp_.nchan=0;</span>
<span class="lineNum">    2355 </span><span class="lineNoCov">          0 :       PHOMAK(ID,NHEP0);       // LOOPING</span>
<span class="lineNum">    2356 </span><span class="lineNoCov">          0 :       if(SUM&gt;1.0-phokey_.expeps) break;</span>
<span class="lineNum">    2357 </span>            :     }
<span class="lineNum">    2358 </span>            :  
<span class="lineNum">    2359 </span>            :   }
<span class="lineNum">    2360 </span><span class="lineNoCov">          0 :   else if(IFOUR){</span>
<span class="lineNum">    2361 </span>            :     //-- quatro photon emission
<span class="lineNum">    2362 </span><span class="lineNoCov">          0 :     phokey_.fsec=1.0;</span>
<span class="lineNum">    2363 </span><span class="lineNoCov">          0 :     RN=Photos::randomDouble();</span>
<span class="lineNum">    2364 </span><span class="lineNoCov">          0 :     if(RN&gt;=23.0/24.0){</span>
<span class="lineNum">    2365 </span><span class="lineNoCov">          0 :       PHOMAK(ID,NHEP0);</span>
<span class="lineNum">    2366 </span><span class="lineNoCov">          0 :       PHOMAK(ID,NHEP0);</span>
<span class="lineNum">    2367 </span><span class="lineNoCov">          0 :       PHOMAK(ID,NHEP0);</span>
<span class="lineNum">    2368 </span><span class="lineNoCov">          0 :       PHOMAK(ID,NHEP0);</span>
<span class="lineNum">    2369 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2370 </span><span class="lineNoCov">          0 :     else if (RN&gt;=17.0/24.0){</span>
<span class="lineNum">    2371 </span><span class="lineNoCov">          0 :       PHOMAK(ID,NHEP0);</span>
<span class="lineNum">    2372 </span><span class="lineNoCov">          0 :       PHOMAK(ID,NHEP0);</span>
<span class="lineNum">    2373 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2374 </span><span class="lineNoCov">          0 :     else if(RN&gt;=9.0/24.0){</span>
<span class="lineNum">    2375 </span><span class="lineNoCov">          0 :       PHOMAK(ID,NHEP0);</span>
<span class="lineNum">    2376 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2377 </span>            :     else{
<span class="lineNum">    2378 </span>            :     }
<span class="lineNum">    2379 </span>            :   }
<span class="lineNum">    2380 </span><span class="lineNoCov">          0 :   else if(phokey_.itre){</span>
<span class="lineNum">    2381 </span>            :     //-- triple photon emission
<span class="lineNum">    2382 </span><span class="lineNoCov">          0 :     phokey_.fsec=1.0;</span>
<span class="lineNum">    2383 </span><span class="lineNoCov">          0 :     RN=Photos::randomDouble();</span>
<span class="lineNum">    2384 </span><span class="lineNoCov">          0 :     if(RN&gt;=5.0/6.0){</span>
<span class="lineNum">    2385 </span><span class="lineNoCov">          0 :       PHOMAK(ID,NHEP0);</span>
<span class="lineNum">    2386 </span><span class="lineNoCov">          0 :       PHOMAK(ID,NHEP0);</span>
<span class="lineNum">    2387 </span><span class="lineNoCov">          0 :       PHOMAK(ID,NHEP0);</span>
<span class="lineNum">    2388 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2389 </span><span class="lineNoCov">          0 :     else if (RN&gt;=2.0/6.0){</span>
<span class="lineNum">    2390 </span><span class="lineNoCov">          0 :       PHOMAK(ID,NHEP0);</span>
<span class="lineNum">    2391 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2392 </span>            :   }
<span class="lineNum">    2393 </span><span class="lineNoCov">          0 :   else if(phokey_.isec){</span>
<span class="lineNum">    2394 </span>            :     //-- double photon emission
<span class="lineNum">    2395 </span><span class="lineNoCov">          0 :     phokey_.fsec=1.0;</span>
<span class="lineNum">    2396 </span><span class="lineNoCov">          0 :     RN=Photos::randomDouble();</span>
<span class="lineNum">    2397 </span><span class="lineNoCov">          0 :     if(RN&gt;=0.5){</span>
<span class="lineNum">    2398 </span><span class="lineNoCov">          0 :       PHOMAK(ID,NHEP0);</span>
<span class="lineNum">    2399 </span><span class="lineNoCov">          0 :       PHOMAK(ID,NHEP0);</span>
<span class="lineNum">    2400 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2401 </span>            :   }
<span class="lineNum">    2402 </span>            :   else{
<span class="lineNum">    2403 </span>            :     //-- single photon emission
<span class="lineNum">    2404 </span>            :     phokey_.fsec=1.0;
<span class="lineNum">    2405 </span><span class="lineNoCov">          0 :     PHOMAK(ID,NHEP0);</span>
<span class="lineNum">    2406 </span>            :   }
<span class="lineNum">    2407 </span>            :   //--
<span class="lineNum">    2408 </span>            :   //-- electron positron pair (coomented out for a while
<span class="lineNum">    2409 </span>            :   //    if (IPAIR)  PHOPAR(ID,NHEP0);
<span class="lineNum">    2410 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2411 </span>            : 
<span class="lineNum">    2412 </span>            : } // namespace Photospp
<span class="lineNum">    2413 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
