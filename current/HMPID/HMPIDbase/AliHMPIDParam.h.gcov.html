<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - HMPID/HMPIDbase/AliHMPIDParam.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">HMPID/HMPIDbase</a> - AliHMPIDParam.h<span style="font-size: 80%;"> (source / <a href="AliHMPIDParam.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">83</td>
            <td class="headerCovTableEntry">148</td>
            <td class="headerCovTableEntryLo">56.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">60</td>
            <td class="headerCovTableEntry">95</td>
            <td class="headerCovTableEntryLo">63.2 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : #ifndef AliHMPIDParam_h</a>
<span class="lineNum">       2 </span>            : #define AliHMPIDParam_h
<span class="lineNum">       3 </span>            : /* Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
<span class="lineNum">       4 </span>            :  * See cxx source for full Copyright notice                               */
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : /* $Id$ */
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : #include &quot;stdio.h&quot;
<span class="lineNum">       9 </span>            : #include &lt;TMath.h&gt;
<span class="lineNum">      10 </span>            : #include &lt;TNamed.h&gt;        //base class
<span class="lineNum">      11 </span>            : #include &lt;TGeoManager.h&gt;   //Instance()
<span class="lineNum">      12 </span>            : #include &lt;TGeoMatrix.h&gt;   //Instance()
<span class="lineNum">      13 </span>            : #include &lt;TVector3.h&gt;      //Lors2Mars() Mars2Lors()
<span class="lineNum">      14 </span>            :  
<span class="lineNum">      15 </span>            : // Class providing all the needed parametrised information
<span class="lineNum">      16 </span>            : // to construct the geometry, to define segmentation and to provide response model
<span class="lineNum">      17 </span>            : // In future will also provide all the staff needed for alignment and calibration
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : class AliHMPIDParam :public TNamed  
<span class="lineNum">      20 </span>            : {
<a name="21"><span class="lineNum">      21 </span>            : public:</a>
<span class="lineNum">      22 </span>            : //ctor&amp;dtor    
<span class="lineNum">      23 </span><span class="lineNoCov">          0 :   virtual        ~AliHMPIDParam() {if (fgInstance){for(Int_t i=0;i&lt;7;i++){delete fM[i];fM[i] = 0x0;};fgInstance=0;}}</span>
<span class="lineNum">      24 </span>            :   
<span class="lineNum">      25 </span>            :   void     Print(Option_t *opt=&quot;&quot;) const;                                         //print current parametrization
<span class="lineNum">      26 </span>            :          
<span class="lineNum">      27 </span>            :   static inline AliHMPIDParam* Instance();                                //pointer to AliHMPIDParam singleton
<span class="lineNum">      28 </span>            :   static inline AliHMPIDParam* InstanceNoGeo();                           //pointer to AliHMPIDParam singleton without geometry.root for MOOD, displays, ...
<span class="lineNum">      29 </span>            : //geo info
<span class="lineNum">      30 </span>            :   enum EChamberData{kMinCh=0,kMaxCh=6,kMinPc=0,kMaxPc=5};      //Segmenation
<span class="lineNum">      31 </span>            :   enum EPadxData{kPadPcX=80,kMinPx=0,kMaxPx=79,kMaxPcx=159};   //Segmentation structure along x
<span class="lineNum">      32 </span>            :   enum EPadyData{kPadPcY=48,kMinPy=0,kMaxPy=47,kMaxPcy=143};   //Segmentation structure along y 
<span class="lineNum">      33 </span>            :   //The electronics takes the 32bit int as: first 9 bits for the pedestal and the second 9 bits for threshold - values below should be within range
<span class="lineNum">      34 </span>            :   enum EPedestalData{kPadMeanZeroCharge=400,kPadSigmaZeroCharge=20,kPadMeanMasked=401,kPadSigmaMasked=20};         //One can go up to 5 sigma cut, overflow is protected in AliHMPIDCalib
<a name="35"><span class="lineNum">      35 </span>            :   </a>
<a name="36"><span class="lineNum">      36 </span>            :       </a>
<a name="37"><span class="lineNum">      37 </span><span class="lineNoCov">          0 :   static Float_t r2d         (                               )     {return 57.2957795;                               }</span></a>
<span class="lineNum">      38 </span><span class="lineCov">    2173114 :   static Float_t SizePadX    (                               )     {return fgCellX;                                  }  //pad size x, [cm]  </span>
<a name="39"><span class="lineNum">      39 </span><span class="lineCov">    2173306 :   static Float_t SizePadY    (                               )     {return fgCellY;                                  }  //pad size y, [cm]  </span></a>
<a name="40"><span class="lineNum">      40 </span>            : </a>
<a name="41"><span class="lineNum">      41 </span><span class="lineNoCov">          0 :   static Float_t SizePcX    (                                )     {return fgPcX;                                    }  // PC size x</span></a>
<a name="42"><span class="lineNum">      42 </span><span class="lineCov">         40 :   static Float_t SizePcY    (                                )     {return fgPcY;                                    }  // PC size y</span></a>
<a name="43"><span class="lineNum">      43 </span><span class="lineCov">        440 :   static Float_t MaxPcX      (Int_t iPc                      )     {return fgkMaxPcX[iPc];                           }  // PC limits</span></a>
<a name="44"><span class="lineNum">      44 </span><span class="lineCov">        440 :   static Float_t MaxPcY      (Int_t iPc                      )     {return fgkMaxPcY[iPc];                           }  // PC limits</span></a>
<a name="45"><span class="lineNum">      45 </span><span class="lineCov">        440 :   static Float_t MinPcX      (Int_t iPc                      )     {return fgkMinPcX[iPc];                           }  // PC limits</span></a>
<a name="46"><span class="lineNum">      46 </span><span class="lineCov">        440 :   static Float_t MinPcY      (Int_t iPc                      )     {return fgkMinPcY[iPc];                           }  // PC limits</span></a>
<a name="47"><span class="lineNum">      47 </span><span class="lineCov">    1293602 :   static Int_t   Nsig        (                               )     {return fgNSigmas;                                 }  //Getter n. sigmas for noise</span></a>
<span class="lineNum">      48 </span><span class="lineCov">       1764 :   static Float_t SizeAllX    (                               )     {return fgAllX;                                   }  //all PCs size x, [cm]        </span>
<a name="49"><span class="lineNum">      49 </span><span class="lineCov">       1764 :   static Float_t SizeAllY    (                               )     {return fgAllY;                                   }  //all PCs size y, [cm]    </span></a>
<a name="50"><span class="lineNum">      50 </span>            : </a>
<span class="lineNum">      51 </span><span class="lineCov">    1086326 :   static Float_t LorsX       (Int_t pc,Int_t padx             )    {return (padx    +0.5)*SizePadX()+fgkMinPcX[pc];  }  //center of the pad x, [cm]</span>
<a name="52"><span class="lineNum">      52 </span><span class="lineCov">    1086528 :   static Float_t LorsY       (Int_t pc,Int_t pady            )     {return (pady    +0.5)*SizePadY()+fgkMinPcY[pc];  }  //center of the pad y, [cm]</span></a>
<a name="53"><span class="lineNum">      53 </span>            : </a>
<a name="54"><span class="lineNum">      54 </span><span class="lineNoCov">          0 :   Float_t ChPhiMin    (Int_t ch                       ) {return Lors2Mars(ch,LorsX(ch,kMinPx)-fX,LorsY(ch,kMinPy)-fY).Phi()*r2d();}      //PhiMin (degree) of the camber ch</span></a>
<a name="55"><span class="lineNum">      55 </span><span class="lineNoCov">          0 :   Float_t ChThMin     (Int_t ch                       ) {return Lors2Mars(ch,LorsX(ch,kMinPx)-fX,LorsY(ch,kMinPy)-fY).Theta()*r2d();}    //ThMin  (degree) of the camber ch</span></a>
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :   Float_t ChPhiMax    (Int_t ch                       ) {return Lors2Mars(ch,LorsX(ch,kMaxPcx)-fX,LorsY(ch,kMaxPcy)-fY).Phi()*r2d();}    //PhiMax (degree) of the camber ch</span>
<span class="lineNum">      57 </span><span class="lineNoCov">          0 :   Float_t ChThMax     (Int_t ch                       ) {return Lors2Mars(ch,LorsX(ch,kMaxPcx)-fX,LorsY(ch,kMaxPcy)-fY).Theta()*r2d();}  //ThMax  (degree) of the camber ch</span>
<span class="lineNum">      58 </span>            : 
<a name="59"><span class="lineNum">      59 </span>            :   inline static void   Lors2Pad(Float_t x,Float_t y,Int_t &amp;pc,Int_t &amp;px,Int_t &amp;py);                                     //(x,y)-&gt;(pc,px,py) </a>
<a name="60"><span class="lineNum">      60 </span>            : </a>
<a name="61"><span class="lineNum">      61 </span><span class="lineCov">      13494 :   static Int_t   Abs         (Int_t ch,Int_t pc,Int_t x,Int_t y)   {return ch*100000000+pc*1000000+x*1000+y;         }  //(ch,pc,padx,pady)-&gt; abs pad</span></a>
<a name="62"><span class="lineNum">      62 </span><span class="lineCov">        112 :   static Int_t   DDL2C       (Int_t ddl                      )     {return ddl/2;                                    }  //ddl -&gt; chamber</span></a>
<a name="63"><span class="lineNum">      63 </span><span class="lineCov">      10232 :   static Int_t   A2C         (Int_t pad                      )     {return pad/100000000;                            }  //abs pad -&gt; chamber</span></a>
<a name="64"><span class="lineNum">      64 </span><span class="lineCov">    2236570 :   static Int_t   A2P         (Int_t pad                      )     {return pad%100000000/1000000;                    }  //abs pad -&gt; pc </span></a>
<span class="lineNum">      65 </span><span class="lineCov">    1132564 :   static Int_t   A2X         (Int_t pad                      )     {return pad%1000000/1000;                         }  //abs pad -&gt; pad X </span>
<a name="66"><span class="lineNum">      66 </span><span class="lineCov">    1132462 :   static Int_t   A2Y         (Int_t pad                      )     {return pad%1000;                                 }  //abs pad -&gt; pad Y </span></a>
<span class="lineNum">      67 </span>            : 
<a name="68"><span class="lineNum">      68 </span><span class="lineCov">    1293602 :   static Bool_t  IsOverTh    (Float_t q                      )     {return q &gt;= fgThreshold;                         }  //is digit over threshold?</span></a>
<span class="lineNum">      69 </span>            :   
<span class="lineNum">      70 </span><span class="lineCov">       1758 :   Bool_t  GetInstType        (                               )const{return fgInstanceType;                            }  //return if the instance is from geom or ideal                        </span>
<span class="lineNum">      71 </span>            :   
<span class="lineNum">      72 </span>            :   inline static Bool_t IsInDead(Float_t x,Float_t y        );                                                           //is the point in dead area?
<span class="lineNum">      73 </span>            :   inline static Bool_t IsDeadPad(Int_t padx,Int_t pady,Int_t ch);                                                       //is a dead pad?
<span class="lineNum">      74 </span>            :   
<span class="lineNum">      75 </span>            :   inline void SetChStatus(Int_t ch,Bool_t status=kTRUE);
<span class="lineNum">      76 </span>            :   inline void SetSectStatus(Int_t ch,Int_t sect,Bool_t status); 
<span class="lineNum">      77 </span>            :   inline void SetPcStatus(Int_t ch,Int_t pc,Bool_t status); 
<span class="lineNum">      78 </span>            :   inline void PrintChStatus(Int_t ch);
<span class="lineNum">      79 </span>            :   inline void SetGeomAccept();
<a name="80"><span class="lineNum">      80 </span>            :   </a>
<a name="81"><span class="lineNum">      81 </span>            :   inline static Int_t  InHVSector(           Float_t y     );                                                           //find HV sector</a>
<a name="82"><span class="lineNum">      82 </span><span class="lineCov">        128 :   static Int_t     Radiator(          Float_t y               )       {if (InHVSector(y)&lt;0) return -1; return InHVSector(y)/2;}</span></a>
<span class="lineNum">      83 </span><span class="lineCov">         32 :   static Double_t  HinRad(Float_t y)         {if (Radiator(y)&lt;0) return -1;return y-Radiator(y)*fgkMinPcY[Radiator(y)];}                                   // height in the radiator to estimate temperature from gradient</span>
<span class="lineNum">      84 </span><span class="lineCov">      39020 :   static Bool_t    IsInside    (Float_t x,Float_t y,Float_t d=0)     {return  x&gt;-d&amp;&amp;y&gt;-d&amp;&amp;x&lt;fgkMaxPcX[kMaxPc]+d&amp;&amp;y&lt;fgkMaxPcY[kMaxPc]+d; } //is point inside chamber boundaries?</span>
<a name="85"><span class="lineNum">      85 </span>            : </a>
<a name="86"><span class="lineNum">      86 </span>            :   //For optical properties</a>
<a name="87"><span class="lineNum">      87 </span><span class="lineNoCov">          0 :   static Double_t   EPhotMin()                       {return 5.5;}           //</span></a>
<a name="88"><span class="lineNum">      88 </span><span class="lineNoCov">          0 :   static Double_t   EPhotMax()                       {return 8.5;}           //Photon energy range,[eV]</span></a>
<a name="89"><span class="lineNum">      89 </span><span class="lineCov">        182 :   static Double_t NIdxRad(Double_t eV,Double_t temp) {return TMath::Sqrt(1+0.554*(1239.84/eV)*(1239.84/eV)/((1239.84/eV)*(1239.84/eV)-5769))-0.0005*(temp-20);}</span></a>
<a name="90"><span class="lineNum">      90 </span><span class="lineNoCov">          0 :   static Double_t NIdxWin(Double_t eV)               {return TMath::Sqrt(1+46.411/(10.666*10.666-eV*eV)+228.71/(18.125*18.125-eV*eV));}  </span></a>
<a name="91"><span class="lineNum">      91 </span><span class="lineNoCov">          0 :   static Double_t NMgF2Idx(Double_t eV)              {return 1.7744 - 2.866e-3*(1239.842609/eV) + 5.5564e-6*(1239.842609/eV)*(1239.842609/eV);}          // MgF2 idx of trasparency system</span></a>
<a name="92"><span class="lineNum">      92 </span><span class="lineNoCov">          0 :   static Double_t NIdxGap(Double_t eV)               {return 1+0.12489e-6/(2.62e-4 - eV*eV/1239.84/1239.84);}</span></a>
<a name="93"><span class="lineNum">      93 </span><span class="lineNoCov">          0 :   static Double_t LAbsRad(Double_t eV)               {return (eV&lt;7.8)*(GausPar(eV,3.20491e16,-0.00917890,0.742402)+GausPar(eV,3035.37,4.81171,0.626309))+(eV&gt;=7.8)*0.0001;}</span></a>
<a name="94"><span class="lineNum">      94 </span><span class="lineNoCov">          0 :   static Double_t LAbsWin(Double_t eV)               {return (eV&lt;8.2)*(818.8638-301.0436*eV+36.89642*eV*eV-1.507555*eV*eV*eV)+(eV&gt;=8.2)*0.0001;}//fit from DiMauro data 28.10.03</span></a>
<a name="95"><span class="lineNum">      95 </span><span class="lineNoCov">          0 :   static Double_t LAbsGap(Double_t eV)               {return (eV&lt;7.75)*6512.399+(eV&gt;=7.75)*3.90743e-2/(-1.655279e-1+6.307392e-2*eV-8.011441e-3*eV*eV+3.392126e-4*eV*eV*eV);}</span></a>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :   static Double_t QEffCSI(Double_t eV)               {return (eV&gt;6.07267)*0.344811*(1-exp(-1.29730*(eV-6.07267)));}//fit from DiMauro data 28.10.03</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :   static Double_t GausPar(Double_t x,Double_t a1,Double_t a2,Double_t a3) {return a1*TMath::Exp(-0.5*((x-a2)/a3)*((x-a2)/a3));}</span>
<span class="lineNum">      98 </span>            :   inline static Double_t FindTemp(Double_t tLow,Double_t tUp,Double_t y);    //find the temperature of the C6F14 in a given point with coord. y (in x is uniform)
<a name="99"><span class="lineNum">      99 </span>            :   </a>
<a name="100"><span class="lineNum">     100 </span>            :   </a>
<span class="lineNum">     101 </span><span class="lineCov">         16 :   Double_t   GetEPhotMean            ()const {return fPhotEMean;} </span>
<a name="102"><span class="lineNum">     102 </span><span class="lineCov">      97608 :   Double_t   GetRefIdx               ()const {return fRefIdx;}                       //running refractive index</span></a>
<a name="103"><span class="lineNum">     103 </span>            :   </a>
<span class="lineNum">     104 </span><span class="lineCov">        166 :   Double_t   MeanIdxRad              ()const {return NIdxRad(fPhotEMean,fTemp);}</span>
<a name="105"><span class="lineNum">     105 </span><span class="lineNoCov">          0 :   Double_t   MeanIdxWin              ()const {return NIdxWin(fPhotEMean);}</span></a>
<a name="106"><span class="lineNum">     106 </span>            :   //</a>
<a name="107"><span class="lineNum">     107 </span><span class="lineCov">       1024 :   Float_t    DistCut                 ()const {return 1.0;}       //&lt;--TEMPORAR--&gt; to be removed in future. Cut for MIP-TRACK residual </span></a>
<span class="lineNum">     108 </span><span class="lineCov">        304 :   Float_t    QCut                    ()const {return 100;}       //&lt;--TEMPORAR--&gt; to be removed in future. Separation PHOTON-MIP charge </span>
<a name="109"><span class="lineNum">     109 </span><span class="lineCov">         16 :   Float_t    MultCut                 ()const {return 30;}       //&lt;--TEMPORAR--&gt; to be removed in future. Multiplicity cut to activate WEIGHT procedure </span></a>
<a name="110"><span class="lineNum">     110 </span>            : </a>
<a name="111"><span class="lineNum">     111 </span><span class="lineCov">      34342 :   Double_t   RadThick                ()const {return 1.5;}       //&lt;--TEMPORAR--&gt; to be removed in future. Radiator thickness</span></a>
<a name="112"><span class="lineNum">     112 </span><span class="lineCov">      59388 :   Double_t   WinThick                ()const {return 0.5;}       //&lt;--TEMPORAR--&gt; to be removed in future. Window thickness</span></a>
<a name="113"><span class="lineNum">     113 </span><span class="lineCov">      53300 :   Double_t   GapThick                ()const {return 8.0;}       //&lt;--TEMPORAR--&gt; to be removed in future. Proximity gap thickness</span></a>
<span class="lineNum">     114 </span><span class="lineCov">      29336 :   Double_t   WinIdx                  ()const {return 1.5787;}    //&lt;--TEMPORAR--&gt; to be removed in future. Mean refractive index of WIN material (SiO2) </span>
<span class="lineNum">     115 </span><span class="lineCov">      14954 :   Double_t   GapIdx                  ()const {return 1.0005;}    //&lt;--TEMPORAR--&gt; to be removed in future. Mean refractive index of GAP material (CH4)</span>
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            :   static        Int_t      Stack(Int_t evt=-1,Int_t tid=-1);              //Print stack info for event and tid
<span class="lineNum">     118 </span>            :   static        Int_t      StackCount(Int_t pid,Int_t evt);               //Counts stack particles of given sort in given event  
<a name="119"><span class="lineNum">     119 </span>            :   static        void       IdealPosition(Int_t iCh,TGeoHMatrix *m);       //ideal position of given chamber </a>
<a name="120"><span class="lineNum">     120 </span>            :   //trasformation methodes</a>
<a name="121"><span class="lineNum">     121 </span><span class="lineCov">       9035 :   void     Lors2Mars   (Int_t c,Float_t x,Float_t y,Double_t *m,Int_t pl=kPc)const{Double_t z=0; switch(pl){case kPc:z=8.0;break; case kAnod:z=7.806;break; case kRad:z=-1.25; break;}   Double_t l[3]={x-fX,y-fY,z};  fM[c]-&gt;LocalToMaster(l,m); }    </span></a>
<a name="122"><span class="lineNum">     122 </span><span class="lineCov">         30 :   TVector3 Lors2Mars   (Int_t c,Float_t x,Float_t y,            Int_t pl=kPc)const{Double_t m[3];Lors2Mars(c,x,y,m,pl); return TVector3(m);    }//MRS-&gt;LRS  </span></a>
<span class="lineNum">     123 </span><span class="lineCov">       2644 :   void     Mars2Lors   (Int_t c,Double_t *m,Float_t &amp;x ,Float_t &amp;y          )const{Double_t l[3];fM[c]-&gt;MasterToLocal(m,l);x=l[0]+fX;y=l[1]+fY;}//MRS-&gt;LRS</span>
<span class="lineNum">     124 </span><span class="lineCov">       1024 :   void     Mars2LorsVec(Int_t c,Double_t *m,Float_t &amp;th,Float_t &amp;ph         )const{Double_t l[3]; fM[c]-&gt;MasterToLocalVect(m,l); </span>
<span class="lineNum">     125 </span><span class="lineCov">        512 :                                                                                    Float_t pt=TMath::Sqrt(l[0]*l[0]+l[1]*l[1]); </span>
<a name="126"><span class="lineNum">     126 </span><span class="lineCov">        512 :                                                                                            th=TMath::ATan(pt/l[2]); </span></a>
<a name="127"><span class="lineNum">     127 </span><span class="lineCov">        512 :                                                                                            ph=TMath::ATan2(l[1],l[0]);}    </span></a>
<a name="128"><span class="lineNum">     128 </span><span class="lineNoCov">          0 :   void     Lors2MarsVec(Int_t c,Double_t *m,Double_t *l                     )const{fM[c]-&gt;LocalToMasterVect(m,l);                              }//LRS-&gt;MRS </span></a>
<a name="129"><span class="lineNum">     129 </span><span class="lineNoCov">          0 :   TVector3 Norm        (Int_t c                                             )const{Double_t n[3]; Norm(c,n); return TVector3(n);               }//norm </span></a>
<span class="lineNum">     130 </span><span class="lineCov">       3584 :   void     Norm        (Int_t c,Double_t *n                                 )const{Double_t l[3]={0,0,1};fM[c]-&gt;LocalToMasterVect(l,n);        }//norm</span>
<a name="131"><span class="lineNum">     131 </span><span class="lineCov">       3584 :   void     Point       (Int_t c,Double_t *p,Int_t plane                     )const{Lors2Mars(c,0,0,p,plane);}         //point of given chamber plane</span></a>
<a name="132"><span class="lineNum">     132 </span>            : </a>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :   void     SetTemp        (Double_t temp                                       ) {fTemp = temp;}                      //set actual temperature of the C6F14</span>
<a name="134"><span class="lineNum">     134 </span><span class="lineNoCov">          0 :   void     SetEPhotMean   (Double_t ePhotMean                                  ) {fPhotEMean = ePhotMean;}            //set mean photon energy</span></a>
<span class="lineNum">     135 </span>            :   
<a name="136"><span class="lineNum">     136 </span><span class="lineCov">        104 :   void     SetRefIdx      (Double_t refRadIdx                                  ) {fRefIdx = refRadIdx;}               //set running refractive index</span></a>
<a name="137"><span class="lineNum">     137 </span>            :   </a>
<a name="138"><span class="lineNum">     138 </span><span class="lineNoCov">          0 :   void     SetNSigmas     (Int_t sigmas                                        ) {fgNSigmas   = sigmas;}                 //set sigma cut  </span></a>
<span class="lineNum">     139 </span><span class="lineCov">    1293602 :   void     SetThreshold   (Int_t thres                                         ) {fgThreshold = thres;}                 //set sigma cut        </span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :   void     SetInstanceType(Bool_t inst                                         ) {fgInstanceType = inst;}             //kTRUE if from geomatry kFALSE if from ideal geometry</span>
<span class="lineNum">     141 </span>            :   //For PID
<span class="lineNum">     142 </span>            :   Double_t SigLoc         (Double_t trkTheta,Double_t trkPhi,Double_t ckovTh,Double_t ckovPh,Double_t beta);//error due to cathode segmetation
<span class="lineNum">     143 </span>            :   Double_t SigGeom        (Double_t trkTheta,Double_t trkPhi,Double_t ckovTh,Double_t ckovPh,Double_t beta);//error due to unknown photon origin
<span class="lineNum">     144 </span>            :   Double_t SigCrom        (Double_t trkTheta,Double_t trkPhi,Double_t ckovTh,Double_t ckovPh,Double_t beta);//error due to unknonw photon energy
<span class="lineNum">     145 </span>            :   Double_t Sigma2         (Double_t trkTheta,Double_t trkPhi,Double_t ckovTh,Double_t ckovPh              );//photon candidate sigma^2
<span class="lineNum">     146 </span>            :   
<span class="lineNum">     147 </span>            :   static Double_t SigmaCorrFact(Int_t iPart, Double_t occupancy                                         );//correction factor for theoretical resolution
<span class="lineNum">     148 </span>            : 
<a name="149"><span class="lineNum">     149 </span>            :   //Mathieson Getters</a>
<a name="150"><span class="lineNum">     150 </span>            :   </a>
<a name="151"><span class="lineNum">     151 </span><span class="lineCov">    2167352 :   static Double_t PitchAnodeCathode()  {return fgkD;}</span></a>
<a name="152"><span class="lineNum">     152 </span><span class="lineCov">    1105400 :   static Double_t SqrtK3x() {return fgkSqrtK3x;}</span></a>
<a name="153"><span class="lineNum">     153 </span><span class="lineCov">    1083676 :   static Double_t K2x    () {return fgkK2x;}</span></a>
<a name="154"><span class="lineNum">     154 </span><span class="lineCov">      21724 :   static Double_t K1x    () {return fgkK1x;}</span></a>
<a name="155"><span class="lineNum">     155 </span><span class="lineCov">     530976 :   static Double_t K4x    () {return fgkK4x;}</span></a>
<a name="156"><span class="lineNum">     156 </span><span class="lineCov">    1105400 :   static Double_t SqrtK3y() {return fgkSqrtK3y;}</span></a>
<a name="157"><span class="lineNum">     157 </span><span class="lineCov">    1083676 :   static Double_t K2y    () {return fgkK2y;}</span></a>
<span class="lineNum">     158 </span><span class="lineCov">      21724 :   static Double_t K1y    () {return fgkK1y;}</span>
<span class="lineNum">     159 </span><span class="lineCov">     530976 :   static Double_t K4y    () {return fgkK4y;}</span>
<span class="lineNum">     160 </span>            :   //
<span class="lineNum">     161 </span>            :   enum EPlaneId {kPc,kRad,kAnod};            //3 planes in chamber 
<span class="lineNum">     162 </span>            :   enum ETrackingFlags {kMipDistCut=-9,kMipQdcCut=-5,kNoPhotAccept=-11};     //flags for Reconstruction
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            : protected:
<span class="lineNum">     165 </span>            :   static /*const*/ Float_t fgkMinPcX[6];                                                           //limits PC
<span class="lineNum">     166 </span>            :   static /*const*/ Float_t fgkMinPcY[6];                                                           //limits PC
<span class="lineNum">     167 </span>            :   static /*const*/ Float_t fgkMaxPcX[6];                                                           //limits PC
<span class="lineNum">     168 </span>            :   static /*const*/ Float_t fgkMaxPcY[6]; 
<span class="lineNum">     169 </span>            :   
<span class="lineNum">     170 </span>            :   static Bool_t fgMapPad[160][144][7];                                                                   //map of pads to evaluate if they are active or dead (160,144) pads for 7 chambers
<span class="lineNum">     171 </span>            :   
<span class="lineNum">     172 </span>            : // Mathieson constants
<span class="lineNum">     173 </span>            : // For HMPID --&gt; x direction means parallel      to the wires: K3 = 0.66  (NIM A270 (1988) 602-603) fig.1  
<span class="lineNum">     174 </span>            : // For HMPID --&gt; y direction means perpendicular to the wires: K3 = 0.90  (NIM A270 (1988) 602-603) fig.2  
<span class="lineNum">     175 </span>            : //
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span>            :   static const Double_t fgkD;  // ANODE-CATHODE distance 0.445/2
<span class="lineNum">     178 </span>            :   
<span class="lineNum">     179 </span>            :   static const Double_t fgkSqrtK3x,fgkK2x,fgkK1x,fgkK4x;
<span class="lineNum">     180 </span>            :   static const Double_t fgkSqrtK3y,fgkK2y,fgkK1y,fgkK4y;
<span class="lineNum">     181 </span>            : //
<span class="lineNum">     182 </span>            :     
<span class="lineNum">     183 </span>            :   static Int_t    fgNSigmas;                                                                        //sigma Cut
<span class="lineNum">     184 </span>            :   static Int_t    fgThreshold;                                                                        //sigma Cut
<span class="lineNum">     185 </span>            :   static Bool_t   fgInstanceType;                                                                  //kTRUE if from geomatry kFALSE if from ideal geometry
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span>            :   static Float_t fgCellX, fgCellY, fgPcX, fgPcY, fgAllX, fgAllY;                                   //definition of HMPID geometric parameters 
<span class="lineNum">     188 </span>            :          AliHMPIDParam(Bool_t noGeo);             //default ctor is protected to enforce it to be singleton
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            :   static AliHMPIDParam *fgInstance;   //static pointer  to instance of AliHMPIDParam singleton
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            :   TGeoHMatrix *fM[7];                 //pointers to matrices defining HMPID chambers rotations-translations
<span class="lineNum">     193 </span>            :   Float_t fX;                         //x shift of LORS with respect to rotated MARS 
<span class="lineNum">     194 </span>            :   Float_t fY;                         //y shift of LORS with respect to rotated MARS
<span class="lineNum">     195 </span>            :   Double_t fRefIdx;                   //running refractive index of C6F14
<span class="lineNum">     196 </span>            :   Double_t fPhotEMean;                //mean energy of photon
<span class="lineNum">     197 </span>            :   Double_t fTemp;                     //actual temparature of C6F14  
<span class="lineNum">     198 </span>            : private:
<span class="lineNum">     199 </span>            :   AliHMPIDParam(const AliHMPIDParam&amp; r);              //dummy copy constructor
<a name="200"><span class="lineNum">     200 </span>            :   AliHMPIDParam &amp;operator=(const AliHMPIDParam&amp; r);   //dummy assignment operator</a>
<span class="lineNum">     201 </span>            :       
<span class="lineNum">     202 </span><span class="lineCov">         22 :   ClassDef(AliHMPIDParam,1)           //HMPID main parameters class</span>
<span class="lineNum">     203 </span>            : };
<a name="204"><span class="lineNum">     204 </span>            : </a>
<span class="lineNum">     205 </span>            : //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<span class="lineNum">     206 </span>            : AliHMPIDParam* AliHMPIDParam::Instance()
<span class="lineNum">     207 </span>            : {
<span class="lineNum">     208 </span>            : // Return pointer to the AliHMPIDParam singleton. 
<span class="lineNum">     209 </span>            : // Arguments: none
<span class="lineNum">     210 </span>            : //   Returns: pointer to the instance of AliHMPIDParam or 0 if no geometry       
<span class="lineNum">     211 </span><span class="lineCov">    1300002 :   if(!fgInstance) new AliHMPIDParam(kFALSE);                                //default setting for reconstruction, if no geometry.root -&gt; AliFatal</span>
<span class="lineNum">     212 </span><span class="lineCov">     649851 :   return fgInstance;  </span>
<a name="213"><span class="lineNum">     213 </span><span class="lineNoCov">          0 : }//Instance()    </span></a>
<span class="lineNum">     214 </span>            : //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<span class="lineNum">     215 </span>            : AliHMPIDParam* AliHMPIDParam::InstanceNoGeo()
<span class="lineNum">     216 </span>            : {
<span class="lineNum">     217 </span>            : // Return pointer to the AliHMPIDParam singleton without the geometry.root. 
<span class="lineNum">     218 </span>            : // Arguments: none
<span class="lineNum">     219 </span>            : //   Returns: pointer to the instance of AliHMPIDParam or 0 if no geometry       
<span class="lineNum">     220 </span><span class="lineCov">        528 :   if(!fgInstance) new AliHMPIDParam(kTRUE);                               //to avoid AliFatal, for MOOD and displays, use ideal geometry parameters</span>
<span class="lineNum">     221 </span><span class="lineCov">        264 :   return fgInstance;  </span>
<a name="222"><span class="lineNum">     222 </span><span class="lineNoCov">          0 : }//Instance()    </span></a>
<span class="lineNum">     223 </span>            : //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<span class="lineNum">     224 </span>            : Bool_t AliHMPIDParam::IsInDead(Float_t x,Float_t y)
<span class="lineNum">     225 </span>            : {
<span class="lineNum">     226 </span>            : // Check is the current point is outside of sensitive area or in dead zones
<span class="lineNum">     227 </span>            : // Arguments: x,y -position
<span class="lineNum">     228 </span>            : //   Returns: 1 if not in sensitive zone           
<span class="lineNum">     229 </span><span class="lineCov">      55888 :   for(Int_t iPc=0;iPc&lt;6;iPc++)</span>
<span class="lineNum">     230 </span><span class="lineCov">      75788 :     if(x&gt;=fgkMinPcX[iPc] &amp;&amp; x&lt;=fgkMaxPcX[iPc] &amp;&amp; y&gt;=fgkMinPcY[iPc] &amp;&amp; y&lt;=fgkMaxPcY [iPc]) return kFALSE; //in current pc</span>
<span class="lineNum">     231 </span>            :   
<span class="lineNum">     232 </span><span class="lineCov">        145 :   return kTRUE;</span>
<a name="233"><span class="lineNum">     233 </span><span class="lineCov">       5585 : }</span></a>
<span class="lineNum">     234 </span>            : //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<span class="lineNum">     235 </span>            : Bool_t AliHMPIDParam::IsDeadPad(Int_t padx,Int_t pady,Int_t ch)
<span class="lineNum">     236 </span>            : {
<span class="lineNum">     237 </span>            : // Check is the current pad is active or not
<span class="lineNum">     238 </span>            : // Arguments: padx,pady pad integer coord
<span class="lineNum">     239 </span>            : //   Returns: kTRUE if dead, kFALSE if active
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :     if(fgMapPad[padx-1][pady-1][ch]) return kFALSE; //current pad active</span>
<span class="lineNum">     242 </span>            :   
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :   return kTRUE;</span>
<a name="244"><span class="lineNum">     244 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     245 </span>            : //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<span class="lineNum">     246 </span>            : void AliHMPIDParam::Lors2Pad(Float_t x,Float_t y,Int_t &amp;pc,Int_t &amp;px,Int_t &amp;py)
<span class="lineNum">     247 </span>            : {
<span class="lineNum">     248 </span>            : // Check the pad of given position
<span class="lineNum">     249 </span>            : // Arguments: x,y- position [cm] in LORS; pc,px,py- pad where to store the result
<span class="lineNum">     250 </span>            : //   Returns: none
<span class="lineNum">     251 </span><span class="lineCov">       2232 :   pc=px=py=-1;</span>
<span class="lineNum">     252 </span><span class="lineCov">       3204 :   if     (x&gt;fgkMinPcX[0] &amp;&amp; x&lt;fgkMaxPcX[0]) {pc=0; px=Int_t( x               / SizePadX());}//PC 0 or 2 or 4</span>
<span class="lineNum">     253 </span><span class="lineCov">        432 :   else if(x&gt;fgkMinPcX[1] &amp;&amp; x&lt;fgkMaxPcX[1]) {pc=1; px=Int_t((x-fgkMinPcX[1]) / SizePadX());}//PC 1 or 3 or 5</span>
<span class="lineNum">     254 </span>            :   else return;
<span class="lineNum">     255 </span><span class="lineCov">       2335 :   if     (y&gt;fgkMinPcY[0] &amp;&amp; y&lt;fgkMaxPcY[0]) {      py=Int_t( y               / SizePadY());}//PC 0 or 1</span>
<span class="lineNum">     256 </span><span class="lineCov">       2525 :   else if(y&gt;fgkMinPcY[2] &amp;&amp; y&lt;fgkMaxPcY[2]) {pc+=2;py=Int_t((y-fgkMinPcY[2]) / SizePadY());}//PC 2 or 3</span>
<span class="lineNum">     257 </span><span class="lineCov">       1472 :   else if(y&gt;fgkMinPcY[4] &amp;&amp; y&lt;fgkMaxPcY[4]) {pc+=4;py=Int_t((y-fgkMinPcY[4]) / SizePadY());}//PC 4 or 5</span>
<span class="lineNum">     258 </span>            :   else return;
<a name="259"><span class="lineNum">     259 </span><span class="lineCov">       1116 : }</span></a>
<span class="lineNum">     260 </span>            : //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<span class="lineNum">     261 </span>            : Int_t AliHMPIDParam::InHVSector(Float_t y)
<span class="lineNum">     262 </span>            : {
<span class="lineNum">     263 </span>            : //Calculate the HV sector corresponding to the cluster position
<span class="lineNum">     264 </span>            : //Arguments: y
<span class="lineNum">     265 </span>            : //Returns the HV sector in the single module
<span class="lineNum">     266 </span>            :  
<span class="lineNum">     267 </span>            :    Int_t hvsec = -1;
<span class="lineNum">     268 </span><span class="lineCov">        670 :    Int_t pc,px,py;</span>
<span class="lineNum">     269 </span><span class="lineCov">        335 :    Lors2Pad(1.,y,pc,px,py);</span>
<span class="lineNum">     270 </span><span class="lineCov">        340 :    if(py==-1) return hvsec;</span>
<span class="lineNum">     271 </span>            :    
<span class="lineNum">     272 </span><span class="lineCov">        330 :    hvsec = (py+(pc/2)*(kMaxPy+1))/((kMaxPy+1)/2);</span>
<span class="lineNum">     273 </span>            :    
<span class="lineNum">     274 </span><span class="lineCov">        330 :    return hvsec;</span>
<a name="275"><span class="lineNum">     275 </span><span class="lineCov">        335 : }</span></a>
<span class="lineNum">     276 </span>            : //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<span class="lineNum">     277 </span>            : Double_t AliHMPIDParam::FindTemp(Double_t tLow,Double_t tHigh,Double_t y)
<span class="lineNum">     278 </span>            : {
<span class="lineNum">     279 </span>            : //  Model for gradient in temperature
<span class="lineNum">     280 </span><span class="lineCov">         16 :   Double_t yRad = HinRad(y);     //height in a given radiator</span>
<span class="lineNum">     281 </span><span class="lineCov">          8 :   if(tHigh&lt;tLow) tHigh = tLow;   //if Tout &lt; Tin consider just Tin as reference...</span>
<span class="lineNum">     282 </span><span class="lineCov">          8 :   if(yRad&lt;0        ) yRad = 0;         //protection against fake y values</span>
<span class="lineNum">     283 </span><span class="lineCov">         12 :   if(yRad&gt;SizePcY()) yRad = SizePcY(); //protection against fake y values</span>
<span class="lineNum">     284 </span>            :   
<span class="lineNum">     285 </span><span class="lineCov">          8 :   Double_t gradT = (tHigh-tLow)/SizePcY();  // linear gradient</span>
<span class="lineNum">     286 </span><span class="lineCov">          8 :   return gradT*yRad+tLow;</span>
<a name="287"><span class="lineNum">     287 </span>            : }</a>
<span class="lineNum">     288 </span>            : //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<span class="lineNum">     289 </span>            : void AliHMPIDParam::SetChStatus(Int_t ch,Bool_t status)
<span class="lineNum">     290 </span>            : {
<span class="lineNum">     291 </span>            : //Set a chamber on or off depending on the status
<span class="lineNum">     292 </span>            : //Arguments: ch=chamber,status=kTRUE = active, kFALSE=off
<span class="lineNum">     293 </span>            : //Returns: none
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :   for(Int_t padx=0;padx&lt;kMaxPcx+1;padx++) {</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :      for(Int_t pady=0;pady&lt;kMaxPcy+1;pady++) {</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :        fgMapPad[padx][pady][ch] = status;</span>
<span class="lineNum">     297 </span>            :      }
<span class="lineNum">     298 </span>            :    }
<a name="299"><span class="lineNum">     299 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     300 </span>            : //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<span class="lineNum">     301 </span>            : void AliHMPIDParam::SetSectStatus(Int_t ch,Int_t sect,Bool_t status)
<span class="lineNum">     302 </span>            : {
<span class="lineNum">     303 </span>            : //Set a given sector sect for a chamber ch on or off depending on the status
<span class="lineNum">     304 </span>            : //Sector=0,5 (6 sectors)
<span class="lineNum">     305 </span>            : //Arguments: ch=chamber,sect=sector,status: kTRUE = active, kFALSE=off
<span class="lineNum">     306 </span>            : //Returns: none
<span class="lineNum">     307 </span>            :   
<span class="lineNum">     308 </span>            :   Int_t npadsect = (kMaxPcy+1)/6;
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :   Int_t padSectMin = npadsect*sect;</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :   Int_t padSectMax = padSectMin+npadsect;</span>
<span class="lineNum">     311 </span>            :   
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :   for(Int_t padx=0;padx&lt;kMaxPcx+1;padx++) {</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :      for(Int_t pady=padSectMin;pady&lt;padSectMax;pady++) {</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :        fgMapPad[padx][pady][ch] = status;</span>
<span class="lineNum">     315 </span>            :      }
<span class="lineNum">     316 </span>            :    }
<a name="317"><span class="lineNum">     317 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     318 </span>            : //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<span class="lineNum">     319 </span>            : void AliHMPIDParam::SetPcStatus(Int_t ch,Int_t pc,Bool_t status)
<span class="lineNum">     320 </span>            : {
<span class="lineNum">     321 </span>            : //Set a given PC pc for a chamber ch on or off depending on the status
<span class="lineNum">     322 </span>            : //Arguments: ch=chamber,pc=PC,status: kTRUE = active, kFALSE=off
<span class="lineNum">     323 </span>            : //Returns: none
<span class="lineNum">     324 </span>            :   
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :   Int_t deltaX = pc%2;</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :   Int_t deltaY = pc/2;</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :   Int_t padPcXMin = deltaX*kPadPcX;</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :   Int_t padPcXMax = padPcXMin+kPadPcX;</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :   Int_t padPcYMin = deltaY*kPadPcY;</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :   Int_t padPcYMax = padPcYMin+kPadPcY;</span>
<span class="lineNum">     331 </span>            :   
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :   for(Int_t padx=padPcXMin;padx&lt;padPcXMax;padx++) {</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :      for(Int_t pady=padPcYMin;pady&lt;padPcYMax;pady++) {</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :        fgMapPad[padx][pady][ch] = status;</span>
<span class="lineNum">     335 </span>            :      }
<span class="lineNum">     336 </span>            :    }
<a name="337"><span class="lineNum">     337 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     338 </span>            : //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<span class="lineNum">     339 </span>            : void AliHMPIDParam::PrintChStatus(Int_t ch)
<span class="lineNum">     340 </span>            : {
<span class="lineNum">     341 </span>            : //Print the map status of a chamber on or off depending on the status
<span class="lineNum">     342 </span>            : //Arguments: ch=chamber
<span class="lineNum">     343 </span>            : //Returns: none
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :   Printf(&quot; &quot;);</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :   Printf(&quot; --------- C H A M B E R  %d   ---------------&quot;,ch);</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :   for(Int_t pady=kMaxPcy;pady&gt;=0;pady--) {</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :      for(Int_t padx=0;padx&lt;kMaxPcx+1;padx++) {</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :        if(padx==80) printf(&quot; &quot;);</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :        printf(&quot;%d&quot;,fgMapPad[padx][pady][ch]);</span>
<span class="lineNum">     350 </span>            :      }
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :      printf(&quot; %d \n&quot;,pady+1);</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :      if(pady%48==0) printf(&quot;\n&quot;);</span>
<span class="lineNum">     353 </span>            :    }
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :    printf(&quot;\n&quot;);</span>
<a name="355"><span class="lineNum">     355 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     356 </span>            : //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<span class="lineNum">     357 </span>            : void AliHMPIDParam::SetGeomAccept()
<span class="lineNum">     358 </span>            : {
<span class="lineNum">     359 </span>            : //Set the real acceptance of the modules, due to ineficciency or hardware problems (up tp 1/6/2010)
<span class="lineNum">     360 </span>            : //Arguments: none
<span class="lineNum">     361 </span>            : //Returns: none
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :   SetSectStatus(0,3,kFALSE);</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :   SetSectStatus(4,0,kFALSE);</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :   SetSectStatus(5,1,kFALSE);</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :   SetSectStatus(6,2,kFALSE);</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :   SetSectStatus(6,3,kFALSE);</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     368 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
