<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - ANALYSIS/ANALYSISalice/AliESDtrackCuts.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">ANALYSIS/ANALYSISalice</a> - AliESDtrackCuts.h<span style="font-size: 80%;"> (source / <a href="AliESDtrackCuts.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">38</td>
            <td class="headerCovTableEntry">90</td>
            <td class="headerCovTableEntryLo">42.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">39</td>
            <td class="headerCovTableEntry">94</td>
            <td class="headerCovTableEntryLo">41.5 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : //</a>
<span class="lineNum">       2 </span>            : //  Class for handling of ESD track cuts.
<span class="lineNum">       3 </span>            : //
<span class="lineNum">       4 </span>            : //  The class manages a number of track quality cuts, a
<span class="lineNum">       5 </span>            : //  track-to-vertex cut and a number of kinematic cuts. Two methods
<span class="lineNum">       6 </span>            : //  can be used to figure out if an ESD track survives the cuts:
<span class="lineNum">       7 </span>            : //  AcceptTrack which takes a single AliESDtrack as argument and
<span class="lineNum">       8 </span>            : //  returns kTRUE/kFALSE or GetAcceptedTracks which takes an AliESDEvent
<span class="lineNum">       9 </span>            : //  object and returns an TObjArray (of AliESDtracks) with the tracks
<span class="lineNum">      10 </span>            : //  in the ESD that survived the cuts.
<span class="lineNum">      11 </span>            : //
<span class="lineNum">      12 </span>            : //
<span class="lineNum">      13 </span>            : //  TODO:
<span class="lineNum">      14 </span>            : //  - add functionality to save and load cuts
<span class="lineNum">      15 </span>            : //  - add histograms for kinematic cut variables?
<span class="lineNum">      16 </span>            : //  - upper and lower cuts for all (non-boolean) cuts
<span class="lineNum">      17 </span>            : //  - update print method
<span class="lineNum">      18 </span>            : //  - put comments to each variable
<span class="lineNum">      19 </span>            : //
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : #ifndef ALIESDTRACKCUTS_H
<span class="lineNum">      22 </span>            : #define ALIESDTRACKCUTS_H
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : #include &lt;TString.h&gt;
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : #include &quot;AliAnalysisCuts.h&quot;
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : class AliESDEvent;
<span class="lineNum">      29 </span>            : class AliESDtrack;
<span class="lineNum">      30 </span>            : class AliVTrack;
<span class="lineNum">      31 </span>            : class AliVEvent;
<span class="lineNum">      32 </span>            : class AliLog;
<span class="lineNum">      33 </span>            : class TTree;
<span class="lineNum">      34 </span>            : class TH1;
<span class="lineNum">      35 </span>            : class TH1F;
<span class="lineNum">      36 </span>            : class TH2F;
<span class="lineNum">      37 </span>            : class TF1;
<span class="lineNum">      38 </span>            : class TCollection;
<span class="lineNum">      39 </span>            : class TFormula;
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            : class AliESDtrackCuts : public AliAnalysisCuts
<span class="lineNum">      42 </span>            : {
<span class="lineNum">      43 </span>            : public:
<span class="lineNum">      44 </span>            :   enum ITSClusterRequirement { kOff = 0, kNone, kAny, kFirst, kOnlyFirst, kSecond, kOnlySecond, kBoth };
<span class="lineNum">      45 </span>            :   enum Detector { kSPD = 0, kSDD, kSSD };
<span class="lineNum">      46 </span>            :   enum ITSULayers { kITSU012 = 0, kITSU34, kITSU56 };
<span class="lineNum">      47 </span>            :   enum MultEstTrackCuts { kMultEstTrackCutGlobal = 0, kMultEstTrackCutITSSA, kMultEstTrackCutDCAwSPD, kMultEstTrackCutDCAwoSPD, kNMultEstTrackCuts /* this must always be the last */};
<span class="lineNum">      48 </span>            :   enum MultEstTrackType { kTrackletsITSTPC = 0, kTrackletsITSSA, kTracklets };
<span class="lineNum">      49 </span>            :   enum VertexType { kVertexTracks = 0x1, kVertexSPD = 0x2, kVertexTPC = 0x4 };
<span class="lineNum">      50 </span>            :   
<span class="lineNum">      51 </span>            :   AliESDtrackCuts(const Char_t* name = &quot;AliESDtrackCuts&quot;, const Char_t* title = &quot;&quot;);
<a name="52"><span class="lineNum">      52 </span>            :   virtual ~AliESDtrackCuts();</a>
<span class="lineNum">      53 </span>            : 
<a name="54"><span class="lineNum">      54 </span>            :   virtual Bool_t IsSelected(TObject* obj)</a>
<span class="lineNum">      55 </span><span class="lineCov">        628 :        {return AcceptTrack((AliESDtrack*)obj);}</span>
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :   virtual Bool_t IsSelected(TList* /*list*/) {return kTRUE;}</span>
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            :   Bool_t AcceptTrack(const AliESDtrack* esdTrack);
<span class="lineNum">      59 </span>            :   Bool_t AcceptVTrack(const AliVTrack* vTrack);
<span class="lineNum">      60 </span>            :   TObjArray* GetAcceptedTracks(const AliESDEvent* esd, Bool_t bTPC = kFALSE);
<span class="lineNum">      61 </span>            :   Int_t CountAcceptedTracks(const AliESDEvent* const esd);
<span class="lineNum">      62 </span>            :   
<span class="lineNum">      63 </span>            :   static Int_t GetReferenceMultiplicity(const AliESDEvent* esd, Bool_t tpcOnly);
<span class="lineNum">      64 </span>            :   static Int_t GetReferenceMultiplicity(const AliESDEvent* esd, MultEstTrackType trackType = kTrackletsITSTPC, Float_t etaRange = 0.5, Float_t etaCent=0.);
<span class="lineNum">      65 </span>            :   static AliESDtrackCuts* GetMultEstTrackCuts(MultEstTrackCuts cut);
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            :   static AliESDtrack* GetTPCOnlyTrack(const AliESDEvent* esd, Int_t iTrack);
<span class="lineNum">      68 </span>            :   static AliESDtrack* GetTPCOnlyTrackFromVEvent(const AliVEvent* vEvent, Int_t iTrack);
<span class="lineNum">      69 </span>            :   
<span class="lineNum">      70 </span>            :   // Standard cut definitions
<span class="lineNum">      71 </span>            :   static AliESDtrackCuts* GetStandardTPCOnlyTrackCuts();
<span class="lineNum">      72 </span>            :   static AliESDtrackCuts* GetStandardITSTPCTrackCuts2009(Bool_t selPrimaries=kTRUE);
<span class="lineNum">      73 </span>            :   static AliESDtrackCuts* GetStandardITSTPCTrackCuts2010(Bool_t selPrimaries=kTRUE, Int_t clusterCut=0);
<span class="lineNum">      74 </span>            :   static AliESDtrackCuts* GetStandardITSTPCTrackCuts2011(Bool_t selPrimaries=kTRUE, Int_t clusterCut=1);
<span class="lineNum">      75 </span>            :   static AliESDtrackCuts* GetStandardITSTPCTrackCuts2015PbPb(Bool_t selPrimaries=kTRUE, Int_t clusterCut=1, Bool_t cutAcceptanceEdges = kTRUE, Bool_t removeDistortedRegions = kFALSE);
<span class="lineNum">      76 </span>            :   static AliESDtrackCuts* GetStandardITSSATrackCuts2009(Bool_t selPrimaries=kTRUE, Bool_t useForPid=kTRUE);
<span class="lineNum">      77 </span>            :   static AliESDtrackCuts* GetStandardITSSATrackCuts2010(Bool_t selPrimaries=kTRUE, Bool_t useForPid=kTRUE);
<span class="lineNum">      78 </span>            :   static AliESDtrackCuts* GetStandardITSSATrackCutsPbPb2010(Bool_t selPrimaries=kTRUE, Bool_t useForPid=kTRUE);
<span class="lineNum">      79 </span>            :   static AliESDtrackCuts* GetStandardITSPureSATrackCuts2009(Bool_t selPrimaries=kTRUE, Bool_t useForPid=kTRUE);
<span class="lineNum">      80 </span>            :   static AliESDtrackCuts* GetStandardITSPureSATrackCuts2010(Bool_t selPrimaries=kTRUE, Bool_t useForPid=kTRUE);
<span class="lineNum">      81 </span>            :   // Standard cuts for daughter tracks
<span class="lineNum">      82 </span>            :   static AliESDtrackCuts* GetStandardV0DaughterCuts();
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span>            :   // static function to determine if the track crosses a distorted region in the TPC
<span class="lineNum">      85 </span>            :   static Bool_t IsTrackInDistortedTpcRegion(const AliESDtrack * esdTrack);
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            :   virtual Long64_t Merge(TCollection* list);
<span class="lineNum">      88 </span>            :   virtual void Copy(TObject &amp;c) const;
<span class="lineNum">      89 </span>            :   AliESDtrackCuts(const AliESDtrackCuts&amp; pd);  // Copy Constructor
<span class="lineNum">      90 </span>            :   AliESDtrackCuts &amp;operator=(const AliESDtrackCuts &amp;c);
<span class="lineNum">      91 </span>            : 
<a name="92"><span class="lineNum">      92 </span>            :   //######################################################</a>
<span class="lineNum">      93 </span>            :   // track quality cut setters  
<a name="94"><span class="lineNum">      94 </span><span class="lineCov">         60 :   void SetMinNClustersTPC(Int_t min=-1)          {fCutMinNClusterTPC=min;}</span></a>
<a name="95"><span class="lineNum">      95 </span>            :   void SetMinNClustersTPCPtDep(TFormula *f1=0x0, Float_t ptmax=0.);</a>
<a name="96"><span class="lineNum">      96 </span><span class="lineCov">         44 :   void SetMinNClustersITS(Int_t min=-1)          {fCutMinNClusterITS=min;}</span></a>
<a name="97"><span class="lineNum">      97 </span><span class="lineCov">         44 :   void SetMinNCrossedRowsTPC(Float_t min=-1) { fCutMinNCrossedRowsTPC=min;}</span></a>
<span class="lineNum">      98 </span><span class="lineCov">         44 :   void SetMinRatioCrossedRowsOverFindableClustersTPC(Float_t min = -1) { fCutMinRatioCrossedRowsOverFindableClustersTPC=min;}</span>
<a name="99"><span class="lineNum">      99 </span><span class="lineNoCov">          0 :   void SetMinLengthActiveVolumeTPC(Float_t min = 120., Float_t width=2) {fCutMinLengthActiveVolumeTPC=min; fDeadZoneWidth=width;}</span></a>
<span class="lineNum">     100 </span>            :   void SetCutGeoNcrNcl(Float_t deadZoneWidth=2,Float_t cutGeoNcrNclLength=130, Float_t cutGeoNcrNclGeom1Pt=1.5, Float_t cutGeoNcrNclFractionNcr=0.9,  Float_t cutGeoNcrNclFractionNcl=0.70);
<a name="101"><span class="lineNum">     101 </span><span class="lineNoCov">          0 :   void SetCutOutDistortedRegionsTPC(Bool_t cutOutDistortedRegionTPC = kTRUE) {fCutOutDistortedRegionTPC=cutOutDistortedRegionTPC;}</span></a>
<a name="102"><span class="lineNum">     102 </span>            : </a>
<a name="103"><span class="lineNum">     103 </span><span class="lineCov">        140 :   void SetClusterRequirementITS(Detector det, ITSClusterRequirement req = kOff) { fCutClusterRequirementITS[det] = req; }</span></a>
<a name="104"><span class="lineNum">     104 </span><span class="lineNoCov">          0 :   void SetClusterRequirementITS(ITSULayers det, ITSClusterRequirement req = kOff) { fCutClusterRequirementITS[det] = req; }</span></a>
<a name="105"><span class="lineNum">     105 </span><span class="lineCov">         60 :   void SetMaxChi2PerClusterTPC(Float_t max=1e10) {fCutMaxChi2PerClusterTPC=max;}</span></a>
<a name="106"><span class="lineNum">     106 </span><span class="lineCov">         44 :   void SetMaxChi2PerClusterITS(Float_t max=1e10) {fCutMaxChi2PerClusterITS=max;}</span></a>
<a name="107"><span class="lineNum">     107 </span><span class="lineCov">         44 :   void SetMaxChi2TPCConstrainedGlobal(Float_t max=1e10) {fCutMaxChi2TPCConstrainedVsGlobal = max; }</span></a>
<a name="108"><span class="lineNum">     108 </span><span class="lineCov">         44 :   void SetMaxChi2TPCConstrainedGlobalVertexType(Int_t vertexType = kVertexTracks | kVertexSPD) { fCutMaxChi2TPCConstrainedVsGlobalVertexType = vertexType; }</span></a>
<a name="109"><span class="lineNum">     109 </span><span class="lineCov">         44 :   void SetMaxNOfMissingITSPoints(Int_t max=6)    {fCutMaxMissingITSPoints=max;}</span></a>
<a name="110"><span class="lineNum">     110 </span><span class="lineCov">         26 :   void SetRequireTPCRefit(Bool_t b=kFALSE)       {fCutRequireTPCRefit=b;}</span></a>
<a name="111"><span class="lineNum">     111 </span><span class="lineCov">         22 :   void SetRequireTPCStandAlone(Bool_t b=kFALSE)  {fCutRequireTPCStandAlone=b;}</span></a>
<a name="112"><span class="lineNum">     112 </span><span class="lineCov">         26 :   void SetRequireITSRefit(Bool_t b=kFALSE)       {fCutRequireITSRefit=b;}</span></a>
<a name="113"><span class="lineNum">     113 </span><span class="lineCov">         22 :   void SetRequireITSPid(Bool_t b=kFALSE)         {fCutRequireITSPid=b;}</span></a>
<span class="lineNum">     114 </span><span class="lineCov">         24 :   void SetRequireITSStandAlone(Bool_t b=kFALSE)    {fCutRequireITSStandAlone = b;} </span>
<span class="lineNum">     115 </span><span class="lineCov">         22 :   void SetRequireITSPureStandAlone(Bool_t b=kFALSE){fCutRequireITSpureSA = b;}</span>
<a name="116"><span class="lineNum">     116 </span>            : </a>
<a name="117"><span class="lineNum">     117 </span>            : </a>
<a name="118"><span class="lineNum">     118 </span><span class="lineCov">         30 :   void SetAcceptKinkDaughters(Bool_t b=kTRUE)    {fCutAcceptKinkDaughters=b;}</span></a>
<a name="119"><span class="lineNum">     119 </span><span class="lineCov">         22 :   void SetAcceptSharedTPCClusters(Bool_t b=kTRUE){fCutAcceptSharedTPCClusters=b;}</span></a>
<span class="lineNum">     120 </span><span class="lineCov">         44 :   void SetMaxFractionSharedTPCClusters(Float_t max=1e10) {fCutMaxFractionSharedTPCClusters=max;}</span>
<a name="121"><span class="lineNum">     121 </span>            :   void SetMaxCovDiagonalElements(Float_t c1=1e10, Float_t c2=1e10, Float_t c3=1e10, Float_t c4=1e10, Float_t c5=1e10) </a>
<span class="lineNum">     122 </span><span class="lineCov">         48 :     {fCutMaxC11=c1; fCutMaxC22=c2; fCutMaxC33=c3; fCutMaxC44=c4; fCutMaxC55=c5;}</span>
<span class="lineNum">     123 </span><span class="lineCov">         44 :   void SetMaxRel1PtUncertainty(Float_t max=1e10)      {fCutMaxRel1PtUncertainty=max;}</span>
<span class="lineNum">     124 </span>            : 
<a name="125"><span class="lineNum">     125 </span>            : </a>
<a name="126"><span class="lineNum">     126 </span>            :   // track to vertex cut setters</a>
<a name="127"><span class="lineNum">     127 </span><span class="lineCov">         44 :   void SetMaxNsigmaToVertex(Float_t sigma=1e10)       {fCutNsigmaToVertex = sigma; SetRequireSigmaToVertex(kTRUE);}</span></a>
<a name="128"><span class="lineNum">     128 </span><span class="lineCov">         24 :   void SetRequireSigmaToVertex(Bool_t b=kTRUE)        {fCutSigmaToVertexRequired = b;}</span></a>
<a name="129"><span class="lineNum">     129 </span><span class="lineCov">         56 :   void SetMaxDCAToVertexXY(Float_t dist=1e10)         {fCutMaxDCAToVertexXY = dist;}</span></a>
<a name="130"><span class="lineNum">     130 </span><span class="lineCov">         64 :   void SetMaxDCAToVertexZ(Float_t dist=1e10)          {fCutMaxDCAToVertexZ = dist;}</span></a>
<span class="lineNum">     131 </span><span class="lineCov">         44 :   void SetMinDCAToVertexXY(Float_t dist=0.)           {fCutMinDCAToVertexXY = dist;}</span>
<span class="lineNum">     132 </span><span class="lineCov">         44 :   void SetMinDCAToVertexZ(Float_t dist=0.)            {fCutMinDCAToVertexZ = dist;}</span>
<span class="lineNum">     133 </span>            :   void SetMaxDCAToVertexXYPtDep(const char *dist=&quot;&quot;);
<span class="lineNum">     134 </span>            :   void SetMaxDCAToVertexZPtDep(const char *dist=&quot;&quot;); 
<a name="135"><span class="lineNum">     135 </span>            :   void SetMinDCAToVertexXYPtDep(const char *dist=&quot;&quot;);</a>
<span class="lineNum">     136 </span>            :   void SetMinDCAToVertexZPtDep(const char *dist=&quot;&quot;); 
<span class="lineNum">     137 </span><span class="lineCov">         28 :   void SetDCAToVertex2D(Bool_t b=kFALSE)              {fCutDCAToVertex2D = b;}</span>
<span class="lineNum">     138 </span>            : 
<a name="139"><span class="lineNum">     139 </span>            : </a>
<a name="140"><span class="lineNum">     140 </span>            :   // getters  </a>
<a name="141"><span class="lineNum">     141 </span><span class="lineNoCov">          0 :   Int_t   GetMinNClusterTPC()        const   { return fCutMinNClusterTPC;}</span></a>
<a name="142"><span class="lineNum">     142 </span><span class="lineNoCov">          0 :   Float_t GetMinNCrossedRowsTPC()    const   { return fCutMinNCrossedRowsTPC;}</span></a>
<a name="143"><span class="lineNum">     143 </span><span class="lineNoCov">          0 :   Float_t GetMinRatioCrossedRowsOverFindableClustersTPC()    const   { return fCutMinRatioCrossedRowsOverFindableClustersTPC;}</span></a>
<a name="144"><span class="lineNum">     144 </span><span class="lineNoCov">          0 :   Float_t GetMinLengthActiveVolumeTPC() const { return fCutMinLengthActiveVolumeTPC;}</span></a>
<a name="145"><span class="lineNum">     145 </span><span class="lineNoCov">          0 :   Int_t   GetMinNClustersITS()       const   { return fCutMinNClusterITS;}</span></a>
<a name="146"><span class="lineNum">     146 </span><span class="lineNoCov">          0 :   TFormula *GetMinNClustersTPCPtDep() const  { return f1CutMinNClustersTPCPtDep;}</span></a>
<a name="147"><span class="lineNum">     147 </span><span class="lineNoCov">          0 :   ITSClusterRequirement GetClusterRequirementITS(Detector det) const { return fCutClusterRequirementITS[det]; }</span></a>
<a name="148"><span class="lineNum">     148 </span><span class="lineNoCov">          0 :   ITSClusterRequirement GetClusterRequirementITS(ITSULayers det) const { return fCutClusterRequirementITS[det]; }</span></a>
<a name="149"><span class="lineNum">     149 </span><span class="lineNoCov">          0 :   Float_t GetMaxChi2PerClusterTPC()  const   { return fCutMaxChi2PerClusterTPC;}</span></a>
<a name="150"><span class="lineNum">     150 </span><span class="lineNoCov">          0 :   Float_t GetMaxChi2PerClusterITS()  const   { return fCutMaxChi2PerClusterITS;}</span></a>
<a name="151"><span class="lineNum">     151 </span><span class="lineNoCov">          0 :   Float_t GetMaxChi2TPCConstrainedGlobal() const { return fCutMaxChi2TPCConstrainedVsGlobal; }</span></a>
<a name="152"><span class="lineNum">     152 </span><span class="lineNoCov">          0 :   Int_t GetMaxChi2TPCConstrainedGlobalVertexType() const { return fCutMaxChi2TPCConstrainedVsGlobalVertexType; }</span></a>
<a name="153"><span class="lineNum">     153 </span><span class="lineNoCov">          0 :   Int_t   GetMaxNOfMissingITSPoints() const   { return  fCutMaxMissingITSPoints;}</span></a>
<a name="154"><span class="lineNum">     154 </span><span class="lineNoCov">          0 :   Bool_t  GetRequireTPCRefit()       const   { return fCutRequireTPCRefit;}</span></a>
<a name="155"><span class="lineNum">     155 </span><span class="lineNoCov">          0 :   Bool_t  GetRequireTPCStandAlone()  const   { return fCutRequireTPCStandAlone;}</span></a>
<a name="156"><span class="lineNum">     156 </span><span class="lineNoCov">          0 :   Bool_t  GetRequireITSRefit()       const   { return fCutRequireITSRefit;}</span></a>
<a name="157"><span class="lineNum">     157 </span><span class="lineNoCov">          0 :   Bool_t  GetRequireITSStandAlone()  const   { return fCutRequireITSStandAlone; }</span></a>
<a name="158"><span class="lineNum">     158 </span><span class="lineNoCov">          0 :   Bool_t  GetAcceptKinkDaughters()   const   { return fCutAcceptKinkDaughters;}</span></a>
<a name="159"><span class="lineNum">     159 </span><span class="lineNoCov">          0 :   Bool_t  GetAcceptSharedTPCClusters()        const   {return fCutAcceptSharedTPCClusters;}</span></a>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :   Float_t GetMaxFractionSharedTPCClusters()   const   {return fCutMaxFractionSharedTPCClusters;}</span>
<a name="161"><span class="lineNum">     161 </span>            :   void    GetMaxCovDiagonalElements(Float_t&amp; c1, Float_t&amp; c2, Float_t&amp; c3, Float_t&amp; c4, Float_t&amp; c5) const</a>
<a name="162"><span class="lineNum">     162 </span><span class="lineNoCov">          0 :       {c1 = fCutMaxC11; c2 = fCutMaxC22; c3 = fCutMaxC33; c4 = fCutMaxC44; c5 = fCutMaxC55;}</span></a>
<a name="163"><span class="lineNum">     163 </span><span class="lineNoCov">          0 :   Float_t GetMaxRel1PtUncertainty()  const   { return fCutMaxRel1PtUncertainty;}</span></a>
<a name="164"><span class="lineNum">     164 </span><span class="lineNoCov">          0 :   Float_t GetMaxNsigmaToVertex()     const   { return fCutNsigmaToVertex;}</span></a>
<a name="165"><span class="lineNum">     165 </span><span class="lineNoCov">          0 :   Float_t GetMaxDCAToVertexXY()      const   { return fCutMaxDCAToVertexXY;}</span></a>
<a name="166"><span class="lineNum">     166 </span><span class="lineNoCov">          0 :   Float_t GetMaxDCAToVertexZ()       const   { return fCutMaxDCAToVertexZ;}</span></a>
<a name="167"><span class="lineNum">     167 </span><span class="lineNoCov">          0 :   Float_t GetMinDCAToVertexXY()      const   { return fCutMinDCAToVertexXY;}</span></a>
<a name="168"><span class="lineNum">     168 </span><span class="lineNoCov">          0 :   Float_t GetMinDCAToVertexZ()       const   { return fCutMinDCAToVertexZ;}</span></a>
<a name="169"><span class="lineNum">     169 </span><span class="lineNoCov">          0 :   const char* GetMaxDCAToVertexXYPtDep() const   { return fCutMaxDCAToVertexXYPtDep;}</span></a>
<a name="170"><span class="lineNum">     170 </span><span class="lineNoCov">          0 :   const char* GetMaxDCAToVertexZPtDep()  const   { return fCutMaxDCAToVertexZPtDep;}</span></a>
<a name="171"><span class="lineNum">     171 </span><span class="lineNoCov">          0 :   const char* GetMinDCAToVertexXYPtDep() const   { return fCutMinDCAToVertexXYPtDep;}</span></a>
<a name="172"><span class="lineNum">     172 </span><span class="lineNoCov">          0 :   const char* GetMinDCAToVertexZPtDep()  const   { return fCutMinDCAToVertexZPtDep;}</span></a>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :   Bool_t  GetDCAToVertex2D()         const   { return fCutDCAToVertex2D;}</span>
<a name="174"><span class="lineNum">     174 </span><span class="lineNoCov">          0 :   Bool_t  GetRequireSigmaToVertex( ) const   { return fCutSigmaToVertexRequired;}</span></a>
<a name="175"><span class="lineNum">     175 </span>            : </a>
<a name="176"><span class="lineNum">     176 </span><span class="lineNoCov">          0 :   void GetPRange(Float_t&amp; r1, Float_t&amp; r2)  const {r1=fPMin;   r2=fPMax;}</span></a>
<a name="177"><span class="lineNum">     177 </span><span class="lineNoCov">          0 :   void GetPtRange(Float_t&amp; r1, Float_t&amp; r2) const {r1=fPtMin;  r2=fPtMax;}</span></a>
<a name="178"><span class="lineNum">     178 </span><span class="lineNoCov">          0 :   void GetPxRange(Float_t&amp; r1, Float_t&amp; r2) const {r1=fPxMin;  r2=fPxMax;}</span></a>
<a name="179"><span class="lineNum">     179 </span><span class="lineNoCov">          0 :   void GetPyRange(Float_t&amp; r1, Float_t&amp; r2) const {r1=fPyMin;  r2=fPyMax;}</span></a>
<a name="180"><span class="lineNum">     180 </span><span class="lineNoCov">          0 :   void GetPzRange(Float_t&amp; r1, Float_t&amp; r2) const {r1=fPzMin;  r2=fPzMax;}</span></a>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :   void GetEtaRange(Float_t&amp; r1, Float_t&amp; r2) const {r1=fEtaMin; r2=fEtaMax;}</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :   void GetRapRange(Float_t&amp; r1, Float_t&amp; r2) const {r1=fRapMin; r2=fRapMax;}</span>
<a name="183"><span class="lineNum">     183 </span>            : </a>
<a name="184"><span class="lineNum">     184 </span>            :   // track kinmatic cut setters</a>
<a name="185"><span class="lineNum">     185 </span><span class="lineCov">         44 :   void SetPRange(Float_t r1=0, Float_t r2=1e10)       {fPMin=r1;   fPMax=r2;}</span></a>
<a name="186"><span class="lineNum">     186 </span><span class="lineCov">         48 :   void SetPtRange(Float_t r1=0, Float_t r2=1e10)      {fPtMin=r1;  fPtMax=r2;}</span></a>
<a name="187"><span class="lineNum">     187 </span><span class="lineCov">         44 :   void SetPxRange(Float_t r1=-1e10, Float_t r2=1e10)  {fPxMin=r1;  fPxMax=r2;}</span></a>
<a name="188"><span class="lineNum">     188 </span><span class="lineCov">         44 :   void SetPyRange(Float_t r1=-1e10, Float_t r2=1e10)  {fPyMin=r1;  fPyMax=r2;}</span></a>
<a name="189"><span class="lineNum">     189 </span><span class="lineCov">         44 :   void SetPzRange(Float_t r1=-1e10, Float_t r2=1e10)  {fPzMin=r1;  fPzMax=r2;}</span></a>
<span class="lineNum">     190 </span><span class="lineCov">        196 :   void SetEtaRange(Float_t r1=-1e10, Float_t r2=1e10) {fEtaMin=r1; fEtaMax=r2;}</span>
<span class="lineNum">     191 </span><span class="lineCov">         44 :   void SetRapRange(Float_t r1=-1e10, Float_t r2=1e10) {fRapMin=r1; fRapMax=r2;}</span>
<a name="192"><span class="lineNum">     192 </span>            : </a>
<span class="lineNum">     193 </span>            :   //######################################################
<span class="lineNum">     194 </span><span class="lineCov">         22 :   void SetHistogramsOn(Bool_t b=kFALSE) {fHistogramsOn = b;}</span>
<span class="lineNum">     195 </span>            :   void DefineHistograms(Int_t color=1);
<span class="lineNum">     196 </span>            :   virtual Bool_t LoadHistograms(const Char_t* dir = 0);
<span class="lineNum">     197 </span>            :   void SaveHistograms(const Char_t* dir = 0);
<span class="lineNum">     198 </span>            :   void DrawHistograms();
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span>            :   static Float_t GetSigmaToVertex(const AliESDtrack* const esdTrack);
<span class="lineNum">     201 </span>            :   static Float_t GetSigmaToVertexVTrack(const AliVTrack* const vTrack);
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span>            :   static void EnableNeededBranches(TTree* tree);
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span>            :   // void SaveQualityCuts(Char_t* file)
<a name="206"><span class="lineNum">     206 </span>            :   // void LoadQualityCuts(Char_t* file)</a>
<a name="207"><span class="lineNum">     207 </span>            : </a>
<a name="208"><span class="lineNum">     208 </span><span class="lineNoCov">          0 :   TH1F* GetDZNormalized(Int_t i) const { return fhDZNormalized[i]; }</span></a>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :   TH1F* GetNClustersTPC(Int_t i) const { return fhNClustersTPC[i]; }</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :   TH1F* GetPtHist(Int_t i) const { return fhPt[i]; }</span>
<a name="211"><span class="lineNum">     211 </span>            :   </a>
<a name="212"><span class="lineNum">     212 </span>            :   // TOF cuts</a>
<a name="213"><span class="lineNum">     213 </span><span class="lineNoCov">          0 :   void SetFlagCutTOFdistance(Bool_t flagTOFcut) { fFlagCutTOFdistance = flagTOFcut;}</span></a>
<a name="214"><span class="lineNum">     214 </span><span class="lineNoCov">          0 :   Bool_t GetFlagCutTOFdistance() const { return fFlagCutTOFdistance;}</span></a>
<a name="215"><span class="lineNum">     215 </span><span class="lineNoCov">          0 :   void SetCutTOFdistance(Float_t cut) { fCutTOFdistance = cut;}</span></a>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :   Float_t GetCutTOFdistance() const { return fCutTOFdistance;}</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :   void SetRequireTOFout(Bool_t b = kFALSE) {fCutRequireTOFout = b;} </span>
<span class="lineNum">     218 </span>            :   void SetRequireStandardTOFmatchCuts();
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            : protected:
<span class="lineNum">     221 </span>            :   void Init(); // sets everything to 0
<span class="lineNum">     222 </span>            :   Bool_t CheckITSClusterRequirement(ITSClusterRequirement req, Bool_t clusterL1, Bool_t clusterL2);
<span class="lineNum">     223 </span>            :   Bool_t CheckPtDepDCA(TString dist,Bool_t print=kFALSE) const;
<span class="lineNum">     224 </span>            :   void SetPtDepDCACuts(Double_t pt);
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            :   enum { kNCuts = 45 }; 
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span>            :   //######################################################
<span class="lineNum">     229 </span>            :   // esd track quality cuts
<span class="lineNum">     230 </span>            :   static const Char_t* fgkCutNames[kNCuts]; //! names of cuts (for internal use)
<span class="lineNum">     231 </span>            :   static AliESDtrackCuts* fgMultEstTrackCuts[kNMultEstTrackCuts]; //! track cuts used for the multiplicity estimate
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span>            :   Int_t   fCutMinNClusterTPC;         // min number of tpc clusters
<span class="lineNum">     234 </span>            :   Int_t   fCutMinNClusterITS;         // min number of its clusters
<span class="lineNum">     235 </span>            :   Float_t   fCutMinNCrossedRowsTPC;     // min number of tpc crossed rows
<span class="lineNum">     236 </span>            :   Float_t fCutMinRatioCrossedRowsOverFindableClustersTPC; // min ratio crossed rows / findable clusters
<span class="lineNum">     237 </span>            :   TFormula *f1CutMinNClustersTPCPtDep; // pt dependent tpc clusters cut
<span class="lineNum">     238 </span>            :   Float_t fCutMaxPtDepNClustersTPC;     // maximum pt for pt dependend TPC cluster cut. For pt=&gt;ptmax NClusterMin = f1CutMinNClustersTPCPtDep-&gt;Eval(fCutMaxPtDepNClustersTPC).
<span class="lineNum">     239 </span>            :   Float_t fCutMinLengthActiveVolumeTPC; // mininum length (in cm) over which the track is sampled in the active volume of the TPC (outside boundaries)
<span class="lineNum">     240 </span>            :   Float_t fDeadZoneWidth;             // width of the TPC dead zone (missing pads + PRF +ExB)
<span class="lineNum">     241 </span>            :   // TPC geometrical cut combined with cut on crossed rows and number of clusters    
<span class="lineNum">     242 </span>            :   Float_t fCutGeoNcrNclLength;        // cut on the geometical length  condition Ngeom(cm)&gt;cutGeoNcrNclLength default=130
<span class="lineNum">     243 </span>            :   Float_t fCutGeoNcrNclGeom1Pt;       // 1/pt dependence slope  cutGeoNcrNclLength:=fCutGeoNcrNclLength-abs(1/pt)^fCutGeoNcrNclGeom1Pt
<span class="lineNum">     244 </span>            :   Float_t fCutGeoNcrNclFractionNcr;   // relative fraction cut Ncr  condition Ncr&gt;cutGeoNcrNclFractionNcr*fCutGeoNcrNclLength
<span class="lineNum">     245 </span>            :   Float_t fCutGeoNcrNclFractionNcl;   // ralative fraction cut Ncr  condition Ncl&gt;cutGeoNcrNclFractionNcl
<span class="lineNum">     246 </span>            :   // TPC distorted regions
<span class="lineNum">     247 </span>            :   Bool_t  fCutOutDistortedRegionTPC;  // flag if distorted regions in the TPC should be cut out
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span>            :   ITSClusterRequirement fCutClusterRequirementITS[3];  // detailed ITS cluster requirements for (SPD, SDD, SSD)
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            :   Float_t fCutMaxChi2PerClusterTPC;   // max tpc fit chi2 per tpc cluster
<span class="lineNum">     253 </span>            :   Float_t fCutMaxChi2PerClusterITS;   // max its fit chi2 per its cluster
<span class="lineNum">     254 </span>            :   Float_t fCutMaxChi2TPCConstrainedVsGlobal; // max chi2 TPC track constrained with vtx vs. global track
<span class="lineNum">     255 </span>            :   Int_t fCutMaxChi2TPCConstrainedVsGlobalVertexType; // vertex type for max chi2 TPC track constrained with vtx vs. global track (can be configured to accept several vertex types)
<span class="lineNum">     256 </span>            :   Int_t   fCutMaxMissingITSPoints;    // max n. of missing ITS points
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            :   Float_t fCutMaxC11;                 // max cov. matrix diag. elements (res. y^2)
<span class="lineNum">     259 </span>            :   Float_t fCutMaxC22;                 // max cov. matrix diag. elements (res. z^2)
<span class="lineNum">     260 </span>            :   Float_t fCutMaxC33;                 // max cov. matrix diag. elements (res. sin(phi)^2)
<span class="lineNum">     261 </span>            :   Float_t fCutMaxC44;                 // max cov. matrix diag. elements (res. tan(theta_dip)^2)
<span class="lineNum">     262 </span>            :   Float_t fCutMaxC55;                 // max cov. matrix diag. elements (res. 1/pt^2)
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span>            :   Float_t fCutMaxRel1PtUncertainty;   // max relative uncertainty of 1/pt
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            :   Bool_t  fCutAcceptKinkDaughters;    // accepting kink daughters?
<span class="lineNum">     267 </span>            :   Bool_t  fCutAcceptSharedTPCClusters;// accepting shared clusters in TPC?
<span class="lineNum">     268 </span>            :   Float_t fCutMaxFractionSharedTPCClusters; //Maximum fraction of shared clusters in TPC
<span class="lineNum">     269 </span>            :   Bool_t  fCutRequireTPCRefit;        // require TPC refit
<span class="lineNum">     270 </span>            :   Bool_t  fCutRequireTPCStandAlone;   // require TPC standalone tracks
<span class="lineNum">     271 </span>            :   Bool_t  fCutRequireITSRefit;        // require ITS refit
<span class="lineNum">     272 </span>            :   Bool_t  fCutRequireITSPid;          // require ITS pid
<span class="lineNum">     273 </span>            :   Bool_t  fCutRequireITSStandAlone;   // require ITS standalone tracks (remove pure SA)
<span class="lineNum">     274 </span>            :   Bool_t  fCutRequireITSpureSA;       // require ITS pure standalone tracks (found using all ITS clusters)
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            :   // track to vertex cut
<span class="lineNum">     278 </span>            :   Float_t fCutNsigmaToVertex;         // max number of estimated sigma from track-to-vertex
<span class="lineNum">     279 </span>            :   Bool_t  fCutSigmaToVertexRequired;  // cut track if sigma from track-to-vertex could not be calculated
<span class="lineNum">     280 </span>            :   Float_t fCutMaxDCAToVertexXY;       // track-to-vertex cut in max absolute distance in xy-plane
<span class="lineNum">     281 </span>            :   Float_t fCutMaxDCAToVertexZ;        // track-to-vertex cut in max absolute distance in z-plane
<span class="lineNum">     282 </span>            :   Float_t fCutMinDCAToVertexXY;       // track-to-vertex cut on min absolute distance in xy-plane
<span class="lineNum">     283 </span>            :   Float_t fCutMinDCAToVertexZ;        // track-to-vertex cut on min absolute distance in z-plane
<span class="lineNum">     284 </span>            :   // 
<span class="lineNum">     285 </span>            :   TString fCutMaxDCAToVertexXYPtDep;  // pt-dep track-to-vertex cut in max absolute distance in xy-plane
<span class="lineNum">     286 </span>            :   TString fCutMaxDCAToVertexZPtDep;   // pt-dep track-to-vertex cut in max absolute distance in z-plane
<span class="lineNum">     287 </span>            :   TString fCutMinDCAToVertexXYPtDep;  // pt-dep track-to-vertex cut on min absolute distance in xy-plane
<span class="lineNum">     288 </span>            :   TString fCutMinDCAToVertexZPtDep;   // pt-dep track-to-vertex cut on min absolute distance in z-plane
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span>            :   // only internal use, set via strings above
<span class="lineNum">     291 </span>            :   TFormula *f1CutMaxDCAToVertexXYPtDep;  // pt-dep track-to-vertex cut in max absolute distance in xy-plane
<span class="lineNum">     292 </span>            :   TFormula *f1CutMaxDCAToVertexZPtDep;   // pt-dep track-to-vertex cut in max absolute distance in z-plane
<span class="lineNum">     293 </span>            :   TFormula *f1CutMinDCAToVertexXYPtDep;  // pt-dep track-to-vertex cut on min absolute distance in xy-plane
<span class="lineNum">     294 </span>            :   TFormula *f1CutMinDCAToVertexZPtDep;   // pt-dep track-to-vertex cut on min absolute distance in z-plane
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span>            :   Bool_t  fCutDCAToVertex2D;          // if true a 2D DCA cut is made. Tracks are accepted if sqrt((DCAXY / fCutMaxDCAToVertexXY)^2 + (DCAZ / fCutMaxDCAToVertexZ)^2) &lt; 1 AND sqrt((DCAXY / fCutMinDCAToVertexXY)^2 + (DCAZ / fCutMinDCAToVertexZ)^2) &gt; 1
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            :   // esd kinematics cuts
<span class="lineNum">     299 </span>            :   Float_t fPMin,   fPMax;             // definition of the range of the P
<span class="lineNum">     300 </span>            :   Float_t fPtMin,  fPtMax;            // definition of the range of the Pt
<span class="lineNum">     301 </span>            :   Float_t fPxMin,  fPxMax;            // definition of the range of the Px
<span class="lineNum">     302 </span>            :   Float_t fPyMin,  fPyMax;            // definition of the range of the Py
<span class="lineNum">     303 </span>            :   Float_t fPzMin,  fPzMax;            // definition of the range of the Pz
<span class="lineNum">     304 </span>            :   Float_t fEtaMin, fEtaMax;           // definition of the range of the eta
<span class="lineNum">     305 </span>            :   Float_t fRapMin, fRapMax;           // definition of the range of the y
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            :   Bool_t  fCutRequireTOFout;        // require TOF out 
<span class="lineNum">     308 </span>            :   Bool_t  fFlagCutTOFdistance;       // cut on TOFdistance? --&gt; yes by default!
<span class="lineNum">     309 </span>            :   Float_t fCutTOFdistance;           // value of the cut on TOFdistance
<span class="lineNum">     310 </span>            :   static Char_t fgBeamTypeFlag;      // -1 --&gt; no check done on the beam type yet
<span class="lineNum">     311 </span>            :                                      // 0 --&gt; beam type != &quot;A-A&quot;
<span class="lineNum">     312 </span>            :                                      // 1  --&gt; beam type == &quot;A-A&quot;
<span class="lineNum">     313 </span>            :    
<span class="lineNum">     314 </span>            :   //######################################################
<span class="lineNum">     315 </span>            :   // diagnostics histograms
<span class="lineNum">     316 </span>            :   Bool_t fHistogramsOn;               // histograms on/off
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            :   TH1F* fhNClustersITS[2];            //-&gt;
<span class="lineNum">     319 </span>            :   TH1F* fhNClustersTPC[2];            //-&gt;
<span class="lineNum">     320 </span>            :   TH1F* fhNSharedClustersTPC[2];      //-&gt;
<span class="lineNum">     321 </span>            :   TH1F* fhNCrossedRowsTPC[2];         //-&gt;
<span class="lineNum">     322 </span>            :   TH1F* fhRatioCrossedRowsOverFindableClustersTPC[2]; // -&gt;
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span>            :   TH1F* fhChi2PerClusterITS[2];       //-&gt;
<span class="lineNum">     325 </span>            :   TH1F* fhChi2PerClusterTPC[2];       //-&gt;
<span class="lineNum">     326 </span>            :   TH1F* fhChi2TPCConstrainedVsGlobal[2];       //-&gt;
<span class="lineNum">     327 </span>            :   TH1F* fhNClustersForITSPID[2];      //-&gt; number of points in SDD+SSD (ITS PID selection)
<span class="lineNum">     328 </span>            :   TH1F* fhNMissingITSPoints[2];       //-&gt; number of missing ITS points
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            :   TH1F* fhC11[2];                     //-&gt;
<span class="lineNum">     331 </span>            :   TH1F* fhC22[2];                     //-&gt;
<span class="lineNum">     332 </span>            :   TH1F* fhC33[2];                     //-&gt;
<span class="lineNum">     333 </span>            :   TH1F* fhC44[2];                     //-&gt;
<span class="lineNum">     334 </span>            :   TH1F* fhC55[2];                     //-&gt;
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            :   TH1F* fhRel1PtUncertainty[2];       //-&gt; rel. uncertainty of 1/pt
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span>            :   TH1F* fhDXY[2];                     //-&gt;
<span class="lineNum">     339 </span>            :   TH1F* fhDZ[2];                      //-&gt;
<span class="lineNum">     340 </span>            :   TH1F* fhDXYDZ[2];                   //-&gt; absolute distance sqrt(dxy**2 + dz**2) to vertex; if 2D cut is set, normalized to given values
<span class="lineNum">     341 </span>            :   TH2F* fhDXYvsDZ[2];                 //-&gt;
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span>            :   TH1F* fhDXYNormalized[2];           //-&gt;
<span class="lineNum">     344 </span>            :   TH1F* fhDZNormalized[2];            //-&gt;
<span class="lineNum">     345 </span>            :   TH2F* fhDXYvsDZNormalized[2];       //-&gt;
<span class="lineNum">     346 </span>            :   TH1F* fhNSigmaToVertex[2];          //-&gt;
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span>            :   TH1F* fhPt[2];                      //-&gt; pt of esd tracks
<span class="lineNum">     349 </span>            :   TH1F* fhEta[2];                     //-&gt; eta of esd tracks
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span>            :   TF1*  ffDTheoretical;               //-&gt; theoretical distance to vertex normalized (2d gauss)
<span class="lineNum">     352 </span>            : 
<span class="lineNum">     353 </span>            :   TH1F*  fhCutStatistics;             //-&gt; statistics of what cuts the tracks did not survive
<span class="lineNum">     354 </span>            :   TH2F*  fhCutCorrelation;            //-&gt; 2d statistics plot
<span class="lineNum">     355 </span>            : 
<a name="356"><span class="lineNum">     356 </span>            :   TH2F* fhTOFdistance[2];            //-&gt; TOF signal distance dx vs dz</a>
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span><span class="lineCov">        218 :   ClassDef(AliESDtrackCuts, 23)</span>
<span class="lineNum">     359 </span>            : };
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
