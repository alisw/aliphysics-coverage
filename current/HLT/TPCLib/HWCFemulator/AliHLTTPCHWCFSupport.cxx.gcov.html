<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - HLT/TPCLib/HWCFemulator/AliHLTTPCHWCFSupport.cxx</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">HLT/TPCLib/HWCFemulator</a> - AliHLTTPCHWCFSupport.cxx<span style="font-size: 80%;"> (source / <a href="AliHLTTPCHWCFSupport.cxx.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">18</td>
            <td class="headerCovTableEntry">357</td>
            <td class="headerCovTableEntryLo">5.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">5</td>
            <td class="headerCovTableEntry">15</td>
            <td class="headerCovTableEntryLo">33.3 %</td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // $Id$</a>
<span class="lineNum">       2 </span>            : //****************************************************************************
<span class="lineNum">       3 </span>            : //* This file is property of and copyright by the ALICE HLT Project          * 
<span class="lineNum">       4 </span>            : //* ALICE Experiment at CERN, All rights reserved.                           *
<span class="lineNum">       5 </span>            : //*                                                                          *
<span class="lineNum">       6 </span>            : //* Primary Authors: Sergey Gorbunov, Torsten Alt                            *
<span class="lineNum">       7 </span>            : //* Developers:      Sergey Gorbunov &lt;sergey.gorbunov@fias.uni-frankfurt.de&gt; *
<span class="lineNum">       8 </span>            : //*                  Torsten Alt &lt;talt@cern.ch&gt;                              *
<span class="lineNum">       9 </span>            : //*                  for The ALICE HLT Project.                              *
<span class="lineNum">      10 </span>            : //*                                                                          *
<span class="lineNum">      11 </span>            : //* Permission to use, copy, modify and distribute this software and its     *
<span class="lineNum">      12 </span>            : //* documentation strictly for non-commercial purposes is hereby granted     *
<span class="lineNum">      13 </span>            : //* without fee, provided that the above copyright notice appears in all     *
<span class="lineNum">      14 </span>            : //* copies and that both the copyright notice and this permission notice     *
<span class="lineNum">      15 </span>            : //* appear in the supporting documentation. The authors make no claims       *
<span class="lineNum">      16 </span>            : //* about the suitability of this software for any purpose. It is            *
<span class="lineNum">      17 </span>            : //* provided &quot;as is&quot; without express or implied warranty.                    *
<span class="lineNum">      18 </span>            : //****************************************************************************
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : //  @file   AliHLTTPCHWCFSupport.cxx
<span class="lineNum">      21 </span>            : //  @author Sergey Gorbunov &lt;sergey.gorbunov@fias.uni-frankfurt.de&gt;
<span class="lineNum">      22 </span>            : //  @author Torsten Alt &lt;talt@cern.ch&gt; 
<span class="lineNum">      23 </span>            : //  @brief  Input interfaces for FPGA ClusterFinder Emulator for TPC
<span class="lineNum">      24 </span>            : //  @brief  ( see AliHLTTPCHWCFEmulator class )
<span class="lineNum">      25 </span>            : //  @note
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : #include &quot;AliHLTTPCHWCFSupport.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;AliHLTDataTypes.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;AliHLTTPCMapping.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;AliHLTTPCDigitReaderUnpacked.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;AliHLTTPCGeometry.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;AliHLTTPCDefinitions.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;AliHLTCDHWrapper.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;AliHLTTPCHWCFEmulator.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;AliTPCcalibDB.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;AliTPCCalPad.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;AliTPCCalROC.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;TMath.h&quot;
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            : #include &lt;cstdlib&gt;
<span class="lineNum">      42 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      43 </span>            : #include &lt;cerrno&gt;
<span class="lineNum">      44 </span>            : #include &lt;sys/time.h&gt;
<span class="lineNum">      45 </span>            : 
<a name="46"><span class="lineNum">      46 </span>            : using namespace std;</a>
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            : AliHLTTPCHWCFSupport::AliHLTTPCHWCFSupport()
<span class="lineNum">      49 </span>            :   : 
<span class="lineNum">      50 </span><span class="lineCov">          3 :   AliHLTLogging(),</span>
<span class="lineNum">      51 </span><span class="lineCov">          3 :   fProcessingRCU2Data(0),</span>
<span class="lineNum">      52 </span><span class="lineCov">          3 :   fEventMemory(0),</span>
<span class="lineNum">      53 </span><span class="lineCov">          3 :   fEventMCMemory(0)</span>
<span class="lineNum">      54 </span><span class="lineCov">         15 : {</span>
<span class="lineNum">      55 </span>            :   // see header file for class documentation
<span class="lineNum">      56 </span><span class="lineCov">        222 :   for( int i=0; i&lt;fgkNSlices; i++ )</span>
<span class="lineNum">      57 </span><span class="lineCov">       1512 :     for( int j=0; j&lt;fgkNPatches; j++ ) fMapping[i][j] = 0;</span>
<span class="lineNum">      58 </span><span class="lineCov">          6 : }</span>
<a name="59"><span class="lineNum">      59 </span>            : </a>
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            : AliHLTTPCHWCFSupport::~AliHLTTPCHWCFSupport()
<span class="lineNum">      62 </span><span class="lineCov">         12 : {</span>
<span class="lineNum">      63 </span>            :   // see header file for class documentation
<span class="lineNum">      64 </span><span class="lineCov">        222 :   for( int i=0; i&lt;fgkNSlices; i++ )</span>
<span class="lineNum">      65 </span><span class="lineCov">       2160 :     for( int j=0; j&lt;fgkNPatches; j++ ) delete[] fMapping[i][j];</span>
<span class="lineNum">      66 </span><span class="lineCov">          3 :   ReleaseEventMemory(); </span>
<a name="67"><span class="lineNum">      67 </span><span class="lineCov">          6 : }</span></a>
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            : AliHLTTPCHWCFSupport::AliHLTTPCHWCFSupport(const AliHLTTPCHWCFSupport&amp;)
<span class="lineNum">      70 </span>            :   : 
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :   AliHLTLogging(),</span>
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :   fProcessingRCU2Data(0),</span>
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :   fEventMemory(0),</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :   fEventMCMemory(0)</span>
<span class="lineNum">      75 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">      76 </span>            :   // dummy
<a name="77"><span class="lineNum">      77 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : AliHLTTPCHWCFSupport&amp; AliHLTTPCHWCFSupport::operator=(const AliHLTTPCHWCFSupport&amp;){
<span class="lineNum">      80 </span>            :   // dummy
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :   return *this;</span>
<span class="lineNum">      82 </span>            : }
<a name="83"><span class="lineNum">      83 </span>            : </a>
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            : void AliHLTTPCHWCFSupport::ReleaseEventMemory()
<span class="lineNum">      86 </span>            : {
<span class="lineNum">      87 </span>            :   // clean up 
<span class="lineNum">      88 </span><span class="lineCov">          6 :   if( fEventMemory ) delete[] fEventMemory;</span>
<span class="lineNum">      89 </span><span class="lineCov">          3 :   if( fEventMCMemory )delete[] fEventMCMemory;</span>
<span class="lineNum">      90 </span><span class="lineCov">          3 :   fEventMemory = 0;</span>
<span class="lineNum">      91 </span><span class="lineCov">          3 :   fEventMCMemory = 0;</span>
<a name="92"><span class="lineNum">      92 </span><span class="lineCov">          3 : }</span></a>
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            : void AliHLTTPCHWCFSupport::UnloadMapping()
<span class="lineNum">      95 </span>            : {
<span class="lineNum">      96 </span>            :   // unload mapping
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :   for( int i=0; i&lt;fgkNSlices; i++ ){</span>
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :     for( int j=0; j&lt;fgkNPatches; j++ ){</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :       delete[] fMapping[i][j];</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :       fMapping[i][j] = NULL;</span>
<span class="lineNum">     101 </span>            :     }
<span class="lineNum">     102 </span>            :   }
<a name="103"><span class="lineNum">     103 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            : const AliHLTUInt32_t *AliHLTTPCHWCFSupport::GetMapping( int slice, int patch )
<span class="lineNum">     106 </span>            : { 
<span class="lineNum">     107 </span>            :   // see header file for class documentation
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :   if( slice&lt;0 || slice&gt;=fgkNSlices ){</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :     HLTFatal(&quot;Wrong slice number %d, no mapping is provided.&quot;, slice);</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     111 </span>            :   }
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :   if( patch&lt;0 || patch&gt;= fgkNPatches ){</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :     HLTFatal(&quot;Wrong patch number %d, no mapping is provided.&quot;, patch);</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     115 </span>            :   }
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :   if( !fMapping[slice][patch] ) fMapping[slice][patch] = ReadMapping(slice,patch);</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 : return fMapping[slice][patch];</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 : }</span>
<a name="119"><span class="lineNum">     119 </span>            : </a>
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            : AliHLTUInt32_t *AliHLTTPCHWCFSupport::ReadMapping( int slice, int patch, const char *mappingFileName ) const
<span class="lineNum">     122 </span>            : {
<span class="lineNum">     123 </span>            :   // Create mapping array for one patch 
<span class="lineNum">     124 </span>            :   // If no mapping file provided, reads from default file
<span class="lineNum">     125 </span>            :   // Output: mapping [] array of type AliHLTUInt32_t, where :
<span class="lineNum">     126 </span>            :   //
<span class="lineNum">     127 </span>            :   // mapping[0] == N hardware adresses in the array (mapping size is maping[0] + 1 )
<span class="lineNum">     128 </span>            :   // mapping[hwAddress] == configWord
<span class="lineNum">     129 </span>            :   //
<span class="lineNum">     130 </span>            :   // configWord consist of:
<span class="lineNum">     131 </span>            :   //
<span class="lineNum">     132 </span>            :   // bits 0-7: pad number
<span class="lineNum">     133 </span>            :   // bits 8-13: row number
<span class="lineNum">     134 </span>            :   // bit  14 : flag for border pad
<span class="lineNum">     135 </span>            :   // bit  15 : is the pad active
<span class="lineNum">     136 </span>            :   // bits 16-&gt;28 : gain calibration as 13 bit fixed point,
<span class="lineNum">     137 </span>            :   //               with 1 bit position before decimal point
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span>            :   const AliHLTUInt32_t  kBorderFlag = (1 &lt;&lt; 14); 
<span class="lineNum">     140 </span>            :   const AliHLTUInt32_t  kActiveFlag = (1 &lt;&lt; 15); 
<span class="lineNum">     141 </span>            :   
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :   if( slice&lt;0 || slice&gt;=fgkNSlices ){</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :      HLTFatal(&quot;Wrong slice number %d, no mapping is provided.&quot;, slice);</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :      return 0;</span>
<span class="lineNum">     145 </span>            :   }
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :   if( patch&lt;0 || patch&gt;5 ){</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :      HLTFatal(&quot;Wrong patch number %d, no mapping is provided.&quot;, patch);</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :      return 0;</span>
<span class="lineNum">     150 </span>            :   }
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            :   // AliHLTTPCGeometry::GetFirstRow returns first row in scheme A.
<span class="lineNum">     153 </span>            :   // We have to transform to scheme B by AliHLTTPCGeometry::Slice2Sector.
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span>            :   UInt_t offsetSchemeB=0;
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :   Int_t sector = 0;</span>
<span class="lineNum">     157 </span>            :   {
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :     Int_t tmp=0;</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :     AliHLTTPCGeometry::Slice2Sector(slice, AliHLTTPCGeometry::GetFirstRow(patch),</span>
<span class="lineNum">     160 </span>            :                                      sector, tmp);
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :     offsetSchemeB = (UInt_t) tmp;</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     163 </span>            :   
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :   AliTPCcalibDB *calib = AliTPCcalibDB::Instance();  </span>
<span class="lineNum">     166 </span>            :   AliTPCCalPad * gainTPC = 0;
<span class="lineNum">     167 </span>            :   AliTPCCalROC * gainROC = 0;
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :   if( calib ) gainTPC = calib-&gt;GetPadGainFactor();</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :   if( gainTPC ) gainROC = gainTPC-&gt;GetCalROC(sector);  // pad gains per given sector</span>
<span class="lineNum">     170 </span>            :   else{      
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :     HLTWarning(&quot;No TPC gain calibration found&quot;);  </span>
<span class="lineNum">     172 </span>            :   }
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :   TString filename;</span>
<span class="lineNum">     175 </span>            :   
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :   if( mappingFileName ){</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :     filename = mappingFileName;</span>
<span class="lineNum">     178 </span>            :   } else {
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :     const char* basePath=getenv(&quot;ALICE_ROOT&quot;);</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :     if (basePath) filename.Form(&quot;%s/TPC/mapping/Patch%d.data&quot;, basePath,patch);    </span>
<span class="lineNum">     181 </span>            :   } 
<span class="lineNum">     182 </span>            :   
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :   ifstream inFile;</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :   inFile.open(filename.Data());</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :   if (!inFile) {</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :     HLTFatal(&quot;Unable to open mapping file: %s   This means no mapping is provided.&quot;, filename.Data());</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     188 </span>            :   }
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span>            :   AliHLTUInt32_t *mapping = 0; 
<span class="lineNum">     192 </span>            :   AliHLTUInt32_t *rowBranchPadHw = 0;
<span class="lineNum">     193 </span>            :   bool err = 1;
<span class="lineNum">     194 </span>            :   do{
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :     UInt_t nHWAdd=0;</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :     UInt_t maxHWAdd=0;</span>
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :     if( !(inFile &gt;&gt; nHWAdd ) || !(inFile &gt;&gt; maxHWAdd)  ){</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :       HLTError(&quot;Mapping file for patch %d corrupted &amp;s&quot;, patch,filename.Data());</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     202 </span>            :     }
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :     if( maxHWAdd &gt; 0xFFF ){</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :       HLTError(&quot;Max hardware address exceeded for patch %d, max number is %d, number from mapping file is %d.&quot;,patch, 0xFFF, maxHWAdd+1);     </span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     207 </span>            :     }
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :     if(nHWAdd &gt; maxHWAdd ){</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :       HLTError(&quot;Too large number of hardware addresses for patch %d: max number is %d, number from mapping file is %d.&quot;,patch, maxHWAdd, nHWAdd );</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     212 </span>            :     }
<span class="lineNum">     213 </span>            :       
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :     mapping = new AliHLTUInt32_t[maxHWAdd+2];</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :     rowBranchPadHw = new AliHLTUInt32_t[nHWAdd];</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :     if( !mapping || !rowBranchPadHw ){</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :       HLTError(&quot;Can not allocate &amp;d bytes of memory&quot;, (maxHWAdd+1+nHWAdd)*sizeof(AliHLTUInt32_t));</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     219 </span>            :     }
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :     for( unsigned int i=0; i&lt;maxHWAdd+2; i++ ) mapping[i] = 0;</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :     for( unsigned int i=0; i&lt;nHWAdd; i++ ) rowBranchPadHw[i] = 0;    </span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :     mapping[0] = maxHWAdd+1;</span>
<span class="lineNum">     224 </span>            :     UInt_t nRead = 0;
<span class="lineNum">     225 </span>            :     err = 0;
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :     while(!err ){</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :       UInt_t hwAdd=0;</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :       UInt_t row=0;</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :       UInt_t pad=0;</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :       if( !(inFile&gt;&gt;hwAdd) || !(inFile&gt;&gt;row) || !(inFile&gt;&gt;pad) ) break;      </span>
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            :       err = 1;
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :       if ( nRead &gt;= nHWAdd ){</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :         HLTError(&quot;Too many hardware addresses: %d, expected %d, mapping file %s corrupted?&quot;, nRead+1,  nHWAdd, filename.Data());</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     237 </span>            :       }
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :       if (hwAdd&gt;maxHWAdd) {</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :         HLTError(&quot;hardware address exceeds max hwAddress %d, mapping file %s corrupted?&quot;, maxHWAdd, filename.Data()); </span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     241 </span>            :       }
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :       if( row &lt; offsetSchemeB ){</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :         HLTError(&quot;row number %d below minimum %d for patch %d, mapping file %s corrupted?&quot;, row, offsetSchemeB, patch, filename.Data());      </span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :         break;    </span>
<span class="lineNum">     246 </span>            :       } 
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :       row -= offsetSchemeB;</span>
<span class="lineNum">     249 </span>            :         
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :       if( row &gt; 0x3F ){</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :         HLTError(&quot;row number %d withing patch exceed the maximum %d for patch %d, mapping file %s corrupted?&quot;, row, 0x3F, patch, filename.Data());    </span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :         break;    </span>
<span class="lineNum">     253 </span>            :       }
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :       if( pad &gt; 0xFF ){</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :         HLTError(&quot;pad number %d exceed the maximum %d for patch %d, mapping file %s corrupted?&quot;, pad, 0xFF, patch, filename.Data());  </span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :         break;    </span>
<span class="lineNum">     258 </span>            :       }
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            :       bool active = true; // Currently all channels are always active   
<span class="lineNum">     261 </span>            :       //
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            :       AliHLTFloat64_t gain = 1.;
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :       if( gainROC ){</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :         gain = gainROC-&gt;GetValue(offsetSchemeB+row,pad);</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :         if( gain&gt;1.e-4 ) gain = 1./gain;</span>
<span class="lineNum">     267 </span>            :         else gain = 0;
<span class="lineNum">     268 </span>            :       }
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :       gain*= (1&lt;&lt;12);</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :       AliHLTUInt32_t  gainCalib = TMath::Nint(gain); </span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :       if( gainCalib &gt; 0x1FFF ) gainCalib = 0x1FFF;</span>
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :       AliHLTUInt32_t configWord = ( (row &amp; 0x3F) &lt;&lt; 8 ) | (pad &amp; 0xFF);</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :       if ( active ) configWord |= kActiveFlag;</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :       configWord |= (gainCalib &amp; 0x1FFF) &lt;&lt; 16;       </span>
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :       mapping[1+hwAdd] = configWord;</span>
<span class="lineNum">     278 </span>            :         
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :       AliHLTUInt32_t branch = (hwAdd &gt;&gt; 11) &amp; 0x1;    </span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :       if( fProcessingRCU2Data ) branch = 0;</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :       rowBranchPadHw[nRead] = (row&lt;&lt;25) | (branch&lt;&lt;24) | (pad&lt;&lt;16) | hwAdd;</span>
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :       nRead++;</span>
<span class="lineNum">     284 </span>            :       err = 0;
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     286 </span>            :     
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :     if( err ) break;</span>
<span class="lineNum">     288 </span>            :     
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :     if ( nRead!= nHWAdd ){</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :       HLTError(&quot;Too less hardware addresses: %d, expected %d, mapping file %s corrupted?&quot;, nRead,  nHWAdd, filename.Data());</span>
<span class="lineNum">     291 </span>            :       err = 1;
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     293 </span>            :     }
<span class="lineNum">     294 </span>            :     
<span class="lineNum">     295 </span>            :     // mark pads at borders of A/B branches 
<span class="lineNum">     296 </span>            :       
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :     std::sort(rowBranchPadHw, rowBranchPadHw + nHWAdd);</span>
<span class="lineNum">     298 </span>            :     int rowBranchPadLast = -10;
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :     for( unsigned int i=0; i&lt;nHWAdd; i++ ){</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :       int rowBranchPad = rowBranchPadHw[i]&gt;&gt;16;</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :       if( rowBranchPad != rowBranchPadLast+1 ){</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :         mapping[1+(rowBranchPadHw[i] &amp; 0xFFF)] |= kBorderFlag;</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :         if( i&gt;0 ) mapping[1+(rowBranchPadHw[i-1] &amp; 0xFFF)] |= kBorderFlag;         </span>
<span class="lineNum">     304 </span>            :       }
<span class="lineNum">     305 </span>            :       rowBranchPadLast = rowBranchPad;
<span class="lineNum">     306 </span>            :     }
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :     mapping[1+(rowBranchPadHw[nRead-1] &amp; 0xFFF)] |= kBorderFlag;</span>
<span class="lineNum">     308 </span>            :     
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :   } while(0);</span>
<span class="lineNum">     310 </span>            :   
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :   inFile.close();</span>
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :   delete[] rowBranchPadHw;</span>
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :   if( err ){</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :     delete[] mapping; </span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     318 </span>            :   }
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :   return mapping;</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 : }</span>
<a name="321"><span class="lineNum">     321 </span>            : </a>
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            : int AliHLTTPCHWCFSupport::CreateRawEvent
<span class="lineNum">     324 </span>            : ( const AliHLTComponentBlockData* block, 
<span class="lineNum">     325 </span>            :   const AliHLTUInt32_t *&amp;rawEvent, AliHLTUInt32_t &amp;rawEventSize32, 
<span class="lineNum">     326 </span>            :   const AliHLTTPCClusterMCLabel *&amp;mcLabels,  AliHLTUInt32_t &amp;nMCLabels 
<span class="lineNum">     327 </span>            : )
<span class="lineNum">     328 </span>            : {
<span class="lineNum">     329 </span>            :   // the method creates TPC raw data out of the input block
<span class="lineNum">     330 </span>            :   // MC labels are provided if possible  
<span class="lineNum">     331 </span>            :   //
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :   ReleaseEventMemory();</span>
<span class="lineNum">     334 </span>            :   
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :   rawEvent = 0;</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :   rawEventSize32 = 0;</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :   mcLabels = 0;</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :   nMCLabels = 0;</span>
<span class="lineNum">     339 </span>            :       
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :   if( block-&gt;fPtr==NULL ){</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :     HLTWarning(&quot;NULL pointer to the data block&quot;);</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     343 </span>            :   }
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :   Int_t slice = AliHLTTPCDefinitions::GetMinSliceNr( *block );</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :   Int_t patch = AliHLTTPCDefinitions::GetMinPatchNr( *block );</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :   AliHLTTPCMapping mapping(patch);</span>
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :   const char *str=Form(&quot;slice %d patch %d:&quot;, slice, patch);</span>
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :   if ( block-&gt;fDataType == (kAliHLTDataTypeDDLRaw | kAliHLTDataOriginTPC) )</span>
<span class="lineNum">     352 </span>            :     {    
<span class="lineNum">     353 </span>            :       // already raw format -&gt; only set the pointers and estimate the size
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span>            :       // read CDH header, estimate size of the data 
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :       AliHLTCDHWrapper cdhHeader(block-&gt;fPtr);</span>
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :       AliHLTUInt64_t headerSize = cdhHeader.GetHeaderSize();</span>
<span class="lineNum">     359 </span>            :  
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :       AliHLTUInt64_t blockSize = block-&gt;fSize; // size of the raw data in bytes      </span>
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :       if( cdhHeader.GetDataSize()!=0xFFFFFFFF ){ // use size information from the header</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :         blockSize = cdhHeader.GetDataSize();</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :         if( blockSize &gt; block-&gt;fSize ){</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :           HLTWarning(&quot;%s Could not find a valid DDL header!&quot;,str);</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :           return 0;</span>
<span class="lineNum">     367 </span>            :         }
<span class="lineNum">     368 </span>            :       }
<span class="lineNum">     369 </span>            :       
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :       if( blockSize &lt; headerSize ){</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :         HLTWarning(&quot;%s Buffer size is smaller than CDH header size&quot;, str);</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     373 </span>            :       }
<span class="lineNum">     374 </span>            :       
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :       rawEvent = reinterpret_cast&lt;AliHLTUInt32_t*&gt; (reinterpret_cast&lt;UChar_t*&gt;(block-&gt;fPtr)+headerSize);</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :       rawEventSize32 = ( blockSize - headerSize )/sizeof(AliHLTUInt32_t);</span>
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :   else if ( block-&gt;fDataType == AliHLTTPCDefinitions::fgkUnpackedRawDataType )</span>
<span class="lineNum">     380 </span>            :     {
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :       AliHLTTPCDigitReaderUnpacked digitReader;          </span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :       digitReader.SetUnsorted(kTRUE);      </span>
<span class="lineNum">     384 </span>            :       
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :       if( digitReader.InitBlock(block-&gt;fPtr,block-&gt;fSize,patch,slice)&lt;0 ) {</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :         HLTWarning(&quot;failed setting up digit reader (InitBlock)&quot;);</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     388 </span>            :       }
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span>            :       int nDigitsTotal = 0;
<span class="lineNum">     391 </span>            :       int nBunchesTotal = 0;
<span class="lineNum">     392 </span>            :      
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :       while( digitReader.NextChannel() ){</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :         while(digitReader.NextBunch()){</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :           nBunchesTotal++;</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :           nDigitsTotal+=digitReader.GetBunchSize();</span>
<span class="lineNum">     397 </span>            :         }
<span class="lineNum">     398 </span>            :       }
<span class="lineNum">     399 </span>            :       
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :       digitReader.Reset();</span>
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :       if( digitReader.InitBlock(block-&gt;fPtr,block-&gt;fSize,patch,slice)&lt;0) {</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :         HLTWarning(&quot;failed setting up digit reader (InitBlock)&quot;);</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     405 </span>            :       }
<span class="lineNum">     406 </span>            :       
<span class="lineNum">     407 </span>            :       Int_t nPadsTotal = 0;
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :       Int_t firstRow = AliHLTTPCGeometry::GetFirstRow(patch);</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :       Int_t nRows = AliHLTTPCGeometry::GetNRows(patch);</span>
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :       for( int i=0; i&lt;nRows; i++ ){</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :         nPadsTotal += AliHLTTPCGeometry::GetNPads(firstRow+i);  </span>
<span class="lineNum">     413 </span>            :       }
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :       AliHLTUInt32_t totalSize32 = (nDigitsTotal + nBunchesTotal*2)/3+2*nPadsTotal + 10;</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :       AliHLTUInt32_t totalNMC = nDigitsTotal + 10;</span>
<span class="lineNum">     417 </span>            :       
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :       fEventMemory = new AliHLTUInt32_t[totalSize32];</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :       if( !fEventMemory ){</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :         HLTWarning(&quot;Not enougth memory: can not allocate %d bytes&quot;,totalSize32*8);</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     422 </span>            :       }
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :       fEventMCMemory = new AliHLTTPCClusterMCLabel[totalNMC];</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :       if( !fEventMCMemory ){</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :         HLTWarning(&quot;Not enougth memory: can not allocate %d bytes&quot;,totalNMC*sizeof(AliHLTTPCClusterMCLabel));</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :         delete[] fEventMemory;</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :         fEventMemory = 0;</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     430 </span>            :       }
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :       AliHLTUInt32_t nWords32 = 0;</span>
<span class="lineNum">     433 </span>            :       AliHLTUInt32_t mcIndex = 0;
<span class="lineNum">     434 </span>            :       int err=0;
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :       AliHLTTPCDigitData tmpDigit;</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :       tmpDigit.fTrackID[0] = -1;</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :       tmpDigit.fTrackID[1] = -1;</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :       tmpDigit.fTrackID[2] = -1;</span>
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :       while( !err &amp;&amp; digitReader.NextChannel() ){</span>
<span class="lineNum">     442 </span>            :         
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :         Int_t row=digitReader.GetRow();</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :         Int_t pad=digitReader.GetPad();</span>
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :         AliHLTUInt32_t hwAddr = mapping.GetHwAddress(row, pad);</span>
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span>            :         // create header
<span class="lineNum">     449 </span>            : 
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :         if( nWords32 &gt;= totalSize32){ err = 1; break; }      </span>
<span class="lineNum">     451 </span>            :         
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :         AliHLTUInt32_t *header = fEventMemory + nWords32;</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :         nWords32++;</span>
<span class="lineNum">     454 </span>            : 
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :         int seek10 = 2;</span>
<span class="lineNum">     456 </span>            :         int prevTime = 10000000;
<span class="lineNum">     457 </span>            :         int nWords10 = 0;
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :         while(digitReader.NextBunch()){</span>
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :           if( hwAddr &gt; 0xFFF ) continue;</span>
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :           Int_t nSignals = digitReader.GetBunchSize();</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :           if( nSignals &lt;=0 ){</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :             HLTWarning(&quot;Empty bunch received&quot;);</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     466 </span>            :           }
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :           Int_t time = digitReader.GetTime() + nSignals-1;</span>
<span class="lineNum">     469 </span>            :           
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :           if( time-nSignals+1&lt;0 || time&gt;=AliHLTTPCGeometry::GetNTimeBins() ){</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :             HLTWarning(&quot;Wrong time bins received: %d-%d for row %d pad %d&quot;, time-nSignals+1, time, row, pad);</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     473 </span>            :           }
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :           if( time &gt;= prevTime ){</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :             HLTWarning(&quot;Unexpected order of TPC bunches in row %d, pad %d&quot;, row, pad);            </span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     478 </span>            :           }
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            :           prevTime = time-nSignals+1;
<span class="lineNum">     481 </span>            :           
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :           if( nWords32+( 2+nSignals)/3+1 &gt;= totalSize32 ){ err = 1; break; }</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :           if( mcIndex + nSignals   &gt;= totalNMC ){ err = 1; break; }</span>
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :           if( nWords10 + 2 + nSignals &gt; 0x3FF ){</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :             HLTWarning(&quot;Too much data in row %d, pad %d&quot;, row, pad);      </span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     488 </span>            :           }
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :           nWords10 += 2 + nSignals;</span>
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :           Add10Word( nWords32, seek10, nSignals + 2 );</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :           Add10Word( nWords32, seek10, time );</span>
<span class="lineNum">     494 </span>            :           
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :           const UInt_t *bunchData = digitReader.GetSignals();</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :           const AliHLTTPCDigitData *mcDigits = digitReader.GetBunchDigits();</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :           if( !mcDigits ){</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :             HLTWarning(&quot;No MC labels found for a bunch of digits&quot;);</span>
<span class="lineNum">     499 </span>            :           }
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :           for(Int_t is=nSignals-1; is&gt;=0; is--){</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :             Add10Word( nWords32, seek10, bunchData[is] );           </span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :             const AliHLTTPCDigitData &amp;digit = mcDigits ?mcDigits[is] :tmpDigit;</span>
<span class="lineNum">     504 </span>            :             int nmc = 0;
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :             for( int i=0; i&lt;3; i++ ) if( digit.fTrackID[i] &gt;=0 ) nmc++;      </span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :             for( int i=0; i&lt;3; i++ ){</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :               fEventMCMemory[mcIndex].fClusterID[i].fMCID = digit.fTrackID[i];</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :               fEventMCMemory[mcIndex].fClusterID[i].fWeight = 0;</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :               if( digit.fTrackID[i] &gt;=0 ){                   </span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :                 fEventMCMemory[mcIndex].fClusterID[i].fWeight  = ((float)bunchData[is])/nmc;</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :               }</span>
<span class="lineNum">     512 </span>            :             }     
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :             mcIndex++;</span>
<span class="lineNum">     514 </span>            :           }       
<span class="lineNum">     515 </span>            : 
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :         } // bunches</span>
<span class="lineNum">     517 </span>            :         
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :       *header = (1&lt;&lt;30) | ((nWords10&amp;0x3FF)&lt;&lt;16) | (hwAddr &amp; 0xFFF);</span>
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :       }// channels (pads)</span>
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :       if( err ){</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :         HLTError(&quot;Internal error: too less memory allocated&quot;);        </span>
<span class="lineNum">     524 </span>            :       } else {
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :         for( AliHLTUInt32_t i=0; i&lt;nWords32; i++ ) fEventMemory[i] = AliHLTTPCHWCFEmulator::WriteBigEndian(fEventMemory[i]);</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :         rawEvent = fEventMemory;</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :         rawEventSize32 = nWords32;</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :         mcLabels = fEventMCMemory;</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :         nMCLabels = mcIndex;</span>
<span class="lineNum">     530 </span>            :       }
<span class="lineNum">     531 </span>            : 
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :     } // unpacked data type</span>
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 : }</span>
<a name="536"><span class="lineNum">     536 </span>            : </a>
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span>            : void AliHLTTPCHWCFSupport::Add10Word( AliHLTUInt32_t &amp;nWords32, int &amp;seek10, UInt_t data )
<span class="lineNum">     539 </span>            : {
<span class="lineNum">     540 </span>            :   // add 10-bit data to the 32-bit word
<span class="lineNum">     541 </span>            :   // fEventMemory [nWords32] --- current 32-bit word
<span class="lineNum">     542 </span>            :   // *seek10 --- 10-bit position withing the word
<span class="lineNum">     543 </span>            :   // pointers are increased, a new word is first initialised to 0
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :   data = data &amp; 0x3FF; // truncate to 10 bits</span>
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :   if( seek10 == 2 ){</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :     nWords32++;</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :     fEventMemory[nWords32-1] = data&lt;&lt;20;</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :     seek10 = 1;</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :   } else if( seek10 == 1 ){</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :     fEventMemory[nWords32-1] &amp;= 0xFFF003FF;</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :     fEventMemory[nWords32-1] |= (data&lt;&lt;10);</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :     seek10 = 0;</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :   } else if( seek10 == 0 ){</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :     fEventMemory[nWords32-1] &amp;= 0xFFFFFC00;</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :     fEventMemory[nWords32-1] |= data;</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :     seek10 = 2;</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :   } </span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     561 </span>            : 
<a name="562"><span class="lineNum">     562 </span>            : </a>
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span>            : int AliHLTTPCHWCFSupport::CheckRawData( const AliHLTUInt32_t *buffer,
<span class="lineNum">     565 </span>            :                                                    unsigned long bufferSize32, int patch, int slice )
<span class="lineNum">     566 </span>            : {
<span class="lineNum">     567 </span>            :   //
<span class="lineNum">     568 </span>            :   // The procedure checks consistency of the data
<span class="lineNum">     569 </span>            :   //
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :   if (!buffer) return 0;</span>
<span class="lineNum">     573 </span>            : 
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :   AliHLTCDHWrapper cdh((void*)buffer);</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :   const unsigned int headerSize32 = cdh.GetHeaderSize()/4;</span>
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :   const char *str=Form(&quot;slice %d patch %d:&quot;, slice, patch);</span>
<span class="lineNum">     578 </span>            :   
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :   if( bufferSize32 &lt; headerSize32 ){</span>
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :     HLTWarning(&quot;%s Buffer size is smaller than CDH header size&quot;, str);</span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">     582 </span>            :   }    
<span class="lineNum">     583 </span>            :   
<span class="lineNum">     584 </span>            :   // read data header 
<span class="lineNum">     585 </span>            :  
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :   AliHLTUInt32_t blockSize32 = bufferSize32; // size of the raw data in words</span>
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :   if( buffer[0]!=0xFFFFFFFF ) blockSize32 = buffer[0]/4; // use size information from the header  </span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :   if( blockSize32 &gt; bufferSize32 ){  </span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :     HLTWarning(Form(&quot;%s Could not find a valid DDL header!&quot;,str));</span>
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     592 </span>            :   }
<span class="lineNum">     593 </span>            :   
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :   UChar_t rcuVer = (UChar_t)( (buffer[1] &gt;&gt; 24) &amp; 0xFF ); </span>
<span class="lineNum">     595 </span>            : 
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :   if (rcuVer &lt; 2) {</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :     HLTWarning(&quot;%s Old data format, RCU version %d&quot;, str,rcuVer);</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     599 </span>            :   }
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span>            :   // is the block valid
<span class="lineNum">     602 </span>            :   //AliHLTUInt32_t blockAttributes = buffer[3]; // block attributes (bits 24-31) and participating sub detectors 
<span class="lineNum">     603 </span>            :   //cout&lt;&lt;blockAttributes&lt;&lt;&quot; &quot;&lt;&lt;(blockAttributes &gt;&gt; 24)&lt;&lt;endl;
<span class="lineNum">     604 </span>            :   //if ( !( (blockAttributes &gt;&gt; 24) &amp; 1) ) return 0; 
<span class="lineNum">     605 </span>            :      
<span class="lineNum">     606 </span>            : 
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :   const AliHLTUInt32_t* fData = buffer + headerSize32;</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :   unsigned long  dataSize32 = blockSize32 - headerSize32;       </span>
<span class="lineNum">     609 </span>            :   
<span class="lineNum">     610 </span>            :   // Read the RCU trailer according to the RCU formware version specified in CDH
<span class="lineNum">     611 </span>            :   // Cross-check with version found in the trailer
<span class="lineNum">     612 </span>            :   // The two major bit should be 11 (identifies the end of the trailer)    
<span class="lineNum">     613 </span>            :   
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :   AliHLTUInt32_t word = fData[dataSize32 - 1];</span>
<span class="lineNum">     615 </span>            :   
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :   if ((word &gt;&gt; 30) != 3) {</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :     HLTWarning(&quot;%s Last RCU trailer word not found!&quot;, str);</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     619 </span>            :   }
<span class="lineNum">     620 </span>            :   
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :   UChar_t ver = (word &gt;&gt; 16) &amp; 0xFF;</span>
<span class="lineNum">     622 </span>            :   //AliHLTUInt32_t rcuId = (Int_t)((word &gt;&gt; 7) &amp; 0x1FF);
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :   AliHLTUInt32_t rcuTrailerSize32 = (word &amp; 0x7F); // size of RCU trailer data in words</span>
<span class="lineNum">     624 </span>            :   
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :   if (ver != rcuVer) {</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :     HLTWarning(&quot;%s Wrong RCU firmware version detected: %d != %d&quot;,</span>
<span class="lineNum">     627 </span>            :                str,ver,rcuVer);
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     629 </span>            :   }  
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :   if (rcuTrailerSize32 &lt; 2) {</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :     HLTWarning(Form(&quot;Invalid trailer size found (%d bytes) !&quot;,</span>
<span class="lineNum">     633 </span>            :                     rcuTrailerSize32*4));
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     635 </span>            :   }
<span class="lineNum">     636 </span>            :   
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :   if( rcuTrailerSize32 &gt; dataSize32 ){</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :     HLTWarning(Form(&quot;%s Invalid trailer size found (%d bytes) ! The size is bigger than the raw data size (%ld bytes)!&quot;,</span>
<span class="lineNum">     639 </span>            :                     str, rcuTrailerSize32*4,dataSize32*4));
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :     return 0;    </span>
<span class="lineNum">     641 </span>            :   }
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span>            :   // check the trailer
<span class="lineNum">     644 </span>            : 
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :   Int_t trailerIndex = dataSize32 - rcuTrailerSize32;</span>
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :   for( unsigned int i=trailerIndex; i&lt;dataSize32-1; i++){</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :     if ((fData[i] &gt;&gt; 30) != 2) {</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :       HLTWarning(&quot;%s Missing RCU trailer identifier pattern!&quot;,str);</span>
<span class="lineNum">     650 </span>            :       continue;
<span class="lineNum">     651 </span>            :     }
<span class="lineNum">     652 </span>            :   }
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span>            :   // Read the payload size  
<span class="lineNum">     655 </span>            :  
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :   Int_t  rcuPayloadSize32 = fData[trailerIndex] &amp; 0x3FFFFFF;</span>
<span class="lineNum">     657 </span>            : 
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :   if ( rcuPayloadSize32 + rcuTrailerSize32  != dataSize32) {</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :     HLTWarning(Form(&quot;%s Inconsistent raw data size ! Raw data size - %ld bytes (from CDH), RCU trailer - %d bytes, raw data size (from RCU trailer) - %d bytes !&quot;,</span>
<span class="lineNum">     660 </span>            :                     str, dataSize32*4,
<span class="lineNum">     661 </span>            :                     (rcuTrailerSize32)*4,
<span class="lineNum">     662 </span>            :                     rcuPayloadSize32*4));
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     664 </span>            :   }
<span class="lineNum">     665 </span>            :     
<span class="lineNum">     666 </span>            :   
<span class="lineNum">     667 </span>            :   //AliHLTTPCMapping *mapping = new AliHLTTPCMapping(patch);
<span class="lineNum">     668 </span>            :   const int kMaxNTimeBins = 2000;
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :   UShort_t  *channelData10 = new UShort_t[kMaxNTimeBins];    // cache for the decoded altro payload</span>
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span>            :   Int_t position = 0; // current position (32-bit words) in fData
<span class="lineNum">     673 </span>            :  
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :   while(1){</span>
<span class="lineNum">     675 </span>            : 
<span class="lineNum">     676 </span>            :     // Search for the next Altro channel
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span>            :     word = 0;
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :     while( position &lt; rcuPayloadSize32 ){</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :       word = fData[position++];</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :       if( (word &gt;&gt; 30) == 1) break;</span>
<span class="lineNum">     682 </span>            :     }
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :     if (position &gt;= rcuPayloadSize32 ) break; // no next channel found</span>
<span class="lineNum">     684 </span>            :     
<span class="lineNum">     685 </span>            :     // extract channel payload and hw address
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :     Int_t channelPayloadSize10 = (word &gt;&gt; 16) &amp; 0x3FF; // payload size in 10-bit words </span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :     Int_t channelPayloadSize32 = (channelPayloadSize10+2)/3;</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :     Bool_t channelIOErrors = (word &gt;&gt; 29) &amp; 0x1; // check for readout errors    </span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :     Short_t  channelHWAddress = word &amp; 0xFFF;</span>
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :     if( position + channelPayloadSize32-1&gt; rcuPayloadSize32 ){</span>
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :       HLTWarning(Form(&quot;%s Inconsistent channel payload data size: expected &lt;= %d bytes from RCU trailer, found %d bytes in the channel header!&quot;,</span>
<span class="lineNum">     694 </span>            :                       str,(rcuPayloadSize32 - position)*4, channelPayloadSize32*4 ));
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">     696 </span>            :     }
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span>            :     //bool channelBranchAB = ((channelHWAddress &gt;&gt; 11) &amp; 0x1);
<span class="lineNum">     699 </span>            :     // int channelFEC       = ((channelHWAddress &gt;&gt; 7) &amp; 0xF); // front-end card index
<span class="lineNum">     700 </span>            :     //int channelAltro = ((channelHWAddress &gt;&gt; 4) &amp; 0x7); // altro chip index
<span class="lineNum">     701 </span>            :     //int channelIndex = (channelHWAddress &amp; 0xF); // channel index
<span class="lineNum">     702 </span>            :     //int channelRow = mapping-&gt;GetRow(channelHWAddress);
<span class="lineNum">     703 </span>            :     //int channelPad = mapping-&gt;GetPad(channelHWAddress);
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span>            :     // Now unpack the Altro data: 10-bit words to 16 bit-words    
<span class="lineNum">     706 </span>            :     
<span class="lineNum">     707 </span>            :     Int_t channelData10Index = 0;// current position in the payload
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :     for (Int_t iword = 0; iword &lt; channelPayloadSize32; iword++) {</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :       word = fData[position++];</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :       if ((word &gt;&gt; 30) != 0) {</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :         HLTWarning(Form(&quot;%s Unexpected end of payload in altro channel payload! Address=0x%x, word=0x%x&quot;,</span>
<span class="lineNum">     713 </span>            :                         str, channelHWAddress,word));
<span class="lineNum">     714 </span>            :         channelIOErrors = 1;
<span class="lineNum">     715 </span>            :         position--;
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     717 </span>            :       }
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :       channelData10[channelData10Index++] = (word &gt;&gt; 20) &amp; 0x3FF;</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :       channelData10[channelData10Index++] = (word &gt;&gt; 10) &amp; 0x3FF;</span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :       channelData10[channelData10Index++] = word &amp; 0x3FF;</span>
<span class="lineNum">     721 </span>            :     }
<span class="lineNum">     722 </span>            :   
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :     if ( channelIOErrors ) continue;    </span>
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span>            :     // read bunches
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span>            :     Int_t prevTimeBin =  1024;
<span class="lineNum">     728 </span>            :     channelData10Index = 0;
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :     while(1){</span>
<span class="lineNum">     731 </span>            :       
<span class="lineNum">     732 </span>            :       // Read next Altro bunch 
<span class="lineNum">     733 </span>            :   
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :       if ((channelData10Index+1 &gt;= channelPayloadSize10) ) break;</span>
<span class="lineNum">     735 </span>            :     
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :       Int_t bunchLength = channelData10[channelData10Index++];</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :       Int_t bunchStartTimeBin = channelData10[channelData10Index++];</span>
<span class="lineNum">     738 </span>            : 
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :       if (bunchLength &lt;= 2) {</span>
<span class="lineNum">     740 </span>            :         // Invalid bunch size
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :         HLTWarning(Form(&quot;%s Too short bunch length (%d) in Address=0x%x!&quot;,</span>
<span class="lineNum">     742 </span>            :                         str, bunchLength,channelHWAddress));    
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     744 </span>            :       }
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :       if( channelData10Index + bunchLength - 2 &gt; channelPayloadSize10 ){</span>
<span class="lineNum">     746 </span>            :         // Too long bunch detected
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :         HLTWarning(Form(&quot;%s Too long bunch detected in Address=0x%x! Expected &lt;= %d 10-bit words, found %d !&quot;,</span>
<span class="lineNum">     748 </span>            :                         str,channelHWAddress,channelPayloadSize10-channelData10Index,bunchLength));
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     750 </span>            :       }
<span class="lineNum">     751 </span>            :             
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :       if( bunchStartTimeBin-bunchLength+1 &lt; 0) {</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :         HLTWarning(Form(&quot;%s Invalid start time-bin in Address=0x%x ! (%d-%d+1) &lt; 0&quot;,</span>
<span class="lineNum">     754 </span>            :                         str,channelHWAddress,bunchStartTimeBin,bunchLength));
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     756 </span>            :       }
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :       if (bunchStartTimeBin &gt;= prevTimeBin) {</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :         HLTWarning(Form(&quot;%s Invalid start time-bin in Address=0x%x! (%d&gt;=%d)&quot;,</span>
<span class="lineNum">     759 </span>            :                         str,channelHWAddress,bunchStartTimeBin,prevTimeBin));
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     761 </span>            :       }
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span>            :       prevTimeBin = bunchStartTimeBin-bunchLength+1;
<span class="lineNum">     764 </span>            :   
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :       bunchLength -= 2;</span>
<span class="lineNum">     766 </span>            :         
<span class="lineNum">     767 </span>            :       //UShort_t* bunchData = &amp;channelData10[channelData10Index];   // pointer to the current bunch samples
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :       channelData10Index += bunchLength;            </span>
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     771 </span>            :   
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :   delete[] channelData10;</span>
<span class="lineNum">     773 </span>            :   //delete mapping;
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span>            :   return 1;
<span class="lineNum">     776 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     777 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
