<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - HLT/BASE/AliHLTComponent.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">HLT/BASE</a> - AliHLTComponent.h<span style="font-size: 80%;"> (source / <a href="AliHLTComponent.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">12</td>
            <td class="headerCovTableEntryLo">8.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">14</td>
            <td class="headerCovTableEntryLo">7.1 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : //-*- Mode: C++ -*-</a>
<span class="lineNum">       2 </span>            : // $Id$
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : #ifndef ALIHLTCOMPONENT_H
<span class="lineNum">       5 </span>            : #define ALIHLTCOMPONENT_H
<span class="lineNum">       6 </span>            : //* This file is property of and copyright by the ALICE HLT Project        * 
<span class="lineNum">       7 </span>            : //* ALICE Experiment at CERN, All rights reserved.                         *
<span class="lineNum">       8 </span>            : //* See cxx source for full Copyright notice                               *
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : //  @file   AliHLTComponent.h
<span class="lineNum">      11 </span>            : //  @author Matthias Richter, Timm Steinbeck
<span class="lineNum">      12 </span>            : //  @date   
<span class="lineNum">      13 </span>            : //  @brief  Base class declaration for HLT components. 
<span class="lineNum">      14 </span>            : //  @note   The class is both used in Online (PubSub) and Offline (AliRoot)
<span class="lineNum">      15 </span>            : //          context
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : /**
<span class="lineNum">      19 </span>            :  * @defgroup alihlt_component Component handling of the HLT module
<span class="lineNum">      20 </span>            :  * This section describes the the component base classes and handling for
<span class="lineNum">      21 </span>            :  * the HLT module.
<span class="lineNum">      22 </span>            :  *
<span class="lineNum">      23 </span>            :  * @section alihlt_component_intro General remarks
<span class="lineNum">      24 </span>            :  * HLT analysis is organized in so called components. Each component can
<span class="lineNum">      25 </span>            :  * subscribe to the data produced by other components and can from the
<span class="lineNum">      26 </span>            :  * analysis publish new data for the subsequent components. Only the
<span class="lineNum">      27 </span>            :  * input data blocks and entries from CDB are available for the analysis. 
<span class="lineNum">      28 </span>            :  *
<span class="lineNum">      29 </span>            :  * @section alihlt_component_implementation Component implementation
<span class="lineNum">      30 </span>            :  * AliHLTComponent provides the interface for all components, see there
<span class="lineNum">      31 </span>            :  * for details. Three types are provided:
<span class="lineNum">      32 </span>            :  * - AliHLTProcessor
<span class="lineNum">      33 </span>            :  * - AliHLTDataSource
<span class="lineNum">      34 </span>            :  * - AliHLTDataSink
<span class="lineNum">      35 </span>            :  *
<span class="lineNum">      36 </span>            :  * The two last represent data sinks and sources for the HLT integration
<span class="lineNum">      37 </span>            :  * into AliRoot. When running only, only the processors are relevant,
<span class="lineNum">      38 </span>            :  * sources and sinks are provided by the HLT PubSub framework. Please check
<span class="lineNum">      39 </span>            :  * AliHLTComponent for detailed description.
<span class="lineNum">      40 </span>            :  *
<span class="lineNum">      41 </span>            :  * @section alihlt_component_registration Component registration
<span class="lineNum">      42 </span>            :  * Components need to be registered with the AliHLTComponentHandler in
<span class="lineNum">      43 </span>            :  * order to be used with the system. Registration is purely done from the
<span class="lineNum">      44 </span>            :  * module library. Two methods are possible:
<span class="lineNum">      45 </span>            :  * - the module library implements an AliHLTModuleAgent and overloads the
<span class="lineNum">      46 </span>            :  *   AliHLTModuleAgent::RegisterComponents() function
<span class="lineNum">      47 </span>            :  * - in the implementation file, one object is defined. The global object is
<span class="lineNum">      48 </span>            :  *   automatically instantiated when the library is loaded for the first
<span class="lineNum">      49 </span>            :  *   time and the object is used for registration.
<span class="lineNum">      50 </span>            :  *
<span class="lineNum">      51 </span>            :  * In both cases, the library must be loaded via the method
<span class="lineNum">      52 </span>            :  * &lt;pre&gt;
<span class="lineNum">      53 </span>            :  *  AliHLTComponentHandler::LoadComponentLibraries()
<span class="lineNum">      54 </span>            :  * &lt;/pre&gt;
<span class="lineNum">      55 </span>            :  * For the global object approach it is important that the library is
<span class="lineNum">      56 </span>            :  * not loaded elsewhere before (e.g. a gSystem-&gt;Load operation in your
<span class="lineNum">      57 </span>            :  * rootlogon.C).
<span class="lineNum">      58 </span>            :  *
<span class="lineNum">      59 </span>            :  *
<span class="lineNum">      60 </span>            :  */
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            : #include &lt;vector&gt;
<span class="lineNum">      63 </span>            : #include &lt;string&gt;
<span class="lineNum">      64 </span>            : #include &lt;map&gt;
<span class="lineNum">      65 </span>            : #include &quot;AliHLTLogging.h&quot;
<span class="lineNum">      66 </span>            : #include &quot;AliHLTDataTypes.h&quot;
<span class="lineNum">      67 </span>            : #include &quot;AliHLTCommonCDBEntries.h&quot;
<span class="lineNum">      68 </span>            : #include &quot;TList.h&quot;
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            : /* Matthias Dec 2006
<span class="lineNum">      71 </span>            :  * The names have been changed for Aliroot's coding conventions sake
<span class="lineNum">      72 </span>            :  * The old names are defined for backward compatibility with the 
<span class="lineNum">      73 </span>            :  * stand alone SampleLib package
<span class="lineNum">      74 </span>            :  */
<span class="lineNum">      75 </span>            : typedef AliHLTComponentLogSeverity AliHLTComponent_LogSeverity;
<span class="lineNum">      76 </span>            : typedef AliHLTComponentEventData AliHLTComponent_EventData;
<span class="lineNum">      77 </span>            : typedef AliHLTComponentShmData AliHLTComponent_ShmData;
<span class="lineNum">      78 </span>            : typedef AliHLTComponentDataType AliHLTComponent_DataType;
<span class="lineNum">      79 </span>            : typedef AliHLTComponentBlockData AliHLTComponent_BlockData;
<span class="lineNum">      80 </span>            : typedef AliHLTComponentTriggerData AliHLTComponent_TriggerData;
<span class="lineNum">      81 </span>            : typedef AliHLTComponentEventDoneData AliHLTComponent_EventDoneData;
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span>            : class AliHLTComponentHandler;
<span class="lineNum">      84 </span>            : class TObjArray;
<span class="lineNum">      85 </span>            : class TMap;
<span class="lineNum">      86 </span>            : class TStopwatch;
<span class="lineNum">      87 </span>            : class TUUID;
<span class="lineNum">      88 </span>            : class AliHLTComponent;
<span class="lineNum">      89 </span>            : class AliHLTMemoryFile;
<span class="lineNum">      90 </span>            : class AliHLTCTPData;
<span class="lineNum">      91 </span>            : class AliHLTReadoutList;
<span class="lineNum">      92 </span>            : class AliHLTCDHWrapper;
<span class="lineNum">      93 </span>            : class TStreamerInfo;
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span>            : using std::vector;
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            : /** list of component data type structures */
<span class="lineNum">      98 </span>            : typedef vector&lt;AliHLTComponentDataType&gt;   AliHLTComponentDataTypeList;
<span class="lineNum">      99 </span>            : /** list of component block data structures */
<span class="lineNum">     100 </span>            : typedef vector&lt;AliHLTComponentBlockData&gt;  AliHLTComponentBlockDataList;
<span class="lineNum">     101 </span>            : /** list of component statistics struct */
<span class="lineNum">     102 </span>            : typedef vector&lt;AliHLTComponentStatistics&gt; AliHLTComponentStatisticsList;
<span class="lineNum">     103 </span>            : /** list of component pointers */
<span class="lineNum">     104 </span>            : typedef vector&lt;AliHLTComponent*&gt;          AliHLTComponentPList;
<span class="lineNum">     105 </span>            : /** list of memory file pointers */
<span class="lineNum">     106 </span>            : typedef vector&lt;AliHLTMemoryFile*&gt;         AliHLTMemoryFilePList;
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span>            : /**
<span class="lineNum">     109 </span>            :  * @class AliHLTComponent
<span class="lineNum">     110 </span>            :  * Base class of HLT data processing components.
<span class="lineNum">     111 </span>            :  * The class provides a common interface for HLT data processing components.
<span class="lineNum">     112 </span>            :  * The interface can be accessed from the online HLT framework or the AliRoot
<span class="lineNum">     113 </span>            :  * offline analysis framework.
<span class="lineNum">     114 </span>            :  * @section alihltcomponent-properties Component identification and properties
<span class="lineNum">     115 </span>            :  * Each component must provide a unique ID, input and output data type indications,
<span class="lineNum">     116 </span>            :  * and a spawn function.
<span class="lineNum">     117 </span>            :  * @subsection alihltcomponent-req-methods Required property methods
<span class="lineNum">     118 </span>            :  * - @ref GetComponentID
<span class="lineNum">     119 </span>            :  * - @ref GetInputDataTypes (see @ref alihltcomponent-type for default
<span class="lineNum">     120 </span>            :  *   implementations.)
<span class="lineNum">     121 </span>            :  * - @ref GetOutputDataType (see @ref alihltcomponent-type for default
<span class="lineNum">     122 </span>            :  *   implementations.)
<span class="lineNum">     123 </span>            :  * - @ref GetOutputDataSize (see @ref alihltcomponent-type for default
<span class="lineNum">     124 </span>            :  *   implementations.)
<span class="lineNum">     125 </span>            :  * - @ref Spawn
<span class="lineNum">     126 </span>            :  *
<span class="lineNum">     127 </span>            :  * @subsection alihltcomponent-opt-mehods Optional handlers
<span class="lineNum">     128 </span>            :  * - @ref DoInit
<span class="lineNum">     129 </span>            :  * - @ref DoDeinit
<span class="lineNum">     130 </span>            :  * - @ref GetOutputDataTypes
<span class="lineNum">     131 </span>            :  *   If the component has multiple output data types @ref GetOutputDataType
<span class="lineNum">     132 </span>            :  *   should return @ref kAliHLTMultipleDataType. The framework will invoke
<span class="lineNum">     133 </span>            :  *   @ref GetOutputDataTypes, a list can be filled.
<span class="lineNum">     134 </span>            :  * - @ref Reconfigure
<span class="lineNum">     135 </span>            :  *   This function is invoked by the framework on a special event which
<span class="lineNum">     136 </span>            :  *   triggers the reconfiguration of the component.
<span class="lineNum">     137 </span>            :  *
<span class="lineNum">     138 </span>            :  * @subsection alihltcomponent-processing-mehods Data processing
<span class="lineNum">     139 </span>            :  * 
<span class="lineNum">     140 </span>            :  * 
<span class="lineNum">     141 </span>            :  * @subsection alihltcomponent-type Component type
<span class="lineNum">     142 </span>            :  * Components can be of type
<span class="lineNum">     143 </span>            :  * - @ref kSource     components which only produce data 
<span class="lineNum">     144 </span>            :  * - @ref kProcessor  components which consume and produce data
<span class="lineNum">     145 </span>            :  * - @ref kSink       components which only consume data
<span class="lineNum">     146 </span>            :  *
<span class="lineNum">     147 </span>            :  * where data production and consumption refer to the analysis data stream. In
<span class="lineNum">     148 </span>            :  * order to indicate the type, a child component can overload the
<span class="lineNum">     149 </span>            :  * @ref GetComponentType function.
<span class="lineNum">     150 </span>            :  * @subsubsection alihltcomponent-type-std Standard implementations
<span class="lineNum">     151 </span>            :  * Components in general do not need to implement this function, standard
<span class="lineNum">     152 </span>            :  * implementations of the 3 types are available:
<span class="lineNum">     153 </span>            :  * - AliHLTDataSource for components of type @ref kSource &lt;br&gt;
<span class="lineNum">     154 </span>            :  *   All types of data sources can inherit from AliHLTDataSource and must
<span class="lineNum">     155 </span>            :  *   implement the @ref AliHLTDataSource::GetEvent method. The class
<span class="lineNum">     156 </span>            :  *   also implements a standard method for @ref GetInputDataTypes.
<span class="lineNum">     157 </span>            :  *   
<span class="lineNum">     158 </span>            :  * - AliHLTProcessor for components of type @ref kProcessor &lt;br&gt;
<span class="lineNum">     159 </span>            :  *   All types of data processors can inherit from AliHLTProcessor and must
<span class="lineNum">     160 </span>            :  *   implement the @ref AliHLTProcessor::DoEvent method.
<span class="lineNum">     161 </span>            :  *
<span class="lineNum">     162 </span>            :  * - AliHLTDataSink for components of type @ref kSink &lt;br&gt;
<span class="lineNum">     163 </span>            :  *   All types of data processors can inherit from AliHLTDataSink and must
<span class="lineNum">     164 </span>            :  *   implement the @ref AliHLTDataSink::DumpEvent method. The class
<span class="lineNum">     165 </span>            :  *   also implements a standard method for @ref GetOutputDataType and @ref
<span class="lineNum">     166 </span>            :  *   GetOutputDataSize.
<span class="lineNum">     167 </span>            :  *
<span class="lineNum">     168 </span>            :  * @subsection alihltcomponent-environment Running environment
<span class="lineNum">     169 </span>            :  *
<span class="lineNum">     170 </span>            :  * In order to adapt to different environments (on-line/off-line), the component
<span class="lineNum">     171 </span>            :  * gets an environment structure with function pointers. The base class provides
<span class="lineNum">     172 </span>            :  * member functions for those environment dependend functions. The member 
<span class="lineNum">     173 </span>            :  * functions are used by the component implementation and are re-mapped to the
<span class="lineNum">     174 </span>            :  * corresponding functions.
<span class="lineNum">     175 </span>            :  *
<span class="lineNum">     176 </span>            :  * @section alihltcomponent-interfaces Component interfaces
<span class="lineNum">     177 </span>            :  * Each of the 3 standard component base classes AliHLTProcessor, AliHLTDataSource
<span class="lineNum">     178 </span>            :  * and AliHLTDataSink provides it's own processing method (see
<span class="lineNum">     179 </span>            :  * @ref alihltcomponent-type-std), which splits into a high and a low-level
<span class="lineNum">     180 </span>            :  * method. For the @ref alihltcomponent-low-level-interface, all parameters are
<span class="lineNum">     181 </span>            :  * shipped as function arguments, the component is supposed to write data to the
<span class="lineNum">     182 </span>            :  * output buffer and handle all block descriptors. 
<span class="lineNum">     183 </span>            :  * The @ref alihltcomponent-high-level-interface is the standard processing
<span class="lineNum">     184 </span>            :  * method and will be used whenever the low-level method is not overloaded.
<span class="lineNum">     185 </span>            :  *
<span class="lineNum">     186 </span>            :  * In both cases it is necessary to calculate/estimate the size of the output
<span class="lineNum">     187 </span>            :  * buffer before the processing. Output buffers can never be allocated inside
<span class="lineNum">     188 </span>            :  * the component because of the push-architecture of the HLT.
<span class="lineNum">     189 </span>            :  * For that reason the @ref GetOutputDataSize function should return a rough
<span class="lineNum">     190 </span>            :  * estimatian of the data to be produced by the component. The component is
<span class="lineNum">     191 </span>            :  * responsible for checking the memory size and must return -ENOSPC if the
<span class="lineNum">     192 </span>            :  * available buffer is too small, and update the estimator respectively. The
<span class="lineNum">     193 </span>            :  * framework will allocate a buffer of appropriate size and call the processing
<span class="lineNum">     194 </span>            :  * again.
<span class="lineNum">     195 </span>            :  *
<span class="lineNum">     196 </span>            :  * @subsection alihltcomponent-error-codes Return values/Error codes
<span class="lineNum">     197 </span>            :  * For return codes, the following scheme applies:
<span class="lineNum">     198 </span>            :  * - The data processing methods have to indicate error conditions by a negative
<span class="lineNum">     199 </span>            :  * error/return code. Preferably the system error codes are used like
<span class="lineNum">     200 </span>            :  * e.g. -EINVAL. This requires to include the header
<span class="lineNum">     201 </span>            :  * &lt;pre&gt;
<span class="lineNum">     202 </span>            :  * \#include \&lt;cerrno\&gt;
<span class="lineNum">     203 </span>            :  * &lt;/pre&gt;
<span class="lineNum">     204 </span>            :  * This schema aplies to all interface functions of the component base class.
<span class="lineNum">     205 </span>            :  * For data processing it is as follows:
<span class="lineNum">     206 </span>            :  * - If no suitable input block could be found (e.g. no clusters for the TPC cluster
<span class="lineNum">     207 </span>            :  * finder) set size to 0, block list is empty, return 0
<span class="lineNum">     208 </span>            :  * - If no ususable or significant signal could be found in the input blocks
<span class="lineNum">     209 </span>            :  * return an empty output block, set size accordingly, and return 0. An empty output
<span class="lineNum">     210 </span>            :  * block here could be either a real empty one of size 0 (in which case size also
<span class="lineNum">     211 </span>            :  * would have to be set to zero) or a block filled with just the minimum necessary
<span class="lineNum">     212 </span>            :  * accounting/meta-structures. E.g. in the TPC
<span class="lineNum">     213 </span>            :  *
<span class="lineNum">     214 </span>            :  * @subsection alihltcomponent-high-level-interface High-level interface
<span class="lineNum">     215 </span>            :  * The high-level component interface provides functionality to exchange ROOT
<span class="lineNum">     216 </span>            :  * structures between components. In contrast to the 
<span class="lineNum">     217 </span>            :  * @ref alihltcomponent-low-level-interface, a couple of functions can be used
<span class="lineNum">     218 </span>            :  * to access data blocks of the input stream
<span class="lineNum">     219 </span>            :  * and send data blocks or ROOT TObject's to the output stream. The functionality
<span class="lineNum">     220 </span>            :  * is hidden from the user and is implemented by using ROOT's TMessage class.
<span class="lineNum">     221 </span>            :  *
<span class="lineNum">     222 </span>            :  * @subsubsection alihltcomponent-high-level-int-methods Interface methods
<span class="lineNum">     223 </span>            :  * The interface provides a couple of methods in order to get objects from the
<span class="lineNum">     224 </span>            :  * input, data blocks (non TObject) from the input, and to push back objects and
<span class="lineNum">     225 </span>            :  * data blocks to the output. For convenience there are several functions of 
<span class="lineNum">     226 </span>            :  * identical name (and similar behavior) with different parameters defined.
<span class="lineNum">     227 </span>            :  * Please refer to the function documentation.
<span class="lineNum">     228 </span>            :  * - @ref GetNumberOfInputBlocks &lt;br&gt;
<span class="lineNum">     229 </span>            :  *        return the number of data blocks in the input stream
<span class="lineNum">     230 </span>            :  * - @ref GetFirstInputObject &lt;br&gt;
<span class="lineNum">     231 </span>            :  *        get the first object of a specific data type
<span class="lineNum">     232 </span>            :  * - @ref GetNextInputObject &lt;br&gt;
<span class="lineNum">     233 </span>            :  *        get the next object of same data type as last GetFirstInputObject/Block call
<span class="lineNum">     234 </span>            :  * - @ref GetFirstInputBlock &lt;br&gt;
<span class="lineNum">     235 </span>            :  *        get the first block of a specific data type
<span class="lineNum">     236 </span>            :  * - @ref GetNextInputBlock &lt;br&gt;
<span class="lineNum">     237 </span>            :  *        get the next block of same data type as last GetFirstInputBlock/Block call
<span class="lineNum">     238 </span>            :  * - @ref PushBack &lt;br&gt;
<span class="lineNum">     239 </span>            :  *        insert an object or data buffer into the output
<span class="lineNum">     240 </span>            :  * - @ref CreateEventDoneData &lt;br&gt;
<span class="lineNum">     241 </span>            :  *        add event information to the output
<span class="lineNum">     242 </span>            :  * 
<span class="lineNum">     243 </span>            :  * In addition, the processing methods are simplified a bit by cutting out most of
<span class="lineNum">     244 </span>            :  * the parameters.
<span class="lineNum">     245 </span>            :  * @see 
<span class="lineNum">     246 </span>            :  * - @ref AliHLTProcessor::DoEvent
<span class="lineNum">     247 </span>            :  * - @ref AliHLTDataSource::GetEvent
<span class="lineNum">     248 </span>            :  * - @ref AliHLTDataSink::DumpEvent
<span class="lineNum">     249 </span>            :  *
<span class="lineNum">     250 </span>            :  * \em IMPORTANT: objects and block descriptors provided by the high-level interface
<span class="lineNum">     251 </span>            :  *  &lt;b&gt;MUST NOT BE DELETED&lt;/b&gt; by the caller.
<span class="lineNum">     252 </span>            :  *
<span class="lineNum">     253 </span>            :  * @subsubsection alihltcomponent-high-level-int-guidelines High-level interface guidelines
<span class="lineNum">     254 </span>            :  * - Structures must inherit from the ROOT object base class TObject in order be 
<span class="lineNum">     255 </span>            :  * transported by the transportation framework.
<span class="lineNum">     256 </span>            :  * - all pointer members must be transient (marked &lt;tt&gt;//!&lt;/tt&gt; behind the member
<span class="lineNum">     257 </span>            :  * definition), i.e. will not be stored/transported, or properly marked
<span class="lineNum">     258 </span>            :  * (&lt;tt&gt;//-&gt;&lt;/tt&gt;) in order to call the streamer of the object the member is pointing
<span class="lineNum">     259 </span>            :  * to. The latter is not recomended. Structures to be transported between components
<span class="lineNum">     260 </span>            :  * should be streamlined.
<span class="lineNum">     261 </span>            :  * - no use of stl vectors/strings, use appropriate ROOT classes instead 
<span class="lineNum">     262 </span>            :  * 
<span class="lineNum">     263 </span>            :  * @subsection alihltcomponent-low-level-interface Low-level interface
<span class="lineNum">     264 </span>            :  * The low-level component interface consists of the specific data processing
<span class="lineNum">     265 </span>            :  * methods for @ref AliHLTProcessor, @ref AliHLTDataSource, and @ref AliHLTDataSink.
<span class="lineNum">     266 </span>            :  * - @ref AliHLTProcessor::DoEvent
<span class="lineNum">     267 </span>            :  * - @ref AliHLTDataSource::GetEvent
<span class="lineNum">     268 </span>            :  * - @ref AliHLTDataSink::DumpEvent
<span class="lineNum">     269 </span>            :  * 
<span class="lineNum">     270 </span>            :  * The base class passes all relevant parameters for data access directly on to the
<span class="lineNum">     271 </span>            :  * component. Input blocks can be accessed by means of the array &lt;tt&gt; blocks &lt;/tt&gt;.
<span class="lineNum">     272 </span>            :  * Output data are written directly to shared memory provided by the pointer
<span class="lineNum">     273 </span>            :  * &lt;tt&gt; outputPtr &lt;/tt&gt; and output block descriptors are inserted directly to the
<span class="lineNum">     274 </span>            :  * list &lt;tt&gt; outputBlocks &lt;/tt&gt;.
<span class="lineNum">     275 </span>            :  *
<span class="lineNum">     276 </span>            :  * \b NOTE: The high-level input data access methods can be used also from the low
<span class="lineNum">     277 </span>            :  * level interface. Also the PushBack functions can be used BUT ONLY if no data is
<span class="lineNum">     278 </span>            :  * written to the output buffer and no data block descriptors are inserted into the
<span class="lineNum">     279 </span>            :  * output block list.
<span class="lineNum">     280 </span>            :  *
<span class="lineNum">     281 </span>            :  * @section alihltcomponent-initialization Component initialization and configuration
<span class="lineNum">     282 </span>            :  * The component interface provides two optional methods for component initialization
<span class="lineNum">     283 </span>            :  * and configuration. The @ref DoInit function is called once before the processing.
<span class="lineNum">     284 </span>            :  * During the event processing, a special event can trigger a reconfiguration and the
<span class="lineNum">     285 </span>            :  * @ref Reconfigure method is called. There are three possible options of initialization
<span class="lineNum">     286 </span>            :  * and configuration:
<span class="lineNum">     287 </span>            :  * - default values: set directly in the source code
<span class="lineNum">     288 </span>            :  * - OCDB objects: all necessary information must be loaded from OCDB objects. The
<span class="lineNum">     289 </span>            :  *   Offline Conditions Data Base stores objects specifically valid for individual runs
<span class="lineNum">     290 </span>            :  *   or run ranges.
<span class="lineNum">     291 </span>            :  * - Component arguments: can be specified for every component in the chain
<span class="lineNum">     292 </span>            :  *   configuration. The arguments can be used to override specific parameters of the
<span class="lineNum">     293 </span>            :  *   component.
<span class="lineNum">     294 </span>            :  *
<span class="lineNum">     295 </span>            :  * As a general rule, the three options should be processed in that sequence, i.e
<span class="lineNum">     296 </span>            :  * default parameters might be overridden by OCDB configuration, and the latter one
<span class="lineNum">     297 </span>            :  * by component arguments.
<span class="lineNum">     298 </span>            :  *
<span class="lineNum">     299 </span>            :  * @subsection alihltcomponent-initialization-arguments Component arguments
<span class="lineNum">     300 </span>            :  * In normal operation, components are supposed to run without any additional argument,
<span class="lineNum">     301 </span>            :  * however such arguments can be useful for testing and debugging. The idea follows
<span class="lineNum">     302 </span>            :  * the format of command line arguments. A keyword is indicated by a dash and an
<span class="lineNum">     303 </span>            :  * optional argument might follow, e.g.:
<span class="lineNum">     304 </span>            :  * &lt;pre&gt;
<span class="lineNum">     305 </span>            :  * -argument1 0.5 -argument2
<span class="lineNum">     306 </span>            :  * &lt;/pre&gt;
<span class="lineNum">     307 </span>            :  * In this case argument1 requires an additional parameter whereas argument2 does not.
<span class="lineNum">     308 </span>            :  * The arguments will be provided as an array of separated arguments.
<span class="lineNum">     309 </span>            :  *
<span class="lineNum">     310 </span>            :  * Component arguments can be classified into initialization arguments and configuration
<span class="lineNum">     311 </span>            :  * arguments. The latter are applicable for both the @ref DoInit and @ref Reconfigure
<span class="lineNum">     312 </span>            :  * method whereas initialization arguments are not applicable after DoInit.
<span class="lineNum">     313 </span>            :  *
<span class="lineNum">     314 </span>            :  * @subsection alihltcomponent-initialization-ocdb OCDB objects
<span class="lineNum">     315 </span>            :  * OCDB objects are ROOT &lt;tt&gt;TObjects&lt;/tt&gt; and can be of any type. This is in particular
<span class="lineNum">     316 </span>            :  * useful for complex parameter sets. However in most cases, a simple approach of human
<span class="lineNum">     317 </span>            :  * readable command line arguments is appropriate. Such a string can be simply stored
<span class="lineNum">     318 </span>            :  * in a TObjString (take note that the TString does not derive from TObject). The
<span class="lineNum">     319 </span>            :  * same arguments as for the command line can be used. Take note that in the TObjString
<span class="lineNum">     320 </span>            :  * all arguments are separated by blanks, instead of being in an array of separate
<span class="lineNum">     321 </span>            :  * strings.
<span class="lineNum">     322 </span>            :  *
<span class="lineNum">     323 </span>            :  * The base class provides two functions regarding OCDB objects: 
<span class="lineNum">     324 </span>            :  * - LoadAndExtractOCDBObject() loads the OCDB entry for the specified path and extracts
<span class="lineNum">     325 </span>            :  *                              the TObject from it. An optional key allows to access
<span class="lineNum">     326 </span>            :  *                              a TObject within a TMap
<span class="lineNum">     327 </span>            :  * - ConfigureFromCDBTObjString() can load a number of OCDB objects and calls the
<span class="lineNum">     328 </span>            :  *                              argument parsing ConfigureFromArgumentString
<span class="lineNum">     329 </span>            :  *
<span class="lineNum">     330 </span>            :  *
<span class="lineNum">     331 </span>            :  * @subsection alihltcomponent-initialization-sequence Initialization sequence
<span class="lineNum">     332 </span>            :  * Using the approach of &lt;tt&gt;TObjString&lt;/tt&gt;-type configuration objects allows to treat
<span class="lineNum">     333 </span>            :  * configuration from both @ref DoInit and @ref Reconfigure in the same way.
<span class="lineNum">     334 </span>            :  *
<span class="lineNum">     335 </span>            :  * The base class provides the function ConfigureFromArgumentString() which loops over
<span class="lineNum">     336 </span>            :  * all arguments and calls the child's method ScanConfigurationArgument(). Here the
<span class="lineNum">     337 </span>            :  * actual treatment of the argument and its parameters needs to be implemented.
<span class="lineNum">     338 </span>            :  * ConfigureFromArgumentString() can treat both arrays of arguments and arguments in
<span class="lineNum">     339 </span>            :  * one single string separated by blanks. The two options can be mixed.
<span class="lineNum">     340 </span>            :  *
<span class="lineNum">     341 </span>            :  * A second base class function ConfigureFromCDBTObjString() allows to configure
<span class="lineNum">     342 </span>            :  * directly from a number of OCDB objects. This requires the entries to be of
<span class="lineNum">     343 </span>            :  * type TObjString and the child implementation of ScanConfigurationArgument().
<span class="lineNum">     344 </span>            :  * The object can also be of type TMap with TObjStrings as key-value pairs. The
<span class="lineNum">     345 </span>            :  * key identifier can be chosen by the component implementation. Normally it will
<span class="lineNum">     346 </span>            :  * be the run type (&quot;p&quot;,&quot;A-A&quot;, &quot;p-A&quot;, ...) or e.g. the trigger code secified by
<span class="lineNum">     347 </span>            :  * ECS.
<span class="lineNum">     348 </span>            :  *
<span class="lineNum">     349 </span>            :  * @section alihltcomponent-handling Component handling 
<span class="lineNum">     350 </span>            :  * The handling of HLT analysis components is carried out by the AliHLTComponentHandler.
<span class="lineNum">     351 </span>            :  * Component are registered automatically at load-time of the component shared library
<span class="lineNum">     352 </span>            :  * under the following suppositions:
<span class="lineNum">     353 </span>            :  * - the component library has to be loaded from the AliHLTComponentHandler using the
<span class="lineNum">     354 </span>            :  *   @ref AliHLTComponentHandler::LoadLibrary method.
<span class="lineNum">     355 </span>            :  * - the library defines an AliHLTModuleAgent which registers all components.
<span class="lineNum">     356 </span>            :  *   See AliHLTModuleAgent::RegisterComponents                               &lt;br&gt;
<span class="lineNum">     357 </span>            :  *     or                                                                    &lt;br&gt;
<span class="lineNum">     358 </span>            :  * - the component implementation defines one global object (which is generated
<span class="lineNum">     359 </span>            :  *   when the library is loaded)                                             &lt;br&gt;
<span class="lineNum">     360 </span>            :  *
<span class="lineNum">     361 </span>            :  * @subsection alihltcomponent-design-rules General design considerations
<span class="lineNum">     362 </span>            :  * The analysis code should be implemented in one or more destict class(es). A 
<span class="lineNum">     363 </span>            :  * \em component should be implemented which interface the destict analysis code to the
<span class="lineNum">     364 </span>            :  * component interface. This component generates the analysis object dynamically. &lt;br&gt;
<span class="lineNum">     365 </span>            :  *
<span class="lineNum">     366 </span>            :  * Assume you have an implemetation &lt;tt&gt; AliHLTDetMyAnalysis &lt;/tt&gt;, another class &lt;tt&gt;
<span class="lineNum">     367 </span>            :  * AliHLTDetMyAnalysisComponent &lt;/tt&gt; contains:
<span class="lineNum">     368 </span>            :  * &lt;pre&gt;
<span class="lineNum">     369 </span>            :  * private:
<span class="lineNum">     370 </span>            :  *   AliHLTDetMyAnalysis* fMyAnalysis;  //!
<span class="lineNum">     371 </span>            :  * &lt;/pre&gt;
<span class="lineNum">     372 </span>            :  * The object should then be instantiated in the DoInit handler of 
<span class="lineNum">     373 </span>            :  * &lt;tt&gt;AliHLTDetMyAnalysisComponent &lt;/tt&gt;, and cleaned in the DoDeinit handler.
<span class="lineNum">     374 </span>            :  *
<span class="lineNum">     375 </span>            :  * Further rules:
<span class="lineNum">     376 </span>            :  * - avoid big static arrays in the component, allocate the memory at runtime
<span class="lineNum">     377 </span>            :  * - allocate all kind of complex data members (like classes, ROOT TObjects of
<span class="lineNum">     378 </span>            :  *   any kind) dynamically in DoInit and clean up in DoDeinit
<span class="lineNum">     379 </span>            :  *
<span class="lineNum">     380 </span>            :  * @section alihlt_component_arguments Default arguments
<span class="lineNum">     381 </span>            :  * The component base class provides some default arguments:
<span class="lineNum">     382 </span>            :  * &lt;!-- NOTE: ignore the \li. &lt;i&gt; and &lt;/i&gt;: it's just doxygen formatting --&gt;
<span class="lineNum">     383 </span>            :  * \li -loglevel=level     &lt;br&gt;
<span class="lineNum">     384 </span>            :  * \li -object-compression=level     &lt;br&gt;
<span class="lineNum">     385 </span>            :  *      compression level for ROOT objects, default is defined by
<span class="lineNum">     386 </span>            :  *      @ref ALIHLTCOMPONENT_DEFAULT_OBJECT_COMPRESSION
<span class="lineNum">     387 </span>            :  * \li -pushback-period=period     &lt;br&gt;
<span class="lineNum">     388 </span>            :  *      scale down for PushBack of objects, shipped only for one event
<span class="lineNum">     389 </span>            :  *      every &lt;i&gt;period&lt;/i&gt; seconds
<span class="lineNum">     390 </span>            :  * \li -event-module=number     &lt;br&gt;
<span class="lineNum">     391 </span>            :  *      This option reduces the event processing rate by processing only n'th event
<span class="lineNum">     392 </span>            :  *      based on the modulo number &lt;i&gt;number&lt;/i&gt;. The scale down should be about
<span class="lineNum">     393 </span>            :  *      1/&lt;i&gt;number&lt;/i&gt;, where &lt;i&gt;number&lt;/i&gt; is a positive integer.
<span class="lineNum">     394 </span>            :  *
<span class="lineNum">     395 </span>            :  * @ingroup alihlt_component
<span class="lineNum">     396 </span>            :  * @section alihltcomponent-members Class members
<span class="lineNum">     397 </span>            :  */
<span class="lineNum">     398 </span>            : class AliHLTComponent : public AliHLTLogging {
<span class="lineNum">     399 </span>            :  public:
<span class="lineNum">     400 </span>            :   /** standard constructor */
<span class="lineNum">     401 </span>            :   AliHLTComponent();
<span class="lineNum">     402 </span>            :   /** standard destructor */
<span class="lineNum">     403 </span>            :   virtual ~AliHLTComponent();
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span>            :   /** component type definitions */
<span class="lineNum">     406 </span>            :   enum TComponentType { kUnknown=0, kSource=1, kProcessor=2, kSink=3 };
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            :   /**
<span class="lineNum">     409 </span>            :    * Init function to prepare data processing.
<span class="lineNum">     410 </span>            :    * Initialization of common data structures for a sequence of events.
<span class="lineNum">     411 </span>            :    * The call is redirected to the internal method DoInit which can be
<span class="lineNum">     412 </span>            :    * overridden by the child class.
<span class="lineNum">     413 </span>            :    * During Init also the environment structure is passed to the component.
<span class="lineNum">     414 </span>            :    * @param comenv         environment pointer with environment dependent function
<span class="lineNum">     415 </span>            :    *                       calls
<span class="lineNum">     416 </span>            :    * @param environParam   additional parameter for function calls, the pointer
<span class="lineNum">     417 </span>            :    *                       is passed as it is
<span class="lineNum">     418 </span>            :    * @param argc           size of the argument array
<span class="lineNum">     419 </span>            :    * @param argv           augment array for component initialization
<span class="lineNum">     420 </span>            :    */
<span class="lineNum">     421 </span>            :   virtual int Init( const AliHLTAnalysisEnvironment* comenv, void* environParam, int argc, const char** argv );
<span class="lineNum">     422 </span>            : 
<span class="lineNum">     423 </span>            :   /**
<span class="lineNum">     424 </span>            :    * Clean-up function to terminate data processing.
<span class="lineNum">     425 </span>            :    * Clean-up of common data structures after data processing.
<span class="lineNum">     426 </span>            :    * The call is redirected to the internal method @ref DoDeinit which can be
<span class="lineNum">     427 </span>            :    * overridden by the child class.
<span class="lineNum">     428 </span>            :    */
<span class="lineNum">     429 </span>            :   virtual int Deinit();
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span>            :   /**
<span class="lineNum">     432 </span>            :    * Processing of one event.
<span class="lineNum">     433 </span>            :    * The method is the entrance of the event processing. The parameters are
<span class="lineNum">     434 </span>            :    * cached for uses with the high-level interface and the DoProcessing
<span class="lineNum">     435 </span>            :    * implementation is called.
<span class="lineNum">     436 </span>            :    *
<span class="lineNum">     437 </span>            :    * @param evtData
<span class="lineNum">     438 </span>            :    * @param blocks
<span class="lineNum">     439 </span>            :    * @param trigData
<span class="lineNum">     440 </span>            :    * @param outputPtr
<span class="lineNum">     441 </span>            :    * @param size
<span class="lineNum">     442 </span>            :    * @param outputBlockCnt  out: size of the output block array, set by the component
<span class="lineNum">     443 </span>            :    * @param outputBlocks    out: the output block array is allocated internally
<span class="lineNum">     444 </span>            :    * @param edd
<span class="lineNum">     445 </span>            :    * @return neg. error code if failed
<span class="lineNum">     446 </span>            :    */
<span class="lineNum">     447 </span>            :   int ProcessEvent( const AliHLTComponentEventData&amp; evtData, const AliHLTComponentBlockData* blocks, 
<span class="lineNum">     448 </span>            :                             AliHLTComponentTriggerData&amp; trigData, AliHLTUInt8_t* outputPtr, 
<span class="lineNum">     449 </span>            :                             AliHLTUInt32_t&amp; size, AliHLTUInt32_t&amp; outputBlockCnt, 
<span class="lineNum">     450 </span>            :                             AliHLTComponentBlockData*&amp; outputBlocks,
<span class="lineNum">     451 </span>            :                             AliHLTComponentEventDoneData*&amp; edd );
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span>            :   /**
<span class="lineNum">     454 </span>            :    * Internal processing of one event.
<span class="lineNum">     455 </span>            :    * The method is pure virtual and implemented by the child classes 
<span class="lineNum">     456 </span>            :    * - @ref AliHLTProcessor
<span class="lineNum">     457 </span>            :    * - @ref AliHLTDataSource
<span class="lineNum">     458 </span>            :    * - @ref AliHLTDataSink
<span class="lineNum">     459 </span>            :    *
<span class="lineNum">     460 </span>            :    * @param evtData
<span class="lineNum">     461 </span>            :    * @param blocks
<span class="lineNum">     462 </span>            :    * @param trigData
<span class="lineNum">     463 </span>            :    * @param outputPtr
<span class="lineNum">     464 </span>            :    * @param size
<span class="lineNum">     465 </span>            :    * @param outputBlocks    out: the output block array is allocated internally
<span class="lineNum">     466 </span>            :    * @param edd
<span class="lineNum">     467 </span>            :    * @return neg. error code if failed
<span class="lineNum">     468 </span>            :    */
<span class="lineNum">     469 </span>            :   virtual int DoProcessing( const AliHLTComponentEventData&amp; evtData, const AliHLTComponentBlockData* blocks, 
<span class="lineNum">     470 </span>            :                             AliHLTComponentTriggerData&amp; trigData, AliHLTUInt8_t* outputPtr, 
<span class="lineNum">     471 </span>            :                             AliHLTUInt32_t&amp; size,
<span class="lineNum">     472 </span>            :                             AliHLTComponentBlockDataList&amp; outputBlocks,
<span class="lineNum">     473 </span>            :                             AliHLTComponentEventDoneData*&amp; edd ) = 0;
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span>            :   /**
<span class="lineNum">     476 </span>            :    * Init the CDB.
<span class="lineNum">     477 </span>            :    * The function must not be called when running in AliRoot unless it it
<span class="lineNum">     478 </span>            :    * really wanted. The CDB path will be set to the specified path, which might
<span class="lineNum">     479 </span>            :    * override the path initialized at the beginning of the AliRoot reconstruction.
<span class="lineNum">     480 </span>            :    *
<span class="lineNum">     481 </span>            :    * The method is used from the external interface in order to set the correct
<span class="lineNum">     482 </span>            :    * path when running on-line. The function also initializes the function
<span class="lineNum">     483 </span>            :    * callback for setting the run no during operation.
<span class="lineNum">     484 </span>            :    *
<span class="lineNum">     485 </span>            :    * A separation of library and component handling is maybe appropriate in the
<span class="lineNum">     486 </span>            :    * future. Using the global component handler here is maybe not the cleanest
<span class="lineNum">     487 </span>            :    * solution.
<span class="lineNum">     488 </span>            :    * @param cdbPath      path of the CDB
<span class="lineNum">     489 </span>            :    * @param pHandler     the component handler used for llibrary handling.
<span class="lineNum">     490 </span>            :    */
<span class="lineNum">     491 </span>            :   int InitCDB(const char* cdbPath, AliHLTComponentHandler* pHandler);
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span>            :   /**
<span class="lineNum">     494 </span>            :    * Set the run no for the CDB.
<span class="lineNum">     495 </span>            :    * The function must not be called when running in AliRoot unless it it
<span class="lineNum">     496 </span>            :    * really wanted. The CDB path will be set to the specified path, which might
<span class="lineNum">     497 </span>            :    * override the run no initialized at the beginning of the AliRoot reconstruction.
<span class="lineNum">     498 </span>            :    * InitCDB() has to be called before in order to really change the CDB settings.
<span class="lineNum">     499 </span>            :    *
<span class="lineNum">     500 </span>            :    * The method is used from the external interface in order to set the correct
<span class="lineNum">     501 </span>            :    * path when running on-line.
<span class="lineNum">     502 </span>            :    */
<span class="lineNum">     503 </span>            :   int SetCDBRunNo(int runNo);
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span>            :   /**
<span class="lineNum">     506 </span>            :    * Set the run description.
<span class="lineNum">     507 </span>            :    * The run description is set before the call of Init() -&gt; DoInit().
<span class="lineNum">     508 </span>            :    * @note: This functionality has been added in Juli 2008. The transmission of
<span class="lineNum">     509 </span>            :    * run properties by a special SOR (SOD event in DAQ terminalogy but this was
<span class="lineNum">     510 </span>            :    * changed after the HLT interface was designed) event is not sufficient because
<span class="lineNum">     511 </span>            :    * the data might be needed already in the DoInit handler of the component.
<span class="lineNum">     512 </span>            :    * @param desc    run descriptor, currently only the run no member is used
<span class="lineNum">     513 </span>            :    * @param runType originally, run type was supposed to be a number and part
<span class="lineNum">     514 </span>            :    *                of the run descriptor. But it was defined as string later
<span class="lineNum">     515 </span>            :    */
<span class="lineNum">     516 </span>            :   int SetRunDescription(const AliHLTRunDesc* desc, const char* runType);
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span>            :   /**
<span class="lineNum">     519 </span>            :    * Set the component description.
<span class="lineNum">     520 </span>            :    * The description string can contain tokens separated by blanks, a token
<span class="lineNum">     521 </span>            :    * consists of a key and an optional value separated by '='.
<span class="lineNum">     522 </span>            :    * Possible keys:
<span class="lineNum">     523 </span>            :    * \li -chainid=id        string id within the chain of the instance
<span class="lineNum">     524 </span>            :    *
<span class="lineNum">     525 </span>            :    * @param desc    component description
<span class="lineNum">     526 </span>            :    */
<span class="lineNum">     527 </span>            :   int SetComponentDescription(const char* desc);
<span class="lineNum">     528 </span>            : 
<span class="lineNum">     529 </span>            :   /**
<span class="lineNum">     530 </span>            :    * Set the running environment for the component.
<span class="lineNum">     531 </span>            :    * Originally, the environment was set in the Init function. However, the setup of
<span class="lineNum">     532 </span>            :    * the CDB is required before. In order to have proper logging functionality, the
<span class="lineNum">     533 </span>            :    * environment is required.
<span class="lineNum">     534 </span>            :    * @param comenv         environment pointer with environment dependent function
<span class="lineNum">     535 </span>            :    *                       calls
<span class="lineNum">     536 </span>            :    * @param environParam   additional parameter for function calls, the pointer
<span class="lineNum">     537 </span>            :    *                       is passed as it is
<span class="lineNum">     538 </span>            :    */
<span class="lineNum">     539 </span>            :   int SetComponentEnvironment(const AliHLTAnalysisEnvironment* comenv, void* environParam);
<span class="lineNum">     540 </span>            : 
<span class="lineNum">     541 </span>            :   // Information member functions for registration.
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span>            :   /**
<span class="lineNum">     544 </span>            :    * Get the type of the component.
<span class="lineNum">     545 </span>            :    * The function is pure virtual and must be implemented by the child class.
<span class="lineNum">     546 </span>            :    * @return component type id
<span class="lineNum">     547 </span>            :    */
<span class="lineNum">     548 </span>            :   virtual TComponentType GetComponentType() = 0; // Source, sink, or processor
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span>            :   /**
<span class="lineNum">     551 </span>            :    * Get the id of the component.
<span class="lineNum">     552 </span>            :    * Each component is identified by a unique id.
<span class="lineNum">     553 </span>            :    * The function is pure virtual and must be implemented by the child class.
<span class="lineNum">     554 </span>            :    * @return component id (string)
<span class="lineNum">     555 </span>            :    */
<span class="lineNum">     556 </span>            :   virtual const char* GetComponentID() = 0;
<span class="lineNum">     557 </span>            : 
<span class="lineNum">     558 </span>            :   /**
<span class="lineNum">     559 </span>            :    * Get the input data types of the component.
<span class="lineNum">     560 </span>            :    * The function is pure virtual and must be implemented by the child class.
<span class="lineNum">     561 </span>            :    * @return list of data types in the vector reference
<span class="lineNum">     562 </span>            :    */
<span class="lineNum">     563 </span>            :   virtual void GetInputDataTypes( AliHLTComponentDataTypeList&amp; ) = 0;
<span class="lineNum">     564 </span>            : 
<span class="lineNum">     565 </span>            :   /**
<span class="lineNum">     566 </span>            :    * Get the output data type of the component.
<span class="lineNum">     567 </span>            :    * The function is pure virtual and must be implemented by the child class.
<span class="lineNum">     568 </span>            :    * @return output data type
<span class="lineNum">     569 </span>            :    */
<span class="lineNum">     570 </span>            :   virtual AliHLTComponentDataType GetOutputDataType() = 0;
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span>            :   /**
<span class="lineNum">     573 </span>            :    * Get the output data types of the component.
<span class="lineNum">     574 </span>            :    * The function can be implemented to indicate multiple output data types
<span class="lineNum">     575 </span>            :    * in the target array.
<span class="lineNum">     576 </span>            :    * @ref GetOutputDataType must return @ref kAliHLTMultipleDataType in order
<span class="lineNum">     577 </span>            :    * to invoke this method.
<span class="lineNum">     578 </span>            :    * @param tgtList          list to receive the data types
<span class="lineNum">     579 </span>            :    * @return no of output data types, data types in the target list
<span class="lineNum">     580 </span>            :    */
<span class="lineNum">     581 </span>            :   virtual int GetOutputDataTypes(AliHLTComponentDataTypeList&amp; tgtList);
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span>            :   /**
<span class="lineNum">     584 </span>            :    * Get a ratio by how much the data volume is shrunken or enhanced.
<span class="lineNum">     585 </span>            :    * The function is pure virtual and must be implemented by the child class.
<span class="lineNum">     586 </span>            :    * @param constBase        &lt;i&gt;return&lt;/i&gt;: additive part, independent of the
<span class="lineNum">     587 </span>            :    *                                   input data volume  
<span class="lineNum">     588 </span>            :    * @param inputMultiplier  &lt;i&gt;return&lt;/i&gt;: multiplication ratio
<span class="lineNum">     589 </span>            :    * @return values in the reference variables
<span class="lineNum">     590 </span>            :    */
<span class="lineNum">     591 </span>            :   virtual void GetOutputDataSize( unsigned long&amp; constBase, double&amp; inputMultiplier ) = 0;
<span class="lineNum">     592 </span>            : 
<span class="lineNum">     593 </span>            :   /**
<span class="lineNum">     594 </span>            :    * Get a list of OCDB object description.
<span class="lineNum">     595 </span>            :    * The list of objects is provided in a TMap
<span class="lineNum">     596 </span>            :    * - key: complete OCDB path, e.g. GRP/GRP/Data
<span class="lineNum">     597 </span>            :    * - value: short description why the object is needed
<span class="lineNum">     598 </span>            :    * Key and value objects created inside this class go into ownership of
<span class="lineNum">     599 </span>            :    * target TMap.
<span class="lineNum">     600 </span>            :    * @param targetMap   TMap instance receiving the list
<span class="lineNum">     601 </span>            :    * @return void
<span class="lineNum">     602 </span>            :    */
<span class="lineNum">     603 </span>            :   virtual void GetOCDBObjectDescription( TMap* const targetArray);
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span>            :   /**
<span class="lineNum">     606 </span>            :    * Spawn function.
<span class="lineNum">     607 </span>            :    * Each component must implement a spawn function to create a new instance of 
<span class="lineNum">     608 </span>            :    * the class. Basically the function must return &lt;i&gt;new &lt;b&gt;my_class_name&lt;/b&gt;&lt;/i&gt;.
<span class="lineNum">     609 </span>            :    * @return new class instance
<span class="lineNum">     610 </span>            :    */
<span class="lineNum">     611 </span>            :   virtual AliHLTComponent* Spawn() = 0;
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span>            :   /**
<span class="lineNum">     614 </span>            :    * check the availability of the OCDB entry descriptions in the TMap
<span class="lineNum">     615 </span>            :    *  key : complete OCDB path of the entry
<span class="lineNum">     616 </span>            :    *  value : auxiliary object - short description
<span class="lineNum">     617 </span>            :    * if the external map was not provided the function invokes
<span class="lineNum">     618 </span>            :    * interface function GetOCDBObjectDescription() to retrieve the list.
<span class="lineNum">     619 </span>            :    * @param externList  map of entries to be tested
<span class="lineNum">     620 </span>            :    * @result 0 if all found, -ENOENT if objects not found
<span class="lineNum">     621 </span>            :    */
<span class="lineNum">     622 </span>            :   int CheckOCDBEntries(const TMap* const externList=NULL);
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span>            :   /**
<span class="lineNum">     625 </span>            :    * Find matching data types between this component and a consumer component.
<span class="lineNum">     626 </span>            :    * Currently, a component can produce only one type of data. This restriction is most
<span class="lineNum">     627 </span>            :    * likely to be abolished in the future.
<span class="lineNum">     628 </span>            :    * @param pConsumer a component and consumer of the data produced by this component
<span class="lineNum">     629 </span>            :    * @param tgtList   reference to a vector list to receive the matching data types.
<span class="lineNum">     630 </span>            :    * @return &gt;= 0 success, neg. error code if failed
<span class="lineNum">     631 </span>            :    */ 
<span class="lineNum">     632 </span>            :   int FindMatchingDataTypes(AliHLTComponent* pConsumer, AliHLTComponentDataTypeList* tgtList);
<span class="lineNum">     633 </span>            :  
<span class="lineNum">     634 </span>            :   /**
<span class="lineNum">     635 </span>            :    * Set the global component handler.
<span class="lineNum">     636 </span>            :    * The static method is needed for the automatic registration of components. 
<span class="lineNum">     637 </span>            :    */
<span class="lineNum">     638 </span>            :   static int SetGlobalComponentHandler(AliHLTComponentHandler* pCH, int bOverwrite=0);
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span>            :   /**
<span class="lineNum">     641 </span>            :    * Clear the global component handler.
<span class="lineNum">     642 </span>            :    * The static method is needed for the automatic registration of components. 
<span class="lineNum">     643 </span>            :    */
<span class="lineNum">     644 </span>            :   static int UnsetGlobalComponentHandler();
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span>            :   /**
<span class="lineNum">     647 </span>            :    * Helper function to convert the data type to a string.
<span class="lineNum">     648 </span>            :    * @param type        data type structure
<span class="lineNum">     649 </span>            :    * @param mode        0 print string origin:type          &lt;br&gt;
<span class="lineNum">     650 </span>            :    *                    1 print chars                       &lt;br&gt;
<span class="lineNum">     651 </span>            :    *                    2 print numbers                     &lt;br&gt;
<span class="lineNum">     652 </span>            :    *                    3 print 'type' 'origin' 
<span class="lineNum">     653 </span>            :    */
<span class="lineNum">     654 </span>            :   static string DataType2Text( const AliHLTComponentDataType&amp; type, int mode=0);
<span class="lineNum">     655 </span>            :   
<span class="lineNum">     656 </span>            :   /**
<span class="lineNum">     657 </span>            :    * Helper functions to convert data type to a char array (ZMQ topic) and back
<span class="lineNum">     658 </span>            :    * fID goes first (8 chars) then fOrigin (4 chars)
<span class="lineNum">     659 </span>            :    **/
<span class="lineNum">     660 </span>            :   static void DataType2Topic( const AliHLTComponentDataType type, char* output );
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span>            :   /**
<span class="lineNum">     663 </span>            :    * Calculate a CRC checksum of a data buffer.
<span class="lineNum">     664 </span>            :    * Polynomial for the calculation is 0xD8.
<span class="lineNum">     665 </span>            :    */
<span class="lineNum">     666 </span>            :   static AliHLTUInt32_t CalculateChecksum(const AliHLTUInt8_t* buffer, int size);
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span>            :   /**
<span class="lineNum">     669 </span>            :    * Helper function to print content of data type.
<span class="lineNum">     670 </span>            :    */
<span class="lineNum">     671 </span>            :   static void PrintDataTypeContent(AliHLTComponentDataType&amp; dt, const char* format=NULL);
<span class="lineNum">     672 </span>            : 
<span class="lineNum">     673 </span>            :   /**
<span class="lineNum">     674 </span>            :    * helper function to initialize AliHLTComponentEventData structure
<span class="lineNum">     675 </span>            :    */
<span class="lineNum">     676 </span>            :   static void FillEventData(AliHLTComponentEventData&amp; evtData);
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span>            :   /**
<span class="lineNum">     679 </span>            :    * Print info on an AliHLTComponentDataType structure
<span class="lineNum">     680 </span>            :    * This is just a helper function to examine an @ref AliHLTComponentDataType
<span class="lineNum">     681 </span>            :    * structur.
<span class="lineNum">     682 </span>            :    */
<span class="lineNum">     683 </span>            :   static void PrintComponentDataTypeInfo(const AliHLTComponentDataType&amp; dt);
<span class="lineNum">     684 </span>            : 
<span class="lineNum">     685 </span>            :   /**
<span class="lineNum">     686 </span>            :    * Fill AliHLTComponentBlockData structure with default values.
<span class="lineNum">     687 </span>            :    * @param blockData   reference to data structure
<span class="lineNum">     688 </span>            :    */
<span class="lineNum">     689 </span>            :   static void FillBlockData( AliHLTComponentBlockData&amp; blockData );
<span class="lineNum">     690 </span>            : 
<span class="lineNum">     691 </span>            :   /**
<span class="lineNum">     692 </span>            :    * Serializes an object into a buffer. If buffer is NULL, this allocates memory for the pointer
<span class="lineNum">     693 </span>            :    * and returns the size of the buffer. The input-size is then used as offset of the object in the buffer,
<span class="lineNum">     694 </span>            :    * i.e. the buffer is chosen larger and [size] bytes are left at the beginning for a custom header.
<span class="lineNum">     695 </span>            :    * If buffer is not NULL, caller provides a preallocated buffer and the size of it.
<span class="lineNum">     696 </span>            :    */
<span class="lineNum">     697 </span>            :   int SerializeObject(TObject* obj, void* &amp;buffer, size_t &amp;size);
<span class="lineNum">     698 </span>            :   
<span class="lineNum">     699 </span>            :   /**
<span class="lineNum">     700 </span>            :    * Fill AliHLTComponentShmData structure with default values.
<span class="lineNum">     701 </span>            :    * @param shmData   reference to data structure
<span class="lineNum">     702 </span>            :    */
<span class="lineNum">     703 </span>            :   static void FillShmData( AliHLTComponentShmData&amp; shmData );
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span>            :   /**
<span class="lineNum">     706 </span>            :    * Fill AliHLTComponentDataType structure with default values.
<span class="lineNum">     707 </span>            :    * @param dataType   reference to data structure
<span class="lineNum">     708 </span>            :    */
<span class="lineNum">     709 </span>            :   static void FillDataType( AliHLTComponentDataType&amp; dataType );
<span class="lineNum">     710 </span>            :   
<span class="lineNum">     711 </span>            :   /**
<span class="lineNum">     712 </span>            :    * Copy data type structure
<span class="lineNum">     713 </span>            :    * Copies the value an AliHLTComponentDataType structure to another one
<span class="lineNum">     714 </span>            :    * @param [out] tgtdt   target structure
<span class="lineNum">     715 </span>            :    * @param [in] srcdt   source structure
<span class="lineNum">     716 </span>            :    */
<span class="lineNum">     717 </span>            :   static void CopyDataType(AliHLTComponentDataType&amp; tgtdt, const AliHLTComponentDataType&amp; srcdt);
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span>            :   /**
<span class="lineNum">     720 </span>            :    * Set the ID and Origin of an AliHLTComponentDataType structure.
<span class="lineNum">     721 </span>            :    * The function sets the fStructureSize member and copies the strings
<span class="lineNum">     722 </span>            :    * to the ID and Origin. Only characters from the valid part of the string
<span class="lineNum">     723 </span>            :    * are copied, the rest is filled with 0's. &lt;br&gt;
<span class="lineNum">     724 </span>            :    * Please note that the fID and fOrigin members are not strings, just arrays of
<span class="lineNum">     725 </span>            :    * chars of size @ref kAliHLTComponentDataTypefIDsize and
<span class="lineNum">     726 </span>            :    * @ref kAliHLTComponentDataTypefOriginSize respectively and not necessarily with
<span class="lineNum">     727 </span>            :    * a terminating zero. &lt;br&gt;
<span class="lineNum">     728 </span>            :    * It is possible to pass NULL pointers as id or origin argument, in that case they
<span class="lineNum">     729 </span>            :    * are just ignored.
<span class="lineNum">     730 </span>            :    * @param tgtdt   target data type structure
<span class="lineNum">     731 </span>            :    * @param id      ID string
<span class="lineNum">     732 </span>            :    * @param origin  Origin string
<span class="lineNum">     733 </span>            :    */
<span class="lineNum">     734 </span>            :   static void SetDataType(AliHLTComponentDataType&amp; tgtdt, const char* id, const char* origin);
<span class="lineNum">     735 </span>            : 
<span class="lineNum">     736 </span>            :   /**
<span class="lineNum">     737 </span>            :    * Set the ID and Origin of an AliHLTComponentDataType structure.
<span class="lineNum">     738 </span>            :    * Given the fact that the data type ID is 64bit wide and origin 32, this helper
<span class="lineNum">     739 </span>            :    * function sets the data type from those two parameters.
<span class="lineNum">     740 </span>            :    * @param dt      target data type structure
<span class="lineNum">     741 </span>            :    * @param id      64bit id
<span class="lineNum">     742 </span>            :    * @param orig    32bit origin
<span class="lineNum">     743 </span>            :    */
<span class="lineNum">     744 </span>            :   static void SetDataType(AliHLTComponentDataType&amp; dt, AliHLTUInt64_t id, AliHLTUInt32_t orig); 
<span class="lineNum">     745 </span>            : 
<span class="lineNum">     746 </span>            :   /**
<span class="lineNum">     747 </span>            :    * Extract a component table entry from the payload buffer.
<span class="lineNum">     748 </span>            :    * The entry consists of the AliHLTComponentTableEntry structure, the array of
<span class="lineNum">     749 </span>            :    * parents and a description string of the format 'chain-id{component-id:component-args}'.
<a name="750"><span class="lineNum">     750 </span>            :    * The function fills all the variables after a consistency check.</a>
<span class="lineNum">     751 </span>            :    */
<span class="lineNum">     752 </span>            :   static int ExtractComponentTableEntry(const AliHLTUInt8_t* pBuffer, AliHLTUInt32_t size,
<span class="lineNum">     753 </span>            :                                         string&amp; chainId, string&amp; compId, string&amp; compParam,
<span class="lineNum">     754 </span>            :                                         vector&lt;AliHLTUInt32_t&gt;&amp; parents) {
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :     int dummy=0;</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :     return ExtractComponentTableEntry(pBuffer, size, chainId, compId, compParam, parents, dummy);</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     758 </span>            : 
<span class="lineNum">     759 </span>            :   static int ExtractComponentTableEntry(const AliHLTUInt8_t* pBuffer, AliHLTUInt32_t size,
<span class="lineNum">     760 </span>            :                                         string&amp; chainId, string&amp; compId, string&amp; compParam,
<span class="lineNum">     761 </span>            :                                         vector&lt;AliHLTUInt32_t&gt;&amp; parents, int&amp; level);
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span>            :   /**
<span class="lineNum">     764 </span>            :    * Extracts the different data parts from the trigger data structure.
<span class="lineNum">     765 </span>            :    * @param [in] trigData  The trigger data as passed to the DoProcessing method.
<span class="lineNum">     766 </span>            :    * @param [out] attributes  The data block attributes given by the HLT framework.
<span class="lineNum">     767 </span>            :    * @param [out] status  The HLT status bits given by the HLT framework.
<span class="lineNum">     768 </span>            :    * @param [out] cdh  The common data header received from DDL links.
<span class="lineNum">     769 </span>            :    * @param [out] readoutlist  The readout list to fill with readout list bits
<span class="lineNum">     770 </span>            :    *                           passed on by the HLT framework.
<span class="lineNum">     771 </span>            :    * @param [in] printErrors  If true then error messages are generated as necessary
<span class="lineNum">     772 </span>            :    *                          and suppressed otherwise.
<span class="lineNum">     773 </span>            :    * @note If any of the output parameters are set to NULL then the field is not set.
<span class="lineNum">     774 </span>            :    *   For example, the following line will only fill the CDH pointer.
<span class="lineNum">     775 </span>            :    *   \code
<span class="lineNum">     776 </span>            :    *     AliHLTCDHWrapper cdh;
<span class="lineNum">     777 </span>            :    *     ExtractTriggerData(trigData, NULL, NULL, &amp;cdh, NULL);
<span class="lineNum">     778 </span>            :    *   \endcode
<span class="lineNum">     779 </span>            :    * @return zero on success or one of the following error codes on failure.
<span class="lineNum">     780 </span>            :    *   if a non-zero error code is returned then none of the output parameters are
<span class="lineNum">     781 </span>            :    *   modified.
<span class="lineNum">     782 </span>            :    *    \li -ENOENT  The &lt;i&gt;trigData&lt;/i&gt; structure size is wrong.
<span class="lineNum">     783 </span>            :    *    \li -EBADF   The &lt;i&gt;trigData&lt;/i&gt; data size is wrong.
<span class="lineNum">     784 </span>            :    *    \li -EBADMSG The common data header (CDH) in the trigger data has the wrong
<span class="lineNum">     785 </span>            :    *                 number of words indicated.
<span class="lineNum">     786 </span>            :    *    \li -EPROTO  The readout list structure in the trigger data has the wrong
<span class="lineNum">     787 </span>            :    *                 number of words indicated.
<span class="lineNum">     788 </span>            :    */
<span class="lineNum">     789 </span>            :   static int ExtractTriggerData(
<span class="lineNum">     790 </span>            :       const AliHLTComponentTriggerData&amp; trigData,
<span class="lineNum">     791 </span>            :       const AliHLTUInt8_t (**attributes)[gkAliHLTBlockDAttributeCount],
<span class="lineNum">     792 </span>            :       AliHLTUInt64_t* status,
<span class="lineNum">     793 </span>            :       AliHLTCDHWrapper* const cdh,
<span class="lineNum">     794 </span>            :       AliHLTReadoutList* readoutlist,
<span class="lineNum">     795 </span>            :       bool printErrors = false
<span class="lineNum">     796 </span>            :     );
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span>            :   /**
<span class="lineNum">     799 </span>            :    * Extracts the readout list from a trigger data structure.
<span class="lineNum">     800 </span>            :    * @param [in] trigData  The trigger data as passed to the DoProcessing method.
<span class="lineNum">     801 </span>            :    * @param [out] list  The output readout list to fill.
<span class="lineNum">     802 </span>            :    * @param [in] printErrors  If true then error messages are generated as necessary
<span class="lineNum">     803 </span>            :    *                          and suppressed otherwise.
<a name="804"><span class="lineNum">     804 </span>            :    * @return zero on success or one of the error codes returned by ExtractTriggerData.</a>
<span class="lineNum">     805 </span>            :    */
<span class="lineNum">     806 </span>            :   static int GetReadoutList(
<span class="lineNum">     807 </span>            :       const AliHLTComponentTriggerData&amp; trigData, AliHLTReadoutList&amp; list,
<span class="lineNum">     808 </span>            :       bool printErrors = false
<span class="lineNum">     809 </span>            :     )
<span class="lineNum">     810 </span>            :   {
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :     return ExtractTriggerData(trigData, NULL, NULL, NULL, &amp;list, printErrors);</span>
<span class="lineNum">     812 </span>            :   }
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span>            :   /**
<span class="lineNum">     815 </span>            :    * Extracts the event type from the given Common Data Header.
<span class="lineNum">     816 </span>            :    * @param [in] cdh  The Common Data Header to extract the event type from.
<span class="lineNum">     817 </span>            :    * @return the event type code from the CDH.
<span class="lineNum">     818 </span>            :    */
<span class="lineNum">     819 </span>            :   static AliHLTUInt32_t ExtractEventTypeFromCDH(const AliHLTCDHWrapper* const cdh);
<span class="lineNum">     820 </span>            :   
<span class="lineNum">     821 </span>            :   /**
<span class="lineNum">     822 </span>            :    * Stopwatch type for benchmarking.
<span class="lineNum">     823 </span>            :    */
<span class="lineNum">     824 </span>            :   enum AliHLTStopwatchType {
<span class="lineNum">     825 </span>            :     /** total time for event processing */
<span class="lineNum">     826 </span>            :     kSWBase,
<span class="lineNum">     827 </span>            :     /** detector algorithm w/o interface callbacks */
<span class="lineNum">     828 </span>            :     kSWDA,
<span class="lineNum">     829 </span>            :     /** data sources */
<span class="lineNum">     830 </span>            :     kSWInput,
<span class="lineNum">     831 </span>            :     /** data sinks */
<span class="lineNum">     832 </span>            :     kSWOutput,
<span class="lineNum">     833 </span>            :     /** number of types */
<span class="lineNum">     834 </span>            :     kSWTypeCount
<span class="lineNum">     835 </span>            :   };
<span class="lineNum">     836 </span>            : 
<span class="lineNum">     837 </span>            :   /**
<span class="lineNum">     838 </span>            :    * Helper class for starting and stopping a stopwatch.
<span class="lineNum">     839 </span>            :    * The guard can be used by instantiating an object in a function. The
<span class="lineNum">     840 </span>            :    * specified stopwatch is started and the previous stopwatch put on
<span class="lineNum">     841 </span>            :    * hold. When the function is terminated, the object is deleted automatically
<span class="lineNum">     842 </span>            :    * deleted, stopping the stopwatch and starting the one on hold.&lt;br&gt;
<span class="lineNum">     843 </span>            :    * \em IMPORTANT: never create dynamic objects from this guard as this violates
<span class="lineNum">     844 </span>            :    * the idea of a guard.
<span class="lineNum">     845 </span>            :    */
<span class="lineNum">     846 </span>            :   class AliHLTStopwatchGuard {
<span class="lineNum">     847 </span>            :   public:
<span class="lineNum">     848 </span>            :     /** standard constructor (not for use) */
<span class="lineNum">     849 </span>            :     AliHLTStopwatchGuard();
<span class="lineNum">     850 </span>            :     /** constructor */
<span class="lineNum">     851 </span>            :     AliHLTStopwatchGuard(TStopwatch* pStart);
<span class="lineNum">     852 </span>            :     /** copy constructor (not for use) */
<span class="lineNum">     853 </span>            :     AliHLTStopwatchGuard(const AliHLTStopwatchGuard&amp;);
<span class="lineNum">     854 </span>            :     /** assignment operator (not for use) */
<span class="lineNum">     855 </span>            :     AliHLTStopwatchGuard&amp; operator=(const AliHLTStopwatchGuard&amp;);
<span class="lineNum">     856 </span>            :     /** destructor */
<span class="lineNum">     857 </span>            :     ~AliHLTStopwatchGuard();
<span class="lineNum">     858 </span>            : 
<span class="lineNum">     859 </span>            :   private:
<span class="lineNum">     860 </span>            :     /**
<span class="lineNum">     861 </span>            :      * Hold the previous guard for the existence of this guard.
<span class="lineNum">     862 </span>            :      * Checks whether this guard controls a new stopwatch. In that case, the
<span class="lineNum">     863 </span>            :      * previous guard and its stopwatch are put on hold.
<span class="lineNum">     864 </span>            :      * @param pSucc        instance of the stopwatch of the new guard
<span class="lineNum">     865 </span>            :      * @return    1 if pSucc is a different stopwatch which should
<span class="lineNum">     866 </span>            :      *            be started&lt;br&gt;
<span class="lineNum">     867 </span>            :      *            0 if it controls the same stopwatch
<span class="lineNum">     868 </span>            :      */
<span class="lineNum">     869 </span>            :     int Hold(const TStopwatch* pSucc);
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span>            :     /**
<span class="lineNum">     872 </span>            :      * Resume the previous guard.
<span class="lineNum">     873 </span>            :      * Checks whether the peceeding guard controls a different stopwatch. In that
<span class="lineNum">     874 </span>            :      * case, the its stopwatch is resumed.
<span class="lineNum">     875 </span>            :      * @param pSucc        instance of the stopwatch of the new guard
<span class="lineNum">     876 </span>            :      * @return    1 if pSucc is a different stopwatch which should
<span class="lineNum">     877 </span>            :      *            be stopped&lt;br&gt;
<span class="lineNum">     878 </span>            :      *            0 if it controls the same stopwatch
<span class="lineNum">     879 </span>            :      */
<span class="lineNum">     880 </span>            :     int Resume(const TStopwatch* pSucc);
<span class="lineNum">     881 </span>            : 
<span class="lineNum">     882 </span>            :     /** the stopwatch controlled by this guard */
<span class="lineNum">     883 </span>            :     TStopwatch* fpStopwatch;                                                //!transient
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span>            :     /** previous stopwatch guard, put on hold during existence of the guard */
<span class="lineNum">     886 </span>            :     AliHLTStopwatchGuard* fpPrec;                                           //!transient
<span class="lineNum">     887 </span>            : 
<span class="lineNum">     888 </span>            :     /** active stopwatch guard */
<span class="lineNum">     889 </span>            :     static AliHLTStopwatchGuard* fgpCurrent;                                //!transient
<span class="lineNum">     890 </span>            :   };
<span class="lineNum">     891 </span>            : 
<span class="lineNum">     892 </span>            :   /**
<span class="lineNum">     893 </span>            :    * Set a stopwatch for a given purpose.
<span class="lineNum">     894 </span>            :    * @param pSW         stopwatch object
<span class="lineNum">     895 </span>            :    * @param type        type of the stopwatch
<span class="lineNum">     896 </span>            :    */
<span class="lineNum">     897 </span>            :   int SetStopwatch(TObject* pSW, AliHLTStopwatchType type=kSWBase);
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span>            :   /**
<span class="lineNum">     900 </span>            :    * Init a set of stopwatches.
<span class="lineNum">     901 </span>            :    * @param pStopwatches object array of stopwatches
<span class="lineNum">     902 </span>            :    */
<span class="lineNum">     903 </span>            :   int SetStopwatches(TObjArray* pStopwatches);
<span class="lineNum">     904 </span>            : 
<span class="lineNum">     905 </span>            :   /**
<span class="lineNum">     906 </span>            :    * Customized logging function.
<span class="lineNum">     907 </span>            :    * The chain id, component id and pointer is added at the beginning of each message.
<span class="lineNum">     908 </span>            :    */
<span class="lineNum">     909 </span>            :   int LoggingVarargs(AliHLTComponentLogSeverity severity, 
<span class="lineNum">     910 </span>            :                      const char* originClass, const char* originFunc,
<span class="lineNum">     911 </span>            :                      const char* file, int line, ... ) const;
<span class="lineNum">     912 </span>            : 
<span class="lineNum">     913 </span>            :   /**
<span class="lineNum">     914 </span>            :    * Get size of last serialized object.
<span class="lineNum">     915 </span>            :    * During PushBack, TObjects are serialized in a separate buffer. The
<span class="lineNum">     916 </span>            :    * size of the last object can be retrieved by this function.
<span class="lineNum">     917 </span>            :    *
<span class="lineNum">     918 </span>            :    * This might be especially useful for PushBack failures caused by too
<a name="919"><span class="lineNum">     919 </span>            :    * small output buffer.</a>
<span class="lineNum">     920 </span>            :    */
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :   int GetLastObjectSize() const {return fLastObjectSize;}</span>
<span class="lineNum">     922 </span>            : 
<span class="lineNum">     923 </span>            :   /**
<span class="lineNum">     924 </span>            :    * This method generates a V4 Globally Unique Identifier (GUID) using the
<span class="lineNum">     925 </span>            :    * ROOT TRandom3 pseudo-random number generator with the process' UID, GID
<span class="lineNum">     926 </span>            :    * PID and host address as seeds. For good measure MD5 sum hashing is also
<span class="lineNum">     927 </span>            :    * applied.
<span class="lineNum">     928 </span>            :    * @return the newly generated GUID structure.
<span class="lineNum">     929 </span>            :    */
<span class="lineNum">     930 </span>            :   static TUUID GenerateGUID();
<a name="931"><span class="lineNum">     931 </span>            : </a>
<span class="lineNum">     932 </span>            :   /// get the compression level for TObjects
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :   int GetCompressionLevel() const {return fCompressionLevel;}</span>
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span>            :   /**
<a name="936"><span class="lineNum">     936 </span>            :    * get the full configuration string</a>
<span class="lineNum">     937 </span>            :    */
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :   string GetComponentArgs() const { return fComponentArgs; }</span>
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span>            :  protected:
<span class="lineNum">     941 </span>            : 
<span class="lineNum">     942 </span>            :   /** Get the schema map and get/set the use flag
<span class="lineNum">     943 </span>            :   */
<span class="lineNum">     944 </span>            :   TList* GetSchema() {return &amp;fSchema;}
<span class="lineNum">     945 </span>            :   Bool_t GetUseSchema() const {return fUseSchema;}
<span class="lineNum">     946 </span>            :   void SetUseSchema(Bool_t s=kTRUE) {fUseSchema = s;}
<span class="lineNum">     947 </span>            :   int UpdateSchema(const TCollection* listOfStreamerInfos);
<span class="lineNum">     948 </span>            :   int UpdateSchema(TCollection* listOfStreamerInfos);
<span class="lineNum">     949 </span>            :   /** push back a schema evolution block (only when new streamer infos
<span class="lineNum">     950 </span>            :    * are added
<span class="lineNum">     951 </span>            :    */
<span class="lineNum">     952 </span>            :   int PushBackSchema();
<span class="lineNum">     953 </span>            : 
<span class="lineNum">     954 </span>            :   /**
<span class="lineNum">     955 </span>            :    * Default method for the internal initialization.
<span class="lineNum">     956 </span>            :    * The method is called by @ref Init
<span class="lineNum">     957 </span>            :    */
<span class="lineNum">     958 </span>            :   virtual int DoInit( int argc, const char** argv );
<span class="lineNum">     959 </span>            : 
<span class="lineNum">     960 </span>            :   /**
<span class="lineNum">     961 </span>            :    * Default method for the internal clean-up.
<span class="lineNum">     962 </span>            :    * The method is called by @ref Deinit
<span class="lineNum">     963 </span>            :    */
<span class="lineNum">     964 </span>            :   virtual int DoDeinit();
<span class="lineNum">     965 </span>            : 
<span class="lineNum">     966 </span>            :   /**
<span class="lineNum">     967 </span>            :    * Reconfigure the component.
<span class="lineNum">     968 </span>            :    * The method is called when an event of type @ref kAliHLTDataTypeComConf
<span class="lineNum">     969 </span>            :    * {COM_CONF:PRIV} is received by the component. If the event is sent as
<span class="lineNum">     970 </span>            :    * part of a normal event, the component configuration is called first.
<span class="lineNum">     971 </span>            :    *
<span class="lineNum">     972 </span>            :    * The CDB path parameter specifies the path in the CDB, i.e. without
<span class="lineNum">     973 </span>            :    * leading absolute path of the CDB location. The framework might also
<span class="lineNum">     974 </span>            :    * provide the id of the component in the analysis chain.
<span class="lineNum">     975 </span>            :    *
<span class="lineNum">     976 </span>            :    * The actual sequence of configuration depends on the component. As a
<span class="lineNum">     977 </span>            :    * general rule, the component should load the specific OCDB object if
<span class="lineNum">     978 </span>            :    * provided as parameter, and load the default objects if the parameter
<span class="lineNum">     979 </span>            :    * is NULL. However, other schemes are possible. See @ref 
<span class="lineNum">     980 </span>            :    *
<span class="lineNum">     981 </span>            :    * \b Note: The CDB will be initialized by the framework, either already set
<span class="lineNum">     982 </span>            :    * from AliRoot or from the wrapper interface during initialization.
<span class="lineNum">     983 </span>            :    *
<span class="lineNum">     984 </span>            :    * @param cdbEntry     path of the cdbEntry
<span class="lineNum">     985 </span>            :    * @param chainId      the id/name of the component in the current analysis
<span class="lineNum">     986 </span>            :    *                     chain. This is not necessarily the same as what is
<span class="lineNum">     987 </span>            :    *                     returned by the GetComponentID() method.
<span class="lineNum">     988 </span>            :    * @note both parameters can be NULL, check before usage
<span class="lineNum">     989 </span>            :    */
<span class="lineNum">     990 </span>            :   virtual int Reconfigure(const char* cdbEntry, const char* chainId);
<span class="lineNum">     991 </span>            : 
<span class="lineNum">     992 </span>            :   /**
<span class="lineNum">     993 </span>            :    * Read the Preprocessor values.
<span class="lineNum">     994 </span>            :    * The function is invoked when the component is notified about available/
<span class="lineNum">     995 </span>            :    * updated data points from the detector Preprocessors. The 'modules'
<span class="lineNum">     996 </span>            :    * argument contains all detectors for which the Preprocessors have
<span class="lineNum">     997 </span>            :    * updated data points. The component has to implement the CDB access to
<span class="lineNum">     998 </span>            :    * get the desired data points.
<span class="lineNum">     999 </span>            :    * @param modules     detectors for which the Preprocessors have updated
<span class="lineNum">    1000 </span>            :    *                    data points: TPC, TRD, ITS, PHOS, MUON, or ALL if
<span class="lineNum">    1001 </span>            :    *                    no argument was received.
<span class="lineNum">    1002 </span>            :    * @return neg. error code if failed
<span class="lineNum">    1003 </span>            :    */
<span class="lineNum">    1004 </span>            :   virtual int ReadPreprocessorValues(const char* modules);
<span class="lineNum">    1005 </span>            : 
<span class="lineNum">    1006 </span>            :   /**
<span class="lineNum">    1007 </span>            :    * Child implementation to scan a number of configuration arguments.
<span class="lineNum">    1008 </span>            :    * The method is invoked by the framework in conjunction with the
<span class="lineNum">    1009 </span>            :    * common framework functions ConfigureFromArgumentString and
<span class="lineNum">    1010 </span>            :    * ConfigureFromCDBTObjString.
<span class="lineNum">    1011 </span>            :    * Function needs to scan the argument and optional additional
<span class="lineNum">    1012 </span>            :    * parameters and returns the number of elements in the array which
<span class="lineNum">    1013 </span>            :    * have been treated.
<span class="lineNum">    1014 </span>            :    * @param argc
<span class="lineNum">    1015 </span>            :    * @param argv
<span class="lineNum">    1016 </span>            :    * @return number of arguments which have been scanned or neg error
<span class="lineNum">    1017 </span>            :    *         code if failed                                              &lt;br&gt;
<span class="lineNum">    1018 </span>            :    *         \li -EINVAL      unknown argument
<span class="lineNum">    1019 </span>            :    *         \li -EPROTO      protocol error, e.g. missing parameter
<span class="lineNum">    1020 </span>            :    */
<span class="lineNum">    1021 </span>            :   virtual int ScanConfigurationArgument(int argc, const char** argv);
<span class="lineNum">    1022 </span>            : 
<span class="lineNum">    1023 </span>            :   /**
<span class="lineNum">    1024 </span>            :    * Custom handler for the SOR event.
<span class="lineNum">    1025 </span>            :    * Is invoked from the base class if an SOR event is in the block list.
<span class="lineNum">    1026 </span>            :    * The handler is called before the processing function. The processing
<span class="lineNum">    1027 </span>            :    * function is skipped if there are no other data blocks available.
<span class="lineNum">    1028 </span>            :    *
<span class="lineNum">    1029 </span>            :    * The SOR event is generated by the PubSub framework in response to
<span class="lineNum">    1030 </span>            :    * the DAQ start of data (SOD - has been renamed after HLT interface
<span class="lineNum">    1031 </span>            :    * was designed). The SOD event consists of 3 blocks:
<span class="lineNum">    1032 </span>            :    * - ::kAliHLTDataTypeEvent block: spec ::gkAliEventTypeStartOfRun
<span class="lineNum">    1033 </span>            :    * - SOD block of type ::kAliHLTDataTypeSOR, payload: AliHLTRunDesc struct
<span class="lineNum">    1034 </span>            :    * - run type block ::kAliHLTDataTypeRunType, payload: run type string 
<span class="lineNum">    1035 </span>            :    *
<span class="lineNum">    1036 </span>            :    * Run properties can be retrieved by getters like GetRunNo().
<span class="lineNum">    1037 </span>            :    * @return neg. error code if failed
<span class="lineNum">    1038 </span>            :    */
<span class="lineNum">    1039 </span>            :   virtual int StartOfRun();
<span class="lineNum">    1040 </span>            : 
<span class="lineNum">    1041 </span>            :   /**
<span class="lineNum">    1042 </span>            :    * Custom handler for the EOR event.
<span class="lineNum">    1043 </span>            :    * Is invoked from the base class if an EOR event is in the block list.
<span class="lineNum">    1044 </span>            :    * The handler is called before the processing function. The processing
<span class="lineNum">    1045 </span>            :    * function is skipped if there are no other data blocks available.
<span class="lineNum">    1046 </span>            :    *
<span class="lineNum">    1047 </span>            :    * See StartOfRun() for more comments of the sequence of steering events.
<span class="lineNum">    1048 </span>            :    *
<span class="lineNum">    1049 </span>            :    * @return neg. error code if failed
<span class="lineNum">    1050 </span>            :    */
<span class="lineNum">    1051 </span>            :   virtual int EndOfRun();
<span class="lineNum">    1052 </span>            : 
<span class="lineNum">    1053 </span>            :   /**
<span class="lineNum">    1054 </span>            :    * Check whether a component requires all steering blocks.
<span class="lineNum">    1055 </span>            :    * Childs can overload in order to indicate that they want to
<span class="lineNum">    1056 </span>            :    * receive also the steering data blocks. There is also the
<span class="lineNum">    1057 </span>            :    * possibility to add the required data types to the input
<a name="1058"><span class="lineNum">    1058 </span>            :    * data type list in GetInputDataTypes().</a>
<span class="lineNum">    1059 </span>            :    */
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :   virtual bool RequireSteeringBlocks() const {return false;}</span>
<span class="lineNum">    1061 </span>            : 
<span class="lineNum">    1062 </span>            :   /**
<span class="lineNum">    1063 </span>            :    * General memory allocation method.
<span class="lineNum">    1064 </span>            :    * All memory which is going to be used 'outside' of the interface must
<span class="lineNum">    1065 </span>            :    * be provided by the framework (online or offline).
<span class="lineNum">    1066 </span>            :    * The method is redirected to a function provided by the current
<span class="lineNum">    1067 </span>            :    * framework. Function pointers are transferred via the @ref
<span class="lineNum">    1068 </span>            :    * AliHLTAnalysisEnvironment structure.
<span class="lineNum">    1069 </span>            :    */
<span class="lineNum">    1070 </span>            :   void* AllocMemory( unsigned long size );
<span class="lineNum">    1071 </span>            : 
<span class="lineNum">    1072 </span>            :   /**
<span class="lineNum">    1073 </span>            :    * Helper function to create a monolithic BlockData description block out
<span class="lineNum">    1074 </span>            :    * of a list BlockData descriptors.
<span class="lineNum">    1075 </span>            :    * For convenience, inside the interface vector lists are used, to make the
<span class="lineNum">    1076 </span>            :    * interface pure C style, monilithic blocks must be exchanged. 
<span class="lineNum">    1077 </span>            :    * The method is redirected to a function provided by the current
<span class="lineNum">    1078 </span>            :    * framework. Function pointers are transferred via the @ref
<span class="lineNum">    1079 </span>            :    * AliHLTAnalysisEnvironment structure.
<span class="lineNum">    1080 </span>            :    */
<span class="lineNum">    1081 </span>            :   int MakeOutputDataBlockList( const AliHLTComponentBlockDataList&amp; blocks, AliHLTUInt32_t* blockCount,
<span class="lineNum">    1082 </span>            :                                AliHLTComponentBlockData** outputBlocks );
<span class="lineNum">    1083 </span>            : 
<span class="lineNum">    1084 </span>            :   /**
<span class="lineNum">    1085 </span>            :    * Fill the EventDoneData structure.
<span class="lineNum">    1086 </span>            :    * The method is redirected to a function provided by the current
<span class="lineNum">    1087 </span>            :    * framework. Function pointers are transferred via the @ref
<span class="lineNum">    1088 </span>            :    * AliHLTAnalysisEnvironment structure.
<span class="lineNum">    1089 </span>            :    */
<span class="lineNum">    1090 </span>            :   int GetEventDoneData( unsigned long size, AliHLTComponentEventDoneData** edd ) const;
<span class="lineNum">    1091 </span>            : 
<span class="lineNum">    1092 </span>            :   /**
<span class="lineNum">    1093 </span>            :    * Allocate an EventDoneData structure for the current event .
<span class="lineNum">    1094 </span>            :    * The method allocates the memory internally and does not interact with the current Framework.
<span class="lineNum">    1095 </span>            :    * The allocated data structure is empty initially and can be filled by calls to the 
<span class="lineNum">    1096 </span>            :    * @ref PushEventDoneData method. The memory will be automatically released after the event has been processed.
<span class="lineNum">    1097 </span>            :    * 
<span class="lineNum">    1098 </span>            :    */
<span class="lineNum">    1099 </span>            :   int ReserveEventDoneData( unsigned long size );
<span class="lineNum">    1100 </span>            : 
<span class="lineNum">    1101 </span>            :   /**
<span class="lineNum">    1102 </span>            :    * Push a 32 bit word of data into event done data for the current event which
<span class="lineNum">    1103 </span>            :    * has previously been allocated by the @ref ReserveEventDoneData method.
<span class="lineNum">    1104 </span>            :    */
<span class="lineNum">    1105 </span>            :   int PushEventDoneData( AliHLTUInt32_t eddDataWord );
<span class="lineNum">    1106 </span>            : 
<span class="lineNum">    1107 </span>            :   /**
<span class="lineNum">    1108 </span>            :    * Release event done data previously reserved by @ref ReserveEventDoneData
<span class="lineNum">    1109 </span>            :    */
<span class="lineNum">    1110 </span>            :    void ReleaseEventDoneData();
<span class="lineNum">    1111 </span>            : 
<span class="lineNum">    1112 </span>            :   /**
<span class="lineNum">    1113 </span>            :    * Get the pointer to the event done data available/built so far for the current event via
<a name="1114"><span class="lineNum">    1114 </span>            :    * @ref ReserveEventDoneData and @ref PushEventDoneData</a>
<span class="lineNum">    1115 </span>            :    */
<span class="lineNum">    1116 </span>            :   AliHLTComponentEventDoneData* GetCurrentEventDoneData() const
<span class="lineNum">    1117 </span>            :     {
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :     return fEventDoneData;</span>
<span class="lineNum">    1119 </span>            :     }
<span class="lineNum">    1120 </span>            : 
<span class="lineNum">    1121 </span>            :   /**
<span class="lineNum">    1122 </span>            :    * Helper function to convert the data type to a string.
<span class="lineNum">    1123 </span>            :    */
<span class="lineNum">    1124 </span>            :   void DataType2Text(const AliHLTComponentDataType&amp; type, char output[kAliHLTComponentDataTypefIDsize+kAliHLTComponentDataTypefOriginSize+2]) const;
<span class="lineNum">    1125 </span>            : 
<span class="lineNum">    1126 </span>            :   /**
<span class="lineNum">    1127 </span>            :    * Loop through a list of component arguments.
<span class="lineNum">    1128 </span>            :    * The list can be either an array of separated strings or one single
<span class="lineNum">    1129 </span>            :    * string containing blank separated arguments, or both mixed.
<span class="lineNum">    1130 </span>            :    * ScanConfigurationArgument() is called to allow the component to treat
<span class="lineNum">    1131 </span>            :    * the individual arguments.
<span class="lineNum">    1132 </span>            :    * @return neg. error code if failed
<span class="lineNum">    1133 </span>            :    */
<span class="lineNum">    1134 </span>            :   int ConfigureFromArgumentString(int argc, const char** argv);
<span class="lineNum">    1135 </span>            : 
<span class="lineNum">    1136 </span>            :   /**
<span class="lineNum">    1137 </span>            :    * Read configuration objects from OCDB and configure from
<span class="lineNum">    1138 </span>            :    * the content of TObjString entries.
<span class="lineNum">    1139 </span>            :    * @param entries   blank separated list of OCDB paths
<span class="lineNum">    1140 </span>            :    * @param key       if the entry is a TMap, search for the corresponding object
<span class="lineNum">    1141 </span>            :    * @defaultToEmptyString if OCDB object does not exist, we assume an empty configuration string and do continue
<span class="lineNum">    1142 </span>            :    * @return neg. error code if failed
<span class="lineNum">    1143 </span>            :    */
<span class="lineNum">    1144 </span>            :   int ConfigureFromCDBTObjString(const char* entries, const char* key=NULL, bool defaultToEmptyString = false);
<span class="lineNum">    1145 </span>            : 
<span class="lineNum">    1146 </span>            :   /**
<span class="lineNum">    1147 </span>            :    * Load specified entry from the OCDB and extract the object.
<span class="lineNum">    1148 </span>            :    * The entry is explicitely unloaded from the cache before it is loaded.
<span class="lineNum">    1149 </span>            :    * If parameter key is specified the OCDB object is treated as TMap
<span class="lineNum">    1150 </span>            :    * and the TObject associated with 'key' is loaded.
<span class="lineNum">    1151 </span>            :    * @param path      path of the entry under to root of the OCDB
<span class="lineNum">    1152 </span>            :    * @param version   version of the entry
<span class="lineNum">    1153 </span>            :    * @param subVersion  subversion of the entry
<span class="lineNum">    1154 </span>            :    * @param key       key of the object within TMap
<span class="lineNum">    1155 </span>            :    */
<span class="lineNum">    1156 </span>            :   TObject* LoadAndExtractOCDBObject(const char* path, const char* key=NULL) const;
<span class="lineNum">    1157 </span>            : 
<span class="lineNum">    1158 </span>            :   /**
<span class="lineNum">    1159 </span>            :    * Get event number.
<span class="lineNum">    1160 </span>            :    * @return value of the internal event counter
<span class="lineNum">    1161 </span>            :    */
<span class="lineNum">    1162 </span>            :   int GetEventCount() const;
<span class="lineNum">    1163 </span>            : 
<span class="lineNum">    1164 </span>            :   /**
<span class="lineNum">    1165 </span>            :    * Get the number of input blocks.
<span class="lineNum">    1166 </span>            :    * @return number of input blocks
<span class="lineNum">    1167 </span>            :    */
<span class="lineNum">    1168 </span>            :   int GetNumberOfInputBlocks() const;
<span class="lineNum">    1169 </span>            : 
<span class="lineNum">    1170 </span>            :   /**
<span class="lineNum">    1171 </span>            :    * Get id of the current event
<span class="lineNum">    1172 </span>            :    * @return event id
<span class="lineNum">    1173 </span>            :    */
<span class="lineNum">    1174 </span>            :   AliHLTEventID_t GetEventId() const;
<span class="lineNum">    1175 </span>            : 
<span class="lineNum">    1176 </span>            :   /**
<span class="lineNum">    1177 </span>            :    * Get the first object of a specific data type from the input data.
<span class="lineNum">    1178 </span>            :    * The High-level methods provide functionality to transfer ROOT data
<span class="lineNum">    1179 </span>            :    * structures which inherit from TObject.
<span class="lineNum">    1180 </span>            :    *
<span class="lineNum">    1181 </span>            :    * The method looks for the first ROOT object of type dt in the input stream.
<span class="lineNum">    1182 </span>            :    * If also the class name is provided, the object is checked for the right
<span class="lineNum">    1183 </span>            :    * class type. The input data block needs a certain structure, namely the 
<span class="lineNum">    1184 </span>            :    * buffer size as first word. If the cross check fails, the retrieval is
<span class="lineNum">    1185 </span>            :    * silently abandoned, unless the \em bForce parameter is set.&lt;br&gt;
<span class="lineNum">    1186 </span>            :    * \b Note: THE OBJECT MUST NOT BE DELETED by the caller.
<span class="lineNum">    1187 </span>            :    *
<span class="lineNum">    1188 </span>            :    * If called without parameters, the function tries to create objects from
<span class="lineNum">    1189 </span>            :    * all available input blocks, also the ones of data type kAliHLTVoidDataType
<span class="lineNum">    1190 </span>            :    * which are not matched by kAliHLTAnyDataType.
<span class="lineNum">    1191 </span>            :    *
<span class="lineNum">    1192 </span>            :    * @param dt          data type of the object
<span class="lineNum">    1193 </span>            :    * @param classname   class name of the object
<span class="lineNum">    1194 </span>            :    * @param bForce      force the retrieval of an object, error messages
<span class="lineNum">    1195 </span>            :    *                    are suppressed if \em bForce is not set
<span class="lineNum">    1196 </span>            :    * @return pointer to @ref TObject, NULL if no objects of specified type
<span class="lineNum">    1197 </span>            :    *         available
<span class="lineNum">    1198 </span>            :    */
<span class="lineNum">    1199 </span>            :   const TObject* GetFirstInputObject(const AliHLTComponentDataType&amp; dt=kAliHLTAllDataTypes,
<span class="lineNum">    1200 </span>            :                                      const char* classname=NULL,
<span class="lineNum">    1201 </span>            :                                      int bForce=0);
<span class="lineNum">    1202 </span>            : 
<span class="lineNum">    1203 </span>            :   /**
<span class="lineNum">    1204 </span>            :    * Get the first object of a specific data type from the input data.
<span class="lineNum">    1205 </span>            :    * The High-level methods provide functionality to transfer ROOT data
<span class="lineNum">    1206 </span>            :    * structures which inherit from TObject.
<span class="lineNum">    1207 </span>            :    * The method looks for the first ROOT object of type specified by the ID and 
<span class="lineNum">    1208 </span>            :    * Origin strings in the input stream.
<span class="lineNum">    1209 </span>            :    * If also the class name is provided, the object is checked for the right
<span class="lineNum">    1210 </span>            :    * class type. The input data block needs a certain structure, namely the 
<span class="lineNum">    1211 </span>            :    * buffer size as first word. If the cross check fails, the retrieval is
<span class="lineNum">    1212 </span>            :    * silently abandoned, unless the \em bForce parameter is set.&lt;br&gt;
<span class="lineNum">    1213 </span>            :    * \em Note: THE OBJECT MUST NOT BE DELETED by the caller.
<span class="lineNum">    1214 </span>            :    * @param dtID        data type ID of the object
<span class="lineNum">    1215 </span>            :    * @param dtOrigin    data type origin of the object
<span class="lineNum">    1216 </span>            :    * @param classname   class name of the object
<span class="lineNum">    1217 </span>            :    * @param bForce      force the retrieval of an object, error messages
<span class="lineNum">    1218 </span>            :    *                    are suppressed if \em bForce is not set
<span class="lineNum">    1219 </span>            :    * @return pointer to @ref TObject, NULL if no objects of specified type
<span class="lineNum">    1220 </span>            :    *         available
<span class="lineNum">    1221 </span>            :    */
<span class="lineNum">    1222 </span>            :   const TObject* GetFirstInputObject(const char* dtID, 
<span class="lineNum">    1223 </span>            :                                      const char* dtOrigin,
<span class="lineNum">    1224 </span>            :                                      const char* classname=NULL,
<span class="lineNum">    1225 </span>            :                                      int bForce=0);
<span class="lineNum">    1226 </span>            : 
<span class="lineNum">    1227 </span>            :   /**
<span class="lineNum">    1228 </span>            :    * Get the next object of a specific data type from the input data.
<span class="lineNum">    1229 </span>            :    * The High-level methods provide functionality to transfer ROOT data
<span class="lineNum">    1230 </span>            :    * structures which inherit from TObject.
<span class="lineNum">    1231 </span>            :    * The method looks for the next ROOT object of type and class specified
<span class="lineNum">    1232 </span>            :    * to the previous @ref GetFirstInputObject call.&lt;br&gt;
<span class="lineNum">    1233 </span>            :    * \em Note: THE OBJECT MUST NOT BE DELETED by the caller.
<span class="lineNum">    1234 </span>            :    * @param bForce      force the retrieval of an object, error messages
<span class="lineNum">    1235 </span>            :    *                    are suppressed if \em bForce is not set
<span class="lineNum">    1236 </span>            :    * @return pointer to @ref TObject, NULL if no more objects available
<span class="lineNum">    1237 </span>            :    */
<span class="lineNum">    1238 </span>            :   const TObject* GetNextInputObject(int bForce=0);
<span class="lineNum">    1239 </span>            :   
<span class="lineNum">    1240 </span>            :   /**
<span class="lineNum">    1241 </span>            :    * Get an object from an input block whose number you already know.
<span class="lineNum">    1242 </span>            :    * In fact, this calls GetInputObject on that block, and returns
<span class="lineNum">    1243 </span>            :    * a const pointer
<span class="lineNum">    1244 </span>            :    */
<span class="lineNum">    1245 </span>            :   const TObject* GetInputObjectFromIndex(const int idx, const char* classname=NULL, int bforce=0);
<span class="lineNum">    1246 </span>            :   
<span class="lineNum">    1247 </span>            :   /**
<span class="lineNum">    1248 </span>            :    * Removes a TObject from the list of objects automatically deleted
<span class="lineNum">    1249 </span>            :    * after the event processing function DoEvent. Objects obtained via
<span class="lineNum">    1250 </span>            :    * GetFirstInputObject etc. are placed there and cleaned up afterwards.
<span class="lineNum">    1251 </span>            :    * With these function, the component &quot;takes ownership&quot; and has to make
<span class="lineNum">    1252 </span>            :    * sure the object is cleaned up properly by itself. Returns a non-const
<span class="lineNum">    1253 </span>            :    * pointer on success and NULL otherwise
<span class="lineNum">    1254 </span>            :    */
<span class="lineNum">    1255 </span>            :   
<span class="lineNum">    1256 </span>            :   TObject* RemoveInputObjectFromCleanupList(const TObject* obj);
<span class="lineNum">    1257 </span>            : 
<span class="lineNum">    1258 </span>            :   /**
<span class="lineNum">    1259 </span>            :    * Get data type of an input block.
<span class="lineNum">    1260 </span>            :    * Get data type of the object previously fetched via
<span class="lineNum">    1261 </span>            :    * GetFirstInputObject/NextInputObject or the last one if no object
<span class="lineNum">    1262 </span>            :    * specified.
<span class="lineNum">    1263 </span>            :    * @param pObject     pointer to TObject
<span class="lineNum">    1264 </span>            :    * @return data specification, kAliHLTVoidDataSpec if failed
<span class="lineNum">    1265 </span>            :    */
<span class="lineNum">    1266 </span>            :   AliHLTComponentDataType GetDataType(const TObject* pObject=NULL);
<span class="lineNum">    1267 </span>            : 
<span class="lineNum">    1268 </span>            :   /**
<span class="lineNum">    1269 </span>            :    * Get data specification of an input block.
<span class="lineNum">    1270 </span>            :    * Get data specification of the object previously fetched via
<span class="lineNum">    1271 </span>            :    * GetFirstInputObject/NextInputObject or the last one if no object
<span class="lineNum">    1272 </span>            :    * specified.
<span class="lineNum">    1273 </span>            :    * @param pObject     pointer to TObject
<span class="lineNum">    1274 </span>            :    * @return data specification, kAliHLTVoidDataSpec if failed
<span class="lineNum">    1275 </span>            :    */
<span class="lineNum">    1276 </span>            :   AliHLTUInt32_t GetSpecification(const TObject* pObject=NULL);
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span>            :   /**
<span class="lineNum">    1279 </span>            :    * Get the first block of a specific data type from the input data.
<span class="lineNum">    1280 </span>            :    * The method looks for the first block of type dt in the input stream.
<span class="lineNum">    1281 </span>            :    * It is intended to be used within the high-level interface.&lt;br&gt;
<span class="lineNum">    1282 </span>            :    * \em Note: THE BLOCK DESCRIPTOR MUST NOT BE DELETED by the caller.
<span class="lineNum">    1283 </span>            :    *
<span class="lineNum">    1284 </span>            :    * If called without parameters, the function works on all input blocks,
<span class="lineNum">    1285 </span>            :    * also the ones of data type kAliHLTVoidDataType which are not matched by
<span class="lineNum">    1286 </span>            :    * kAliHLTAnyDataType.
<span class="lineNum">    1287 </span>            :    *
<span class="lineNum">    1288 </span>            :    * @param dt          data type of the block
<span class="lineNum">    1289 </span>            :    * @return pointer to @ref AliHLTComponentBlockData
<span class="lineNum">    1290 </span>            :    */
<span class="lineNum">    1291 </span>            :   const AliHLTComponentBlockData* GetFirstInputBlock(const AliHLTComponentDataType&amp; dt=kAliHLTAllDataTypes);
<span class="lineNum">    1292 </span>            : 
<span class="lineNum">    1293 </span>            :   /**
<span class="lineNum">    1294 </span>            :    * Get the first block of a specific data type from the input data.
<span class="lineNum">    1295 </span>            :    * The method looks for the first block of type specified by the ID and 
<span class="lineNum">    1296 </span>            :    * Origin strings in the input stream.  It is intended
<span class="lineNum">    1297 </span>            :    * to be used within the high-level interface.&lt;br&gt;
<span class="lineNum">    1298 </span>            :    * \em Note: THE BLOCK DESCRIPTOR MUST NOT BE DELETED by the caller.
<span class="lineNum">    1299 </span>            :    * @param dtID        data type ID of the block
<span class="lineNum">    1300 </span>            :    * @param dtOrigin    data type origin of the block
<span class="lineNum">    1301 </span>            :    * @return pointer to @ref AliHLTComponentBlockData
<span class="lineNum">    1302 </span>            :    */
<span class="lineNum">    1303 </span>            :   const AliHLTComponentBlockData* GetFirstInputBlock(const char* dtID, 
<span class="lineNum">    1304 </span>            :                                                       const char* dtOrigin);
<span class="lineNum">    1305 </span>            : 
<span class="lineNum">    1306 </span>            :   /**
<span class="lineNum">    1307 </span>            :    * Get input block by index.&lt;br&gt;
<span class="lineNum">    1308 </span>            :    * \em Note: THE BLOCK DESCRIPTOR MUST NOT BE DELETED by the caller.
<span class="lineNum">    1309 </span>            :    * @return pointer to AliHLTComponentBlockData, NULL if index out of range
<span class="lineNum">    1310 </span>            :    */
<span class="lineNum">    1311 </span>            :   const AliHLTComponentBlockData* GetInputBlock(int index) const;
<span class="lineNum">    1312 </span>            : 
<span class="lineNum">    1313 </span>            :   /**
<span class="lineNum">    1314 </span>            :    * Get the next block of a specific data type from the input data.
<span class="lineNum">    1315 </span>            :    * The method looks for the next block  of type and class specified
<span class="lineNum">    1316 </span>            :    * to the previous @ref GetFirstInputBlock call.
<span class="lineNum">    1317 </span>            :    * To be used within the high-level interface.&lt;br&gt;
<span class="lineNum">    1318 </span>            :    * \em Note: THE BLOCK DESCRIPTOR MUST NOT BE DELETED by the caller.
<span class="lineNum">    1319 </span>            :    */
<span class="lineNum">    1320 </span>            :   const AliHLTComponentBlockData* GetNextInputBlock();
<span class="lineNum">    1321 </span>            :   
<span class="lineNum">    1322 </span>            :   /**
<span class="lineNum">    1323 </span>            :    * Returns the index of the last input block obtained via
<span class="lineNum">    1324 </span>            :    * GetFirstInputBlock or GetFirstInputObject.
<span class="lineNum">    1325 </span>            :    */
<span class="lineNum">    1326 </span>            :   int GetCurrentInputBlockIndex();
<span class="lineNum">    1327 </span>            : 
<span class="lineNum">    1328 </span>            :   /**
<span class="lineNum">    1329 </span>            :    * Get data specification of an input block.
<span class="lineNum">    1330 </span>            :    * Get data specification of the input block previously fetched via
<span class="lineNum">    1331 </span>            :    * GetFirstInputObject/NextInputObject or the last one if no block
<span class="lineNum">    1332 </span>            :    * specified.
<span class="lineNum">    1333 </span>            :    * @param pBlock     pointer to input block
<span class="lineNum">    1334 </span>            :    * @return data specification, kAliHLTVoidDataSpec if failed
<span class="lineNum">    1335 </span>            :    */
<span class="lineNum">    1336 </span>            :   AliHLTUInt32_t GetSpecification(const AliHLTComponentBlockData* pBlock);
<span class="lineNum">    1337 </span>            : 
<span class="lineNum">    1338 </span>            :   /**
<span class="lineNum">    1339 </span>            :    * Forward an input object to the output.
<span class="lineNum">    1340 </span>            :    * Forward the input block of an object previously fetched via
<span class="lineNum">    1341 </span>            :    * GetFirstInputObject/NextInputObject or the last one if no object
<span class="lineNum">    1342 </span>            :    * specified.
<span class="lineNum">    1343 </span>            :    * The block descriptor of the input block is forwarded to the
<span class="lineNum">    1344 </span>            :    * output block list.
<span class="lineNum">    1345 </span>            :    * @param pObject     pointer to TObject
<span class="lineNum">    1346 </span>            :    * @return neg. error code if failed
<span class="lineNum">    1347 </span>            :    */
<span class="lineNum">    1348 </span>            :   int Forward(const TObject* pObject);
<span class="lineNum">    1349 </span>            : 
<span class="lineNum">    1350 </span>            :   /**
<span class="lineNum">    1351 </span>            :    * Forward an input block to the output.
<span class="lineNum">    1352 </span>            :    * Forward the input block fetched via GetFirstInputObject/
<span class="lineNum">    1353 </span>            :    * NextInputBlock or the last one if no block specified.
<span class="lineNum">    1354 </span>            :    * The block descriptor of the input block is forwarded to the
<span class="lineNum">    1355 </span>            :    * output block list.
<span class="lineNum">    1356 </span>            :    * @param pBlock     pointer to input block
<span class="lineNum">    1357 </span>            :    * @return neg. error code if failed
<span class="lineNum">    1358 </span>            :    */
<span class="lineNum">    1359 </span>            :   int Forward(const AliHLTComponentBlockData* pBlock=NULL);
<span class="lineNum">    1360 </span>            : 
<span class="lineNum">    1361 </span>            :   /**
<span class="lineNum">    1362 </span>            :    * Insert a string in the output
<span class="lineNum">    1363 </span>            :    * If header is specified, it will be inserted before the root object,
<span class="lineNum">    1364 </span>            :    * default is no header.
<span class="lineNum">    1365 </span>            :    * The publishing can be downscaled by means of the -pushback-period
<span class="lineNum">    1366 </span>            :    * parameter. This is especially useful for histograms which do not
<span class="lineNum">    1367 </span>            :    * need to be sent for every event. At EOR data is always pushed.
<span class="lineNum">    1368 </span>            :    * @param pString     pointer to string
<span class="lineNum">    1369 </span>            :    * @param dt          data type of the object
<span class="lineNum">    1370 </span>            :    * @param spec        data specification
<span class="lineNum">    1371 </span>            :    * @param pHeader     pointer to header
<span class="lineNum">    1372 </span>            :    * @param headerSize  size of Header
<span class="lineNum">    1373 </span>            :    * @return neg. error code if failed 
<span class="lineNum">    1374 </span>            :    */
<span class="lineNum">    1375 </span>            :   int PushBack(const std::string&amp; string, const AliHLTComponentDataType&amp; dt, 
<span class="lineNum">    1376 </span>            :                AliHLTUInt32_t spec=kAliHLTVoidDataSpec, 
<span class="lineNum">    1377 </span>            :                void* pHeader=NULL, int headerSize=0);
<span class="lineNum">    1378 </span>            : 
<span class="lineNum">    1379 </span>            :   /**
<span class="lineNum">    1380 </span>            :    * Insert an object into the output.
<span class="lineNum">    1381 </span>            :    * If header is specified, it will be inserted before the root object,
<span class="lineNum">    1382 </span>            :    * default is no header.
<span class="lineNum">    1383 </span>            :    * The publishing can be downscaled by means of the -pushback-period
<span class="lineNum">    1384 </span>            :    * parameter. This is especially useful for histograms which do not
<span class="lineNum">    1385 </span>            :    * need to be sent for every event. At EOR data is always pushed.
<span class="lineNum">    1386 </span>            :    * @param pObject     pointer to root object
<span class="lineNum">    1387 </span>            :    * @param dt          data type of the object
<span class="lineNum">    1388 </span>            :    * @param spec        data specification
<span class="lineNum">    1389 </span>            :    * @param pHeader     pointer to header
<span class="lineNum">    1390 </span>            :    * @param headerSize  size of Header
<span class="lineNum">    1391 </span>            :    * @return neg. error code if failed 
<span class="lineNum">    1392 </span>            :    */
<span class="lineNum">    1393 </span>            :   int PushBack(const TObject* pObject, const AliHLTComponentDataType&amp; dt, 
<span class="lineNum">    1394 </span>            :                AliHLTUInt32_t spec=kAliHLTVoidDataSpec, 
<span class="lineNum">    1395 </span>            :                void* pHeader=NULL, int headerSize=0);
<span class="lineNum">    1396 </span>            : 
<span class="lineNum">    1397 </span>            :   /**
<span class="lineNum">    1398 </span>            :    * Checks whether the Pushback period has expired, i.e. if the
<span class="lineNum">    1399 </span>            :    * compoenent will push back data.
<span class="lineNum">    1400 </span>            :    */
<span class="lineNum">    1401 </span>            :   bool CheckPushbackPeriod();
<span class="lineNum">    1402 </span>            :   
<span class="lineNum">    1403 </span>            :   /**
<span class="lineNum">    1404 </span>            :    * Insert an object into the output.
<span class="lineNum">    1405 </span>            :    * If header is specified, it will be inserted before the root object,
<span class="lineNum">    1406 </span>            :    * default is no header.
<span class="lineNum">    1407 </span>            :    * The publishing can be downscaled by means of the -pushback-period
<span class="lineNum">    1408 </span>            :    * parameter. This is especially useful for histograms which do not
<span class="lineNum">    1409 </span>            :    * need to be sent for every event. At EOR data is always pushed.
<span class="lineNum">    1410 </span>            :    * @param pObject     pointer to root object
<span class="lineNum">    1411 </span>            :    * @param dtID        data type ID of the object
<span class="lineNum">    1412 </span>            :    * @param dtOrigin    data type origin of the object
<span class="lineNum">    1413 </span>            :    * @param spec        data specification
<span class="lineNum">    1414 </span>            :    * @param pHeader     pointer to header
<span class="lineNum">    1415 </span>            :    * @param headerSize  size of Header
<span class="lineNum">    1416 </span>            :    * @return neg. error code if failed 
<span class="lineNum">    1417 </span>            :    */
<span class="lineNum">    1418 </span>            :   int PushBack(const TObject* pObject, const char* dtID, const char* dtOrigin,
<span class="lineNum">    1419 </span>            :                AliHLTUInt32_t spec=kAliHLTVoidDataSpec,
<span class="lineNum">    1420 </span>            :                void* pHeader=NULL, int headerSize=0);
<span class="lineNum">    1421 </span>            :  
<span class="lineNum">    1422 </span>            :   /**
<span class="lineNum">    1423 </span>            :    * Insert an object into the output.
<span class="lineNum">    1424 </span>            :    * @param pBuffer     pointer to buffer
<span class="lineNum">    1425 </span>            :    * @param iSize       size of the buffer
<span class="lineNum">    1426 </span>            :    * @param dt          data type of the object
<span class="lineNum">    1427 </span>            :    * @param spec        data specification
<span class="lineNum">    1428 </span>            :    * @param pHeader     pointer to header
<span class="lineNum">    1429 </span>            :    * @param headerSize size of Header
<span class="lineNum">    1430 </span>            :    * @return neg. error code if failed 
<span class="lineNum">    1431 </span>            :    */
<span class="lineNum">    1432 </span>            :   int PushBack(const void* pBuffer, int iSize, const AliHLTComponentDataType&amp; dt,
<span class="lineNum">    1433 </span>            :                AliHLTUInt32_t spec=kAliHLTVoidDataSpec,
<span class="lineNum">    1434 </span>            :                const void* pHeader=NULL, int headerSize=0);
<span class="lineNum">    1435 </span>            : 
<span class="lineNum">    1436 </span>            :   /**
<span class="lineNum">    1437 </span>            :    * Insert an object into the output.
<span class="lineNum">    1438 </span>            :    * @param pBuffer     pointer to buffer
<span class="lineNum">    1439 </span>            :    * @param iSize       size of the buffer
<span class="lineNum">    1440 </span>            :    * @param dtID        data type ID of the object
<span class="lineNum">    1441 </span>            :    * @param dtOrigin    data type origin of the object
<span class="lineNum">    1442 </span>            :    * @param spec        data specification
<span class="lineNum">    1443 </span>            :    * @param pHeader     pointer to header
<span class="lineNum">    1444 </span>            :    * @param headerSize size of Header
<span class="lineNum">    1445 </span>            :    * @return neg. error code if failed 
<span class="lineNum">    1446 </span>            :    */
<span class="lineNum">    1447 </span>            :   int PushBack(const void* pBuffer, int iSize, const char* dtID, const char* dtOrigin,
<span class="lineNum">    1448 </span>            :                AliHLTUInt32_t spec=kAliHLTVoidDataSpec,
<span class="lineNum">    1449 </span>            :                const void* pHeader=NULL, int headerSize=0);
<span class="lineNum">    1450 </span>            : 
<span class="lineNum">    1451 </span>            :   /**
<span class="lineNum">    1452 </span>            :    * Estimate size of a TObject
<span class="lineNum">    1453 </span>            :    * @param pObject
<span class="lineNum">    1454 </span>            :    * @return buffer size in byte
<span class="lineNum">    1455 </span>            :    */
<span class="lineNum">    1456 </span>            :   int EstimateObjectSize(const TObject* pObject) const;
<span class="lineNum">    1457 </span>            : 
<span class="lineNum">    1458 </span>            :   /**
<span class="lineNum">    1459 </span>            :    * Create a memory file in the output stream.
<span class="lineNum">    1460 </span>            :    * This method creates a TFile object which stores all data in
<span class="lineNum">    1461 </span>            :    * memory instead of disk. The TFile object is published as binary data.
<span class="lineNum">    1462 </span>            :    * The instance can be used like a normal TFile object. The TFile::Close
<span class="lineNum">    1463 </span>            :    * or @ref CloseMemoryFile method has to be called in order to flush the
<span class="lineNum">    1464 </span>            :    * output stream.
<span class="lineNum">    1465 </span>            :    *
<span class="lineNum">    1466 </span>            :    * \b Note: The returned object is deleted by the framework.
<span class="lineNum">    1467 </span>            :    * @param capacity    total size reserved for the memory file
<span class="lineNum">    1468 </span>            :    * @param dtID        data type ID of the file
<span class="lineNum">    1469 </span>            :    * @param dtOrigin    data type origin of the file
<span class="lineNum">    1470 </span>            :    * @param spec        data specification
<span class="lineNum">    1471 </span>            :    * @return file handle, NULL if failed 
<span class="lineNum">    1472 </span>            :    */
<span class="lineNum">    1473 </span>            :   AliHLTMemoryFile* CreateMemoryFile(int capacity, const char* dtID, const char* dtOrigin,
<span class="lineNum">    1474 </span>            :                                      AliHLTUInt32_t spec=kAliHLTVoidDataSpec);
<span class="lineNum">    1475 </span>            : 
<span class="lineNum">    1476 </span>            :   /**
<span class="lineNum">    1477 </span>            :    * Create a memory file in the output stream.
<span class="lineNum">    1478 </span>            :    * This method creates a TFile object which stores all data in
<span class="lineNum">    1479 </span>            :    * memory instead of disk. The TFile object is published as binary data.
<span class="lineNum">    1480 </span>            :    * The instance can be used like a normal TFile object. The TFile::Close
<span class="lineNum">    1481 </span>            :    * or @ref CloseMemoryFile method has to be called in order to flush the
<span class="lineNum">    1482 </span>            :    * output stream.
<span class="lineNum">    1483 </span>            :    *
<span class="lineNum">    1484 </span>            :    * \b Note: The returned object is deleted by the framework.
<span class="lineNum">    1485 </span>            :    * @param capacity    total size reserved for the memory file
<span class="lineNum">    1486 </span>            :    * @param dt          data type of the file
<span class="lineNum">    1487 </span>            :    * @param spec        data specification
<span class="lineNum">    1488 </span>            :    * @return file handle, NULL if failed 
<span class="lineNum">    1489 </span>            :    */
<span class="lineNum">    1490 </span>            :   AliHLTMemoryFile* CreateMemoryFile(int capacity, 
<span class="lineNum">    1491 </span>            :                                      const AliHLTComponentDataType&amp; dt=kAliHLTAnyDataType,
<span class="lineNum">    1492 </span>            :                                      AliHLTUInt32_t spec=kAliHLTVoidDataSpec);
<span class="lineNum">    1493 </span>            : 
<span class="lineNum">    1494 </span>            :   /**
<span class="lineNum">    1495 </span>            :    * Create a memory file in the output stream.
<span class="lineNum">    1496 </span>            :    * This method creates a TFile object which stores all data in
<span class="lineNum">    1497 </span>            :    * memory instead of disk. The TFile object is published as binary data.
<span class="lineNum">    1498 </span>            :    * The instance can be used like a normal TFile object. The TFile::Close
<span class="lineNum">    1499 </span>            :    * or @ref CloseMemoryFile method has to be called in order to flush the
<span class="lineNum">    1500 </span>            :    * output stream.
<span class="lineNum">    1501 </span>            :    *
<span class="lineNum">    1502 </span>            :    * \b Note: The returned object is deleted by the framework.
<span class="lineNum">    1503 </span>            :    * @param dtID        data type ID of the file
<span class="lineNum">    1504 </span>            :    * @param dtOrigin    data type origin of the file
<span class="lineNum">    1505 </span>            :    * @param spec        data specification
<span class="lineNum">    1506 </span>            :    * @param capacity    fraction of the available output buffer size
<span class="lineNum">    1507 </span>            :    * @return file handle, NULL if failed 
<span class="lineNum">    1508 </span>            :    */
<span class="lineNum">    1509 </span>            :   AliHLTMemoryFile* CreateMemoryFile(const char* dtID, const char* dtOrigin,
<span class="lineNum">    1510 </span>            :                                      AliHLTUInt32_t spec=kAliHLTVoidDataSpec,
<span class="lineNum">    1511 </span>            :                                      float capacity=1.0);
<span class="lineNum">    1512 </span>            : 
<span class="lineNum">    1513 </span>            :   /**
<span class="lineNum">    1514 </span>            :    * Create a memory file in the output stream.
<span class="lineNum">    1515 </span>            :    * This method creates a TFile object which stores all data in
<span class="lineNum">    1516 </span>            :    * memory instead of disk. The TFile object is published as binary data.
<span class="lineNum">    1517 </span>            :    * The instance can be used like a normal TFile object. The TFile::Close
<span class="lineNum">    1518 </span>            :    * or @ref CloseMemoryFile method has to be called in order to flush the
<span class="lineNum">    1519 </span>            :    * output stream.
<span class="lineNum">    1520 </span>            :    *
<span class="lineNum">    1521 </span>            :    * \b Note: The returned object is deleted by the framework.
<span class="lineNum">    1522 </span>            :    * @param dt          data type of the file
<span class="lineNum">    1523 </span>            :    * @param spec        data specification
<span class="lineNum">    1524 </span>            :    * @param capacity    fraction of the available output buffer size
<span class="lineNum">    1525 </span>            :    * @return file handle, NULL if failed 
<span class="lineNum">    1526 </span>            :    */
<span class="lineNum">    1527 </span>            :   AliHLTMemoryFile* CreateMemoryFile(const AliHLTComponentDataType&amp; dt=kAliHLTAnyDataType,
<span class="lineNum">    1528 </span>            :                                      AliHLTUInt32_t spec=kAliHLTVoidDataSpec,
<span class="lineNum">    1529 </span>            :                                      float capacity=1.0);
<span class="lineNum">    1530 </span>            : 
<span class="lineNum">    1531 </span>            :   /**
<span class="lineNum">    1532 </span>            :    * Write an object to memory file in the output stream.
<span class="lineNum">    1533 </span>            :    * @param pFile       file handle
<span class="lineNum">    1534 </span>            :    * @param pObject     pointer to root object
<span class="lineNum">    1535 </span>            :    * @param key         key in ROOT file
<span class="lineNum">    1536 </span>            :    * @param option      options, see TObject::Write
<span class="lineNum">    1537 </span>            :    * @return neg. error code if failed
<span class="lineNum">    1538 </span>            :    *         - -ENOSPC    no space left
<span class="lineNum">    1539 </span>            :    */
<span class="lineNum">    1540 </span>            :   int Write(AliHLTMemoryFile* pFile, const TObject* pObject, const char* key=NULL, int option=TObject::kOverwrite);
<span class="lineNum">    1541 </span>            : 
<span class="lineNum">    1542 </span>            :   /**
<span class="lineNum">    1543 </span>            :    * Close object memory file.
<span class="lineNum">    1544 </span>            :    * @param pFile       file handle
<span class="lineNum">    1545 </span>            :    * @return neg. error code if failed
<span class="lineNum">    1546 </span>            :    *         - -ENOSPC    buffer size too small
<span class="lineNum">    1547 </span>            :    */
<span class="lineNum">    1548 </span>            :   int CloseMemoryFile(AliHLTMemoryFile* pFile);
<span class="lineNum">    1549 </span>            : 
<span class="lineNum">    1550 </span>            :   /**
<span class="lineNum">    1551 </span>            :    * Insert event-done data information into the output.
<span class="lineNum">    1552 </span>            :    * @param edd          event-done data information
<span class="lineNum">    1553 </span>            :    */
<span class="lineNum">    1554 </span>            :   int CreateEventDoneData(AliHLTComponentEventDoneData edd);
<span class="lineNum">    1555 </span>            : 
<span class="lineNum">    1556 </span>            :   /**
<span class="lineNum">    1557 </span>            :    * Get current run number
<span class="lineNum">    1558 </span>            :    */
<span class="lineNum">    1559 </span>            :   AliHLTUInt32_t GetRunNo() const;
<span class="lineNum">    1560 </span>            : 
<span class="lineNum">    1561 </span>            :   /**
<span class="lineNum">    1562 </span>            :    * Get the current run type.
<span class="lineNum">    1563 </span>            :    */
<span class="lineNum">    1564 </span>            :   AliHLTUInt32_t GetRunType() const;
<span class="lineNum">    1565 </span>            : 
<span class="lineNum">    1566 </span>            :   /**
<a name="1567"><span class="lineNum">    1567 </span>            :    * Get the chain id of the component.</a>
<span class="lineNum">    1568 </span>            :    */
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :   const char* GetChainId() const {return fChainId.c_str();}</span>
<span class="lineNum">    1570 </span>            : 
<span class="lineNum">    1571 </span>            :   /**
<span class="lineNum">    1572 </span>            :    * Get a timestamp of the current event
<span class="lineNum">    1573 </span>            :    * Exact format needs to be documented.
<span class="lineNum">    1574 </span>            :    */
<span class="lineNum">    1575 </span>            :   AliHLTUInt32_t    GetTimeStamp() const;
<span class="lineNum">    1576 </span>            : 
<span class="lineNum">    1577 </span>            :   /**
<span class="lineNum">    1578 </span>            :    * Get the period number.
<span class="lineNum">    1579 </span>            :    * Upper 28 bits (36 to 63) of the 64-bit event id 
<span class="lineNum">    1580 </span>            :    */
<span class="lineNum">    1581 </span>            :   AliHLTUInt32_t    GetPeriodNumber() const;
<span class="lineNum">    1582 </span>            : 
<span class="lineNum">    1583 </span>            :   /**
<span class="lineNum">    1584 </span>            :    * Get the period number.
<span class="lineNum">    1585 </span>            :    * 24 bits, 12 to 35 of the 64-bit event id 
<span class="lineNum">    1586 </span>            :    */
<span class="lineNum">    1587 </span>            :   AliHLTUInt32_t    GetOrbitNumber() const;
<span class="lineNum">    1588 </span>            : 
<span class="lineNum">    1589 </span>            :   /**
<span class="lineNum">    1590 </span>            :    * Get the bunch crossing number.
<span class="lineNum">    1591 </span>            :    * 12 bits, 0 to 12 of the 64-bit event id 
<span class="lineNum">    1592 </span>            :    */
<span class="lineNum">    1593 </span>            :   AliHLTUInt16_t    GetBunchCrossNumber() const;
<span class="lineNum">    1594 </span>            : 
<span class="lineNum">    1595 </span>            :   /**
<span class="lineNum">    1596 </span>            :    * Setup the CTP accounting functionality of the base class.
<span class="lineNum">    1597 </span>            :    * The method can be invoked from DoInit() for componenets which want to
<span class="lineNum">    1598 </span>            :    * use the CTP functionality of the base class.
<span class="lineNum">    1599 </span>            :    *
<span class="lineNum">    1600 </span>            :    * The AliHLTCTPData is initialized with the trigger classes from the ECS
<span class="lineNum">    1601 </span>            :    * parameters. The base class automatically increments the counters according
<span class="lineNum">    1602 </span>            :    * to the trigger pattern in the CDH before the event processing. 
<span class="lineNum">    1603 </span>            :    */
<span class="lineNum">    1604 </span>            :   int SetupCTPData();
<span class="lineNum">    1605 </span>            : 
<span class="lineNum">    1606 </span>            :   /**
<a name="1607"><span class="lineNum">    1607 </span>            :    * Get the instance of the CTP data.</a>
<span class="lineNum">    1608 </span>            :    */
<span class="lineNum">    1609 </span><span class="lineNoCov">          0 :   const AliHLTCTPData* CTPData() const {return fpCTPData;}</span>
<span class="lineNum">    1610 </span>            : 
<span class="lineNum">    1611 </span>            :   /**
<span class="lineNum">    1612 </span>            :    * Check whether a combination of trigger classes is fired.
<span class="lineNum">    1613 </span>            :    * The expression can contain trigger class ids and logic operators
<span class="lineNum">    1614 </span>            :    * like &amp;&amp;, ||, !, and ^, and may be grouped by parentheses.
<span class="lineNum">    1615 </span>            :    * @note the function requires the setup of the CTP handling for the component by
<span class="lineNum">    1616 </span>            :    * invoking SetupCTPData() from DoInit()
<span class="lineNum">    1617 </span>            :    * @param expression     a logic expression of trigger class ids
<span class="lineNum">    1618 </span>            :    * @param trigData       the trigger data data
<span class="lineNum">    1619 </span>            :    */
<span class="lineNum">    1620 </span>            :   bool EvaluateCTPTriggerClass(const char* expression, AliHLTComponentTriggerData&amp; trigData) const;
<span class="lineNum">    1621 </span>            : 
<span class="lineNum">    1622 </span>            :   /**
<span class="lineNum">    1623 </span>            :    * Check state of a trigger class.
<span class="lineNum">    1624 </span>            :    * If the class name is not part of the current trigger setup (i.e. ECS parameter
<span class="lineNum">    1625 </span>            :    * does not contain a trigger definition for this class name) the function
<span class="lineNum">    1626 </span>            :    * returns -1
<span class="lineNum">    1627 </span>            :    * @note the function requires the setup of the CTP handling for the component by
<span class="lineNum">    1628 </span>            :    * invoking SetupCTPData() from DoInit()
<span class="lineNum">    1629 </span>            :    * @return -1 class name not initialized, 
<span class="lineNum">    1630 </span>            :    *          0 trigger not active
<span class="lineNum">    1631 </span>            :    *          1 trigger active
<span class="lineNum">    1632 </span>            :    */
<span class="lineNum">    1633 </span>            :   int CheckCTPTrigger(const char* name) const;
<span class="lineNum">    1634 </span>            : 
<span class="lineNum">    1635 </span>            :   /**
<span class="lineNum">    1636 </span>            :    * Get the overall solenoid field.
<span class="lineNum">    1637 </span>            :    */
<span class="lineNum">    1638 </span>            :   Double_t GetBz();
<span class="lineNum">    1639 </span>            :   /**
<span class="lineNum">    1640 </span>            :    * Get the solenoid field at point r.
<span class="lineNum">    1641 </span>            :    */
<span class="lineNum">    1642 </span>            :   Double_t GetBz(const Double_t *r);
<span class="lineNum">    1643 </span>            :   /**
<span class="lineNum">    1644 </span>            :    * Get the solenoid field components at point r.
<span class="lineNum">    1645 </span>            :    */
<span class="lineNum">    1646 </span>            :   void GetBxByBz(const Double_t r[3], Double_t b[3]);
<span class="lineNum">    1647 </span>            : 
<span class="lineNum">    1648 </span>            :   /**
<span class="lineNum">    1649 </span>            :    * Check whether the current event is a valid data event.
<span class="lineNum">    1650 </span>            :    * @param pTgt    optional pointer to get the event type
<span class="lineNum">    1651 </span>            :    * @return true if the current event is a real data event
<span class="lineNum">    1652 </span>            :    */
<span class="lineNum">    1653 </span>            :   bool IsDataEvent(AliHLTUInt32_t* pTgt=NULL) const;
<span class="lineNum">    1654 </span>            : 
<span class="lineNum">    1655 </span>            :   /**
<span class="lineNum">    1656 </span>            :    * Copy a struct from block data.
<span class="lineNum">    1657 </span>            :    * The function checks for block size and struct size. The least common
<span class="lineNum">    1658 </span>            :    * size will be copied to the target struct, remaining fields are initialized
<span class="lineNum">    1659 </span>            :    * to zero.&lt;br&gt;
<span class="lineNum">    1660 </span>            :    * The target struct must have a 32bit struct size indicator as first member.
<span class="lineNum">    1661 </span>            :    * @param pStruct     target struct
<span class="lineNum">    1662 </span>            :    * @param iStructSize size of the struct
<span class="lineNum">    1663 </span>            :    * @param iBlockNo    index of input block
<span class="lineNum">    1664 </span>            :    * @param structname  name of the struct (log messages)
<span class="lineNum">    1665 </span>            :    * @param eventname   name of the event (log messages)
<span class="lineNum">    1666 </span>            :    * @return size copied, neg. error if failed
<span class="lineNum">    1667 </span>            :    */
<span class="lineNum">    1668 </span>            :   int CopyStruct(void* pStruct, unsigned int iStructSize, unsigned int iBlockNo,
<span class="lineNum">    1669 </span>            :                  const char* structname=&quot;&quot;, const char* eventname=&quot;&quot;);
<span class="lineNum">    1670 </span>            : 
<span class="lineNum">    1671 </span>            :  private:
<span class="lineNum">    1672 </span>            :   /** copy constructor prohibited */
<span class="lineNum">    1673 </span>            :   AliHLTComponent(const AliHLTComponent&amp;);
<span class="lineNum">    1674 </span>            :   /** assignment operator prohibited */
<span class="lineNum">    1675 </span>            :   AliHLTComponent&amp; operator=(const AliHLTComponent&amp;);
<span class="lineNum">    1676 </span>            : 
<span class="lineNum">    1677 </span>            :   /**
<span class="lineNum">    1678 </span>            :    * Increment the internal event counter.
<span class="lineNum">    1679 </span>            :    * To be used by the friend classes AliHLTProcessor, AliHLTDataSource
<span class="lineNum">    1680 </span>            :    * and AliHLTDataSink.
<span class="lineNum">    1681 </span>            :    * @return new value of the internal event counter
<span class="lineNum">    1682 </span>            :    * @internal
<span class="lineNum">    1683 </span>            :    */
<span class="lineNum">    1684 </span>            :   int IncrementEventCounter();
<span class="lineNum">    1685 </span>            : 
<span class="lineNum">    1686 </span>            :   /**
<span class="lineNum">    1687 </span>            :    * Find the first input block of specified data type beginning at index.
<span class="lineNum">    1688 </span>            :    * Input blocks containing a TObject have the size of the object as an
<span class="lineNum">    1689 </span>            :    * unsigned 32 bit number in the first 4 bytes. This has to match the block
<span class="lineNum">    1690 </span>            :    * size minus 4.
<span class="lineNum">    1691 </span>            :    *
<span class="lineNum">    1692 </span>            :    * kAliHLTAllDataTypes is a special data type which includes both 
<span class="lineNum">    1693 </span>            :    * kAliHLTVoidDataType and kAliHLTAnyDataType.
<span class="lineNum">    1694 </span>            :    *
<span class="lineNum">    1695 </span>            :    * @param dt          data type
<span class="lineNum">    1696 </span>            :    * @param startIdx    index to start the search
<span class="lineNum">    1697 </span>            :    * @param bObject     check if this is an object
<span class="lineNum">    1698 </span>            :    * @return index of the block, -ENOENT if no block found
<span class="lineNum">    1699 </span>            :    *
<span class="lineNum">    1700 </span>            :    * @internal
<span class="lineNum">    1701 </span>            :    */
<span class="lineNum">    1702 </span>            :   int FindInputBlock(const AliHLTComponentDataType&amp; dt, int startIdx=-1, int bObject=0) const;
<span class="lineNum">    1703 </span>            : 
<span class="lineNum">    1704 </span>            :   /**
<span class="lineNum">    1705 </span>            :    * Get index in the array of input bocks.
<span class="lineNum">    1706 </span>            :    * Calculate index and check integrety of a block data structure pointer.
<span class="lineNum">    1707 </span>            :    * @param pBlock      pointer to block data
<span class="lineNum">    1708 </span>            :    * @return index of the block, -ENOENT if no block found
<span class="lineNum">    1709 </span>            :    *
<span class="lineNum">    1710 </span>            :    * @internal
<span class="lineNum">    1711 </span>            :    */
<span class="lineNum">    1712 </span>            :   int FindInputBlock(const AliHLTComponentBlockData* pBlock) const;
<span class="lineNum">    1713 </span>            : 
<span class="lineNum">    1714 </span>            :   /**
<span class="lineNum">    1715 </span>            :    * Create an object from a specified input block.
<span class="lineNum">    1716 </span>            :    * @param idx         index of the input block
<span class="lineNum">    1717 </span>            :    * @param bForce      force the retrieval of an object, error messages
<span class="lineNum">    1718 </span>            :    *                    are suppressed if \em bForce is not set
<span class="lineNum">    1719 </span>            :    * @return pointer to TObject, caller must delete the object after use
<span class="lineNum">    1720 </span>            :    *
<span class="lineNum">    1721 </span>            :    * @internal
<span class="lineNum">    1722 </span>            :    */
<span class="lineNum">    1723 </span>            :   TObject* CreateInputObject(int idx, int bForce=0);
<span class="lineNum">    1724 </span>            : 
<span class="lineNum">    1725 </span>            :   /**
<span class="lineNum">    1726 </span>            :    * Get input object
<span class="lineNum">    1727 </span>            :    * Get object from the input block list. The methods first checks whether the
<span class="lineNum">    1728 </span>            :    * object was already created. If not, it is created by @ref CreateInputObject
<span class="lineNum">    1729 </span>            :    * and inserted into the list of objects.
<span class="lineNum">    1730 </span>            :    * @param idx         index in the input block list
<span class="lineNum">    1731 </span>            :    * @param classname   name of the class, object is checked for correct class
<span class="lineNum">    1732 </span>            :    *                    name if set
<span class="lineNum">    1733 </span>            :    * @param bForce      force the retrieval of an object, error messages
<span class="lineNum">    1734 </span>            :    *                    are suppressed if \em bForce is not set
<span class="lineNum">    1735 </span>            :    * @return pointer to TObject
<span class="lineNum">    1736 </span>            :    *
<span class="lineNum">    1737 </span>            :    * @internal
<span class="lineNum">    1738 </span>            :    */
<span class="lineNum">    1739 </span>            :   TObject* GetInputObject(int idx, const char* classname=NULL, int bForce=0);
<span class="lineNum">    1740 </span>            : 
<span class="lineNum">    1741 </span>            :   /**
<span class="lineNum">    1742 </span>            :    * Clean the list of input objects.
<span class="lineNum">    1743 </span>            :    * Cleanup is done at the end of each event processing.
<span class="lineNum">    1744 </span>            :    */
<span class="lineNum">    1745 </span>            :   int CleanupInputObjects();
<span class="lineNum">    1746 </span>            : 
<span class="lineNum">    1747 </span>            :   /**
<span class="lineNum">    1748 </span>            :    * Insert a buffer into the output block stream.
<span class="lineNum">    1749 </span>            :    * This is the only method to insert blocks into the output stream, called
<span class="lineNum">    1750 </span>            :    * from all types of the Pushback method. The actual data might have been
<span class="lineNum">    1751 </span>            :    * written to the output buffer already. In that case NULL can be provided
<span class="lineNum">    1752 </span>            :    * as buffer, only the block descriptor will be build. If a header is specified, 
<span class="lineNum">    1753 </span>            :    * it will be inserted before the buffer, default is no header.
<span class="lineNum">    1754 </span>            :    * @param pBuffer     pointer to buffer
<span class="lineNum">    1755 </span>            :    * @param iBufferSize size of the buffer in byte
<span class="lineNum">    1756 </span>            :    * @param dt          data type
<span class="lineNum">    1757 </span>            :    * @param spec        data specification
<span class="lineNum">    1758 </span>            :    * @param pHeader     pointer to header
<span class="lineNum">    1759 </span>            :    * @param iHeaderSize size of Header
<span class="lineNum">    1760 </span>            :    * @return size of buffer
<span class="lineNum">    1761 </span>            :    * @return neg. error code if failed
<span class="lineNum">    1762 </span>            :    */
<span class="lineNum">    1763 </span>            :   int InsertOutputBlock(const void* pBuffer, int iBufferSize,
<span class="lineNum">    1764 </span>            :                         const AliHLTComponentDataType&amp; dt,
<span class="lineNum">    1765 </span>            :                         AliHLTUInt32_t spec,
<span class="lineNum">    1766 </span>            :                         const void* pHeader=NULL, int iHeaderSize=0);
<span class="lineNum">    1767 </span>            : 
<span class="lineNum">    1768 </span>            :   /**
<span class="lineNum">    1769 </span>            :    * Add a component statistics block to the output.
<span class="lineNum">    1770 </span>            :    * @return size of the added data
<span class="lineNum">    1771 </span>            :    */
<span class="lineNum">    1772 </span>            :   int AddComponentStatistics(AliHLTComponentBlockDataList&amp; blocks, 
<span class="lineNum">    1773 </span>            :                              AliHLTUInt8_t* buffer,
<span class="lineNum">    1774 </span>            :                              AliHLTUInt32_t bufferSize,
<span class="lineNum">    1775 </span>            :                              AliHLTUInt32_t offset,
<span class="lineNum">    1776 </span>            :                              AliHLTComponentStatisticsList&amp; stats) const;
<span class="lineNum">    1777 </span>            : 
<span class="lineNum">    1778 </span>            :   /**
<span class="lineNum">    1779 </span>            :    * Add a component table entry (descriptor) to the output
<span class="lineNum">    1780 </span>            :    * This is done at SOR/EOR. The component table is a list of chain ids
<span class="lineNum">    1781 </span>            :    * and 32bit ids calculated by a crc algorithm from the chian id. This
<span class="lineNum">    1782 </span>            :    * allows to tag data blocks with the id number rather than the string.
<span class="lineNum">    1783 </span>            :    *
<span class="lineNum">    1784 </span>            :    * The kAliHLTDataTypeComponentTable data block currently has the string
<span class="lineNum">    1785 </span>            :    * as payload and the crc id as specification.
<span class="lineNum">    1786 </span>            :    * @return size of the added data
<span class="lineNum">    1787 </span>            :    */
<span class="lineNum">    1788 </span>            :   int  AddComponentTableEntry(AliHLTComponentBlockDataList&amp; blocks, 
<span class="lineNum">    1789 </span>            :                               AliHLTUInt8_t* buffer,
<span class="lineNum">    1790 </span>            :                               AliHLTUInt32_t bufferSize,
<span class="lineNum">    1791 </span>            :                               AliHLTUInt32_t offset,
<span class="lineNum">    1792 </span>            :                               const vector&lt;AliHLTUInt32_t&gt;&amp; parents,
<span class="lineNum">    1793 </span>            :                               int processingLevel) const;
<span class="lineNum">    1794 </span>            : 
<span class="lineNum">    1795 </span>            :   /**
<span class="lineNum">    1796 </span>            :    * Scan the ECS parameter string.
<span class="lineNum">    1797 </span>            :    * The framework provides both the parameters of CONFIGURE and ENGAGE
<span class="lineNum">    1798 </span>            :    * in one string in a special data block kAliHLTDataTypeECSParam
<span class="lineNum">    1799 </span>            :    * {ECSPARAM:PRIV}. The general format is
<span class="lineNum">    1800 </span>            :    * &lt;command&gt;;&lt;parameterkey&gt;=&lt;parametervalue&gt;;&lt;parameterkey&gt;=&lt;parametervalue&gt;;...
<span class="lineNum">    1801 </span>            :    */
<span class="lineNum">    1802 </span>            :   int ScanECSParam(const char* ecsParam);
<span class="lineNum">    1803 </span>            : 
<span class="lineNum">    1804 </span>            :   /**
<span class="lineNum">    1805 </span>            :    * The trigger classes are determined from the trigger and propagated by
<span class="lineNum">    1806 </span>            :    * ECS as part of the ENGAGE command parameter which is sent through the
<span class="lineNum">    1807 </span>            :    * framework during the SOR event. This function treats the value of the
<span class="lineNum">    1808 </span>            :    * parameter key CTP_TRIGGER_CLASS.
<span class="lineNum">    1809 </span>            :    */
<span class="lineNum">    1810 </span>            :   int InitCTPTriggerClasses(const char* ctpString);
<span class="lineNum">    1811 </span>            : 
<span class="lineNum">    1812 </span>            :   enum {
<span class="lineNum">    1813 </span>            :     kRequireSteeringBlocks = 0x1,
<span class="lineNum">    1814 </span>            :     kDisableComponentStat = 0x2
<span class="lineNum">    1815 </span>            :   };
<span class="lineNum">    1816 </span>            : 
<span class="lineNum">    1817 </span>            :   /** The global component handler instance */
<span class="lineNum">    1818 </span>            :   static AliHLTComponentHandler* fgpComponentHandler;              //! transient
<span class="lineNum">    1819 </span>            : 
<span class="lineNum">    1820 </span>            :   /** The environment where the component is running in */
<span class="lineNum">    1821 </span>            :   AliHLTAnalysisEnvironment fEnvironment;                         // see above
<span class="lineNum">    1822 </span>            : 
<span class="lineNum">    1823 </span>            :   /** Set by ProcessEvent before the processing starts */
<span class="lineNum">    1824 </span>            :   AliHLTEventID_t fCurrentEvent;                                   // see above
<span class="lineNum">    1825 </span>            : 
<span class="lineNum">    1826 </span>            :   /** internal event no */
<span class="lineNum">    1827 </span>            :   int fEventCount;                                                 // see above
<span class="lineNum">    1828 </span>            : 
<span class="lineNum">    1829 </span>            :   /** the number of failed events */
<span class="lineNum">    1830 </span>            :   int fFailedEvents;                                               // see above
<span class="lineNum">    1831 </span>            : 
<span class="lineNum">    1832 </span>            :   /** event data struct of the current event under processing */
<span class="lineNum">    1833 </span>            :   AliHLTComponentEventData fCurrentEventData;                      // see above
<span class="lineNum">    1834 </span>            : 
<span class="lineNum">    1835 </span>            :   /** array of input data blocks of the current event */
<span class="lineNum">    1836 </span>            :   const AliHLTComponentBlockData* fpInputBlocks;                   //! transient
<span class="lineNum">    1837 </span>            : 
<span class="lineNum">    1838 </span>            :   /** index of the current input block */
<span class="lineNum">    1839 </span>            :   int fCurrentInputBlock;                                          // see above
<span class="lineNum">    1840 </span>            : 
<span class="lineNum">    1841 </span>            :   /** data type of the last block search */
<span class="lineNum">    1842 </span>            :   AliHLTComponentDataType fSearchDataType;                         // see above
<span class="lineNum">    1843 </span>            : 
<span class="lineNum">    1844 </span>            :   /** name of the class for the object to search for */
<span class="lineNum">    1845 </span>            :   string fClassName;                                               // see above
<span class="lineNum">    1846 </span>            : 
<span class="lineNum">    1847 </span>            :   /** array of generated input objects */
<span class="lineNum">    1848 </span>            :   TObjArray* fpInputObjects;                                       //! transient
<span class="lineNum">    1849 </span>            :  
<span class="lineNum">    1850 </span>            :   /** the output buffer */
<span class="lineNum">    1851 </span>            :   AliHLTUInt8_t* fpOutputBuffer;                                   //! transient
<span class="lineNum">    1852 </span>            : 
<span class="lineNum">    1853 </span>            :   /** size of the output buffer */
<span class="lineNum">    1854 </span>            :   AliHLTUInt32_t fOutputBufferSize;                                // see above
<span class="lineNum">    1855 </span>            : 
<span class="lineNum">    1856 </span>            :   /** size of data written to output buffer */
<span class="lineNum">    1857 </span>            :   AliHLTUInt32_t fOutputBufferFilled;                              // see above
<span class="lineNum">    1858 </span>            : 
<span class="lineNum">    1859 </span>            :   /** list of ouput block data descriptors */
<span class="lineNum">    1860 </span>            :   AliHLTComponentBlockDataList fOutputBlocks;                      // see above
<span class="lineNum">    1861 </span>            : 
<span class="lineNum">    1862 </span>            :   /** stopwatch array */
<span class="lineNum">    1863 </span>            :   TObjArray* fpStopwatches;                                        //! transient
<span class="lineNum">    1864 </span>            : 
<span class="lineNum">    1865 </span>            :   /** array of memory files AliHLTMemoryFile */
<span class="lineNum">    1866 </span>            :   AliHLTMemoryFilePList fMemFiles;                                 //! transient
<span class="lineNum">    1867 </span>            : 
<span class="lineNum">    1868 </span>            :   /** descriptor of the current run */
<span class="lineNum">    1869 </span>            :   AliHLTRunDesc* fpRunDesc;                                        //! transient
<span class="lineNum">    1870 </span>            : 
<span class="lineNum">    1871 </span>            :   /** external fct to set CDB run no, indicates external CDB initialization */
<span class="lineNum">    1872 </span>            :   void (*fCDBSetRunNoFunc)();                                      //! transient
<span class="lineNum">    1873 </span>            : 
<span class="lineNum">    1874 </span>            :   /** id of the component in the analysis chain */
<span class="lineNum">    1875 </span>            :   string fChainId;                                                 //! transient
<span class="lineNum">    1876 </span>            : 
<span class="lineNum">    1877 </span>            :   /** crc value of the chainid, used as a 32bit id */
<span class="lineNum">    1878 </span>            :   AliHLTUInt32_t fChainIdCrc;                                      //! transient
<span class="lineNum">    1879 </span>            : 
<span class="lineNum">    1880 </span>            :   /** optional benchmarking for the component statistics */
<span class="lineNum">    1881 </span>            :   TStopwatch* fpBenchmark;                                         //! transient
<span class="lineNum">    1882 </span>            : 
<span class="lineNum">    1883 </span>            :   /** component flags, cleared in Deinit */
<span class="lineNum">    1884 </span>            :   AliHLTUInt32_t fFlags;                                           //! transient
<span class="lineNum">    1885 </span>            : 
<span class="lineNum">    1886 </span>            :   /** current event type */
<span class="lineNum">    1887 </span>            :   AliHLTUInt32_t fEventType;                                       //! transient
<span class="lineNum">    1888 </span>            : 
<span class="lineNum">    1889 </span>            :   /** component arguments */
<span class="lineNum">    1890 </span>            :   string fComponentArgs;                                           //! transient
<span class="lineNum">    1891 </span>            : 
<span class="lineNum">    1892 </span>            : 
<span class="lineNum">    1893 </span>            :   /** event done data */
<span class="lineNum">    1894 </span>            :   AliHLTComponentEventDoneData* fEventDoneData;                    //! transient
<span class="lineNum">    1895 </span>            : 
<span class="lineNum">    1896 </span>            :   /** Reserved size of the memory stored at fEventDoneData */
<span class="lineNum">    1897 </span>            :   unsigned long fEventDoneDataSize;                                //! transient
<span class="lineNum">    1898 </span>            : 
<span class="lineNum">    1899 </span>            :   /** Comression level for ROOT objects */
<span class="lineNum">    1900 </span>            :   int fCompressionLevel;                                           //! transient
<span class="lineNum">    1901 </span>            : 
<span class="lineNum">    1902 </span>            :   /** size of last PushBack-serialized object */
<span class="lineNum">    1903 </span>            :   int fLastObjectSize;                                             //! transient
<span class="lineNum">    1904 </span>            : 
<span class="lineNum">    1905 </span>            :  /**  array of trigger class descriptors */
<span class="lineNum">    1906 </span>            :   AliHLTCTPData* fpCTPData;                                        //! transient
<span class="lineNum">    1907 </span>            : 
<span class="lineNum">    1908 </span>            :   /// update period for PushBack calls
<span class="lineNum">    1909 </span>            :   int fPushbackPeriod;                                             //! transient
<span class="lineNum">    1910 </span>            :   /// time of last executed PushBack
<span class="lineNum">    1911 </span>            :   int fLastPushBackTime;                                           //! transient
<span class="lineNum">    1912 </span>            :   
<span class="lineNum">    1913 </span>            :   /// Event modulo for down scaling the processing rate.
<span class="lineNum">    1914 </span>            :   int fEventModulo;                                                //! transient
<span class="lineNum">    1915 </span>            : 
<span class="lineNum">    1916 </span>            :   /// A map of ROOT streamer infos
<span class="lineNum">    1917 </span>            :   TList fSchema;                                                   //! transient
<span class="lineNum">    1918 </span>            : 
<span class="lineNum">    1919 </span>            :   /// How many schema updates are left
<span class="lineNum">    1920 </span>            :   Bool_t fUseSchema;                                               //! transient
<span class="lineNum">    1921 </span>            : 
<span class="lineNum">    1922 </span>            :   /// signal a change in the schema list
<a name="1923"><span class="lineNum">    1923 </span>            :   Bool_t fSchemaUpdated;                                           //! transient</a>
<span class="lineNum">    1924 </span>            : 
<span class="lineNum">    1925 </span><span class="lineCov">        126 :   ClassDef(AliHLTComponent, 0)</span>
<span class="lineNum">    1926 </span>            : };
<span class="lineNum">    1927 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
