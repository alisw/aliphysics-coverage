<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - HLT/MUON/OnlineAnalysis/AliHLTMUONHitReconstructor.h</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">HLT/MUON/OnlineAnalysis</a> - AliHLTMUONHitReconstructor.h<span style="font-size: 80%;"> (source / <a href="AliHLTMUONHitReconstructor.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">26</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">26</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : #ifndef ALIHLTMUONHITRECONSTRUCTOR_H</a>
<span class="lineNum">       2 </span>            : #define ALIHLTMUONHITRECONSTRUCTOR_H
<span class="lineNum">       3 </span>            : /* This file is property of and copyright by the ALICE HLT Project        *
<span class="lineNum">       4 </span>            :  * ALICE Experiment at CERN, All rights reserved.                         *
<span class="lineNum">       5 </span>            :  * See cxx source for full Copyright notice                               */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : // $Id$
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : ///////////////////////////////////////////////
<span class="lineNum">      10 </span>            : //Author : Indranil Das, SINP, INDIA
<span class="lineNum">      11 </span>            : //         Sukalyan Chattopadhyay, SINP, INDIA
<span class="lineNum">      12 </span>            : //         
<span class="lineNum">      13 </span>            : //Email :  indra.das@saha.ac.in
<span class="lineNum">      14 </span>            : //         sukalyan.chattopadhyay@saha.ac.in 
<span class="lineNum">      15 </span>            : ///////////////////////////////////////////////
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : #include &lt;map&gt;
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : #include &quot;AliHLTLogging.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;AliMUONTrackerDDLDecoder.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;AliMUONTrackerDDLDecoderEventHandler.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;AliHLTMUONDataTypes.h&quot;
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : #if __GNUC__ &amp;&amp; __GNUC__ &lt; 3
<span class="lineNum">      25 </span>            : #define std
<span class="lineNum">      26 </span>            : #endif
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : extern &quot;C&quot; struct AliHLTMUONRecHitStruct;
<span class="lineNum">      30 </span>            : extern &quot;C&quot; struct AliHLTMUONClusterStruct;
<span class="lineNum">      31 </span>            : extern &quot;C&quot; struct AliHLTMUONChannelStruct;
<span class="lineNum">      32 </span>            : typedef std::map&lt;AliHLTInt32_t, AliHLTInt32_t&gt; IdManuChannelToEntry;
<span class="lineNum">      33 </span>            : typedef IdManuChannelToEntry MaxEntryPerBusPatch;
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : class AliHLTMUONHitReconstructor : public AliHLTLogging
<span class="lineNum">      36 </span>            : {
<span class="lineNum">      37 </span>            : public:
<span class="lineNum">      38 </span>            :         
<span class="lineNum">      39 </span>            :         AliHLTMUONHitReconstructor();
<span class="lineNum">      40 </span>            :         virtual ~AliHLTMUONHitReconstructor(void);
<span class="lineNum">      41 </span>            :         
<span class="lineNum">      42 </span>            :         void SetLookUpTable(
<span class="lineNum">      43 </span>            :                         const AliHLTMUONHitRecoLutRow* lookupTable,
<span class="lineNum">      44 </span>            :                         const IdManuChannelToEntry* idToEntry,
<span class="lineNum">      45 </span>            :                         const MaxEntryPerBusPatch* maxEntryPerBP
<a name="46"><span class="lineNum">      46 </span>            :                 );</a>
<a name="47"><span class="lineNum">      47 </span>            :         </a>
<span class="lineNum">      48 </span><span class="lineNoCov">          0 :         void SetDCCut(AliHLTInt32_t dcCut) { fDCCut = dcCut; }</span>
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :         AliHLTInt32_t GetDCCut() const { return fDCCut; }</span>
<span class="lineNum">      50 </span>            :         
<span class="lineNum">      51 </span>            :         bool Run(
<span class="lineNum">      52 </span>            :                         AliHLTUInt32_t* rawData,
<span class="lineNum">      53 </span>            :                         AliHLTUInt32_t rawDataSize,
<span class="lineNum">      54 </span>            :                         AliHLTMUONRecHitStruct* const recHit,
<span class="lineNum">      55 </span>            :                         AliHLTUInt32_t&amp; nofHit
<span class="lineNum">      56 </span>            :                 );
<span class="lineNum">      57 </span>            :         
<span class="lineNum">      58 </span>            :         /**
<span class="lineNum">      59 </span>            :          * Fills the output clusters array with the extra cluster information generated.
<span class="lineNum">      60 </span>            :          * If the method GenerateClusterInfo(true) was not called, then no cluster information
<span class="lineNum">      61 </span>            :          * is generated and this method will not do anything.
<span class="lineNum">      62 </span>            :          * \param [out] clusters  This is the output array that will be filled.
<span class="lineNum">      63 </span>            :          * \param [in,out] nofClusters Initially this contains the maximum number of elements
<span class="lineNum">      64 </span>            :          *     that can be stored in the clusters array. The method will fill this with
<span class="lineNum">      65 </span>            :          *     the actual number of elements stored.
<span class="lineNum">      66 </span>            :          * \returns true if all elements were copied and false if there is not enough space in
<span class="lineNum">      67 </span>            :          *     the output array.
<span class="lineNum">      68 </span>            :          */
<span class="lineNum">      69 </span>            :         bool FillClusterData(AliHLTMUONClusterStruct* clusters, AliHLTUInt32_t&amp; nofClusters);
<span class="lineNum">      70 </span>            :         
<span class="lineNum">      71 </span>            :         /**
<span class="lineNum">      72 </span>            :          * Fills the output channels array with the extra channel information generated.
<span class="lineNum">      73 </span>            :          * If the method GenerateChannelInfo(true) was not called, then no extra channel
<span class="lineNum">      74 </span>            :          * information is generated and this method will not do anything.
<span class="lineNum">      75 </span>            :          * \param [out] channels  This is the output array that will be filled.
<span class="lineNum">      76 </span>            :          * \param [in,out] nofChannels Initially this contains the maximum number of elements
<span class="lineNum">      77 </span>            :          *     that can be stored in the channels array. The method will fill this with
<span class="lineNum">      78 </span>            :          *     the actual number of elements stored.
<span class="lineNum">      79 </span>            :          * \returns true if all elements were copied and false if there is not enough space in
<span class="lineNum">      80 </span>            :          *     the output array.
<span class="lineNum">      81 </span>            :          */
<span class="lineNum">      82 </span>            :         bool FillChannelData(AliHLTMUONChannelStruct* channels, AliHLTUInt32_t&amp; nofChannels);
<span class="lineNum">      83 </span>            :         
<span class="lineNum">      84 </span>            :         static AliHLTInt32_t GetkDetectorId() { return fgkDetectorId; }
<span class="lineNum">      85 </span>            :         static AliHLTInt32_t GetkDDLOffSet() { return fgkDDLOffSet; }
<span class="lineNum">      86 </span>            :         static AliHLTInt32_t GetkNofDDL() { return fgkNofDDL; }
<span class="lineNum">      87 </span>            :         static AliHLTInt32_t GetkDDLHeaderSize() { return fgkDDLHeaderSize; }
<span class="lineNum">      88 </span>            :         static AliHLTInt32_t GetkNofDetElemInDDL(Int_t iDDL);
<span class="lineNum">      89 </span>            :         static AliHLTInt32_t GetkMinDetElemIdInDDL(Int_t iDDL);
<span class="lineNum">      90 </span>            :         
<span class="lineNum">      91 </span>            :         /// The error recovery mode used for TryRecover.
<span class="lineNum">      92 </span>            :         enum ERecoveryMode
<span class="lineNum">      93 </span>            :         {
<span class="lineNum">      94 </span>            :                 kDontTryRecover = 0,  /// Will not try recover from errors.
<span class="lineNum">      95 </span>            :                 kRecoverFull,  /// Try recover from all errors.
<span class="lineNum">      96 </span>            :                 kRecoverJustSkip,  /// Just skip any corrupt structures.
<span class="lineNum">      97 </span>            :                 kRecoverFromParityErrorsOnly  /// Recover only from parity errors.
<span class="lineNum">      98 </span>            :         };
<span class="lineNum">      99 </span>            :         
<span class="lineNum">     100 </span>            :         /// Returns the recovery mode used for the TryRecover option.
<a name="101"><span class="lineNum">     101 </span>            :         /// This controls if the decoder is set to enable recovery logic if</a>
<span class="lineNum">     102 </span>            :         /// raw data errors are found.
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :         ERecoveryMode TryRecover() const { return fRecoveryMode; }</span>
<span class="lineNum">     104 </span>            :         
<span class="lineNum">     105 </span>            :         /// Sets if the decoder should enable the error recovery logic and how.
<span class="lineNum">     106 </span>            :         void TryRecover(ERecoveryMode mode);
<span class="lineNum">     107 </span>            :         
<span class="lineNum">     108 </span>            :         /// Returns true if ADC digits with parity errors are skipped.
<span class="lineNum">     109 </span>            :         bool SkipParityErrors() const { return fHLTMUONDecoder.GetHandler().SkipParityErrors(); }
<a name="110"><span class="lineNum">     110 </span>            :         </a>
<span class="lineNum">     111 </span>            :         /// Sets the flag indicating if ADC digits with parity errors are skipped.
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :         void SkipParityErrors(bool value) { fHLTMUONDecoder.GetHandler().SkipParityErrors(value); }</span>
<span class="lineNum">     113 </span>            :         
<span class="lineNum">     114 </span>            :         /// Returns true if messages about parity errors are not printed.
<span class="lineNum">     115 </span>            :         bool DontPrintParityErrors() const { return fHLTMUONDecoder.GetHandler().DontPrintParityErrors(); }
<a name="116"><span class="lineNum">     116 </span>            :         </a>
<span class="lineNum">     117 </span>            :         /// Sets the flag indicating if messages about parity errors are not printed.
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :         void DontPrintParityErrors(bool value) { fHLTMUONDecoder.GetHandler().DontPrintParityErrors(value); }</span>
<a name="119"><span class="lineNum">     119 </span>            :         </a>
<span class="lineNum">     120 </span>            :         /// Returns true if the extra cluster information should be generated.
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :         bool GenerateClusterInfo() const { return fGenerateClusterInfo; }</span>
<a name="122"><span class="lineNum">     122 </span>            :         </a>
<span class="lineNum">     123 </span>            :         /// Sets the flag to indicate if the extra cluster information should be generated.
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :         void GenerateClusterInfo(bool value) { fGenerateClusterInfo = value; }</span>
<a name="125"><span class="lineNum">     125 </span>            :         </a>
<span class="lineNum">     126 </span>            :         /// Returns true if the extra channel information should be generated.
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :         bool GenerateChannelInfo() const { return fGenerateChannelInfo; }</span>
<a name="128"><span class="lineNum">     128 </span>            :         </a>
<span class="lineNum">     129 </span>            :         /// Sets the flag to indicate if the extra channel information should be generated.
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :         void GenerateChannelInfo(bool value) { fGenerateChannelInfo = value; }</span>
<span class="lineNum">     131 </span>            :         
<span class="lineNum">     132 </span>            :         /// Returns the maximum channel multiplicity allowed per cluster.
<span class="lineNum">     133 </span>            :         bool MaxChannelMultiplicity() const { return fMaxChannelMult; }
<span class="lineNum">     134 </span>            :         
<span class="lineNum">     135 </span>            :         /// Sets the maximum channel multiplicity allowed per cluster.
<span class="lineNum">     136 </span>            :         /// \note This effects the memory allocation required. Generally M*N number of
<span class="lineNum">     137 </span>            :         ///   channel structures will be allocated, where M = fMaxChannelMult and
<span class="lineNum">     138 </span>            :         ///   N = the maximum number of hits that can be filled into the output buffers.
<span class="lineNum">     139 </span>            :         void MaxChannelMultiplicity(bool value) { fMaxChannelMult = value; }
<span class="lineNum">     140 </span>            :         
<span class="lineNum">     141 </span>            :         /// Returns the DDL number the component expects data to be received from.
<span class="lineNum">     142 </span>            :         AliHLTInt32_t DDLNumber() const { return fDDL; }
<a name="143"><span class="lineNum">     143 </span>            :         </a>
<span class="lineNum">     144 </span>            :         /// Sets the DDL number the component expects data to be received from.
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :         void DDLNumber(AliHLTInt32_t value) { fDDL = (value &amp; 0x1F); }  // 0x1F forces value into our required range.</span>
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span>            :         bool InitDetElemInDDLArray();
<span class="lineNum">     148 </span>            :         bool DeInitDetElemInDDLArray();
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span>            : private:
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            :         static const AliHLTInt32_t fgkDetectorId;      // DDL Offset
<span class="lineNum">     153 </span>            :         static const AliHLTInt32_t fgkDDLOffSet;       // DDL Offset
<span class="lineNum">     154 </span>            :         static const AliHLTInt32_t fgkNofDDL;          // Number of DDL 
<span class="lineNum">     155 </span>            :         static const AliHLTInt32_t fgkDDLHeaderSize;   // DDL header size
<span class="lineNum">     156 </span>            :         static const AliHLTInt32_t fgkLutLine;         // nof Line in LookupTable
<span class="lineNum">     157 </span>            :         static const AliHLTInt32_t fgkMaxNofDataPerDetElem;         // maximum allowed data points per detlem
<span class="lineNum">     158 </span>            :         static const AliHLTInt32_t fgkNofDetElemInDDL[20] ;         // nof Detelem in a given ddl
<span class="lineNum">     159 </span>            :         static const AliHLTInt32_t fgkMinDetElemIdInDDL[20] ;       // the detelem which has minimum value in ddl
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            :         AliHLTMUONHitReconstructor(const AliHLTMUONHitReconstructor&amp; rhs); // copy constructor
<span class="lineNum">     162 </span>            :         AliHLTMUONHitReconstructor&amp; operator=(const AliHLTMUONHitReconstructor&amp; rhs); // assignment operator
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            :         struct AliHLTMUONPad
<span class="lineNum">     165 </span>            :         {
<span class="lineNum">     166 </span>            :                 AliHLTInt32_t fDetElemId;  // The detector element ID of the pad.
<span class="lineNum">     167 </span>            :                 AliHLTInt32_t fIX, fIY;  // The X,Y number of the pad.
<span class="lineNum">     168 </span>            :                 AliHLTFloat32_t fRealX, fRealY, fRealZ;   // The real coordinate of the pad.
<span class="lineNum">     169 </span>            :                 AliHLTFloat32_t fHalfPadSize; // half padsize in X and Y
<span class="lineNum">     170 </span>            :                 AliHLTFloat32_t fPadSizeXY; // padsize in Y for bending plane and X for nonbending
<span class="lineNum">     171 </span>            :                 AliHLTInt32_t fPlane;   // The plane and PCB zone ID numbers.
<span class="lineNum">     172 </span>            :                 AliHLTFloat32_t fCharge;  // The charge measured on the pad.
<span class="lineNum">     173 </span>            :                 AliHLTInt32_t fBusPatch;  // The bus patch of the raw data word from the DDL stream.
<span class="lineNum">     174 </span>            :                 AliHLTUInt32_t fRawData;  // The raw data word from the DDL stream.
<span class="lineNum">     175 </span>            :         };
<span class="lineNum">     176 </span>            :         
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            :         class AliHLTMUONRawDecoder : public AliMUONTrackerDDLDecoderEventHandler, public AliHLTLogging
<span class="lineNum">     179 </span>            :         {
<span class="lineNum">     180 </span>            :         public:
<span class="lineNum">     181 </span>            :         
<span class="lineNum">     182 </span>            :                 AliHLTMUONRawDecoder();
<span class="lineNum">     183 </span>            :                 virtual ~AliHLTMUONRawDecoder();
<span class="lineNum">     184 </span>            :                 
<span class="lineNum">     185 </span>            :                 void OnData(UInt_t dataWord, bool parityError);
<span class="lineNum">     186 </span>            :                 void OnNewBusPatch(const AliMUONBusPatchHeaderStruct* header, const void* data) ;
<span class="lineNum">     187 </span>            :                 
<span class="lineNum">     188 </span>            :                 void OnNewBuffer(const void* buffer, UInt_t bufferSize);
<a name="189"><span class="lineNum">     189 </span>            :                 void OnError(ErrorCode code, const void* location);</a>
<a name="190"><span class="lineNum">     190 </span>            :                 </a>
<a name="191"><span class="lineNum">     191 </span><span class="lineNoCov">          0 :                 void SetDCCut(AliHLTInt32_t dcCut) {fDCCut = dcCut;}</span></a>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :                 void SetPadData(AliHLTMUONPad* const padData) {fPadData = padData;}</span>
<a name="193"><span class="lineNum">     193 </span><span class="lineNoCov">          0 :                 void SetLookUpTable(const AliHLTMUONHitRecoLutRow* lookUpTableData) {fkLookUpTableData = lookUpTableData;}</span></a>
<a name="194"><span class="lineNum">     194 </span>            : </a>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :                 void SetIdManuChannelToEntry(const IdManuChannelToEntry* idToEntry) {fkIdToEntry = idToEntry;}</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :                 void SetMaxEntryPerBusPatch(const MaxEntryPerBusPatch* maxEntryPerBP) {fkMaxEntryPerBusPatch = maxEntryPerBP;}</span>
<a name="197"><span class="lineNum">     197 </span>            : </a>
<span class="lineNum">     198 </span>            :                 AliHLTInt32_t DDLNumber() const { return fDDL; }
<a name="199"><span class="lineNum">     199 </span><span class="lineNoCov">          0 :                 void DDLNumber(AliHLTInt32_t value) { fDDL = (value &amp; 0x1F); }  // 0x1F forces value into our required range.</span></a>
<a name="200"><span class="lineNum">     200 </span>            :                 // The following two methods have to called after set the ddl</a>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :                 void SetNofFiredDetElemId(AliHLTUInt16_t* const nofDataInDetElem) {fNofDataInDetElem = nofDataInDetElem;}</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :                 void SetMaxFiredPerDetElem(AliHLTUInt16_t** const dataCountListPerDetElem) {fDataCountListPerDetElem = dataCountListPerDetElem;}                </span>
<a name="203"><span class="lineNum">     203 </span>            : </a>
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :                 AliHLTInt32_t GetDataCount() const {return fDataCount;}</span>
<span class="lineNum">     206 </span>            :                 
<span class="lineNum">     207 </span>            :                 /**
<span class="lineNum">     208 </span>            :                  * Returns true if the OnError handler method will only generate warning
<span class="lineNum">     209 </span>            :                  * messages and rather than error messages.
<span class="lineNum">     210 </span>            :                  */
<span class="lineNum">     211 </span>            :                 bool WarnOnly() const { return fWarnOnly; }
<span class="lineNum">     212 </span>            :                 
<span class="lineNum">     213 </span>            :                 /**
<span class="lineNum">     214 </span>            :                  * Sets the flag indicating if the OnError method should only generate
<a name="215"><span class="lineNum">     215 </span>            :                  * warnings rather than error messages.</a>
<span class="lineNum">     216 </span>            :                  */
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :                 void WarnOnly(bool value) { fWarnOnly = value; }</span>
<span class="lineNum">     218 </span>            :                 
<span class="lineNum">     219 </span>            :                 /**
<span class="lineNum">     220 </span>            :                  * Returns true if ADC digits with parity errors are skipped.
<span class="lineNum">     221 </span>            :                  */
<span class="lineNum">     222 </span>            :                 bool SkipParityErrors() const { return fSkipParityErrors; }
<span class="lineNum">     223 </span>            :                 
<span class="lineNum">     224 </span>            :                 /**
<a name="225"><span class="lineNum">     225 </span>            :                  * Sets the flag indicating if ADC digits with parity errors are skipped.</a>
<span class="lineNum">     226 </span>            :                  */
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :                 void SkipParityErrors(bool value) { fSkipParityErrors = value; }</span>
<span class="lineNum">     228 </span>            :                 
<span class="lineNum">     229 </span>            :                 /**
<a name="230"><span class="lineNum">     230 </span>            :                  * Returns true if messages about parity errors are not printed.</a>
<span class="lineNum">     231 </span>            :                  */
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :                 bool DontPrintParityErrors() const { return fDontPrintParityErrors; }</span>
<span class="lineNum">     233 </span>            :                 
<span class="lineNum">     234 </span>            :                 /**
<a name="235"><span class="lineNum">     235 </span>            :                  * Sets the flag indicating if messages about parity errors are not printed.</a>
<span class="lineNum">     236 </span>            :                  */
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :                 void DontPrintParityErrors(bool value) { fDontPrintParityErrors = value; }</span>
<span class="lineNum">     238 </span>            :                 
<span class="lineNum">     239 </span>            :                 /**
<span class="lineNum">     240 </span>            :                  * Returns true if parity error messages are printed as warnings.
<span class="lineNum">     241 </span>            :                  */
<span class="lineNum">     242 </span>            :                 bool PrintParityErrorAsWarning() const { return fPrintParityErrorAsWarning; }
<span class="lineNum">     243 </span>            :                 
<span class="lineNum">     244 </span>            :                 /**
<a name="245"><span class="lineNum">     245 </span>            :                  * Sets the flag indicating if parity error messages are printed as warnings.</a>
<span class="lineNum">     246 </span>            :                  */
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :                 void PrintParityErrorAsWarning(bool value) { fPrintParityErrorAsWarning = value; }</span>
<span class="lineNum">     248 </span>            :                 
<span class="lineNum">     249 </span>            :                 /**
<a name="250"><span class="lineNum">     250 </span>            :                  * Returns true if a parity error was found during the last call to Decode.</a>
<span class="lineNum">     251 </span>            :                  */
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :                 bool ParityErrorFound() const { return fParityErrorFound; }</span>
<span class="lineNum">     253 </span>            :                 
<span class="lineNum">     254 </span>            :                 /**
<a name="255"><span class="lineNum">     255 </span>            :                  * Returns true if a non-parity error was found during the last call to Decode.</a>
<span class="lineNum">     256 </span>            :                  */
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :                 bool NonParityErrorFound() const { return fNonParityErrorFound; }</span>
<span class="lineNum">     258 </span>            :         
<span class="lineNum">     259 </span>            :         private:
<span class="lineNum">     260 </span>            :                 // Do not allow copying of this class.
<span class="lineNum">     261 </span>            :                 /// Not implemented
<span class="lineNum">     262 </span>            :                 AliHLTMUONRawDecoder(const AliHLTMUONRawDecoder&amp; rhs); // copy constructor
<span class="lineNum">     263 </span>            :                 /// Not implemented
<span class="lineNum">     264 </span>            :                 AliHLTMUONRawDecoder&amp; operator=(const AliHLTMUONRawDecoder&amp; rhs); // assignment operator
<span class="lineNum">     265 </span>            :         
<span class="lineNum">     266 </span>            :                 const void* fkBufferStart;   // Pointer to the start of the current DDL payload buffer.
<span class="lineNum">     267 </span>            :                 AliHLTInt32_t fBusPatchId;  // buspatchId
<span class="lineNum">     268 </span>            :                 AliHLTInt32_t fDCCut;       // DC Cut value
<span class="lineNum">     269 </span>            :                 AliHLTMUONPad* fPadData;    // pointer to the array containing the information of each padhits
<span class="lineNum">     270 </span>            :                 const AliHLTMUONHitRecoLutRow* fkLookUpTableData;   // pointer to the array of Lookuptable data
<span class="lineNum">     271 </span>            :                 /* AliHLTInt32_t* fNofFiredDetElem;         // counter for detector elements that are fired  */
<span class="lineNum">     272 </span>            :                 /* AliHLTInt32_t* fMaxFiredPerDetElem;      // array for detector elements that are fired  */
<span class="lineNum">     273 </span>            :                 const IdManuChannelToEntry* fkIdToEntry;  // Mapping between Linenumber to IdManuChannel;
<span class="lineNum">     274 </span>            :                 const MaxEntryPerBusPatch* fkMaxEntryPerBusPatch;   // Maximum allowed entry per Buspatch.
<span class="lineNum">     275 </span>            :                 
<span class="lineNum">     276 </span>            :                 AliHLTInt32_t fDDL;                 // DDL number
<span class="lineNum">     277 </span>            :                 AliHLTInt32_t fDataCount;           // Data Counter
<span class="lineNum">     278 </span>            :                 AliHLTInt32_t fPrevDetElemId;       // previous detection elementId
<span class="lineNum">     279 </span>            :                 AliHLTInt32_t fPadCharge;           // pedestal subtracted pad charge
<span class="lineNum">     280 </span>            :                 AliHLTFloat32_t fCharge;            //calibrated pad charge 
<span class="lineNum">     281 </span>            :                 AliHLTInt32_t fIdManuChannel;       // id manu channel
<span class="lineNum">     282 </span>            :                 AliHLTInt32_t fLutEntry;            // i-th entry in lookuptable
<span class="lineNum">     283 </span>            :                 
<span class="lineNum">     284 </span>            :                 AliHLTUInt16_t **fDataCountListPerDetElem;               ///&lt; List of datacounts associated with given ddl
<span class="lineNum">     285 </span>            :                 AliHLTUInt16_t *fNofDataInDetElem;                       ///&lt; Nof datacount in a ddl
<span class="lineNum">     286 </span>            :                 bool fWarnOnly;  ///&lt; Flag indicating if the OnError method should generate warnings rather than error messages.
<span class="lineNum">     287 </span>            :                 bool fSkipParityErrors;  ///&lt; Flag indicating if ADC digits with parity errors should be skipped.
<span class="lineNum">     288 </span>            :                 bool fDontPrintParityErrors;  ///&lt; Flag for controlling if messages about parity errors should be printed.
<span class="lineNum">     289 </span>            :                 bool fPrintParityErrorAsWarning;  ///&lt; Flag for controlling if parity error messages are printed as warnings.
<span class="lineNum">     290 </span>            :                 bool fParityErrorFound;  ///&lt; Flag if a parity error was found after a decoding pass.
<span class="lineNum">     291 </span>            :                 bool fNonParityErrorFound;  ///&lt; Flag which indicates if a non parity error code was found after a decoding pass.
<span class="lineNum">     292 </span>            :                 bool fIsMuchNoisy;  ///&lt; tag for noisy buspatch.
<span class="lineNum">     293 </span>            :         };
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span>            :         AliMUONTrackerDDLDecoder&lt;AliHLTMUONRawDecoder&gt; fHLTMUONDecoder; // robust HLTMUON Decoder
<span class="lineNum">     296 </span>            :         
<span class="lineNum">     297 </span>            :         AliHLTInt32_t fkBlockHeaderSize;      // Block header size
<span class="lineNum">     298 </span>            :         AliHLTInt32_t fkDspHeaderSize;        // DSP header size
<span class="lineNum">     299 </span>            :         AliHLTInt32_t fkBuspatchHeaderSize;   // buspatch header size
<span class="lineNum">     300 </span>            :         
<span class="lineNum">     301 </span>            :         AliHLTInt32_t fDCCut;                 // DC Cut value
<span class="lineNum">     302 </span>            :         
<span class="lineNum">     303 </span>            :         AliHLTMUONPad* fPadData;  // pointer to the array containing the information of each padhits
<span class="lineNum">     304 </span>            :         const AliHLTMUONHitRecoLutRow* fkLookUpTableData;  // pointer to the array of Lookuptable data (The memory is not owned by this component).
<span class="lineNum">     305 </span>            :         
<span class="lineNum">     306 </span>            :         AliHLTMUONRecHitStruct* fRecPoints;      // Reconstructed hits
<span class="lineNum">     307 </span>            :         AliHLTUInt32_t *fRecPointsCount;         // nof reconstructed hit.
<span class="lineNum">     308 </span>            :         AliHLTUInt32_t fMaxRecPointsCount;       // max nof reconstructed hit.
<span class="lineNum">     309 </span>            :         
<span class="lineNum">     310 </span>            :         AliHLTMUONClusterStruct* fClusters;  // Array of output cluster infromation.
<span class="lineNum">     311 </span>            :         AliHLTUInt32_t fClusterCount;       // Number of elemenets in fClusters.
<span class="lineNum">     312 </span>            :         AliHLTUInt32_t fMaxClusters;        // Maximum number of clusters in fClusters.
<span class="lineNum">     313 </span>            :         bool fGenerateClusterInfo;   // Flag indicating if extra cluster information should be generated.
<span class="lineNum">     314 </span>            :         AliHLTInt32_t fNewClusterId;  // The ID to use for a new cluster structure.
<span class="lineNum">     315 </span>            :         AliHLTInt32_t fDDL;   // The source DDL number of the raw data.
<span class="lineNum">     316 </span>            :         
<span class="lineNum">     317 </span>            :         AliHLTMUONChannelStruct* fChannels;  // Array of output channel infromation.
<span class="lineNum">     318 </span>            :         AliHLTUInt32_t fChannelCount;       // Number of elemenets in fChannels.
<span class="lineNum">     319 </span>            :         AliHLTUInt32_t fMaxChannels;        // Maximum number of channels in fChannels.
<span class="lineNum">     320 </span>            :         bool fGenerateChannelInfo;   // Flag indicating if extra channel information should be generated.
<span class="lineNum">     321 </span>            :         AliHLTUInt32_t fMaxChannelMult;  // Indicates the maximum channel multiplicity per cluster allowed.
<span class="lineNum">     322 </span>            :         
<span class="lineNum">     323 </span>            :         AliHLTInt32_t fCentralCountB, fCentralCountNB;   // centeral hits.
<span class="lineNum">     324 </span>            :         AliHLTInt32_t fDigitPerDDL;                      // Total nof Digits perDDL.
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span>            :         AliHLTUInt16_t **fDataCountListPerDetElem;               // List of datacounts associated with given ddl
<span class="lineNum">     327 </span>            :         AliHLTUInt16_t *fNofDataInDetElem;                       // Nof datacount in a ddl
<span class="lineNum">     328 </span>            :         AliHLTInt32_t *fCentralChargeB, *fCentralChargeNB;       // pointer to an array of central hit
<span class="lineNum">     329 </span>            :         AliHLTFloat32_t *fRecX, *fRecY;                          // pointer to an array of reconstructed hit
<span class="lineNum">     330 </span>            :         AliHLTFloat32_t *fAvgChargeX, *fAvgChargeY;              // average charge on central pad found using CG method
<span class="lineNum">     331 </span>            :         AliHLTFloat32_t *fTotChargeX, *fTotChargeY;              // Total charge in bending and nonbending direction
<span class="lineNum">     332 </span>            :         AliHLTInt32_t *fNofBChannel, *fNofNBChannel;             // number of channels bending and non-bending.
<span class="lineNum">     333 </span>            :         AliHLTInt32_t *fNofYNeighbour;                           // number of neighbour pad in y direction, needed for y-resolution correction
<span class="lineNum">     334 </span>            :         AliHLTInt32_t fGetIdTotalData[336][237][2];              // an array of idManuChannel with argument of centralX, centralY and planeType.
<span class="lineNum">     335 </span>            :         //AliHLTInt32_t fNofFiredDetElem,fMaxFiredPerDetElem[130];  // counter for detector elements that are fired
<span class="lineNum">     336 </span>            :         const IdManuChannelToEntry* fkIdToEntry;   // Mapping between Linenumber to IdManuChannel (The object is not owned by this component).
<span class="lineNum">     337 </span>            :         const MaxEntryPerBusPatch* fkMaxEntryPerBusPatch;   // Maximum allowed entry per Buspatch.
<span class="lineNum">     338 </span>            :         
<span class="lineNum">     339 </span>            :         ERecoveryMode fRecoveryMode;  ///&lt; The recovery mode for the decoder.
<span class="lineNum">     340 </span>            :         
<span class="lineNum">     341 </span>            :         bool DecodeDDL(AliHLTUInt32_t* rawData, AliHLTUInt32_t rawDataSize);
<span class="lineNum">     342 </span>            :         void FindCentralHits(AliHLTInt32_t iDet);
<span class="lineNum">     343 </span>            :         bool FindRecHits();
<span class="lineNum">     344 </span>            :         void RecXRecY();
<span class="lineNum">     345 </span>            :         bool MergeSlatRecHits();
<span class="lineNum">     346 </span>            :         bool MergeQuadRecHits();
<span class="lineNum">     347 </span>            :         void Clear();
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span>            : };
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span>            : #endif // ALIHLTMUONHITRECONSTRUCTOR_H
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
