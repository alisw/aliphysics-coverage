<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - ITS/ITSrec/AliITSTPArrayFit.cxx</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">ITS/ITSrec</a> - AliITSTPArrayFit.cxx<span style="font-size: 80%;"> (source / <a href="AliITSTPArrayFit.cxx.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">924</td>
            <td class="headerCovTableEntryLo">0.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">57</td>
            <td class="headerCovTableEntryLo">1.8 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**************************************************************************</a>
<span class="lineNum">       2 </span>            :  * Copyright(c) 2009-2011, ALICE Experiment at CERN, All rights reserved. *
<span class="lineNum">       3 </span>            :  *                                                                        *
<span class="lineNum">       4 </span>            :  * Author: The ALICE Off-line Project.                                    *
<span class="lineNum">       5 </span>            :  * Contributors are mentioned in the code where appropriate.              *
<span class="lineNum">       6 </span>            :  *                                                                        *
<span class="lineNum">       7 </span>            :  * Permission to use, copy, modify and distribute this software and its   *
<span class="lineNum">       8 </span>            :  * documentation strictly for non-commercial purposes is hereby granted   *
<span class="lineNum">       9 </span>            :  * without fee, provided that the above copyright notice appears in all   *
<span class="lineNum">      10 </span>            :  * copies and that both the copyright notice and this permission notice   *
<span class="lineNum">      11 </span>            :  * appear in the supporting documentation. The authors make no claims     *
<span class="lineNum">      12 </span>            :  * about the suitability of this software for any purpose. It is          *
<span class="lineNum">      13 </span>            :  * provided &quot;as is&quot; without express or implied warranty.                  *
<span class="lineNum">      14 </span>            :  **************************************************************************/
<span class="lineNum">      15 </span>            : /* $Id$ */
<span class="lineNum">      16 </span>            : ///////////////////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">      17 </span>            : //                                                                                           //
<span class="lineNum">      18 </span>            : // The line is defined by equations (1)                                                      //
<span class="lineNum">      19 </span>            : // a0*z+a1*x-a0*a1=0 and                                                                     //
<span class="lineNum">      20 </span>            : // b0*z+b1*y-b0*b1=0                                                                         //
<span class="lineNum">      21 </span>            : // where x,y,z are NOT the lab axes but z is the lab axis along which the track              //
<span class="lineNum">      22 </span>            : // has the largest lever arm and x,y are the remaining 2 axis in                             //
<span class="lineNum">      23 </span>            : // the order of fgkAxisID[z][0], fgkAxisID[z][1]                                             //
<span class="lineNum">      24 </span>            : // The parameters are fParams[kA0,kB0,kA1,kB1] and the axis chosen as the independent        //
<span class="lineNum">      25 </span>            : // var. is fParAxis (i.e. if fParAxis==kZ, then a0=ax,b0=bx, a1=ay,b1=by)                    //
<span class="lineNum">      26 </span>            : //                                                                                           //
<span class="lineNum">      27 </span>            : //                                                                                           //
<span class="lineNum">      28 </span>            : // The helix is defined by the equations (2)                                                 //
<span class="lineNum">      29 </span>            : // X(t) = (dr+R)*cos(phi0) - (R+sum{dRi})*cos(t+phi0) + sum{dRi*cos(phi0+ti)}                //
<span class="lineNum">      30 </span>            : // Y(t) = (dr+R)*sin(phi0) - (R+sum{dRi})*sin(t+phi0) + sum{dRi*sin(phi0+ti)}                //
<span class="lineNum">      31 </span>            : // Z(t) = dz - (R+sum{dRi})*t*tg(dip) + sum{dRi*ti}*tg(dip)                                  //
<span class="lineNum">      32 </span>            : // where dRi is the change of the radius due to the ELoss at parameter ti                    //
<span class="lineNum">      33 </span>            : //                                                                                           //
<span class="lineNum">      34 </span>            : // Author: ruben.shahoyan@cern.ch                                                            //
<span class="lineNum">      35 </span>            : //                                                                                           //
<span class="lineNum">      36 </span>            : ///////////////////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : #include &quot;AliITSTPArrayFit.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;AliExternalTrackParam.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;AliSymMatrix.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;AliLog.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;AliParamSolver.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;AliGeomManager.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;AliITSgeomTGeo.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;AliTracker.h&quot;
<span class="lineNum">      46 </span>            : #include &lt;TRandom.h&gt;
<a name="47"><span class="lineNum">      47 </span>            : #include &lt;TArrayD.h&gt;</a>
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span><span class="lineCov">        116 : ClassImp(AliITSTPArrayFit)</span>
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : const Int_t  AliITSTPArrayFit::fgkAxisID[3][3] = { 
<span class="lineNum">      52 </span>            :   {AliITSTPArrayFit::kY,AliITSTPArrayFit::kZ,AliITSTPArrayFit::kX},
<span class="lineNum">      53 </span>            :   {AliITSTPArrayFit::kZ,AliITSTPArrayFit::kX,AliITSTPArrayFit::kY},
<span class="lineNum">      54 </span>            :   {AliITSTPArrayFit::kX,AliITSTPArrayFit::kY,AliITSTPArrayFit::kZ} };
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : const Int_t  AliITSTPArrayFit::fgkAxisCID[3][6] = { 
<span class="lineNum">      57 </span>            :   {AliITSTPArrayFit::kYY,AliITSTPArrayFit::kYZ,AliITSTPArrayFit::kXY,
<span class="lineNum">      58 </span>            :    AliITSTPArrayFit::kZZ,AliITSTPArrayFit::kXZ,AliITSTPArrayFit::kXX},
<span class="lineNum">      59 </span>            :   //
<span class="lineNum">      60 </span>            :   {AliITSTPArrayFit::kZZ,AliITSTPArrayFit::kXZ,AliITSTPArrayFit::kYZ,
<span class="lineNum">      61 </span>            :    AliITSTPArrayFit::kXX,AliITSTPArrayFit::kYX,AliITSTPArrayFit::kYY},
<span class="lineNum">      62 </span>            :   //
<span class="lineNum">      63 </span>            :   {AliITSTPArrayFit::kXX,AliITSTPArrayFit::kXY,AliITSTPArrayFit::kXZ,
<span class="lineNum">      64 </span>            :    AliITSTPArrayFit::kYY,AliITSTPArrayFit::kYZ,AliITSTPArrayFit::kZZ}
<span class="lineNum">      65 </span>            : };
<span class="lineNum">      66 </span>            : //
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            : const Double_t AliITSTPArrayFit::fgkAlmostZero = 1E-55;
<span class="lineNum">      69 </span>            : const Double_t AliITSTPArrayFit::fgkCQConv = 0.299792458e-3;// R = PT/Bz/fgkCQConv with GeV,kGauss,cm
<span class="lineNum">      70 </span>            : const Double_t AliITSTPArrayFit::fgkZSpanITS[AliITSTPArrayFit::kMaxLrITS] = {
<span class="lineNum">      71 </span>            :   36. ,14.1,14.1,  38., 22.2,29.7, 51.   ,43.1,48.9};
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : const Double_t AliITSTPArrayFit::fgkRLayITS[AliITSTPArrayFit::kMaxLrITS] = {
<span class="lineNum">      74 </span>            :   2.94, 3.9,7.6, 11.04, 15.0,23.9, 29.44 ,38.0,43.0};
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            : const Int_t    AliITSTPArrayFit::fgkPassivLrITS[3] = 
<span class="lineNum">      77 </span>            :   {AliITSTPArrayFit::kLrBeamPime,AliITSTPArrayFit::kLrShield1,AliITSTPArrayFit::kLrShield2};
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : const Int_t    AliITSTPArrayFit::fgkActiveLrITS[6] = 
<span class="lineNum">      80 </span>            :   {AliITSTPArrayFit::kLrSPD1,AliITSTPArrayFit::kLrSPD2,
<span class="lineNum">      81 </span>            :    AliITSTPArrayFit::kLrSDD1,AliITSTPArrayFit::kLrSDD2,
<span class="lineNum">      82 </span>            :    AliITSTPArrayFit::kLrSSD1,AliITSTPArrayFit::kLrSSD2};
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span>            : Double_t AliITSTPArrayFit::fgRhoLITS[AliITSTPArrayFit::kMaxLrITS] = {
<span class="lineNum">      85 </span>            :   1.48e-01, 2.48e-01,2.57e-01, 1.34e-01, 3.34e-01,3.50e-01, 2.22e-01, 2.38e-01,2.25e-01};
<a name="86"><span class="lineNum">      86 </span>            : </a>
<span class="lineNum">      87 </span>            : //____________________________________________________
<span class="lineNum">      88 </span><span class="lineNoCov">          0 : AliITSTPArrayFit::AliITSTPArrayFit() :</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :   fkPoints(0),fParSol(0),fBz(0),fCharge(0),fPntFirst(-1),</span>
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :   fPntLast(-1),fNPBooked(0),fParAxis(-1),fCovI(0),fChi2NDF(0),</span>
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :   fMaxIter(20),fIter(0),fEps(1e-6),fMass(0),fSwitch2Line(kFALSE),fMaxRforHelix(6.e5),</span>
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :   fkAxID(0),fkAxCID(0),fCurT(0),</span>
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :   fFirstPosT(0),fNElsPnt(0),fElsId(0),fElsDR(0)</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">      95 </span>            :   // default constructor
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :   for (int i=kMaxParam;i--;)   fParams[i] = 0;</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :   for (int i=kMaxParamSq;i--;) fParamsCov[i] = 0;</span>
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :   SetMass();</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 : }</span>
<a name="100"><span class="lineNum">     100 </span>            : </a>
<span class="lineNum">     101 </span>            : //____________________________________________________
<span class="lineNum">     102 </span><span class="lineNoCov">          0 : AliITSTPArrayFit::AliITSTPArrayFit(Int_t np) :</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :   fkPoints(0),fParSol(0),fBz(0),fCharge(0),fPntFirst(-1),</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :   fPntLast(-1),fNPBooked(np),fParAxis(-1),fCovI(0),fChi2NDF(0),</span>
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :   fMaxIter(20),fIter(0),fEps(1e-6),fMass(0),fSwitch2Line(kFALSE),fMaxRforHelix(6.e5),</span>
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :   fkAxID(0),fkAxCID(0),fCurT(0),fFirstPosT(0),fNElsPnt(0),fElsId(0),fElsDR(0)</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">     108 </span>            :   // constructor with booking of np points
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :   for (int i=kMaxParam;i--;)   fParams[i] = 0;</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :   for (int i=kMaxParamSq;i--;) fParamsCov[i] = 0;</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :   InitAux();</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :   SetEps();</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :   SetMass();</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :   SetMaxIterations();</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 : }</span>
<a name="116"><span class="lineNum">     116 </span>            : </a>
<span class="lineNum">     117 </span>            : //____________________________________________________
<span class="lineNum">     118 </span>            : AliITSTPArrayFit::AliITSTPArrayFit(const AliITSTPArrayFit &amp;src) : 
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :   TObject(src),fkPoints(src.fkPoints),fParSol(0),fBz(src.fBz),</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :   fCharge(src.fCharge),fPntFirst(src.fPntFirst),fPntLast(src.fPntLast),fNPBooked(src.fNPBooked),</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :   fParAxis(src.fParAxis),fCovI(0),fChi2NDF(0),fMaxIter(20),fIter(0),fEps(0),fMass(src.fMass),</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :   fSwitch2Line(src.fSwitch2Line),fMaxRforHelix(src.fMaxRforHelix),fkAxID(0),fkAxCID(0),fCurT(0),</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :   fFirstPosT(0),fNElsPnt(0),fElsId(0),fElsDR(0)</span>
<span class="lineNum">     124 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">     125 </span>            :   // copy constructor
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :   InitAux();</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :   memcpy(fCovI,src.fCovI,fNPBooked*kNCov*sizeof(Double_t));</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :   for (int i=kMaxParam;i--;)   fParams[i] = src.fParams[i];</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :   for (int i=kMaxParamSq;i--;) fParamsCov[i] = src.fParamsCov[i];</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :   memcpy(fCurT,src.fCurT,fNPBooked*sizeof(Double_t));</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :   SetEps(src.fEps);</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :   SetMaxIterations(src.fMaxIter);</span>
<span class="lineNum">     133 </span>            :   //  
<span class="lineNum">     134 </span><span class="lineNoCov">          0 : }</span>
<a name="135"><span class="lineNum">     135 </span>            : </a>
<span class="lineNum">     136 </span>            : //____________________________________________________
<span class="lineNum">     137 </span>            : AliITSTPArrayFit &amp;AliITSTPArrayFit::operator =(const AliITSTPArrayFit&amp; src)
<span class="lineNum">     138 </span>            : {
<span class="lineNum">     139 </span>            :   // assignment operator
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :   if (this==&amp;src) return *this;</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :   ((TObject*)this)-&gt;operator=(src);</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :   fkPoints   = src.fkPoints;</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :   if (!fParSol) fParSol = new AliParamSolver(*src.fParSol);</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :   else *fParSol = *src.fParSol; </span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :   fBz       = src.fBz; </span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :   fCharge   = src.fCharge;</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :   fNPBooked = src.fNPBooked;</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :   fPntFirst = src.fPntFirst;</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :   fPntLast  = src.fPntLast;</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :   InitAux();</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :   memcpy(fCovI,src.fCovI,fNPBooked*kNCov*sizeof(Double_t));</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :   for (int i=kMaxParam;i--;)   fParams[i] = src.fParams[i];</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :   for (int i=kMaxParamSq;i--;) fParamsCov[i] = src.fParamsCov[i];</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :   SetParAxis(src.fParAxis);</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :   fNElsPnt   = src.fNElsPnt;</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :   fFirstPosT = src.fFirstPosT;</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :   memcpy(fCurT  ,src.fCurT  ,fNPBooked*sizeof(Double_t));</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :   memcpy(fElsId ,src.fElsId ,fNPBooked*sizeof(Int_t));</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :   memcpy(fElsDR ,src.fElsDR ,fNPBooked*sizeof(Double_t));</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :   memcpy(fCurT  ,src.fCurT  ,fNPBooked*sizeof(Double_t));</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :   SetEps(src.fEps);</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :   SetMaxIterations(src.fMaxIter);</span>
<span class="lineNum">     163 </span>            :   //
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :   return *this;</span>
<span class="lineNum">     165 </span>            :   //
<span class="lineNum">     166 </span><span class="lineNoCov">          0 : }</span>
<a name="167"><span class="lineNum">     167 </span>            : </a>
<span class="lineNum">     168 </span>            : //____________________________________________________
<span class="lineNum">     169 </span>            : AliITSTPArrayFit::~AliITSTPArrayFit()
<span class="lineNum">     170 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">     171 </span>            :   // destructor
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :   delete   fParSol;</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :   delete[] fCovI;</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :   delete[] fCurT;</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :   delete[] fElsId;</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :   delete[] fElsDR;</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 : }</span>
<a name="178"><span class="lineNum">     178 </span>            : </a>
<span class="lineNum">     179 </span>            : //____________________________________________________
<span class="lineNum">     180 </span>            : void AliITSTPArrayFit::Reset()
<span class="lineNum">     181 </span>            : {
<span class="lineNum">     182 </span>            :   // reset to process new track
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :   if (fParSol) fParSol-&gt;Clear();</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :   fkPoints=0; </span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :   fNElsPnt = 0;</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :   fFirstPosT = 0;</span>
<span class="lineNum">     187 </span>            :   //  fBz = 0;
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :   fCharge = 0;</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :   fIter = 0;</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :   fPntFirst=fPntLast=-1; </span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :   SetParAxis(-1);</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :   fSwitch2Line = kFALSE;</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :   ResetBit(kFitDoneBit|kCovInvBit);</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 : }</span>
<a name="195"><span class="lineNum">     195 </span>            : </a>
<span class="lineNum">     196 </span>            : //____________________________________________________
<span class="lineNum">     197 </span>            : void AliITSTPArrayFit::AttachPoints(const AliTrackPointArray* points, Int_t pfirst,Int_t plast) 
<span class="lineNum">     198 </span>            : {
<span class="lineNum">     199 </span>            :   // create from piece of AliTrackPointArray
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :   Reset();</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :   fkPoints = points;</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :   int np = points-&gt;GetNPoints();</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :   if (fNPBooked&lt;np) {</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :     fNPBooked = np;</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :     InitAux();</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :   fPntFirst = pfirst&lt;0 ? 0 : pfirst;</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :   fPntLast  = plast&lt;fPntFirst ? np-1 : plast;</span>
<span class="lineNum">     209 </span>            :   //
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :   for (int i=kMaxParam;i--;)   fParams[i] = 0;</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :   for (int i=kMaxParamSq;i--;) fParamsCov[i] = 0;</span>
<span class="lineNum">     212 </span>            :   //
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :   InvertPointsCovMat();</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :   ResetCovIScale();</span>
<span class="lineNum">     215 </span>            :   //
<span class="lineNum">     216 </span><span class="lineNoCov">          0 : }</span>
<a name="217"><span class="lineNum">     217 </span>            : </a>
<span class="lineNum">     218 </span>            : //____________________________________________________
<span class="lineNum">     219 </span>            : Bool_t AliITSTPArrayFit::SetFirstLast(Int_t pfirst,Int_t plast) 
<span class="lineNum">     220 </span>            : {
<span class="lineNum">     221 </span>            :   // set first and last point to fit
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :   const AliTrackPointArray* pnts = fkPoints;</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :   if (!pnts) {AliError(&quot;TrackPointArray is not attached yet&quot;); return kFALSE;}</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :   AttachPoints(pnts,pfirst,plast);</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :   return kTRUE;</span>
<span class="lineNum">     226 </span>            :   //
<span class="lineNum">     227 </span><span class="lineNoCov">          0 : }</span>
<a name="228"><span class="lineNum">     228 </span>            : </a>
<span class="lineNum">     229 </span>            : //____________________________________________________
<span class="lineNum">     230 </span>            : Bool_t AliITSTPArrayFit::InvertPointsCovMat()
<span class="lineNum">     231 </span>            : {
<span class="lineNum">     232 </span>            :   // invert the cov.matrices of the points
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :   for (int i=fPntFirst;i&lt;=fPntLast;i++) {</span>
<span class="lineNum">     234 </span>            :     //
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :     float *cov = (float*)fkPoints-&gt;GetCov() + i*6; // pointer on cov.matrix</span>
<span class="lineNum">     236 </span>            :     //
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :     Double_t t0 = cov[kYY]*cov[kZZ] - cov[kYZ]*cov[kYZ];</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :     Double_t t1 = cov[kXY]*cov[kZZ] - cov[kXZ]*cov[kYZ];</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :     Double_t t2 = cov[kXY]*cov[kYZ] - cov[kXZ]*cov[kYY];</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :     Double_t det = cov[kXX]*t0 - cov[kXY]*t1 + cov[kXZ]*t2;</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :     if (IsZero(det,1e-18)) { // one of errors is 0, fix this</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :       double norm[3];</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :       TGeoHMatrix hcov;</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :       TGeoRotation hrot,hrotI;</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :       GetNormal(norm,cov);</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :       double phi = TMath::ATan2(norm[1],norm[0]);</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :       hrot.SetAngles(-phi*TMath::RadToDeg(),0.,0.);</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :       hrotI.SetAngles(phi*TMath::RadToDeg(),0.,0.);</span>
<span class="lineNum">     249 </span>            :       //      
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :       Double_t hcovel[9];</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :       hcovel[0] = cov[kXX];</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :       hcovel[1] = cov[kXY];</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :       hcovel[2] = cov[kXZ];</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :       hcovel[3] = cov[kXY];</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :       hcovel[4] = cov[kYY];</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :       hcovel[5] = cov[kYZ];</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :       hcovel[6] = cov[kXZ];</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :       hcovel[7] = cov[kYZ];</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :       hcovel[8] = cov[kZZ];</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :       hcov.SetRotation(hcovel);</span>
<span class="lineNum">     261 </span>            :       //
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :       Double_t *hcovscl = hcov.GetRotationMatrix(); </span>
<span class="lineNum">     263 </span>            :       //      printf(&quot;&gt;&gt; %+e %+e %+e\n   %+e %+e %+e\n   %+e %+e %+e\n\n&quot;,hcovscl[0],hcovscl[1],hcovscl[2],hcovscl[3],hcovscl[4],hcovscl[5],hcovscl[6],hcovscl[7],hcovscl[8]);
<span class="lineNum">     264 </span>            :       //      printf(&quot;Rot by %+.e (%+.e %+.e %+.e)\n&quot;,phi, norm[0],norm[1],norm[2]);
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :       hcov.Multiply(&amp;hrotI);</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :       hcov.MultiplyLeft(&amp;hrot);</span>
<span class="lineNum">     267 </span>            :       //      printf(&quot;|| %+e %+e %+e\n   %+e %+e %+e\n   %+e %+e %+e\n\n&quot;,hcovscl[0],hcovscl[1],hcovscl[2],hcovscl[3],hcovscl[4],hcovscl[5],hcovscl[6],hcovscl[7],hcovscl[8]);
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :       if (hcovscl[0]&lt;1e-8) hcovscl[0] = 1e-8;</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :       if (hcovscl[4]&lt;1e-8) hcovscl[4] = 1e-8;</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :       if (hcovscl[8]&lt;1e-8) hcovscl[8] = 1e-8;</span>
<span class="lineNum">     271 </span>            :       //      printf(&quot;** %+e %+e %+e\n   %+e %+e %+e\n   %+e %+e %+e\n\n&quot;,hcovscl[0],hcovscl[1],hcovscl[2],hcovscl[3],hcovscl[4],hcovscl[5],hcovscl[6],hcovscl[7],hcovscl[8]);
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :       hcov.Multiply(&amp;hrot);</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :       hcov.MultiplyLeft(&amp;hrotI);</span>
<span class="lineNum">     274 </span>            :       //      printf(&quot;^^ %+e %+e %+e\n   %+e %+e %+e\n   %+e %+e %+e\n\n&quot;,hcovscl[0],hcovscl[1],hcovscl[2],hcovscl[3],hcovscl[4],hcovscl[5],hcovscl[6],hcovscl[7],hcovscl[8]);
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :       cov[kXX] = hcovscl[0];</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :       cov[kXY] = hcovscl[1];</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :       cov[kXZ] = hcovscl[2];</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :       cov[kYY] = hcovscl[4];</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :       cov[kYZ] = hcovscl[5];</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :       cov[kZZ] = hcovscl[8];</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :     t0 = cov[kYY]*cov[kZZ] - cov[kYZ]*cov[kYZ];</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :     t1 = cov[kXY]*cov[kZZ] - cov[kXZ]*cov[kYZ];</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :     t2 = cov[kXY]*cov[kYZ] - cov[kXZ]*cov[kYY];</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :     det = cov[kXX]*t0 - cov[kXY]*t1 + cov[kXZ]*t2;</span>
<span class="lineNum">     286 </span>            :     //
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :     AliDebug(2,Form(&quot;%+.4e %+.4e %+.4e -&gt; %+.4e&quot;,t0,t1,t2,det));</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :     if (IsZero(det,fgkAlmostZero)) {</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :       AliInfo(Form(&quot;Cov.Matrix for point %d is singular&quot;,i));</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :       return kFALSE;</span>
<span class="lineNum">     291 </span>            :     }
<span class="lineNum">     292 </span>            :     //
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :     Double_t *covI = GetCovI(i);</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :     covI[kXX] =  t0/det;</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :     covI[kXY] = -t1/det;</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :     covI[kXZ] =  t2/det;</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :     covI[kYY] =  (cov[kXX]*cov[kZZ] - cov[kXZ]*cov[kXZ])/det;</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :     covI[kYZ] =  (cov[kXY]*cov[kXZ] - cov[kXX]*cov[kYZ])/det;</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :     covI[kZZ] =  (cov[kXX]*cov[kYY] - cov[kXY]*cov[kXY])/det;</span>
<span class="lineNum">     300 </span>            :     //
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :   SetCovInv();</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :   return kTRUE;</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 : }</span>
<a name="305"><span class="lineNum">     305 </span>            : </a>
<span class="lineNum">     306 </span>            : //____________________________________________________
<span class="lineNum">     307 </span>            : void AliITSTPArrayFit::InitAux()
<span class="lineNum">     308 </span>            : {
<span class="lineNum">     309 </span>            :   // init auxiliary space
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :   if (fCovI) delete[] fCovI;</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :   if (fCurT) delete[] fCurT;</span>
<span class="lineNum">     312 </span>            :   //
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :   fCovI   = new Double_t[kNCov*fNPBooked];</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :   fCurT   = new Double_t[fNPBooked+kMaxLrITS];</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :   fElsId  = new Int_t[fNPBooked+kMaxLrITS];</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :   fElsDR  = new Double_t[fNPBooked+kMaxLrITS];</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :   memset(fElsDR,0,(fNPBooked+kMaxLrITS)*sizeof(Double_t));</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :   memset(fCovI,0,fNPBooked*kNCov*sizeof(Double_t));</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :   ResetCovIScale();</span>
<span class="lineNum">     320 </span>            :   //
<span class="lineNum">     321 </span><span class="lineNoCov">          0 : }</span>
<a name="322"><span class="lineNum">     322 </span>            : </a>
<span class="lineNum">     323 </span>            : //____________________________________________________
<span class="lineNum">     324 </span>            : Bool_t AliITSTPArrayFit::FitLineCrude()
<span class="lineNum">     325 </span>            : {
<span class="lineNum">     326 </span>            :   // perform linear fit w/o accounting the errors
<span class="lineNum">     327 </span>            :   // fit is done in the parameterization
<span class="lineNum">     328 </span>            :   // x = res[0] + res[1]*z
<span class="lineNum">     329 </span>            :   // y = res[2] + res[3]*z
<span class="lineNum">     330 </span>            :   // where x,y,z are NOT the lab axes but z is the lab axis along which the track 
<span class="lineNum">     331 </span>            :   // has the largest lever arm and x,y are the remaining 2 axis in 
<span class="lineNum">     332 </span>            :   // the order of fgkAxisID[z][0], fgkAxisID[z][1]
<span class="lineNum">     333 </span>            :   //
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :   int np = fPntLast - fPntFirst + 1;</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :   if (np&lt;2) {</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :     AliError(&quot;At least 2 points are needed for straight line fit&quot;);</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">     338 </span>            :   }
<span class="lineNum">     339 </span>            :   //
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :   if (fParAxis&lt;0) SetParAxis(ChoseParAxis());</span>
<span class="lineNum">     341 </span>            :   Double_t sZ=0,sZZ=0,sY=0,sYZ=0,sX=0,sXZ=0,det=0;
<span class="lineNum">     342 </span>            :   //
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :   const float *coord[3] = {fkPoints-&gt;GetX(),fkPoints-&gt;GetY(),fkPoints-&gt;GetZ()};</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :   const Float_t *varZ = coord[ fParAxis  ];</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :   const Float_t *varX = coord[ fkAxID[kX] ];</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :   const Float_t *varY = coord[ fkAxID[kY] ];</span>
<span class="lineNum">     347 </span>            :   //
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :   for (int i=fPntFirst;i&lt;=fPntLast;i++) {</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :     sZ  += varZ[i];</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :     sZZ += varZ[i]*varZ[i];</span>
<span class="lineNum">     351 </span>            :     //
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :     sX  += varX[i];</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :     sXZ += varX[i]*varZ[i];</span>
<span class="lineNum">     354 </span>            :     //
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :     sY  += varY[i];</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :     sYZ += varY[i]*varZ[i];</span>
<span class="lineNum">     357 </span>            :   }
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :   det = sZZ*np-sZ*sZ;</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :   if (TMath::Abs(det)&lt;fgkAlmostZero) return kFALSE;</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :   fParams[0] = (sX*sZZ-sZ*sXZ)/det;</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :   fParams[1] = (sXZ*np-sZ*sX)/det;</span>
<span class="lineNum">     362 </span>            :   //
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :   fParams[2] = (sY*sZZ-sZ*sYZ)/det;</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :   fParams[3] = (sYZ*np-sZ*sY)/det;</span>
<span class="lineNum">     365 </span>            :   //
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :   return kTRUE;</span>
<span class="lineNum">     367 </span>            :   //
<span class="lineNum">     368 </span><span class="lineNoCov">          0 : }</span>
<a name="369"><span class="lineNum">     369 </span>            : </a>
<span class="lineNum">     370 </span>            : //____________________________________________________
<span class="lineNum">     371 </span>            : void AliITSTPArrayFit::SetParAxis(Int_t ax)
<span class="lineNum">     372 </span>            : {
<span class="lineNum">     373 </span>            :   // select the axis which will be used as a parameter for the line: longest baseline
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :   if (ax&gt;kZ) {</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :     AliInfo(Form(&quot;Wrong axis choice: %d&quot;,ax));</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :     fParAxis = -1;</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :   fParAxis = ax;</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :   if (ax&gt;=0) {</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :     fkAxID  = fgkAxisID[ax];</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :     fkAxCID = fgkAxisCID[ax];</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     383 </span>            :   else {
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :     fkAxID = fkAxCID = 0;</span>
<span class="lineNum">     385 </span>            :   }
<span class="lineNum">     386 </span>            :   //
<span class="lineNum">     387 </span><span class="lineNoCov">          0 : }</span>
<a name="388"><span class="lineNum">     388 </span>            : </a>
<span class="lineNum">     389 </span>            : //____________________________________________________
<span class="lineNum">     390 </span>            : Int_t AliITSTPArrayFit::ChoseParAxis() const
<span class="lineNum">     391 </span>            : {
<span class="lineNum">     392 </span>            :   // select the variable with largest base as a parameter
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :   Double_t cmn[3]={1.e9,1.e9,1.e9},cmx[3]={-1.e9,-1.e9,-1.e9};</span>
<span class="lineNum">     394 </span>            :   //
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :   const float *coord[3] = {fkPoints-&gt;GetX(),fkPoints-&gt;GetY(),fkPoints-&gt;GetZ()};</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :   for (int i=fPntFirst;i&lt;=fPntLast;i++) {</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :     for (int j=3;j--;) {</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :       Double_t val = coord[j][i];</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :       if (cmn[j]&gt;val) cmn[j] = val;</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :       if (cmx[j]&lt;val) cmx[j] = val;</span>
<span class="lineNum">     401 </span>            :     }
<span class="lineNum">     402 </span>            :   }
<span class="lineNum">     403 </span>            :   //
<span class="lineNum">     404 </span>            :   int axis = kZ;
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :   if (cmx[axis]-cmn[axis] &lt; cmx[kX]-cmn[kX]) axis = kX;</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :   if (cmx[axis]-cmn[axis] &lt; cmx[kY]-cmn[kY]) axis = kY;</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :   return axis;</span>
<span class="lineNum">     408 </span>            :   //
<span class="lineNum">     409 </span><span class="lineNoCov">          0 : }</span>
<a name="410"><span class="lineNum">     410 </span>            : </a>
<span class="lineNum">     411 </span>            : //____________________________________________________
<span class="lineNum">     412 </span>            : Double_t AliITSTPArrayFit::GetPosition(Double_t *xyzPCA, const Double_t *xyz, const Double_t *covI, Double_t sclCovI) const
<span class="lineNum">     413 </span>            : {
<span class="lineNum">     414 </span>            :   // calculate the position of the track at PCA to xyz
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :   Double_t t = GetParPCA(xyz,covI,sclCovI);</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :   GetPosition(xyzPCA,t);</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :   return t;</span>
<span class="lineNum">     418 </span>            : }
<a name="419"><span class="lineNum">     419 </span>            : </a>
<span class="lineNum">     420 </span>            : //____________________________________________________
<span class="lineNum">     421 </span>            : Double_t AliITSTPArrayFit::GetPosition(Double_t *xyzPCA, const AliTrackPoint *pntCovInv, Bool_t useErr) const
<span class="lineNum">     422 </span>            : {
<span class="lineNum">     423 </span>            :   // calculate the position of the track at PCA to pntCovInv
<span class="lineNum">     424 </span>            :   // NOTE: the covariance matrix of the point must be inverted
<span class="lineNum">     425 </span>            :   double t;
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :   double xyz[3] = {pntCovInv-&gt;GetX(),pntCovInv-&gt;GetY(),pntCovInv-&gt;GetZ()};</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :   if (useErr) {</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :     Double_t covI[6];;</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :     for (int i=6;i--;) covI[i] = pntCovInv-&gt;GetCov()[i];</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :     t = GetParPCA(xyz,covI);</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :   else t = GetParPCA(xyz);</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :   GetPosition(xyzPCA,t);</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :   return t;</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 : }</span>
<a name="436"><span class="lineNum">     436 </span>            : </a>
<span class="lineNum">     437 </span>            : //____________________________________________________
<span class="lineNum">     438 </span>            : void AliITSTPArrayFit::GetResiduals(Double_t *resPCA, const AliTrackPoint *pntCovInv, Bool_t useErr) const
<span class="lineNum">     439 </span>            : {
<span class="lineNum">     440 </span>            :   // calculate the residuals  of the track at PCA to pntCovInv
<span class="lineNum">     441 </span>            :   // NOTE: the covariance matrix of the point must be inverted
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :   GetPosition(resPCA,pntCovInv,useErr);</span>
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :   resPCA[0] -= pntCovInv-&gt;GetX();</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :   resPCA[1] -= pntCovInv-&gt;GetY();</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :   resPCA[2] -= pntCovInv-&gt;GetZ();</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 : }</span>
<a name="447"><span class="lineNum">     447 </span>            : </a>
<span class="lineNum">     448 </span>            : //____________________________________________________
<span class="lineNum">     449 </span>            : void AliITSTPArrayFit::GetResiduals(Double_t *resPCA, const Double_t *xyz, const Double_t *covI, Double_t sclCovI) const
<span class="lineNum">     450 </span>            : {
<span class="lineNum">     451 </span>            :   // calculate the residuals of the track at PCA to xyz
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :   GetPosition(resPCA,xyz,covI,sclCovI);</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :   resPCA[kX] -= xyz[kX];</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :   resPCA[kY] -= xyz[kY];</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :   resPCA[kZ] -= xyz[kZ];</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 : }</span>
<a name="457"><span class="lineNum">     457 </span>            : </a>
<span class="lineNum">     458 </span>            : //____________________________________________________
<span class="lineNum">     459 </span>            : Double_t AliITSTPArrayFit::GetParPCALine(const Double_t *xyz, const Double_t *covI/*, Double_t sclCovI*/) const
<span class="lineNum">     460 </span>            : {
<span class="lineNum">     461 </span>            :   // get parameter for the point with least weighted distance to the point
<span class="lineNum">     462 </span>            :   //
<span class="lineNum">     463 </span>            :   Double_t rhs,denom;
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :   Double_t dx = fParams[kA0]-xyz[ fkAxID[kX] ];</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :   Double_t dy = fParams[kA1]-xyz[ fkAxID[kY] ];</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :   Double_t dz =             -xyz[ fkAxID[kZ] ];</span>
<span class="lineNum">     467 </span>            :   //
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :   if (covI) {</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :     Double_t tx = fParams[kB0]*covI[ fkAxCID[kXX] ] + fParams[kB1]*covI[ fkAxCID[kXY] ] + covI[ fkAxCID[kXZ] ];</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :     Double_t ty = fParams[kB0]*covI[ fkAxCID[kXY] ] + fParams[kB1]*covI[ fkAxCID[kYY] ] + covI[ fkAxCID[kYZ] ];</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :     Double_t tz = fParams[kB0]*covI[ fkAxCID[kXZ] ] + fParams[kB1]*covI[ fkAxCID[kYZ] ] + covI[ fkAxCID[kZZ] ];</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :     rhs   = tx*dx + ty*dy + tz*dz;</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :     denom = -(fParams[kB0]*(covI[ fkAxCID[kXZ] ] + tx) + fParams[kB1]*(covI[ fkAxCID[kYZ] ] + ty) + covI[ fkAxCID[kZZ] ]);</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     475 </span>            :   else {
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :     rhs = fParams[kB0]*dx + fParams[kB1]*dy + dz;</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :     denom = -(fParams[kB0]*fParams[kB0] + fParams[kB1]*fParams[kB1] + 1);</span>
<span class="lineNum">     478 </span>            :   }
<span class="lineNum">     479 </span>            :   //
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :   return rhs/denom;</span>
<span class="lineNum">     481 </span>            :   //
<span class="lineNum">     482 </span>            : }
<a name="483"><span class="lineNum">     483 </span>            : </a>
<span class="lineNum">     484 </span>            : //____________________________________________________
<span class="lineNum">     485 </span>            : void AliITSTPArrayFit::GetDResDPosLine(Double_t *dXYZdP, /*const Double_t *xyz,*/ const Double_t *covI/*,Double_t sclCovI*/) const
<span class="lineNum">     486 </span>            : {
<span class="lineNum">     487 </span>            :   // calculate detivative of the PCA residuals vs point position and fill in user provide
<span class="lineNum">     488 </span>            :   // array in the format {dXdXp,dY/dXp,dZdXp, ... dXdZp,dYdZp,dZdZp}
<span class="lineNum">     489 </span>            :   //
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :   Double_t dTdP[3];</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :   GetDtDPosLine(dTdP, /*xyz,*/ covI/*,sclCovI*/); // derivative of the t-param over point position</span>
<span class="lineNum">     492 </span>            :   //
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :   for (int i=3;i--;) {</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :     int var = fkAxID[i];</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :     Double_t *curd = dXYZdP + var*3;   // d/dCoord_i</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :     curd[ fkAxID[kX] ] = fParams[kB0]*dTdP[var];</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :     curd[ fkAxID[kY] ] = fParams[kB1]*dTdP[var];</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :     curd[ fkAxID[kZ] ] = dTdP[var];</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :     curd[    var     ]-= 1.;</span>
<span class="lineNum">     500 </span>            :   }
<span class="lineNum">     501 </span>            :   //
<span class="lineNum">     502 </span><span class="lineNoCov">          0 : }</span>
<a name="503"><span class="lineNum">     503 </span>            : </a>
<span class="lineNum">     504 </span>            : //____________________________________________________
<span class="lineNum">     505 </span>            : void AliITSTPArrayFit::GetDResDParamsLine(Double_t *dXYZdP, const Double_t *xyz, const Double_t *covI/*,Double_t sclCovI*/) const
<span class="lineNum">     506 </span>            : {
<span class="lineNum">     507 </span>            :   // calculate detivative of the PCA residuals vs line parameters and fill in user provide
<span class="lineNum">     508 </span>            :   // array in the format {dXdP0,dYdP0,dZdP0, ... dXdPn,dYdPn,dZdPn}
<span class="lineNum">     509 </span>            :   //
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :   Double_t dTdP[4];</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :   Double_t t = GetDtDParamsLine(dTdP, xyz, covI /*,sclCovI*/); // derivative of the t-param over line params</span>
<span class="lineNum">     512 </span>            :   //
<span class="lineNum">     513 </span>            :   Double_t *curd = dXYZdP + kA0*3; // d/dA0
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :   curd[ fkAxID[kX] ] = fParams[kB0]*dTdP[kA0] + 1.;</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :   curd[ fkAxID[kY] ] = fParams[kB1]*dTdP[kA0];</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :   curd[ fkAxID[kZ] ] = dTdP[kA0];</span>
<span class="lineNum">     517 </span>            :   //
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :   curd = dXYZdP + kB0*3; // d/dB0</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :   curd[ fkAxID[kX] ] = fParams[kB0]*dTdP[kB0] + t;</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :   curd[ fkAxID[kY] ] = fParams[kB1]*dTdP[kB0];</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :   curd[ fkAxID[kZ] ] = dTdP[kB0];</span>
<span class="lineNum">     522 </span>            :   //
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :   curd = dXYZdP + kA1*3; // d/dA1</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :   curd[ fkAxID[kX] ] = fParams[kB0]*dTdP[kA1];</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :   curd[ fkAxID[kY] ] = fParams[kB1]*dTdP[kA1] + 1.;</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :   curd[ fkAxID[kZ] ] = dTdP[kA1];</span>
<span class="lineNum">     527 </span>            :   //
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :   curd = dXYZdP + kB1*3; // d/dB1</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :   curd[ fkAxID[kX] ] = fParams[kB0]*dTdP[kB1];</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :   curd[ fkAxID[kY] ] = fParams[kB1]*dTdP[kB1] + t;</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :   curd[ fkAxID[kZ] ] = dTdP[kB1];</span>
<span class="lineNum">     532 </span>            :   //
<span class="lineNum">     533 </span><span class="lineNoCov">          0 : }</span>
<a name="534"><span class="lineNum">     534 </span>            : </a>
<span class="lineNum">     535 </span>            : //____________________________________________________
<span class="lineNum">     536 </span>            : Double_t AliITSTPArrayFit::GetDtDParamsLine(Double_t *dtparam,const Double_t *xyz, const Double_t *covI) const
<span class="lineNum">     537 </span>            : {
<span class="lineNum">     538 </span>            :   // get t-param detivative over the parameters for the point with least weighted distance to the point
<span class="lineNum">     539 </span>            :   //
<span class="lineNum">     540 </span>            :   Double_t rhs,denom;
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :   Double_t dx = fParams[kA0]-xyz[ fkAxID[kX] ];</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :   Double_t dy = fParams[kA1]-xyz[ fkAxID[kY] ];</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :   Double_t dz =             -xyz[ fkAxID[kZ] ];</span>
<span class="lineNum">     544 </span>            :   Double_t rhsDA0,rhsDA1,rhsDB0,rhsDB1,denDB0,denDB1;
<span class="lineNum">     545 </span>            :   //
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :   if (covI) {</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :     Double_t tx = fParams[kB0]*covI[ fkAxCID[kXX] ] + fParams[kB1]*covI[ fkAxCID[kXY] ] + covI[ fkAxCID[kXZ] ];</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :     Double_t ty = fParams[kB0]*covI[ fkAxCID[kXY] ] + fParams[kB1]*covI[ fkAxCID[kYY] ] + covI[ fkAxCID[kYZ] ];</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :     Double_t tz = fParams[kB0]*covI[ fkAxCID[kXZ] ] + fParams[kB1]*covI[ fkAxCID[kYZ] ] + covI[ fkAxCID[kZZ] ];</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :     rhs = tx*dx + ty*dy + tz*dz;</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :     denom = -(fParams[kB0]*(covI[ fkAxCID[kXZ] ] + tx) + fParams[kB1]*(covI[ fkAxCID[kYZ] ] + ty) + covI[ fkAxCID[kZZ] ]);</span>
<span class="lineNum">     552 </span>            :     //
<span class="lineNum">     553 </span>            :     rhsDA0 = tx;
<span class="lineNum">     554 </span>            :     rhsDA1 = ty;
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :     rhsDB0 = covI[ fkAxCID[kXX] ]*dx + covI[ fkAxCID[kXY] ]*dy + covI[ fkAxCID[kXZ] ]*dz;</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :     rhsDB1 = covI[ fkAxCID[kXY] ]*dx + covI[ fkAxCID[kYY] ]*dy + covI[ fkAxCID[kYZ] ]*dz;</span>
<span class="lineNum">     557 </span>            :     //
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :     denDB0 = -(tx + tx);</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :     denDB1 = -(ty + ty);</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     561 </span>            :   else {
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :     rhs = fParams[kB0]*dx + fParams[kB1]*dy + dz;</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :     denom = -(fParams[kB0]*fParams[kB0] + fParams[kB1]*fParams[kB1] + 1);</span>
<span class="lineNum">     564 </span>            :     //
<span class="lineNum">     565 </span>            :     rhsDA0 = fParams[kB0];
<span class="lineNum">     566 </span>            :     rhsDB0 = dx;
<span class="lineNum">     567 </span>            :     rhsDA1 = fParams[kB1];
<span class="lineNum">     568 </span>            :     rhsDB1 = dy;
<span class="lineNum">     569 </span>            :     //
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :     denDB0 = -(fParams[kB0]+fParams[kB0]);</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :     denDB1 = -(fParams[kB1]+fParams[kB1]);</span>
<span class="lineNum">     572 </span>            :     //
<span class="lineNum">     573 </span>            :   }
<span class="lineNum">     574 </span>            :   //
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :   Double_t denom2 = denom*denom;</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :   dtparam[kA0] = rhsDA0/denom;    // denom does not depend on A0,A1</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :   dtparam[kA1] = rhsDA1/denom;</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :   dtparam[kB0] = rhsDB0/denom - rhs/denom2 * denDB0;</span>
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :   dtparam[kB1] = rhsDB1/denom - rhs/denom2 * denDB1;</span>
<span class="lineNum">     580 </span>            :   //
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :   return rhs/denom;</span>
<span class="lineNum">     582 </span>            : }
<a name="583"><span class="lineNum">     583 </span>            : </a>
<span class="lineNum">     584 </span>            : //____________________________________________________
<span class="lineNum">     585 </span>            : void AliITSTPArrayFit::GetDtDPosLine(Double_t *dtpos,/*const Double_t *xyz,*/ const Double_t *covI) const
<span class="lineNum">     586 </span>            : {
<span class="lineNum">     587 </span>            :   // get t-param detivative over the parameters for the point with least weighted distance to the point
<span class="lineNum">     588 </span>            :   //
<span class="lineNum">     589 </span>            :   //  Double_t rhs;
<span class="lineNum">     590 </span>            :   //  Double_t dx = fParams[kA0]-xyz[ fkAxID[kX] ];
<span class="lineNum">     591 </span>            :   //  Double_t dy = fParams[kA1]-xyz[ fkAxID[kY] ];
<span class="lineNum">     592 </span>            :   //  Double_t dz =             -xyz[ fkAxID[kZ] ];
<span class="lineNum">     593 </span>            :   Double_t denom;
<span class="lineNum">     594 </span>            :   Double_t rhsDX,rhsDY,rhsDZ;
<span class="lineNum">     595 </span>            :   //
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :   if (covI) {</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :     Double_t tx = fParams[kB0]*covI[ fkAxCID[kXX] ] + fParams[kB1]*covI[ fkAxCID[kXY] ] + covI[ fkAxCID[kXZ] ];</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :     Double_t ty = fParams[kB0]*covI[ fkAxCID[kXY] ] + fParams[kB1]*covI[ fkAxCID[kYY] ] + covI[ fkAxCID[kYZ] ];</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :     Double_t tz = fParams[kB0]*covI[ fkAxCID[kXZ] ] + fParams[kB1]*covI[ fkAxCID[kYZ] ] + covI[ fkAxCID[kZZ] ];</span>
<span class="lineNum">     600 </span>            :     // rhs = tx*dx + ty*dy + tz*dz;
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :     denom = -(fParams[kB0]*(covI[ fkAxCID[kXZ] ] + tx) + fParams[kB1]*(covI[ fkAxCID[kYZ] ] + ty) + covI[ fkAxCID[kZZ] ]);</span>
<span class="lineNum">     602 </span>            :     //
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :     rhsDX = -tx;</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :     rhsDY = -ty;</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :     rhsDZ = -tz;</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     607 </span>            :   else {
<span class="lineNum">     608 </span>            :     // rhs = fParams[kB0]*dx + fParams[kB1]*dy + dz;
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :     denom = -(fParams[kB0]*fParams[kB0] + fParams[kB1]*fParams[kB1] + 1);</span>
<span class="lineNum">     610 </span>            :     //
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :     rhsDX = -fParams[kB0];</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :     rhsDY = -fParams[kB1];</span>
<span class="lineNum">     613 </span>            :     rhsDZ = -1;
<span class="lineNum">     614 </span>            :     //
<span class="lineNum">     615 </span>            :   }
<span class="lineNum">     616 </span>            :   //
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :   dtpos[ fkAxID[kX] ] = rhsDX/denom;</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :   dtpos[ fkAxID[kY] ] = rhsDY/denom;</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :   dtpos[ fkAxID[kZ] ] = rhsDZ/denom;</span>
<span class="lineNum">     620 </span>            :   //
<span class="lineNum">     621 </span>            :   //  return rhs/denom;
<span class="lineNum">     622 </span><span class="lineNoCov">          0 : }</span>
<a name="623"><span class="lineNum">     623 </span>            : </a>
<span class="lineNum">     624 </span>            : //____________________________________________________
<span class="lineNum">     625 </span>            : void AliITSTPArrayFit::GetDResDParamsLine(Double_t *dXYZdP, Int_t ipnt) const
<span class="lineNum">     626 </span>            : {
<span class="lineNum">     627 </span>            :   // calculate detivative of the PCA residuals vs line parameters and fill in user provide
<span class="lineNum">     628 </span>            :   // array in the format {dXdP0,dYdP0,dZdP0, ... dXdPn,dYdPn,dZdPn}
<span class="lineNum">     629 </span>            :   //
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :   if (ipnt&lt;fPntFirst || ipnt&gt;fPntLast) {</span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :     AliError(Form(&quot;Attempt to access the point %d not in the fitted points [%d:%d]&quot;,ipnt,fPntFirst,fPntLast));</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     633 </span>            :   }
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :   GetDResDParamsLine(dXYZdP, GetPoint(ipnt) , IsCovIgnored() ? 0 : GetCovI(ipnt));</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 : }</span>
<a name="636"><span class="lineNum">     636 </span>            : </a>
<span class="lineNum">     637 </span>            : //____________________________________________________
<span class="lineNum">     638 </span>            : void AliITSTPArrayFit::GetDResDPosLine(Double_t *dXYZdP, Int_t ipnt) const
<span class="lineNum">     639 </span>            : {
<span class="lineNum">     640 </span>            :   // calculate detivative of the PCA residuals vs point position and fill in user provide
<span class="lineNum">     641 </span>            :   // array in the format {dXdXp,dY/dXp,dZdXp, ... dXdZp,dYdZp,dZdZp}
<span class="lineNum">     642 </span>            :   //
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :   if (ipnt&lt;fPntFirst || ipnt&gt;fPntLast) {</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :     AliError(Form(&quot;Attempt to access the point %d not in the fitted points [%d:%d]&quot;,ipnt,fPntFirst,fPntLast));</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     646 </span>            :   }
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :   GetDResDPosLine(dXYZdP,IsCovIgnored() ? 0 : GetCovI(ipnt)/*,GetCovIScale(ipnt)*/);</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 : }</span>
<a name="649"><span class="lineNum">     649 </span>            : </a>
<span class="lineNum">     650 </span>            : //____________________________________________________
<span class="lineNum">     651 </span>            : void AliITSTPArrayFit::GetDResDParams(Double_t *dXYZdP, Int_t ipnt)
<span class="lineNum">     652 </span>            : {
<span class="lineNum">     653 </span>            :   // calculate detivative of the PCA residuals vs track parameters and fill in user provide
<span class="lineNum">     654 </span>            :   // array in the format {dXdP0,dYdP0,dZdP0, ... dXdPn,dYdPn,dZdPn}
<span class="lineNum">     655 </span>            :   //
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :   if (ipnt&lt;fPntFirst || ipnt&gt;fPntLast) {</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :     AliError(Form(&quot;Attempt to access the point %d not in the fitted points [%d:%d]&quot;,ipnt,fPntFirst,fPntLast));</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     659 </span>            :   }
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :   GetDResDParams(dXYZdP, GetPoint(ipnt) , IsCovIgnored() ? 0 : GetCovI(ipnt),GetCovIScale(ipnt));</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 : }</span>
<a name="662"><span class="lineNum">     662 </span>            : </a>
<span class="lineNum">     663 </span>            : //____________________________________________________
<span class="lineNum">     664 </span>            : void AliITSTPArrayFit::GetDResDPos(Double_t *dXYZdP, Int_t ipnt)
<span class="lineNum">     665 </span>            : {
<span class="lineNum">     666 </span>            :   // calculate detivative of the PCA residuals vs point position and fill in user provide
<span class="lineNum">     667 </span>            :   // array in the format {dXdXp,dY/dXp,dZdXp, ... dXdZp,dYdZp,dZdZp} 
<span class="lineNum">     668 </span>            :   //
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :   if (ipnt&lt;fPntFirst || ipnt&gt;fPntLast) {</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :     AliError(Form(&quot;Attempt to access the point %d not in the fitted points [%d:%d]&quot;,ipnt,fPntFirst,fPntLast));</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     672 </span>            :   }
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :   GetDResDPos(dXYZdP, GetPoint(ipnt), IsCovIgnored() ? 0 : GetCovI(ipnt), GetCovIScale(ipnt));</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 : }</span>
<a name="675"><span class="lineNum">     675 </span>            : </a>
<span class="lineNum">     676 </span>            : //____________________________________________________
<span class="lineNum">     677 </span>            : void AliITSTPArrayFit::GetDResDParams(Double_t *dXYZdP, const Double_t *xyz, const Double_t *covI, Double_t sclCovI) 
<span class="lineNum">     678 </span>            : {
<span class="lineNum">     679 </span>            :   // get residual detivatives over the track parameters for the point with least weighted distance to the point
<span class="lineNum">     680 </span>            :   //
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :   if (!IsHelix()) { // for the straight line calculate analytically</span>
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :     GetDResDParamsLine(dXYZdP, xyz, covI /*,sclCovI*/);</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     684 </span>            :   }
<span class="lineNum">     685 </span>            :   //
<span class="lineNum">     686 </span>            :   // calculate derivative numerically
<span class="lineNum">     687 </span>            :   const Double_t delta = 0.01;
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :   Double_t xyzVar[4][3];</span>
<span class="lineNum">     689 </span>            :   //
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :   for (int ipar = 5;ipar--;) {</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :     double sav = fParams[ipar];</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :     fParams[ipar] -= delta;</span>
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :     GetPosition(xyzVar[0],xyz,covI,sclCovI);</span>
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :     fParams[ipar] += delta/2;</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :     GetPosition(xyzVar[1],xyz,covI,sclCovI);</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :     fParams[ipar] += delta;</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :     GetPosition(xyzVar[2],xyz,covI,sclCovI);</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :     fParams[ipar] += delta/2;</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :     GetPosition(xyzVar[3],xyz,covI,sclCovI);</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :     fParams[ipar] = sav;  // restore</span>
<span class="lineNum">     701 </span>            :     //
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :     double *curd = dXYZdP + 3*ipar;</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :     for (int i=3;i--;) curd[i] = (8.*(xyzVar[2][i]-xyzVar[1][i]) - (xyzVar[3][i]-xyzVar[0][i]))/6./delta;</span>
<span class="lineNum">     704 </span>            :   }
<span class="lineNum">     705 </span>            :   //
<span class="lineNum">     706 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     707 </span>            : 
<a name="708"><span class="lineNum">     708 </span>            : </a>
<span class="lineNum">     709 </span>            : //____________________________________________________
<span class="lineNum">     710 </span>            : void AliITSTPArrayFit::GetDResDPos(Double_t *dXYZdP, const Double_t *xyz, const Double_t *covI,Double_t sclCovI) const
<span class="lineNum">     711 </span>            : {
<span class="lineNum">     712 </span>            :   // get residuals detivative over the point position for the point with least weighted distance to the point
<span class="lineNum">     713 </span>            :   //
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :   if (!IsHelix()) { // for the straight line calculate analytically</span>
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :     GetDResDPosLine(dXYZdP, /*xyz,*/ covI /*,sclCovI*/);</span>
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     718 </span>            :   }
<span class="lineNum">     719 </span>            :   //
<span class="lineNum">     720 </span>            :   // calculate derivative numerically
<span class="lineNum">     721 </span>            :   const Double_t delta = 0.005;
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :   Double_t xyzVar[4][3];</span>
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :   Double_t xyzv[3] = {xyz[0],xyz[1],xyz[2]};</span>
<span class="lineNum">     724 </span>            :   //
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :   for (int ipar = 3;ipar--;) {</span>
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :     double sav = xyzv[ipar];</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :     xyzv[ipar] -= delta;</span>
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :     GetPosition(xyzVar[0],xyzv,covI,sclCovI);</span>
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :     xyzv[ipar] += delta/2;</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :     GetPosition(xyzVar[1],xyzv,covI,sclCovI);</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :     xyzv[ipar] += delta;</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :     GetPosition(xyzVar[2],xyzv,covI,sclCovI);</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :     xyzv[ipar] += delta/2;</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :     GetPosition(xyzVar[3],xyzv,covI,sclCovI);</span>
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :     xyzv[ipar] = sav;  // restore</span>
<span class="lineNum">     736 </span>            :     //
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :     double *curd = dXYZdP + 3*ipar;</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :     for (int i=3;i--;) curd[i] = (8.*(xyzVar[2][i]-xyzVar[1][i]) - (xyzVar[3][i]-xyzVar[0][i]))/6./delta;</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :     curd[ipar] -= 1.;</span>
<span class="lineNum">     740 </span>            :   }
<span class="lineNum">     741 </span>            :   //
<span class="lineNum">     742 </span><span class="lineNoCov">          0 : }</span>
<a name="743"><span class="lineNum">     743 </span>            : </a>
<span class="lineNum">     744 </span>            : //________________________________________________________________________________________________________
<span class="lineNum">     745 </span>            : Double_t AliITSTPArrayFit::GetParPCAHelix(const Double_t* xyz, const Double_t* covI,Double_t sclCovI) const
<span class="lineNum">     746 </span>            : {
<span class="lineNum">     747 </span>            :   // find track parameter t (eq.2) corresponding to point of closest approach to xyz
<span class="lineNum">     748 </span>            :   //
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :   Double_t phi  = GetParPCACircle(xyz[kX],xyz[kY]); </span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :   Double_t cs = TMath::Cos(fParams[kPhi0]);</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :   Double_t sn = TMath::Sin(fParams[kPhi0]);</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :   Double_t xc = (fParams[kD0]+fParams[kR0])*cs;</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :   Double_t yc = (fParams[kD0]+fParams[kR0])*sn;</span>
<span class="lineNum">     754 </span>            :   Double_t dchi2,ddchi2;
<span class="lineNum">     755 </span>            :   //
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :   Double_t dzD  = -fParams[kR0]*fParams[kDip];</span>
<span class="lineNum">     757 </span>            :   Double_t dphi = 0;
<span class="lineNum">     758 </span>            :   //
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :   double rEps = 1e-5/TMath::Abs(fParams[kR0]); // dphi corresponding to 0.1 micron</span>
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :   if (rEps&gt;fEps) rEps = fEps;</span>
<span class="lineNum">     761 </span>            :   //
<span class="lineNum">     762 </span>            :   int it=0;
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :   do {</span>
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :     cs = TMath::Cos(phi + fParams[kPhi0]);</span>
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :     sn = TMath::Sin(phi + fParams[kPhi0]);</span>
<span class="lineNum">     766 </span>            :     //
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :     Double_t dxD  =  fParams[kR0]*sn;</span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :     Double_t dyD  = -fParams[kR0]*cs;</span>
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :     Double_t dxDD = -dyD;</span>
<span class="lineNum">     770 </span>            :     Double_t dyDD =  dxD;
<span class="lineNum">     771 </span>            :     //
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :     Double_t dx   = xc - fParams[kR0]*cs - xyz[kX];</span>
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :     Double_t dy   = yc - fParams[kR0]*sn - xyz[kY];</span>
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :     Double_t dz   = fParams[kDZ] + dzD*phi- xyz[kZ];</span>
<span class="lineNum">     775 </span>            :     //
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :     if (covI) {</span>
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :       Double_t tx = dx*covI[kXX] + dy*covI[kXY] + dz*covI[kXZ];</span>
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :       Double_t ty = dx*covI[kXY] + dy*covI[kYY] + dz*covI[kYZ];</span>
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :       Double_t tz = dx*covI[kXZ] + dy*covI[kYZ] + dz*covI[kZZ];</span>
<span class="lineNum">     780 </span>            :       //
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :       Double_t ttx = dxD*covI[kXX] + dyD*covI[kXY] + dzD*covI[kXZ];</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :       Double_t tty = dxD*covI[kXY] + dyD*covI[kYY] + dzD*covI[kYZ];</span>
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :       Double_t ttz = dxD*covI[kXZ] + dyD*covI[kYZ] + dzD*covI[kZZ];</span>
<span class="lineNum">     784 </span>            :       //
<span class="lineNum">     785 </span>            :       // chi2   = dx*tx + dy*ty + dz*tz;
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :       dchi2  = dxD*tx  + dyD*ty  + dzD*tz;</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :       ddchi2 = dxDD*tx + dyDD*ty           + dxD *ttx + dyD *tty + dzD *ttz;</span>
<span class="lineNum">     788 </span>            :       //
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :       if (sclCovI&gt;0) {dchi2 *= sclCovI; ddchi2 *= sclCovI;}</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     791 </span>            :     else {
<span class="lineNum">     792 </span>            :       // chi2   = dx*dx + dy*dy + dz*dz;
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :       dchi2  = dxD*dx  + dyD*dy  + dzD*dz;</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :       ddchi2 = dxDD*dx + dyDD*dy +         + dxD*dxD + dyD*dyD + dzD*dzD;</span>
<span class="lineNum">     795 </span>            :     }
<span class="lineNum">     796 </span>            :     //
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :     if (TMath::Abs(ddchi2)&lt;fgkAlmostZero || TMath::Abs(dphi=dchi2/ddchi2)&lt;rEps) break;</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :     phi -= dphi;    </span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :   } while(++it&lt;fMaxIter);</span>
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span>            :   //
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :   return phi;</span>
<span class="lineNum">     803 </span>            : }
<a name="804"><span class="lineNum">     804 </span>            : </a>
<span class="lineNum">     805 </span>            : //________________________________________________________________________________________________________
<span class="lineNum">     806 </span>            : Double_t AliITSTPArrayFit::GetParPCACircle(Double_t x,Double_t y)  const
<span class="lineNum">     807 </span>            : {
<span class="lineNum">     808 </span>            :   // find track parameter t (eq.2) corresponding to point on the circle with closest approach to x,y
<span class="lineNum">     809 </span>            :   //
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :   Double_t r = fParams[kD0]+fParams[kR0];</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :   Double_t t = TMath::ATan2( r*TMath::Sin(fParams[kPhi0])-y, r*TMath::Cos(fParams[kPhi0])-x ) - fParams[kPhi0]; </span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :   if (fParams[kR0] &lt; 0) t += TMath::Pi();</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :   if (t &gt; TMath::Pi())  t -= TMath::Pi()*2;</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :   if (t &lt;-TMath::Pi())  t += TMath::Pi()*2;</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :   return t;</span>
<span class="lineNum">     816 </span>            : }
<a name="817"><span class="lineNum">     817 </span>            : </a>
<span class="lineNum">     818 </span>            : //________________________________________________________________________________________________________
<span class="lineNum">     819 </span>            : Double_t AliITSTPArrayFit::GetHelixParAtR(Double_t r)  const
<span class="lineNum">     820 </span>            : {
<span class="lineNum">     821 </span>            :   // find helix parameter t (eq.2) corresponding to point on the circle of radius t
<span class="lineNum">     822 </span>            :   //
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :   double gam = 1. - (r-fParams[kD0])*(r+fParams[kD0])/fParams[kR0]/(fParams[kD0]+fParams[kR0])/2.;</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :   return (TMath::Abs(gam)&gt;1) ?  -1e9 : TMath::ACos(gam);</span>
<span class="lineNum">     825 </span>            : }
<a name="826"><span class="lineNum">     826 </span>            : </a>
<span class="lineNum">     827 </span>            : //________________________________________________________________________________________________________
<span class="lineNum">     828 </span>            : Double_t AliITSTPArrayFit::CalcChi2NDF() const
<span class="lineNum">     829 </span>            : {
<span class="lineNum">     830 </span>            :   // calculate fit chi2/ndf
<span class="lineNum">     831 </span>            :   Double_t chi2 = 0;
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :   Double_t dr[3]; // residuals</span>
<span class="lineNum">     833 </span>            :   //if (!IsFitDone()) return -1;
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :   for (int ipnt=fPntFirst;ipnt&lt;=fPntLast;ipnt++) {</span>
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :     GetResiduals(dr,ipnt);</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :     Double_t* covI = GetCovI(ipnt);</span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :     Double_t chi2p = dr[kX]*(dr[kX]*covI[ kXX ]+dr[kY]*covI[ kXY ]+dr[kZ]*covI[ kXZ ])</span>
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :       +              dr[kY]*(dr[kX]*covI[ kXY ]+dr[kY]*covI[ kYY ]+dr[kZ]*covI[ kYZ ])</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :       +              dr[kZ]*(dr[kX]*covI[ kXZ ]+dr[kY]*covI[ kYZ ]+dr[kZ]*covI[ kZZ ]);</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :     if (covI[kScl]&gt;0) chi2p *= covI[kScl]; // rescaling was requested for this point's errors</span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :     chi2 += chi2p;</span>
<span class="lineNum">     842 </span>            :   }
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :   int ndf = (fPntLast-fPntFirst+1)*3 - GetNParams();</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :   chi2 /= ndf;</span>
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :   return chi2;</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 : }</span>
<a name="847"><span class="lineNum">     847 </span>            : </a>
<span class="lineNum">     848 </span>            : //________________________________________________________________________________________________________
<span class="lineNum">     849 </span>            : void AliITSTPArrayFit::GetResiduals(Double_t *res,Int_t ipnt) const
<span class="lineNum">     850 </span>            : {
<span class="lineNum">     851 </span>            :   // calculate residuals at point
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :   if (ipnt&lt;fPntFirst || ipnt&gt;fPntLast) {</span>
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :     AliError(Form(&quot;Attempt to access the point %d not in the fitted points [%d:%d]&quot;,ipnt,fPntFirst,fPntLast));</span>
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     855 </span>            :   }
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :   GetPosition(res,fCurT[ipnt]);</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :   res[kX] -= fkPoints-&gt;GetX()[ipnt];</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :   res[kY] -= fkPoints-&gt;GetY()[ipnt];</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :   res[kZ] -= fkPoints-&gt;GetZ()[ipnt];</span>
<span class="lineNum">     860 </span><span class="lineNoCov">          0 : }</span>
<a name="861"><span class="lineNum">     861 </span>            : </a>
<span class="lineNum">     862 </span>            : //________________________________________________________________________________________________________
<span class="lineNum">     863 </span>            : void AliITSTPArrayFit::GetPosition(Double_t *xyz, Double_t t) const
<span class="lineNum">     864 </span>            : {
<span class="lineNum">     865 </span>            :   // calculate track position for parameter value t
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :   if (IsHelix()) {</span>
<span class="lineNum">     867 </span>            :     //
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :     Double_t rrho = fParams[kD0]+fParams[kR0];</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :     Double_t xc = rrho*TMath::Cos(fParams[kPhi0]);</span>
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :     Double_t yc = rrho*TMath::Sin(fParams[kPhi0]);</span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :     Double_t r  = fParams[kR0];</span>
<span class="lineNum">     872 </span>            :     Double_t ze = 0;
<span class="lineNum">     873 </span>            :     //
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :     if (IsELossON()) {</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :       if (t&gt;0) {</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :         for (int i=fFirstPosT;i&lt;fNElsPnt;i++) { // along the track direction</span>
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :           int indE = fElsId[i];</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :           if ( t&lt;fCurT[indE] ) break;       // does not reach this layer on  its way to t </span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :           xc += fElsDR[indE] * TMath::Cos(fParams[kPhi0] + fCurT[indE]);</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :           yc += fElsDR[indE] * TMath::Sin(fParams[kPhi0] + fCurT[indE]);</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :           ze += fElsDR[indE] * fCurT[indE];</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :           r  += fElsDR[indE];</span>
<span class="lineNum">     883 </span>            :           //printf(&quot;ELoss@ %+.2e r:%+.3e got %+.3e\n&quot;,fCurT[indE],r,fElsDR[indE]);
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :       } else {</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :         for (int i=fFirstPosT;i--;) { // against the track direction</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :           int indE = fElsId[i];</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :           if ( t&gt;=fCurT[indE] ) break;       // does not reach this layer on  its way to t </span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :           xc += fElsDR[indE] * TMath::Cos(fParams[kPhi0] + fCurT[indE]);</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :           yc += fElsDR[indE] * TMath::Sin(fParams[kPhi0] + fCurT[indE]);</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :           ze += fElsDR[indE] * fCurT[indE];</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :           r  += fElsDR[indE];</span>
<span class="lineNum">     893 </span>            :           //printf(&quot;ELoss@ %+.2e r:%+.3e got %+.3e\n&quot;,fCurT[indE],r,fElsDR[indE]);
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :         }     </span>
<span class="lineNum">     895 </span>            :       }
<span class="lineNum">     896 </span>            :     }
<span class="lineNum">     897 </span>            :     //
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :     xyz[kZ] = fParams[kDZ] - fParams[kDip]*(t*r - ze);</span>
<span class="lineNum">     899 </span>            :     //
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :     t += fParams[kPhi0];    </span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :     xyz[kX] = xc - r*TMath::Cos(t);</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :     xyz[kY] = yc - r*TMath::Sin(t);</span>
<span class="lineNum">     903 </span>            :     //    printf(&quot;t: %+.3e xyz:%+.2e %+.2e %+.2e | R %+.6e -&gt; %+.6e | sign %d\n&quot;,t-fParams[kPhi0],xyz[0],xyz[1],xyz[2],fParams[kR0],r,GetSignQB());
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     905 </span>            :   else {
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :     xyz[ fkAxID[kX] ] = fParams[kA0] + fParams[kB0]*t;</span>
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :     xyz[ fkAxID[kY] ] = fParams[kA1] + fParams[kB1]*t;</span>
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :     xyz[ fParAxis   ] = t;</span>
<span class="lineNum">     909 </span>            :   }
<span class="lineNum">     910 </span><span class="lineNoCov">          0 : }</span>
<a name="911"><span class="lineNum">     911 </span>            : </a>
<span class="lineNum">     912 </span>            : //________________________________________________________________________________________________________
<span class="lineNum">     913 </span>            : void AliITSTPArrayFit::GetDirCos(Double_t *dircos, Double_t t) const
<span class="lineNum">     914 </span>            : {
<span class="lineNum">     915 </span>            :   // calculate track direction cosines for parameter value t
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :   if (IsHelix()) {</span>
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :     dircos[kZ] = -fParams[kDip];</span>
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :     t += fParams[kPhi0];    </span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :     dircos[kX] = TMath::Sin(t);</span>
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :     dircos[kY] =-TMath::Cos(t);</span>
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :     double gam = TMath::Sign(1/TMath::Sqrt(dircos[kZ]*dircos[kZ]+dircos[kY]*dircos[kY]+dircos[kX]*dircos[kX]),fParams[kR0]);</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :     for (int i=3;i--;) dircos[i] *= gam;</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :     if (GetSignQB()&gt;0) for (int i=3;i--;) dircos[i] = -dircos[i]; // positive tracks move along decreasing t</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     925 </span>            :   else {
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :     double gam = 1/TMath::Sqrt( fParams[kB0]*fParams[kB0] + fParams[kB1]*fParams[kB1] + 1.);</span>
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :     dircos[ fkAxID[kX] ] = fParams[kB0]*gam;</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :     dircos[ fkAxID[kY] ] = fParams[kB1]*gam;</span>
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :     dircos[ fParAxis   ] = gam;</span>
<span class="lineNum">     930 </span>            :     // decide direction
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :     if (IsTypeCollision()) {</span>
<span class="lineNum">     932 </span>            :       static double xyzF[3],xyzL[3];
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :       GetPosition(xyzF,fPntFirst);</span>
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :       GetPosition(xyzL,fPntLast);</span>
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :       double dif = fCurT[fPntLast] - fCurT[fPntFirst];</span>
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :       double dr = (xyzL[kX]-xyzF[kX])*(xyzL[kX]+xyzF[kX]) + (xyzL[kY]-xyzF[kY])*(xyzL[kY]+xyzF[kY]);</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :       if (dr*dif&lt;0) for (int i=3;i--;) dircos[i] = -dircos[i]; // with increasing t the tracks comes closer to origin</span>
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :     else if (dircos[kY]&gt;0) for (int i=3;i--;) dircos[i] = -dircos[i];  // cosmic tracks have negative angle to Y axis</span>
<span class="lineNum">     940 </span>            :   }
<span class="lineNum">     941 </span>            :   //
<span class="lineNum">     942 </span><span class="lineNoCov">          0 : }</span>
<a name="943"><span class="lineNum">     943 </span>            : </a>
<span class="lineNum">     944 </span>            : //________________________________________________________________________________________________________
<span class="lineNum">     945 </span>            : Double_t AliITSTPArrayFit::GetMachinePrec()
<span class="lineNum">     946 </span>            : {
<span class="lineNum">     947 </span>            :   // estimate machine precision
<span class="lineNum">     948 </span>            :   Double_t eps=1.0,a;
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :   do { a = 1. + (eps=eps/2.0); } while(a&gt;1.);</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :   return TMath::Abs(2.*eps);</span>
<span class="lineNum">     951 </span>            : }
<a name="952"><span class="lineNum">     952 </span>            : </a>
<span class="lineNum">     953 </span>            : //________________________________________________________________________________________________________
<span class="lineNum">     954 </span>            : Bool_t AliITSTPArrayFit::FitHelixCrude(Int_t extQ)
<span class="lineNum">     955 </span>            : {
<span class="lineNum">     956 </span>            :   // crude estimate of helix parameters, w/o errors and Eloss.
<span class="lineNum">     957 </span>            :   // Fast Riemann fit: Comp.Phy.Comm.131 (2000) 95
<span class="lineNum">     958 </span>            :   //
<span class="lineNum">     959 </span>            :   // if charge is not imposed (extQ==0) then it will be determined from the collision type
<span class="lineNum">     960 </span>            :   //
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :   static TArrayD arrU,arrV,arrW;</span>
<span class="lineNum">     962 </span>            :   double *parrW,*parrU,*parrV;
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :   Bool_t eloss = IsELossON();</span>
<span class="lineNum">     964 </span>            :   //
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :   int np = fPntLast - fPntFirst + 1;</span>
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :   if (np&lt;3) { AliError(&quot;At least 3 points are needed for helix fit&quot;); return kFALSE; }</span>
<span class="lineNum">     967 </span>            :   //
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :   const float *x=fkPoints-&gt;GetX(),*y=fkPoints-&gt;GetY(),*z=fkPoints-&gt;GetZ(),*cov=fkPoints-&gt;GetCov();</span>
<span class="lineNum">     969 </span>            :   //
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :   if (fPntLast&gt;=arrU.GetSize()) {</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :     arrU.Set(2*fPntLast);</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :     arrV.Set(2*fPntLast);</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :     arrW.Set(2*fPntLast);</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :   parrU = arrU.GetArray();</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :   parrV = arrV.GetArray();</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :   parrW = arrW.GetArray();</span>
<span class="lineNum">     978 </span>            :   //
<span class="lineNum">     979 </span>            :   double uav=0,vav=0,wav=0,muu=0,muv=0,muw=0,mvv=0,mvw=0,mww=0;
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :   int minRId = fPntFirst;</span>
<span class="lineNum">     981 </span>            :   //  
<span class="lineNum">     982 </span>            :   // get points span
<span class="lineNum">     983 </span>            :   double xmn=1e9,xmx=-1e9, ymn=1e9,ymx=-1e9;
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :   for (int i=fPntFirst;i&lt;=fPntLast;i++) {</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :     parrW[i] = x[i]*x[i]+y[i]*y[i];</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :     if (parrW[i]&lt;parrW[minRId]) minRId = i; // point closest to origin</span>
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :     if (xmn&gt;x[i]) xmn = x[i];</span>
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :     if (xmx&lt;x[i]) xmx = x[i];</span>
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :     if (ymn&gt;y[i]) ymn = y[i];</span>
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :     if (ymx&lt;y[i]) ymx = y[i];</span>
<span class="lineNum">     991 </span>            :   }
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :   int minRId1 = minRId&gt;fPntFirst ? fPntFirst:fPntFirst+1;</span>
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :   for (int i=fPntFirst;i&lt;=fPntLast;i++) if (parrW[i]&lt;parrW[minRId1] &amp;&amp; i!=minRId) minRId1 = i; </span>
<span class="lineNum">     994 </span>            :   //
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :   double xshift = (xmx+xmn)/2 + 10*(ymx-ymn); // shift origin to have uniform weights</span>
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :   double yshift = (ymx+ymn)/2 - 10*(xmx-xmn);</span>
<span class="lineNum">     997 </span>            :   //  printf(&quot;X: %+e %+e Y: %+e %+e | shift: %+e %+e\n&quot;,xmn,xmx,ymn,ymx,xshift,yshift);
<span class="lineNum">     998 </span>            :   //
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :   for (int i=fPntFirst;i&lt;=fPntLast;i++) {</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :     double xs = x[i] - xshift;</span>
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :     double ys = y[i] - yshift;</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :     double w = xs*xs + ys*ys;</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :     double scl = 1./(1.+w);</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :     int i0 = i-fPntFirst;</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :     wav += parrW[i0] = w*scl;</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :     uav += parrU[i0] = xs*scl;</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :     vav += parrV[i0] = ys*scl;</span>
<span class="lineNum">    1008 </span>            :   }
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :   uav /= np;    vav /= np;   wav /= np;</span>
<span class="lineNum">    1010 </span>            :   //
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :   for (int i=fPntFirst;i&lt;=fPntLast;i++) {</span>
<span class="lineNum">    1012 </span>            :     //
<span class="lineNum">    1013 </span>            :     // point next to closest
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :     int i0 = i-fPntFirst;</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :     if (parrW[i0]&lt;parrW[minRId1-fPntFirst] &amp;&amp; i!=minRId) minRId1 = i; </span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :     double u = parrU[i0] - uav;</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :     double v = parrV[i0] - vav;</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :     double w = parrW[i0] - wav;</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :     muu += u*u;</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :     muv += u*v;</span>
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :     muw += u*w;</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :     mvv += v*v;</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :     mvw += v*w;</span>
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :     mww += w*w;</span>
<span class="lineNum">    1025 </span>            :   } 
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :   muu/=np; muv/=np; muw/=np; mvv/=np; mvw/=np; mww/=np;</span>
<span class="lineNum">    1027 </span>            :   //
<span class="lineNum">    1028 </span>            :   // find eigenvalues:
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :   double trace3 = (muu + mvv + mww)/3.;</span>
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :   double muut = muu-trace3;</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :   double mvvt = mvv-trace3;</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :   double mwwt = mww-trace3;</span>
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :   double q = (muut*(mvvt*mwwt-mvw*mvw) - muv*(muv*mwwt-mvw*muw) + muw*(muv*mvw-mvvt*muw))/2;</span>
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :   double p = (muut*muut+mvvt*mvvt+mwwt*mwwt+2*(muv*muv+muw*muw+mvw*mvw))/6;</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :   double dfpp = p*p*p-q*q;</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :   dfpp = dfpp&gt;0 ? TMath::Sqrt(dfpp)/q : 0;</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :   double ph = TMath::ATan( dfpp )/3.;</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :   if (ph&lt;0) ph += TMath::Pi()/3;</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :   p = p&gt;0 ? TMath::Sqrt(p) : 0;</span>
<span class="lineNum">    1040 </span>            :   const double kSqrt3 = 1.73205080;
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :   double snp = TMath::Sin(ph);</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :   double csp = TMath::Cos(ph);</span>
<span class="lineNum">    1043 </span>            :   //  double eg1 = trace3 + 2*p*csp;
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :   double eg2 = trace3 - p*(csp+kSqrt3*snp); // smallest one</span>
<span class="lineNum">    1045 </span>            :   //  double eg3 = trace3 - p*(csp-kSqrt3*snp);
<span class="lineNum">    1046 </span>            :   // eigenvector for min.eigenvalue
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :   muut = muu-eg2;</span>
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :   mvvt = mvv-eg2;</span>
<span class="lineNum">    1049 </span>            :   mwwt = mww-eg2;
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :   double n0 = muv*mvw-muw*mvvt;</span>
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :   double n1 = muv*muw-mvw*muut;</span>
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :   double n2 = muut*mvvt-muv*muv;</span>
<span class="lineNum">    1053 </span>            :   // normalize to largest one
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :   double nrm = TMath::Abs(n0);</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :   if (nrm&lt;TMath::Abs(n1)) nrm = TMath::Abs(n1);</span>
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :   if (nrm&lt;TMath::Abs(n2)) nrm = TMath::Abs(n2);</span>
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :   n0/=nrm; n1/=nrm; n2/=nrm;</span>
<span class="lineNum">    1058 </span>            :   //
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :   double cpar = -(uav*n0 + vav*n1 + wav*n2);</span>
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :   double xc = -n0/(cpar+n2)/2 + xshift;</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :   double yc = -n1/(cpar+n2)/2 + yshift;</span>
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :   double rad = TMath::Sqrt(n0*n0+n1*n1-4*cpar*(cpar+n2))/2./TMath::Abs(cpar+n2);</span>
<span class="lineNum">    1063 </span>            :   //
<span class="lineNum">    1064 </span>            :   //  printf(&quot;Rad: %+e xc: %+e yc: %+e | X0: %+e Y0: %+e | X1: %+e Y1: %+e\n&quot;,rad,xc,yc, x[minRId],y[minRId],x[minRId1],y[minRId1]);
<span class="lineNum">    1065 </span>            : 
<span class="lineNum">    1066 </span>            :   // linear circle fit --------------------------------------------------- &lt;&lt;&lt;
<span class="lineNum">    1067 </span>            :   //
<span class="lineNum">    1068 </span>            :   // decide sign(Q*B) and fill cicrle parameters ------------------------- &gt;&gt;&gt;
<span class="lineNum">    1069 </span>            :   int sqb;
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :   if (extQ) {</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :     SetCharge(extQ); </span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :     sqb = fBz&lt;0 ? -GetCharge():GetCharge();</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1074 </span>            :   else { 
<span class="lineNum">    1075 </span>            :     // determine the charge from the collision type and field sign
<span class="lineNum">    1076 </span>            :     // the negative Q*B will have positive Vc x dir product Z component
<span class="lineNum">    1077 </span>            :     // with Vc={-xc,-yc} : vector from circle center to the origin
<span class="lineNum">    1078 </span>            :     // and V0 - track direction vector (take {0,-1,1} for cosmics)
<span class="lineNum">    1079 </span>            :     // If Bz is not provided, assume positive Bz
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :     if ( IsTypeCosmics() ) sqb = xc&gt;0 ? -1:1;</span>
<span class="lineNum">    1081 </span>            :     else {
<span class="lineNum">    1082 </span>            :       // track direction vector as a - diference between the closest and the next to closest to origin points
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :       double v0X = x[minRId1] - x[minRId];</span>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :       double v0Y = y[minRId1] - y[minRId];</span>
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :       sqb = (yc*v0X - xc*v0Y)&gt;0 ? -1:1;</span>
<span class="lineNum">    1086 </span>            :     }
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :     SetCharge( fBz&lt;0 ? -sqb : sqb);</span>
<span class="lineNum">    1088 </span>            :   }
<span class="lineNum">    1089 </span>            :   //
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :   Double_t phi = TMath::ATan2(yc,xc);</span>
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :   if (sqb&lt;0) phi += TMath::Pi();</span>
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :   if      (phi &gt; TMath::Pi()) phi -= 2.*TMath::Pi();</span>
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :   else if (phi &lt;-TMath::Pi()) phi += 2.*TMath::Pi();</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :   fParams[kPhi0] = phi;  </span>
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :   fParams[kR0]   = sqb&lt;0 ? -rad:rad;  </span>
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :   fParams[kD0] = xc*TMath::Cos(phi) + yc*TMath::Sin(phi) - fParams[kR0];</span>
<span class="lineNum">    1097 </span>            :   //
<span class="lineNum">    1098 </span>            :   // decide sign(Q*B) and fill cicrle parameters ------------------------- &lt;&lt;&lt;
<span class="lineNum">    1099 </span>            :   //
<span class="lineNum">    1100 </span>            :   // find z-offset and dip + the parameter t of closest approach to hits - &gt;&gt;&gt;
<span class="lineNum">    1101 </span>            :   //
<span class="lineNum">    1102 </span>            :   UInt_t hitLrPos=0;  // pattern of hit layers at pos
<span class="lineNum">    1103 </span>            :   UInt_t hitLrNeg=0;  // and negative t's
<span class="lineNum">    1104 </span>            : 
<span class="lineNum">    1105 </span>            :   Double_t ss=0,st=0,sz=0,stt=0,szt=0;
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :   for (int i=fPntFirst;i&lt;=fPntLast;i++) {</span>
<span class="lineNum">    1107 </span>            :     //
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :     Double_t ze2 = cov[i*6 + kZZ];</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :     Double_t t = TMath::ATan2(yc-y[i],xc-x[i]) - fParams[kPhi0]; // angle at measured z</span>
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :     if (fParams[kR0]&lt;0)  t += TMath::Pi();</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :     if      (t &gt; TMath::Pi()) t -= TMath::Pi()*2;</span>
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :     else if (t &lt;-TMath::Pi()) t += TMath::Pi()*2;</span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :     if (ze2&lt;fgkAlmostZero) ze2 = 1E-8;</span>
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :     ze2 = 1./ze2;</span>
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :     ss += ze2;</span>
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :     st += t*ze2;</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :     stt+= t*t*ze2;</span>
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :     sz += z[i]*ze2;</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :     szt+= z[i]*t*ze2;</span>
<span class="lineNum">    1120 </span>            :     //
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :     fCurT[i] = t; // parameter of the closest approach to the point</span>
<span class="lineNum">    1122 </span>            :     //    printf(&quot;%d %+e %+e %+e %+e\n&quot;,i,x[i],y[i],z[i],t);
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :     if (eloss) {</span>
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :       double r = TMath::Sqrt(x[i]*x[i]+y[i]*y[i]);</span>
<span class="lineNum">    1125 </span>            :       int lr;
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :       for (lr=kMaxLrITS;lr--;) if ( IsZero(r-fgkRLayITS[ lr ],1.) ) break;</span>
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :       if (lr&lt;kMaxLrITS) {</span>
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :         if (t&gt;0) hitLrPos |= (1&lt;&lt;lr);  // set bit of the layer</span>
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :         else     hitLrNeg |= (1&lt;&lt;lr);  // set bit of the layer</span>
<span class="lineNum">    1130 </span>            :       }
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1132 </span>            :   }
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :   double det = ss*stt - st*st;</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :   if (TMath::Abs(det)&lt;fgkAlmostZero) { // no Z dependence</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :     fParams[kDZ]  = sz/ss;</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :     fParams[kDip] = 0;</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1138 </span>            :   else {
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :     fParams[kDZ]  =  (sz*stt-st*szt)/det;</span>
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :     fParams[kDip] = -(ss*szt-st*sz)/det/fParams[kR0];</span>
<span class="lineNum">    1141 </span>            :   }
<span class="lineNum">    1142 </span>            :   //
<span class="lineNum">    1143 </span>            :   // find z-offset and dip + the parameter t of closest approach to hits - &lt;&lt;&lt;
<span class="lineNum">    1144 </span>            :   //
<span class="lineNum">    1145 </span>            :   // fill info needed to account for ELoss ------------------------------- &gt;&gt;&gt;
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :   if (eloss) {</span>
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :     fNElsPnt = fPntLast - fPntFirst + 1;</span>
<span class="lineNum">    1148 </span>            :     //
<span class="lineNum">    1149 </span>            :     // to account for the energy loss in the passive volumes, calculate the relevant t-parameters 
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :     double* tcur = fCurT + fPntFirst;</span>
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :     double* ecur = fElsDR+ fPntFirst;</span>
<span class="lineNum">    1152 </span>            :     //
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :     for (int ilp=3;ilp--;) {</span>
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :       int id = fgkPassivLrITS[ilp];</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :       double tp = GetHelixParAtR( fgkRLayITS[ id ] );</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :       if (tp&lt;0) continue; // does not hit this radius</span>
<span class="lineNum">    1157 </span>            :       //
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :       tcur[fNElsPnt] = GetSignQB()&gt;0 ? -tp : tp;</span>
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :       ecur[fNElsPnt] = fgRhoLITS[ id ];</span>
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :       fNElsPnt++;</span>
<span class="lineNum">    1161 </span>            :       //      printf(&quot;Passive  on lr %d  %+e\n&quot;,ilp,tcur[fNElsPnt-1]);
<span class="lineNum">    1162 </span>            :       //
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :       if (IsTypeCosmics() &amp;&amp; !IsZero(tp)) { // 2 crossings for cosmics</span>
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :         tcur[fNElsPnt] = -tcur[fNElsPnt-1];</span>
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :         ecur[fNElsPnt] =  ecur[fNElsPnt-1];</span>
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :         fNElsPnt++;</span>
<span class="lineNum">    1167 </span>            :         //printf(&quot;Passive* on lr %d  %+e\n&quot;,ilp,-tcur[fNElsPnt-1]);
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1169 </span>            :       //
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1171 </span>            :     // check if some active layers did not miss the hit, treat them as passive
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :     for (int ilp=6;ilp--;) {</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :       int id = fgkActiveLrITS[ilp];</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :       double tp = GetHelixParAtR( fgkRLayITS[ id ] );</span>
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :       if (tp&lt;0) continue; // does not hit this radius</span>
<span class="lineNum">    1176 </span>            :       //
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :       if ( (GetSignQB()&gt;0||IsTypeCosmics()) &amp;&amp; !(hitLrNeg &amp; (1&lt;&lt;id)) ) {</span>
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :         tcur[fNElsPnt] = -tp;</span>
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :         ecur[fNElsPnt] = fgRhoLITS[ id ];</span>
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :         fNElsPnt++;</span>
<span class="lineNum">    1181 </span>            :         //printf(&quot;Missed  on lr %d  %+e\n&quot;,ilp,-tp);
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1183 </span>            :       //
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :       if ( (GetSignQB()&lt;0||IsTypeCosmics()) &amp;&amp; !(hitLrPos &amp; (1&lt;&lt;id)) ) {</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :         tcur[fNElsPnt] = tp;</span>
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :         ecur[fNElsPnt] = fgRhoLITS[ id ];</span>
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :         fNElsPnt++;</span>
<span class="lineNum">    1188 </span>            :         //printf(&quot;Missed* on lr %d  %e\n&quot;,ilp,tp);
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1191 </span>            :     //
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :     TMath::Sort(fNElsPnt,fCurT+fPntFirst,fElsId,kFALSE);    // index e-loss points in increasing order</span>
<span class="lineNum">    1193 </span>            :     // find the position of smallest positive t-param
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :     for (fFirstPosT=0;fFirstPosT&lt;fNElsPnt;fFirstPosT++) if (fCurT[ fElsId[ fFirstPosT ] ]&gt;0) break;</span>
<span class="lineNum">    1195 </span>            :     //
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :     Double_t cdip = 1./TMath::Sqrt(1.+fParams[kDip]*fParams[kDip]);</span>
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :     Double_t ptot = TMath::Abs(fParams[kR0]*fgkCQConv*fBz/cdip); // momentum and energy</span>
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :     Double_t etot = TMath::Sqrt(ptot*ptot + fMass*fMass);      // in the point of closest approach to beam</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :     Double_t normS[3];</span>
<span class="lineNum">    1200 </span>            :     //
<span class="lineNum">    1201 </span>            :     // Positive t-params: along the track direction for negative track, against for positive
<span class="lineNum">    1202 </span>            :     //   Double_t pcur = ptot, ecurr = etot;
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :     for (int ip=fFirstPosT;ip&lt;fNElsPnt;ip++) {</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :       int tID = fElsId[ip];</span>
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 :       Double_t t = fCurT[ tID ];</span>
<span class="lineNum">    1206 </span>            :       //
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :       if (tID&gt;fPntLast) { // this is not a hit layer but passive layer</span>
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :         double php = TMath::ATan2(yc-fParams[kR0]*TMath::Cos(fParams[kPhi0]+t),</span>
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :                                   xc-fParams[kR0]*TMath::Cos(fParams[kPhi0]+t));</span>
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :         normS[0] = -TMath::Cos(php);  // normal to the cylinder at intersection point</span>
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :         normS[1] = -TMath::Sin(php);</span>
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :         normS[2] = 0;</span>
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :       else GetNormal(normS,fkPoints-&gt;GetCov()+tID*6);   // vector normal to hit module</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :       fElsDR[tID] = GetDRofELoss(t,cdip,fElsDR[tID],normS,ptot,etot);</span>
<span class="lineNum">    1216 </span>            :     }
<span class="lineNum">    1217 </span>            :     //
<span class="lineNum">    1218 </span>            :     // negaive t-params: against the track direction for negative track, along for positive
<span class="lineNum">    1219 </span>            :     //    pcur  = ptot;
<span class="lineNum">    1220 </span>            :     //    ecurr = etot;
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :     for (int ip=fFirstPosT;ip--;) {</span>
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :       int tID = fElsId[ip];</span>
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :       Double_t t = fCurT[ tID ];</span>
<span class="lineNum">    1224 </span>            :       //
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :       if (tID&gt;fPntLast) { // this is not a hit layer but passive layer</span>
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :         double php = TMath::ATan2(yc-fParams[kR0]*TMath::Cos(fParams[kPhi0]+t),</span>
<span class="lineNum">    1227 </span><span class="lineNoCov">          0 :                                   xc-fParams[kR0]*TMath::Cos(fParams[kPhi0]+t));</span>
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :         normS[0] = -TMath::Cos(php);  // normal to the cylinder at intersection point</span>
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :         normS[1] = -TMath::Sin(php);</span>
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :         normS[2] = 0;   </span>
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :       else GetNormal(normS,fkPoints-&gt;GetCov()+tID*6);   // vector normal to hit module</span>
<span class="lineNum">    1233 </span>            :       //
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :       fElsDR[tID] = GetDRofELoss(t,cdip,fElsDR[tID],normS,ptot,etot);</span>
<span class="lineNum">    1235 </span>            :     }
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1237 </span>            :   // fill info needed to account for ELoss ------------------------------- &lt;&lt;&lt;
<span class="lineNum">    1238 </span>            :   //
<span class="lineNum">    1239 </span>            :   return kTRUE;
<span class="lineNum">    1240 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1241 </span>            : 
<span class="lineNum">    1242 </span>            : /*
<span class="lineNum">    1243 </span>            : //________________________________________________________________________________________________________
<span class="lineNum">    1244 </span>            : Bool_t AliITSTPArrayFit::FitHelixCrude(Int_t extQ)
<span class="lineNum">    1245 </span>            : {
<span class="lineNum">    1246 </span>            :   // crude estimate of helix parameters, w/o errors and Eloss.
<span class="lineNum">    1247 </span>            :   // 1st fit the circle (R,xc,yc) by minimizing
<span class="lineNum">    1248 </span>            :   // chi2 = sum{ (bx*xi + by*yi + xi^2+yi^2 + rho)^2 } vs bx,by,rho
<span class="lineNum">    1249 </span>            :   // with bx = -2*xc, by = -2*yc , rho = xc^2+yc^2 - R2
<span class="lineNum">    1250 </span>            :   //
<span class="lineNum">    1251 </span>            :   // if charge is not imposed (extQ==0) then it will be determined from the collision type
<span class="lineNum">    1252 </span>            :   //
<span class="lineNum">    1253 </span>            :   Bool_t eloss = IsELossON();
<span class="lineNum">    1254 </span>            :   //
<span class="lineNum">    1255 </span>            :   int np = fPntLast - fPntFirst + 1;
<span class="lineNum">    1256 </span>            :   if (np&lt;3) { AliError(&quot;At least 3 points are needed for helix fit&quot;); return kFALSE; }
<span class="lineNum">    1257 </span>            :   //
<span class="lineNum">    1258 </span>            :   const float *x=fkPoints-&gt;GetX(),*y=fkPoints-&gt;GetY(),*z=fkPoints-&gt;GetZ(),*cov=fkPoints-&gt;GetCov();
<span class="lineNum">    1259 </span>            :   //
<span class="lineNum">    1260 </span>            :   // linear circle fit --------------------------------------------------- &gt;&gt;&gt;
<span class="lineNum">    1261 </span>            :   Double_t sxx=0,sxy=0,syy=0,sx=0,sy=0,rhs0=0,rhs1=0,rhs2=0,minR=1E9;
<span class="lineNum">    1262 </span>            :   int minRId = 0;
<span class="lineNum">    1263 </span>            :   for (int i=fPntFirst;i&lt;=fPntLast;i++) {
<span class="lineNum">    1264 </span>            :     Double_t xx = x[i]*x[i];
<span class="lineNum">    1265 </span>            :     Double_t yy = y[i]*y[i];
<span class="lineNum">    1266 </span>            :     Double_t xy = x[i]*y[i];
<span class="lineNum">    1267 </span>            :     Double_t xxyy = xx + yy;
<span class="lineNum">    1268 </span>            :     //
<span class="lineNum">    1269 </span>            :     sxx += xx;
<span class="lineNum">    1270 </span>            :     sxy += xy;
<span class="lineNum">    1271 </span>            :     syy += yy;
<span class="lineNum">    1272 </span>            :     sx  += x[i];
<span class="lineNum">    1273 </span>            :     sy  += y[i];
<span class="lineNum">    1274 </span>            :     //
<span class="lineNum">    1275 </span>            :     rhs0 -= xxyy*x[i];
<span class="lineNum">    1276 </span>            :     rhs1 -= xxyy*y[i];
<span class="lineNum">    1277 </span>            :     rhs2 -= xxyy;
<span class="lineNum">    1278 </span>            :     // 
<span class="lineNum">    1279 </span>            :     // remember Id of the point closest to origin, to determine the charge  
<span class="lineNum">    1280 </span>            :     if (xxyy&lt;minR) { minR   = xxyy; minRId = i; }
<span class="lineNum">    1281 </span>            :     //
<span class="lineNum">    1282 </span>            :     if (eloss) { // find layer id
<span class="lineNum">    1283 </span>            :       int lrid,volid = fkPoints-&gt;GetVolumeID()[i];
<span class="lineNum">    1284 </span>            :       if (volid&gt;0) lrid = fgkActiveLrITS[AliGeomManager::VolUIDToLayer(fkPoints-&gt;GetVolumeID()[i])-1];
<span class="lineNum">    1285 </span>            :       else { // missing layer info, find from radius
<span class="lineNum">    1286 </span>            :         double r = TMath::Sqrt(xxyy);
<span class="lineNum">    1287 </span>            :         for (lrid=kMaxLrITS;lrid--;) if ( IsZero(r-fgkRLayITS[ lrid ],1.) ) break;
<span class="lineNum">    1288 </span>            :       }
<span class="lineNum">    1289 </span>            :       fElsDR[i] = (lrid&gt;=0 &amp;&amp; lrid&lt;kMaxLrITS) ? fgRhoLITS[ lrid ] : 0;   // eloss for normal track
<span class="lineNum">    1290 </span>            :     }
<span class="lineNum">    1291 </span>            :     //
<span class="lineNum">    1292 </span>            :   }
<span class="lineNum">    1293 </span>            :   //
<span class="lineNum">    1294 </span>            :   Double_t mn00 = syy*np-sy*sy;
<span class="lineNum">    1295 </span>            :   Double_t mn01 = sxy*np-sy*sx;
<span class="lineNum">    1296 </span>            :   Double_t mn02 = sxy*sy-syy*sx;
<span class="lineNum">    1297 </span>            :   Double_t det  = sxx*mn00 - sxy*mn01 + sx*mn02; 
<span class="lineNum">    1298 </span>            :   if (TMath::Abs(det)&lt;fgkAlmostZero) return kFALSE;
<span class="lineNum">    1299 </span>            :   //
<span class="lineNum">    1300 </span>            :   Double_t mn11 = sxx*np-sx*sx;
<span class="lineNum">    1301 </span>            :   Double_t mn12 = sxx*sy-sxy*sx;
<span class="lineNum">    1302 </span>            :   Double_t mn22 = sxx*syy-sxy*sxy;
<span class="lineNum">    1303 </span>            :   //
<span class="lineNum">    1304 </span>            :   Double_t mi00 =  mn00/det;
<span class="lineNum">    1305 </span>            :   Double_t mi01 = -mn01/det;
<span class="lineNum">    1306 </span>            :   Double_t mi02 =  mn02/det;
<span class="lineNum">    1307 </span>            :   Double_t mi11 =  mn11/det;
<span class="lineNum">    1308 </span>            :   Double_t mi12 = -mn12/det;
<span class="lineNum">    1309 </span>            :   Double_t mi22 =  mn22/det;
<span class="lineNum">    1310 </span>            :   //
<span class="lineNum">    1311 </span>            :   Double_t xc   = -(rhs0*mi00 + rhs1*mi01 + rhs2*mi02)/2;
<span class="lineNum">    1312 </span>            :   Double_t yc   = -(rhs0*mi01 + rhs1*mi11 + rhs2*mi12)/2;
<span class="lineNum">    1313 </span>            :   Double_t rho2 =  (rhs0*mi02 + rhs1*mi12 + rhs2*mi22);
<span class="lineNum">    1314 </span>            : 
<span class="lineNum">    1315 </span>            :   //
<span class="lineNum">    1316 </span>            :   // check
<span class="lineNum">    1317 </span>            :   double bx = -2*xc;
<span class="lineNum">    1318 </span>            :   double by = -2*yc;
<span class="lineNum">    1319 </span>            :   double sm0=0,sm1=0;
<span class="lineNum">    1320 </span>            :   for (int i=fPntFirst;i&lt;=fPntLast;i++) {
<span class="lineNum">    1321 </span>            :     double dst = bx*x[i]+by*y[i]+x[i]*x[i]+y[i]*y[i]+rho2;
<span class="lineNum">    1322 </span>            :     sm0 += dst;
<span class="lineNum">    1323 </span>            :     sm1 += dst*dst;
<span class="lineNum">    1324 </span>            :     printf(&quot;Point %d: %+e %+e %+e\n&quot;,i,dst,sm0,sm1);
<span class="lineNum">    1325 </span>            :   }
<span class="lineNum">    1326 </span>            : 
<span class="lineNum">    1327 </span>            :   //
<span class="lineNum">    1328 </span>            :   Double_t rad = xc*xc + yc*yc - rho2;
<span class="lineNum">    1329 </span>            :   rad = (rad&gt;fgkAlmostZero) ? (TMath::Sqrt(rad)):fgkAlmostZero;
<span class="lineNum">    1330 </span>            :   //
<span class="lineNum">    1331 </span>            :   //  printf(&quot;Rad: %+e xc: %+e yc: %+e\n&quot;,rad,xc,yc);
<span class="lineNum">    1332 </span>            : 
<span class="lineNum">    1333 </span>            :   // linear circle fit --------------------------------------------------- &lt;&lt;&lt;
<span class="lineNum">    1334 </span>            :   //
<span class="lineNum">    1335 </span>            :   // decide sign(Q*B) and fill cicrle parameters ------------------------- &gt;&gt;&gt;
<span class="lineNum">    1336 </span>            :   int sqb;
<span class="lineNum">    1337 </span>            :   if (extQ) {
<span class="lineNum">    1338 </span>            :     SetCharge(extQ); 
<span class="lineNum">    1339 </span>            :     sqb = fBz&lt;0 ? -GetCharge():GetCharge();
<span class="lineNum">    1340 </span>            :   }
<span class="lineNum">    1341 </span>            :   else { 
<span class="lineNum">    1342 </span>            :     // determine the charge from the collision type and field sign
<span class="lineNum">    1343 </span>            :     // the negative Q*B will have positive Vc x V0 product Z component
<span class="lineNum">    1344 </span>            :     // with Vc={-xc,-yc} : vector from circle center to the origin
<span class="lineNum">    1345 </span>            :     // and V0 - track direction vector (take {0,-1,1} for cosmics)
<span class="lineNum">    1346 </span>            :     // If Bz is not provided, assume positive Bz
<span class="lineNum">    1347 </span>            :     sqb = ( IsTypeCosmics() ? xc:(yc*x[minRId]-xc*y[minRId]) ) &gt; 0 ? -1:1;
<span class="lineNum">    1348 </span>            :     SetCharge( fBz&lt;0 ? -sqb : sqb);
<span class="lineNum">    1349 </span>            :   }
<span class="lineNum">    1350 </span>            :   //
<span class="lineNum">    1351 </span>            :   Double_t phi = TMath::ATan2(yc,xc);
<span class="lineNum">    1352 </span>            :   if (sqb&lt;0) phi += TMath::Pi();
<span class="lineNum">    1353 </span>            :   if      (phi &gt; TMath::Pi()) phi -= 2.*TMath::Pi();
<span class="lineNum">    1354 </span>            :   else if (phi &lt;-TMath::Pi()) phi += 2.*TMath::Pi();
<span class="lineNum">    1355 </span>            :   fParams[kPhi0] = phi;  
<span class="lineNum">    1356 </span>            :   fParams[kR0]   = sqb&lt;0 ? -rad:rad;  
<span class="lineNum">    1357 </span>            :   fParams[kD0] = xc*TMath::Cos(phi) + yc*TMath::Sin(phi) - fParams[kR0];
<span class="lineNum">    1358 </span>            :   //
<span class="lineNum">    1359 </span>            :   // decide sign(Q*B) and fill cicrle parameters ------------------------- &lt;&lt;&lt;
<span class="lineNum">    1360 </span>            :   //
<span class="lineNum">    1361 </span>            :   // find z-offset and dip + the parameter t of closest approach to hits - &gt;&gt;&gt;
<span class="lineNum">    1362 </span>            :   //
<span class="lineNum">    1363 </span>            :   UInt_t hitLrPos=0;  // pattern of hit layers at pos
<span class="lineNum">    1364 </span>            :   UInt_t hitLrNeg=0;  // and negative t's
<span class="lineNum">    1365 </span>            : 
<span class="lineNum">    1366 </span>            :   Double_t ss=0,st=0,sz=0,stt=0,szt=0;
<span class="lineNum">    1367 </span>            :   for (int i=fPntFirst;i&lt;=fPntLast;i++) {
<span class="lineNum">    1368 </span>            :     //
<span class="lineNum">    1369 </span>            :     Double_t ze2 = cov[i*6 + kZZ];
<span class="lineNum">    1370 </span>            :     Double_t t = TMath::ATan2(yc-y[i],xc-x[i]) - fParams[kPhi0]; // angle at measured z
<span class="lineNum">    1371 </span>            :     if (fParams[kR0]&lt;0)  t += TMath::Pi();
<span class="lineNum">    1372 </span>            :     if      (t &gt; TMath::Pi()) t -= TMath::Pi()*2;
<span class="lineNum">    1373 </span>            :     else if (t &lt;-TMath::Pi()) t += TMath::Pi()*2;
<span class="lineNum">    1374 </span>            :     if (ze2&lt;fgkAlmostZero) ze2 = 1E-8;
<span class="lineNum">    1375 </span>            :     ze2 = 1./ze2;
<span class="lineNum">    1376 </span>            :     ss += ze2;
<span class="lineNum">    1377 </span>            :     st += t*ze2;
<span class="lineNum">    1378 </span>            :     stt+= t*t*ze2;
<span class="lineNum">    1379 </span>            :     sz += z[i]*ze2;
<span class="lineNum">    1380 </span>            :     szt+= z[i]*t*ze2;
<span class="lineNum">    1381 </span>            :     //
<span class="lineNum">    1382 </span>            :     fCurT[i] = t; // parameter of the closest approach to the point
<span class="lineNum">    1383 </span>            :     //    printf(&quot;%d %+e %+e %+e %+e\n&quot;,i,x[i],y[i],z[i],t);
<span class="lineNum">    1384 </span>            :     if (eloss) {
<span class="lineNum">    1385 </span>            :       double r = TMath::Sqrt(x[i]*x[i]+y[i]*y[i]);
<span class="lineNum">    1386 </span>            :       int lr;
<span class="lineNum">    1387 </span>            :       for (lr=kMaxLrITS;lr--;) if ( IsZero(r-fgkRLayITS[ lr ],1.) ) break;
<span class="lineNum">    1388 </span>            :       if (lr&lt;kMaxLrITS) {
<span class="lineNum">    1389 </span>            :         if (t&gt;0) hitLrPos |= (1&lt;&lt;lr);  // set bit of the layer
<span class="lineNum">    1390 </span>            :         else     hitLrNeg |= (1&lt;&lt;lr);  // set bit of the layer
<span class="lineNum">    1391 </span>            :       }
<span class="lineNum">    1392 </span>            :     }
<span class="lineNum">    1393 </span>            :   }
<span class="lineNum">    1394 </span>            :   det = ss*stt - st*st;
<span class="lineNum">    1395 </span>            :   if (TMath::Abs(det)&lt;fgkAlmostZero) { // no Z dependence
<span class="lineNum">    1396 </span>            :     fParams[kDZ]  = sz/ss;
<span class="lineNum">    1397 </span>            :     fParams[kDip] = 0;
<span class="lineNum">    1398 </span>            :   }
<span class="lineNum">    1399 </span>            :   else {
<span class="lineNum">    1400 </span>            :     fParams[kDZ]  =  (sz*stt-st*szt)/det;
<span class="lineNum">    1401 </span>            :     fParams[kDip] = -(ss*szt-st*sz)/det/fParams[kR0];
<span class="lineNum">    1402 </span>            :   }
<span class="lineNum">    1403 </span>            :   //
<span class="lineNum">    1404 </span>            :   // find z-offset and dip + the parameter t of closest approach to hits - &lt;&lt;&lt;
<span class="lineNum">    1405 </span>            :   //
<span class="lineNum">    1406 </span>            :   // fill info needed to account for ELoss ------------------------------- &gt;&gt;&gt;
<span class="lineNum">    1407 </span>            :   if (eloss) {
<span class="lineNum">    1408 </span>            :     fNElsPnt = fPntLast - fPntFirst + 1;
<span class="lineNum">    1409 </span>            :     //
<span class="lineNum">    1410 </span>            :     // to account for the energy loss in the passive volumes, calculate the relevant t-parameters 
<span class="lineNum">    1411 </span>            :     double* tcur = fCurT + fPntFirst;
<span class="lineNum">    1412 </span>            :     double* ecur = fElsDR+ fPntFirst;
<span class="lineNum">    1413 </span>            :     //
<span class="lineNum">    1414 </span>            :     for (int ilp=3;ilp--;) {
<span class="lineNum">    1415 </span>            :       int id = fgkPassivLrITS[ilp];
<span class="lineNum">    1416 </span>            :       double tp = GetHelixParAtR( fgkRLayITS[ id ] );
<span class="lineNum">    1417 </span>            :       if (tp&lt;0) continue; // does not hit this radius
<span class="lineNum">    1418 </span>            :       //
<span class="lineNum">    1419 </span>            :       tcur[fNElsPnt] = GetSignQB()&gt;0 ? -tp : tp;
<span class="lineNum">    1420 </span>            :       ecur[fNElsPnt] = fgRhoLITS[ id ];
<span class="lineNum">    1421 </span>            :       fNElsPnt++;
<span class="lineNum">    1422 </span>            :       //      printf(&quot;Passive  on lr %d  %+e\n&quot;,ilp,tcur[fNElsPnt-1]);
<span class="lineNum">    1423 </span>            :       //
<span class="lineNum">    1424 </span>            :       if (IsTypeCosmics() &amp;&amp; !IsZero(tp)) { // 2 crossings for cosmics
<span class="lineNum">    1425 </span>            :         tcur[fNElsPnt] = -tcur[fNElsPnt-1];
<span class="lineNum">    1426 </span>            :         ecur[fNElsPnt] =  ecur[fNElsPnt-1];
<span class="lineNum">    1427 </span>            :         fNElsPnt++;
<span class="lineNum">    1428 </span>            :         //printf(&quot;Passive* on lr %d  %+e\n&quot;,ilp,-tcur[fNElsPnt-1]);
<span class="lineNum">    1429 </span>            :       }
<span class="lineNum">    1430 </span>            :       //
<span class="lineNum">    1431 </span>            :     }
<span class="lineNum">    1432 </span>            :     // check if some active layers did not miss the hit, treat them as passive
<span class="lineNum">    1433 </span>            :     for (int ilp=6;ilp--;) {
<span class="lineNum">    1434 </span>            :       int id = fgkActiveLrITS[ilp];
<span class="lineNum">    1435 </span>            :       double tp = GetHelixParAtR( fgkRLayITS[ id ] );
<span class="lineNum">    1436 </span>            :       if (tp&lt;0) continue; // does not hit this radius
<span class="lineNum">    1437 </span>            :       //
<span class="lineNum">    1438 </span>            :       if ( (GetSignQB()&gt;0||IsTypeCosmics()) &amp;&amp; !(hitLrNeg &amp; (1&lt;&lt;id)) ) {
<span class="lineNum">    1439 </span>            :         tcur[fNElsPnt] = -tp;
<span class="lineNum">    1440 </span>            :         ecur[fNElsPnt] = fgRhoLITS[ id ];
<span class="lineNum">    1441 </span>            :         fNElsPnt++;
<span class="lineNum">    1442 </span>            :         //printf(&quot;Missed  on lr %d  %+e\n&quot;,ilp,-tp);
<span class="lineNum">    1443 </span>            :       }
<span class="lineNum">    1444 </span>            :       //
<span class="lineNum">    1445 </span>            :       if ( (GetSignQB()&lt;0||IsTypeCosmics()) &amp;&amp; !(hitLrPos &amp; (1&lt;&lt;id)) ) {
<span class="lineNum">    1446 </span>            :         tcur[fNElsPnt] = tp;
<span class="lineNum">    1447 </span>            :         ecur[fNElsPnt] = fgRhoLITS[ id ];
<span class="lineNum">    1448 </span>            :         fNElsPnt++;
<span class="lineNum">    1449 </span>            :         //printf(&quot;Missed* on lr %d  %e\n&quot;,ilp,tp);
<span class="lineNum">    1450 </span>            :       }
<span class="lineNum">    1451 </span>            :     }
<span class="lineNum">    1452 </span>            :     //
<span class="lineNum">    1453 </span>            :     TMath::Sort(fNElsPnt,fCurT+fPntFirst,fElsId,kFALSE);    // index e-loss points in increasing order
<span class="lineNum">    1454 </span>            :     // find the position of smallest positive t-param
<span class="lineNum">    1455 </span>            :     for (fFirstPosT=0;fFirstPosT&lt;fNElsPnt;fFirstPosT++) if (fCurT[ fElsId[ fFirstPosT ] ]&gt;0) break;
<span class="lineNum">    1456 </span>            :     //
<span class="lineNum">    1457 </span>            :     Double_t cdip = 1./TMath::Sqrt(1.+fParams[kDip]*fParams[kDip]);
<span class="lineNum">    1458 </span>            :     Double_t ptot = TMath::Abs(fParams[kR0]*fgkCQConv*fBz/cdip); // momentum and energy
<span class="lineNum">    1459 </span>            :     Double_t etot = TMath::Sqrt(ptot*ptot + fMass*fMass);      // in the point of closest approach to beam
<span class="lineNum">    1460 </span>            :     Double_t normS[3];
<span class="lineNum">    1461 </span>            :     //
<span class="lineNum">    1462 </span>            :     // Positive t-params: along the track direction for negative track, against for positive
<span class="lineNum">    1463 </span>            :     Double_t pcur = ptot, ecurr = etot;
<span class="lineNum">    1464 </span>            :     for (int ip=fFirstPosT;ip&lt;fNElsPnt;ip++) {
<span class="lineNum">    1465 </span>            :       int tID = fElsId[ip];
<span class="lineNum">    1466 </span>            :       Double_t t = fCurT[ tID ];
<span class="lineNum">    1467 </span>            :       //
<span class="lineNum">    1468 </span>            :       if (tID&gt;fPntLast) { // this is not a hit layer but passive layer
<span class="lineNum">    1469 </span>            :         double php = TMath::ATan2(yc-fParams[kR0]*TMath::Cos(fParams[kPhi0]+t),
<span class="lineNum">    1470 </span>            :                                   xc-fParams[kR0]*TMath::Cos(fParams[kPhi0]+t));
<span class="lineNum">    1471 </span>            :         normS[0] = -TMath::Cos(php);  // normal to the cylinder at intersection point
<span class="lineNum">    1472 </span>            :         normS[1] = -TMath::Sin(php);
<span class="lineNum">    1473 </span>            :         normS[2] = 0;
<span class="lineNum">    1474 </span>            :       }
<span class="lineNum">    1475 </span>            :       else GetNormal(normS,fkPoints-&gt;GetCov()+tID*6);   // vector normal to hit module
<span class="lineNum">    1476 </span>            :       fElsDR[tID] = GetDRofELoss(t,cdip,fElsDR[tID],normS,ptot,etot);
<span class="lineNum">    1477 </span>            :     }
<span class="lineNum">    1478 </span>            :     //
<span class="lineNum">    1479 </span>            :     // negaive t-params: against the track direction for negative track, along for positive
<span class="lineNum">    1480 </span>            :     pcur  = ptot;
<span class="lineNum">    1481 </span>            :     ecurr = etot;
<span class="lineNum">    1482 </span>            :     for (int ip=fFirstPosT;ip--;) {
<span class="lineNum">    1483 </span>            :       int tID = fElsId[ip];
<span class="lineNum">    1484 </span>            :       Double_t t = fCurT[ tID ];
<span class="lineNum">    1485 </span>            :       //
<span class="lineNum">    1486 </span>            :       if (tID&gt;fPntLast) { // this is not a hit layer but passive layer
<span class="lineNum">    1487 </span>            :         double php = TMath::ATan2(yc-fParams[kR0]*TMath::Cos(fParams[kPhi0]+t),
<span class="lineNum">    1488 </span>            :                                   xc-fParams[kR0]*TMath::Cos(fParams[kPhi0]+t));
<span class="lineNum">    1489 </span>            :         normS[0] = -TMath::Cos(php);  // normal to the cylinder at intersection point
<span class="lineNum">    1490 </span>            :         normS[1] = -TMath::Sin(php);
<span class="lineNum">    1491 </span>            :         normS[2] = 0;   
<span class="lineNum">    1492 </span>            :       }
<span class="lineNum">    1493 </span>            :       else GetNormal(normS,fkPoints-&gt;GetCov()+tID*6);   // vector normal to hit module
<span class="lineNum">    1494 </span>            :       //
<span class="lineNum">    1495 </span>            :       fElsDR[tID] = GetDRofELoss(t,cdip,fElsDR[tID],normS,ptot,etot);
<span class="lineNum">    1496 </span>            :     }
<span class="lineNum">    1497 </span>            :   }
<span class="lineNum">    1498 </span>            :   // fill info needed to account for ELoss ------------------------------- &lt;&lt;&lt;
<span class="lineNum">    1499 </span>            :   //
<span class="lineNum">    1500 </span>            :   return kTRUE;
<span class="lineNum">    1501 </span>            : }
<a name="1502"><span class="lineNum">    1502 </span>            : */</a>
<span class="lineNum">    1503 </span>            : //____________________________________________________
<span class="lineNum">    1504 </span>            : Double_t AliITSTPArrayFit::FitHelix(Int_t extQ, Double_t extPT,Double_t extPTerr)
<span class="lineNum">    1505 </span>            : {
<span class="lineNum">    1506 </span>            :   // fit by helix accounting for the errors of all coordinates (and energy loss if requested)
<span class="lineNum">    1507 </span>            :   // 
<span class="lineNum">    1508 </span>            :   // If extQ is non-0, its sign is imposed as a charge of the track
<span class="lineNum">    1509 </span>            :   // If extPT&gt;0 and extPTerr&gt;=0, constrain to measured tr.momentum PT 
<span class="lineNum">    1510 </span>            :   // with corresponding error (err=0 -&gt; rel.err=1e-6)
<span class="lineNum">    1511 </span>            :   //
<span class="lineNum">    1512 </span>            :   double chiprev=1e99;
<span class="lineNum">    1513 </span>            :   //const Double_t kMaxTEffect = 1E-6;
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 :   Double_t dXYZdGlo[3*5],dXYZdLoc[3],xyzRes[3];</span>
<span class="lineNum">    1515 </span>            :   //
<span class="lineNum">    1516 </span><span class="lineNoCov">          0 :   SetFitDone(kFALSE);</span>
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 :   fChi2NDF = -1;</span>
<span class="lineNum">    1518 </span>            :   //
<span class="lineNum">    1519 </span><span class="lineNoCov">          0 :   if (!FitHelixCrude(extQ)) return -1; // get initial estimate, ignoring the errors</span>
<span class="lineNum">    1520 </span>            :   //
<span class="lineNum">    1521 </span><span class="lineNoCov">          0 :   if (TMath::Abs(fParams[kR0])&gt;fMaxRforHelix &amp;&amp; extPT&lt;=0) {</span>
<span class="lineNum">    1522 </span><span class="lineNoCov">          0 :     fSwitch2Line = kTRUE;</span>
<span class="lineNum">    1523 </span><span class="lineNoCov">          0 :     return FitLine();</span>
<span class="lineNum">    1524 </span>            :   }
<span class="lineNum">    1525 </span>            :   //
<span class="lineNum">    1526 </span>            :   //
<span class="lineNum">    1527 </span><span class="lineNoCov">          0 :   if (!IsCovInv()) InvertPointsCovMat();    // prepare inverted errors</span>
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 :   if (!fParSol) fParSol = new AliParamSolver(5);</span>
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 :   fParSol-&gt;SetNGlobal(5);</span>
<span class="lineNum">    1530 </span>            :   //
<span class="lineNum">    1531 </span>            :   //  printf(&quot;-1 | %+.2e %+.2e %+.2e %+.2e %+.2e | chi2: %+.4e\n&quot;,fParams[0],fParams[1],fParams[2],fParams[3],fParams[4],CalcChi2NDF());
<span class="lineNum">    1532 </span>            :   int iter = 0;
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 :   fChi2NDF = 1e99;</span>
<span class="lineNum">    1534 </span>            :   Bool_t converged = kFALSE;
<span class="lineNum">    1535 </span><span class="lineNoCov">          0 :   while(iter&lt;fMaxIter) {</span>
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 :     chiprev = fChi2NDF;</span>
<span class="lineNum">    1537 </span><span class="lineNoCov">          0 :     fParSol-&gt;Clear();</span>
<span class="lineNum">    1538 </span><span class="lineNoCov">          0 :     for (int ip=fPntFirst;ip&lt;=fPntLast;ip++) {</span>
<span class="lineNum">    1539 </span>            :       //
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :       GetResiduals(xyzRes, ip); // current residuals at point ip</span>
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 :       Double_t rrho = fParams[kR0]+fParams[kD0];</span>
<span class="lineNum">    1542 </span><span class="lineNoCov">          0 :       Double_t cs0  = TMath::Cos(fParams[kPhi0]);</span>
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :       Double_t sn0  = TMath::Sin(fParams[kPhi0]);</span>
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :       Double_t cst  = TMath::Cos(fCurT[ip]+fParams[kPhi0]);</span>
<span class="lineNum">    1545 </span><span class="lineNoCov">          0 :       Double_t snt  = TMath::Sin(fCurT[ip]+fParams[kPhi0]);</span>
<span class="lineNum">    1546 </span>            :       //
<span class="lineNum">    1547 </span>            :       int offs = kD0;                  // dXYZ/dD0
<span class="lineNum">    1548 </span><span class="lineNoCov">          0 :       dXYZdGlo[offs + kX] = cs0;</span>
<span class="lineNum">    1549 </span><span class="lineNoCov">          0 :       dXYZdGlo[offs + kY] = sn0;</span>
<span class="lineNum">    1550 </span><span class="lineNoCov">          0 :       dXYZdGlo[offs + kZ] = 0;</span>
<span class="lineNum">    1551 </span>            :       //
<span class="lineNum">    1552 </span>            :       offs = kPhi0*3;                  // dXYZ/dPhi0
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :       dXYZdGlo[offs + kX] = -rrho*sn0 + fParams[kR0]*snt;</span>
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :       dXYZdGlo[offs + kY] =  rrho*cs0 - fParams[kR0]*cst;</span>
<span class="lineNum">    1555 </span><span class="lineNoCov">          0 :       dXYZdGlo[offs + kZ] = 0;</span>
<span class="lineNum">    1556 </span>            :       //
<span class="lineNum">    1557 </span>            :       offs = kR0*3;                   // dXYZ/dR0
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 :       if (TMath::Abs(fParams[kR0])&lt;0.9*fMaxRforHelix) {</span>
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :         dXYZdGlo[offs + kX] =  cs0 - cst;</span>
<span class="lineNum">    1560 </span><span class="lineNoCov">          0 :         dXYZdGlo[offs + kY] =  sn0 - snt;</span>
<span class="lineNum">    1561 </span><span class="lineNoCov">          0 :         dXYZdGlo[offs + kZ] =  -fParams[kDip]*fCurT[ip];</span>
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1563 </span>            :       else {
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :         dXYZdGlo[offs + kX] = dXYZdGlo[offs + kY] = dXYZdGlo[offs + kZ] = 0;</span>
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :         fParSol-&gt;AddConstraint(kR0,0,1.e2);</span>
<span class="lineNum">    1566 </span>            :       }
<span class="lineNum">    1567 </span>            :       //
<span class="lineNum">    1568 </span>            :       offs = kDZ*3;                   // dXYZ/dDZ
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :       dXYZdGlo[offs + kX] =  0;</span>
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :       dXYZdGlo[offs + kY] =  0;</span>
<span class="lineNum">    1571 </span><span class="lineNoCov">          0 :       dXYZdGlo[offs + kZ] =  1.;</span>
<span class="lineNum">    1572 </span>            :       //
<span class="lineNum">    1573 </span>            :       offs = kDip*3;                  // dXYZ/dDip
<span class="lineNum">    1574 </span><span class="lineNoCov">          0 :       dXYZdGlo[offs + kX] =  0;</span>
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :       dXYZdGlo[offs + kY] =  0;</span>
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 :       dXYZdGlo[offs + kZ] = -fParams[kR0]*fCurT[ip];</span>
<span class="lineNum">    1577 </span>            :       //
<span class="lineNum">    1578 </span>            :       //      /*
<span class="lineNum">    1579 </span><span class="lineNoCov">          0 :       dXYZdLoc[kX] =  fParams[kR0]*snt;</span>
<span class="lineNum">    1580 </span><span class="lineNoCov">          0 :       dXYZdLoc[kY] = -fParams[kR0]*cst;</span>
<span class="lineNum">    1581 </span><span class="lineNoCov">          0 :       dXYZdLoc[kZ] = -fParams[kR0]*fParams[kDip];</span>
<span class="lineNum">    1582 </span>            :       //      */
<span class="lineNum">    1583 </span>            :       //      dXYZdLoc[0] = dXYZdLoc[1] = dXYZdLoc[2] = 0;
<span class="lineNum">    1584 </span>            :       //
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :       fParSol-&gt;AddEquation(dXYZdGlo,dXYZdLoc,xyzRes,GetCovI(ip),GetCovIScale(ip));</span>
<span class="lineNum">    1586 </span>            :     }
<span class="lineNum">    1587 </span>            :     //
<span class="lineNum">    1588 </span><span class="lineNoCov">          0 :     if (extPT&gt;0) { // add constraint on pt</span>
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :       if (extPTerr&lt;fgkAlmostZero) extPTerr = 1e-6*extPT;</span>
<span class="lineNum">    1590 </span><span class="lineNoCov">          0 :       Double_t cf = fBz*GetCharge()*fgkCQConv;</span>
<span class="lineNum">    1591 </span><span class="lineNoCov">          0 :       Double_t err2i = extPTerr/cf;</span>
<span class="lineNum">    1592 </span><span class="lineNoCov">          0 :       err2i = 1./err2i/err2i;</span>
<span class="lineNum">    1593 </span>            :       //      printf(&quot;Constrain R to %+e\n&quot;,extPT/cf);
<span class="lineNum">    1594 </span><span class="lineNoCov">          0 :       fParSol-&gt;AddConstraint(kR0,-extPT/cf+fParams[kR0],err2i);</span>
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1596 </span><span class="lineNoCov">          0 :     if (!fParSol-&gt;Solve()) { AliError(&quot;Failed to fit helix&quot;); return -1; }</span>
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :     Double_t *deltaG = fParSol-&gt;GetGlobals();</span>
<span class="lineNum">    1598 </span>            :     //    Double_t *deltaT = fParSol-&gt;GetLocals();
<span class="lineNum">    1599 </span><span class="lineNoCov">          0 :     for (int ipar=5;ipar--;) fParams[ipar] -= deltaG[ipar];</span>
<span class="lineNum">    1600 </span>            :     //
<span class="lineNum">    1601 </span><span class="lineNoCov">          0 :     if (TMath::Abs(fParams[kR0])&gt;0.9*fMaxRforHelix) fParams[kR0] = TMath::Sign(0.9*fMaxRforHelix,fParams[kR0]);</span>
<span class="lineNum">    1602 </span>            :     //
<span class="lineNum">    1603 </span><span class="lineNoCov">          0 :     for (int ip=fPntFirst;ip&lt;=fPntLast;ip++) {</span>
<span class="lineNum">    1604 </span><span class="lineNoCov">          0 :       fCurT[ip] = CalcParPCA(ip);</span>
<span class="lineNum">    1605 </span>            :       //      printf(&quot;iter%d : delta%2d : expl: %+e | %+e | R=%+e p0=%+e\n&quot;,iter,ip,deltaT[ip-fPntFirst], fCurT[ip],fParams[kR0],fParams[kPhi0]);
<span class="lineNum">    1606 </span>            :       //      fCurT[ip] -= deltaT[ip-fPntFirst];
<span class="lineNum">    1607 </span>            :     }
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 :     iter++;</span>
<span class="lineNum">    1609 </span>            :     //
<span class="lineNum">    1610 </span><span class="lineNoCov">          0 :     fChi2NDF = CalcChi2NDF();</span>
<span class="lineNum">    1611 </span>            :     //        printf(&quot;%2d | %+.2e %+.2e %+.2e %+.2e %+.2e | chi2: %+.4e %+.4e\n&quot;,iter,deltaG[0],deltaG[1],deltaG[2],deltaG[3],deltaG[4],fChi2NDF,fChi2NDF-chiprev);
<span class="lineNum">    1612 </span>            :     //        printf(&quot;-&gt;&gt;  %+.2e %+.2e %+.2e %+.2e %+.2e | Chi2: %+.6e %+.6e\n&quot;,fParams[0],fParams[1],fParams[2],fParams[3],fParams[4],fChi2NDF,fChi2NDF-chiprev);
<span class="lineNum">    1613 </span><span class="lineNoCov">          0 :     double difchi2 = chiprev - fChi2NDF;</span>
<span class="lineNum">    1614 </span><span class="lineNoCov">          0 :     if ( difchi2&lt;fEps &amp;&amp; TMath::Abs(difchi2)&lt;1e-4) {converged = kTRUE; break;} </span>
<span class="lineNum">    1615 </span>            :     //    if (errT*TMath::Abs(fParams[kR0])&lt;kMaxTEffect &amp;&amp; errP&lt;fEps) {converged = kTRUE; break;} 
<span class="lineNum">    1616 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1617 </span>            :   //
<span class="lineNum">    1618 </span><span class="lineNoCov">          0 :   if (!converged) {</span>
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :     AliDebug(2,Form(&quot;Max number of %d iteration reached, Current chi2:%.3e, chi2 change %+.3e&quot;,iter,</span>
<span class="lineNum">    1620 </span>            :                     fChi2NDF,chiprev-fChi2NDF));
<span class="lineNum">    1621 </span><span class="lineNoCov">          0 :     for (int ip=fPntFirst;ip&lt;=fPntLast;ip++)</span>
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 :       AliDebug(2,Form(&quot;P%2d| %+.3e %+.3e %+.3e\n&quot;,ip,fkPoints-&gt;GetX()[ip],fkPoints-&gt;GetY()[ip],fkPoints-&gt;GetZ()[ip]));</span>
<span class="lineNum">    1623 </span>            : 
<span class="lineNum">    1624 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1625 </span><span class="lineNoCov">          0 :   fIter = iter;</span>
<span class="lineNum">    1626 </span><span class="lineNoCov">          0 :   SetCharge( fParams[kR0]&gt;0 ? (fBz&lt;0?-1:1):(fBz&gt;0?-1:1) );</span>
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 :   SetFitDone();</span>
<span class="lineNum">    1628 </span>            :   //  printf(&quot;F1&gt;&gt; %+.7e %+.7e %+.7e %+.7e %.7e\n&quot;,fParams[0],fParams[1],fParams[2],fParams[3],fParams[4]);
<span class="lineNum">    1629 </span>            :   //
<span class="lineNum">    1630 </span><span class="lineNoCov">          0 :   return fChi2NDF;</span>
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 : }</span>
<a name="1632"><span class="lineNum">    1632 </span>            : </a>
<span class="lineNum">    1633 </span>            : //____________________________________________________
<span class="lineNum">    1634 </span>            : Double_t AliITSTPArrayFit::FitLine()
<span class="lineNum">    1635 </span>            : {
<span class="lineNum">    1636 </span>            :   // fit by helix accounting for the errors of all coordinates (and energy loss if requested)
<span class="lineNum">    1637 </span>            :   // 
<span class="lineNum">    1638 </span>            :   double chiprev=1e99;
<span class="lineNum">    1639 </span>            :   //  const Double_t kMaxTEffect = 1.e-6;
<span class="lineNum">    1640 </span><span class="lineNoCov">          0 :   Double_t dXYZdGlo[3*4],dXYZdLoc[3],xyzRes[3];</span>
<span class="lineNum">    1641 </span><span class="lineNoCov">          0 :   SetFitDone(kFALSE);</span>
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 :   fChi2NDF = -1;</span>
<span class="lineNum">    1643 </span>            :   //
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :   if (fParAxis&lt;0) SetParAxis(ChoseParAxis());</span>
<span class="lineNum">    1645 </span>            :   //
<span class="lineNum">    1646 </span><span class="lineNoCov">          0 :   const float *xyzp[3]={fkPoints-&gt;GetX(),fkPoints-&gt;GetY(),fkPoints-&gt;GetZ()};</span>
<span class="lineNum">    1647 </span><span class="lineNoCov">          0 :   if (!IsCovInv()) InvertPointsCovMat();</span>
<span class="lineNum">    1648 </span><span class="lineNoCov">          0 :   if (!FitLineCrude()) return -1; // get initial estimate, ignoring the errors</span>
<span class="lineNum">    1649 </span>            :   //
<span class="lineNum">    1650 </span><span class="lineNoCov">          0 :   if (!fParSol) fParSol = new AliParamSolver(5);</span>
<span class="lineNum">    1651 </span><span class="lineNoCov">          0 :   fParSol-&gt;SetNGlobal(4);</span>
<span class="lineNum">    1652 </span>            :   // initial set of parameters
<span class="lineNum">    1653 </span><span class="lineNoCov">          0 :   for (int ip=fPntFirst;ip&lt;=fPntLast;ip++) fCurT[ip] = xyzp[fParAxis][ip]; // use measured param-coordinate</span>
<span class="lineNum">    1654 </span>            :   //
<span class="lineNum">    1655 </span>            :   int iter = 0;
<span class="lineNum">    1656 </span>            :   Bool_t converged = kFALSE;
<span class="lineNum">    1657 </span><span class="lineNoCov">          0 :   fChi2NDF = 1e99;</span>
<span class="lineNum">    1658 </span><span class="lineNoCov">          0 :   while(iter&lt;fMaxIter) {</span>
<span class="lineNum">    1659 </span><span class="lineNoCov">          0 :     chiprev = fChi2NDF;</span>
<span class="lineNum">    1660 </span><span class="lineNoCov">          0 :     fParSol-&gt;Clear();</span>
<span class="lineNum">    1661 </span><span class="lineNoCov">          0 :     for (int ip=fPntFirst;ip&lt;=fPntLast;ip++) {</span>
<span class="lineNum">    1662 </span>            :       //
<span class="lineNum">    1663 </span>            :       int offs;
<span class="lineNum">    1664 </span><span class="lineNoCov">          0 :       GetResiduals(xyzRes, ip); // current residuals at point ip</span>
<span class="lineNum">    1665 </span>            :       //
<span class="lineNum">    1666 </span>            :       offs = kA0*3;                   // dXYZ/dA0
<span class="lineNum">    1667 </span><span class="lineNoCov">          0 :       dXYZdGlo[offs + fkAxID[kX]] = 1;</span>
<span class="lineNum">    1668 </span><span class="lineNoCov">          0 :       dXYZdGlo[offs + fkAxID[kY]] = 0;</span>
<span class="lineNum">    1669 </span><span class="lineNoCov">          0 :       dXYZdGlo[offs + fParAxis  ] = 0;</span>
<span class="lineNum">    1670 </span>            :       //
<span class="lineNum">    1671 </span>            :       offs = kB0*3;                   // dXYZ/dB0
<span class="lineNum">    1672 </span><span class="lineNoCov">          0 :       dXYZdGlo[offs + fkAxID[kX]] = fCurT[ip];</span>
<span class="lineNum">    1673 </span><span class="lineNoCov">          0 :       dXYZdGlo[offs + fkAxID[kY]] = 0;</span>
<span class="lineNum">    1674 </span><span class="lineNoCov">          0 :       dXYZdGlo[offs + fParAxis  ] = 0;</span>
<span class="lineNum">    1675 </span>            :       //
<span class="lineNum">    1676 </span>            :       offs = kA1*3;                   // dXYZ/dA1
<span class="lineNum">    1677 </span><span class="lineNoCov">          0 :       dXYZdGlo[offs + fkAxID[kX]] = 0;</span>
<span class="lineNum">    1678 </span><span class="lineNoCov">          0 :       dXYZdGlo[offs + fkAxID[kY]] = 1;</span>
<span class="lineNum">    1679 </span><span class="lineNoCov">          0 :       dXYZdGlo[offs + fParAxis  ] = 0;</span>
<span class="lineNum">    1680 </span>            :       //
<span class="lineNum">    1681 </span>            :       offs = kB1*3;                   // dXYZ/dB1
<span class="lineNum">    1682 </span><span class="lineNoCov">          0 :       dXYZdGlo[offs + fkAxID[kX]] = 0;</span>
<span class="lineNum">    1683 </span><span class="lineNoCov">          0 :       dXYZdGlo[offs + fkAxID[kY]] = fCurT[ip];</span>
<span class="lineNum">    1684 </span><span class="lineNoCov">          0 :       dXYZdGlo[offs + fParAxis  ] = 0;</span>
<span class="lineNum">    1685 </span>            :       //
<span class="lineNum">    1686 </span><span class="lineNoCov">          0 :       dXYZdLoc[ fkAxID[kX] ] =  fParams[kB0];  // dX/dt</span>
<span class="lineNum">    1687 </span><span class="lineNoCov">          0 :       dXYZdLoc[ fkAxID[kY] ] =  fParams[kB1];  // dY/dt</span>
<span class="lineNum">    1688 </span><span class="lineNoCov">          0 :       dXYZdLoc[ fParAxis   ] =  1;</span>
<span class="lineNum">    1689 </span>            :       //
<span class="lineNum">    1690 </span><span class="lineNoCov">          0 :       fParSol-&gt;AddEquation(dXYZdGlo,dXYZdLoc,xyzRes,GetCovI(ip),GetCovIScale(ip));</span>
<span class="lineNum">    1691 </span>            :     }
<span class="lineNum">    1692 </span>            :     //
<span class="lineNum">    1693 </span><span class="lineNoCov">          0 :     if (!fParSol-&gt;Solve()) { AliError(&quot;Failed to fit line&quot;); return -1; }</span>
<span class="lineNum">    1694 </span><span class="lineNoCov">          0 :     Double_t *deltaG = fParSol-&gt;GetGlobals();</span>
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :     Double_t *deltaT = fParSol-&gt;GetLocals();</span>
<span class="lineNum">    1696 </span><span class="lineNoCov">          0 :     for (int ipar=4;ipar--;) fParams[ipar] -= deltaG[ipar];</span>
<span class="lineNum">    1697 </span><span class="lineNoCov">          0 :     for (int ip=fPntFirst;ip&lt;=fPntLast;ip++) fCurT[ip] -= deltaT[ip-fPntFirst];</span>
<span class="lineNum">    1698 </span><span class="lineNoCov">          0 :     iter++;</span>
<span class="lineNum">    1699 </span><span class="lineNoCov">          0 :     fChi2NDF = CalcChi2NDF();</span>
<span class="lineNum">    1700 </span>            :     //    printf(&quot;%d %+e %+e | %+.2e %+.2e %+.2e %+.2e | chi2: %+.4e %+.4e\n&quot;,iter,errP,errT, deltaG[0],deltaG[1],deltaG[2],deltaG[3],fChi2NDF,fChi2NDF-chiprev);
<span class="lineNum">    1701 </span>            :     //    printf(&quot;-&gt;&gt; %+.2e %+.2e %+.2e %+.2e %+.2e | Chi2: %+.6e %+.6e\n&quot;,fParams[0],fParams[1],fParams[2],fParams[3],fParams[4],fChi2NDF,fChi2NDF-chiprev);
<span class="lineNum">    1702 </span><span class="lineNoCov">          0 :     double difchi2 = chiprev - fChi2NDF;</span>
<span class="lineNum">    1703 </span><span class="lineNoCov">          0 :     if ( difchi2&lt;fEps &amp;&amp; TMath::Abs(difchi2)&lt;1e-4) {converged = kTRUE; break;} </span>
<span class="lineNum">    1704 </span><span class="lineNoCov">          0 :     chiprev = fChi2NDF;</span>
<span class="lineNum">    1705 </span>            :     //    if (errT&lt;kMaxTEffect &amp;&amp; errP&lt;fEps) {converged = kTRUE; break;} 
<span class="lineNum">    1706 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1707 </span>            :   //
<span class="lineNum">    1708 </span><span class="lineNoCov">          0 :   if (!converged) {</span>
<span class="lineNum">    1709 </span><span class="lineNoCov">          0 :     AliDebug(2,Form(&quot;Max number of %d iteration reached, Current chi2:%.3e, chi2 change %+.3e&quot;,iter,</span>
<span class="lineNum">    1710 </span>            :                     fChi2NDF,chiprev-fChi2NDF));
<span class="lineNum">    1711 </span><span class="lineNoCov">          0 :     for (int ip=fPntFirst;ip&lt;=fPntLast;ip++)</span>
<span class="lineNum">    1712 </span><span class="lineNoCov">          0 :       AliDebug(2,Form(&quot;P%2d| %+.3e %+.3e %+.3e\n&quot;,ip,fkPoints-&gt;GetX()[ip],fkPoints-&gt;GetY()[ip],fkPoints-&gt;GetZ()[ip]));</span>
<span class="lineNum">    1713 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1714 </span><span class="lineNoCov">          0 :   fIter = iter;</span>
<span class="lineNum">    1715 </span><span class="lineNoCov">          0 :   SetFitDone();</span>
<span class="lineNum">    1716 </span>            :   //printf(&quot;F1&gt;&gt; %+.2e %+.2e %+.2e %+.2e\n&quot;,fParams[0],fParams[1],fParams[2],fParams[3]);
<span class="lineNum">    1717 </span><span class="lineNoCov">          0 :   return fChi2NDF;</span>
<span class="lineNum">    1718 </span>            :   //
<span class="lineNum">    1719 </span><span class="lineNoCov">          0 : }</span>
<a name="1720"><span class="lineNum">    1720 </span>            : </a>
<span class="lineNum">    1721 </span>            : //____________________________________________________
<span class="lineNum">    1722 </span>            : void AliITSTPArrayFit::GetNormal(Double_t *norm, const Float_t *covMat) 
<span class="lineNum">    1723 </span>            : {
<span class="lineNum">    1724 </span>            :   // obtain the lab normal vector to the sensor from the covariance matrix
<span class="lineNum">    1725 </span>            :   // in such a way that when the local frame of the sensor coincides with 
<span class="lineNum">    1726 </span>            :   // the lab frame, the vector {0,1,0} is obtained
<span class="lineNum">    1727 </span><span class="lineNoCov">          0 :   Double_t tgxy = TMath::Tan(0.5*TMath::ATan2(2.*covMat[kXY],covMat[kYY]-covMat[kXX]));</span>
<span class="lineNum">    1728 </span><span class="lineNoCov">          0 :   Double_t tgyz = TMath::Tan(0.5*TMath::ATan2(2.*covMat[kYZ],covMat[kZZ]-covMat[kYY]));</span>
<span class="lineNum">    1729 </span><span class="lineNoCov">          0 :   norm[kY] = 1./TMath::Sqrt(1 + tgxy*tgxy + tgyz*tgyz);</span>
<span class="lineNum">    1730 </span><span class="lineNoCov">          0 :   norm[kX] = norm[kY]*tgxy;</span>
<span class="lineNum">    1731 </span><span class="lineNoCov">          0 :   norm[kZ] = norm[kY]*tgyz;</span>
<span class="lineNum">    1732 </span>            :   //
<span class="lineNum">    1733 </span><span class="lineNoCov">          0 : }</span>
<a name="1734"><span class="lineNum">    1734 </span>            : </a>
<span class="lineNum">    1735 </span>            : //____________________________________________________
<span class="lineNum">    1736 </span>            : Double_t AliITSTPArrayFit::GetDRofELoss(Double_t t,Double_t cdip,Double_t rhoL,const Double_t *normS, 
<span class="lineNum">    1737 </span>            :                                         Double_t &amp;p,Double_t &amp;e) const
<span class="lineNum">    1738 </span>            : {
<span class="lineNum">    1739 </span>            :   // Calculate energy loss of the particle at given t-param on the layer with rhoL (thickness*density) with
<span class="lineNum">    1740 </span>            :   // normal vector normS in the lab. The particle before eloss has energy &quot;e&quot; and momentum &quot;p&quot;
<span class="lineNum">    1741 </span>            :   // cdip = cosine of the dip angle = 1/sqrt(1+tgL^2)
<span class="lineNum">    1742 </span>            :   // Return the change DR of the radius due to the ELoss 
<span class="lineNum">    1743 </span>            :   //
<span class="lineNum">    1744 </span>            :   // NOTE: with B&gt;0 the negative particles propagate along increasing t-param and positive 
<span class="lineNum">    1745 </span>            :   // particles - against.
<span class="lineNum">    1746 </span>            :   // t-param = 0 corresponds to the point of closest approach of the track to the beam.
<span class="lineNum">    1747 </span>            :   // Since the fitted helix parameters of the track are defined in this PCA point, when the correction
<span class="lineNum">    1748 </span>            :   // is applied upstream of the PCS, the energy must be increased (DR&gt;0) rather than decreased (DR&lt;0)
<span class="lineNum">    1749 </span>            :   //
<span class="lineNum">    1750 </span>            :   Double_t dirTr[3];
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :   dirTr[0] = -TMath::Sin(fParams[kPhi0]+t);</span>
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :   dirTr[1] =  TMath::Cos(fParams[kPhi0]+t);</span>
<span class="lineNum">    1753 </span><span class="lineNoCov">          0 :   dirTr[2] =  fParams[kDip];</span>
<span class="lineNum">    1754 </span>            :   // cosine of the impact angle
<span class="lineNum">    1755 </span><span class="lineNoCov">          0 :   Double_t cosImp = cdip*TMath::Abs(dirTr[0]*normS[0]+dirTr[1]*normS[1]+dirTr[2]*normS[2]);</span>
<span class="lineNum">    1756 </span>            :   //
<span class="lineNum">    1757 </span><span class="lineNoCov">          0 :   if (cosImp&lt;0.3) cosImp = 0.3; //?</span>
<span class="lineNum">    1758 </span><span class="lineNoCov">          0 :   Double_t dE = AliExternalTrackParam::BetheBlochSolid(p/fMass)*rhoL/cosImp;</span>
<span class="lineNum">    1759 </span><span class="lineNoCov">          0 :   Double_t dP = e/p*dE;</span>
<span class="lineNum">    1760 </span>            :   //
<span class="lineNum">    1761 </span><span class="lineNoCov">          0 :   if (t*GetSignQB() &lt; 0) {</span>
<span class="lineNum">    1762 </span><span class="lineNoCov">          0 :     dP =  -dP;</span>
<span class="lineNum">    1763 </span><span class="lineNoCov">          0 :     dE =  -dE;</span>
<span class="lineNum">    1764 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1765 </span>            :   //
<span class="lineNum">    1766 </span><span class="lineNoCov">          0 :   if (p+dP&lt;0) {</span>
<span class="lineNum">    1767 </span><span class="lineNoCov">          0 :     AliInfo(Form(&quot;Estimated PLoss %.3f is larger than particle momentum %.3f. Skipping&quot;,dP,p));</span>
<span class="lineNum">    1768 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1769 </span>            :   }
<span class="lineNum">    1770 </span>            :   //
<span class="lineNum">    1771 </span><span class="lineNoCov">          0 :   p += dP;</span>
<span class="lineNum">    1772 </span><span class="lineNoCov">          0 :   e += dE;</span>
<span class="lineNum">    1773 </span>            :   //
<span class="lineNum">    1774 </span><span class="lineNoCov">          0 :   return fCharge*dP*cdip/fBz/fgkCQConv;</span>
<span class="lineNum">    1775 </span><span class="lineNoCov">          0 : }</span>
<a name="1776"><span class="lineNum">    1776 </span>            : </a>
<span class="lineNum">    1777 </span>            : //_____________________________________________________________
<span class="lineNum">    1778 </span>            : Double_t AliITSTPArrayFit::GetLineOffset(Int_t axis) const
<span class="lineNum">    1779 </span>            : {
<span class="lineNum">    1780 </span>            :   // return intercept of the parameterization coord = intercept + slope*t for given axis
<span class="lineNum">    1781 </span><span class="lineNoCov">          0 :   if (fParAxis&lt;0) return -1E6; // no line fit</span>
<span class="lineNum">    1782 </span><span class="lineNoCov">          0 :   if (axis==fParAxis) return 0;</span>
<span class="lineNum">    1783 </span><span class="lineNoCov">          0 :   if (fParAxis==kX) return fParams[axis==kY ? kA0 : kA1 ];</span>
<span class="lineNum">    1784 </span><span class="lineNoCov">          0 :   if (fParAxis==kY) return fParams[axis==kZ ? kA0 : kA1 ];</span>
<span class="lineNum">    1785 </span><span class="lineNoCov">          0 :   return fParams[axis==kX ? kA0 : kA1 ];</span>
<span class="lineNum">    1786 </span><span class="lineNoCov">          0 : }</span>
<a name="1787"><span class="lineNum">    1787 </span>            : </a>
<span class="lineNum">    1788 </span>            : //_____________________________________________________________
<span class="lineNum">    1789 </span>            : Double_t AliITSTPArrayFit::GetLineSlope(Int_t axis) const
<span class="lineNum">    1790 </span>            : {
<span class="lineNum">    1791 </span>            :   // return intercept of the parameterization coord = intercept + slope*t for given axis
<span class="lineNum">    1792 </span><span class="lineNoCov">          0 :   if (fParAxis&lt;0) return -1E6; // no line fit</span>
<span class="lineNum">    1793 </span><span class="lineNoCov">          0 :   if (axis==fParAxis) return 1.;</span>
<span class="lineNum">    1794 </span><span class="lineNoCov">          0 :   if (fParAxis==kX) return fParams[axis==kY ? kB0 : kB1 ];</span>
<span class="lineNum">    1795 </span><span class="lineNoCov">          0 :   if (fParAxis==kY) return fParams[axis==kZ ? kB0 : kB1 ];</span>
<span class="lineNum">    1796 </span><span class="lineNoCov">          0 :   return fParams[axis==kX ? kB0 : kB1 ];</span>
<span class="lineNum">    1797 </span><span class="lineNoCov">          0 : }</span>
<a name="1798"><span class="lineNum">    1798 </span>            : </a>
<span class="lineNum">    1799 </span>            : //_____________________________________________________________
<span class="lineNum">    1800 </span>            : void AliITSTPArrayFit::Print(Option_t *) const
<span class="lineNum">    1801 </span>            : {
<span class="lineNum">    1802 </span>            :   // print results of the fit
<span class="lineNum">    1803 </span>            :   //
<span class="lineNum">    1804 </span>            :   const char kCxyz[] = &quot;XYZ&quot;;
<span class="lineNum">    1805 </span><span class="lineNoCov">          0 :   if (!fkPoints) return;</span>
<span class="lineNum">    1806 </span>            :   //
<span class="lineNum">    1807 </span><span class="lineNoCov">          0 :   printf(&quot;Track of %3d points in Bz=%+.1f |Fit &quot;,fPntLast-fPntFirst+1,fBz);</span>
<span class="lineNum">    1808 </span><span class="lineNoCov">          0 :   if ( IsFitDone() ) {</span>
<span class="lineNum">    1809 </span><span class="lineNoCov">          0 :     if (IsHelix())</span>
<span class="lineNum">    1810 </span><span class="lineNoCov">          0 :       printf(&quot;Helix: Chi2: %5.1f | %+.2e %+.2e %+.2e %+.2e %+.2e\n&quot;,</span>
<span class="lineNum">    1811 </span><span class="lineNoCov">          0 :              fChi2NDF,fParams[kD0],fParams[kPhi0],fParams[kR0],fParams[kDZ],fParams[kDip]);</span>
<span class="lineNum">    1812 </span>            :     else 
<span class="lineNum">    1813 </span><span class="lineNoCov">          0 :       printf(&quot;Line%c: Chi2: %5.1f | %+.2e %+.2e %+.2e %+.2e\n&quot;,</span>
<span class="lineNum">    1814 </span><span class="lineNoCov">          0 :              kCxyz[fParAxis],fChi2NDF,fParams[kA0],fParams[kB0],fParams[kA1],fParams[kB1]);</span>
<span class="lineNum">    1815 </span>            :   }
<span class="lineNum">    1816 </span><span class="lineNoCov">          0 :   else printf(&quot;N/A\n&quot;);</span>
<span class="lineNum">    1817 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1818 </span>            : 
<span class="lineNum">    1819 </span>            : 
<span class="lineNum">    1820 </span>            : 
<a name="1821"><span class="lineNum">    1821 </span>            : </a>
<span class="lineNum">    1822 </span>            : //____________________________________________________
<span class="lineNum">    1823 </span>            : void AliITSTPArrayFit::BuildMaterialLUT(Int_t ntri) 
<span class="lineNum">    1824 </span>            : {
<span class="lineNum">    1825 </span>            :   // Fill a look-up table with mean material a la AliITSTrackerMI
<span class="lineNum">    1826 </span>            :   //
<span class="lineNum">    1827 </span><span class="lineNoCov">          0 :   if (!AliGeomManager::GetGeometry()) AliFatal(&quot;Geometry is not loaded&quot;);</span>
<span class="lineNum">    1828 </span>            :   //
<span class="lineNum">    1829 </span>            :   // detector layer to check: dX,dZ,Ymin,Ymax
<span class="lineNum">    1830 </span>            :   const double kLayr[9][4] =  {{0.  ,60. , 2.80,3.00},  // beam pipe
<span class="lineNum">    1831 </span>            :                                {1.28,7.07,-0.20,0.22},  // SPD1
<span class="lineNum">    1832 </span>            :                                {1.28,7.07,-0.20,0.22},  // SPD2
<span class="lineNum">    1833 </span>            :                                {0.  ,76.0, 10.4,11.8},  // Shield1
<span class="lineNum">    1834 </span>            :                                {7.02,7.53,-1.00,4.50},  // SDD1
<span class="lineNum">    1835 </span>            :                                {7.02,7.53,-1.00,4.50},  // SDD2
<span class="lineNum">    1836 </span>            :                                {0.  ,102., 29.0,30.0},  // Shield2
<span class="lineNum">    1837 </span>            :                                {7.50,4.20,-0.15,4.50},  // SSD1
<span class="lineNum">    1838 </span>            :                                {7.50,4.20,-0.15,4.50}}; // SSD2
<span class="lineNum">    1839 </span>            :   //
<span class="lineNum">    1840 </span>            :   //
<span class="lineNum">    1841 </span>            :   // build &lt;dens*L&gt; for detectors (track hitting the sensor in normal direction)
<span class="lineNum">    1842 </span><span class="lineNoCov">          0 :   double pg1[3],pg2[3],res[7];</span>
<span class="lineNum">    1843 </span>            :   //
<span class="lineNum">    1844 </span>            :   int sID = 0;
<span class="lineNum">    1845 </span>            :   int actLrID = 0;
<span class="lineNum">    1846 </span><span class="lineNoCov">          0 :   for (int lr=0;lr&lt;9;lr++) {</span>
<span class="lineNum">    1847 </span>            :     //
<span class="lineNum">    1848 </span>            :     Bool_t active = kFALSE;
<span class="lineNum">    1849 </span><span class="lineNoCov">          0 :     const double* tpars = kLayr[lr];</span>
<span class="lineNum">    1850 </span>            :     //
<span class="lineNum">    1851 </span><span class="lineNoCov">          0 :     if (IsZero(tpars[0])) { // passive layer</span>
<span class="lineNum">    1852 </span>            :       active = kFALSE;
<span class="lineNum">    1853 </span><span class="lineNoCov">          0 :       AliInfo(Form(&quot;Probing passive layer (total layer #%d)&quot;,lr));</span>
<span class="lineNum">    1854 </span><span class="lineNoCov">          0 :     }  </span>
<span class="lineNum">    1855 </span>            :     else {
<span class="lineNum">    1856 </span>            :       active = kTRUE;
<span class="lineNum">    1857 </span><span class="lineNoCov">          0 :       sID += AliGeomManager::LayerSize(++actLrID);</span>
<span class="lineNum">    1858 </span><span class="lineNoCov">          0 :       AliInfo(Form(&quot;Probing sensors of active layer #%d (total layers #%d)&quot;,actLrID,lr));</span>
<span class="lineNum">    1859 </span>            :     }
<span class="lineNum">    1860 </span><span class="lineNoCov">          0 :     double shift = TMath::Abs(tpars[2]-tpars[3])*1E-4;</span>
<span class="lineNum">    1861 </span>            :     double rhol = 0;
<span class="lineNum">    1862 </span><span class="lineNoCov">          0 :     for (int i=ntri;i--;) {</span>
<span class="lineNum">    1863 </span>            :       //
<span class="lineNum">    1864 </span><span class="lineNoCov">          0 :       if (active) {</span>
<span class="lineNum">    1865 </span><span class="lineNoCov">          0 :         int ssID = sID -1 - (int)(AliGeomManager::LayerSize(actLrID)*gRandom-&gt;Rndm());</span>
<span class="lineNum">    1866 </span><span class="lineNoCov">          0 :         pg1[0] = pg2[0] = (gRandom-&gt;Rndm()-0.5)*tpars[0] + shift; // local X</span>
<span class="lineNum">    1867 </span><span class="lineNoCov">          0 :         pg2[0] -= 2*shift;</span>
<span class="lineNum">    1868 </span><span class="lineNoCov">          0 :         pg1[1] = tpars[2];</span>
<span class="lineNum">    1869 </span><span class="lineNoCov">          0 :         pg2[1] = tpars[3];</span>
<span class="lineNum">    1870 </span><span class="lineNoCov">          0 :         pg1[2] = pg2[2] = (gRandom-&gt;Rndm()-0.5)*tpars[1] + shift; // local Z</span>
<span class="lineNum">    1871 </span><span class="lineNoCov">          0 :         pg2[2] -= 2*shift;</span>
<span class="lineNum">    1872 </span><span class="lineNoCov">          0 :         AliITSgeomTGeo::LocalToGlobal(ssID,pg1,pg1);    </span>
<span class="lineNum">    1873 </span><span class="lineNoCov">          0 :         AliITSgeomTGeo::LocalToGlobal(ssID,pg2,pg2);    </span>
<span class="lineNum">    1874 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1875 </span>            :       else {
<span class="lineNum">    1876 </span><span class="lineNoCov">          0 :         double ang = gRandom-&gt;Rndm()*TMath::Pi()*2;</span>
<span class="lineNum">    1877 </span><span class="lineNoCov">          0 :         pg1[0] = tpars[2]*TMath::Cos(ang)+shift;</span>
<span class="lineNum">    1878 </span><span class="lineNoCov">          0 :         pg2[0] = tpars[3]*TMath::Cos(ang)-shift;</span>
<span class="lineNum">    1879 </span><span class="lineNoCov">          0 :         pg1[1] = tpars[2]*TMath::Sin(ang);</span>
<span class="lineNum">    1880 </span><span class="lineNoCov">          0 :         pg2[1] = tpars[3]*TMath::Sin(ang);</span>
<span class="lineNum">    1881 </span><span class="lineNoCov">          0 :         pg1[2] = pg2[2] = (gRandom-&gt;Rndm()-0.5)*tpars[1]+shift; // local Z</span>
<span class="lineNum">    1882 </span><span class="lineNoCov">          0 :         pg2[2] -= 2*shift;</span>
<span class="lineNum">    1883 </span>            :       }
<span class="lineNum">    1884 </span>            : 
<span class="lineNum">    1885 </span>            :       //
<span class="lineNum">    1886 </span><span class="lineNoCov">          0 :       AliTracker::MeanMaterialBudget(pg1,pg2,res);</span>
<span class="lineNum">    1887 </span><span class="lineNoCov">          0 :       rhol += res[0]*res[4];   // rho*L</span>
<span class="lineNum">    1888 </span>            :     }
<span class="lineNum">    1889 </span><span class="lineNoCov">          0 :     fgRhoLITS[lr] = rhol/ntri;</span>
<span class="lineNum">    1890 </span><span class="lineNoCov">          0 :     AliInfo(Form(&quot;Obtained &lt;rho*L&gt; = %e\n&quot;,fgRhoLITS[lr]));</span>
<span class="lineNum">    1891 </span>            :   }
<span class="lineNum">    1892 </span>            :   //
<span class="lineNum">    1893 </span>            :   return;
<span class="lineNum">    1894 </span><span class="lineNoCov">          0 : }</span>
<a name="1895"><span class="lineNum">    1895 </span>            : </a>
<span class="lineNum">    1896 </span>            : //____________________________________________________
<span class="lineNum">    1897 </span>            : Double_t AliITSTPArrayFit::GetPCA2PlaneInfo(Double_t *xyz, Double_t *dir, Int_t axis, Double_t axval) const
<span class="lineNum">    1898 </span>            : {
<span class="lineNum">    1899 </span>            :   // calculate the PCA to plane normal ti axis and crossing it at axval
<span class="lineNum">    1900 </span>            :   // fill the position and direction cosines at this point
<span class="lineNum">    1901 </span>            :   //
<span class="lineNum">    1902 </span><span class="lineNoCov">          0 :   double xyzp[3] = {0,0,0};                // create fake point</span>
<span class="lineNum">    1903 </span><span class="lineNoCov">          0 :   xyzp[axis] = axval;</span>
<span class="lineNum">    1904 </span><span class="lineNoCov">          0 :   double covI[6] = {1e-4,0,0,1e-4,0,1e-4}; // fake cov.matrix loose in all directions</span>
<span class="lineNum">    1905 </span><span class="lineNoCov">          0 :   covI[4*axis - axis*(axis+1)/2] = 1e8;    // except axis</span>
<span class="lineNum">    1906 </span>            :   //
<span class="lineNum">    1907 </span><span class="lineNoCov">          0 :   double t = GetPosition(xyz, xyzp, covI); // got pca</span>
<span class="lineNum">    1908 </span>            :   //
<span class="lineNum">    1909 </span><span class="lineNoCov">          0 :   if (dir) GetDirCos(dir,t);</span>
<span class="lineNum">    1910 </span><span class="lineNoCov">          0 :   return t;</span>
<span class="lineNum">    1911 </span><span class="lineNoCov">          0 : }</span>
<a name="1912"><span class="lineNum">    1912 </span>            : </a>
<span class="lineNum">    1913 </span>            : //____________________________________________________
<span class="lineNum">    1914 </span>            : void AliITSTPArrayFit::GetT0Info(Double_t* xyz, Double_t *dir) const
<span class="lineNum">    1915 </span>            : {
<span class="lineNum">    1916 </span>            :   // get direction cosines for t = 0;
<span class="lineNum">    1917 </span><span class="lineNoCov">          0 :   GetPosition(xyz, 0);</span>
<span class="lineNum">    1918 </span><span class="lineNoCov">          0 :   if (dir) GetDirCos(dir,0);</span>
<span class="lineNum">    1919 </span><span class="lineNoCov">          0 : }</span>
<a name="1920"><span class="lineNum">    1920 </span>            : </a>
<span class="lineNum">    1921 </span>            : //____________________________________________________
<span class="lineNum">    1922 </span>            : Bool_t AliITSTPArrayFit::CalcErrorMatrix()
<span class="lineNum">    1923 </span>            : {
<span class="lineNum">    1924 </span>            :   // compute covariance matrix in lenear approximation of residuals on parameters
<span class="lineNum">    1925 </span><span class="lineNoCov">          0 :   static AliSymMatrix cv(5);</span>
<span class="lineNum">    1926 </span>            :   static Double_t dres[5][3]; 
<span class="lineNum">    1927 </span><span class="lineNoCov">          0 :   cv.Reset();</span>
<span class="lineNum">    1928 </span><span class="lineNoCov">          0 :   int npar = IsHelix() ? 5:4;</span>
<span class="lineNum">    1929 </span>            :   //
<span class="lineNum">    1930 </span><span class="lineNoCov">          0 :   for (int ip=fPntFirst;ip&lt;=fPntLast;ip++) {</span>
<span class="lineNum">    1931 </span><span class="lineNoCov">          0 :     GetDResDParams(&amp;dres[0][0],ip);</span>
<span class="lineNum">    1932 </span><span class="lineNoCov">          0 :     Double_t* covI = GetCovI(ip);</span>
<span class="lineNum">    1933 </span><span class="lineNoCov">          0 :     for (int i=npar;i--;) </span>
<span class="lineNum">    1934 </span><span class="lineNoCov">          0 :       for (int j=i+1;j--;) {</span>
<span class="lineNum">    1935 </span><span class="lineNoCov">          0 :         double cvadd = dres[i][kX]*(dres[j][kX]*covI[ kXX ] + dres[j][kY]*covI[ kXY ] + dres[j][kZ]*covI[ kXZ ])</span>
<span class="lineNum">    1936 </span><span class="lineNoCov">          0 :           +            dres[i][kY]*(dres[j][kX]*covI[ kXY ] + dres[j][kY]*covI[ kYY ] + dres[j][kZ]*covI[ kYZ ])</span>
<span class="lineNum">    1937 </span><span class="lineNoCov">          0 :           +            dres[i][kZ]*(dres[j][kX]*covI[ kXZ ] + dres[j][kY]*covI[ kYZ ] + dres[j][kZ]*covI[ kZZ ]);</span>
<span class="lineNum">    1938 </span><span class="lineNoCov">          0 :         if (covI[kScl]&gt;0) cvadd *= covI[kScl];</span>
<span class="lineNum">    1939 </span><span class="lineNoCov">          0 :         cv(i,j) += cvadd;</span>
<span class="lineNum">    1940 </span>            :       }
<span class="lineNum">    1941 </span>            :   }
<span class="lineNum">    1942 </span><span class="lineNoCov">          0 :   cv.SetSizeUsed(npar);</span>
<span class="lineNum">    1943 </span><span class="lineNoCov">          0 :   if (cv.InvertChol()) {</span>
<span class="lineNum">    1944 </span>            :     //cv.Print(&quot;l&quot;);
<span class="lineNum">    1945 </span>            :     int cnt = 0;
<span class="lineNum">    1946 </span><span class="lineNoCov">          0 :     for (int i=npar;i--;) for (int j=i+1;j--;)fParamsCov[cnt++] = cv(i,j);</span>
<span class="lineNum">    1947 </span>            :     return kTRUE;
<span class="lineNum">    1948 </span>            :   }
<span class="lineNum">    1949 </span>            :   //
<span class="lineNum">    1950 </span><span class="lineNoCov">          0 :   return kFALSE;</span>
<span class="lineNum">    1951 </span><span class="lineNoCov">          0 : }</span>
<a name="1952"><span class="lineNum">    1952 </span>            : </a>
<span class="lineNum">    1953 </span>            : //____________________________________________________
<span class="lineNum">    1954 </span>            : Double_t AliITSTPArrayFit::CalcParPCA(Int_t ipnt) const
<span class="lineNum">    1955 </span>            : {
<span class="lineNum">    1956 </span>            :   // get parameter for the point with least weighted distance to the point
<span class="lineNum">    1957 </span><span class="lineNoCov">          0 :   const double *xyz  = GetPoint(ipnt);</span>
<span class="lineNum">    1958 </span><span class="lineNoCov">          0 :   const double *covI = GetCovI(ipnt);</span>
<span class="lineNum">    1959 </span><span class="lineNoCov">          0 :   if (IsHelix()) return GetParPCAHelix(xyz,covI,covI[kScl]);</span>
<span class="lineNum">    1960 </span><span class="lineNoCov">          0 :   else           return GetParPCALine(xyz,covI/*,covI[kScl]*/);</span>
<span class="lineNum">    1961 </span><span class="lineNoCov">          0 : }</span>
<a name="1962"><span class="lineNum">    1962 </span>            : </a>
<span class="lineNum">    1963 </span>            : //____________________________________________________
<span class="lineNum">    1964 </span>            : Double_t AliITSTPArrayFit::GetPt() const 
<span class="lineNum">    1965 </span>            : {
<span class="lineNum">    1966 </span><span class="lineNoCov">          0 :   return IsFieldON()&amp;&amp;IsHelix() ? TMath::Abs(fParams[kR0]*fBz*fgkCQConv) : -1;</span>
<span class="lineNum">    1967 </span>            : }
<a name="1968"><span class="lineNum">    1968 </span>            : </a>
<span class="lineNum">    1969 </span>            : //____________________________________________________
<span class="lineNum">    1970 </span>            : Double_t AliITSTPArrayFit::GetP() const 
<span class="lineNum">    1971 </span>            : {
<span class="lineNum">    1972 </span><span class="lineNoCov">          0 :   if (!IsFieldON()) return -1;</span>
<span class="lineNum">    1973 </span><span class="lineNoCov">          0 :   Double_t cdip = 1./TMath::Sqrt(1.+fParams[kDip]*fParams[kDip]);</span>
<span class="lineNum">    1974 </span><span class="lineNoCov">          0 :   return TMath::Abs(fParams[kR0]*fgkCQConv*fBz/cdip); // momentum</span>
<span class="lineNum">    1975 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1976 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
