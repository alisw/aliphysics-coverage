<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - ITS/ITSsim/AliITSv11GeometrySSD.cxx</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">ITS/ITSsim</a> - AliITSv11GeometrySSD.cxx<span style="font-size: 80%;"> (source / <a href="AliITSv11GeometrySSD.cxx.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">5652</td>
            <td class="headerCovTableEntry">5931</td>
            <td class="headerCovTableEntryHi">95.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">271</td>
            <td class="headerCovTableEntry">273</td>
            <td class="headerCovTableEntryHi">99.3 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**************************************************************************</a>
<span class="lineNum">       2 </span>            :  * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
<span class="lineNum">       3 </span>            :  *                                                                        *
<span class="lineNum">       4 </span>            :  * Author: The ALICE Off-line Project.                                    *
<span class="lineNum">       5 </span>            :  * Contributors are mentioned in the code where appropriate.              *
<span class="lineNum">       6 </span>            :  *                                                                        *
<span class="lineNum">       7 </span>            :  * Permission to use, copy, modify and distribute this software and its   *
<span class="lineNum">       8 </span>            :  * documentation strictly for non-commercial purposes is hereby granted   *
<span class="lineNum">       9 </span>            :  * without fee, provided that the above copyright notice appears in all   *
<span class="lineNum">      10 </span>            :  * copies and that both the copyright notice and this permission notice   *
<span class="lineNum">      11 </span>            :  * appear in the supporting documentation. The authors make no claims     *
<span class="lineNum">      12 </span>            :  * about the suitability of this software for any purpose. It is          *
<span class="lineNum">      13 </span>            :  * provided &quot;as is&quot; without express or implied warranty.                  *
<span class="lineNum">      14 </span>            :  **************************************************************************/
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : /* $Id$ */
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : //*************************************************************************
<span class="lineNum">      19 </span>            : // SSD geometry, based on ROOT geometrical modeler
<span class="lineNum">      20 </span>            : //
<span class="lineNum">      21 </span>            : // Enrico Cattaruzza                                    ecattar@ts.infn.it
<span class="lineNum">      22 </span>            : //*************************************************************************
<span class="lineNum">      23 </span>            : #include &quot;TMath.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;TGeoVolume.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;TGeoMatrix.h&quot;
<span class="lineNum">      26 </span>            : #include &lt;TGeoManager.h&gt;
<span class="lineNum">      27 </span>            : #include &quot;TVector3.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;TGeoArb8.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;TList.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;TGeoMatrix.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;TGeoCompositeShape.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;TGeoBoolNode.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;TGeoTube.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;TGeoBBox.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;TGeoXtru.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;TGeoTorus.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;TGeoPgon.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;TGeoPcon.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;TRotation.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;AliITSv11GeometrySSD.h&quot;
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : /////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">      43 </span>            : // Names of the Sensitive Volumes of Layer 5 and Layer 6
<span class="lineNum">      44 </span>            : /////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">      45 </span>            : const char* AliITSv11GeometrySSD::fgkSSDsensitiveVolName5 = &quot;ITSssdSensitivL5&quot;;
<span class="lineNum">      46 </span>            : const char* AliITSv11GeometrySSD::fgkSSDsensitiveVolName6 = &quot;ITSssdSensitivL6&quot;;
<span class="lineNum">      47 </span>            : /////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">      48 </span>            : //Parameters for SSD Geometry
<span class="lineNum">      49 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="50"><span class="lineNum">      50 </span>            : // Variable for Vertical Disalignement of Modules</a>
<a name="51"><span class="lineNum">      51 </span>            : /////////////////////////////////////////////////////////////////////////////////</a>
<a name="52"><span class="lineNum">      52 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDTolerance = 0.0001*fgkmm;</span></a>
<span class="lineNum">      53 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDModuleVerticalDisalignment = 0.2*fgkmm;</span>
<a name="54"><span class="lineNum">      54 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDModuleSideDisalignment     = 0.2*fgkmm;</span></a>
<span class="lineNum">      55 </span>            : // For ladders:
<span class="lineNum">      56 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDLadderVerticalDisalignment = 0.520*fgkmm;</span>
<span class="lineNum">      57 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="58"><span class="lineNum">      58 </span>            : // Layer5 (lengths are in mm and angles in degrees)</a>
<span class="lineNum">      59 </span>            : /////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">      60 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDLay5LadderLength      = 950.7*fgkmm;</span>
<a name="61"><span class="lineNum">      61 </span>            : const Int_t AliITSv11GeometrySSD::fgkSSDLay5SensorsNumber        =  22;</a>
<a name="62"><span class="lineNum">      62 </span>            : const Int_t AliITSv11GeometrySSD::fgkSSDLay5LadderNumber         =  34;</a>
<a name="63"><span class="lineNum">      63 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDLay5RadiusMin         = 378.0*fgkmm;</span></a>
<span class="lineNum">      64 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDLay5RadiusMax         = 384.0*fgkmm;</span>
<span class="lineNum">      65 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkLay5CenterITSPosition    = 467.85*fgkmm;</span>
<span class="lineNum">      66 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="67"><span class="lineNum">      67 </span>            : // Layer6 (lengths are in mm and angles in degrees)</a>
<span class="lineNum">      68 </span>            : /////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">      69 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDLay6LadderLength      = 1068.0*fgkmm;</span>
<a name="70"><span class="lineNum">      70 </span>            : const Int_t AliITSv11GeometrySSD::fgkSSDLay6SensorsNumber        =   25;</a>
<a name="71"><span class="lineNum">      71 </span>            : const Int_t AliITSv11GeometrySSD::fgkSSDLay6LadderNumber         =   38;</a>
<a name="72"><span class="lineNum">      72 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDLay6RadiusMin         =  428.0*fgkmm;</span></a>
<span class="lineNum">      73 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDLay6RadiusMax         =  434.0*fgkmm;</span>
<span class="lineNum">      74 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkLay6CenterITSPosition    = 526.50*fgkmm;</span>
<span class="lineNum">      75 </span>            : /////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">      76 </span>            : // SSD Chips and Hybrid (lengths are in mm and angles in degrees)
<a name="77"><span class="lineNum">      77 </span>            : /////////////////////////////////////////////////////////////////////////////////</a>
<a name="78"><span class="lineNum">      78 </span>            : const Int_t AliITSv11GeometrySSD::fgkSSDChipNumber               =   6;</a>
<a name="79"><span class="lineNum">      79 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDChipLength            =  11.100*fgkmm; </span></a>
<a name="80"><span class="lineNum">      80 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDChipWidth             =   3.850*fgkmm;</span></a>
<a name="81"><span class="lineNum">      81 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDChipHeight            =   0.180*fgkmm;</span></a>
<a name="82"><span class="lineNum">      82 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDChipSeparationLength  =   1.000*fgkmm;</span></a>
<a name="83"><span class="lineNum">      83 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDChipGlueLength     = fgkSSDChipLength;</span></a>
<span class="lineNum">      84 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDChipGlueWidth      =  fgkSSDChipWidth;</span>
<span class="lineNum">      85 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDChipGlueHeight        =   0.030*fgkmm;</span>
<span class="lineNum">      86 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="87"><span class="lineNum">      87 </span>            : // Stiffener (lengths are in mm and angles in degrees)</a>
<a name="88"><span class="lineNum">      88 </span>            : /////////////////////////////////////////////////////////////////////////////////</a>
<a name="89"><span class="lineNum">      89 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDStiffenerLength       =  73.000*fgkmm;</span></a>
<a name="90"><span class="lineNum">      90 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDStiffenerWidth        =   6.500*fgkmm;</span></a>
<a name="91"><span class="lineNum">      91 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDStiffenerHeight       =   0.295*fgkmm;</span></a>
<a name="92"><span class="lineNum">      92 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDStiffenerToChipDist   =   2.500*fgkmm;</span></a>
<a name="93"><span class="lineNum">      93 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDCapacitor0603CapLength  =  0.900*fgkmm;  // Includes solder</span></a>
<a name="94"><span class="lineNum">      94 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDCapacitor0603Length   = 1.600*fgkmm; </span></a>
<a name="95"><span class="lineNum">      95 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDCapacitor0603Width    =   0.870*fgkmm;</span></a>
<a name="96"><span class="lineNum">      96 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDCapacitor0603Height   =   0.800*fgkmm;</span></a>
<a name="97"><span class="lineNum">      97 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDCapacitor1812CapLength  =  0.215*fgkmm;</span></a>
<a name="98"><span class="lineNum">      98 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDCapacitor1812Length   =   4.600*fgkmm;</span></a>
<a name="99"><span class="lineNum">      99 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDCapacitor1812Width    =   3.400*fgkmm;</span></a>
<a name="100"><span class="lineNum">     100 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDCapacitor1812Height   =   1.400*fgkmm;   </span></a>
<a name="101"><span class="lineNum">     101 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDWireLength            =  30.000*fgkmm;</span></a>
<a name="102"><span class="lineNum">     102 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDWireRadius            =   0.185*fgkmm;</span></a>
<a name="103"><span class="lineNum">     103 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDConnectorPosition[2]  = {44.32*fgkmm, 0.33*fgkmm};</span></a>
<a name="104"><span class="lineNum">     104 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDConnectorSeparation   =        0.44*fgkmm;</span></a>
<a name="105"><span class="lineNum">     105 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDConnectorLength       =        2.16*fgkmm;</span></a>
<a name="106"><span class="lineNum">     106 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDConnectorWidth        =        3.60*fgkmm;</span></a>
<a name="107"><span class="lineNum">     107 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDConnectorHeight       =   0.25*fgkSSDStiffenerHeight;</span></a>
<a name="108"><span class="lineNum">     108 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDConnectorAlHeight     =       0.030*fgkmm;</span></a>
<span class="lineNum">     109 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDConnectorNiHeight     =   0.002*fgkmm;</span>
<span class="lineNum">     110 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDConnectorSnHeight     =   0.15*fgkmm;</span>
<span class="lineNum">     111 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="112"><span class="lineNum">     112 </span>            : // Cooling Block (lengths are in mm and angles in degrees)</a>
<a name="113"><span class="lineNum">     113 </span>            : /////////////////////////////////////////////////////////////////////////////////</a>
<a name="114"><span class="lineNum">     114 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDCoolingBlockLength    =   3.000*fgkmm;</span></a>
<span class="lineNum">     115 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDCoolingBlockWidth     =   4.000*fgkmm;</span>
<a name="116"><span class="lineNum">     116 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDCoolingBlockHeight[3] =  </a>
<span class="lineNum">     117 </span><span class="lineCov">        116 :                                                                                  {1.950*fgkmm, 0.240*fgkmm, 0.300*fgkmm};</span>
<a name="118"><span class="lineNum">     118 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDCoolingBlockHoleRadius[2] = </a>
<span class="lineNum">     119 </span><span class="lineCov">        116 :   {1.025*fgkmm, 0.120*fgkmm};  // Added 50 micron tolerance for thicker wall cooling pipe (March 2010)</span>
<a name="120"><span class="lineNum">     120 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDCoolingBlockHoleLength[2] = </a>
<span class="lineNum">     121 </span><span class="lineCov">        116 :                                                                                                           {1.900*fgkmm, 0.400*fgkmm};</span>
<a name="122"><span class="lineNum">     122 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDCoolingBlockHoleCenter    =  </a>
<span class="lineNum">     123 </span><span class="lineCov">        116 :                                                                                                                                          1.500*fgkmm;</span>
<span class="lineNum">     124 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDCoolingBlockHoleHeight    =  
<span class="lineNum">     125 </span><span class="lineCov">        116 :                                                                                                                                          0.300*fgkmm;</span>
<span class="lineNum">     126 </span>            : /////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     127 </span>            : // SSD Sensor (lengths are in mm and angles in degrees)
<span class="lineNum">     128 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="129"><span class="lineNum">     129 </span>            : const char*  AliITSv11GeometrySSD::fgkSSDSensitiveVolName       = </a>
<a name="130"><span class="lineNum">     130 </span>            :                                                                                                                  &quot;SSDSensorSensitiveVol&quot;;</a>
<a name="131"><span class="lineNum">     131 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDSensorLength          =  42.000*fgkmm;</span></a>
<a name="132"><span class="lineNum">     132 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDSensorHeight          =   0.300*fgkmm;</span></a>
<span class="lineNum">     133 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDSensorWidth           =  75.000*fgkmm;</span>
<a name="134"><span class="lineNum">     134 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDSensorOverlap         = </a>
<a name="135"><span class="lineNum">     135 </span><span class="lineCov">        116 :                                                                                                    fgkSSDSensorLength-39.1*fgkmm;</span></a>
<span class="lineNum">     136 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDSensorInsensitiveLength    = 1.*fgkmm; </span>
<span class="lineNum">     137 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDSensorInsensitiveWidth     = 1.*fgkmm;</span>
<span class="lineNum">     138 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="139"><span class="lineNum">     139 </span>            : // Flex (lengths are in mm and angles in degrees)</a>
<a name="140"><span class="lineNum">     140 </span>            : /////////////////////////////////////////////////////////////////////////////////</a>
<span class="lineNum">     141 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDFlexFullLength       =  106.000*fgkmm; </span>
<span class="lineNum">     142 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDFlexLength[4]        = 
<span class="lineNum">     143 </span><span class="lineCov">        348 :                         {0.5 * (fgkSSDStiffenerLength+fgkSSDChipNumber*fgkSSDChipLength</span>
<span class="lineNum">     144 </span><span class="lineCov">         58 :                                  + (fgkSSDChipNumber-1)*fgkSSDChipSeparationLength),</span>
<span class="lineNum">     145 </span><span class="lineCov">        116 :                          0.5 * (fgkSSDStiffenerLength+fgkSSDChipNumber*fgkSSDChipLength</span>
<a name="146"><span class="lineNum">     146 </span><span class="lineCov">         58 :                                  + (fgkSSDChipNumber-1)*fgkSSDChipSeparationLength)</span></a>
<span class="lineNum">     147 </span><span class="lineCov">        232 :                                                                            - 4.000*fgkmm, 9.500*fgkmm, 10.000*fgkmm};</span>
<a name="148"><span class="lineNum">     148 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDFlexWidth[2]         = </a>
<span class="lineNum">     149 </span><span class="lineCov">        116 :                                                                                                    {  9.340*fgkmm,  5.380*fgkmm};</span>
<span class="lineNum">     150 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDFlexHeight[2]        =
<a name="151"><span class="lineNum">     151 </span><span class="lineCov">        116 :                                                                                                    {  0.030*fgkmm,  0.020*fgkmm};      </span></a>
<a name="152"><span class="lineNum">     152 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDFlexAngle            =   30.000;</a>
<a name="153"><span class="lineNum">     153 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDFlexHoleLength       =    1.430*fgkmm;</span></a>
<span class="lineNum">     154 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDFlexHoleWidth        =    3.000*fgkmm;</span>
<a name="155"><span class="lineNum">     155 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDEndFlexCompLength[6] = </a>
<span class="lineNum">     156 </span><span class="lineCov">        116 :                          {3.30*fgkmm,4.12*fgkmm,4.22*fgkmm,1.70*fgkmm,0.75*fgkmm,7.18*fgkmm};</span>
<span class="lineNum">     157 </span>            : const Double_t AliITSv11GeometrySSD:: fgkSSDEndFlexCompWidth[3] =
<span class="lineNum">     158 </span><span class="lineCov">        116 :                                                                                    {15.03*fgkmm,23.48*fgkmm,12.28*fgkmm};</span>
<span class="lineNum">     159 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="160"><span class="lineNum">     160 </span>            : // SSD Ladder Cable (lengths are in mm and angles in degrees)</a>
<a name="161"><span class="lineNum">     161 </span>            : /////////////////////////////////////////////////////////////////////////////////</a>
<span class="lineNum">     162 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDLadderCableWidth     =     23.5*fgkmm;</span>
<span class="lineNum">     163 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDLadderCableHeight[2] = {  0.030*fgkmm*17.5/23.5,  1.25 * 0.030*fgkmm};   // Al covers ~ 17.5/23.5 of surface, Kapton includes glue+foam   </span>
<span class="lineNum">     164 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="165"><span class="lineNum">     165 </span>            : // SSD Module (lengths are in mm and angles in degrees)</a>
<span class="lineNum">     166 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="167"><span class="lineNum">     167 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDModuleStiffenerPosition[2]  = </a>
<span class="lineNum">     168 </span><span class="lineCov">        116 :                                                                                                          { 1.000*fgkmm, 3.900*fgkmm};</span>
<a name="169"><span class="lineNum">     169 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDModuleSensorSupportDistance =  </a>
<span class="lineNum">     170 </span><span class="lineCov">        116 :                                                                                                                                         45.600*fgkmm;</span>
<span class="lineNum">     171 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDModuleCoolingBlockToSensor  =  
<span class="lineNum">     172 </span><span class="lineCov">        116 :                                                                                                                                          5.075*fgkmm;</span>
<span class="lineNum">     173 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="174"><span class="lineNum">     174 </span>            : // Sensor Support (lengths are in mm and angles in degrees)</a>
<span class="lineNum">     175 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="176"><span class="lineNum">     176 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDSensorSideSupportLength                     = </a>
<span class="lineNum">     177 </span><span class="lineCov">        116 :                                                                                                                                          5.800*fgkmm;</span>
<a name="178"><span class="lineNum">     178 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDSensorSideSupportWidth          =  </a>
<span class="lineNum">     179 </span><span class="lineCov">        116 :                                                                                                                                          2.000*fgkmm;</span>
<span class="lineNum">     180 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDSensorSideSupportHeight[2]      =
<span class="lineNum">     181 </span><span class="lineCov">        174 :                                                                                                      { 4.620*fgkmm-fgkSSDModuleVerticalDisalignment, </span>
<span class="lineNum">     182 </span><span class="lineCov">        116 :                                                                                                        5.220*fgkmm-fgkSSDModuleVerticalDisalignment};</span>
<a name="183"><span class="lineNum">     183 </span>            : //const Double_t AliITSv11GeometrySSD::fgkSSDSensorSideSupportHeight[2]      =</a>
<span class="lineNum">     184 </span>            : //                                                                                                   { 4.520*fgkmm, 5.130*fgkmm};
<a name="185"><span class="lineNum">     185 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDSensorSideSupportThickness[2]   = </a>
<span class="lineNum">     186 </span><span class="lineCov">        116 :                                                                                                          { 0.450*fgkmm, 0.450*fgkmm};</span>
<span class="lineNum">     187 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDSensorSideSupportPosition       
<span class="lineNum">     188 </span><span class="lineCov">        174 :                                                                 = 0.5 * (fgkSSDModuleSensorSupportDistance</span>
<a name="189"><span class="lineNum">     189 </span><span class="lineCov">         58 :                                                             +  fgkSSDSensorSideSupportThickness[0])</span></a>
<span class="lineNum">     190 </span><span class="lineCov">         58 :                                                                 -  fgkSSDSensorSideSupportLength;</span>
<a name="191"><span class="lineNum">     191 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDSensorCenterSupportLength       =  </a>
<span class="lineNum">     192 </span><span class="lineCov">        116 :                                                                                                                                     5.250*fgkmm;</span>
<a name="193"><span class="lineNum">     193 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDSensorCenterSupportWidth        =</a>
<span class="lineNum">     194 </span><span class="lineCov">        116 :                                                                                                                                         1.680*fgkmm;</span>
<span class="lineNum">     195 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDSensorCenterSupportHeight[2]    
<span class="lineNum">     196 </span><span class="lineCov">        232 :                                                                   = {fgkSSDSensorSideSupportHeight[0]</span>
<span class="lineNum">     197 </span><span class="lineCov">         58 :                                                                   +  fgkSSDSensorSideSupportThickness[0],</span>
<a name="198"><span class="lineNum">     198 </span><span class="lineCov">         58 :                                                                          fgkSSDSensorSideSupportHeight[1]</span></a>
<span class="lineNum">     199 </span><span class="lineCov">        116 :                                                                   +  fgkSSDSensorSideSupportThickness[1]};</span>
<span class="lineNum">     200 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDSensorCenterSupportThickness[2] 
<a name="201"><span class="lineNum">     201 </span><span class="lineCov">        174 :                                                                   =  {fgkSSDSensorSideSupportThickness[0],</span></a>
<span class="lineNum">     202 </span><span class="lineCov">        116 :                                                                           fgkSSDSensorSideSupportThickness[1]};</span>
<span class="lineNum">     203 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDSensorCenterSupportPosition     = 
<span class="lineNum">     204 </span><span class="lineCov">        116 :                                                                                                                                    19.000*fgkmm;</span>
<span class="lineNum">     205 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="206"><span class="lineNum">     206 </span>            : // Chip Cables (lengths are in mm and angles in degrees)</a>
<span class="lineNum">     207 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="208"><span class="lineNum">     208 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDChipCablesLength[2]   = </a>
<span class="lineNum">     209 </span><span class="lineCov">        116 :                                   {73.12/fgkSSDChipNumber*fgkmm,fgkSSDChipLength+2.*0.19*fgkmm};</span>
<span class="lineNum">     210 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDChipCablesHeight[4]   = 
<span class="lineNum">     211 </span><span class="lineCov">        232 :                                   {  0.014*fgkmm,  0.010*fgkmm, fgkSSDModuleCoolingBlockToSensor</span>
<span class="lineNum">     212 </span><span class="lineCov">        116 :                                                                   -  (fgkSSDSensorSideSupportHeight[1]</span>
<span class="lineNum">     213 </span><span class="lineCov">         58 :                                                                   -   fgkSSDSensorSideSupportHeight[0])</span>
<span class="lineNum">     214 </span><span class="lineCov">         58 :                                                                   -   fgkSSDModuleVerticalDisalignment</span>
<span class="lineNum">     215 </span><span class="lineCov">         58 :                                                                   -   fgkSSDCoolingBlockHoleCenter</span>
<span class="lineNum">     216 </span><span class="lineCov">         58 :                                                                   -   fgkSSDStiffenerHeight</span>
<span class="lineNum">     217 </span><span class="lineCov">         58 :                                                                   -   fgkSSDChipHeight-fgkSSDSensorHeight,</span>
<span class="lineNum">     218 </span><span class="lineCov">         58 :                                                                           fgkSSDModuleCoolingBlockToSensor</span>
<span class="lineNum">     219 </span><span class="lineCov">         58 :                                                                   -   fgkSSDModuleVerticalDisalignment  </span>
<span class="lineNum">     220 </span><span class="lineCov">         58 :                                                                   -   fgkSSDCoolingBlockHoleCenter</span>
<a name="221"><span class="lineNum">     221 </span><span class="lineCov">         58 :                                                                   -       fgkSSDStiffenerHeight</span></a>
<span class="lineNum">     222 </span><span class="lineCov">        116 :                                                                   -   fgkSSDChipHeight-fgkSSDSensorHeight};</span>
<span class="lineNum">     223 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDChipCablesWidth[3]    = 
<span class="lineNum">     224 </span><span class="lineCov">        116 :                                             { 11.000*fgkmm,  0.800*fgkmm,  0.600*fgkmm};</span>
<span class="lineNum">     225 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="226"><span class="lineNum">     226 </span>            : // Carbon Fiber Junction Parameters (lengths are in mm and angles in degrees)</a>
<span class="lineNum">     227 </span>            : /////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     228 </span>            : const Double_t AliITSv11GeometrySSD::fgkCarbonFiberJunctionLength          = 
<span class="lineNum">     229 </span><span class="lineCov">        116 :                                                                                                                                         3.820*fgkmm;</span>
<a name="230"><span class="lineNum">     230 </span>            : //const Double_t AliITSv11GeometrySSD::fgkCarbonFiberJunctionLength          = </a>
<span class="lineNum">     231 </span>            : //                                                                                                                                         3.780;
<a name="232"><span class="lineNum">     232 </span>            : const Double_t AliITSv11GeometrySSD::fgkCarbonFiberJunctionWidth           = </a>
<span class="lineNum">     233 </span><span class="lineCov">        116 :                                                                                  fgkSSDSensorLength-fgkSSDSensorOverlap;</span>
<span class="lineNum">     234 </span>            : const Double_t AliITSv11GeometrySSD::fgkCarbonFiberJunctionEdge[2]         = 
<span class="lineNum">     235 </span><span class="lineCov">        116 :                                                                                                         {  0.86*fgkmm,  0.30*fgkmm};</span>
<a name="236"><span class="lineNum">     236 </span>            : const Double_t AliITSv11GeometrySSD::fgkCarbonFiberJunctionAngle[2]        = </a>
<span class="lineNum">     237 </span>            :                                                                                                                                 { 30.00, 90.00};
<span class="lineNum">     238 </span>            : const Double_t AliITSv11GeometrySSD::fgkCarbonFiberJunctionToSensorSupport = 
<span class="lineNum">     239 </span><span class="lineCov">        116 :                                                                                                                                          1.78*fgkmm;</span>
<span class="lineNum">     240 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="241"><span class="lineNum">     241 </span>            : //Carbon Fiber Parameters (lengths are in mm and angles in degrees)</a>
<span class="lineNum">     242 </span>            : /////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     243 </span>            : const Double_t AliITSv11GeometrySSD::fgkCarbonFiberTriangleLength          
<span class="lineNum">     244 </span><span class="lineCov">        116 :                                                                    = fgkSSDModuleSensorSupportDistance</span>
<a name="245"><span class="lineNum">     245 </span><span class="lineCov">         58 :                                                                    - 2. * fgkCarbonFiberJunctionToSensorSupport;  </span></a>
<span class="lineNum">     246 </span>            : const Double_t AliITSv11GeometrySSD::fgkCarbonFiberTriangleAngle = 60.00;
<a name="247"><span class="lineNum">     247 </span>            : const Double_t AliITSv11GeometrySSD::fgkCarbonFiberSupportTopEdgeDist[2]   = </a>
<span class="lineNum">     248 </span><span class="lineCov">        116 :                                                                                                   {  0.751*fgkmm,  0.482*fgkmm};</span>
<a name="249"><span class="lineNum">     249 </span>            : const Double_t AliITSv11GeometrySSD::fgkCarbonFiberSupportEdgeLength  = </a>
<a name="250"><span class="lineNum">     250 </span><span class="lineCov">        116 :                                                                                                                                         1.630*fgkmm;</span></a>
<span class="lineNum">     251 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkCarbonFiberSupportWidth =   0.950*fgkmm;</span>
<span class="lineNum">     252 </span>            : const Double_t AliITSv11GeometrySSD::fgkCarbonFiberSupportXAxisLength      
<span class="lineNum">     253 </span><span class="lineCov">        116 :                                                                         = fgkCarbonFiberTriangleLength</span>
<span class="lineNum">     254 </span><span class="lineCov">        116 :                                                                         - 0.5*fgkCarbonFiberSupportTopEdgeDist[1]</span>
<a name="255"><span class="lineNum">     255 </span><span class="lineCov">         58 :                                                                         / TMath::Cos(fgkCarbonFiberTriangleAngle</span></a>
<span class="lineNum">     256 </span><span class="lineCov">        116 :                                                                         * TMath::DegToRad());</span>
<span class="lineNum">     257 </span>            : const Double_t AliITSv11GeometrySSD::fgkCarbonFiberSupportYAxisLength      
<span class="lineNum">     258 </span><span class="lineCov">        174 :                                                                         = 0.5*(fgkCarbonFiberJunctionWidth</span>
<span class="lineNum">     259 </span><span class="lineCov">         58 :                                                                         - fgkCarbonFiberSupportWidth)</span>
<span class="lineNum">     260 </span><span class="lineCov">         58 :                                                                         - fgkCarbonFiberSupportTopEdgeDist[0]</span>
<span class="lineNum">     261 </span><span class="lineCov">         58 :                                                                         - fgkCarbonFiberSupportWidth;</span>
<span class="lineNum">     262 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="263"><span class="lineNum">     263 </span>            : // Carbon Fiber Lower Support Parameters (lengths are in mm)</a>
<a name="264"><span class="lineNum">     264 </span>            : /////////////////////////////////////////////////////////////////////////////////</a>
<span class="lineNum">     265 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkLowerSupportToSensorZ           = 11.575*fgkmm;  </span>
<a name="266"><span class="lineNum">     266 </span>            : const Double_t AliITSv11GeometrySSD::fgkCarbonFiberLowerSupportWidth             </a>
<span class="lineNum">     267 </span><span class="lineCov">        116 :                                                                                                                                           =  0.950*fgkmm;</span>
<a name="268"><span class="lineNum">     268 </span>            : const Double_t AliITSv11GeometrySSD::fgkCarbonFiberLowerSupportLowerLenght       </a>
<span class="lineNum">     269 </span><span class="lineCov">        116 :                                                                                                                                           =  1.600*fgkmm;</span>
<a name="270"><span class="lineNum">     270 </span>            : const Double_t AliITSv11GeometrySSD::fgkCarbonFiberLowerSupportHeight            </a>
<span class="lineNum">     271 </span><span class="lineCov">        116 :                                                                                                                                           =  0.830*fgkmm;</span>
<a name="272"><span class="lineNum">     272 </span>            : const Double_t AliITSv11GeometrySSD::fgkCarbonFiberLowerSupportVolumeSeparation  </a>
<span class="lineNum">     273 </span><span class="lineCov">        116 :                                                                                           = 0.5*fgkCarbonFiberSupportWidth;</span>
<span class="lineNum">     274 </span>            : const Double_t AliITSv11GeometrySSD::fgkCarbonFiberLowerSupportTransverseWidth   
<span class="lineNum">     275 </span><span class="lineCov">        116 :                                                                         = fgkCarbonFiberJunctionWidth</span>
<a name="276"><span class="lineNum">     276 </span><span class="lineCov">        116 :                                                                         - 2. * (fgkCarbonFiberLowerSupportWidth</span></a>
<span class="lineNum">     277 </span><span class="lineCov">        116 :                                                                         + fgkCarbonFiberLowerSupportVolumeSeparation);</span>
<span class="lineNum">     278 </span>            : const Double_t AliITSv11GeometrySSD::fgkCarbonFiberLowerSupportVolumePosition[2] 
<span class="lineNum">     279 </span><span class="lineCov">        232 :                                                                         = {fgkCarbonFiberLowerSupportWidth</span>
<span class="lineNum">     280 </span><span class="lineCov">         58 :                                                                         +  fgkCarbonFiberLowerSupportVolumeSeparation,</span>
<span class="lineNum">     281 </span><span class="lineCov">         58 :                                                                            fgkCarbonFiberLowerSupportWidth</span>
<span class="lineNum">     282 </span><span class="lineCov">         58 :                                                                         +  fgkCarbonFiberLowerSupportVolumeSeparation                                                   </span>
<span class="lineNum">     283 </span><span class="lineCov">        116 :                                                                         +  fgkCarbonFiberLowerSupportTransverseWidth};</span>
<span class="lineNum">     284 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="285"><span class="lineNum">     285 </span>            : // End Ladder Carbon Fiber Junction Parameters (lengths are in mm and angles in degrees)</a>
<span class="lineNum">     286 </span>            : /////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     287 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndLadderCarbonFiberLowerJunctionLength[2] = 
<span class="lineNum">     288 </span><span class="lineCov">        232 :                                                            {0.5 * (fgkSSDLay5LadderLength</span>
<span class="lineNum">     289 </span><span class="lineCov">         58 :                                                                         -  fgkSSDLay5SensorsNumber</span>
<span class="lineNum">     290 </span><span class="lineCov">         58 :                                                                         *  fgkCarbonFiberJunctionWidth</span>
<span class="lineNum">     291 </span><span class="lineCov">         58 :                                                                         -  fgkCarbonFiberLowerSupportWidth),</span>
<span class="lineNum">     292 </span><span class="lineCov">        116 :                                                                 0.5 * (fgkSSDLay5LadderLength</span>
<span class="lineNum">     293 </span><span class="lineCov">         58 :                                                                         -  fgkSSDLay5SensorsNumber</span>
<a name="294"><span class="lineNum">     294 </span><span class="lineCov">         58 :                                                                         *  fgkCarbonFiberJunctionWidth</span></a>
<span class="lineNum">     295 </span><span class="lineCov">        116 :                                                                         +  fgkCarbonFiberLowerSupportWidth)};</span>
<span class="lineNum">     296 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndLadderCarbonFiberUpperJunctionLength[2] = 
<a name="297"><span class="lineNum">     297 </span><span class="lineCov">        174 :                                                 {fgkEndLadderCarbonFiberLowerJunctionLength[0]-20.4*fgkmm,</span></a>
<span class="lineNum">     298 </span><span class="lineCov">        116 :                                                  fgkEndLadderCarbonFiberLowerJunctionLength[1]-20.6*fgkmm};</span>
<span class="lineNum">     299 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndLadderMountingBlockPosition[2] = 
<a name="300"><span class="lineNum">     300 </span><span class="lineCov">        174 :                                                 {fgkEndLadderCarbonFiberLowerJunctionLength[0]-16.50*fgkmm,</span></a>
<span class="lineNum">     301 </span><span class="lineCov">        116 :                                                  fgkEndLadderCarbonFiberLowerJunctionLength[1]-31.50*fgkmm};</span>
<span class="lineNum">     302 </span>            : const Double_t AliITSv11GeometrySSD::fgkendladdercoolingsupportdistance[3] = 
<span class="lineNum">     303 </span><span class="lineCov">        116 :                                                                                         {15.0*fgkmm, 13.5*fgkmm, 14.5*fgkmm};</span>
<span class="lineNum">     304 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="305"><span class="lineNum">     305 </span>            : // Cooling Tube Support (lengths are in mm and angles in degrees)</a>
<a name="306"><span class="lineNum">     306 </span>            : /////////////////////////////////////////////////////////////////////////////////</a>
<span class="lineNum">     307 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkCoolingTubeSupportRmax      =  1.45*fgkmm;</span>
<a name="308"><span class="lineNum">     308 </span>            : const Double_t AliITSv11GeometrySSD::fgkCoolingTubeSupportRmin          </a>
<a name="309"><span class="lineNum">     309 </span><span class="lineCov">        116 :                                                                                           = fgkSSDCoolingBlockHoleRadius[0];</span></a>
<a name="310"><span class="lineNum">     310 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkCoolingTubeSupportLength    =  8.55*fgkmm;</span></a>
<a name="311"><span class="lineNum">     311 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkCoolingTubeSupportHeight    =  0.85*fgkmm;</span></a>
<span class="lineNum">     312 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkCoolingTubeSupportWidth     =  2.00*fgkmm;</span>
<a name="313"><span class="lineNum">     313 </span>            : const Double_t AliITSv11GeometrySSD::fgkCoolingTubeSupportSeparation    = </a>
<span class="lineNum">     314 </span><span class="lineCov">        116 :                                         fgkSSDSensorLength-2.*fgkSSDSensorOverlap;</span>
<span class="lineNum">     315 </span>            : const Double_t AliITSv11GeometrySSD::fgkCoolingTubeSupportToCarbonFiber = 
<span class="lineNum">     316 </span><span class="lineCov">        116 :                                                                                                                                           11.70*fgkmm;</span>
<span class="lineNum">     317 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="318"><span class="lineNum">     318 </span>            : // Cooling Tube (lengths are in mm and angles in degrees)</a>
<a name="319"><span class="lineNum">     319 </span>            : /////////////////////////////////////////////////////////////////////////////////</a>
<a name="320"><span class="lineNum">     320 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkCoolingTubeRmax = fgkCoolingTubeSupportRmin;</span></a>
<span class="lineNum">     321 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkCoolingTubeRmin =  1.915*fgkmm/2; // Nominal + 50 micron tolerance; real pipes are closer to 450 micron wall thickness</span>
<a name="322"><span class="lineNum">     322 </span>            : const Double_t AliITSv11GeometrySSD::fgkCoolingTubeLength = </a>
<span class="lineNum">     323 </span><span class="lineCov">        116 :                                                                                                         fgkCarbonFiberJunctionWidth;</span>
<span class="lineNum">     324 </span>            : const Double_t AliITSv11GeometrySSD::fgkCoolingTubeSeparation = 
<a name="325"><span class="lineNum">     325 </span><span class="lineCov">        116 :                                                                          fgkSSDModuleSensorSupportDistance</span></a>
<span class="lineNum">     326 </span><span class="lineCov">         58 :                                                                   +      fgkSSDCoolingBlockLength;</span>
<span class="lineNum">     327 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkMountingBlockToSensorSupport = 30.7*fgkmm;</span>
<span class="lineNum">     328 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="329"><span class="lineNum">     329 </span>            : // SSD Mounting Block Parameters (lengths are in mm and angles in degrees)</a>
<span class="lineNum">     330 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="331"><span class="lineNum">     331 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDMountingBlockLength[3]            = </a>
<span class="lineNum">     332 </span><span class="lineCov">        116 :                                                                                    { 60.0*fgkmm, 42.2*fgkmm, 34.0*fgkmm};</span>
<a name="333"><span class="lineNum">     333 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDMountingBlockHeight[4]            =</a>
<span class="lineNum">     334 </span><span class="lineCov">        116 :                                                            {  4.0*fgkmm,  8.0*fgkmm,  5.0*fgkmm,  0.2*fgkmm};</span>
<span class="lineNum">     335 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDMountingBlockWidth                =   
<span class="lineNum">     336 </span><span class="lineCov">        116 :                                                                                                                                           20.0*fgkmm;</span>
<a name="337"><span class="lineNum">     337 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDMountingBlockHoleTrapezoidAngle   =   </a>
<span class="lineNum">     338 </span>            :                                                                                                                                                     40.0;
<a name="339"><span class="lineNum">     339 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDMountingBlockHoleTrapezoidHeight  = </a>
<span class="lineNum">     340 </span><span class="lineCov">        116 :                    0.30*(fgkSSDMountingBlockHeight[1]-fgkSSDMountingBlockHeight[2]);</span>
<a name="341"><span class="lineNum">     341 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDMountingBlockHoleTrapezoidUpBasis =    </a>
<span class="lineNum">     342 </span><span class="lineCov">        116 :                                                                                                                                           2.5*fgkmm;</span>
<a name="343"><span class="lineNum">     343 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDMountingBlockHoleTubeLength[2]    = </a>
<span class="lineNum">     344 </span><span class="lineCov">        116 :                                                                                                           { 56.0*fgkmm, 12.0*fgkmm}; </span>
<a name="345"><span class="lineNum">     345 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDMountingBlockHoleTubeWidth[2]     = </a>
<span class="lineNum">     346 </span><span class="lineCov">        116 :                                                                                                       {  5.0*fgkmm,  2.9*fgkmm}; </span>
<a name="347"><span class="lineNum">     347 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDMountingBlockHoleRadius           = </a>
<span class="lineNum">     348 </span><span class="lineCov">        116 :                                                                                                                                           1.0*fgkmm;</span>
<a name="349"><span class="lineNum">     349 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDMountingBlockScrewHoleEdge        =   </a>
<span class="lineNum">     350 </span><span class="lineCov">        116 :                                                                                                                                           6.0*fgkmm;</span>
<a name="351"><span class="lineNum">     351 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDMountingBlockScrewHoleHeight      =  </a>
<span class="lineNum">     352 </span><span class="lineCov">        116 :                                                                                                                                           4.0*fgkmm;</span>
<span class="lineNum">     353 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDMountingBlockScrewHoleRadius[2]   =
<span class="lineNum">     354 </span><span class="lineCov">        116 :                                                           {  1.5*fgkmm,fgkSSDMountingBlockScrewHoleEdge/6.};</span>
<span class="lineNum">     355 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="356"><span class="lineNum">     356 </span>            : // SSD Mounting Block Clip Parameters (lengths are in mm and angles in degrees)</a>
<a name="357"><span class="lineNum">     357 </span>            : /////////////////////////////////////////////////////////////////////////////////</a>
<a name="358"><span class="lineNum">     358 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkMountingBlockClipLength        = 15.1*fgkmm;</span></a>
<a name="359"><span class="lineNum">     359 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkMountingBlockClipThickness     = 0.3*fgkmm;</span></a>
<a name="360"><span class="lineNum">     360 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkMountingBlockClibScrewRadius   = 1.6*fgkmm;</span></a>
<span class="lineNum">     361 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkMountingBlockClibScrewPosition = 4.0*fgkmm;</span>
<span class="lineNum">     362 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkMountingBlockClibWidth         = 9.0*fgkmm;</span>
<span class="lineNum">     363 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="364"><span class="lineNum">     364 </span>            : // SSD Mounting Block Support Parameters (lengths are in mm and angles in degrees)</a>
<a name="365"><span class="lineNum">     365 </span>            : /////////////////////////////////////////////////////////////////////////////////</a>
<a name="366"><span class="lineNum">     366 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkMountingBlockSupportWidth[2] = {9.5*fgkmm,10.0*fgkmm}; </span></a>
<span class="lineNum">     367 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkMountingBlockSupportDownHeight   = 4.0*fgkmm;</span>
<span class="lineNum">     368 </span><span class="lineCov">        232 : const Double_t AliITSv11GeometrySSD::fgkMountingBlockSupportRadius[2] = {fgkSSDLay5RadiusMin</span>
<span class="lineNum">     369 </span><span class="lineCov">         58 :                                                                                                   -  fgkSSDMountingBlockHeight[1]</span>
<span class="lineNum">     370 </span><span class="lineCov">         58 :                                                                                                   +  0.5*fgkCoolingTubeSupportHeight</span>
<span class="lineNum">     371 </span><span class="lineCov">         58 :                                                                                                   +      fgkSSDModuleCoolingBlockToSensor</span>
<span class="lineNum">     372 </span><span class="lineCov">         58 :                                                                                                   -      fgkMountingBlockSupportDownHeight,</span>
<span class="lineNum">     373 </span><span class="lineCov">         58 :                                                                                                          fgkSSDLay6RadiusMin</span>
<span class="lineNum">     374 </span><span class="lineCov">         58 :                                                                                                   -  fgkSSDMountingBlockHeight[1]</span>
<span class="lineNum">     375 </span><span class="lineCov">         58 :                                                                                                   +  0.5*fgkCoolingTubeSupportHeight</span>
<a name="376"><span class="lineNum">     376 </span><span class="lineCov">         58 :                                                                                                   +      fgkSSDModuleCoolingBlockToSensor</span></a>
<span class="lineNum">     377 </span><span class="lineCov">        116 :                                                                                                   -      fgkMountingBlockSupportDownHeight}; </span>
<span class="lineNum">     378 </span><span class="lineCov">        232 : const Double_t AliITSv11GeometrySSD::fgkMountingBlockSupportUpHeight[2] = {fgkSSDLay5RadiusMax</span>
<span class="lineNum">     379 </span><span class="lineCov">         58 :                                                                                                     -  fgkSSDMountingBlockHeight[1]</span>
<span class="lineNum">     380 </span><span class="lineCov">         58 :                                                                                                     +  0.5*fgkCoolingTubeSupportHeight</span>
<span class="lineNum">     381 </span><span class="lineCov">         58 :                                                                                                     +  fgkSSDModuleCoolingBlockToSensor</span>
<span class="lineNum">     382 </span><span class="lineCov">         58 :                                                                                                         -  fgkMountingBlockSupportRadius[0],</span>
<span class="lineNum">     383 </span><span class="lineCov">         58 :                                                                                                            fgkSSDLay6RadiusMax</span>
<span class="lineNum">     384 </span><span class="lineCov">         58 :                                                                                                     -  fgkSSDMountingBlockHeight[1]</span>
<span class="lineNum">     385 </span><span class="lineCov">         58 :                                                                                                     +  0.5*fgkCoolingTubeSupportHeight</span>
<a name="386"><span class="lineNum">     386 </span><span class="lineCov">         58 :                                                                                                     +  fgkSSDModuleCoolingBlockToSensor</span></a>
<a name="387"><span class="lineNum">     387 </span><span class="lineCov">        116 :                                                                                                         -  fgkMountingBlockSupportRadius[1]};</span></a>
<a name="388"><span class="lineNum">     388 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkLadderSupportHeight = 10.0*fgkmm; // To be verified</span></a>
<span class="lineNum">     389 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkLadderSupportRingLay5Position = 451.35*fgkmm;</span>
<span class="lineNum">     390 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkLadderSupportRingLay6Position = 510.00*fgkmm;</span>
<span class="lineNum">     391 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="392"><span class="lineNum">     392 </span>            : // SSD End Cap Cover Plate Parameters (lengths are in mm and angles in degrees)</a>
<a name="393"><span class="lineNum">     393 </span>            : /////////////////////////////////////////////////////////////////////////////////</a>
<a name="394"><span class="lineNum">     394 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapCoverPlateSmallHoleRadius = 1.25*fgkmm;</span></a>
<a name="395"><span class="lineNum">     395 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapCoverPlateBigHoleRadius = 2.45*fgkmm;</span></a>
<span class="lineNum">     396 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapCoverPlateThickness = 0.5*fgkmm;</span>
<a name="397"><span class="lineNum">     397 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapCoverPlateSmallHoleSeparation[3] =</a>
<span class="lineNum">     398 </span><span class="lineCov">        116 :                                                                                                 {16.5*fgkmm,22.0*fgkmm,7.*fgkmm};</span>
<a name="399"><span class="lineNum">     399 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapCoverPlateLength[6] = </a>
<span class="lineNum">     400 </span><span class="lineCov">        116 :                                   {7.*fgkmm,55.*fgkmm,8.0*fgkmm,53.*fgkmm,61.0*fgkmm,25.5*fgkmm};</span>
<a name="401"><span class="lineNum">     401 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapCoverPlateWidth[3] = </a>
<a name="402"><span class="lineNum">     402 </span><span class="lineCov">        116 :                                                                                            {68.5*fgkmm,75.5*fgkmm,6.5*fgkmm};</span></a>
<a name="403"><span class="lineNum">     403 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapCoverPlateScrewRadiusMin = 0.750*fgkmm;  </span></a>
<a name="404"><span class="lineNum">     404 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapCoverPlateScrewRadiusMax = 2.*fgkmm;  </span></a>
<a name="405"><span class="lineNum">     405 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapCoverPlateClipLength = 10.4*fgkmm;</span></a>
<a name="406"><span class="lineNum">     406 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapCoverPlateClipWidth = 6.0*fgkmm;</span></a>
<span class="lineNum">     407 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapCoverPlateDownClipLength = 5.7*fgkmm;</span>
<span class="lineNum">     408 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapCoverPlateDownClipWidth = 5.0*fgkmm;</span>
<span class="lineNum">     409 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="410"><span class="lineNum">     410 </span>            : // SSD End Cap Kapton Foil Parameters (lengths are in mm and angles in degrees)</a>
<a name="411"><span class="lineNum">     411 </span>            : /////////////////////////////////////////////////////////////////////////////////</a>
<a name="412"><span class="lineNum">     412 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapKaptonFoilThickness = 0.4*fgkmm;</span></a>
<span class="lineNum">     413 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapKaptonFoilLength = 68.0*fgkmm;</span>
<span class="lineNum">     414 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapKaptonFoilWidth = 75.0*fgkmm;</span>
<span class="lineNum">     415 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="416"><span class="lineNum">     416 </span>            : // SSD End Cap Cooling Tube Parameters (lengths are in mm and angles in degrees)</a>
<span class="lineNum">     417 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="418"><span class="lineNum">     418 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapCoolingTubeAxialRadius[2] =</a>
<a name="419"><span class="lineNum">     419 </span><span class="lineCov">        116 :                                                                                                                 {10.5*fgkmm,9.25*fgkmm}; </span></a>
<span class="lineNum">     420 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapCoolingTubeRadiusMin = 1.3*fgkmm; </span>
<span class="lineNum">     421 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapCoolingTubeRadiusMax = 1.5*fgkmm; </span>
<a name="422"><span class="lineNum">     422 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapCoolingTubeAngle[5] =</a>
<span class="lineNum">     423 </span>            :                                                                                                         {182.3,177.9,84.4,70.0,35.0}; 
<a name="424"><span class="lineNum">     424 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapCoolingTubeLength[5] = </a>
<span class="lineNum">     425 </span><span class="lineCov">        232 :                                                                         {49.5*fgkmm,41.7*fgkmm,47.6*fgkmm,5.0*fgkmm};</span>
<span class="lineNum">     426 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapCoolingTubeToCoverSide = 13.0*fgkmm;</span>
<span class="lineNum">     427 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="428"><span class="lineNum">     428 </span>            : // SSD End Cap Cover Side Parameters (lengths are in mm and angles in degrees)</a>
<span class="lineNum">     429 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="430"><span class="lineNum">     430 </span><span class="lineCov">        348 : const Double_t AliITSv11GeometrySSD::fgkEndCapSideCoverLength[5] = {3.5*fgkmm,</span></a>
<span class="lineNum">     431 </span><span class="lineCov">        290 :                                                                           6.5*fgkmm,75.0*fgkmm,8.0*fgkmm,2.0*fgkmm};</span>
<span class="lineNum">     432 </span><span class="lineCov">        464 : const Double_t AliITSv11GeometrySSD::fgkEndCapSideCoverWidth[7] = {30.9*fgkmm,</span>
<a name="433"><span class="lineNum">     433 </span><span class="lineCov">        174 :                                                                           47.5*fgkmm,12.6*fgkmm,5.6*fgkmm,</span></a>
<span class="lineNum">     434 </span><span class="lineCov">        232 :                                                                           20.0*fgkmm,7.0*fgkmm,5.9*fgkmm};</span>
<span class="lineNum">     435 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapSideCoverThickness = 0.4*fgkmm; </span>
<span class="lineNum">     436 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="437"><span class="lineNum">     437 </span>            : // SSD End Cap Cards Parameters (lengths are in mm and angles in degrees)</a>
<span class="lineNum">     438 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="439"><span class="lineNum">     439 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapCardElectBoardBackLength[3] = </a>
<span class="lineNum">     440 </span><span class="lineCov">        232 :                                                                                                            {62.0*fgkmm,21.87*fgkmm};</span>
<a name="441"><span class="lineNum">     441 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapCardElectBoardBackWidth[2] = </a>
<span class="lineNum">     442 </span><span class="lineCov">        116 :                                                                                                             {47.0*fgkmm,0.35*fgkmm};</span>
<a name="443"><span class="lineNum">     443 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapCardElectBoardBackThickness = </a>
<a name="444"><span class="lineNum">     444 </span><span class="lineCov">        116 :                                                                                                                                           1.0*fgkmm;</span></a>
<span class="lineNum">     445 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapCardElectBoardLength = 61.8*fgkmm;</span>
<a name="446"><span class="lineNum">     446 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapCardElectBoardLayerWidth[2] =</a>
<span class="lineNum">     447 </span><span class="lineCov">        116 :                                                                                                            {43.5*fgkmm, 0.70*fgkmm};</span>
<a name="448"><span class="lineNum">     448 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapCardElectBoardLayerThickness = </a>
<span class="lineNum">     449 </span><span class="lineCov">        116 :                                                                                                                                          0.15*fgkmm;</span>
<a name="450"><span class="lineNum">     450 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapCardJMDConnectorThickness = </a>
<span class="lineNum">     451 </span><span class="lineCov">        116 :                                                                                                                                          19.0*fgkmm;</span>
<a name="452"><span class="lineNum">     452 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapCardJMDConnectorLength[2] = </a>
<span class="lineNum">     453 </span><span class="lineCov">        116 :                                                                                                                  {4.80*fgkmm,1.1*fgkmm};</span>
<a name="454"><span class="lineNum">     454 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapCardJMDConnectorWidth[2] =</a>
<span class="lineNum">     455 </span><span class="lineCov">        116 :                                                                                                                  {3.3*fgkmm,1.10*fgkmm};</span>
<a name="456"><span class="lineNum">     456 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapCardJMDConnectorToLayer = </a>
<span class="lineNum">     457 </span><span class="lineCov">        116 :                                                                                                                                           2.1*fgkmm;</span>
<a name="458"><span class="lineNum">     458 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapCardCableConnectorLength[3] =</a>
<span class="lineNum">     459 </span><span class="lineCov">        116 :                                                                                                 {5.2*fgkmm,3.5*fgkmm,1.2*fgkmm}; </span>
<a name="460"><span class="lineNum">     460 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapCardCableConnectorWidth[2] =</a>
<span class="lineNum">     461 </span><span class="lineCov">        116 :                                                                                                                  {1.9*fgkmm,0.15*fgkmm}; </span>
<a name="462"><span class="lineNum">     462 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapCardCableConnectorThickness = </a>
<span class="lineNum">     463 </span><span class="lineCov">        116 :                                                                                                                                            19*fgkmm; </span>
<a name="464"><span class="lineNum">     464 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapCardCableConnectorDistance = </a>
<span class="lineNum">     465 </span><span class="lineCov">        116 :                                                                                                                                           1.0*fgkmm;</span>
<a name="466"><span class="lineNum">     466 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapCardCableConnectorToLayer = </a>
<span class="lineNum">     467 </span><span class="lineCov">        116 :                                                                                                                                           3.6*fgkmm;</span>
<a name="468"><span class="lineNum">     468 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapStripConnectionLength = </a>
<span class="lineNum">     469 </span><span class="lineCov">        116 :                                                                                                                                          61.0*fgkmm; </span>
<a name="470"><span class="lineNum">     470 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapStripConnectionThickness =</a>
<a name="471"><span class="lineNum">     471 </span><span class="lineCov">        116 :                                                                                                                                          5.97*fgkmm; </span></a>
<span class="lineNum">     472 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapStripConnectionWidth = 3.0*fgkmm; </span>
<span class="lineNum">     473 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapInterfaceCardBLength[7] = 
<a name="474"><span class="lineNum">     474 </span><span class="lineCov">        348 :                                                                                                 {3.1*fgkmm,68.0*fgkmm,3.6*fgkmm,</span></a>
<span class="lineNum">     475 </span><span class="lineCov">        290 :                                                                           1.9*fgkmm,2.5*fgkmm,14.2*fgkmm,1.5*fgkmm};</span>
<a name="476"><span class="lineNum">     476 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapInterfaceCardBWidth[5] = </a>
<span class="lineNum">     477 </span><span class="lineCov">        116 :                                                   {17.0*fgkmm,10.0*fgkmm,5.9*fgkmm,6.4*fgkmm,3.9*fgkmm};</span>
<a name="478"><span class="lineNum">     478 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapInterfaceCardBThickness = </a>
<span class="lineNum">     479 </span><span class="lineCov">        116 :                                                                                                                                           1.0*fgkmm; </span>
<a name="480"><span class="lineNum">     480 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapInterfaceElectBoardCardBThickness </a>
<span class="lineNum">     481 </span><span class="lineCov">        116 :                                                                                                                                    = 0.15*fgkmm; </span>
<a name="482"><span class="lineNum">     482 </span>            : const Double_t AliITSv11GeometrySSD::fgkEndCapInterfaceCardBJMDConnectorSeparation = </a>
<a name="483"><span class="lineNum">     483 </span><span class="lineCov">        116 :                                                                                                                                          20.0*fgkmm;</span></a>
<a name="484"><span class="lineNum">     484 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapStiffenerLength = 68.0*fgkmm;</span></a>
<a name="485"><span class="lineNum">     485 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapStiffenerWidth = 5.0*fgkmm;</span></a>
<a name="486"><span class="lineNum">     486 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapStiffenerThickness = 5.0*fgkmm;</span></a>
<span class="lineNum">     487 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapEffectiveCableRadiusMin = 1.25*fgkmm; // To Be Checked</span>
<span class="lineNum">     488 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapEffectiveCableRadiusMax = 1.575*fgkmm; // To Be Checked</span>
<span class="lineNum">     489 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="490"><span class="lineNum">     490 </span>            : // SSD End Cap SupportLayer5/6 Side Parameters (lengths are in mm and angles in degrees)</a>
<a name="491"><span class="lineNum">     491 </span>            : /////////////////////////////////////////////////////////////////////////////////</a>
<a name="492"><span class="lineNum">     492 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapSupportLength[2] = {70.424*fgkmm,72.919*fgkmm};</span></a>
<a name="493"><span class="lineNum">     493 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapSupportMiddleRadius[2] = {377.0*fgkmm,437.0*fgkmm};</span></a>
<a name="494"><span class="lineNum">     494 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapSupportLowRadius[2] = {375.0*fgkmm,435.0*fgkmm};</span></a>
<a name="495"><span class="lineNum">     495 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapSupportHighWidth = 20.0*fgkmm;</span></a>
<a name="496"><span class="lineNum">     496 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapSupportLowWidth[2] = {3.0*fgkmm,3.0*fgkmm};</span></a>
<a name="497"><span class="lineNum">     497 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapSupportCenterLay5ITSPosition = 624.9*fgkmm;</span></a>
<a name="498"><span class="lineNum">     498 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapSupportCenterLay5Position = 2.5*fgkmm;</span></a>
<span class="lineNum">     499 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapSupportCenterLay6ITSPosition = 635.0*fgkmm;</span>
<span class="lineNum">     500 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkEndCapSupportCenterLay6Position = 2.5*fgkmm;</span>
<span class="lineNum">     501 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="502"><span class="lineNum">     502 </span>            : // SSD Cone Parameters (lengths are in mm and angles in degrees)</a>
<span class="lineNum">     503 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="504"><span class="lineNum">     504 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDLowerPConeRadius = 296.5*fgkmm;</span></a>
<a name="505"><span class="lineNum">     505 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDPConeAngle = 39.0; </a>
<a name="506"><span class="lineNum">     506 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDPConeZLength[2] = {168.0*fgkmm,153.0*fgkmm};</span></a>
<a name="507"><span class="lineNum">     507 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDPConeLittleHoleRadius = 317.5*fgkmm;</span></a>
<a name="508"><span class="lineNum">     508 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDPConeLittleHoleLength = 20.*fgkmm;   </span></a>
<a name="509"><span class="lineNum">     509 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDConeMiddleRadius = 350.*fgkmm;</span></a>
<a name="510"><span class="lineNum">     510 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDPConeMiddleLength = 30.*fgkmm;</span></a>
<a name="511"><span class="lineNum">     511 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDPConeMiddleWidth = 40.*fgkmm;</span></a>
<a name="512"><span class="lineNum">     512 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDPConeUpRadius = 400.*fgkmm;</span></a>
<a name="513"><span class="lineNum">     513 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDPConeUpMaxRadius = 459.*fgkmm;</span></a>
<span class="lineNum">     514 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDPConeUpMiddleRadius = 472.5*fgkmm;</span>
<a name="515"><span class="lineNum">     515 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDPConeDownRadius = 282.0*fgkmm;</span></a>
<a name="516"><span class="lineNum">     516 </span>            : const Double_t AliITSv11GeometrySSD::fgkSSDPConeTrapezoidAngle = 42.0;</a>
<a name="517"><span class="lineNum">     517 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDPConeTrapezoidBasis = 200.0*fgkmm;</span></a>
<a name="518"><span class="lineNum">     518 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDPConeExternalRadius = 492.5*fgkmm;</span></a>
<a name="519"><span class="lineNum">     519 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDPConeRadiusWidth = 16.75*fgkmm;</span></a>
<a name="520"><span class="lineNum">     520 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDPConeLength = 168.0*fgkmm;</span></a>
<a name="521"><span class="lineNum">     521 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDCentralSupportLength = 1020.*fgkmm;</span></a>
<a name="522"><span class="lineNum">     522 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDCentralSupportRadius = 297.5*fgkmm;  </span></a>
<a name="523"><span class="lineNum">     523 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDCentralSupportWidth = 6.28*fgkmm;</span></a>
<span class="lineNum">     524 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDCentralAL3SupportLength = 60.0*fgkmm;</span>
<span class="lineNum">     525 </span><span class="lineCov">        116 : const Double_t AliITSv11GeometrySSD::fgkSSDCentralAL3SupportWidth = 2.5*fgkSSDCentralSupportWidth;</span>
<a name="526"><span class="lineNum">     526 </span>            : </a>
<span class="lineNum">     527 </span>            : /////////////////////////////////////////////////////////////////////////////////
<a name="528"><span class="lineNum">     528 </span><span class="lineCov">        116 : ClassImp(AliITSv11GeometrySSD)</span></a>
<span class="lineNum">     529 </span>            : /////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     530 </span>            : AliITSv11GeometrySSD::AliITSv11GeometrySSD(): 
<span class="lineNum">     531 </span><span class="lineCov">          1 :   AliITSv11Geometry(),</span>
<span class="lineNum">     532 </span><span class="lineCov">          1 :   fSSDChipMedium(),</span>
<span class="lineNum">     533 </span><span class="lineCov">          1 :   fSSDChipGlueMedium(),</span>
<span class="lineNum">     534 </span><span class="lineCov">          1 :   fSSDStiffenerMedium(),</span>
<span class="lineNum">     535 </span><span class="lineCov">          1 :   fSSDStiffenerConnectorMedium(),</span>
<span class="lineNum">     536 </span><span class="lineCov">          1 :   fSSDStiffener0603CapacitorMedium(),</span>
<span class="lineNum">     537 </span><span class="lineCov">          1 :   fSSDStiffener1812CapacitorMedium(),</span>
<span class="lineNum">     538 </span><span class="lineCov">          1 :   fSSDStiffenerCapacitorCapMedium(),</span>
<span class="lineNum">     539 </span><span class="lineCov">          1 :   fSSDStiffenerHybridWireMedium(),</span>
<span class="lineNum">     540 </span><span class="lineCov">          1 :   fSSDKaptonFlexMedium(),</span>
<span class="lineNum">     541 </span><span class="lineCov">          1 :   fSSDAlTraceFlexMedium(),</span>
<span class="lineNum">     542 </span><span class="lineCov">          1 :   fSSDAlTraceLadderCableMedium(),</span>
<span class="lineNum">     543 </span><span class="lineCov">          1 :   fSSDKaptonLadderCableMedium(),</span>
<span class="lineNum">     544 </span><span class="lineCov">          1 :   fSSDKaptonChipCableMedium(),</span>
<span class="lineNum">     545 </span><span class="lineCov">          1 :   fSSDAlTraceChipCableMedium(),</span>
<span class="lineNum">     546 </span><span class="lineCov">          1 :   fSSDAlCoolBlockMedium(),</span>
<span class="lineNum">     547 </span><span class="lineCov">          1 :   fSSDSensorMedium(),</span>
<span class="lineNum">     548 </span><span class="lineCov">          1 :   fSSDSensorSupportMedium(),</span>
<span class="lineNum">     549 </span><span class="lineCov">          1 :   fSSDCarbonFiberMedium(),</span>
<span class="lineNum">     550 </span><span class="lineCov">          1 :   fSSDTubeHolderMedium(),</span>
<span class="lineNum">     551 </span><span class="lineCov">          1 :   fSSDCoolingTubeWater(),</span>
<span class="lineNum">     552 </span><span class="lineCov">          1 :   fSSDCoolingTubePhynox(),</span>
<span class="lineNum">     553 </span><span class="lineCov">          1 :   fSSDSupportRingAl(),</span>
<span class="lineNum">     554 </span><span class="lineCov">          1 :   fSSDMountingBlockMedium(),</span>
<span class="lineNum">     555 </span><span class="lineCov">          1 :   fSSDRohaCellCone(),</span>
<span class="lineNum">     556 </span><span class="lineCov">          1 :   fSSDAir(),</span>
<span class="lineNum">     557 </span><span class="lineCov">          1 :   fSSDCopper(),</span>
<span class="lineNum">     558 </span><span class="lineCov">          1 :   fSSDSn(),</span>
<span class="lineNum">     559 </span><span class="lineCov">          1 :   fCreateMaterials(kFALSE),</span>
<span class="lineNum">     560 </span><span class="lineCov">          1 :   fTransformationMatrices(kFALSE),</span>
<span class="lineNum">     561 </span><span class="lineCov">          1 :   fBasicObjects(kFALSE),</span>
<span class="lineNum">     562 </span><span class="lineCov">          1 :   fcarbonfiberjunction(),</span>
<span class="lineNum">     563 </span><span class="lineCov">          1 :   fcoolingtubesupport(),</span>
<span class="lineNum">     564 </span><span class="lineCov">          1 :   fhybridmatrix(),</span>
<span class="lineNum">     565 </span><span class="lineCov">          1 :   fssdcoolingblocksystem(),</span>
<span class="lineNum">     566 </span><span class="lineCov">          1 :   fcoolingblocksystematrix(),</span>
<span class="lineNum">     567 </span><span class="lineCov">          1 :   fssdstiffenerflex(),</span>
<span class="lineNum">     568 </span><span class="lineCov">          1 :   fssdendflex(),</span>
<span class="lineNum">     569 </span><span class="lineCov">          1 :   fcoolingtube(0),</span>
<span class="lineNum">     570 </span><span class="lineCov">          1 :   fendladdercoolingtubesupportmatrix(),</span>
<span class="lineNum">     571 </span><span class="lineCov">          1 :   fendladdermountingblock(),</span>
<span class="lineNum">     572 </span><span class="lineCov">          1 :   fendladdermountingblockclip(),</span>
<span class="lineNum">     573 </span><span class="lineCov">          1 :   fSSDSensor5(),</span>
<span class="lineNum">     574 </span><span class="lineCov">          1 :   fSSDSensor6(),</span>
<span class="lineNum">     575 </span><span class="lineCov">          1 :   fSSDLayer5(), </span>
<span class="lineNum">     576 </span><span class="lineCov">          1 :   fSSDLayer6(),</span>
<span class="lineNum">     577 </span><span class="lineCov">          1 :   fMotherVol(),</span>
<span class="lineNum">     578 </span><span class="lineCov">          1 :   fLay5LadderSupportRing(),</span>
<span class="lineNum">     579 </span><span class="lineCov">          1 :   fLay6LadderSupportRing(),</span>
<span class="lineNum">     580 </span><span class="lineCov">          1 :   fgkEndCapSupportSystem(),</span>
<span class="lineNum">     581 </span><span class="lineCov">          1 :   fSSDCone(),</span>
<span class="lineNum">     582 </span><span class="lineCov">          1 :   fColorCarbonFiber(4),</span>
<span class="lineNum">     583 </span><span class="lineCov">          1 :   fColorRyton(5),</span>
<span class="lineNum">     584 </span><span class="lineCov">          1 :   fColorPhynox(14),</span>
<span class="lineNum">     585 </span><span class="lineCov">          1 :   fColorSilicon(3),</span>
<span class="lineNum">     586 </span><span class="lineCov">          1 :   fColorAl(38),</span>
<span class="lineNum">     587 </span><span class="lineCov">          1 :   fColorNiSn(40),</span>
<span class="lineNum">     588 </span><span class="lineCov">          1 :   fColorKapton(6),</span>
<span class="lineNum">     589 </span><span class="lineCov">          1 :   fColorPolyhamide(5),</span>
<span class="lineNum">     590 </span><span class="lineCov">          1 :   fColorStiffener(9),</span>
<span class="lineNum">     591 </span><span class="lineCov">          1 :   fColorEpoxy(30),</span>
<span class="lineNum">     592 </span><span class="lineCov">          1 :   fColorWater(7),</span>
<span class="lineNum">     593 </span><span class="lineCov">          1 :   fColorG10(41)</span>
<span class="lineNum">     594 </span><span class="lineCov">          5 : {</span>
<span class="lineNum">     595 </span>            :   ////////////////////////
<span class="lineNum">     596 </span>            :   // Standard constructor
<span class="lineNum">     597 </span>            :   ////////////////////////
<span class="lineNum">     598 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkendladdermountingblocknumber; i++){</span>
<span class="lineNum">     599 </span><span class="lineCov">          2 :     fendladdermountingblockcombitrans[i] = NULL;</span>
<span class="lineNum">     600 </span>            :   }
<span class="lineNum">     601 </span><span class="lineCov">          6 :   for (Int_t i=0; i &lt; fgkcarbonfibersupportnumber; i++) {</span>
<span class="lineNum">     602 </span><span class="lineCov">          2 :     fcarbonfibersupport[i] = 0;</span>
<span class="lineNum">     603 </span><span class="lineCov">          2 :     fcarbonfibersupportmatrix[i] = 0;</span>
<span class="lineNum">     604 </span>            :   }
<span class="lineNum">     605 </span><span class="lineCov">          8 :   for (Int_t i=0; i &lt; fgkcarbonfiberjunctionumber; i++) {</span>
<span class="lineNum">     606 </span><span class="lineCov">          3 :     fcarbonfiberjunctionmatrix[i] = 0;</span>
<span class="lineNum">     607 </span>            :   }
<span class="lineNum">     608 </span><span class="lineCov">          6 :   for (Int_t i=0; i &lt; fgkcarbonfiberlowersupportnumber; i++) {</span>
<span class="lineNum">     609 </span><span class="lineCov">          2 :     fcarbonfiberlowersupport[i] = 0;</span>
<span class="lineNum">     610 </span><span class="lineCov">          2 :     fcarbonfiberlowersupportrans[0] = 0;</span>
<span class="lineNum">     611 </span>            :   }
<span class="lineNum">     612 </span><span class="lineCov">          6 :   for (Int_t i=0; i &lt; fgkvolumekind; i++) {</span>
<span class="lineNum">     613 </span><span class="lineCov">          2 :     fssdsensorsupport[i] = 0;</span>
<span class="lineNum">     614 </span>            :   }
<span class="lineNum">     615 </span><span class="lineCov">          8 :   for (Int_t i=0; i &lt; fgkssdsensorsupportnumber; i++) {</span>
<span class="lineNum">     616 </span><span class="lineCov">          3 :     fssdsensorsupportmatrix[i] = 0;</span>
<span class="lineNum">     617 </span>            :   }
<span class="lineNum">     618 </span><span class="lineCov">          6 :   for (Int_t i=0; i &lt; fgkcoolingtubesupportnumber; i++) {</span>
<span class="lineNum">     619 </span><span class="lineCov">          2 :     fcoolingtubesupportmatrix[i] = 0;</span>
<span class="lineNum">     620 </span>            :   }
<span class="lineNum">     621 </span><span class="lineCov">          8 :   for (Int_t i=0; i &lt; fgkhybridcompnumber; i++) {</span>
<span class="lineNum">     622 </span><span class="lineCov">          3 :     fssdhybridcomponent[i] = 0;</span>
<span class="lineNum">     623 </span>            :   }
<span class="lineNum">     624 </span><span class="lineCov">         10 :   for (Int_t i=0; i &lt; fgkcoolingblocknumber; i++) {</span>
<span class="lineNum">     625 </span><span class="lineCov">          4 :     fcoolingblockmatrix[i] = 0;</span>
<span class="lineNum">     626 </span>            :   }
<span class="lineNum">     627 </span><span class="lineCov">          6 :   for (Int_t i=0; i &lt; fgkflexnumber; i++) {</span>
<span class="lineNum">     628 </span><span class="lineCov">          2 :     fstiffenerflexmatrix[i] = 0;</span>
<span class="lineNum">     629 </span><span class="lineCov">          2 :     fendflexmatrix[i] = 0;</span>
<span class="lineNum">     630 </span>            :   }
<span class="lineNum">     631 </span><span class="lineCov">          6 :   for (Int_t i=0; i &lt; fgkendladdercoolingtubenumber; i++) {</span>
<span class="lineNum">     632 </span><span class="lineCov">          2 :     fendladdercoolingtube[i] = 0;</span>
<span class="lineNum">     633 </span><span class="lineCov">         12 :     for (Int_t j = 0; j &lt; 2; j++) </span>
<span class="lineNum">     634 </span><span class="lineCov">          4 :       fendladdercoolingtubematrix[i][j] = 0;</span>
<span class="lineNum">     635 </span>            :   }
<span class="lineNum">     636 </span><span class="lineCov">          6 :   for (Int_t i=0; i &lt; fgkendlabbercarbonfiberjunctionumber; i++) {</span>
<span class="lineNum">     637 </span><span class="lineCov">          2 :     fendladdercarbonfiberjunction[i] = 0;</span>
<span class="lineNum">     638 </span>            :   }
<span class="lineNum">     639 </span><span class="lineCov">          8 :   for (Int_t i=0; i &lt; fgkendladdercarbonfiberjunctionmatrixnumber; i++) {</span>
<span class="lineNum">     640 </span><span class="lineCov">          3 :     fendladdercarbonfiberjunctionmatrix[i] = 0;</span>
<span class="lineNum">     641 </span>            :   }
<span class="lineNum">     642 </span><span class="lineCov">          6 :   for (Int_t i=0; i &lt; fgkendladdercarbonfibermatrixnumber; i++) {</span>
<span class="lineNum">     643 </span><span class="lineCov">          2 :     fendladdercarbonfibermatrix[i] = 0;</span>
<span class="lineNum">     644 </span>            :   }
<span class="lineNum">     645 </span><span class="lineCov">          6 :   for (Int_t i=0; i &lt; fgkendladdermountingblocknumber; i++) {</span>
<span class="lineNum">     646 </span><span class="lineCov">          2 :     fendladdermountingblockclipmatrix[i] = 0;</span>
<span class="lineNum">     647 </span>            :   }
<span class="lineNum">     648 </span><span class="lineCov">          8 :   for (Int_t i = 0; i &lt; fgkendladderlowersuppnumber+1; i++) {</span>
<span class="lineNum">     649 </span><span class="lineCov">          3 :     fendladderlowersupptrans[i] = 0;</span>
<span class="lineNum">     650 </span>            :   }
<span class="lineNum">     651 </span><span class="lineCov">          6 :   for (Int_t i = 0; i &lt; fgkladdercablesnumber; i++) {</span>
<span class="lineNum">     652 </span><span class="lineCov">          2 :     fladdercablematrix[i] = 0;</span>
<span class="lineNum">     653 </span>            :   }
<span class="lineNum">     654 </span><span class="lineCov">          6 :   for (Int_t i = 0; i &lt; fgkladdersegmentnumber; i++) {</span>
<span class="lineNum">     655 </span><span class="lineCov">          2 :     fladdersegment[i] = 0;</span>
<span class="lineNum">     656 </span>            :   }
<span class="lineNum">     657 </span><span class="lineCov">          6 :   for (Int_t i = 0; i &lt; fgkladdernumber; i++) {</span>
<span class="lineNum">     658 </span><span class="lineCov">          2 :     fladder[i] = 0;</span>
<span class="lineNum">     659 </span><span class="lineCov">          2 :     fladdermatrix[i] = 0;</span>
<span class="lineNum">     660 </span><span class="lineCov">          2 :     fssdsensormatrix[i] = 0;</span>
<span class="lineNum">     661 </span><span class="lineCov">          2 :     flayermatrix[i] = 0;</span>
<span class="lineNum">     662 </span>            :   }
<span class="lineNum">     663 </span><span class="lineCov">          6 :   for (Int_t i = 0; i &lt; 2; i++) {</span>
<span class="lineNum">     664 </span><span class="lineCov">          2 :     fLay5LadderSupport[i] = 0;</span>
<span class="lineNum">     665 </span><span class="lineCov">          2 :     fLay6LadderSupport[i] = 0;</span>
<span class="lineNum">     666 </span><span class="lineCov">          2 :     fcoolingtubematrix[i] = NULL;</span>
<span class="lineNum">     667 </span><span class="lineCov">          2 :     fendladdersegment[i] = NULL;</span>
<span class="lineNum">     668 </span><span class="lineCov">          2 :     fendladdersegmentmatrix[i] = NULL;</span>
<span class="lineNum">     669 </span>            :   }
<span class="lineNum">     670 </span><span class="lineCov">          2 : }</span>
<a name="671"><span class="lineNum">     671 </span>            : </a>
<span class="lineNum">     672 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     673 </span>            : void AliITSv11GeometrySSD::CreateTransformationMatrices(){
<span class="lineNum">     674 </span>            :   ///////////////////////////////////////////////////////////////////////  
<span class="lineNum">     675 </span>            :   // Method generating the trasformation matrix for the whole SSD Geometry   
<span class="lineNum">     676 </span>            :   ///////////////////////////////////////////////////////////////////////  
<span class="lineNum">     677 </span>            :   // Setting some variables for Carbon Fiber Supportmatrix creation
<span class="lineNum">     678 </span>            :   //////////////////////////////////////////////////////////////////////
<span class="lineNum">     679 </span><span class="lineCov">          2 :   Double_t carbonfibersupportxaxisEdgeproj = fgkCarbonFiberSupportEdgeLength</span>
<span class="lineNum">     680 </span><span class="lineCov">          1 :                                                                                    * CosD(fgkCarbonFiberJunctionAngle[0]);</span>
<span class="lineNum">     681 </span><span class="lineCov">          1 :   Double_t symmetryplaneposition = (fgkCarbonFiberSupportYAxisLength</span>
<span class="lineNum">     682 </span><span class="lineCov">          1 :                                                                  +      fgkCarbonFiberSupportTopEdgeDist[0]</span>
<span class="lineNum">     683 </span><span class="lineCov">          1 :                                                                  +      fgkCarbonFiberSupportWidth);</span>
<span class="lineNum">     684 </span>            :   Double_t carbonfibersupportheight = carbonfibersupportxaxisEdgeproj
<span class="lineNum">     685 </span><span class="lineCov">          1 :                                                                         * TanD(fgkCarbonFiberJunctionAngle[0]);</span>
<span class="lineNum">     686 </span><span class="lineCov">          1 :   TGeoRotation* carbonfiberot[3];</span>
<span class="lineNum">     687 </span><span class="lineCov">         11 :   for(Int_t i=0; i&lt;3; i++) carbonfiberot[i] = new TGeoRotation();</span>
<span class="lineNum">     688 </span><span class="lineCov">          1 :   carbonfiberot[0]-&gt;SetAngles(0.0,180.0,0.0);</span>
<span class="lineNum">     689 </span><span class="lineCov">          1 :   carbonfiberot[1]-&gt;SetAngles(90.,-fgkCarbonFiberTriangleAngle,-90.);</span>
<span class="lineNum">     690 </span><span class="lineCov">          1 :   carbonfiberot[2]-&gt;SetRotation((*carbonfiberot[1])*(*carbonfiberot[0]));</span>
<span class="lineNum">     691 </span><span class="lineCov">          1 :   Double_t transvector[3] = {fgkCarbonFiberTriangleLength</span>
<span class="lineNum">     692 </span><span class="lineCov">          1 :                                                   *  CosD(fgkCarbonFiberTriangleAngle),0.,</span>
<span class="lineNum">     693 </span><span class="lineCov">          1 :                                                   -  fgkCarbonFiberTriangleLength</span>
<span class="lineNum">     694 </span><span class="lineCov">          1 :                                                   *      SinD(fgkCarbonFiberTriangleAngle)};</span>
<span class="lineNum">     695 </span>            :   ///////////////////////////////////////////
<span class="lineNum">     696 </span>            :   //Setting Local Translations and Rotations: 
<span class="lineNum">     697 </span>            :   ///////////////////////////////////////////
<span class="lineNum">     698 </span><span class="lineCov">          1 :   TGeoCombiTrans* localcarbonfibersupportmatrix[3]; </span>
<span class="lineNum">     699 </span><span class="lineCov">          3 :   localcarbonfibersupportmatrix[0] = new TGeoCombiTrans(0.0,0.0,</span>
<span class="lineNum">     700 </span><span class="lineCov">          1 :                                                                          0.5*carbonfibersupportheight,NULL);    </span>
<span class="lineNum">     701 </span><span class="lineCov">          3 :   localcarbonfibersupportmatrix[1] = new TGeoCombiTrans(transvector[0],</span>
<span class="lineNum">     702 </span><span class="lineCov">          1 :                                                                          2.*symmetryplaneposition+transvector[1],</span>
<span class="lineNum">     703 </span><span class="lineCov">          1 :                                                                          transvector[2], carbonfiberot[2]);</span>
<span class="lineNum">     704 </span><span class="lineCov">          2 :   localcarbonfibersupportmatrix[2] = new TGeoCombiTrans(*carbonfiberot[1]);</span>
<span class="lineNum">     705 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">     706 </span>            :   // Carbon Fiber Support Transformations
<span class="lineNum">     707 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">     708 </span>            :   const Int_t kcarbonfibersupportmatrixnumber[2] = {2,3};
<span class="lineNum">     709 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkcarbonfibersupportnumber; i++){ </span>
<span class="lineNum">     710 </span><span class="lineCov">          4 :                 fcarbonfibersupportmatrix[i] = new TGeoHMatrix();</span>
<span class="lineNum">     711 </span><span class="lineCov">         14 :                 for(Int_t j=0; j&lt;kcarbonfibersupportmatrixnumber[i]; j++)</span>
<span class="lineNum">     712 </span><span class="lineCov">          5 :                         fcarbonfibersupportmatrix[i]-&gt;MultiplyLeft(localcarbonfibersupportmatrix[i==0?2*j:j]);</span>
<span class="lineNum">     713 </span>            :   }             
<span class="lineNum">     714 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">     715 </span>            :   // Carbon Fiber Junction Transformation
<span class="lineNum">     716 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">     717 </span>            :   const Int_t kcarbonfiberjunctionmatrixnumber = 2;
<span class="lineNum">     718 </span><span class="lineCov">          1 :   TGeoCombiTrans** localcarbonfiberjunctionmatrix[fgkcarbonfiberjunctionumber];</span>
<span class="lineNum">     719 </span><span class="lineCov">          1 :   TGeoRotation** localcarbonfiberjunctionrot[fgkcarbonfiberjunctionumber];</span>
<span class="lineNum">     720 </span><span class="lineCov">          1 :   TGeoTranslation** localcarbonfiberjunctiontrans[fgkcarbonfiberjunctionumber];</span>
<span class="lineNum">     721 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;fgkcarbonfiberjunctionumber; i++){ </span>
<span class="lineNum">     722 </span><span class="lineCov">          3 :         localcarbonfiberjunctionmatrix[i] = </span>
<span class="lineNum">     723 </span><span class="lineCov">          3 :                                                 new TGeoCombiTrans*[kcarbonfiberjunctionmatrixnumber];</span>
<span class="lineNum">     724 </span><span class="lineCov">          3 :         localcarbonfiberjunctionrot[i] = </span>
<span class="lineNum">     725 </span><span class="lineCov">          3 :                                                 new TGeoRotation*[kcarbonfiberjunctionmatrixnumber];</span>
<span class="lineNum">     726 </span><span class="lineCov">          3 :         localcarbonfiberjunctiontrans[i] = </span>
<span class="lineNum">     727 </span><span class="lineCov">          3 :                                                 new TGeoTranslation*[kcarbonfiberjunctionmatrixnumber];</span>
<span class="lineNum">     728 </span>            :   }
<span class="lineNum">     729 </span>            :   ///////////////////////
<span class="lineNum">     730 </span>            :   // Setting Translations
<span class="lineNum">     731 </span>            :   ///////////////////////
<span class="lineNum">     732 </span><span class="lineCov">          2 :   localcarbonfiberjunctiontrans[0][0] = new TGeoTranslation(0.,0.,0.);</span>
<span class="lineNum">     733 </span><span class="lineCov">          1 :   localcarbonfiberjunctiontrans[1][0] = </span>
<span class="lineNum">     734 </span><span class="lineCov">          1 :                                  new TGeoTranslation(fgkCarbonFiberTriangleLength,0.0,0.0);</span>
<span class="lineNum">     735 </span><span class="lineCov">          1 :   localcarbonfiberjunctiontrans[2][0] = </span>
<span class="lineNum">     736 </span><span class="lineCov">          2 :                                  new TGeoTranslation(fgkCarbonFiberTriangleLength</span>
<span class="lineNum">     737 </span><span class="lineCov">          2 :                                  * TMath::Cos(fgkCarbonFiberTriangleAngle*TMath::DegToRad()),</span>
<span class="lineNum">     738 </span><span class="lineCov">          1 :                                  fgkCarbonFiberTriangleLength</span>
<span class="lineNum">     739 </span><span class="lineCov">          2 :                                  * TMath::Sin(fgkCarbonFiberTriangleAngle*TMath::DegToRad()),0.0);</span>
<span class="lineNum">     740 </span><span class="lineCov">          1 :   localcarbonfiberjunctiontrans[0][1] = </span>
<span class="lineNum">     741 </span><span class="lineCov">          1 :                                  new TGeoTranslation(0.0,0.5*fgkCarbonFiberJunctionWidth,0.0);</span>
<span class="lineNum">     742 </span><span class="lineCov">          1 :   localcarbonfiberjunctiontrans[1][1] = </span>
<span class="lineNum">     743 </span><span class="lineCov">          1 :                                  new TGeoTranslation(*localcarbonfiberjunctiontrans[0][1]);</span>
<span class="lineNum">     744 </span><span class="lineCov">          1 :   localcarbonfiberjunctiontrans[2][1] = </span>
<span class="lineNum">     745 </span><span class="lineCov">          1 :                                  new TGeoTranslation(*localcarbonfiberjunctiontrans[0][1]);</span>
<span class="lineNum">     746 </span>            :   ////////////////////
<span class="lineNum">     747 </span>            :   // Setting Rotations
<span class="lineNum">     748 </span>            :   ////////////////////
<span class="lineNum">     749 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;fgkcarbonfiberjunctionumber; i++)</span>
<span class="lineNum">     750 </span><span class="lineCov">         18 :                 for(Int_t j=0; j&lt;kcarbonfiberjunctionmatrixnumber; j++)</span>
<span class="lineNum">     751 </span><span class="lineCov">         12 :                         localcarbonfiberjunctionrot[i][j] = new TGeoRotation();</span>
<span class="lineNum">     752 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;fgkcarbonfiberjunctionumber; i++)</span>
<span class="lineNum">     753 </span><span class="lineCov">          3 :         localcarbonfiberjunctionrot[i][0]-&gt;SetAngles(120.*i,0.0,0.0);</span>
<span class="lineNum">     754 </span><span class="lineCov">          1 :   localcarbonfiberjunctionrot[0][1]-&gt;SetAngles(0.0,90.0,0.0);</span>
<span class="lineNum">     755 </span><span class="lineCov">          1 :   localcarbonfiberjunctionrot[1][1]-&gt;SetRotation(*localcarbonfiberjunctionrot[0][1]);</span>
<span class="lineNum">     756 </span><span class="lineCov">          1 :   localcarbonfiberjunctionrot[2][1]-&gt;SetRotation(*localcarbonfiberjunctionrot[0][1]);</span>
<span class="lineNum">     757 </span>            :   ////////////////////////////////////////
<span class="lineNum">     758 </span>            :   // Setting Carbon Fiber Junction matrix 
<span class="lineNum">     759 </span>            :   ////////////////////////////////////////
<span class="lineNum">     760 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;fgkcarbonfiberjunctionumber; i++){</span>
<span class="lineNum">     761 </span><span class="lineCov">          6 :                 fcarbonfiberjunctionmatrix[i] = new TGeoHMatrix();</span>
<span class="lineNum">     762 </span><span class="lineCov">         18 :                 for(Int_t j=0; j&lt;kcarbonfiberjunctionmatrixnumber; j++){</span>
<span class="lineNum">     763 </span><span class="lineCov">          6 :                         localcarbonfiberjunctionmatrix[i][j] = </span>
<span class="lineNum">     764 </span><span class="lineCov">         12 :                         new TGeoCombiTrans(*localcarbonfiberjunctiontrans[i][j],</span>
<span class="lineNum">     765 </span><span class="lineCov">          6 :                                                            *localcarbonfiberjunctionrot[i][j]);</span>
<span class="lineNum">     766 </span><span class="lineCov">          6 :                     fcarbonfiberjunctionmatrix[i]-&gt;MultiplyLeft(localcarbonfiberjunctionmatrix[i][j]);</span>
<span class="lineNum">     767 </span>            :          }
<span class="lineNum">     768 </span>            :   }
<span class="lineNum">     769 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">     770 </span>            :   // Carbon Fiber Lower Support Transformations
<span class="lineNum">     771 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">     772 </span><span class="lineCov">          1 :   TGeoTranslation* localcarbonfiberlowersupportrans[2];</span>
<span class="lineNum">     773 </span><span class="lineCov">          3 :   localcarbonfiberlowersupportrans[0] = new TGeoTranslation(0.0,</span>
<span class="lineNum">     774 </span><span class="lineCov">          1 :                                                                          fgkCarbonFiberLowerSupportVolumePosition[1]</span>
<span class="lineNum">     775 </span><span class="lineCov">          1 :                                                                 +    fgkCarbonFiberLowerSupportVolumePosition[0],</span>
<span class="lineNum">     776 </span>            :                                                                          0.0);
<span class="lineNum">     777 </span><span class="lineCov">          3 :   localcarbonfiberlowersupportrans[1] = new TGeoTranslation(0.0,</span>
<span class="lineNum">     778 </span><span class="lineCov">          1 :                                                                          fgkCarbonFiberJunctionWidth</span>
<span class="lineNum">     779 </span><span class="lineCov">          1 :                                                                 -    fgkCarbonFiberLowerSupportWidth</span>
<span class="lineNum">     780 </span><span class="lineCov">          1 :                                                                 -    fgkCarbonFiberLowerSupportVolumePosition[0]</span>
<span class="lineNum">     781 </span><span class="lineCov">          1 :                                                                 -    fgkCarbonFiberLowerSupportVolumePosition[1],</span>
<span class="lineNum">     782 </span><span class="lineCov">          1 :                                                                 -    0.5*fgkCarbonFiberLowerSupportHeight);</span>
<span class="lineNum">     783 </span><span class="lineCov">          1 :    localcarbonfiberlowersupportrans[0]-&gt;Add(localcarbonfiberlowersupportrans[1]);</span>
<span class="lineNum">     784 </span><span class="lineCov">          1 :    fcarbonfiberlowersupportrans[0] = </span>
<span class="lineNum">     785 </span><span class="lineCov">          1 :                                                 new TGeoTranslation(*localcarbonfiberlowersupportrans[0]);</span>
<span class="lineNum">     786 </span><span class="lineCov">          1 :    fcarbonfiberlowersupportrans[1] = </span>
<span class="lineNum">     787 </span><span class="lineCov">          1 :                                                 new TGeoTranslation(*localcarbonfiberlowersupportrans[1]);</span>
<span class="lineNum">     788 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">     789 </span>            :   // SSD Sensor Support Transformations
<span class="lineNum">     790 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">     791 </span>            :   const Int_t kssdsensorsupportmatrixnumber = 3;
<span class="lineNum">     792 </span><span class="lineCov">          1 :   TGeoCombiTrans** localssdsensorsupportmatrix[fgkssdsensorsupportnumber];</span>
<span class="lineNum">     793 </span><span class="lineCov">          1 :   TGeoRotation** localssdsensorsupportrot[fgkssdsensorsupportnumber];</span>
<span class="lineNum">     794 </span><span class="lineCov">          1 :   TGeoTranslation** localssdsensorsupportrans[fgkssdsensorsupportnumber];</span>
<span class="lineNum">     795 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;fgkssdsensorsupportnumber; i++){ </span>
<span class="lineNum">     796 </span><span class="lineCov">          3 :         localssdsensorsupportmatrix[i] = </span>
<span class="lineNum">     797 </span><span class="lineCov">          3 :                                                 new TGeoCombiTrans*[kssdsensorsupportmatrixnumber];</span>
<span class="lineNum">     798 </span><span class="lineCov">          3 :         localssdsensorsupportrot[i] = </span>
<span class="lineNum">     799 </span><span class="lineCov">          3 :                                                 new TGeoRotation*[kssdsensorsupportmatrixnumber];</span>
<span class="lineNum">     800 </span><span class="lineCov">          3 :         localssdsensorsupportrans[i] = </span>
<span class="lineNum">     801 </span><span class="lineCov">          3 :                                                 new TGeoTranslation*[kssdsensorsupportmatrixnumber];</span>
<span class="lineNum">     802 </span>            :   }
<span class="lineNum">     803 </span>            :   ///////////////////////
<span class="lineNum">     804 </span>            :   // Setting Translations
<span class="lineNum">     805 </span>            :   ///////////////////////
<span class="lineNum">     806 </span><span class="lineCov">          3 :   localssdsensorsupportrans[0][0] = new TGeoTranslation(0.0,</span>
<span class="lineNum">     807 </span><span class="lineCov">          1 :                                                                           0.5*fgkSSDSensorSideSupportWidth,</span>
<span class="lineNum">     808 </span>            :                                                                           0.0);
<span class="lineNum">     809 </span><span class="lineCov">          1 :   localssdsensorsupportrans[1][0] = </span>
<span class="lineNum">     810 </span><span class="lineCov">          1 :                                                  new TGeoTranslation(*localssdsensorsupportrans[0][0]);</span>
<span class="lineNum">     811 </span><span class="lineCov">          1 :   localssdsensorsupportrans[2][0] = </span>
<span class="lineNum">     812 </span><span class="lineCov">          1 :                                                  new TGeoTranslation(*localssdsensorsupportrans[0][0]);</span>
<span class="lineNum">     813 </span><span class="lineCov">          1 :   localssdsensorsupportrans[0][1] = </span>
<span class="lineNum">     814 </span><span class="lineCov">          2 :                                                  new TGeoTranslation(-0.5*fgkSSDSensorSideSupportWidth,</span>
<span class="lineNum">     815 </span><span class="lineCov">          1 :                                                                                 0.5*fgkSSDSensorSideSupportThickness[0],</span>
<span class="lineNum">     816 </span>            :                                                                                 0.0);
<span class="lineNum">     817 </span><span class="lineCov">          1 :   localssdsensorsupportrans[1][1] = </span>
<span class="lineNum">     818 </span><span class="lineCov">          2 :                                                  new TGeoTranslation(0.5*fgkSSDSensorSideSupportWidth,</span>
<span class="lineNum">     819 </span><span class="lineCov">          1 :                                                                         -   0.5*fgkSSDSensorSideSupportThickness[0]</span>
<span class="lineNum">     820 </span><span class="lineCov">          1 :                                                                     -   fgkSSDModuleSensorSupportDistance,</span>
<span class="lineNum">     821 </span>            :                                                                                 0.0);
<span class="lineNum">     822 </span><span class="lineCov">          1 :   localssdsensorsupportrans[2][1] = </span>
<span class="lineNum">     823 </span><span class="lineCov">          2 :                                                  new TGeoTranslation(0.5*fgkSSDSensorCenterSupportThickness[0]</span>
<span class="lineNum">     824 </span><span class="lineCov">          1 :                                                                         -    fgkSSDSensorCenterSupportPosition,</span>
<span class="lineNum">     825 </span><span class="lineCov">          1 :                                                                                  0.5*fgkSSDSensorCenterSupportWidth</span>
<span class="lineNum">     826 </span><span class="lineCov">          1 :                                                                         -    0.5*fgkSSDModuleSensorSupportDistance,</span>
<span class="lineNum">     827 </span>            :                                                                                  fgkSSDSensorCenterSupportThickness[0]);
<span class="lineNum">     828 </span><span class="lineCov">          1 :   localssdsensorsupportrans[0][2] = </span>
<span class="lineNum">     829 </span><span class="lineCov">          2 :                                                  new TGeoTranslation(fgkCarbonFiberTriangleLength</span>
<span class="lineNum">     830 </span><span class="lineCov">          1 :                                                                         +    fgkCarbonFiberJunctionToSensorSupport,</span>
<span class="lineNum">     831 </span><span class="lineCov">          1 :                                                                                  fgkCarbonFiberJunctionWidth</span>
<span class="lineNum">     832 </span><span class="lineCov">          2 :                                                                     -    0.5*(fgkCarbonFiberLowerSupportWidth</span>
<span class="lineNum">     833 </span><span class="lineCov">          1 :                                                                         +    fgkSSDSensorCenterSupportLength</span>
<span class="lineNum">     834 </span><span class="lineCov">          1 :                                                                         -    fgkSSDSensorCenterSupportThickness[0])</span>
<span class="lineNum">     835 </span><span class="lineCov">          1 :                                                                         -    fgkSSDSensorCenterSupportPosition,</span>
<span class="lineNum">     836 </span>            :                                                                              0.0);
<span class="lineNum">     837 </span><span class="lineCov">          1 :   localssdsensorsupportrans[1][2] = </span>
<span class="lineNum">     838 </span><span class="lineCov">          1 :                                                 new TGeoTranslation(*localssdsensorsupportrans[0][2]);</span>
<span class="lineNum">     839 </span><span class="lineCov">          1 :   localssdsensorsupportrans[2][2] = </span>
<span class="lineNum">     840 </span><span class="lineCov">          1 :                                                 new TGeoTranslation(*localssdsensorsupportrans[0][2]);</span>
<span class="lineNum">     841 </span>            :   ////////////////////
<span class="lineNum">     842 </span>            :   // Setting Rotations
<span class="lineNum">     843 </span>            :   ////////////////////
<span class="lineNum">     844 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;fgkssdsensorsupportnumber; i++)</span>
<span class="lineNum">     845 </span><span class="lineCov">         24 :                 for(Int_t j=0; j&lt;kssdsensorsupportmatrixnumber; j++)</span>
<span class="lineNum">     846 </span><span class="lineCov">         18 :                         localssdsensorsupportrot[i][j] = new TGeoRotation();</span>
<span class="lineNum">     847 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;fgkssdsensorsupportnumber; i++){</span>
<span class="lineNum">     848 </span><span class="lineCov">          3 :         localssdsensorsupportrot[i][0]-&gt;SetAngles(0.0,90.0,0.0);</span>
<span class="lineNum">     849 </span><span class="lineCov">          3 :         localssdsensorsupportrot[i][2]-&gt;SetAngles(-90.0,0.0,0.0);</span>
<span class="lineNum">     850 </span>            :   }
<span class="lineNum">     851 </span><span class="lineCov">          1 :   localssdsensorsupportrot[0][1]-&gt;SetAngles(0.0,90.0,-90.0);</span>
<span class="lineNum">     852 </span><span class="lineCov">          1 :   localssdsensorsupportrot[1][1]-&gt;SetAngles(180.0,90.0,-90.0);</span>
<span class="lineNum">     853 </span><span class="lineCov">          1 :   localssdsensorsupportrot[2][1]-&gt;SetAngles(270.0,90.0,-90.0);</span>
<span class="lineNum">     854 </span>            :   ////////////////////////////////////////
<span class="lineNum">     855 </span>            :   // SSD Sensor Support matrix 
<span class="lineNum">     856 </span>            :   ////////////////////////////////////////
<span class="lineNum">     857 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;fgkssdsensorsupportnumber; i++){</span>
<span class="lineNum">     858 </span><span class="lineCov">          6 :                 fssdsensorsupportmatrix[i] = new TGeoHMatrix();</span>
<span class="lineNum">     859 </span><span class="lineCov">         24 :                 for(Int_t j=0; j&lt;kssdsensorsupportmatrixnumber; j++){</span>
<span class="lineNum">     860 </span><span class="lineCov">          9 :                         localssdsensorsupportmatrix[i][j] = </span>
<span class="lineNum">     861 </span><span class="lineCov">         18 :                         new TGeoCombiTrans(*localssdsensorsupportrans[i][j],</span>
<span class="lineNum">     862 </span><span class="lineCov">          9 :                                                            *localssdsensorsupportrot[i][j]);</span>
<span class="lineNum">     863 </span><span class="lineCov">          9 :                     fssdsensorsupportmatrix[i]-&gt;MultiplyLeft(localssdsensorsupportmatrix[i][j]);</span>
<span class="lineNum">     864 </span>            :          }
<span class="lineNum">     865 </span>            :   }
<span class="lineNum">     866 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">     867 </span>            :   // SSD Cooling Tube Support Transformations
<span class="lineNum">     868 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">     869 </span>            :   const Int_t kcoolingtubesupportmatrixnumber = 2;
<span class="lineNum">     870 </span><span class="lineCov">          1 :   TGeoCombiTrans* localcoolingtubesupportmatrix[kcoolingtubesupportmatrixnumber];</span>
<span class="lineNum">     871 </span><span class="lineCov">          1 :   TGeoTranslation* localcoolingtubesupportrans[kcoolingtubesupportmatrixnumber];</span>
<span class="lineNum">     872 </span><span class="lineCov">          1 :   TGeoRotation* localcoolingtubesupportrot[kcoolingtubesupportmatrixnumber];</span>
<span class="lineNum">     873 </span><span class="lineCov">          2 :   Double_t phi = TMath::ASin(0.5*fgkCoolingTubeSupportHeight</span>
<span class="lineNum">     874 </span><span class="lineCov">          1 :                                                                                                         /fgkCoolingTubeSupportRmax);</span>
<span class="lineNum">     875 </span><span class="lineCov">          1 :   localcoolingtubesupportrans[0] = </span>
<span class="lineNum">     876 </span><span class="lineCov">          2 :                         new TGeoTranslation(2.*fgkCoolingTubeSupportRmax*TMath::Cos(phi)</span>
<span class="lineNum">     877 </span><span class="lineCov">          2 :                                                 +  2.*(fgkCoolingTubeSupportLength</span>
<span class="lineNum">     878 </span><span class="lineCov">          1 :                                                 -  fgkCoolingTubeSupportRmax*(1.+TMath::Cos(phi)))</span>
<span class="lineNum">     879 </span><span class="lineCov">          1 :                                                 +  fgkCarbonFiberTriangleLength</span>
<span class="lineNum">     880 </span><span class="lineCov">          1 :                                                 -  2.0*fgkCarbonFiberJunctionLength,0.0,0.0);</span>
<span class="lineNum">     881 </span><span class="lineCov">          1 :   localcoolingtubesupportrans[1] = </span>
<span class="lineNum">     882 </span><span class="lineCov">          2 :                         new TGeoTranslation(fgkCarbonFiberJunctionLength</span>
<span class="lineNum">     883 </span><span class="lineCov">          1 :                                         - (fgkCoolingTubeSupportLength-fgkCoolingTubeSupportRmax),</span>
<span class="lineNum">     884 </span><span class="lineCov">          2 :                                         - (2.0*fgkSSDSensorLength-fgkSSDSensorOverlap)+</span>
<span class="lineNum">     885 </span><span class="lineCov">          2 :                                                    fgkSSDModuleStiffenerPosition[1]+fgkSSDStiffenerWidth</span>
<span class="lineNum">     886 </span><span class="lineCov">          1 :                     +  0.5*fgkSSDFlexHoleLength+2.*fgkCarbonFiberJunctionWidth</span>
<span class="lineNum">     887 </span><span class="lineCov">          2 :                     -  0.5*(fgkCarbonFiberLowerSupportWidth</span>
<span class="lineNum">     888 </span><span class="lineCov">          1 :                                         +          fgkSSDSensorCenterSupportLength</span>
<span class="lineNum">     889 </span><span class="lineCov">          1 :                     -      fgkSSDSensorCenterSupportThickness[0])</span>
<span class="lineNum">     890 </span><span class="lineCov">          1 :                                         +  0.5*fgkSSDSensorLength,</span>
<span class="lineNum">     891 </span><span class="lineCov">          1 :                                         -  0.5*fgkCoolingTubeSupportHeight);  </span>
<span class="lineNum">     892 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;kcoolingtubesupportmatrixnumber; i++)     </span>
<span class="lineNum">     893 </span><span class="lineCov">          4 :   localcoolingtubesupportrot[i] = new TGeoRotation();</span>
<span class="lineNum">     894 </span><span class="lineCov">          1 :   localcoolingtubesupportrot[0]-&gt;SetAngles(180.0,0.0,0.0);</span>
<span class="lineNum">     895 </span><span class="lineCov">          1 :   localcoolingtubesupportrot[1]-&gt;SetAngles(0.0,90.0,0.0);</span>
<span class="lineNum">     896 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;kcoolingtubesupportmatrixnumber; i++)</span>
<span class="lineNum">     897 </span><span class="lineCov">          2 :         localcoolingtubesupportmatrix[i] = </span>
<span class="lineNum">     898 </span><span class="lineCov">          4 :                 new TGeoCombiTrans(*localcoolingtubesupportrans[i],</span>
<span class="lineNum">     899 </span><span class="lineCov">          2 :                                                    *localcoolingtubesupportrot[i]);</span>
<span class="lineNum">     900 </span><span class="lineCov">          2 :   fcoolingtubesupportmatrix[0] = new TGeoHMatrix(*localcoolingtubesupportmatrix[1]);</span>
<span class="lineNum">     901 </span><span class="lineCov">          4 :   fcoolingtubesupportmatrix[1] = new TGeoHMatrix((*localcoolingtubesupportmatrix[1])*</span>
<span class="lineNum">     902 </span><span class="lineCov">          1 :                                                                 (*localcoolingtubesupportmatrix[0]));</span>
<span class="lineNum">     903 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">     904 </span>            :   // End Ladder SSD Cooling Tube Support Transformations
<span class="lineNum">     905 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">     906 </span><span class="lineCov">          1 :   TGeoTranslation** localendladdercooltubetrans[2];</span>
<span class="lineNum">     907 </span><span class="lineCov">          1 :   localendladdercooltubetrans[0] = new TGeoTranslation*[4];</span>
<span class="lineNum">     908 </span><span class="lineCov">          1 :   localendladdercooltubetrans[1] = new TGeoTranslation*[2];</span>
<span class="lineNum">     909 </span><span class="lineCov">         14 :   for(Int_t i=0; i&lt;4; i++) localendladdercooltubetrans[0][i] = new TGeoTranslation();</span>
<span class="lineNum">     910 </span><span class="lineCov">          2 :   localendladdercooltubetrans[0][0]-&gt;SetTranslation(fgkCarbonFiberJunctionLength</span>
<span class="lineNum">     911 </span><span class="lineCov">          2 :                                                                                         -          (fgkCoolingTubeSupportLength</span>
<span class="lineNum">     912 </span><span class="lineCov">          1 :                                                                                         -               fgkCoolingTubeSupportRmax),</span>
<span class="lineNum">     913 </span><span class="lineCov">          1 :                                                                                                         fgkEndLadderMountingBlockPosition[0]</span>
<span class="lineNum">     914 </span><span class="lineCov">          1 :                                                                                         -               fgkendladdercoolingsupportdistance[0]</span>
<span class="lineNum">     915 </span><span class="lineCov">          1 :                                                                                         +   0.5*fgkCoolingTubeSupportWidth,</span>
<span class="lineNum">     916 </span><span class="lineCov">          1 :                                                                                         -   0.5*fgkCoolingTubeSupportHeight);</span>
<span class="lineNum">     917 </span><span class="lineCov">          2 :   localendladdercooltubetrans[0][1]-&gt;SetTranslation(fgkCarbonFiberJunctionLength</span>
<span class="lineNum">     918 </span><span class="lineCov">          2 :                                                                                         -          (fgkCoolingTubeSupportLength</span>
<span class="lineNum">     919 </span><span class="lineCov">          1 :                                                                                         -               fgkCoolingTubeSupportRmax),</span>
<span class="lineNum">     920 </span><span class="lineCov">          1 :                                                                                                         fgkEndLadderMountingBlockPosition[0]</span>
<span class="lineNum">     921 </span><span class="lineCov">          1 :                                                                                         +               fgkendladdercoolingsupportdistance[1]</span>
<span class="lineNum">     922 </span><span class="lineCov">          1 :                                                                                         +   0.5*fgkCoolingTubeSupportWidth,</span>
<span class="lineNum">     923 </span><span class="lineCov">          1 :                                                                                         -   0.5*fgkCoolingTubeSupportHeight);</span>
<span class="lineNum">     924 </span><span class="lineCov">          3 :   localendladdercooltubetrans[0][2]-&gt;SetTranslation(2*(fgkCoolingTubeSupportLength</span>
<span class="lineNum">     925 </span><span class="lineCov">          1 :                                                                                         -       fgkCoolingTubeSupportRmax)</span>
<span class="lineNum">     926 </span><span class="lineCov">          1 :                                                                                         +               fgkCarbonFiberTriangleLength</span>
<span class="lineNum">     927 </span><span class="lineCov">          1 :                                                                                         -   2.0*fgkCarbonFiberJunctionLength,</span>
<span class="lineNum">     928 </span>            :                                                                                                 0.0,
<span class="lineNum">     929 </span>            :                                                                                                 0.0);
<span class="lineNum">     930 </span><span class="lineCov">          2 :   localendladdercooltubetrans[0][3]-&gt;SetTranslation(0.0,</span>
<span class="lineNum">     931 </span><span class="lineCov">          1 :                                                                                                         fgkendladdercoolingsupportdistance[0]</span>
<span class="lineNum">     932 </span><span class="lineCov">          1 :                                                                                         +               fgkendladdercoolingsupportdistance[1],</span>
<span class="lineNum">     933 </span>            :                                                                                                         0.0);
<span class="lineNum">     934 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;2; i++) localendladdercooltubetrans[1][i] = new TGeoTranslation();</span>
<span class="lineNum">     935 </span><span class="lineCov">          2 :   localendladdercooltubetrans[1][0]-&gt;SetTranslation(fgkCoolingTubeSupportRmax</span>
<span class="lineNum">     936 </span><span class="lineCov">          1 :                                                                                         +               fgkCarbonFiberJunctionLength</span>
<span class="lineNum">     937 </span><span class="lineCov">          1 :                                                                                         -               fgkCoolingTubeSupportLength,</span>
<span class="lineNum">     938 </span><span class="lineCov">          1 :                                                                                                         fgkEndLadderCarbonFiberLowerJunctionLength[1]</span>
<span class="lineNum">     939 </span><span class="lineCov">          1 :                                                                                         -       0.5*fgkCoolingTubeSupportWidth</span>
<span class="lineNum">     940 </span><span class="lineCov">          1 :                                                                                                    -fgkendladdercoolingsupportdistance[2],</span>
<span class="lineNum">     941 </span><span class="lineCov">          1 :                                                                                         -   0.5*fgkCoolingTubeSupportHeight);</span>
<span class="lineNum">     942 </span><span class="lineCov">          2 :   localendladdercooltubetrans[1][1]-&gt;SetTranslation(fgkCarbonFiberTriangleLength</span>
<span class="lineNum">     943 </span><span class="lineCov">          1 :                                                                                         +               fgkCoolingTubeSupportLength</span>
<span class="lineNum">     944 </span><span class="lineCov">          1 :                                                                                         -               fgkCoolingTubeSupportRmax</span>
<span class="lineNum">     945 </span><span class="lineCov">          1 :                                                                                         -               fgkCarbonFiberJunctionLength,</span>
<span class="lineNum">     946 </span><span class="lineCov">          1 :                                                                                                         fgkEndLadderCarbonFiberLowerJunctionLength[1]</span>
<span class="lineNum">     947 </span><span class="lineCov">          1 :                                                                                         -       0.5*fgkCoolingTubeSupportWidth</span>
<span class="lineNum">     948 </span><span class="lineCov">          1 :                                                                                         -               fgkendladdercoolingsupportdistance[2],</span>
<span class="lineNum">     949 </span><span class="lineCov">          1 :                                                                                         -   0.5*fgkCoolingTubeSupportHeight);</span>
<span class="lineNum">     950 </span><span class="lineCov">          1 :   fendladdercoolingtubesupportmatrix = new TGeoHMatrix**[kcoolingtubesupportmatrixnumber];</span>
<span class="lineNum">     951 </span><span class="lineCov">          1 :   fendladdercoolingtubesupportmatrix[0] = new TGeoHMatrix*[4];</span>
<span class="lineNum">     952 </span><span class="lineCov">          1 :   fendladdercoolingtubesupportmatrix[1] = new TGeoHMatrix*[2];</span>
<span class="lineNum">     953 </span><span class="lineCov">          4 :   fendladdercoolingtubesupportmatrix[0][0] = new TGeoHMatrix((*localendladdercooltubetrans[0][0])*</span>
<span class="lineNum">     954 </span><span class="lineCov">          1 :   (*localcoolingtubesupportrot[1]));</span>
<span class="lineNum">     955 </span><span class="lineCov">          4 :   fendladdercoolingtubesupportmatrix[0][1] = new TGeoHMatrix((*localendladdercooltubetrans[0][1])*</span>
<span class="lineNum">     956 </span><span class="lineCov">          1 :   (*localcoolingtubesupportrot[1]));</span>
<span class="lineNum">     957 </span><span class="lineCov">          2 :   fendladdercoolingtubesupportmatrix[0][2] = new TGeoHMatrix(*fendladdercoolingtubesupportmatrix[0][0]);</span>
<span class="lineNum">     958 </span><span class="lineCov">          1 :   fendladdercoolingtubesupportmatrix[0][2]-&gt;Multiply(localcoolingtubesupportrot[0]);</span>
<span class="lineNum">     959 </span><span class="lineCov">          1 :   fendladdercoolingtubesupportmatrix[0][2]-&gt;MultiplyLeft(localendladdercooltubetrans[0][2]);</span>
<span class="lineNum">     960 </span><span class="lineCov">          2 :   fendladdercoolingtubesupportmatrix[0][3] = new TGeoHMatrix(*fendladdercoolingtubesupportmatrix[0][2]);</span>
<span class="lineNum">     961 </span><span class="lineCov">          1 :   fendladdercoolingtubesupportmatrix[0][3]-&gt;MultiplyLeft(localendladdercooltubetrans[0][3]);</span>
<span class="lineNum">     962 </span>            : 
<span class="lineNum">     963 </span><span class="lineCov">          1 :   fendladdercoolingtubesupportmatrix[1][0] =    </span>
<span class="lineNum">     964 </span><span class="lineCov">          2 :                                                         new TGeoHMatrix((*localendladdercooltubetrans[1][0])</span>
<span class="lineNum">     965 </span><span class="lineCov">          1 :                                                                                    *(*localcoolingtubesupportrot[1]));</span>
<span class="lineNum">     966 </span><span class="lineCov">          2 :   fendladdercoolingtubesupportmatrix[1][1] = new TGeoHMatrix(*localcoolingtubesupportrot[1]);</span>
<span class="lineNum">     967 </span><span class="lineCov">          1 :   fendladdercoolingtubesupportmatrix[1][1]-&gt;Multiply(localcoolingtubesupportrot[0]);</span>
<span class="lineNum">     968 </span><span class="lineCov">          1 :   fendladdercoolingtubesupportmatrix[1][1]-&gt;MultiplyLeft(localendladdercooltubetrans[1][1]);</span>
<span class="lineNum">     969 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">     970 </span>            :   // SSD Cooling Tube Transformations
<span class="lineNum">     971 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">     972 </span><span class="lineCov">          1 :   TGeoRotation* localcoolingtuberot = new TGeoRotation();       </span>
<span class="lineNum">     973 </span><span class="lineCov">          1 :   localcoolingtuberot-&gt;SetAngles(0.,90.,0.);</span>
<span class="lineNum">     974 </span><span class="lineCov">          1 :   TGeoTranslation* localcoolingtubetrans[2];</span>
<span class="lineNum">     975 </span><span class="lineCov">          1 :   TVector3* localcoolingtubevect[2];</span>
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span><span class="lineCov">          4 :   localcoolingtubevect[0] = new TVector3(-0.5*(fgkCoolingTubeSeparation</span>
<span class="lineNum">     978 </span><span class="lineCov">          1 :                                                   -fgkCarbonFiberTriangleLength),</span>
<span class="lineNum">     979 </span><span class="lineCov">          1 :                                             fgkCarbonFiberJunctionWidth         // Y-coord is local Z, from sensor translation </span>
<span class="lineNum">     980 </span><span class="lineCov">          1 :                                             - fgkCarbonFiberLowerSupportWidth </span>
<span class="lineNum">     981 </span><span class="lineCov">          1 :                                             - fgkLowerSupportToSensorZ ,</span>
<span class="lineNum">     982 </span><span class="lineCov">          1 :                                                   -  0.5*fgkCoolingTubeSupportHeight);  </span>
<span class="lineNum">     983 </span><span class="lineCov">          3 :   localcoolingtubevect[1] = new TVector3( -localcoolingtubevect[0]-&gt;X()+fgkCarbonFiberTriangleLength,</span>
<span class="lineNum">     984 </span><span class="lineCov">          1 :                                               localcoolingtubevect[0]-&gt;Y(),</span>
<span class="lineNum">     985 </span><span class="lineCov">          1 :                                               localcoolingtubevect[0]-&gt;Z());</span>
<span class="lineNum">     986 </span><span class="lineCov">          6 :   for(Int_t j=0; j&lt;2; j++){</span>
<span class="lineNum">     987 </span><span class="lineCov">          2 :     localcoolingtubetrans[j] = </span>
<span class="lineNum">     988 </span><span class="lineCov">          4 :         new TGeoTranslation(localcoolingtubevect[j]-&gt;X(),</span>
<span class="lineNum">     989 </span><span class="lineCov">          2 :                             localcoolingtubevect[j]-&gt;Y(),</span>
<span class="lineNum">     990 </span><span class="lineCov">          2 :                             localcoolingtubevect[j]-&gt;Z());</span>
<span class="lineNum">     991 </span><span class="lineCov">          6 :      fcoolingtubematrix[j] = new TGeoHMatrix((*localcoolingtubetrans[j])</span>
<span class="lineNum">     992 </span><span class="lineCov">          2 :                                              *(*localcoolingtuberot));</span>
<span class="lineNum">     993 </span>            :   }
<span class="lineNum">     994 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">     995 </span>            :   // SSD End Ladder Cooling Tube Transformations
<span class="lineNum">     996 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">     997 </span><span class="lineCov">          1 :   TGeoRotation* localendlladdercoolingtuberot = new TGeoRotation();     </span>
<span class="lineNum">     998 </span><span class="lineCov">          1 :   localendlladdercoolingtuberot-&gt;SetAngles(0.,90.,0.);</span>
<span class="lineNum">     999 </span><span class="lineCov">          1 :   TGeoTranslation** localendlladdercoolingtubetrans[2];</span>
<span class="lineNum">    1000 </span><span class="lineCov">          1 :   localendlladdercoolingtubetrans[0] = new TGeoTranslation*[2];</span>
<span class="lineNum">    1001 </span><span class="lineCov">          1 :   localendlladdercoolingtubetrans[1] = new TGeoTranslation*[2];</span>
<span class="lineNum">    1002 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;2; i++)   </span>
<span class="lineNum">    1003 </span><span class="lineCov">         12 :         for(Int_t j=0; j&lt;2; j++)     </span>
<span class="lineNum">    1004 </span><span class="lineCov">          8 :                 localendlladdercoolingtubetrans[i][j] = new TGeoTranslation();</span>
<span class="lineNum">    1005 </span>            : 
<span class="lineNum">    1006 </span><span class="lineCov">          1 :   Double_t sensZshift = 0.5*fgkCarbonFiberJunctionWidth - fgkCarbonFiberLowerSupportWidth - fgkLowerSupportToSensorZ;</span>
<span class="lineNum">    1007 </span><span class="lineCov">          3 :   localendlladdercoolingtubetrans[0][0]-&gt;SetTranslation(-(fgkCoolingTubeSupportLength</span>
<span class="lineNum">    1008 </span><span class="lineCov">          1 :                                                                         -        fgkCoolingTubeSupportRmax)</span>
<span class="lineNum">    1009 </span><span class="lineCov">          1 :                                                                         +        fgkCarbonFiberJunctionLength,</span>
<span class="lineNum">    1010 </span><span class="lineCov">          1 :                                                         0.5*(fgkEndLadderCarbonFiberLowerJunctionLength[0]+sensZshift),</span>
<span class="lineNum">    1011 </span><span class="lineCov">          1 :                                                                         - 0.5*fgkCoolingTubeSupportHeight);</span>
<span class="lineNum">    1012 </span><span class="lineCov">          2 :   localendlladdercoolingtubetrans[0][1]-&gt;SetTranslation((fgkCoolingTubeSupportLength</span>
<span class="lineNum">    1013 </span><span class="lineCov">          1 :                                                                         -        fgkCoolingTubeSupportRmax)</span>
<span class="lineNum">    1014 </span><span class="lineCov">          1 :                                                                         -        fgkCarbonFiberJunctionLength</span>
<span class="lineNum">    1015 </span><span class="lineCov">          1 :                                                                         +    fgkCarbonFiberTriangleLength,</span>
<span class="lineNum">    1016 </span><span class="lineCov">          1 :                                                         0.5*(fgkEndLadderCarbonFiberLowerJunctionLength[0]+sensZshift),</span>
<span class="lineNum">    1017 </span><span class="lineCov">          1 :                                                                         - 0.5*fgkCoolingTubeSupportHeight);</span>
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span><span class="lineCov">          3 :   localendlladdercoolingtubetrans[1][0]-&gt;SetTranslation(-(fgkCoolingTubeSupportLength</span>
<span class="lineNum">    1020 </span><span class="lineCov">          1 :                                                           -   fgkCoolingTubeSupportRmax)</span>
<span class="lineNum">    1021 </span><span class="lineCov">          1 :                                                         +       fgkCarbonFiberJunctionLength,</span>
<span class="lineNum">    1022 </span><span class="lineCov">          1 :                                                         0.5*(fgkEndLadderCarbonFiberLowerJunctionLength[1]-sensZshift),</span>
<span class="lineNum">    1023 </span><span class="lineCov">          1 :                                                   -             0.5*fgkCoolingTubeSupportHeight);        </span>
<span class="lineNum">    1024 </span><span class="lineCov">          2 :   localendlladdercoolingtubetrans[1][1]-&gt;SetTranslation((fgkCoolingTubeSupportLength</span>
<span class="lineNum">    1025 </span><span class="lineCov">          1 :                                                   -      fgkCoolingTubeSupportRmax)</span>
<span class="lineNum">    1026 </span><span class="lineCov">          1 :                                                   -      fgkCarbonFiberJunctionLength</span>
<span class="lineNum">    1027 </span><span class="lineCov">          1 :                                                   +    fgkCarbonFiberTriangleLength,</span>
<span class="lineNum">    1028 </span><span class="lineCov">          1 :                                                         0.5*(fgkEndLadderCarbonFiberLowerJunctionLength[1]-sensZshift),</span>
<span class="lineNum">    1029 </span><span class="lineCov">          1 :                                                   -             0.5*fgkCoolingTubeSupportHeight);        </span>
<span class="lineNum">    1030 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;2; i++)</span>
<span class="lineNum">    1031 </span><span class="lineCov">         12 :         for(Int_t j=0; j&lt;2; j++){</span>
<span class="lineNum">    1032 </span><span class="lineCov">          8 :                 fendladdercoolingtubematrix[i][j] = new TGeoHMatrix(*localendlladdercoolingtuberot);</span>
<span class="lineNum">    1033 </span><span class="lineCov">          4 :                 fendladdercoolingtubematrix[i][j]-&gt;MultiplyLeft(localendlladdercoolingtubetrans[i][j]);      </span>
<span class="lineNum">    1034 </span>            :         }
<span class="lineNum">    1035 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1036 </span>            :   // SSD Hybrid Components Transformations
<span class="lineNum">    1037 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1038 </span>            :   const Int_t khybridmatrixnumber = 3;
<span class="lineNum">    1039 </span><span class="lineCov">          1 :   TGeoTranslation* localhybridtrans[khybridmatrixnumber];</span>
<span class="lineNum">    1040 </span><span class="lineCov">          3 :   localhybridtrans[0] = new TGeoTranslation(0.5*fgkSSDStiffenerLength,</span>
<span class="lineNum">    1041 </span><span class="lineCov">          1 :                                             0.5*fgkSSDStiffenerWidth,</span>
<span class="lineNum">    1042 </span><span class="lineCov">          1 :                                             0.5*fgkSSDStiffenerHeight);</span>
<span class="lineNum">    1043 </span><span class="lineCov">          3 :   localhybridtrans[1] = new TGeoTranslation(fgkSSDModuleStiffenerPosition[0],</span>
<span class="lineNum">    1044 </span><span class="lineCov">          1 :                                             fgkSSDModuleStiffenerPosition[1],0.0);</span>
<span class="lineNum">    1045 </span>            : 
<span class="lineNum">    1046 </span><span class="lineCov">          3 :   localhybridtrans[2] = new TGeoTranslation(</span>
<span class="lineNum">    1047 </span><span class="lineCov">          1 :                       -  0.5*(fgkSSDSensorWidth-fgkCarbonFiberTriangleLength),</span>
<span class="lineNum">    1048 </span><span class="lineCov">          2 :                       -      (2.*fgkSSDSensorLength-fgkSSDSensorOverlap)+</span>
<span class="lineNum">    1049 </span><span class="lineCov">          2 :                               fgkSSDModuleStiffenerPosition[1]+fgkSSDStiffenerWidth</span>
<span class="lineNum">    1050 </span><span class="lineCov">          1 :                       +         0.5*fgkSSDFlexHoleLength+2.*fgkCarbonFiberJunctionWidth</span>
<span class="lineNum">    1051 </span><span class="lineCov">          2 :                       -         0.5*(fgkCarbonFiberLowerSupportWidth+fgkSSDSensorCenterSupportLength</span>
<span class="lineNum">    1052 </span><span class="lineCov">          1 :                       -       fgkSSDSensorCenterSupportThickness[0]),</span>
<span class="lineNum">    1053 </span><span class="lineCov">          2 :                       -      (fgkSSDModuleCoolingBlockToSensor+0.5*fgkCoolingTubeSupportHeight</span>
<span class="lineNum">    1054 </span><span class="lineCov">          1 :                       -       fgkSSDSensorHeight-fgkSSDChipCablesHeight[3]-fgkSSDChipHeight</span>
<span class="lineNum">    1055 </span><span class="lineCov">          1 :                                           -       fgkSSDModuleVerticalDisalignment)); </span>
<span class="lineNum">    1056 </span><span class="lineCov">          2 :   fhybridmatrix = new TGeoHMatrix();</span>
<span class="lineNum">    1057 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;khybridmatrixnumber; i++) fhybridmatrix-&gt;MultiplyLeft(localhybridtrans[i]);</span>
<span class="lineNum">    1058 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1059 </span>            :   // SSD Cooling Block Transformations
<span class="lineNum">    1060 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1061 </span><span class="lineCov">          2 :   TGeoTranslation localcoolingblocktrans (fcoolingtubematrix[0]-&gt;GetTranslation()[0] </span>
<span class="lineNum">    1062 </span><span class="lineCov">          1 :                                           - 0.5*fgkSSDCoolingBlockLength,</span>
<span class="lineNum">    1063 </span><span class="lineCov">          1 :                                           fhybridmatrix-&gt;GetTranslation()[1]-0.5*fgkSSDStiffenerWidth,</span>
<span class="lineNum">    1064 </span><span class="lineCov">          2 :                                           fhybridmatrix-&gt;GetTranslation()[2]+0.5*fgkSSDStiffenerHeight+</span>
<span class="lineNum">    1065 </span><span class="lineCov">          1 :                                           0.5*(fgkSSDCoolingBlockHoleCenter+fgkCoolingTubeRmax));</span>
<span class="lineNum">    1066 </span><span class="lineCov">          3 :   fcoolingblocksystematrix = new TGeoHMatrix(localcoolingblocktrans);</span>
<span class="lineNum">    1067 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1068 </span>            :   // SSD Stiffener Flex Transformations
<span class="lineNum">    1069 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1070 </span>            :   const Int_t klocalflexmatrixnumber = 4;
<span class="lineNum">    1071 </span><span class="lineCov">          1 :   TGeoCombiTrans** localflexmatrix[fgkflexnumber];</span>
<span class="lineNum">    1072 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkflexnumber; i++)    </span>
<span class="lineNum">    1073 </span><span class="lineCov">          4 :       localflexmatrix[i] = new TGeoCombiTrans*[klocalflexmatrixnumber];</span>
<span class="lineNum">    1074 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkflexnumber; i++)</span>
<span class="lineNum">    1075 </span><span class="lineCov">         20 :       for(Int_t j =0; j&lt;klocalflexmatrixnumber; j++) </span>
<span class="lineNum">    1076 </span><span class="lineCov">         24 :             localflexmatrix[i][j] = new TGeoCombiTrans();</span>
<span class="lineNum">    1077 </span><span class="lineCov">          1 :   Double_t ssdstiffenerseparation = fgkSSDSensorLength</span>
<span class="lineNum">    1078 </span><span class="lineCov">          1 :                                                                   - 2.*fgkSSDModuleStiffenerPosition[1]</span>
<span class="lineNum">    1079 </span><span class="lineCov">          1 :                                                                   -    fgkSSDStiffenerWidth;</span>
<span class="lineNum">    1080 </span><span class="lineCov">          2 :   localflexmatrix[0][0]-&gt;SetTranslation(-fgkSSDFlexLength[0]</span>
<span class="lineNum">    1081 </span><span class="lineCov">          1 :                                         +0.5*fgkSSDStiffenerLength,</span>
<span class="lineNum">    1082 </span><span class="lineCov">          1 :                                          0.5*fgkSSDStiffenerWidth,</span>
<span class="lineNum">    1083 </span><span class="lineCov">          1 :                                         -0.5*fgkSSDStiffenerHeight</span>
<span class="lineNum">    1084 </span><span class="lineCov">          1 :                                         -0.5*fgkSSDFlexHeight[0]);</span>
<span class="lineNum">    1085 </span><span class="lineCov">          2 :   localflexmatrix[1][0]-&gt;SetTranslation(-(fgkSSDStiffenerLength-fgkSSDFlexLength[0])</span>
<span class="lineNum">    1086 </span><span class="lineCov">          1 :                                         +0.5*fgkSSDStiffenerLength,ssdstiffenerseparation</span>
<span class="lineNum">    1087 </span><span class="lineCov">          1 :                                         -0.5*fgkSSDStiffenerWidth,</span>
<span class="lineNum">    1088 </span><span class="lineCov">          1 :                                         -0.5*fgkSSDStiffenerHeight</span>
<span class="lineNum">    1089 </span><span class="lineCov">          1 :                                         -0.5*fgkSSDFlexHeight[0]);</span>
<span class="lineNum">    1090 </span><span class="lineCov">          2 :   TGeoRotation* localflexrot = new TGeoRotation();</span>
<span class="lineNum">    1091 </span><span class="lineCov">          1 :   localflexrot-&gt;SetAngles(180.,0.,0.);    </span>
<span class="lineNum">    1092 </span><span class="lineCov">          1 :   localflexmatrix[1][0]-&gt;SetRotation(localflexrot);</span>
<span class="lineNum">    1093 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkflexnumber; i++)</span>
<span class="lineNum">    1094 </span><span class="lineCov">         16 :       for(Int_t j =1; j&lt;klocalflexmatrixnumber; j++) </span>
<span class="lineNum">    1095 </span><span class="lineCov">          6 :             localflexmatrix[i][j]-&gt;SetTranslation(*localhybridtrans[j-1]);</span>
<span class="lineNum">    1096 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkflexnumber; i++){</span>
<span class="lineNum">    1097 </span><span class="lineCov">          6 :       fstiffenerflexmatrix[i] = new TGeoHMatrix();</span>
<span class="lineNum">    1098 </span><span class="lineCov">         20 :       for(Int_t j =0; j&lt;klocalflexmatrixnumber; j++)   </span>
<span class="lineNum">    1099 </span><span class="lineCov">          8 :             fstiffenerflexmatrix[i]-&gt;MultiplyLeft(localflexmatrix[i][j]);</span>
<span class="lineNum">    1100 </span>            :   }
<span class="lineNum">    1101 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1102 </span>            :   // SSD End Flex Transformations
<span class="lineNum">    1103 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1104 </span><span class="lineCov">          2 :   TGeoRotation* localendflexrot = new TGeoRotation();</span>
<span class="lineNum">    1105 </span><span class="lineCov">          1 :   localendflexrot-&gt;SetAngles(0.0,90.0,0.0);</span>
<span class="lineNum">    1106 </span><span class="lineCov">          2 :   TGeoCombiTrans* localendflexmatrix = new TGeoCombiTrans();</span>
<span class="lineNum">    1107 </span><span class="lineCov">          1 :   Double_t ssdflexradiusmax = (fgkSSDFlexLength[3]-fgkSSDFlexLength[2])</span>
<span class="lineNum">    1108 </span><span class="lineCov">          2 :                             /  TMath::Tan(fgkSSDFlexAngle*TMath::DegToRad());</span>
<span class="lineNum">    1109 </span><span class="lineCov">          2 :   Double_t ssdflexboxlength = fgkSSDFlexFullLength-2.*fgkSSDFlexAngle</span>
<span class="lineNum">    1110 </span><span class="lineCov">          2 :                             * TMath::DegToRad()*ssdflexradiusmax</span>
<span class="lineNum">    1111 </span><span class="lineCov">          2 :                                                                - fgkSSDFlexLength[2]-TMath::Pi()</span>
<span class="lineNum">    1112 </span><span class="lineCov">          2 :                                                                * fgkSSDStiffenerHeight-fgkSSDFlexLength[0]</span>
<span class="lineNum">    1113 </span><span class="lineCov">          1 :                                                                                    - 0.1*fgkSSDFlexFullLength;</span>
<span class="lineNum">    1114 </span><span class="lineCov">          2 :   Double_t trans = ssdflexboxlength*CosD(2.*fgkSSDFlexAngle)</span>
<span class="lineNum">    1115 </span><span class="lineCov">          2 :                             + (ssdflexradiusmax-fgkSSDStiffenerHeight)*SinD(2.*fgkSSDFlexAngle)</span>
<span class="lineNum">    1116 </span><span class="lineCov">          1 :                             +      fgkSSDFlexLength[2];</span>
<span class="lineNum">    1117 </span><span class="lineCov">          2 :   localendflexmatrix-&gt;SetTranslation(fgkSSDFlexLength[0]-trans,</span>
<span class="lineNum">    1118 </span><span class="lineCov">          1 :                               0.5*fgkSSDFlexWidth[0],</span>
<span class="lineNum">    1119 </span><span class="lineCov">          1 :                               2.*fgkSSDStiffenerHeight</span>
<span class="lineNum">    1120 </span><span class="lineCov">          1 :                             + 0.5*fgkSSDFlexHeight[0]);      </span>
<span class="lineNum">    1121 </span><span class="lineCov">          1 :   localendflexmatrix-&gt;SetRotation(localendflexrot);</span>
<span class="lineNum">    1122 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkflexnumber; i++) </span>
<span class="lineNum">    1123 </span><span class="lineCov">          8 :       fendflexmatrix[i] = new TGeoHMatrix((*fstiffenerflexmatrix[i])*(*localendflexmatrix));</span>
<span class="lineNum">    1124 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1125 </span>            :   // End Ladder Carbon Fiber Junction
<span class="lineNum">    1126 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1127 </span><span class="lineCov">          1 :   TGeoCombiTrans** localendladdercarbonfiberjunctionmatrix[fgkendlabbercarbonfiberjunctionumber];</span>
<span class="lineNum">    1128 </span><span class="lineCov">          1 :   TGeoRotation** localendladdercarbonfiberjunctionrot[fgkendlabbercarbonfiberjunctionumber];    </span>
<span class="lineNum">    1129 </span><span class="lineCov">          1 :   TGeoTranslation** localendladdercarbonfiberjunctiontrans[fgkendlabbercarbonfiberjunctionumber];    </span>
<span class="lineNum">    1130 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkendlabbercarbonfiberjunctionumber; i++){</span>
<span class="lineNum">    1131 </span><span class="lineCov">          2 :       localendladdercarbonfiberjunctionmatrix[i] </span>
<span class="lineNum">    1132 </span><span class="lineCov">          6 :             = new TGeoCombiTrans*[fgkendladdercarbonfiberjunctionmatrixnumber];</span>
<span class="lineNum">    1133 </span><span class="lineCov">          2 :       localendladdercarbonfiberjunctionrot[i] </span>
<span class="lineNum">    1134 </span><span class="lineCov">          6 :             = new TGeoRotation*[fgkendladdercarbonfiberjunctionmatrixnumber];</span>
<span class="lineNum">    1135 </span><span class="lineCov">          2 :       localendladdercarbonfiberjunctiontrans[i] </span>
<span class="lineNum">    1136 </span><span class="lineCov">          6 :             = new TGeoTranslation*[fgkendladdercarbonfiberjunctionmatrixnumber];</span>
<span class="lineNum">    1137 </span><span class="lineCov">          2 :       fendladdercarbonfiberjunctionmatrix[i]</span>
<span class="lineNum">    1138 </span><span class="lineCov">          6 :             = new TGeoHMatrix*[fgkendladdercarbonfiberjunctionmatrixnumber];</span>
<span class="lineNum">    1139 </span>            :   }
<span class="lineNum">    1140 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkendlabbercarbonfiberjunctionumber; i++)    </span>
<span class="lineNum">    1141 </span><span class="lineCov">         16 :       for(Int_t j=0; j&lt;fgkendladdercarbonfiberjunctionmatrixnumber; j++){</span>
<span class="lineNum">    1142 </span><span class="lineCov">         18 :             localendladdercarbonfiberjunctionrot[i][j] = new TGeoRotation();</span>
<span class="lineNum">    1143 </span><span class="lineCov">         18 :             localendladdercarbonfiberjunctiontrans[i][j] = new TGeoTranslation();</span>
<span class="lineNum">    1144 </span>            :       }
<span class="lineNum">    1145 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkendlabbercarbonfiberjunctionumber; i++)     </span>
<span class="lineNum">    1146 </span><span class="lineCov">         16 :       for(Int_t j=0; j&lt;fgkendladdercarbonfiberjunctionmatrixnumber; j++)</span>
<span class="lineNum">    1147 </span><span class="lineCov">          6 :           localendladdercarbonfiberjunctionrot[i][j]-&gt;SetAngles(120.*j,0.,0.);</span>
<span class="lineNum">    1148 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkendlabbercarbonfiberjunctionumber; i++){</span>
<span class="lineNum">    1149 </span><span class="lineCov">          2 :       localendladdercarbonfiberjunctiontrans[i][1]-&gt;SetTranslation(fgkCarbonFiberTriangleLength,</span>
<span class="lineNum">    1150 </span>            :                               0.0,0.0);
<span class="lineNum">    1151 </span><span class="lineCov">          4 :       localendladdercarbonfiberjunctiontrans[i][2]-&gt;SetTranslation(fgkCarbonFiberTriangleLength</span>
<span class="lineNum">    1152 </span><span class="lineCov">          4 :                 *                     CosD(fgkCarbonFiberTriangleAngle),fgkCarbonFiberTriangleLength</span>
<span class="lineNum">    1153 </span><span class="lineCov">          4 :                 *                     SinD(fgkCarbonFiberTriangleAngle),</span>
<span class="lineNum">    1154 </span><span class="lineCov">          4 :                         0.5*(fgkEndLadderCarbonFiberLowerJunctionLength[i]</span>
<span class="lineNum">    1155 </span><span class="lineCov">          2 :   -                          fgkEndLadderCarbonFiberUpperJunctionLength[i]));</span>
<span class="lineNum">    1156 </span>            :   }
<span class="lineNum">    1157 </span><span class="lineCov">          1 :   TGeoCombiTrans* localendladdercarbonfiberjunctionglobalmatrix[fgkendlabbercarbonfiberjunctionumber];</span>
<span class="lineNum">    1158 </span><span class="lineCov">          1 :   TGeoRotation* localendladdercarbonfiberjunctionglobalrot[fgkendlabbercarbonfiberjunctionumber];</span>
<span class="lineNum">    1159 </span><span class="lineCov">          1 :   TGeoTranslation* localendladdercarbonfiberjunctionglobaltrans[fgkendlabbercarbonfiberjunctionumber];</span>
<span class="lineNum">    1160 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkendlabbercarbonfiberjunctionumber; i++){</span>
<span class="lineNum">    1161 </span><span class="lineCov">          6 :       localendladdercarbonfiberjunctionglobalrot[i] = new TGeoRotation();</span>
<span class="lineNum">    1162 </span><span class="lineCov">          6 :       localendladdercarbonfiberjunctionglobaltrans[i] = new TGeoTranslation();</span>
<span class="lineNum">    1163 </span><span class="lineCov">          2 :       localendladdercarbonfiberjunctionglobalrot[i]-&gt;SetAngles(0.0,90.0,0.0);</span>
<span class="lineNum">    1164 </span><span class="lineCov">          4 :       localendladdercarbonfiberjunctionglobaltrans[i]-&gt;SetTranslation(0.0,</span>
<span class="lineNum">    1165 </span><span class="lineCov">          2 :             0.5*fgkEndLadderCarbonFiberLowerJunctionLength[i],0.0);</span>
<span class="lineNum">    1166 </span><span class="lineCov">          2 :       localendladdercarbonfiberjunctionglobalmatrix[i] = </span>
<span class="lineNum">    1167 </span><span class="lineCov">          6 :             new TGeoCombiTrans(*localendladdercarbonfiberjunctionglobaltrans[i],</span>
<span class="lineNum">    1168 </span><span class="lineCov">          2 :                                *localendladdercarbonfiberjunctionglobalrot[i]);</span>
<span class="lineNum">    1169 </span>            :   }
<span class="lineNum">    1170 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkendlabbercarbonfiberjunctionumber; i++)    </span>
<span class="lineNum">    1171 </span><span class="lineCov">         16 :       for(Int_t j=0; j&lt;fgkendladdercarbonfiberjunctionmatrixnumber; j++){</span>
<span class="lineNum">    1172 </span><span class="lineCov">          6 :             localendladdercarbonfiberjunctionmatrix[i][j] = </span>
<span class="lineNum">    1173 </span><span class="lineCov">         18 :                   new TGeoCombiTrans(*localendladdercarbonfiberjunctiontrans[i][j],</span>
<span class="lineNum">    1174 </span><span class="lineCov">          6 :                                      *localendladdercarbonfiberjunctionrot[i][j]);</span>
<span class="lineNum">    1175 </span><span class="lineCov">          6 :            fendladdercarbonfiberjunctionmatrix[i][j] =</span>
<span class="lineNum">    1176 </span><span class="lineCov">         18 :             new TGeoHMatrix((*localendladdercarbonfiberjunctionglobalmatrix[i])</span>
<span class="lineNum">    1177 </span><span class="lineCov">          6 :             *               (*localendladdercarbonfiberjunctionmatrix[i][j])); </span>
<span class="lineNum">    1178 </span>            :       }  
<span class="lineNum">    1179 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1180 </span>            :   // End Ladder Carbon Fiber Support
<span class="lineNum">    1181 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1182 </span><span class="lineCov">          1 :   TGeoTranslation* localendladdercarbonfibertrans[fgkendladdercarbonfibermatrixnumber];</span>
<span class="lineNum">    1183 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkendladdercarbonfibermatrixnumber; i++){</span>
<span class="lineNum">    1184 </span><span class="lineCov">          6 :       localendladdercarbonfibertrans[i] = new TGeoTranslation();</span>
<span class="lineNum">    1185 </span><span class="lineCov">          2 :       localendladdercarbonfibertrans[i]-&gt;SetTranslation(0.0,</span>
<span class="lineNum">    1186 </span><span class="lineCov">          2 :             i==0 ? 0.0 :fgkCarbonFiberLowerSupportWidth,0.0);</span>
<span class="lineNum">    1187 </span><span class="lineCov">          4 :       fendladdercarbonfibermatrix[i] = new TGeoHMatrix*[fgkcarbonfibersupportnumber];</span>
<span class="lineNum">    1188 </span>            :   }
<span class="lineNum">    1189 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkendladdercarbonfibermatrixnumber; i++)</span>
<span class="lineNum">    1190 </span><span class="lineCov">         12 :       for(Int_t j=0; j&lt;fgkcarbonfibersupportnumber; j++)</span>
<span class="lineNum">    1191 </span><span class="lineCov">          4 :             fendladdercarbonfibermatrix[i][j] = </span>
<span class="lineNum">    1192 </span><span class="lineCov">         12 :             new TGeoHMatrix((*localendladdercarbonfibertrans[i])</span>
<span class="lineNum">    1193 </span><span class="lineCov">          4 :             *(*fcarbonfibersupportmatrix[j]));</span>
<span class="lineNum">    1194 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1195 </span>            :   // End Ladder SSD Mounting Block
<span class="lineNum">    1196 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1197 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkendladdermountingblocknumber; i++)</span>
<span class="lineNum">    1198 </span><span class="lineCov">          6 :       fendladdermountingblockcombitrans[i] = new TGeoCombiTrans();</span>
<span class="lineNum">    1199 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkendladdermountingblocknumber; i++)</span>
<span class="lineNum">    1200 </span><span class="lineCov">          6 :       fendladdermountingblockcombitrans[i]-&gt;SetTranslation(-  0.25*(fgkSSDMountingBlockLength[0]</span>
<span class="lineNum">    1201 </span><span class="lineCov">          2 :                                 +        fgkSSDMountingBlockLength[1])</span>
<span class="lineNum">    1202 </span><span class="lineCov">          2 :                                 +  0.5*fgkCarbonFiberTriangleLength,</span>
<span class="lineNum">    1203 </span><span class="lineCov">          2 :                                 fgkEndLadderMountingBlockPosition[i],</span>
<span class="lineNum">    1204 </span><span class="lineCov">          2 :                                 -  fgkSSDMountingBlockHeight[1]</span>
<span class="lineNum">    1205 </span><span class="lineCov">          2 :                                 +  0.5*fgkSSDMountingBlockHeight[0]);</span>
<span class="lineNum">    1206 </span><span class="lineCov">          2 :   TGeoRotation* endladdermountingblockrot = new TGeoRotation();</span>
<span class="lineNum">    1207 </span><span class="lineCov">          1 :   endladdermountingblockrot-&gt;SetAngles(0.,90.,0.);</span>
<span class="lineNum">    1208 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkendladdermountingblocknumber; i++)</span>
<span class="lineNum">    1209 </span><span class="lineCov">          2 :         fendladdermountingblockcombitrans[i]-&gt;SetRotation(*endladdermountingblockrot);</span>
<span class="lineNum">    1210 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1211 </span>            :   // End Ladder SSD Mounting Block Clip Matrix 
<span class="lineNum">    1212 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1213 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkendladdermountingblocknumber; i++) </span>
<span class="lineNum">    1214 </span><span class="lineCov">          4 :         fendladdermountingblockclipmatrix[i] = new TGeoHMatrix*[2];</span>
<span class="lineNum">    1215 </span>            :   
<span class="lineNum">    1216 </span><span class="lineCov">          2 :   TGeoRotation* localendladdercliprot = new TGeoRotation();</span>
<span class="lineNum">    1217 </span><span class="lineCov">          2 :   TGeoTranslation* localendladdercliptrans = new TGeoTranslation();</span>
<span class="lineNum">    1218 </span><span class="lineCov">          3 :   localendladdercliptrans-&gt;SetTranslation(-0.5*(fgkSSDMountingBlockLength[0]</span>
<span class="lineNum">    1219 </span><span class="lineCov">          1 :                                                                                   -     fgkSSDMountingBlockLength[1])</span>
<span class="lineNum">    1220 </span><span class="lineCov">          1 :                                                                                   + fgkSSDMountingBlockLength[0],0.,0.);</span>
<span class="lineNum">    1221 </span><span class="lineCov">          1 :   localendladdercliprot-&gt;SetAngles(90.,180.,-90.);</span>
<span class="lineNum">    1222 </span>            :   TGeoCombiTrans* localendladderclipcombitrans = 
<span class="lineNum">    1223 </span><span class="lineCov">          2 :                         new TGeoCombiTrans(*localendladdercliptrans,*localendladdercliprot);</span>
<span class="lineNum">    1224 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkendladdermountingblocknumber; i++)</span>
<span class="lineNum">    1225 </span><span class="lineCov">         12 :         for(Int_t j=0; j&lt;2; j++){</span>
<span class="lineNum">    1226 </span><span class="lineCov">          4 :                 fendladdermountingblockclipmatrix[i][j] = </span>
<span class="lineNum">    1227 </span><span class="lineCov">          8 :                                                 new TGeoHMatrix(*fendladdermountingblockcombitrans[i]);</span>
<span class="lineNum">    1228 </span><span class="lineCov">          6 :                 if(j!=0) fendladdermountingblockclipmatrix[i][j]-&gt;Multiply(localendladderclipcombitrans);</span>
<span class="lineNum">    1229 </span>            :         }
<span class="lineNum">    1230 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1231 </span>            :   // End Ladder Carbon Fiber Lower Support
<span class="lineNum">    1232 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1233 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkendladderlowersuppnumber; i++)</span>
<span class="lineNum">    1234 </span><span class="lineCov">          2 :       fendladderlowersupptrans[i] = </span>
<span class="lineNum">    1235 </span><span class="lineCov">          8 :             new TGeoTranslation(0.0,(1-i)*(fgkEndLadderMountingBlockPosition[i]</span>
<span class="lineNum">    1236 </span><span class="lineCov">          2 :                         +  0.5*fgkSSDMountingBlockWidth),</span>
<span class="lineNum">    1237 </span><span class="lineCov">          2 :                         -  0.5*fgkCarbonFiberLowerSupportHeight);</span>
<span class="lineNum">    1238 </span><span class="lineCov">          1 :   fendladderlowersupptrans[0]-&gt;SetDz(-0.5*fgkCarbonFiberLowerSupportHeight-fgkSSDTolerance);</span>
<span class="lineNum">    1239 </span><span class="lineCov">          4 :   fendladderlowersupptrans[2] = new TGeoTranslation(0.0,</span>
<span class="lineNum">    1240 </span><span class="lineCov">          1 :                                                                          fgkCarbonFiberLowerSupportVolumePosition[1]</span>
<span class="lineNum">    1241 </span><span class="lineCov">          1 :                                                                 +    fgkCarbonFiberLowerSupportVolumePosition[0],</span>
<span class="lineNum">    1242 </span>            :                                                                          0.0);
<span class="lineNum">    1243 </span><span class="lineCov">          1 :   fendladderlowersupptrans[2]-&gt;Add(fendladderlowersupptrans[1]);</span>
<span class="lineNum">    1244 </span>            :  /////////////////////////////////////////////////////////////
<span class="lineNum">    1245 </span>            :   // Matrix for positioning Ladder into mother volume
<span class="lineNum">    1246 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1247 </span><span class="lineCov">          1 :   TGeoHMatrix** ladderglobalmatrix[fgkladdernumber];</span>
<span class="lineNum">    1248 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkladdernumber; i++) </span>
<span class="lineNum">    1249 </span><span class="lineCov">          4 :         ladderglobalmatrix[i] = new TGeoHMatrix*[fgkladdernumber];</span>
<span class="lineNum">    1250 </span><span class="lineCov">          2 :   TGeoRotation* localladdermotherrot = new TGeoRotation();</span>
<span class="lineNum">    1251 </span><span class="lineCov">          1 :   localladdermotherrot-&gt;SetAngles(0.,90.,0.);  </span>
<span class="lineNum">    1252 </span><span class="lineCov">          1 :   TGeoTranslation* localladdermothertrans[fgkladdernumber];</span>
<span class="lineNum">    1253 </span><span class="lineCov">          1 :   TGeoCombiTrans* localladdermothercombitrans[fgkladdernumber];</span>
<span class="lineNum">    1254 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkladdernumber; i++){</span>
<span class="lineNum">    1255 </span><span class="lineCov">          8 :         localladdermothertrans[i] = new TGeoTranslation(0.,</span>
<span class="lineNum">    1256 </span><span class="lineCov">          2 :                                                           - fgkEndLadderCarbonFiberLowerJunctionLength[1]</span>
<span class="lineNum">    1257 </span><span class="lineCov">          2 :                                                           + fgkEndLadderCarbonFiberLowerJunctionLength[0]</span>
<span class="lineNum">    1258 </span><span class="lineCov">          4 :                                                           + (i==0?fgkSSDLay5SensorsNumber:fgkSSDLay6SensorsNumber)</span>
<span class="lineNum">    1259 </span><span class="lineCov">          2 :                                                           * fgkCarbonFiberJunctionWidth,0.);</span>
<span class="lineNum">    1260 </span><span class="lineCov">          6 :         localladdermothercombitrans[i] = new TGeoCombiTrans(*localladdermothertrans[i],</span>
<span class="lineNum">    1261 </span>            :                                                                                                                 *localladdermotherrot);
<span class="lineNum">    1262 </span><span class="lineCov">          6 :         ladderglobalmatrix[0][i] = new TGeoHMatrix(*localladdermothercombitrans[i]);</span>
<span class="lineNum">    1263 </span><span class="lineCov">          8 :         ladderglobalmatrix[1][i] = new TGeoHMatrix(ladderglobalmatrix[0][i]-&gt;Inverse());</span>
<span class="lineNum">    1264 </span>            :   }
<span class="lineNum">    1265 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1266 </span>            :   // Ladder Cables Matrices
<span class="lineNum">    1267 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1268 </span><span class="lineCov">          1 :   Double_t ssdflexradius = fgkSSDStiffenerHeight+2*fgkSSDFlexHeight[0]</span>
<span class="lineNum">    1269 </span><span class="lineCov">          1 :                                              + fgkSSDFlexHeight[1];  </span>
<span class="lineNum">    1270 </span>            :   Double_t ssdladdercabletransx[3];
<span class="lineNum">    1271 </span><span class="lineCov">          1 :   ssdladdercabletransx[0] = (ssdflexradiusmax-fgkSSDFlexHeight[1]-ssdflexradius)</span>
<span class="lineNum">    1272 </span><span class="lineCov">          2 :                                                   *   SinD(2.*fgkSSDFlexAngle)</span>
<span class="lineNum">    1273 </span><span class="lineCov">          2 :                                                   *       CosD(2.*fgkSSDFlexAngle);</span>
<span class="lineNum">    1274 </span><span class="lineCov">          1 :   ssdladdercabletransx[1] = ((ssdflexradiusmax-fgkSSDFlexHeight[1]-ssdflexradius)</span>
<span class="lineNum">    1275 </span><span class="lineCov">          1 :                                                   -     ssdladdercabletransx[0]</span>
<span class="lineNum">    1276 </span><span class="lineCov">          2 :                                                   /     SinD(2.*fgkSSDFlexAngle))</span>
<span class="lineNum">    1277 </span><span class="lineCov">          2 :                                                   *     CosD(fgkSSDFlexAngle);                                          </span>
<span class="lineNum">    1278 </span><span class="lineCov">          2 :   ssdladdercabletransx[2] = (fgkSSDFlexFullLength-2.*fgkSSDFlexAngle</span>
<span class="lineNum">    1279 </span><span class="lineCov">          2 :                                                   *       TMath::DegToRad()*ssdflexradiusmax</span>
<span class="lineNum">    1280 </span><span class="lineCov">          2 :                                                   -     fgkSSDFlexLength[2]-TMath::Pi()</span>
<span class="lineNum">    1281 </span><span class="lineCov">          2 :                                                   *       fgkSSDStiffenerHeight-fgkSSDFlexLength[0]</span>
<span class="lineNum">    1282 </span><span class="lineCov">          1 :                                                   -       fgkSSDLadderCableWidth)</span>
<span class="lineNum">    1283 </span><span class="lineCov">          2 :                                                   *       CosD(2.*fgkSSDFlexAngle);</span>
<span class="lineNum">    1284 </span>            :   Double_t ssdladdercabletransz[3] = {ssdladdercabletransx[0]
<span class="lineNum">    1285 </span><span class="lineCov">          2 :                                                   *     TanD(2.*fgkSSDFlexAngle),</span>
<span class="lineNum">    1286 </span>            :                                                         ssdladdercabletransx[1]
<span class="lineNum">    1287 </span><span class="lineCov">          2 :                                                   *     TanD(fgkSSDFlexAngle),</span>
<span class="lineNum">    1288 </span>            :                                                         ssdladdercabletransx[2]
<span class="lineNum">    1289 </span><span class="lineCov">          2 :                                                   *     TanD(2.*fgkSSDFlexAngle)};      </span>
<span class="lineNum">    1290 </span><span class="lineCov">          1 :   TGeoRotation* localladdercablerot[3]; </span>
<span class="lineNum">    1291 </span><span class="lineCov">         14 :   for(Int_t i=0; i&lt;3; i++) localladdercablerot[i] = new TGeoRotation();</span>
<span class="lineNum">    1292 </span><span class="lineCov">          1 :   localladdercablerot[0]-&gt;SetAngles(90.,0.,0.);</span>
<span class="lineNum">    1293 </span><span class="lineCov">          1 :   localladdercablerot[1]-&gt;SetAngles(90.,60.,-90.);</span>
<span class="lineNum">    1294 </span><span class="lineCov">          2 :   localladdercablerot[2]-&gt;SetRotation((*localladdercablerot[1])</span>
<span class="lineNum">    1295 </span><span class="lineCov">          1 :                                                  *                        (*localladdercablerot[0]));</span>
<span class="lineNum">    1296 </span>            :   //TGeoRotation* localladdercablerot = new TGeoRotation();     
<span class="lineNum">    1297 </span>            :   //localladdercablerot-&gt;SetAngles(90.,0.,0.);
<span class="lineNum">    1298 </span>            :   ////////////////////////////////////////////
<span class="lineNum">    1299 </span>            :   // LocalLadderCableCombiTransMatrix
<span class="lineNum">    1300 </span>            :   ////////////////////////////////////////////
<span class="lineNum">    1301 </span>            :   const Int_t klocalladdersidecablesnumber = 2;
<span class="lineNum">    1302 </span>            :   const Int_t klocalladdercombitransnumber = 5;
<span class="lineNum">    1303 </span><span class="lineCov">          1 :   TGeoCombiTrans** localladdercablecombitransmatrix[klocalladdersidecablesnumber];</span>
<span class="lineNum">    1304 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;klocalladdersidecablesnumber; i++) </span>
<span class="lineNum">    1305 </span><span class="lineCov">          2 :          localladdercablecombitransmatrix[i] = </span>
<span class="lineNum">    1306 </span><span class="lineCov">          4 :                                                            new TGeoCombiTrans*[klocalladdercombitransnumber];</span>
<span class="lineNum">    1307 </span>            :   ///////////////////////////////////////////
<span class="lineNum">    1308 </span>            :   // Left Side Ladder Cables Transformations
<span class="lineNum">    1309 </span>            :   ///////////////////////////////////////////
<span class="lineNum">    1310 </span><span class="lineCov">          1 :   localladdercablecombitransmatrix[0][0]  =</span>
<span class="lineNum">    1311 </span><span class="lineCov">          2 :                                                 new TGeoCombiTrans(-0.5*fgkCarbonFiberTriangleLength,</span>
<span class="lineNum">    1312 </span>            :                                                 0.,0.,NULL);
<span class="lineNum">    1313 </span><span class="lineCov">          1 :   localladdercablecombitransmatrix[0][1] = </span>
<span class="lineNum">    1314 </span><span class="lineCov">          3 :         new TGeoCombiTrans(-0.5*(fgkSSDSensorWidth-fgkCarbonFiberTriangleLength),</span>
<span class="lineNum">    1315 </span><span class="lineCov">          2 :                                            - (2.*fgkSSDSensorLength-fgkSSDSensorOverlap)+</span>
<span class="lineNum">    1316 </span><span class="lineCov">          2 :                                                  fgkSSDModuleStiffenerPosition[1]+fgkSSDStiffenerWidth</span>
<span class="lineNum">    1317 </span><span class="lineCov">          1 :                                            + 0.5*fgkSSDFlexHoleLength+2.*fgkCarbonFiberJunctionWidth</span>
<span class="lineNum">    1318 </span><span class="lineCov">          2 :                                            - 0.5*(fgkCarbonFiberLowerSupportWidth</span>
<span class="lineNum">    1319 </span><span class="lineCov">          1 :                                            + fgkSSDSensorCenterSupportLength</span>
<span class="lineNum">    1320 </span><span class="lineCov">          1 :                                            - fgkSSDSensorCenterSupportThickness[0]),</span>
<span class="lineNum">    1321 </span><span class="lineCov">          2 :                                            - (fgkSSDModuleCoolingBlockToSensor</span>
<span class="lineNum">    1322 </span><span class="lineCov">          1 :                                            + 0.5*fgkCoolingTubeSupportHeight</span>
<span class="lineNum">    1323 </span><span class="lineCov">          1 :                                            - fgkSSDSensorHeight-fgkSSDChipCablesHeight[3]</span>
<span class="lineNum">    1324 </span><span class="lineCov">          1 :                                            - fgkSSDChipHeight),NULL);</span>
<span class="lineNum">    1325 </span><span class="lineCov">          1 :   localladdercablecombitransmatrix[0][2] = </span>
<span class="lineNum">    1326 </span><span class="lineCov">          3 :                                                 new TGeoCombiTrans(fgkSSDModuleStiffenerPosition[0],</span>
<span class="lineNum">    1327 </span><span class="lineCov">          1 :                                                                                    fgkSSDModuleStiffenerPosition[1],0.,0);</span>
<span class="lineNum">    1328 </span><span class="lineCov">          4 :   localladdercablecombitransmatrix[0][3] = new TGeoCombiTrans(</span>
<span class="lineNum">    1329 </span><span class="lineCov">          2 :                                         0.5*(fgkSSDStiffenerLength+fgkSSDChipNumber*fgkSSDChipLength</span>
<span class="lineNum">    1330 </span><span class="lineCov">          1 :                                    +(fgkSSDChipNumber-1)*fgkSSDChipSeparationLength),</span>
<span class="lineNum">    1331 </span><span class="lineCov">          1 :                                    fgkSSDSensorLength-2.*fgkSSDModuleStiffenerPosition[1]</span>
<span class="lineNum">    1332 </span><span class="lineCov">          1 :                                          - fgkSSDStiffenerWidth,- 0.5*fgkSSDChipHeight,</span>
<span class="lineNum">    1333 </span><span class="lineCov">          2 :                                                                                                 new TGeoRotation(&quot;&quot;,180.,0.,0.));</span>
<span class="lineNum">    1334 </span><span class="lineCov">          1 :   localladdercablecombitransmatrix[0][4] = </span>
<span class="lineNum">    1335 </span><span class="lineCov">          3 :                                                 new TGeoCombiTrans(-ssdladdercabletransx[0]</span>
<span class="lineNum">    1336 </span><span class="lineCov">          1 :                                                 -     ssdladdercabletransx[1]-ssdladdercabletransx[2]</span>
<span class="lineNum">    1337 </span><span class="lineCov">          1 :                                                 +     fgkSSDFlexLength[0]-fgkSSDFlexLength[2],</span>
<span class="lineNum">    1338 </span>            :                                                           0.,
<span class="lineNum">    1339 </span><span class="lineCov">          2 :                                                           0.5*fgkSSDFlexHeight[0]+2.*(fgkSSDFlexHeight[0]</span>
<span class="lineNum">    1340 </span><span class="lineCov">          2 :                                                 +         fgkSSDFlexHeight[1])+2.*fgkSSDStiffenerHeight</span>
<span class="lineNum">    1341 </span><span class="lineCov">          1 :                                                 +     ssdladdercabletransz[0]-ssdladdercabletransz[1]</span>
<span class="lineNum">    1342 </span><span class="lineCov">          1 :                                                 +         ssdladdercabletransz[2],localladdercablerot[2]);</span>
<span class="lineNum">    1343 </span>            :   ///////////////////////////////////////////
<span class="lineNum">    1344 </span>            :   // Rigth Side Ladder Cables Transformations
<span class="lineNum">    1345 </span>            :   ///////////////////////////////////////////
<span class="lineNum">    1346 </span>            :   TGeoCombiTrans* localladdercablessdmodulematrix = 
<span class="lineNum">    1347 </span><span class="lineCov">          4 :         new TGeoCombiTrans(0.5*(fgkSSDStiffenerLength-fgkSSDChipNumber*fgkSSDChipLength</span>
<span class="lineNum">    1348 </span><span class="lineCov">          1 :                                                                   - (fgkSSDChipNumber-1)*fgkSSDChipSeparationLength),</span>
<span class="lineNum">    1349 </span><span class="lineCov">          1 :                                                                          fgkSSDStiffenerWidth,</span>
<span class="lineNum">    1350 </span><span class="lineCov">          1 :                                                                   - 0.5*fgkSSDFlexHeight[0],NULL);</span>
<span class="lineNum">    1351 </span><span class="lineCov">         12 :   for(Int_t i=0; i&lt;klocalladdercombitransnumber; i++)</span>
<span class="lineNum">    1352 </span><span class="lineCov">          5 :    localladdercablecombitransmatrix[1][i] = </span>
<span class="lineNum">    1353 </span><span class="lineCov">         18 :                         (i!=3 ? new TGeoCombiTrans(*localladdercablecombitransmatrix[0][i]):</span>
<span class="lineNum">    1354 </span><span class="lineCov">          2 :                                         new TGeoCombiTrans(*localladdercablessdmodulematrix));  </span>
<span class="lineNum">    1355 </span>            :   ///////////////////////////////////////////
<span class="lineNum">    1356 </span>            :   // Setting LadderCableHMatrix
<span class="lineNum">    1357 </span>            :   ///////////////////////////////////////////
<span class="lineNum">    1358 </span><span class="lineCov">          1 :   Int_t beamaxistrans[2][3];</span>
<span class="lineNum">    1359 </span><span class="lineCov">          1 :   beamaxistrans[0][0] = fgkSSDLay5SensorsNumber/2; </span>
<span class="lineNum">    1360 </span><span class="lineCov">          1 :   beamaxistrans[0][1] = beamaxistrans[0][0]+1;</span>
<span class="lineNum">    1361 </span><span class="lineCov">          1 :   beamaxistrans[0][2] = beamaxistrans[0][0]-1;</span>
<span class="lineNum">    1362 </span><span class="lineCov">          1 :   beamaxistrans[1][0] = (fgkSSDLay6SensorsNumber-1)/2;</span>
<span class="lineNum">    1363 </span><span class="lineCov">          1 :   beamaxistrans[1][1] = beamaxistrans[1][0]+1;</span>
<span class="lineNum">    1364 </span><span class="lineCov">          1 :   beamaxistrans[1][2] = beamaxistrans[1][0];</span>
<span class="lineNum">    1365 </span><span class="lineCov">          1 :   TGeoHMatrix** localladdercablehmatrix[fgkladdercablesnumber];</span>
<span class="lineNum">    1366 </span><span class="lineCov">          2 :   TGeoRotation* laddercablerot = new TGeoRotation();</span>
<span class="lineNum">    1367 </span><span class="lineCov">          2 :   TGeoTranslation* laddercabletrans = new TGeoTranslation();</span>
<span class="lineNum">    1368 </span><span class="lineCov">          2 :   TGeoCombiTrans* laddercablecombitrans = new TGeoCombiTrans();</span>
<span class="lineNum">    1369 </span>            :   Double_t* laddercabletransvector;     
<span class="lineNum">    1370 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkladdercablesnumber; i++){ </span>
<span class="lineNum">    1371 </span><span class="lineCov">          4 :         localladdercablehmatrix[i] = new TGeoHMatrix*[klocalladdersidecablesnumber];</span>
<span class="lineNum">    1372 </span><span class="lineCov">          4 :         fladdercablematrix[i] = new TGeoHMatrix*[fgkladdercablematrixnumber];</span>
<span class="lineNum">    1373 </span>            :   }
<span class="lineNum">    1374 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkladdercablesnumber; i++){</span>
<span class="lineNum">    1375 </span><span class="lineCov">         12 :         for(Int_t j=0; j&lt;klocalladdersidecablesnumber; j++){</span>
<span class="lineNum">    1376 </span><span class="lineCov">         12 :                 localladdercablehmatrix[i][j] = new TGeoHMatrix();</span>
<span class="lineNum">    1377 </span><span class="lineCov">         48 :                 for(Int_t k=0; k&lt;klocalladdercombitransnumber; k++){</span>
<span class="lineNum">    1378 </span><span class="lineCov">         40 :                         localladdercablehmatrix[i][j]-&gt;MultiplyLeft(</span>
<span class="lineNum">    1379 </span><span class="lineCov">         20 :                         localladdercablecombitransmatrix[j][klocalladdercombitransnumber-k-1]);</span>
<span class="lineNum">    1380 </span>            :         }
<span class="lineNum">    1381 </span><span class="lineCov">          8 :                 laddercablerot-&gt;SetMatrix(localladdercablehmatrix[i][j]-&gt;GetRotationMatrix());</span>
<span class="lineNum">    1382 </span><span class="lineCov">          4 :                 laddercabletransvector = localladdercablehmatrix[i][j]-&gt;GetTranslation();</span>
<span class="lineNum">    1383 </span><span class="lineCov">          8 :                 laddercabletrans-&gt;SetTranslation(laddercabletransvector[0],</span>
<span class="lineNum">    1384 </span><span class="lineCov">          4 :                                                                          laddercabletransvector[1]</span>
<span class="lineNum">    1385 </span><span class="lineCov">         14 :                                         +                (j==0 ? beamaxistrans[i][0] : 0.)</span>
<span class="lineNum">    1386 </span><span class="lineCov">          4 :                                         *                                fgkCarbonFiberJunctionWidth,</span>
<span class="lineNum">    1387 </span><span class="lineCov">          4 :                                                                          laddercabletransvector[2]);</span>
<span class="lineNum">    1388 </span><span class="lineCov">          4 :                 laddercablecombitrans-&gt;SetRotation(*laddercablerot);</span>
<span class="lineNum">    1389 </span><span class="lineCov">          4 :                 laddercablecombitrans-&gt;SetTranslation(*laddercabletrans);    </span>
<span class="lineNum">    1390 </span><span class="lineCov">         12 :                 fladdercablematrix[i][j] = new TGeoHMatrix(*laddercablecombitrans);</span>
<span class="lineNum">    1391 </span>            :         }
<span class="lineNum">    1392 </span><span class="lineCov">          2 :     fladdercablematrix[i][2] = </span>
<span class="lineNum">    1393 </span><span class="lineCov">          4 :                                         AddTranslationToHMatrix(fladdercablematrix[i][1],0.,</span>
<span class="lineNum">    1394 </span><span class="lineCov">          2 :                                         beamaxistrans[i][1]*fgkCarbonFiberJunctionWidth,0.);</span>
<span class="lineNum">    1395 </span><span class="lineCov">          2 :         fladdercablematrix[i][3] = </span>
<span class="lineNum">    1396 </span><span class="lineCov">          4 :                                         AddTranslationToHMatrix(fladdercablematrix[i][0],0.,</span>
<span class="lineNum">    1397 </span><span class="lineCov">          2 :                                         beamaxistrans[i][2]*fgkCarbonFiberJunctionWidth,0.);</span>
<span class="lineNum">    1398 </span>            :   }
<span class="lineNum">    1399 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkladdercablesnumber; i++)</span>
<span class="lineNum">    1400 </span><span class="lineCov">         20 :     for(Int_t j=0; j&lt;klocalladdercombitransnumber-1; j++) </span>
<span class="lineNum">    1401 </span><span class="lineCov">          8 :       fladdercablematrix[i][j]-&gt;MultiplyLeft(ladderglobalmatrix[1][i]);</span>
<span class="lineNum">    1402 </span>            :   
<span class="lineNum">    1403 </span>            :   ///////////////////////////////////////////
<span class="lineNum">    1404 </span>            :   // Setting Ladder HMatrix
<span class="lineNum">    1405 </span>            :   ///////////////////////////////////////////
<span class="lineNum">    1406 </span><span class="lineCov">          1 :   Int_t ssdlaysensorsnumber[fgkladdernumber] = {fgkSSDLay5SensorsNumber,</span>
<span class="lineNum">    1407 </span>            :                                                                                                 fgkSSDLay6SensorsNumber};
<span class="lineNum">    1408 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkladdernumber; i++){</span>
<span class="lineNum">    1409 </span><span class="lineCov">          4 :         fladdermatrix[i] = new TGeoHMatrix*[ssdlaysensorsnumber[i]];</span>
<span class="lineNum">    1410 </span><span class="lineCov">         98 :         for(Int_t j=0; j&lt;ssdlaysensorsnumber[i]; j++){</span>
<span class="lineNum">    1411 </span><span class="lineCov">        141 :                 fladdermatrix[i][j] = new TGeoHMatrix();</span>
<span class="lineNum">    1412 </span><span class="lineCov">         47 :                 fladdermatrix[i][j]-&gt;SetDx(-0.5*fgkCarbonFiberTriangleLength);</span>
<span class="lineNum">    1413 </span><span class="lineCov">         47 :                 fladdermatrix[i][j]-&gt;SetDy(fgkCarbonFiberJunctionWidth*j);</span>
<span class="lineNum">    1414 </span><span class="lineCov">         47 :                 fladdermatrix[i][j]-&gt;MultiplyLeft(ladderglobalmatrix[1][i]);</span>
<span class="lineNum">    1415 </span>            :         }
<span class="lineNum">    1416 </span>            :   }
<span class="lineNum">    1417 </span>            :   ///////////////////////////////////////////
<span class="lineNum">    1418 </span>            :   // Setting SSD Sensor Matrix 
<span class="lineNum">    1419 </span>            :   ///////////////////////////////////////////
<span class="lineNum">    1420 </span><span class="lineCov">          1 :   TGeoCombiTrans* localssdsensorcombitrans[2];</span>
<span class="lineNum">    1421 </span><span class="lineCov">          2 :   TGeoRotation* localssdsensorrot = new TGeoRotation(); </span>
<span class="lineNum">    1422 </span><span class="lineCov">          1 :   localssdsensorrot-&gt;SetAngles(0.,90.,0.);   </span>
<span class="lineNum">    1423 </span><span class="lineCov">          1 :   TGeoTranslation* localssdsensortrans[2];</span>
<span class="lineNum">    1424 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;2; i++) localssdsensortrans[i] = new TGeoTranslation();</span>
<span class="lineNum">    1425 </span><span class="lineCov">          2 :   localssdsensortrans[0]-&gt;SetTranslation(0.5*fgkCarbonFiberTriangleLength,</span>
<span class="lineNum">    1426 </span><span class="lineCov">          1 :                                          fgkCarbonFiberJunctionWidth </span>
<span class="lineNum">    1427 </span><span class="lineCov">          1 :                                          - fgkCarbonFiberLowerSupportWidth </span>
<span class="lineNum">    1428 </span><span class="lineCov">          1 :                                          - fgkLowerSupportToSensorZ,</span>
<span class="lineNum">    1429 </span><span class="lineCov">          1 :                                                         0.5*fgkSSDSensorHeight-0.5*fgkCoolingTubeSupportHeight</span>
<span class="lineNum">    1430 </span><span class="lineCov">          1 :                                           -             fgkSSDModuleCoolingBlockToSensor</span>
<span class="lineNum">    1431 </span><span class="lineCov">          2 :                                           +    (fgkSSDSensorSideSupportHeight[1]</span>
<span class="lineNum">    1432 </span><span class="lineCov">          1 :                                           -             fgkSSDSensorSideSupportHeight[0]));</span>
<span class="lineNum">    1433 </span><span class="lineCov">          2 :   localssdsensortrans[1]-&gt;SetTranslation(0.5*fgkCarbonFiberTriangleLength,</span>
<span class="lineNum">    1434 </span><span class="lineCov">          1 :                                          fgkCarbonFiberJunctionWidth </span>
<span class="lineNum">    1435 </span><span class="lineCov">          1 :                                          - fgkCarbonFiberLowerSupportWidth </span>
<span class="lineNum">    1436 </span><span class="lineCov">          1 :                                          - fgkLowerSupportToSensorZ,</span>
<span class="lineNum">    1437 </span><span class="lineCov">          1 :                                                     0.5*fgkSSDSensorHeight-0.5*fgkCoolingTubeSupportHeight</span>
<span class="lineNum">    1438 </span><span class="lineCov">          1 :                                                         -fgkSSDModuleCoolingBlockToSensor);</span>
<span class="lineNum">    1439 </span>            : 
<span class="lineNum">    1440 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;2; i++) </span>
<span class="lineNum">    1441 </span><span class="lineCov">          6 :         localssdsensorcombitrans[i] = new TGeoCombiTrans(*localssdsensortrans[i],</span>
<span class="lineNum">    1442 </span>            :                                                                                                          *localssdsensorrot);   
<span class="lineNum">    1443 </span><span class="lineCov">          6 :     for(Int_t i=0; i&lt;fgkladdernumber; i++){</span>
<span class="lineNum">    1444 </span><span class="lineCov">          4 :         fssdsensormatrix[i] = new TGeoHMatrix*[ssdlaysensorsnumber[i]];</span>
<span class="lineNum">    1445 </span><span class="lineCov">         98 :         for(Int_t j=0; j&lt;ssdlaysensorsnumber[i]; j++){</span>
<span class="lineNum">    1446 </span><span class="lineCov">         47 :                 switch(i){</span>
<span class="lineNum">    1447 </span>            :                         case 0: //Ladder of Layer5  
<span class="lineNum">    1448 </span><span class="lineCov">         88 :                         fssdsensormatrix[i][j] = new TGeoHMatrix((*fladdermatrix[i][j])</span>
<span class="lineNum">    1449 </span><span class="lineCov">         44 :                                                                    * ((j%2==0 ? *localssdsensorcombitrans[0] :</span>
<span class="lineNum">    1450 </span><span class="lineCov">         22 :                                                                                                 *localssdsensorcombitrans[1])));</span>
<span class="lineNum">    1451 </span><span class="lineCov">         22 :                         break;</span>
<span class="lineNum">    1452 </span>            :                         case 1: //Ladder of Layer6 
<span class="lineNum">    1453 </span><span class="lineCov">        100 :                         fssdsensormatrix[i][j] = new TGeoHMatrix((*fladdermatrix[i][j])</span>
<span class="lineNum">    1454 </span><span class="lineCov">         50 :                                                                    * ((j%2==0 ? *localssdsensorcombitrans[1] :</span>
<span class="lineNum">    1455 </span><span class="lineCov">         25 :                                                                                                 *localssdsensorcombitrans[0])));</span>
<span class="lineNum">    1456 </span><span class="lineCov">         25 :                 break;</span>
<span class="lineNum">    1457 </span>            :                 }
<span class="lineNum">    1458 </span>            :           }
<span class="lineNum">    1459 </span>            :   }     
<span class="lineNum">    1460 </span>            :   //////////////////////////
<span class="lineNum">    1461 </span>            :   // Setting SSD End Ladder  
<span class="lineNum">    1462 </span>            :   //////////////////////////
<span class="lineNum">    1463 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;2; i++) fendladdersegmentmatrix[i] = new TGeoHMatrix*[2];</span>
<span class="lineNum">    1464 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;2; i++){</span>
<span class="lineNum">    1465 </span><span class="lineCov">          6 :         fendladdersegmentmatrix[0][i] = new TGeoHMatrix();</span>
<span class="lineNum">    1466 </span><span class="lineCov">          2 :         fendladdersegmentmatrix[0][i]-&gt;SetDx(-0.5*fgkCarbonFiberTriangleLength);</span>
<span class="lineNum">    1467 </span><span class="lineCov">          2 :         fendladdersegmentmatrix[0][i]-&gt;SetDy(fgkCarbonFiberJunctionWidth*ssdlaysensorsnumber[i]);</span>
<span class="lineNum">    1468 </span><span class="lineCov">          2 :         fendladdersegmentmatrix[0][i]-&gt;MultiplyLeft(ladderglobalmatrix[1][i]);</span>
<span class="lineNum">    1469 </span><span class="lineCov">          6 :         fendladdersegmentmatrix[1][i] = new TGeoHMatrix();</span>
<span class="lineNum">    1470 </span><span class="lineCov">          2 :         fendladdersegmentmatrix[1][i]-&gt;SetDx(-0.5*fgkCarbonFiberTriangleLength);</span>
<span class="lineNum">    1471 </span><span class="lineCov">          2 :         fendladdersegmentmatrix[1][i]-&gt;RotateZ(180.0);</span>
<span class="lineNum">    1472 </span><span class="lineCov">          2 :         fendladdersegmentmatrix[1][i]-&gt;MultiplyLeft(ladderglobalmatrix[1][i]);</span>
<span class="lineNum">    1473 </span>            :    }
<span class="lineNum">    1474 </span>            :   /////////////////////////////////////////////////////
<span class="lineNum">    1475 </span>            :   // Setting the CombiTransformation to pass ITS center 
<span class="lineNum">    1476 </span>            :   /////////////////////////////////////////////////////
<span class="lineNum">    1477 </span><span class="lineCov">          1 :   Double_t itscentertransz[fgklayernumber];</span>
<span class="lineNum">    1478 </span><span class="lineCov">          2 :   itscentertransz[0] = fgkSSDLay5LadderLength</span>
<span class="lineNum">    1479 </span><span class="lineCov">          1 :                                          - fgkLay5CenterITSPosition;</span>
<span class="lineNum">    1480 </span><span class="lineCov">          2 :   itscentertransz[1] = fgkSSDLay6LadderLength</span>
<span class="lineNum">    1481 </span><span class="lineCov">          1 :                                          - fgkLay6CenterITSPosition;</span>
<span class="lineNum">    1482 </span><span class="lineCov">          1 :   Double_t itssensortransy = fgkSSDModuleCoolingBlockToSensor</span>
<span class="lineNum">    1483 </span><span class="lineCov">          1 :                                                    + 0.5*fgkCoolingTubeSupportHeight;</span>
<span class="lineNum">    1484 </span><span class="lineCov">          1 :   TGeoRotation* itscenterrot[3];</span>
<span class="lineNum">    1485 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;fgklayernumber; i++) itscenterrot[i] = new TGeoRotation();</span>
<span class="lineNum">    1486 </span><span class="lineCov">          1 :   itscenterrot[0]-&gt;SetAngles(90.,180.,-90.);</span>
<span class="lineNum">    1487 </span><span class="lineCov">          1 :   itscenterrot[1]-&gt;SetAngles(0.,90.,0.);</span>
<span class="lineNum">    1488 </span><span class="lineCov">          4 :   itscenterrot[2] = new TGeoRotation((*itscenterrot[1])*(*itscenterrot[0]));</span>
<span class="lineNum">    1489 </span><span class="lineCov">          1 :   TGeoCombiTrans* itscentercombitrans[fgklayernumber];</span>
<span class="lineNum">    1490 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++) </span>
<span class="lineNum">    1491 </span><span class="lineCov">          8 :         itscentercombitrans[i] = new TGeoCombiTrans(0.,</span>
<span class="lineNum">    1492 </span>            :                                                          itssensortransy,
<span class="lineNum">    1493 </span><span class="lineCov">          2 :                                                          fgkEndLadderCarbonFiberLowerJunctionLength[1]</span>
<span class="lineNum">    1494 </span><span class="lineCov">          2 :                                                    - itscentertransz[i],itscenterrot[2]);</span>
<span class="lineNum">    1495 </span><span class="lineCov">          1 :   TGeoRotation** locallayerrot[fgklayernumber];</span>
<span class="lineNum">    1496 </span><span class="lineCov">          1 :   TGeoTranslation** locallayertrans[fgklayernumber];    </span>
<span class="lineNum">    1497 </span><span class="lineCov">          1 :   TGeoCombiTrans** locallayercombitrans[fgklayernumber];</span>
<span class="lineNum">    1498 </span><span class="lineCov">          1 :   TGeoTranslation* localbeamaxistrans[fgklayernumber];</span>
<span class="lineNum">    1499 </span><span class="lineCov">          4 :   localbeamaxistrans[0] = new TGeoTranslation(0.,0.,0.5*fgkSSDLay5LadderLength</span>
<span class="lineNum">    1500 </span><span class="lineCov">          1 :                                          - fgkLay5CenterITSPosition);</span>
<span class="lineNum">    1501 </span><span class="lineCov">          4 :   localbeamaxistrans[1] = new TGeoTranslation(0.,0.,0.5*fgkSSDLay6LadderLength</span>
<span class="lineNum">    1502 </span><span class="lineCov">          1 :                                          - fgkLay6CenterITSPosition);</span>
<span class="lineNum">    1503 </span>            :   const Int_t kssdlayladdernumber[fgklayernumber] = 
<span class="lineNum">    1504 </span>            :                         {fgkSSDLay5LadderNumber,fgkSSDLay6LadderNumber};
<span class="lineNum">    1505 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++){</span>
<span class="lineNum">    1506 </span><span class="lineCov">          4 :     locallayerrot[i] = new TGeoRotation*[kssdlayladdernumber[i]];</span>
<span class="lineNum">    1507 </span><span class="lineCov">          4 :     locallayertrans[i] = new TGeoTranslation*[kssdlayladdernumber[i]];</span>
<span class="lineNum">    1508 </span><span class="lineCov">          4 :         locallayercombitrans[i] = new TGeoCombiTrans*[kssdlayladdernumber[i]];</span>
<span class="lineNum">    1509 </span><span class="lineCov">          4 :         flayermatrix[i] = new TGeoHMatrix*[kssdlayladdernumber[i]];</span>
<span class="lineNum">    1510 </span>            :   }
<span class="lineNum">    1511 </span><span class="lineCov">          1 :   Double_t layerladderangleposition[fgklayernumber] = </span>
<span class="lineNum">    1512 </span>            :                 {360./fgkSSDLay5LadderNumber,360./fgkSSDLay6LadderNumber};
<span class="lineNum">    1513 </span>            :   Double_t layerradius = 0.;
<span class="lineNum">    1514 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++){     </span>
<span class="lineNum">    1515 </span><span class="lineCov">        148 :         for(Int_t j=0; j&lt;kssdlayladdernumber[i]; j++){</span>
<span class="lineNum">    1516 </span><span class="lineCov">        144 :                 switch(i){</span>
<span class="lineNum">    1517 </span>            :                         case 0: //Ladder of Layer5  
<span class="lineNum">    1518 </span><span class="lineCov">         34 :                         layerradius = (j%2==0 ? fgkSSDLay5RadiusMin: fgkSSDLay5RadiusMax);</span>
<span class="lineNum">    1519 </span><span class="lineCov">         34 :                         break;</span>
<span class="lineNum">    1520 </span>            :                         case 1: //Ladder of Layer6 
<span class="lineNum">    1521 </span><span class="lineCov">         38 :                         layerradius = (j%2==0 ? fgkSSDLay6RadiusMin: fgkSSDLay6RadiusMax);</span>
<span class="lineNum">    1522 </span><span class="lineCov">         38 :                 break;</span>
<span class="lineNum">    1523 </span>            :                 }
<span class="lineNum">    1524 </span><span class="lineCov">        216 :                 locallayerrot[i][j] = new TGeoRotation();</span>
<span class="lineNum">    1525 </span><span class="lineCov">        216 :                 locallayertrans[i][j] = new TGeoTranslation();</span>
<span class="lineNum">    1526 </span><span class="lineCov">         72 :                 locallayerrot[i][j]-&gt;SetAngles(j*layerladderangleposition[i],0.,0.);</span>
<span class="lineNum">    1527 </span><span class="lineCov">        144 :                 locallayertrans[i][j]-&gt;SetTranslation(layerradius </span>
<span class="lineNum">    1528 </span><span class="lineCov">        144 :                                                           *     CosD(90.0+j*layerladderangleposition[i]),</span>
<span class="lineNum">    1529 </span>            :                                                             layerradius 
<span class="lineNum">    1530 </span><span class="lineCov">        144 :                                                           * SinD(90.0+j*layerladderangleposition[i]),0.);</span>
<span class="lineNum">    1531 </span><span class="lineCov">        288 :                 locallayercombitrans[i][j] = new TGeoCombiTrans(*locallayertrans[i][j],</span>
<span class="lineNum">    1532 </span><span class="lineCov">         72 :                                                                          *locallayerrot[i][j]);</span>
<span class="lineNum">    1533 </span><span class="lineCov">        288 :                 flayermatrix[i][j] = new TGeoHMatrix((*locallayercombitrans[i][j])*(*itscentercombitrans[i]));</span>
<span class="lineNum">    1534 </span><span class="lineCov">         72 :                 flayermatrix[i][j]-&gt;Multiply(ladderglobalmatrix[0][i]);</span>
<span class="lineNum">    1535 </span><span class="lineCov">         72 :                 flayermatrix[i][j]-&gt;MultiplyLeft(localbeamaxistrans[i]);</span>
<span class="lineNum">    1536 </span>            :         }
<span class="lineNum">    1537 </span>            :   }
<span class="lineNum">    1538 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1539 </span>            :   // Deallocating memory
<span class="lineNum">    1540 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1541 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt; kcarbonfibersupportmatrixnumber[1]; i++){</span>
<span class="lineNum">    1542 </span><span class="lineCov">          6 :         delete carbonfiberot[i];</span>
<span class="lineNum">    1543 </span><span class="lineCov">          6 :         delete localcarbonfibersupportmatrix[i];</span>
<span class="lineNum">    1544 </span>            :   }
<span class="lineNum">    1545 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt; fgkcarbonfiberjunctionumber; i++){</span>
<span class="lineNum">    1546 </span><span class="lineCov">         18 :      for(Int_t j=0; j&lt; kcarbonfiberjunctionmatrixnumber; j++){</span>
<span class="lineNum">    1547 </span><span class="lineCov">         12 :        delete localcarbonfiberjunctionmatrix[i][j];</span>
<span class="lineNum">    1548 </span><span class="lineCov">         12 :            delete localcarbonfiberjunctionrot[i][j];</span>
<span class="lineNum">    1549 </span><span class="lineCov">         12 :            delete localcarbonfiberjunctiontrans[i][j];</span>
<span class="lineNum">    1550 </span>            :            }
<span class="lineNum">    1551 </span><span class="lineCov">          6 :        delete [] localcarbonfiberjunctionmatrix[i];</span>
<span class="lineNum">    1552 </span><span class="lineCov">          6 :        delete [] localcarbonfiberjunctionrot[i];</span>
<span class="lineNum">    1553 </span><span class="lineCov">          6 :        delete [] localcarbonfiberjunctiontrans[i];</span>
<span class="lineNum">    1554 </span>            :   }
<span class="lineNum">    1555 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkcarbonfiberlowersupportnumber; i++) </span>
<span class="lineNum">    1556 </span><span class="lineCov">          4 :            delete localcarbonfiberlowersupportrans[i];</span>
<span class="lineNum">    1557 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt; fgkssdsensorsupportnumber; i++){</span>
<span class="lineNum">    1558 </span><span class="lineCov">         24 :      for(Int_t j=0; j&lt; kssdsensorsupportmatrixnumber; j++){</span>
<span class="lineNum">    1559 </span><span class="lineCov">         18 :        delete localssdsensorsupportmatrix[i][j];</span>
<span class="lineNum">    1560 </span><span class="lineCov">         18 :            delete localssdsensorsupportrot[i][j];</span>
<span class="lineNum">    1561 </span><span class="lineCov">         18 :            delete localssdsensorsupportrans[i][j];</span>
<span class="lineNum">    1562 </span>            :            }
<span class="lineNum">    1563 </span><span class="lineCov">          6 :        delete [] localssdsensorsupportmatrix[i];</span>
<span class="lineNum">    1564 </span><span class="lineCov">          6 :        delete [] localssdsensorsupportrot[i];</span>
<span class="lineNum">    1565 </span><span class="lineCov">          6 :        delete [] localssdsensorsupportrans[i];</span>
<span class="lineNum">    1566 </span>            :   }
<span class="lineNum">    1567 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;kcoolingtubesupportmatrixnumber; i++){</span>
<span class="lineNum">    1568 </span><span class="lineCov">          4 :         delete localcoolingtubesupportmatrix[i];</span>
<span class="lineNum">    1569 </span><span class="lineCov">          4 :         delete localcoolingtubesupportrot[i];</span>
<span class="lineNum">    1570 </span><span class="lineCov">          4 :         delete localcoolingtubesupportrans[i];</span>
<span class="lineNum">    1571 </span>            :   }
<span class="lineNum">    1572 </span><span class="lineCov">          6 :   for(Int_t j=0; j&lt;2; j++){</span>
<span class="lineNum">    1573 </span><span class="lineCov">          4 :     delete localcoolingtubevect[j];</span>
<span class="lineNum">    1574 </span><span class="lineCov">          4 :     delete localcoolingtubetrans[j];</span>
<span class="lineNum">    1575 </span>            :   }
<span class="lineNum">    1576 </span><span class="lineCov">          2 :  delete endladdermountingblockrot;</span>
<span class="lineNum">    1577 </span><span class="lineCov">         14 :  for(Int_t i=0; i&lt;khybridmatrixnumber; i++) delete localhybridtrans[i];</span>
<span class="lineNum">    1578 </span><span class="lineCov">          6 :  for(Int_t i=0; i&lt;fgkflexnumber; i++){</span>
<span class="lineNum">    1579 </span><span class="lineCov">         16 :       for(Int_t j=1; j&lt;klocalflexmatrixnumber; j++) </span>
<span class="lineNum">    1580 </span><span class="lineCov">         12 :             delete localflexmatrix[i][j];</span>
<span class="lineNum">    1581 </span><span class="lineCov">          4 :       delete [] localflexmatrix[i];</span>
<span class="lineNum">    1582 </span>            :  }
<span class="lineNum">    1583 </span><span class="lineCov">          2 :  delete localendlladdercoolingtuberot;</span>
<span class="lineNum">    1584 </span><span class="lineCov">          6 :  for(Int_t i=0; i&lt;2; i++){</span>
<span class="lineNum">    1585 </span><span class="lineCov">         12 :         for(Int_t j=0; j&lt;2; j++)</span>
<span class="lineNum">    1586 </span><span class="lineCov">          8 :           delete localendlladdercoolingtubetrans[i][j];</span>
<span class="lineNum">    1587 </span><span class="lineCov">          4 :         delete [] localendlladdercoolingtubetrans[i];</span>
<span class="lineNum">    1588 </span>            :   }
<span class="lineNum">    1589 </span>            : 
<span class="lineNum">    1590 </span><span class="lineCov">          2 :  delete localflexrot;</span>
<span class="lineNum">    1591 </span><span class="lineCov">          2 :  delete localendflexrot;</span>
<span class="lineNum">    1592 </span><span class="lineCov">          2 :  delete localendflexmatrix;</span>
<span class="lineNum">    1593 </span><span class="lineCov">          6 :  for(Int_t i=0; i&lt;fgkladdernumber; i++){ </span>
<span class="lineNum">    1594 </span><span class="lineCov">          4 :         delete localladdermothertrans[i];</span>
<span class="lineNum">    1595 </span><span class="lineCov">          4 :         delete localladdermothercombitrans[i];</span>
<span class="lineNum">    1596 </span>            :   }
<span class="lineNum">    1597 </span><span class="lineCov">          2 :  delete localladdermotherrot;</span>
<span class="lineNum">    1598 </span><span class="lineCov">          6 :  for(Int_t i=0; i&lt;fgkendlabbercarbonfiberjunctionumber; i++){    </span>
<span class="lineNum">    1599 </span><span class="lineCov">         16 :       for(Int_t j=0; j&lt;fgkendladdercarbonfiberjunctionmatrixnumber; j++){</span>
<span class="lineNum">    1600 </span><span class="lineCov">         12 :             delete localendladdercarbonfiberjunctionmatrix[i][j];</span>
<span class="lineNum">    1601 </span><span class="lineCov">         12 :             delete localendladdercarbonfiberjunctionrot[i][j];</span>
<span class="lineNum">    1602 </span><span class="lineCov">         12 :             delete localendladdercarbonfiberjunctiontrans[i][j];</span>
<span class="lineNum">    1603 </span>            :       }
<span class="lineNum">    1604 </span><span class="lineCov">          4 :       delete [] localendladdercarbonfiberjunctionmatrix[i];</span>
<span class="lineNum">    1605 </span><span class="lineCov">          4 :       delete [] localendladdercarbonfiberjunctionrot[i];</span>
<span class="lineNum">    1606 </span><span class="lineCov">          4 :       delete [] localendladdercarbonfiberjunctiontrans[i];</span>
<span class="lineNum">    1607 </span><span class="lineCov">          4 :       delete localendladdercarbonfiberjunctionglobalrot[i];</span>
<span class="lineNum">    1608 </span><span class="lineCov">          4 :       delete localendladdercarbonfiberjunctionglobaltrans[i];</span>
<span class="lineNum">    1609 </span><span class="lineCov">          4 :       delete localendladdercarbonfiberjunctionglobalmatrix[i];</span>
<span class="lineNum">    1610 </span>            :  }
<span class="lineNum">    1611 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;2; i++){</span>
<span class="lineNum">    1612 </span><span class="lineCov">         28 :         for(Int_t j=0; j&lt;(i==0?4:2); j++) delete localendladdercooltubetrans[i][j];</span>
<span class="lineNum">    1613 </span><span class="lineCov">          4 :         delete [] localendladdercooltubetrans[i];</span>
<span class="lineNum">    1614 </span>            :   }
<span class="lineNum">    1615 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkendladdercarbonfibermatrixnumber; i++)</span>
<span class="lineNum">    1616 </span><span class="lineCov">          4 :       delete localendladdercarbonfibertrans[i];</span>
<span class="lineNum">    1617 </span><span class="lineCov">         14 :   for(Int_t i=0; i&lt;3; i++) delete localladdercablerot[i];</span>
<span class="lineNum">    1618 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;klocalladdersidecablesnumber; i++){</span>
<span class="lineNum">    1619 </span><span class="lineCov">         44 :     for(Int_t j=0; j&lt;klocalladdercombitransnumber; j++)delete localladdercablecombitransmatrix[i][j];</span>
<span class="lineNum">    1620 </span><span class="lineCov">          4 :     delete []localladdercablecombitransmatrix[i];</span>
<span class="lineNum">    1621 </span>            :   }
<span class="lineNum">    1622 </span><span class="lineCov">          2 :   delete localendladdercliprot;</span>
<span class="lineNum">    1623 </span><span class="lineCov">          2 :   delete localendladdercliptrans;</span>
<span class="lineNum">    1624 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkladdercablesnumber; i++){</span>
<span class="lineNum">    1625 </span><span class="lineCov">         12 :         for(Int_t j=0; j&lt;klocalladdersidecablesnumber; j++)</span>
<span class="lineNum">    1626 </span><span class="lineCov">          8 :                 delete localladdercablehmatrix[i][j];</span>
<span class="lineNum">    1627 </span><span class="lineCov">          4 :         delete []localladdercablehmatrix[i];</span>
<span class="lineNum">    1628 </span>            :   }
<span class="lineNum">    1629 </span><span class="lineCov">          2 :   delete laddercablerot;</span>
<span class="lineNum">    1630 </span><span class="lineCov">          2 :   delete laddercabletrans;</span>
<span class="lineNum">    1631 </span><span class="lineCov">          2 :   delete laddercablecombitrans;</span>
<span class="lineNum">    1632 </span><span class="lineCov">          2 :   delete localladdercablessdmodulematrix;</span>
<span class="lineNum">    1633 </span><span class="lineCov">          2 :   delete localssdsensorrot;     </span>
<span class="lineNum">    1634 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;2; i++){</span>
<span class="lineNum">    1635 </span><span class="lineCov">          4 :         delete localssdsensortrans[i];</span>
<span class="lineNum">    1636 </span><span class="lineCov">          4 :         delete localssdsensorcombitrans[i];</span>
<span class="lineNum">    1637 </span>            :   }
<span class="lineNum">    1638 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++){</span>
<span class="lineNum">    1639 </span><span class="lineCov">        148 :         for(Int_t j=0; j&lt;kssdlayladdernumber[i]; j++){</span>
<span class="lineNum">    1640 </span><span class="lineCov">        144 :                 delete locallayerrot[i][j];</span>
<span class="lineNum">    1641 </span><span class="lineCov">        144 :                 delete locallayertrans[i][j];</span>
<span class="lineNum">    1642 </span><span class="lineCov">        144 :                 delete locallayercombitrans[i][j];</span>
<span class="lineNum">    1643 </span>            :     }
<span class="lineNum">    1644 </span><span class="lineCov">          4 :         delete [] locallayerrot[i];</span>
<span class="lineNum">    1645 </span><span class="lineCov">          4 :         delete [] locallayertrans[i];</span>
<span class="lineNum">    1646 </span><span class="lineCov">          4 :         delete [] locallayercombitrans[i];</span>
<span class="lineNum">    1647 </span><span class="lineCov">          4 :         delete localbeamaxistrans[i];</span>
<span class="lineNum">    1648 </span>            :   }
<span class="lineNum">    1649 </span><span class="lineCov">         14 :   for(Int_t i=0; i&lt;3; i++) delete itscenterrot[i];</span>
<span class="lineNum">    1650 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkladdernumber; i++){</span>
<span class="lineNum">    1651 </span><span class="lineCov">         12 :         for(Int_t j=0; j&lt;fgkladdernumber; j++)</span>
<span class="lineNum">    1652 </span><span class="lineCov">          8 :                 delete ladderglobalmatrix[i][j];</span>
<span class="lineNum">    1653 </span><span class="lineCov">          4 :         delete [] ladderglobalmatrix[i];</span>
<span class="lineNum">    1654 </span>            :   }
<span class="lineNum">    1655 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1656 </span><span class="lineCov">          1 :   fTransformationMatrices = kTRUE;      </span>
<a name="1657"><span class="lineNum">    1657 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">    1658 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    1659 </span>            : void AliITSv11GeometrySSD::CreateBasicObjects(){
<span class="lineNum">    1660 </span>            :   /////////////////////////////////////////////////////////////  
<span class="lineNum">    1661 </span>            :   // Method generating the Objects of SSD Geometry    
<span class="lineNum">    1662 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1663 </span>            :   // SSD Sensor
<span class="lineNum">    1664 </span>            :   ///////////////////////////////////
<span class="lineNum">    1665 </span><span class="lineCov">          2 :   SetSSDSensor();</span>
<span class="lineNum">    1666 </span>            :   /////////////////////////////////////////////////////////////  
<span class="lineNum">    1667 </span>            :   // Carbon Fiber Support    
<span class="lineNum">    1668 </span>            :   /////////////////////////////////////////////////////////////  
<span class="lineNum">    1669 </span><span class="lineCov">          1 :   TList* carbonfibersupportlist = GetCarbonFiberSupportList();  </span>
<span class="lineNum">    1670 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkcarbonfibersupportnumber; i++) </span>
<span class="lineNum">    1671 </span><span class="lineCov">          2 :       fcarbonfibersupport[i] = (TGeoVolume*)carbonfibersupportlist-&gt;At(i);</span>
<span class="lineNum">    1672 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1673 </span>            :   // Carbon Fiber Junction 
<span class="lineNum">    1674 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1675 </span><span class="lineCov">          1 :   fcarbonfiberjunction = GetCarbonFiberJunction(fgkCarbonFiberJunctionWidth-fgkSSDTolerance);</span>
<span class="lineNum">    1676 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1677 </span>            :   // Carbon Fiber Lower Support
<span class="lineNum">    1678 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1679 </span><span class="lineCov">          1 :   TList* carbonfiberlowersupportlist = GetCarbonFiberLowerSupportList();</span>
<span class="lineNum">    1680 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkcarbonfiberlowersupportnumber; i++)</span>
<span class="lineNum">    1681 </span><span class="lineCov">          2 :         fcarbonfiberlowersupport[i] = (TGeoVolume*)carbonfiberlowersupportlist-&gt;At(i);</span>
<span class="lineNum">    1682 </span>            :   /////////////////////////////
<span class="lineNum">    1683 </span>            :   // SSD Sensor Support
<span class="lineNum">    1684 </span>            :   /////////////////////////////
<span class="lineNum">    1685 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkvolumekind; i++) fssdsensorsupport[i] = </span>
<span class="lineNum">    1686 </span><span class="lineCov">          2 :                                                                                 new TGeoVolume*[fgkssdsensorsupportnumber]; </span>
<span class="lineNum">    1687 </span><span class="lineCov">          2 :   Double_t sidesupporthickness[2] = {fgkSSDSensorSideSupportThickness[0],</span>
<span class="lineNum">    1688 </span><span class="lineCov">          1 :                                                                          fgkSSDSensorSideSupportThickness[1]};</span>
<span class="lineNum">    1689 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkssdsensorsupportnumber-1; i++){</span>
<span class="lineNum">    1690 </span><span class="lineCov">          4 :         fssdsensorsupport[0][i] = GetSSDSensorSupport(fgkSSDSensorSideSupportLength,</span>
<span class="lineNum">    1691 </span><span class="lineCov">          2 :                                                                                            fgkSSDSensorSideSupportHeight[i],</span>
<span class="lineNum">    1692 </span><span class="lineCov">          2 :                                                                                            fgkSSDSensorSideSupportWidth,</span>
<span class="lineNum">    1693 </span><span class="lineCov">          2 :                                                                                            sidesupporthickness);  </span>
<span class="lineNum">    1694 </span><span class="lineCov">          4 :         fssdsensorsupport[1][i] = GetSSDSensorSupport(fgkSSDSensorCenterSupportLength,</span>
<span class="lineNum">    1695 </span><span class="lineCov">          2 :                                                                                            fgkSSDSensorCenterSupportHeight[i],</span>
<span class="lineNum">    1696 </span><span class="lineCov">          2 :                                                                                            fgkSSDSensorCenterSupportWidth,</span>
<span class="lineNum">    1697 </span>            :                                                                                            sidesupporthickness);
<span class="lineNum">    1698 </span>            :   }
<span class="lineNum">    1699 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1700 </span>            :   // SSD Cooling Tube Support
<span class="lineNum">    1701 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1702 </span>            :   Int_t edgesnumber = 3;
<span class="lineNum">    1703 </span><span class="lineCov">          1 :   fcoolingtubesupport = GetCoolingTubeSupport(edgesnumber);       </span>
<span class="lineNum">    1704 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1705 </span>            :   // SSD Hybrid
<span class="lineNum">    1706 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1707 </span><span class="lineCov">          1 :   TList* ssdhybridcomponentslist = GetSSDHybridParts();</span>
<span class="lineNum">    1708 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;fgkhybridcompnumber; i++) </span>
<span class="lineNum">    1709 </span><span class="lineCov">          3 :         fssdhybridcomponent[i] = (TGeoVolume*)ssdhybridcomponentslist-&gt;At(i);</span>
<span class="lineNum">    1710 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1711 </span>            :   // SSD Cooling Block System
<span class="lineNum">    1712 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1713 </span><span class="lineCov">          1 :   fssdcoolingblocksystem = GetCoolingBlockSystem();</span>
<span class="lineNum">    1714 </span>            :    /////////////////////////////////////////////////////////////
<span class="lineNum">    1715 </span>            :   // SSD Cooling Tube
<span class="lineNum">    1716 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1717 </span><span class="lineCov">          1 :   CreateCoolingTubes();</span>
<span class="lineNum">    1718 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1719 </span>            :   // SSD Flex  
<span class="lineNum">    1720 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1721 </span><span class="lineCov">          1 :   fssdstiffenerflex = GetSSDStiffenerFlex();</span>
<span class="lineNum">    1722 </span><span class="lineCov">          1 :   fssdendflex = GetSSDEndFlex();</span>
<span class="lineNum">    1723 </span>            :   ///////////////////////////////////
<span class="lineNum">    1724 </span>            :   // End Ladder Carbon Fiber Junction
<span class="lineNum">    1725 </span>            :   ///////////////////////////////////
<span class="lineNum">    1726 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkendlabbercarbonfiberjunctionumber; i++) </span>
<span class="lineNum">    1727 </span><span class="lineCov">          2 :                                                    fendladdercarbonfiberjunction[i] = </span>
<span class="lineNum">    1728 </span><span class="lineCov">          2 :                                                    new TGeoVolume*[fgkendlabbercarbonfiberjunctionumber];</span>
<span class="lineNum">    1729 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkendlabbercarbonfiberjunctionumber; i++){</span>
<span class="lineNum">    1730 </span><span class="lineCov">          2 :     fendladdercarbonfiberjunction[i][0] = </span>
<span class="lineNum">    1731 </span><span class="lineCov">          2 :                   GetCarbonFiberJunction(fgkEndLadderCarbonFiberLowerJunctionLength[i]-fgkSSDTolerance);</span>
<span class="lineNum">    1732 </span><span class="lineCov">          2 :     fendladdercarbonfiberjunction[i][1] = </span>
<span class="lineNum">    1733 </span><span class="lineCov">          2 :                   GetCarbonFiberJunction(fgkEndLadderCarbonFiberUpperJunctionLength[i]-fgkSSDTolerance);</span>
<span class="lineNum">    1734 </span>            :   }
<span class="lineNum">    1735 </span>            :   ///////////////////////////////////
<span class="lineNum">    1736 </span>            :   // End Ladder Mounting Block
<span class="lineNum">    1737 </span>            :   ///////////////////////////////////
<span class="lineNum">    1738 </span><span class="lineCov">          1 :   fendladdermountingblock = GetSSDMountingBlock();</span>
<span class="lineNum">    1739 </span>            :   ///////////////////////////////////
<span class="lineNum">    1740 </span>            :   // End Ladder Mounting Block
<span class="lineNum">    1741 </span>            :   ///////////////////////////////////
<span class="lineNum">    1742 </span><span class="lineCov">          1 :   fendladdermountingblockclip = GetMountingBlockClip();</span>
<span class="lineNum">    1743 </span>            :   ///////////////////////////////////
<span class="lineNum">    1744 </span>            :   // Ladder Support 
<span class="lineNum">    1745 </span>            :   ///////////////////////////////////
<span class="lineNum">    1746 </span><span class="lineCov">          1 :   TList* laddersupportlist = GetMountingBlockSupport(20);</span>
<span class="lineNum">    1747 </span><span class="lineCov">          1 :   fLay5LadderSupport[0] = (TGeoVolume*)laddersupportlist-&gt;At(0);</span>
<span class="lineNum">    1748 </span><span class="lineCov">          1 :   fLay5LadderSupport[1] = (TGeoVolume*)laddersupportlist-&gt;At(1);</span>
<span class="lineNum">    1749 </span><span class="lineCov">          1 :   fLay6LadderSupport[0] = (TGeoVolume*)laddersupportlist-&gt;At(2);</span>
<span class="lineNum">    1750 </span><span class="lineCov">          1 :   fLay6LadderSupport[1] = (TGeoVolume*)laddersupportlist-&gt;At(3);</span>
<span class="lineNum">    1751 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1752 </span>            :   // Deallocating memory
<span class="lineNum">    1753 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1754 </span><span class="lineCov">          2 :   delete carbonfibersupportlist;</span>
<span class="lineNum">    1755 </span><span class="lineCov">          2 :   delete carbonfiberlowersupportlist;</span>
<span class="lineNum">    1756 </span><span class="lineCov">          2 :   delete ssdhybridcomponentslist;</span>
<span class="lineNum">    1757 </span><span class="lineCov">          2 :   delete laddersupportlist;</span>
<span class="lineNum">    1758 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1759 </span><span class="lineCov">          1 :   fBasicObjects = kTRUE;</span>
<a name="1760"><span class="lineNum">    1760 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">    1761 </span>            : /////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    1762 </span>            : void AliITSv11GeometrySSD::SetSSDSensor(){
<span class="lineNum">    1763 </span>            :   ////////////////////////////////////////////////////////////////
<span class="lineNum">    1764 </span>            :   // Method generating SSD Sensors: it sets the private variables
<span class="lineNum">    1765 </span>            :   // fSSDSensor5, fSSDSensor6  
<span class="lineNum">    1766 </span>            :   ////////////////////////////////////////////////////////////////
<span class="lineNum">    1767 </span><span class="lineCov">          2 :   Double_t ssdsensitivelength = fgkSSDSensorLength-2.*fgkSSDSensorInsensitiveLength;</span>
<span class="lineNum">    1768 </span><span class="lineCov">          1 :   Double_t ssdsensitivewidth  = fgkSSDSensorWidth-2.*fgkSSDSensorInsensitiveWidth;</span>
<span class="lineNum">    1769 </span><span class="lineCov">          2 :   TGeoBBox* ssdsensorsensitiveshape = new TGeoBBox(&quot;SSDSensorSensitiveShape&quot;,</span>
<span class="lineNum">    1770 </span><span class="lineCov">          1 :                                                 0.5*ssdsensitivewidth,</span>
<span class="lineNum">    1771 </span><span class="lineCov">          1 :                                                 0.5*fgkSSDSensorHeight,</span>
<span class="lineNum">    1772 </span><span class="lineCov">          1 :                                                 0.5*ssdsensitivelength);</span>
<span class="lineNum">    1773 </span>            :   TGeoVolume* ssdsensorsensitiveLay5 = 
<span class="lineNum">    1774 </span><span class="lineCov">          1 :         new TGeoVolume(fgkSSDsensitiveVolName5,ssdsensorsensitiveshape,fSSDSensorMedium);</span>
<span class="lineNum">    1775 </span>            :   TGeoVolume* ssdsensorsensitiveLay6 = 
<span class="lineNum">    1776 </span><span class="lineCov">          1 :         new TGeoVolume(fgkSSDsensitiveVolName6,ssdsensorsensitiveshape,fSSDSensorMedium);</span>
<span class="lineNum">    1777 </span><span class="lineCov">          1 :   ssdsensorsensitiveLay5-&gt;SetLineColor(fColorSilicon);</span>
<span class="lineNum">    1778 </span><span class="lineCov">          1 :   ssdsensorsensitiveLay6-&gt;SetLineColor(fColorSilicon);</span>
<span class="lineNum">    1779 </span><span class="lineCov">          1 :   TGeoBBox* ssdsensorinsensitiveshape[2];</span>
<span class="lineNum">    1780 </span><span class="lineCov">          3 :   ssdsensorinsensitiveshape[0] = new TGeoBBox(&quot;SSDSensorInsensitiveShape1&quot;,</span>
<span class="lineNum">    1781 </span><span class="lineCov">          1 :                                                 0.5*fgkSSDSensorInsensitiveWidth,</span>
<span class="lineNum">    1782 </span><span class="lineCov">          1 :                                                 0.5*fgkSSDSensorHeight,</span>
<span class="lineNum">    1783 </span><span class="lineCov">          1 :                                                 0.5*fgkSSDSensorLength);</span>
<span class="lineNum">    1784 </span><span class="lineCov">          3 :   ssdsensorinsensitiveshape[1] = new TGeoBBox(&quot;SSDSensorInsensitiveShape2&quot;,</span>
<span class="lineNum">    1785 </span>            :                                                 0.5*ssdsensitivewidth,
<span class="lineNum">    1786 </span><span class="lineCov">          1 :                                                 0.5*fgkSSDSensorHeight,</span>
<span class="lineNum">    1787 </span><span class="lineCov">          1 :                                                 0.5*fgkSSDSensorInsensitiveWidth);</span>
<span class="lineNum">    1788 </span><span class="lineCov">          1 :   const char* ssdsensorinsensitivename[2] = {&quot;SSDSensorInsensitive1&quot;,</span>
<span class="lineNum">    1789 </span>            :                                              &quot;SSDSensorInsensitive2&quot;};
<span class="lineNum">    1790 </span><span class="lineCov">          1 :   TGeoVolume* ssdsensorinsensitive[2];</span>
<span class="lineNum">    1791 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;2; i++){ ssdsensorinsensitive[i] = </span>
<span class="lineNum">    1792 </span><span class="lineCov">          4 :       new TGeoVolume(ssdsensorinsensitivename[i],ssdsensorinsensitiveshape[i],</span>
<span class="lineNum">    1793 </span><span class="lineCov">          2 :                      fSSDSensorMedium);</span>
<span class="lineNum">    1794 </span><span class="lineCov">          2 :       ssdsensorinsensitive[i]-&gt;SetLineColor(fColorCarbonFiber);</span>
<span class="lineNum">    1795 </span>            :   }
<span class="lineNum">    1796 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1797 </span>            :   // Virtual Volume containing SSD Sensor  
<span class="lineNum">    1798 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1799 </span><span class="lineCov">          2 :   TGeoBBox* virtualSSDSensorShape = new TGeoBBox(&quot;SSDSensorShape&quot;,</span>
<span class="lineNum">    1800 </span><span class="lineCov">          1 :                                                                                              0.5*fgkSSDSensorWidth,</span>
<span class="lineNum">    1801 </span><span class="lineCov">          1 :                                                                                              0.5*fgkSSDSensorHeight,</span>
<span class="lineNum">    1802 </span><span class="lineCov">          1 :                                                                                              0.5*fgkSSDSensorLength);</span>
<span class="lineNum">    1803 </span><span class="lineCov">          3 :   fSSDSensor5 = new TGeoVolume(&quot;ITSssdSensor5&quot;,virtualSSDSensorShape,</span>
<span class="lineNum">    1804 </span><span class="lineCov">          1 :                                                                                  fSSDAir);      </span>
<span class="lineNum">    1805 </span><span class="lineCov">          3 :   fSSDSensor6 = new TGeoVolume(&quot;ITSssdSensor6&quot;,virtualSSDSensorShape,</span>
<span class="lineNum">    1806 </span><span class="lineCov">          1 :                                                                                  fSSDAir);      </span>
<span class="lineNum">    1807 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1808 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;4; i++){ </span>
<span class="lineNum">    1809 </span><span class="lineCov">         12 :             fSSDSensor5-&gt;AddNode(i%2==0 ? ssdsensorinsensitive[0]:</span>
<span class="lineNum">    1810 </span><span class="lineCov">          8 :             ssdsensorinsensitive[1],i&lt;2?1:2,</span>
<span class="lineNum">    1811 </span><span class="lineCov">         12 :                         new TGeoTranslation(</span>
<span class="lineNum">    1812 </span><span class="lineCov">          4 :                          0.5*(1.+TMath::Power(-1.,i))*(i==0?-1.: 1.)</span>
<span class="lineNum">    1813 </span><span class="lineCov">         12 :       *   (ssdsensorsensitiveshape-&gt;GetDX()+ssdsensorinsensitiveshape[0]-&gt;GetDX()),0.,                    </span>
<span class="lineNum">    1814 </span><span class="lineCov">          4 :                         0.5*(1.-TMath::Power(-1.,i))*(i==1? 1.:-1.)</span>
<span class="lineNum">    1815 </span><span class="lineCov">         12 :       *   (ssdsensorsensitiveshape-&gt;GetDZ()+ssdsensorinsensitiveshape[1]-&gt;GetDZ())));    </span>
<span class="lineNum">    1816 </span><span class="lineCov">         12 :             fSSDSensor6-&gt;AddNode(i%2==0 ? ssdsensorinsensitive[0]:</span>
<span class="lineNum">    1817 </span><span class="lineCov">          4 :             ssdsensorinsensitive[1],i&lt;2?1:2,</span>
<span class="lineNum">    1818 </span><span class="lineCov">         12 :                         new TGeoTranslation(</span>
<span class="lineNum">    1819 </span><span class="lineCov">          4 :                          0.5*(1.+TMath::Power(-1.,i))*(i==0?-1.: 1.)</span>
<span class="lineNum">    1820 </span><span class="lineCov">         12 :       *   (ssdsensorsensitiveshape-&gt;GetDX()+ssdsensorinsensitiveshape[0]-&gt;GetDX()),0.,                    </span>
<span class="lineNum">    1821 </span><span class="lineCov">          4 :                         0.5*(1.-TMath::Power(-1.,i))*(i==1? 1.:-1.)</span>
<span class="lineNum">    1822 </span><span class="lineCov">         12 :       *   (ssdsensorsensitiveshape-&gt;GetDZ()+ssdsensorinsensitiveshape[1]-&gt;GetDZ())));    </span>
<span class="lineNum">    1823 </span>            :   }
<span class="lineNum">    1824 </span><span class="lineCov">          1 :     fSSDSensor5-&gt;AddNode(ssdsensorsensitiveLay5,1);</span>
<span class="lineNum">    1825 </span><span class="lineCov">          1 :     fSSDSensor6-&gt;AddNode(ssdsensorsensitiveLay6,1);</span>
<a name="1826"><span class="lineNum">    1826 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">    1827 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    1828 </span>            : TList* AliITSv11GeometrySSD::GetCarbonFiberSupportList(){
<span class="lineNum">    1829 </span>            :   /////////////////////////////////////////////////////////////  
<span class="lineNum">    1830 </span>            :   // Method generating the Carbon Fiber Support   
<span class="lineNum">    1831 </span>            :   /////////////////////////////////////////////////////////////  
<span class="lineNum">    1832 </span>            :   const Int_t kvertexnumber = 4;
<span class="lineNum">    1833 </span>            :   const Int_t kshapesnumber = 2;
<span class="lineNum">    1834 </span><span class="lineCov">          2 :   TVector3** vertexposition[kshapesnumber];</span>
<span class="lineNum">    1835 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;kshapesnumber; i++) vertexposition[i] = new TVector3*[kvertexnumber];</span>
<span class="lineNum">    1836 </span>            :   Double_t carbonfibersupportxaxisEdgeproj = 
<span class="lineNum">    1837 </span><span class="lineCov">          2 :                 fgkCarbonFiberSupportEdgeLength*TMath::Cos(fgkCarbonFiberJunctionAngle[0]</span>
<span class="lineNum">    1838 </span><span class="lineCov">          1 :         *       TMath::DegToRad());</span>
<span class="lineNum">    1839 </span><span class="lineCov">          2 :   Double_t theta = TMath::ATan(fgkCarbonFiberSupportYAxisLength</span>
<span class="lineNum">    1840 </span><span class="lineCov">          1 :                                  /                         fgkCarbonFiberSupportXAxisLength);</span>
<span class="lineNum">    1841 </span>            :   /////////////////////
<span class="lineNum">    1842 </span>            :   //Vertex Positioning
<span class="lineNum">    1843 </span>            :   ////////////////////
<span class="lineNum">    1844 </span><span class="lineCov">          2 :   vertexposition[0][0] = new TVector3();</span>
<span class="lineNum">    1845 </span><span class="lineCov">          3 :   vertexposition[0][1] = new TVector3(fgkCarbonFiberSupportXAxisLength,</span>
<span class="lineNum">    1846 </span><span class="lineCov">          1 :                                       fgkCarbonFiberSupportYAxisLength, 0);</span>
<span class="lineNum">    1847 </span><span class="lineCov">          3 :   vertexposition[0][2] = new TVector3(carbonfibersupportxaxisEdgeproj,</span>
<span class="lineNum">    1848 </span>            :                                                                           carbonfibersupportxaxisEdgeproj
<span class="lineNum">    1849 </span><span class="lineCov">          1 :                                       *                   TMath::Tan(theta), 0);</span>
<span class="lineNum">    1850 </span><span class="lineCov">          3 :   vertexposition[0][3] = new TVector3(fgkCarbonFiberSupportXAxisLength</span>
<span class="lineNum">    1851 </span><span class="lineCov">          1 :                                            -                      carbonfibersupportxaxisEdgeproj,</span>
<span class="lineNum">    1852 </span><span class="lineCov">          1 :                                                                           fgkCarbonFiberSupportYAxisLength</span>
<span class="lineNum">    1853 </span><span class="lineCov">          1 :                                       - vertexposition[0][2]-&gt;Y(), 0);</span>
<span class="lineNum">    1854 </span>            :   ////////////////////////////////////////////////////
<span class="lineNum">    1855 </span>            :   //Setting the parameters for Isometry Transformation
<span class="lineNum">    1856 </span>            :   ////////////////////////////////////////////////////
<span class="lineNum">    1857 </span><span class="lineCov">          1 :   Double_t symmetryplaneposition = (fgkCarbonFiberSupportYAxisLength</span>
<span class="lineNum">    1858 </span><span class="lineCov">          1 :                                                                  +      fgkCarbonFiberSupportTopEdgeDist[0]</span>
<span class="lineNum">    1859 </span><span class="lineCov">          1 :                                                                  +      fgkCarbonFiberSupportWidth);</span>
<span class="lineNum">    1860 </span><span class="lineCov">          1 :   Double_t* param = new Double_t[4]; </span>
<span class="lineNum">    1861 </span><span class="lineCov">          1 :   param[0] = 0., param[1] = 1., param[2] = 0., param[3] = -symmetryplaneposition;</span>
<span class="lineNum">    1862 </span><span class="lineCov">         10 :   for(Int_t j=0; j&lt;kvertexnumber; j++) vertexposition[1][j] = </span>
<span class="lineNum">    1863 </span><span class="lineCov">         12 :     new TVector3((GetReflection(vertexposition[0][j],param))-&gt;X(),</span>
<span class="lineNum">    1864 </span><span class="lineCov">          8 :                  (GetReflection(vertexposition[0][j],param))-&gt;Y(), 0);</span>
<span class="lineNum">    1865 </span><span class="lineCov">          1 :   const char* carbonfibersupportshapename[kshapesnumber] = </span>
<span class="lineNum">    1866 </span>            :                                                 {&quot;CarbonFiberSupportShape1&quot;,&quot;CarbonFiberSupportShape2&quot;};
<span class="lineNum">    1867 </span><span class="lineCov">          1 :   const char* carbonfibersupportname[kshapesnumber] = </span>
<span class="lineNum">    1868 </span>            :                                                 {&quot;CarbonFiberSupport1&quot;,&quot;CarbonFiberSupport2&quot;};
<span class="lineNum">    1869 </span><span class="lineCov">          1 :   TGeoArb8* carbonfibersupportshape[kshapesnumber]; </span>
<span class="lineNum">    1870 </span><span class="lineCov">          1 :   TGeoVolume* carbonfibersupport[kshapesnumber];</span>
<span class="lineNum">    1871 </span><span class="lineCov">          1 :   TList* carbonfibersupportlist = new TList();</span>
<span class="lineNum">    1872 </span><span class="lineCov">          1 :   Double_t width[2] = {fgkCarbonFiberSupportWidth,fgkCarbonFiberSupportWidth};</span>
<span class="lineNum">    1873 </span>            :   Double_t carbonfibersupportheight = 
<span class="lineNum">    1874 </span><span class="lineCov">          1 :           carbonfibersupportxaxisEdgeproj*TMath::Tan(fgkCarbonFiberJunctionAngle[0]</span>
<span class="lineNum">    1875 </span><span class="lineCov">          1 :           *TMath::DegToRad());</span>
<span class="lineNum">    1876 </span><span class="lineCov">          6 :   for(Int_t i = 0; i&lt; kshapesnumber; i++){</span>
<span class="lineNum">    1877 </span><span class="lineCov">          2 :    carbonfibersupportshape[i] = </span>
<span class="lineNum">    1878 </span><span class="lineCov">          4 :                                         GetArbShape(vertexposition[i],width,carbonfibersupportheight,</span>
<span class="lineNum">    1879 </span><span class="lineCov">          2 :                                                                 carbonfibersupportshapename[i],i==0 ? 1: -1);</span>
<span class="lineNum">    1880 </span><span class="lineCov">          6 :    carbonfibersupport[i] = new TGeoVolume(carbonfibersupportname[i],</span>
<span class="lineNum">    1881 </span><span class="lineCov">          2 :                                                    carbonfibersupportshape[i],fSSDCarbonFiberMedium);</span>
<span class="lineNum">    1882 </span><span class="lineCov">          2 :    carbonfibersupport[i]-&gt;SetLineColor(fColorCarbonFiber);</span>
<span class="lineNum">    1883 </span><span class="lineCov">          2 :    carbonfibersupportlist-&gt;Add(carbonfibersupport[i]);       </span>
<span class="lineNum">    1884 </span>            :    }
<span class="lineNum">    1885 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1886 </span>            :   // Deallocating memory
<span class="lineNum">    1887 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1888 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt; kshapesnumber; i++){</span>
<span class="lineNum">    1889 </span><span class="lineCov">         20 :      for(Int_t j=0; j&lt; kvertexnumber; j++)</span>
<span class="lineNum">    1890 </span><span class="lineCov">         16 :            delete vertexposition[i][j];</span>
<span class="lineNum">    1891 </span><span class="lineCov">          4 :        delete [] vertexposition[i];</span>
<span class="lineNum">    1892 </span>            :   }
<span class="lineNum">    1893 </span><span class="lineCov">          2 :   delete [] param;</span>
<span class="lineNum">    1894 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1895 </span><span class="lineCov">          1 :    return carbonfibersupportlist;</span>
<a name="1896"><span class="lineNum">    1896 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">    1897 </span>            : /////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    1898 </span>            : TGeoVolume* AliITSv11GeometrySSD::GetCarbonFiberJunction(Double_t width){
<span class="lineNum">    1899 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1900 </span>            :   // Method generating SSD Carbon Fiber Junction
<span class="lineNum">    1901 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1902 </span>            :   const Int_t kvertexnumber = 6;
<span class="lineNum">    1903 </span><span class="lineCov">         10 :   TGeoXtru* carbonfiberjunctionshape = new TGeoXtru(2);</span>
<span class="lineNum">    1904 </span><span class="lineCov">         10 :   Double_t reflectionparam[4] = {TMath::Tan(fgkCarbonFiberJunctionAngle[0]</span>
<span class="lineNum">    1905 </span><span class="lineCov">          5 :                                             *  TMath::DegToRad()),-1.,0.,0.};</span>
<span class="lineNum">    1906 </span><span class="lineCov">          5 :   TVector3* vertex[kvertexnumber];</span>
<span class="lineNum">    1907 </span><span class="lineCov">         10 :   vertex[0] = new TVector3();</span>
<span class="lineNum">    1908 </span><span class="lineCov">         15 :   vertex[3] = new TVector3(fgkCarbonFiberJunctionEdge[0]</span>
<span class="lineNum">    1909 </span><span class="lineCov">          5 :                         *                         TMath::Cos(fgkCarbonFiberJunctionAngle[0]</span>
<span class="lineNum">    1910 </span><span class="lineCov">         10 :                         *                         TMath::DegToRad()),</span>
<span class="lineNum">    1911 </span><span class="lineCov">          5 :                                                   fgkCarbonFiberJunctionEdge[0]</span>
<span class="lineNum">    1912 </span><span class="lineCov">          5 :                         *                         TMath::Sin(fgkCarbonFiberJunctionAngle[0]</span>
<span class="lineNum">    1913 </span><span class="lineCov">         10 :                                         * TMath::DegToRad()), 0);</span>
<span class="lineNum">    1914 </span><span class="lineCov">         15 :   vertex[4] = new TVector3(fgkCarbonFiberJunctionLength-fgkSSDTolerance,</span>
<span class="lineNum">    1915 </span><span class="lineCov">          5 :                            fgkCarbonFiberJunctionEdge[1], 0);</span>
<span class="lineNum">    1916 </span><span class="lineCov">         10 :   vertex[5] = new TVector3(fgkCarbonFiberJunctionLength-fgkSSDTolerance, 0, 0); </span>
<span class="lineNum">    1917 </span><span class="lineCov">          5 :   vertex[1] = GetReflection(vertex[5],reflectionparam); </span>
<span class="lineNum">    1918 </span><span class="lineCov">          5 :   vertex[2] = GetReflection(vertex[4],reflectionparam); </span>
<span class="lineNum">    1919 </span><span class="lineCov">          5 :   Double_t xvertexpoints[6], yvertexpoints[6];</span>
<span class="lineNum">    1920 </span><span class="lineCov">         70 :   for(Int_t i=0; i&lt;kvertexnumber; i++) </span>
<span class="lineNum">    1921 </span><span class="lineCov">         30 :           xvertexpoints[i] = vertex[i]-&gt;X(), yvertexpoints[i] = vertex[i]-&gt;Y();</span>
<span class="lineNum">    1922 </span><span class="lineCov">          5 :   carbonfiberjunctionshape-&gt;DefinePolygon(kvertexnumber,xvertexpoints,yvertexpoints);</span>
<span class="lineNum">    1923 </span><span class="lineCov">          5 :   carbonfiberjunctionshape-&gt;DefineSection(0,-0.5*width);</span>
<span class="lineNum">    1924 </span><span class="lineCov">          5 :   carbonfiberjunctionshape-&gt;DefineSection(1,0.5*width);</span>
<span class="lineNum">    1925 </span><span class="lineCov">         10 :   TGeoVolume* carbonfiberjunction = new TGeoVolume(&quot;CarbonFiberJunction&quot;,</span>
<span class="lineNum">    1926 </span><span class="lineCov">          5 :                                                                 carbonfiberjunctionshape,fSSDCarbonFiberMedium);</span>
<span class="lineNum">    1927 </span><span class="lineCov">          5 :   carbonfiberjunction-&gt;SetLineColor(fColorCarbonFiber);</span>
<span class="lineNum">    1928 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1929 </span>            :   // Deallocating memory
<span class="lineNum">    1930 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1931 </span><span class="lineCov">        130 :   for (Int_t i=0; i&lt;kvertexnumber; i++) delete vertex[i];</span>
<span class="lineNum">    1932 </span>            :   ///////////////////////////////////////////////////////////// 
<span class="lineNum">    1933 </span><span class="lineCov">          5 :   return carbonfiberjunction;</span>
<a name="1934"><span class="lineNum">    1934 </span><span class="lineCov">          5 : }</span></a>
<span class="lineNum">    1935 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    1936 </span>            : TList* AliITSv11GeometrySSD::GetCarbonFiberLowerSupportList(){
<span class="lineNum">    1937 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1938 </span>            :   // Method generating the Carbon Fiber Lower Support   
<span class="lineNum">    1939 </span>            :   /////////////////////////////////////////////////////////////  
<span class="lineNum">    1940 </span>            :   const Int_t kvertexnumber = 4;
<span class="lineNum">    1941 </span>            :   const Int_t kshapesnumber = 2;
<span class="lineNum">    1942 </span><span class="lineCov">          3 :   Double_t width[2] = {fgkCarbonFiberLowerSupportWidth,</span>
<span class="lineNum">    1943 </span><span class="lineCov">          1 :                                                                 fgkCarbonFiberLowerSupportWidth};</span>
<span class="lineNum">    1944 </span><span class="lineCov">          1 :   TVector3** vertexposition[kshapesnumber];</span>
<span class="lineNum">    1945 </span><span class="lineCov">          6 :   for(Int_t i = 0; i&lt;kshapesnumber; i++) vertexposition[i] = </span>
<span class="lineNum">    1946 </span><span class="lineCov">          2 :                                                  new TVector3*[kvertexnumber];</span>
<span class="lineNum">    1947 </span>            :   //First Shape Vertex Positioning
<span class="lineNum">    1948 </span><span class="lineCov">          2 :   vertexposition[0][0] = new TVector3(fgkCarbonFiberLowerSupportLowerLenght, 0, 0);</span>
<span class="lineNum">    1949 </span><span class="lineCov">          3 :   vertexposition[0][1] = new TVector3(fgkCarbonFiberTriangleLength</span>
<span class="lineNum">    1950 </span><span class="lineCov">          1 :                                       - fgkCarbonFiberLowerSupportLowerLenght, 0, 0);</span>
<span class="lineNum">    1951 </span><span class="lineCov">          2 :   vertexposition[0][2] = new TVector3();</span>
<span class="lineNum">    1952 </span><span class="lineCov">          2 :   vertexposition[0][3] = new TVector3(fgkCarbonFiberTriangleLength, 0, 0);</span>
<span class="lineNum">    1953 </span>            :   //Second Shape Vertex Positioning
<span class="lineNum">    1954 </span><span class="lineCov">          2 :   Double_t theta = TMath::ATan((fgkCarbonFiberLowerSupportVolumePosition[1]</span>
<span class="lineNum">    1955 </span><span class="lineCov">          1 :                                  -                              fgkCarbonFiberLowerSupportVolumePosition[0])</span>
<span class="lineNum">    1956 </span><span class="lineCov">          1 :                                  /                              fgkCarbonFiberTriangleLength);</span>
<span class="lineNum">    1957 </span><span class="lineCov">          3 :   vertexposition[1][0] = new TVector3(vertexposition[0][0]-&gt;X(),</span>
<span class="lineNum">    1958 </span><span class="lineCov">          1 :                                                                 vertexposition[0][0]-&gt;X()*TMath::Tan(theta)</span>
<span class="lineNum">    1959 </span><span class="lineCov">          1 :                                       + fgkCarbonFiberLowerSupportVolumePosition[0], 0);</span>
<span class="lineNum">    1960 </span><span class="lineCov">          3 :   vertexposition[1][1] = new TVector3(vertexposition[0][1]-&gt;X(),</span>
<span class="lineNum">    1961 </span><span class="lineCov">          1 :                                                                 vertexposition[0][1]-&gt;X()*TMath::Tan(theta)</span>
<span class="lineNum">    1962 </span><span class="lineCov">          1 :                                       + fgkCarbonFiberLowerSupportVolumePosition[0], 0);</span>
<span class="lineNum">    1963 </span><span class="lineCov">          2 :   vertexposition[1][2] = new TVector3(0.,fgkCarbonFiberLowerSupportVolumePosition[0], 0);</span>
<span class="lineNum">    1964 </span><span class="lineCov">          3 :   vertexposition[1][3] = new TVector3(fgkCarbonFiberTriangleLength,</span>
<span class="lineNum">    1965 </span><span class="lineCov">          1 :                                       fgkCarbonFiberLowerSupportVolumePosition[1], 0);</span>
<span class="lineNum">    1966 </span><span class="lineCov">          1 :   const char* carbonfiberlowersupportshapename[kshapesnumber] = </span>
<span class="lineNum">    1967 </span>            :                           {&quot;CarbonFiberLowerSupportShape1&quot;,&quot;CarbonFiberLowerSupportShape2&quot;};
<span class="lineNum">    1968 </span><span class="lineCov">          1 :   const char* carbonfiberlowersupportname[kshapesnumber] = </span>
<span class="lineNum">    1969 </span>            :                           {&quot;CarbonFiberLowerSupport1&quot;,&quot;CarbonFiberLowerSupport2&quot;};
<span class="lineNum">    1970 </span><span class="lineCov">          1 :   TGeoArb8* carbonfiberlowersupportshape[kshapesnumber];</span>
<span class="lineNum">    1971 </span><span class="lineCov">          1 :   TGeoVolume* carbonfiberlowersupport[kshapesnumber];</span>
<span class="lineNum">    1972 </span><span class="lineCov">          1 :   TList* carbonfiberlowersupportlist = new TList();</span>
<span class="lineNum">    1973 </span><span class="lineCov">          6 :   for(Int_t i = 0; i&lt; kshapesnumber; i++){ </span>
<span class="lineNum">    1974 </span><span class="lineCov">          2 :         carbonfiberlowersupportshape[i] = </span>
<span class="lineNum">    1975 </span><span class="lineCov">          4 :                                                                 GetArbShape(vertexposition[i],width,</span>
<span class="lineNum">    1976 </span><span class="lineCov">          2 :                                                                                         fgkCarbonFiberLowerSupportHeight,</span>
<span class="lineNum">    1977 </span><span class="lineCov">          2 :                                                                                         carbonfiberlowersupportshapename[i]);</span>
<span class="lineNum">    1978 </span><span class="lineCov">          6 :     carbonfiberlowersupport[i] = new TGeoVolume(carbonfiberlowersupportname[i],</span>
<span class="lineNum">    1979 </span><span class="lineCov">          2 :                                                 carbonfiberlowersupportshape[i],fSSDCarbonFiberMedium);</span>
<span class="lineNum">    1980 </span><span class="lineCov">          2 :         carbonfiberlowersupport[i]-&gt;SetLineColor(fColorCarbonFiber);</span>
<span class="lineNum">    1981 </span><span class="lineCov">          2 :     carbonfiberlowersupportlist-&gt;Add(carbonfiberlowersupport[i]);</span>
<span class="lineNum">    1982 </span>            :   }
<span class="lineNum">    1983 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1984 </span>            :   // Deallocating memory
<span class="lineNum">    1985 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1986 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt; kshapesnumber; i++){</span>
<span class="lineNum">    1987 </span><span class="lineCov">         20 :      for(Int_t j=0; j&lt; kvertexnumber; j++)</span>
<span class="lineNum">    1988 </span><span class="lineCov">         16 :            delete vertexposition[i][j];</span>
<span class="lineNum">    1989 </span><span class="lineCov">          4 :        delete [] vertexposition[i];</span>
<span class="lineNum">    1990 </span>            :   }
<span class="lineNum">    1991 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1992 </span><span class="lineCov">          1 :   return carbonfiberlowersupportlist;</span>
<a name="1993"><span class="lineNum">    1993 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">    1994 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    1995 </span>            : TGeoVolume* AliITSv11GeometrySSD::GetSSDSensorSupport(Double_t length, Double_t height, 
<span class="lineNum">    1996 </span>            :                                                                  Double_t width, const Double_t* thickness)const{
<span class="lineNum">    1997 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    1998 </span>            :   // Method generating the Sensor Support   
<span class="lineNum">    1999 </span>            :   /////////////////////////////////////////////////////////////  
<span class="lineNum">    2000 </span>            :         const Int_t kvertexnumber = 6;
<span class="lineNum">    2001 </span><span class="lineCov">          8 :         TGeoXtru* ssdsensorsupportshape = new TGeoXtru(2);      </span>
<span class="lineNum">    2002 </span><span class="lineCov">          4 :     TVector3* vertexposition[kvertexnumber];</span>
<span class="lineNum">    2003 </span><span class="lineCov">          8 :         vertexposition[0] = new TVector3();     </span>
<span class="lineNum">    2004 </span><span class="lineCov">          8 :         vertexposition[1] = new TVector3(0.0,length,0); </span>
<span class="lineNum">    2005 </span><span class="lineCov">          8 :         vertexposition[2] = new TVector3(thickness[1],vertexposition[1]-&gt;Y(),0);     </span>
<span class="lineNum">    2006 </span><span class="lineCov">          8 :         vertexposition[3] = new TVector3(vertexposition[2]-&gt;X(),thickness[0],0);     </span>
<span class="lineNum">    2007 </span><span class="lineCov">          8 :         vertexposition[4] = new TVector3(height,vertexposition[3]-&gt;Y(),0);   </span>
<span class="lineNum">    2008 </span><span class="lineCov">          8 :         vertexposition[5] = new TVector3(vertexposition[4]-&gt;X(),0,0);        </span>
<span class="lineNum">    2009 </span><span class="lineCov">          4 :         Double_t xvertexpoints[6], yvertexpoints[6];</span>
<span class="lineNum">    2010 </span><span class="lineCov">         56 :         for(Int_t i=0; i&lt;kvertexnumber; i++) </span>
<span class="lineNum">    2011 </span><span class="lineCov">         24 :                 xvertexpoints[i] = vertexposition[i]-&gt;X(), </span>
<span class="lineNum">    2012 </span><span class="lineCov">         24 :                 yvertexpoints[i] = vertexposition[i]-&gt;Y();</span>
<span class="lineNum">    2013 </span><span class="lineCov">          4 :     ssdsensorsupportshape-&gt;DefinePolygon(kvertexnumber,xvertexpoints,yvertexpoints);</span>
<span class="lineNum">    2014 </span><span class="lineCov">          4 :     ssdsensorsupportshape-&gt;DefineSection(0,-0.5*width);</span>
<span class="lineNum">    2015 </span><span class="lineCov">          4 :     ssdsensorsupportshape-&gt;DefineSection(1,0.5*width);</span>
<span class="lineNum">    2016 </span><span class="lineCov">          8 :     TGeoVolume* ssdsensorsupport = new TGeoVolume(&quot;SSDSensorSupport&quot;,</span>
<span class="lineNum">    2017 </span><span class="lineCov">          4 :                                                                  ssdsensorsupportshape,fSSDSensorSupportMedium);</span>
<span class="lineNum">    2018 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2019 </span>            :   // Deallocating memory
<span class="lineNum">    2020 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2021 </span><span class="lineCov">         56 :         for (Int_t i=0; i&lt;kvertexnumber; i++)</span>
<span class="lineNum">    2022 </span><span class="lineCov">         48 :                 delete vertexposition[i];</span>
<span class="lineNum">    2023 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2024 </span><span class="lineCov">          4 :     return ssdsensorsupport;</span>
<a name="2025"><span class="lineNum">    2025 </span><span class="lineCov">          4 : }</span></a>
<span class="lineNum">    2026 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    2027 </span>            : TGeoVolume* AliITSv11GeometrySSD::GetCoolingTubeSupport(Int_t nedges){
<span class="lineNum">    2028 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2029 </span>            :   // Method generating the Cooling Tube Support
<span class="lineNum">    2030 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2031 </span><span class="lineCov">          3 :   if(nedges%2!=0) nedges--;     </span>
<span class="lineNum">    2032 </span><span class="lineCov">          1 :   const Int_t kvertexnumber = nedges+5;</span>
<span class="lineNum">    2033 </span><span class="lineCov">          2 :   Double_t phi = TMath::ASin(0.5*fgkCoolingTubeSupportHeight</span>
<span class="lineNum">    2034 </span><span class="lineCov">          2 :                            /                     fgkCoolingTubeSupportRmax)*TMath::RadToDeg();</span>
<span class="lineNum">    2035 </span><span class="lineCov">          1 :   Double_t angle = 90.+phi;</span>
<span class="lineNum">    2036 </span><span class="lineCov">          1 :   Double_t psi = 90.-phi;</span>
<span class="lineNum">    2037 </span>            :   ///////////////////////////////////////
<span class="lineNum">    2038 </span>            :   // Vertex Positioning for TGeoXTru
<span class="lineNum">    2039 </span>            :   ///////////////////////////////////////
<span class="lineNum">    2040 </span><span class="lineCov">          1 :   TVector3** vertexposition = new TVector3*[kvertexnumber];</span>
<span class="lineNum">    2041 </span>            : 
<span class="lineNum">    2042 </span><span class="lineCov">          1 :   Double_t router = fgkCoolingTubeSupportRmin/CosD(phi/nedges);  //  Recalc inner radius so that tube fits inside  </span>
<span class="lineNum">    2043 </span><span class="lineCov">          4 :   vertexposition[0] = new TVector3(router*CosD(angle),</span>
<span class="lineNum">    2044 </span><span class="lineCov">          2 :                                    router*SinD(angle), 0);</span>
<span class="lineNum">    2045 </span><span class="lineCov">          4 :   vertexposition[1] = new TVector3(fgkCoolingTubeSupportRmax*CosD(angle),</span>
<span class="lineNum">    2046 </span><span class="lineCov">          2 :                                    fgkCoolingTubeSupportRmax*SinD(angle),0);</span>
<span class="lineNum">    2047 </span><span class="lineCov">          3 :   vertexposition[2] = new TVector3(vertexposition[1]-&gt;X(),</span>
<span class="lineNum">    2048 </span><span class="lineCov">          1 :                                    fgkCoolingTubeSupportRmax, 0);</span>
<span class="lineNum">    2049 </span><span class="lineCov">          3 :   vertexposition[3] = new TVector3(-vertexposition[1]-&gt;X(),</span>
<span class="lineNum">    2050 </span><span class="lineCov">          1 :                                    fgkCoolingTubeSupportRmax, 0);</span>
<span class="lineNum">    2051 </span><span class="lineCov">          3 :   vertexposition[4] = new TVector3(-vertexposition[1]-&gt;X(),</span>
<span class="lineNum">    2052 </span><span class="lineCov">          1 :                                    vertexposition[1]-&gt;Y(), 0);</span>
<span class="lineNum">    2053 </span>            : 
<span class="lineNum">    2054 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;nedges; i++)</span>
<span class="lineNum">    2055 </span><span class="lineCov">          2 :         vertexposition[i+5] = </span>
<span class="lineNum">    2056 </span><span class="lineCov">          6 :                 new TVector3(router*CosD(psi+i*(2.*phi/nedges)),</span>
<span class="lineNum">    2057 </span><span class="lineCov">          4 :                              router*SinD(psi+i*(2.*phi/nedges)), 0);</span>
<span class="lineNum">    2058 </span>            :   ///////////////////////////////////////////////////////////////////////
<span class="lineNum">    2059 </span>            :   // TGeoXTru Volume definition for Cooling Tube Support Arc Part
<span class="lineNum">    2060 </span>            :   ///////////////////////////////////////////////////////////////////////
<span class="lineNum">    2061 </span><span class="lineCov">          1 :   TGeoXtru* coolingtubesupportarcshape = new TGeoXtru(2);       </span>
<span class="lineNum">    2062 </span><span class="lineCov">          1 :   Double_t* xvertexpoints = new Double_t[kvertexnumber];        </span>
<span class="lineNum">    2063 </span><span class="lineCov">          1 :   Double_t* yvertexpoints = new Double_t[kvertexnumber];        </span>
<span class="lineNum">    2064 </span><span class="lineCov">         16 :   for(Int_t i=0; i&lt;kvertexnumber; i++){</span>
<span class="lineNum">    2065 </span><span class="lineCov">          7 :         xvertexpoints[i] = vertexposition[i]-&gt;X();</span>
<span class="lineNum">    2066 </span><span class="lineCov">          7 :         yvertexpoints[i] = vertexposition[i]-&gt;Y();</span>
<span class="lineNum">    2067 </span>            :   } 
<span class="lineNum">    2068 </span><span class="lineCov">          1 :   coolingtubesupportarcshape-&gt;DefinePolygon(kvertexnumber,xvertexpoints,</span>
<span class="lineNum">    2069 </span>            :                                                                                         yvertexpoints);
<span class="lineNum">    2070 </span><span class="lineCov">          1 :   coolingtubesupportarcshape-&gt;DefineSection(0,-0.5*fgkCoolingTubeSupportWidth);</span>
<span class="lineNum">    2071 </span><span class="lineCov">          1 :   coolingtubesupportarcshape-&gt;DefineSection(1,0.5*fgkCoolingTubeSupportWidth);</span>
<span class="lineNum">    2072 </span><span class="lineCov">          2 :   TGeoVolume* coolingtubesupportarc = new TGeoVolume(&quot;CoolingTubeSupportArc&quot;,</span>
<span class="lineNum">    2073 </span><span class="lineCov">          1 :                                                                           coolingtubesupportarcshape,</span>
<span class="lineNum">    2074 </span><span class="lineCov">          1 :                                                                                   fSSDTubeHolderMedium);</span>
<span class="lineNum">    2075 </span><span class="lineCov">          1 :   coolingtubesupportarc-&gt;SetLineColor(fColorG10);</span>
<span class="lineNum">    2076 </span>            :   //////////////////////////////////////////////////////////////////////////
<span class="lineNum">    2077 </span>            :   // TGeoTubeSeg Volume definition for Cooling Tube Support TGeoTubeSeg Part
<span class="lineNum">    2078 </span>            :   //////////////////////////////////////////////////////////////////////////
<span class="lineNum">    2079 </span>            :   TGeoTubeSeg* coolingtubesupportsegshape = 
<span class="lineNum">    2080 </span><span class="lineCov">          2 :                                                         new TGeoTubeSeg(fgkCoolingTubeSupportRmin,</span>
<span class="lineNum">    2081 </span><span class="lineCov">          1 :                                                                                         fgkCoolingTubeSupportRmax,</span>
<span class="lineNum">    2082 </span><span class="lineCov">          1 :                                                                                         0.5*fgkCoolingTubeSupportWidth,</span>
<span class="lineNum">    2083 </span><span class="lineCov">          1 :                                                                                         phi,360-phi);</span>
<span class="lineNum">    2084 </span><span class="lineCov">          2 :   TGeoVolume* coolingtubesupportseg = new TGeoVolume(&quot;CoolingTubeSupportSeg&quot;,</span>
<span class="lineNum">    2085 </span><span class="lineCov">          1 :                                                                                         coolingtubesupportsegshape,</span>
<span class="lineNum">    2086 </span><span class="lineCov">          1 :                                                                                         fSSDTubeHolderMedium);</span>
<span class="lineNum">    2087 </span><span class="lineCov">          1 :   coolingtubesupportseg-&gt;SetLineColor(fColorG10);</span>
<span class="lineNum">    2088 </span>            :   //////////////////////////////////////////////////////////////////////////
<span class="lineNum">    2089 </span>            :   // TGeoBBox Volume definition for Cooling Tube Support Box Part
<span class="lineNum">    2090 </span>            :   //////////////////////////////////////////////////////////////////////////
<span class="lineNum">    2091 </span><span class="lineCov">          1 :   Double_t* boxorigin = new Double_t[3];</span>
<span class="lineNum">    2092 </span><span class="lineCov">          1 :   Double_t boxlength = fgkCoolingTubeSupportLength-2.*fgkCoolingTubeSupportRmax;</span>
<span class="lineNum">    2093 </span><span class="lineCov">          1 :   boxorigin[0] = fgkCoolingTubeSupportRmax+0.5*boxlength, boxorigin[1] = boxorigin[2] = 0.;</span>
<span class="lineNum">    2094 </span><span class="lineCov">          2 :   TGeoBBox* coolingtubesupportboxshape = new TGeoBBox(0.5*boxlength,</span>
<span class="lineNum">    2095 </span><span class="lineCov">          1 :                                                                                  0.5*fgkCoolingTubeSupportHeight,</span>
<span class="lineNum">    2096 </span><span class="lineCov">          1 :                                                                                  0.5*fgkCoolingTubeSupportWidth,boxorigin);</span>
<span class="lineNum">    2097 </span><span class="lineCov">          2 :   TGeoVolume* coolingtubesupportbox = new TGeoVolume(&quot;CoolingTubeSupportBox&quot;,</span>
<span class="lineNum">    2098 </span><span class="lineCov">          1 :                                coolingtubesupportboxshape,fSSDTubeHolderMedium);</span>
<span class="lineNum">    2099 </span><span class="lineCov">          1 :   coolingtubesupportbox-&gt;SetLineColor(fColorG10);</span>
<span class="lineNum">    2100 </span>            :   //////////////////////////////////////////////////////////////////////////
<span class="lineNum">    2101 </span>            :   // Cooling Tube for Cooling Tube Support 
<span class="lineNum">    2102 </span>            :   //////////////////////////////////////////////////////////////////////////
<span class="lineNum">    2103 </span>            :   TGeoXtru* coolingtubearcshape[2];
<span class="lineNum">    2104 </span><span class="lineCov">          1 :   coolingtubearcshape[0] = new TGeoXtru(2);     </span>
<span class="lineNum">    2105 </span><span class="lineCov">          1 :   Double_t* xvert = new Double_t[nedges+2];</span>
<span class="lineNum">    2106 </span><span class="lineCov">          1 :   Double_t* yvert = new Double_t[nedges+2];</span>
<span class="lineNum">    2107 </span><span class="lineCov">          1 :   Double_t ratio = fgkCoolingTubeRmin/fgkCoolingTubeSupportRmin;</span>
<span class="lineNum">    2108 </span>            :   ////////////////////////////////////////
<span class="lineNum">    2109 </span>            :   // Positioning the vertices for TGeoXTru
<span class="lineNum">    2110 </span>            :   ////////////////////////////////////////
<span class="lineNum">    2111 </span><span class="lineCov">          1 :   xvert[0] = 0., yvert[0] = 0.;</span>
<span class="lineNum">    2112 </span><span class="lineCov">          1 :   xvert[1] = vertexposition[0]-&gt;X()*ratio,  yvert[1] = vertexposition[0]-&gt;Y()*ratio;</span>
<span class="lineNum">    2113 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt; nedges; i++)</span>
<span class="lineNum">    2114 </span><span class="lineCov">          2 :                 xvert[i+2] = vertexposition[kvertexnumber-i-1]-&gt;X()*ratio,</span>
<span class="lineNum">    2115 </span><span class="lineCov">          2 :                 yvert[i+2] = vertexposition[kvertexnumber-i-1]-&gt;Y()*ratio;</span>
<span class="lineNum">    2116 </span>            :   ////////////////////////////////////////
<span class="lineNum">    2117 </span>            :   // Defining TGeoXTru PolyGone
<span class="lineNum">    2118 </span>            :   ////////////////////////////////////////
<span class="lineNum">    2119 </span><span class="lineCov">          1 :   coolingtubearcshape[0]-&gt;DefinePolygon(nedges+2,xvert,yvert);</span>
<span class="lineNum">    2120 </span><span class="lineCov">          1 :   coolingtubearcshape[0]-&gt;DefineSection(0,-0.5*fgkCoolingTubeSupportWidth);</span>
<span class="lineNum">    2121 </span><span class="lineCov">          1 :   coolingtubearcshape[0]-&gt;DefineSection(1,0.5*fgkCoolingTubeSupportWidth);</span>
<span class="lineNum">    2122 </span><span class="lineCov">          2 :   coolingtubearcshape[1] = GetArcShape(2.*phi,fgkCoolingTubeRmin,</span>
<span class="lineNum">    2123 </span><span class="lineCov">          1 :                 fgkCoolingTubeRmax,nedges,fgkCoolingTubeSupportWidth);</span>
<span class="lineNum">    2124 </span>            :   TGeoVolume* coolingtubearc[2];
<span class="lineNum">    2125 </span><span class="lineCov">          2 :   coolingtubearc[0] = new TGeoVolume(&quot;CoolingTubeWaterArcPart&quot;,</span>
<span class="lineNum">    2126 </span><span class="lineCov">          1 :                                                                   coolingtubearcshape[0],fSSDCoolingTubeWater);</span>
<span class="lineNum">    2127 </span><span class="lineCov">          2 :   coolingtubearc[1] = new TGeoVolume(&quot;CoolingTubePhynoxArcPart&quot;,</span>
<span class="lineNum">    2128 </span><span class="lineCov">          1 :                                                                   coolingtubearcshape[1],fSSDCoolingTubePhynox);</span>
<span class="lineNum">    2129 </span><span class="lineCov">          1 :   coolingtubearc[0]-&gt;SetLineColor(fColorWater);</span>
<span class="lineNum">    2130 </span><span class="lineCov">          1 :   coolingtubearc[1]-&gt;SetLineColor(fColorPhynox);</span>
<span class="lineNum">    2131 </span>            :   ////////////////////////////////////////////
<span class="lineNum">    2132 </span>            :   // Defining TGeoTubeSeg Part of Cooling Tube
<span class="lineNum">    2133 </span>            :   ////////////////////////////////////////////
<span class="lineNum">    2134 </span>            :   TGeoTubeSeg* coolingtubesegshape[2];
<span class="lineNum">    2135 </span><span class="lineCov">          2 :   coolingtubesegshape[0] = new TGeoTubeSeg(fgkCoolingTubeRmin,fgkCoolingTubeRmax,</span>
<span class="lineNum">    2136 </span><span class="lineCov">          1 :                                                         0.5*fgkCoolingTubeSupportWidth,phi,360-phi);</span>
<span class="lineNum">    2137 </span><span class="lineCov">          2 :   coolingtubesegshape[1] = new TGeoTubeSeg(0.,fgkCoolingTubeRmin,</span>
<span class="lineNum">    2138 </span><span class="lineCov">          1 :                                                         0.5*fgkCoolingTubeSupportWidth,phi,360-phi);</span>
<span class="lineNum">    2139 </span>            :   TGeoVolume* coolingtubeseg[2];
<span class="lineNum">    2140 </span><span class="lineCov">          2 :   coolingtubeseg[0] = new TGeoVolume(&quot;CoolingTubePhynoxPart&quot;,</span>
<span class="lineNum">    2141 </span><span class="lineCov">          1 :                                                                  coolingtubesegshape[0],fSSDCoolingTubePhynox);</span>
<span class="lineNum">    2142 </span><span class="lineCov">          2 :   coolingtubeseg[1] = new TGeoVolume(&quot;CoolingTubeWaterPart&quot;,</span>
<span class="lineNum">    2143 </span><span class="lineCov">          1 :                                                                  coolingtubesegshape[1],fSSDCoolingTubeWater);</span>
<span class="lineNum">    2144 </span><span class="lineCov">          1 :   coolingtubeseg[0]-&gt;SetLineColor(fColorPhynox);</span>
<span class="lineNum">    2145 </span><span class="lineCov">          1 :   coolingtubeseg[1]-&gt;SetLineColor(fColorWater);</span>
<span class="lineNum">    2146 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2147 </span>            :   // Virtual Volume containing Cooling Tube Support  
<span class="lineNum">    2148 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2149 </span><span class="lineCov">          1 :   TGeoXtru* virtualCoolingTubeSupportShape = new TGeoXtru(2);</span>
<span class="lineNum">    2150 </span>            :   const Int_t kvirtualvertexnumber = 8;
<span class="lineNum">    2151 </span><span class="lineCov">          1 :   TVector3* virtualvertex[kvirtualvertexnumber];</span>
<span class="lineNum">    2152 </span>            :    ////////////////////////////////////////
<span class="lineNum">    2153 </span>            :   // Positioning the vertices for TGeoXTru
<span class="lineNum">    2154 </span>            :   ////////////////////////////////////////
<span class="lineNum">    2155 </span><span class="lineCov">          2 :   virtualvertex[0] = new TVector3(-fgkCoolingTubeSupportRmax,-fgkCoolingTubeSupportRmax, 0); </span>
<span class="lineNum">    2156 </span><span class="lineCov">          2 :   virtualvertex[1] = new TVector3(virtualvertex[0]-&gt;X(),-virtualvertex[0]-&gt;Y(),0);</span>
<span class="lineNum">    2157 </span><span class="lineCov">          2 :   virtualvertex[2] = new TVector3(-virtualvertex[0]-&gt;X(),virtualvertex[1]-&gt;Y(),0);</span>
<span class="lineNum">    2158 </span><span class="lineCov">          2 :   virtualvertex[3] = new TVector3(virtualvertex[2]-&gt;X(),0.5*fgkCoolingTubeSupportHeight,0);</span>
<span class="lineNum">    2159 </span><span class="lineCov">          2 :   virtualvertex[4] = new TVector3(virtualvertex[3]-&gt;X()+boxlength,virtualvertex[3]-&gt;Y(),0);</span>
<span class="lineNum">    2160 </span><span class="lineCov">          2 :   virtualvertex[5] = new TVector3(virtualvertex[4]-&gt;X(),-virtualvertex[4]-&gt;Y(),0);</span>
<span class="lineNum">    2161 </span><span class="lineCov">          2 :   virtualvertex[6] = new TVector3(virtualvertex[3]-&gt;X(),-virtualvertex[3]-&gt;Y(),0);</span>
<span class="lineNum">    2162 </span><span class="lineCov">          2 :   virtualvertex[7] = new TVector3(virtualvertex[2]-&gt;X(),-virtualvertex[2]-&gt;Y(),0);</span>
<span class="lineNum">    2163 </span><span class="lineCov">          1 :   Double_t xmothervertex[kvirtualvertexnumber], ymothervertex[kvirtualvertexnumber];</span>
<span class="lineNum">    2164 </span><span class="lineCov">         18 :   for(Int_t i=0; i&lt; kvirtualvertexnumber; i++)</span>
<span class="lineNum">    2165 </span><span class="lineCov">          8 :         xmothervertex[i] = virtualvertex[i]-&gt;X(),</span>
<span class="lineNum">    2166 </span><span class="lineCov">          8 :         ymothervertex[i] = virtualvertex[i]-&gt;Y();</span>
<span class="lineNum">    2167 </span>            :   ////////////////////////////////////////
<span class="lineNum">    2168 </span>            :   // Defining TGeoXTru PolyGone
<span class="lineNum">    2169 </span>            :   ////////////////////////////////////////
<span class="lineNum">    2170 </span><span class="lineCov">          2 :   virtualCoolingTubeSupportShape-&gt;DefinePolygon(kvirtualvertexnumber,xmothervertex,</span>
<span class="lineNum">    2171 </span><span class="lineCov">          1 :                                                                                                                                          ymothervertex);</span>
<span class="lineNum">    2172 </span><span class="lineCov">          1 :   virtualCoolingTubeSupportShape-&gt;DefineSection(0,-0.5*fgkCoolingTubeSupportWidth);</span>
<span class="lineNum">    2173 </span><span class="lineCov">          1 :   virtualCoolingTubeSupportShape-&gt;DefineSection(1,0.5*fgkCoolingTubeSupportWidth);</span>
<span class="lineNum">    2174 </span>            :   /*TGeoVolume* virtualcoolingtubesupport = new TGeoVolume(&quot;CoolingTubeSupport&quot;,
<span class="lineNum">    2175 </span>            :     virtualCoolingTubeSupportShape,fSSDAir); */
<span class="lineNum">    2176 </span><span class="lineCov">          2 :   TGeoVolume* virtualcoolingtubesupport = new TGeoVolumeAssembly(&quot;CoolingTubeSupport&quot;);</span>
<span class="lineNum">    2177 </span>            : 
<span class="lineNum">    2178 </span>            :   ////////////////////////////////////////
<span class="lineNum">    2179 </span>            :   // Positioning Volumes in Virtual Volume
<span class="lineNum">    2180 </span>            :   ////////////////////////////////////////
<span class="lineNum">    2181 </span><span class="lineCov">          1 :   TGeoRotation* coolingtubesupportrot = new TGeoRotation(); </span>
<span class="lineNum">    2182 </span><span class="lineCov">          1 :   coolingtubesupportrot-&gt;SetAngles(-90.0,0.0,0.0);</span>
<span class="lineNum">    2183 </span><span class="lineCov">          1 :   virtualcoolingtubesupport-&gt;AddNode(coolingtubesupportarc,1,coolingtubesupportrot);</span>
<span class="lineNum">    2184 </span><span class="lineCov">          1 :   virtualcoolingtubesupport-&gt;AddNode(coolingtubesupportbox,1);</span>
<span class="lineNum">    2185 </span><span class="lineCov">          1 :   virtualcoolingtubesupport-&gt;AddNode(coolingtubesupportseg,1);</span>
<span class="lineNum">    2186 </span>            :   //virtualcoolingtubesupport-&gt;AddNode(coolingtubearc[0],1,coolingtubesupportrot);
<span class="lineNum">    2187 </span>            :   //virtualcoolingtubesupport-&gt;AddNode(coolingtubearc[1],1,coolingtubesupportrot);
<span class="lineNum">    2188 </span>            :   //virtualcoolingtubesupport-&gt;AddNode(coolingtubeseg[0],1);
<span class="lineNum">    2189 </span>            :   //virtualcoolingtubesupport-&gt;AddNode(coolingtubeseg[1],1);
<span class="lineNum">    2190 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2191 </span>            :   // Deallocating memory
<span class="lineNum">    2192 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2193 </span><span class="lineCov">          2 :   delete [] vertexposition;</span>
<span class="lineNum">    2194 </span><span class="lineCov">          2 :   delete [] xvertexpoints;</span>
<span class="lineNum">    2195 </span><span class="lineCov">          2 :   delete [] yvertexpoints;</span>
<span class="lineNum">    2196 </span><span class="lineCov">          2 :   delete [] xvert;</span>
<span class="lineNum">    2197 </span><span class="lineCov">          2 :   delete [] yvert;</span>
<span class="lineNum">    2198 </span><span class="lineCov">         18 :   for(Int_t i=0; i&lt; kvirtualvertexnumber; i++)</span>
<span class="lineNum">    2199 </span><span class="lineCov">         16 :         delete virtualvertex[i];</span>
<span class="lineNum">    2200 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2201 </span>            : 
<span class="lineNum">    2202 </span><span class="lineCov">          1 :   virtualcoolingtubesupport-&gt;GetShape()-&gt;ComputeBBox(); //RS: enforce recompting of BBox</span>
<span class="lineNum">    2203 </span><span class="lineCov">          1 :   return virtualcoolingtubesupport;</span>
<a name="2204"><span class="lineNum">    2204 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">    2205 </span>            : /////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    2206 </span>            : TList* AliITSv11GeometrySSD::GetSSDHybridParts(){
<span class="lineNum">    2207 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2208 </span>            :   // Method generating List containing SSD Hybrid Components   
<span class="lineNum">    2209 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2210 </span><span class="lineCov">          2 :   TList* ssdhybridlist = new TList();</span>
<span class="lineNum">    2211 </span>            :   const Int_t kssdstiffenernumber = 2;
<span class="lineNum">    2212 </span><span class="lineCov">          1 :   Double_t ssdstiffenerseparation = fgkSSDSensorLength</span>
<span class="lineNum">    2213 </span><span class="lineCov">          1 :                                                                   - 2.*fgkSSDModuleStiffenerPosition[1]</span>
<span class="lineNum">    2214 </span><span class="lineCov">          1 :                                                                   -    fgkSSDStiffenerWidth;</span>
<span class="lineNum">    2215 </span><span class="lineCov">          1 :   Double_t ssdchipcablesradius[kssdstiffenernumber];</span>
<span class="lineNum">    2216 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;kssdstiffenernumber; i++)</span>
<span class="lineNum">    2217 </span><span class="lineCov">          4 :           ssdchipcablesradius[i] = 0.25*(fgkSSDChipCablesHeight[i+2]</span>
<span class="lineNum">    2218 </span><span class="lineCov">          2 :                                -  fgkSSDChipCablesHeight[0]</span>
<span class="lineNum">    2219 </span><span class="lineCov">          2 :                                -  fgkSSDChipCablesHeight[1]);</span>
<span class="lineNum">    2220 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2221 </span>            :   // Mother Volumes Containers 
<span class="lineNum">    2222 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2223 </span>            :   const Int_t kmothernumber = 2;
<span class="lineNum">    2224 </span>            :   const Int_t kmothervertexnumber = 8;
<span class="lineNum">    2225 </span><span class="lineCov">          1 :   Double_t xmothervertex[kmothernumber][kmothervertexnumber]; </span>
<span class="lineNum">    2226 </span><span class="lineCov">          1 :   Double_t ymothervertex[kmothernumber][kmothervertexnumber]; </span>
<span class="lineNum">    2227 </span>            : 
<span class="lineNum">    2228 </span><span class="lineCov">          1 :   TGeoVolumeAssembly* ssdhybridassembly[kmothernumber];</span>
<span class="lineNum">    2229 </span><span class="lineCov">          1 :   TGeoVolume* ssdhybridmother[kmothernumber][2];</span>
<span class="lineNum">    2230 </span>            : 
<span class="lineNum">    2231 </span><span class="lineCov">          6 :   TGeoRotation hybridmotherrotR(TGeoRotation(&quot;&quot;,-90.0,0.0,0.0)*TGeoRotation(&quot;&quot;,0.0,90.0,0.0)*TGeoRotation(&quot;&quot;,90.,180.,-90));</span>
<span class="lineNum">    2232 </span><span class="lineCov">          4 :   TGeoRotation hybridmotherrotL(TGeoRotation(&quot;&quot;,180.,0.0,0.0)*hybridmotherrotR);</span>
<span class="lineNum">    2233 </span><span class="lineCov">          3 :   TGeoRotation *hybridmotherrotInv = new TGeoRotation(hybridmotherrotR.Inverse());</span>
<span class="lineNum">    2234 </span>            : 
<span class="lineNum">    2235 </span><span class="lineCov">          1 :   const char* ssdhybridmothername[kmothernumber] = {&quot;SSDHybridMother1&quot;,&quot;SSDHybridMother2&quot;};</span>
<span class="lineNum">    2236 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;kmothernumber; i++){</span>
<span class="lineNum">    2237 </span><span class="lineCov">          2 :     xmothervertex[i][0] = -0.5*fgkSSDStiffenerWidth;</span>
<span class="lineNum">    2238 </span><span class="lineCov">          2 :     ymothervertex[i][0] = 0.5*fgkSSDStiffenerHeight;</span>
<span class="lineNum">    2239 </span><span class="lineCov">          2 :     xmothervertex[i][1] = -0.5*fgkSSDStiffenerWidth;</span>
<span class="lineNum">    2240 </span><span class="lineCov">          4 :     ymothervertex[i][1] = -0.5*fgkSSDStiffenerHeight-fgkSSDChipHeight      </span>
<span class="lineNum">    2241 </span><span class="lineCov">          2 :       -fgkSSDChipCablesHeight[i+2];</span>
<span class="lineNum">    2242 </span>            :     
<span class="lineNum">    2243 </span><span class="lineCov">          2 :     xmothervertex[i][2] = 0.5*(fgkSSDSensorLength-ssdstiffenerseparation); //0.5*fgkSSDStiffenerWidth;</span>
<span class="lineNum">    2244 </span><span class="lineCov">          2 :     ymothervertex[i][2] = -0.5*fgkSSDStiffenerHeight-fgkSSDChipHeight -fgkSSDChipCablesHeight[i+2];</span>
<span class="lineNum">    2245 </span><span class="lineCov">          2 :     xmothervertex[i][3] = xmothervertex[i][2];</span>
<span class="lineNum">    2246 </span><span class="lineCov">          2 :     ymothervertex[i][3] = ymothervertex[i][2]+fgkSSDChipCablesHeight[0]+fgkSSDChipCablesHeight[1]+fgkSSDTolerance;</span>
<span class="lineNum">    2247 </span>            : 
<span class="lineNum">    2248 </span><span class="lineCov">          2 :     xmothervertex[i][4] = xmothervertex[i][2]-0.4;  </span>
<span class="lineNum">    2249 </span><span class="lineCov">          2 :     ymothervertex[i][4] = ymothervertex[i][3];</span>
<span class="lineNum">    2250 </span><span class="lineCov">          2 :     xmothervertex[i][5] = xmothervertex[i][4];</span>
<span class="lineNum">    2251 </span><span class="lineCov">          2 :     ymothervertex[i][5] = ymothervertex[i][4]+2*ssdchipcablesradius[i]-fgkSSDTolerance;</span>
<span class="lineNum">    2252 </span>            : 
<span class="lineNum">    2253 </span><span class="lineCov">          2 :     xmothervertex[i][6] = 0.5*fgkSSDStiffenerWidth+ssdchipcablesradius[i]+0.3*fgkmm;</span>
<span class="lineNum">    2254 </span><span class="lineCov">          2 :     ymothervertex[i][6] = ymothervertex[i][5];</span>
<span class="lineNum">    2255 </span>            :     
<span class="lineNum">    2256 </span><span class="lineCov">          2 :     xmothervertex[i][7] = xmothervertex[i][6];</span>
<span class="lineNum">    2257 </span><span class="lineCov">          2 :     ymothervertex[i][7] = 0.5*fgkSSDStiffenerHeight;</span>
<span class="lineNum">    2258 </span><span class="lineCov">          4 :     TGeoXtru *shape = new TGeoXtru(2);</span>
<span class="lineNum">    2259 </span><span class="lineCov">          2 :     shape-&gt;DefinePolygon(8,xmothervertex[i],ymothervertex[i]);</span>
<span class="lineNum">    2260 </span><span class="lineCov">          2 :     shape-&gt;DefineSection(0,-0.5*fgkSSDStiffenerLength);</span>
<span class="lineNum">    2261 </span><span class="lineCov">          2 :     shape-&gt;DefineSection(1,0.5*fgkSSDStiffenerLength);</span>
<span class="lineNum">    2262 </span><span class="lineCov">         12 :     ssdhybridmother[i][0] = new TGeoVolume(TString(ssdhybridmothername[i])+&quot;L&quot;,shape,fSSDAir);</span>
<span class="lineNum">    2263 </span><span class="lineCov">         12 :     ssdhybridmother[i][1] = new TGeoVolume(TString(ssdhybridmothername[i])+&quot;R&quot;,shape,fSSDAir);</span>
<span class="lineNum">    2264 </span><span class="lineCov">          6 :     ssdhybridassembly[i] = new TGeoVolumeAssembly(ssdhybridmothername[i]);</span>
<span class="lineNum">    2265 </span>            :    }   
<span class="lineNum">    2266 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2267 </span>            :   // SSD Stiffener   
<span class="lineNum">    2268 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2269 </span><span class="lineCov">          3 :   TGeoBBox* ssdstiffenershape = new TGeoBBox(&quot;SSDStiffenerShape&quot;,</span>
<span class="lineNum">    2270 </span><span class="lineCov">          1 :                                              0.5*fgkSSDStiffenerLength,</span>
<span class="lineNum">    2271 </span><span class="lineCov">          1 :                                              0.5*(fgkSSDStiffenerWidth-fgkSSDTolerance),</span>
<span class="lineNum">    2272 </span><span class="lineCov">          1 :                                              0.5*fgkSSDStiffenerHeight);</span>
<span class="lineNum">    2273 </span><span class="lineCov">          3 :   TGeoVolume* ssdstiffener = new TGeoVolume(&quot;SSDStiffener&quot;,ssdstiffenershape,</span>
<span class="lineNum">    2274 </span><span class="lineCov">          1 :                                             fSSDStiffenerMedium);  </span>
<span class="lineNum">    2275 </span><span class="lineCov">          1 :   ssdstiffener-&gt;SetLineColor(fColorStiffener); </span>
<span class="lineNum">    2276 </span>            : 
<span class="lineNum">    2277 </span>            : ////////////////////////////
<span class="lineNum">    2278 </span>            : // Capacitor 0603-2200 nF
<span class="lineNum">    2279 </span>            : ///////////////////////////
<span class="lineNum">    2280 </span>            :   const Int_t knapacitor0603number = 5;
<span class="lineNum">    2281 </span><span class="lineCov">          3 :   TGeoBBox* capacitor0603mothershape =  new TGeoBBox(&quot;Capacitor0603MotherShape&quot;,</span>
<span class="lineNum">    2282 </span><span class="lineCov">          1 :                                                0.5*fgkSSDCapacitor0603Length + fgkSSDCapacitor0603CapLength,</span>
<span class="lineNum">    2283 </span><span class="lineCov">          1 :                                                0.5*fgkSSDCapacitor0603Width,</span>
<span class="lineNum">    2284 </span><span class="lineCov">          1 :                                                0.5*fgkSSDCapacitor0603Height);</span>
<span class="lineNum">    2285 </span><span class="lineCov">          3 :   TGeoVolume* capacitor0603mother = new TGeoVolume(&quot;Capacitor0603Mother&quot;,capacitor0603mothershape,</span>
<span class="lineNum">    2286 </span><span class="lineCov">          1 :                                              fSSDAir); </span>
<span class="lineNum">    2287 </span>            : 
<span class="lineNum">    2288 </span><span class="lineCov">          3 :   TGeoBBox* capacitor0603shape =  new TGeoBBox(&quot;Capacitor0603Shape&quot;,</span>
<span class="lineNum">    2289 </span><span class="lineCov">          1 :                                                0.5*fgkSSDCapacitor0603Length,</span>
<span class="lineNum">    2290 </span><span class="lineCov">          1 :                                                0.5*fgkSSDCapacitor0603Width,</span>
<span class="lineNum">    2291 </span><span class="lineCov">          1 :                                                0.5*fgkSSDCapacitor0603Height);</span>
<span class="lineNum">    2292 </span><span class="lineCov">          3 :   TGeoVolume* capacitor0603 = new TGeoVolume(&quot;Capacitor0603&quot;,capacitor0603shape,</span>
<span class="lineNum">    2293 </span><span class="lineCov">          1 :                                              fSSDStiffener0603CapacitorMedium); </span>
<span class="lineNum">    2294 </span><span class="lineCov">          1 :   capacitor0603-&gt;SetLineColor(fColorAl);</span>
<span class="lineNum">    2295 </span><span class="lineCov">          2 :   TGeoTranslation *cap0603trans = new TGeoTranslation(0.,0.,0.);</span>
<span class="lineNum">    2296 </span><span class="lineCov">          1 :   capacitor0603mother-&gt;AddNode(capacitor0603,1,cap0603trans);</span>
<span class="lineNum">    2297 </span>            : 
<span class="lineNum">    2298 </span><span class="lineCov">          3 :   TGeoBBox* capacitor0603capshape =  new TGeoBBox(&quot;Capacitor0603CapShape&quot;,</span>
<span class="lineNum">    2299 </span><span class="lineCov">          1 :                                                0.5*fgkSSDCapacitor0603CapLength,</span>
<span class="lineNum">    2300 </span><span class="lineCov">          1 :                                                0.5*fgkSSDCapacitor0603Width,</span>
<span class="lineNum">    2301 </span><span class="lineCov">          1 :                                                0.5*fgkSSDCapacitor0603Height);</span>
<span class="lineNum">    2302 </span><span class="lineCov">          3 :   TGeoVolume* capacitor0603cap = new TGeoVolume(&quot;Capacitor0603Cap&quot;,capacitor0603capshape,</span>
<span class="lineNum">    2303 </span><span class="lineCov">          1 :                                              fSSDStiffenerCapacitorCapMedium); </span>
<span class="lineNum">    2304 </span><span class="lineCov">          1 :   capacitor0603cap-&gt;SetLineColor(fColorNiSn);</span>
<span class="lineNum">    2305 </span><span class="lineCov">          4 :   TGeoTranslation *cap0603captrans1 = new TGeoTranslation(- capacitor0603shape-&gt;GetDX() - capacitor0603capshape-&gt;GetDX(),0.,0.);</span>
<span class="lineNum">    2306 </span><span class="lineCov">          1 :   capacitor0603mother-&gt;AddNode(capacitor0603cap,1,cap0603captrans1);</span>
<span class="lineNum">    2307 </span><span class="lineCov">          4 :   TGeoTranslation *cap0603captrans2 = new TGeoTranslation(capacitor0603shape-&gt;GetDX() + capacitor0603capshape-&gt;GetDX(),0.,0.);</span>
<span class="lineNum">    2308 </span><span class="lineCov">          1 :   capacitor0603mother-&gt;AddNode(capacitor0603cap,2,cap0603captrans2);</span>
<span class="lineNum">    2309 </span>            : 
<span class="lineNum">    2310 </span>            : 
<span class="lineNum">    2311 </span><span class="lineCov">          1 :   TGeoVolume* ssdchip = GetSSDChip();</span>
<span class="lineNum">    2312 </span>            : 
<span class="lineNum">    2313 </span>            :   const Int_t knedges = 5;
<span class="lineNum">    2314 </span><span class="lineCov">          1 :   TGeoVolume *ssdchipcables[2];</span>
<span class="lineNum">    2315 </span>            : 
<span class="lineNum">    2316 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;kmothernumber; i++){</span>
<span class="lineNum">    2317 </span><span class="lineCov">         12 :     for(Int_t j=0; j&lt;kssdstiffenernumber; j++){</span>
<span class="lineNum">    2318 </span><span class="lineCov">          4 :       ssdhybridmother[i][j]-&gt;AddNode(ssdstiffener,1,hybridmotherrotInv);</span>
<span class="lineNum">    2319 </span><span class="lineCov">         48 :       for(Int_t k=1; k&lt;knapacitor0603number+1; k++){</span>
<span class="lineNum">    2320 </span><span class="lineCov">         40 :         ssdhybridmother[i][j]-&gt;AddNode(capacitor0603mother,k,</span>
<span class="lineNum">    2321 </span><span class="lineCov">         80 :                                        new TGeoCombiTrans(&quot;&quot;,</span>
<span class="lineNum">    2322 </span><span class="lineCov">         20 :                                                           -0.5*(fgkSSDStiffenerWidth - fgkSSDCapacitor0603Width),</span>
<span class="lineNum">    2323 </span><span class="lineCov">         20 :                                                           -0.5*(fgkSSDStiffenerHeight+fgkSSDCapacitor0603Height),</span>
<span class="lineNum">    2324 </span><span class="lineCov">         20 :                                                           (k-3.)/6*fgkSSDStiffenerLength,</span>
<span class="lineNum">    2325 </span>            :                                                           hybridmotherrotInv));
<span class="lineNum">    2326 </span>            :       }
<span class="lineNum">    2327 </span>            :     }
<span class="lineNum">    2328 </span>            :     
<span class="lineNum">    2329 </span><span class="lineCov">          2 :     GetSSDChipCables(ssdchipcables[0],ssdchipcables[1],fgkSSDChipCablesHeight[i+2],knedges);</span>
<span class="lineNum">    2330 </span><span class="lineCov">         28 :     for(Int_t k=0; k&lt;fgkSSDChipNumber; k++){</span>
<span class="lineNum">    2331 </span><span class="lineCov">         36 :       TGeoTranslation *chipcabletrans = new TGeoTranslation(&quot;&quot;,0.5*fgkSSDStiffenerWidth-fgkSSDChipWidth,</span>
<span class="lineNum">    2332 </span><span class="lineCov">         12 :                                                             - 0.5*fgkSSDStiffenerHeight - fgkSSDChipHeight</span>
<span class="lineNum">    2333 </span><span class="lineCov">         12 :                                                             - fgkSSDChipCablesHeight[i+2],</span>
<span class="lineNum">    2334 </span><span class="lineCov">         24 :                                                             (k+0.5-fgkSSDChipNumber/2)*</span>
<span class="lineNum">    2335 </span><span class="lineCov">         12 :                                                             (fgkSSDChipLength + fgkSSDChipSeparationLength));</span>
<span class="lineNum">    2336 </span><span class="lineCov">         36 :       TGeoCombiTrans *chiptrans = new TGeoCombiTrans(&quot;&quot;,0.5*(fgkSSDStiffenerWidth-fgkSSDChipWidth),</span>
<span class="lineNum">    2337 </span><span class="lineCov">         12 :                                                      - 0.5*(fgkSSDChipHeight+fgkSSDStiffenerHeight),</span>
<span class="lineNum">    2338 </span><span class="lineCov">         12 :                                                      (k+0.5-fgkSSDChipNumber/2)*(fgkSSDChipLength + fgkSSDChipSeparationLength),</span>
<span class="lineNum">    2339 </span>            :                                                      hybridmotherrotInv);
<span class="lineNum">    2340 </span><span class="lineCov">         72 :       for(Int_t j=0; j&lt;kssdstiffenernumber; j++){</span>
<span class="lineNum">    2341 </span><span class="lineCov">         24 :         ssdhybridmother[i][j]-&gt;AddNode(ssdchipcables[j],k+1,chipcabletrans);</span>
<span class="lineNum">    2342 </span><span class="lineCov">         24 :         ssdhybridmother[i][j]-&gt;AddNode(ssdchip,k+1,chiptrans);</span>
<span class="lineNum">    2343 </span>            :       }
<span class="lineNum">    2344 </span>            :     }  
<span class="lineNum">    2345 </span>            :     // Final placement by assembly
<span class="lineNum">    2346 </span><span class="lineCov">         10 :     ssdhybridassembly[i]-&gt;AddNode(ssdhybridmother[i][0],1,new TGeoCombiTrans(TGeoTranslation(&quot;&quot;,0,0,0),hybridmotherrotL));</span>
<span class="lineNum">    2347 </span><span class="lineCov">         10 :     ssdhybridassembly[i]-&gt;AddNode(ssdhybridmother[i][1],1,new TGeoCombiTrans(TGeoTranslation(&quot;&quot;,0,ssdstiffenerseparation,0),hybridmotherrotR));</span>
<span class="lineNum">    2348 </span><span class="lineCov">          2 :     ssdhybridassembly[i]-&gt;GetShape()-&gt;ComputeBBox(); //RS: enforce recompting of BBox</span>
<span class="lineNum">    2349 </span><span class="lineCov">          2 :     ssdhybridlist-&gt;Add(ssdhybridassembly[i]);</span>
<span class="lineNum">    2350 </span>            :   }    
<span class="lineNum">    2351 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2352 </span>            :   // Mother Volume Containing Capacitor Part 
<span class="lineNum">    2353 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2354 </span>            :   const Int_t kcapacitormothernumber = 8;
<span class="lineNum">    2355 </span><span class="lineCov">          1 :   Double_t xcapacitorvertex[kcapacitormothernumber];</span>
<span class="lineNum">    2356 </span><span class="lineCov">          1 :   Double_t ycapacitorvertex[kcapacitormothernumber];  </span>
<span class="lineNum">    2357 </span>            :   ///////////////////////
<span class="lineNum">    2358 </span>            :   // Setting the vertices 
<span class="lineNum">    2359 </span>            :   ///////////////////////
<span class="lineNum">    2360 </span><span class="lineCov">          2 :   xcapacitorvertex[0] = -fgkSSDConnectorPosition[0]+ssdstiffenershape-&gt;GetDX();    </span>
<span class="lineNum">    2361 </span><span class="lineCov">          1 :   xcapacitorvertex[1] = xcapacitorvertex[0];   </span>
<span class="lineNum">    2362 </span><span class="lineCov">          1 :   xcapacitorvertex[2] = 0.5*fgkSSDFlexHoleWidth;   </span>
<span class="lineNum">    2363 </span><span class="lineCov">          1 :   xcapacitorvertex[3] = xcapacitorvertex[2];   </span>
<span class="lineNum">    2364 </span><span class="lineCov">          1 :   xcapacitorvertex[4] = xcapacitorvertex[0];   </span>
<span class="lineNum">    2365 </span><span class="lineCov">          1 :   xcapacitorvertex[5] = xcapacitorvertex[0];   </span>
<span class="lineNum">    2366 </span><span class="lineCov">          1 :   xcapacitorvertex[6] = -xcapacitorvertex[0];   </span>
<span class="lineNum">    2367 </span><span class="lineCov">          1 :   xcapacitorvertex[7] = xcapacitorvertex[6];   </span>
<span class="lineNum">    2368 </span><span class="lineCov">          1 :   ycapacitorvertex[0] = -0.5*fgkSSDStiffenerWidth;    </span>
<span class="lineNum">    2369 </span><span class="lineCov">          1 :   ycapacitorvertex[1] = ssdstiffenerseparation-0.5*fgkSSDStiffenerWidth-fgkSSDFlexHoleLength;   </span>
<span class="lineNum">    2370 </span><span class="lineCov">          1 :   ycapacitorvertex[2] = ycapacitorvertex[1];   </span>
<span class="lineNum">    2371 </span><span class="lineCov">          1 :   ycapacitorvertex[3] = ycapacitorvertex[2]+fgkSSDFlexHoleLength;   </span>
<span class="lineNum">    2372 </span><span class="lineCov">          1 :   ycapacitorvertex[4] = ycapacitorvertex[3];   </span>
<span class="lineNum">    2373 </span><span class="lineCov">          1 :   ycapacitorvertex[5] = ycapacitorvertex[4]+fgkSSDStiffenerWidth;   </span>
<span class="lineNum">    2374 </span><span class="lineCov">          1 :   ycapacitorvertex[6] = ycapacitorvertex[5];   </span>
<span class="lineNum">    2375 </span><span class="lineCov">          1 :   ycapacitorvertex[7] = ycapacitorvertex[0];   </span>
<span class="lineNum">    2376 </span><span class="lineCov">          2 :   TGeoXtru* ssdhybridcapacitormothershape = new TGeoXtru(2);</span>
<span class="lineNum">    2377 </span><span class="lineCov">          2 :   ssdhybridcapacitormothershape-&gt;DefinePolygon(kcapacitormothernumber,xcapacitorvertex,</span>
<span class="lineNum">    2378 </span><span class="lineCov">          1 :                                               ycapacitorvertex);</span>
<span class="lineNum">    2379 </span><span class="lineCov">          1 :   ssdhybridcapacitormothershape-&gt;DefineSection(0,0.5*fgkSSDStiffenerHeight);</span>
<span class="lineNum">    2380 </span><span class="lineCov">          1 :   ssdhybridcapacitormothershape-&gt;DefineSection(1, 0.5*fgkSSDStiffenerHeight+fgkSSDCapacitor1812Height);</span>
<span class="lineNum">    2381 </span>            : //  TGeoVolume* ssdhybridcapacitormother = new TGeoVolume(&quot;SSDHybridCapacitorMother&quot;,ssdhybridcapacitormothershape,
<span class="lineNum">    2382 </span>            : //                                          fSSDAir);
<span class="lineNum">    2383 </span><span class="lineCov">          2 :   TGeoVolumeAssembly* ssdhybridcapacitormother = new TGeoVolumeAssembly(&quot;SSDHybridCapacitorMother&quot;);</span>
<span class="lineNum">    2384 </span>            : ////////////////////////////
<span class="lineNum">    2385 </span>            : // Connector 
<span class="lineNum">    2386 </span>            : ///////////////////////////
<span class="lineNum">    2387 </span>            :   const Int_t kssdconnectorlayernumber = 3;
<span class="lineNum">    2388 </span><span class="lineCov">          1 :   TGeoBBox* ssdconnectorshape[kssdconnectorlayernumber];</span>
<span class="lineNum">    2389 </span><span class="lineCov">          1 :   Double_t ssdConnectorThickness[kssdconnectorlayernumber]={fgkSSDConnectorAlHeight,fgkSSDConnectorNiHeight,fgkSSDConnectorSnHeight};</span>
<span class="lineNum">    2390 </span>            :   /*
<span class="lineNum">    2391 </span>            :   Double_t ssdAlconnectororigin[3] = {0.0,0.0,0.5*(fgkSSDStiffenerHeight+fgkSSDConnectorAlHeight)};    
<span class="lineNum">    2392 </span>            :   Double_t ssdNiconnectororigin[3] = {0.0,0.0,0.5*(fgkSSDStiffenerHeight+fgkSSDConnectorNiHeight)
<span class="lineNum">    2393 </span>            :                                    +  fgkSSDConnectorAlHeight};  
<span class="lineNum">    2394 </span>            :   */
<span class="lineNum">    2395 </span><span class="lineCov">          1 :   Double_t ssdconnectororigin[3] = {0,0,0.5*fgkSSDStiffenerHeight};</span>
<span class="lineNum">    2396 </span><span class="lineCov">          1 :   const char* ssdconnectorname[kssdconnectorlayernumber] = {&quot;SSDConnectorAl&quot;,&quot;SSDConnectorNi&quot;,&quot;SSDConnectorSn&quot;};</span>
<span class="lineNum">    2397 </span><span class="lineCov">          1 :   TGeoMedium *ssdConnectorMedium[kssdconnectorlayernumber]={fSSDAlTraceFlexMedium,fSSDStiffenerConnectorMedium,fSSDSn};</span>
<span class="lineNum">    2398 </span><span class="lineCov">          1 :   TGeoVolume* ssdconnector[kssdconnectorlayernumber];</span>
<span class="lineNum">    2399 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;kssdconnectorlayernumber; i++){</span>
<span class="lineNum">    2400 </span><span class="lineCov">          3 :     ssdconnectororigin[2]+= 0.5*ssdConnectorThickness[i];</span>
<span class="lineNum">    2401 </span><span class="lineCov">         12 :       ssdconnectorshape[i] = new TGeoBBox(0.5*fgkSSDConnectorLength,</span>
<span class="lineNum">    2402 </span><span class="lineCov">          3 :                                           0.5*fgkSSDConnectorWidth,</span>
<span class="lineNum">    2403 </span><span class="lineCov">          3 :                                           0.5*ssdConnectorThickness[i],</span>
<span class="lineNum">    2404 </span><span class="lineCov">          3 :                                           ssdconnectororigin);</span>
<span class="lineNum">    2405 </span><span class="lineCov">          3 :       ssdconnectororigin[2]+= 0.5*ssdConnectorThickness[i];</span>
<span class="lineNum">    2406 </span><span class="lineCov">         12 :       ssdconnector[i] = new TGeoVolume(ssdconnectorname[i],ssdconnectorshape[i],</span>
<span class="lineNum">    2407 </span><span class="lineCov">          3 :                                        ssdConnectorMedium[i]);      </span>
<span class="lineNum">    2408 </span><span class="lineCov">          9 :       ssdconnector[i]-&gt;SetLineColor(i==0 ? fColorAl : fColorNiSn);</span>
<span class="lineNum">    2409 </span>            :   }
<span class="lineNum">    2410 </span>            :   const Int_t kssdconnectornumber = 4;
<span class="lineNum">    2411 </span><span class="lineCov">          1 :   TGeoTranslation* ssdconnectortrans[kssdconnectornumber];</span>
<span class="lineNum">    2412 </span><span class="lineCov">          5 :   ssdconnectortrans[0] = new TGeoTranslation(-ssdstiffenershape-&gt;GetDX()</span>
<span class="lineNum">    2413 </span><span class="lineCov">          1 :                        +  fgkSSDConnectorPosition[0]</span>
<span class="lineNum">    2414 </span><span class="lineCov">          1 :                        -  fgkSSDConnectorSeparation</span>
<span class="lineNum">    2415 </span><span class="lineCov">          1 :                        -  1.5*fgkSSDConnectorLength,</span>
<span class="lineNum">    2416 </span><span class="lineCov">          2 :                           ssdstiffenerseparation+ssdstiffenershape-&gt;GetDY()</span>
<span class="lineNum">    2417 </span><span class="lineCov">          1 :                        -  fgkSSDConnectorPosition[1]</span>
<span class="lineNum">    2418 </span><span class="lineCov">          2 :                        -  ssdconnectorshape[0]-&gt;GetDY(),0.0);        </span>
<span class="lineNum">    2419 </span><span class="lineCov">          4 :   ssdconnectortrans[1] = new TGeoTranslation(</span>
<span class="lineNum">    2420 </span><span class="lineCov">          2 :                        -  ssdstiffenershape-&gt;GetDX()</span>
<span class="lineNum">    2421 </span><span class="lineCov">          1 :                        +  fgkSSDConnectorPosition[0]</span>
<span class="lineNum">    2422 </span><span class="lineCov">          1 :                        -  0.5*fgkSSDConnectorLength,</span>
<span class="lineNum">    2423 </span><span class="lineCov">          2 :                           ssdstiffenerseparation+ssdstiffenershape-&gt;GetDY()</span>
<span class="lineNum">    2424 </span><span class="lineCov">          1 :                        -  fgkSSDConnectorPosition[1]</span>
<span class="lineNum">    2425 </span><span class="lineCov">          2 :                        -  ssdconnectorshape[0]-&gt;GetDY(),0.0);</span>
<span class="lineNum">    2426 </span><span class="lineCov">          4 :   ssdconnectortrans[2] = new TGeoTranslation(+ssdstiffenershape-&gt;GetDX()</span>
<span class="lineNum">    2427 </span><span class="lineCov">          1 :                        -  fgkSSDConnectorPosition[0]</span>
<span class="lineNum">    2428 </span><span class="lineCov">          1 :                        +  fgkSSDConnectorSeparation</span>
<span class="lineNum">    2429 </span><span class="lineCov">          1 :                        +  1.5*fgkSSDConnectorLength,</span>
<span class="lineNum">    2430 </span><span class="lineCov">          2 :                           -(ssdstiffenershape-&gt;GetDY()</span>
<span class="lineNum">    2431 </span><span class="lineCov">          1 :                        -  fgkSSDConnectorPosition[1]</span>
<span class="lineNum">    2432 </span><span class="lineCov">          2 :                        -  ssdconnectorshape[0]-&gt;GetDY()),0.0);       </span>
<span class="lineNum">    2433 </span><span class="lineCov">          4 :   ssdconnectortrans[3] = new TGeoTranslation(+ssdstiffenershape-&gt;GetDX()</span>
<span class="lineNum">    2434 </span><span class="lineCov">          1 :                        -  fgkSSDConnectorPosition[0]</span>
<span class="lineNum">    2435 </span><span class="lineCov">          1 :                        +  0.5*fgkSSDConnectorLength,</span>
<span class="lineNum">    2436 </span><span class="lineCov">          2 :                           -(ssdstiffenershape-&gt;GetDY()</span>
<span class="lineNum">    2437 </span><span class="lineCov">          1 :                        -  fgkSSDConnectorPosition[1]</span>
<span class="lineNum">    2438 </span><span class="lineCov">          2 :                        -  ssdconnectorshape[0]-&gt;GetDY()),0.0);</span>
<span class="lineNum">    2439 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;kssdconnectornumber; i++) {</span>
<span class="lineNum">    2440 </span>            :     Int_t nlay = kssdconnectorlayernumber - 1;
<span class="lineNum">    2441 </span><span class="lineCov">          4 :     if (i == 1 || i == 2)</span>
<span class="lineNum">    2442 </span><span class="lineCov">          2 :       nlay++;</span>
<span class="lineNum">    2443 </span><span class="lineCov">         28 :     for(Int_t j=0; j&lt;nlay; j++)</span>
<span class="lineNum">    2444 </span><span class="lineCov">         10 :       ssdhybridcapacitormother-&gt;AddNode(ssdconnector[j],i+1,ssdconnectortrans[i]);      </span>
<span class="lineNum">    2445 </span>            :   }
<span class="lineNum">    2446 </span>            : ////////////////////////////
<span class="lineNum">    2447 </span>            : // Capacitor 1812-330 nF
<span class="lineNum">    2448 </span>            : /////////////////////////// 
<span class="lineNum">    2449 </span>            : //  Double_t ssdcapacitor1812origin[3] = {0.0,0.0,0.5*(fgkSSDStiffenerHeight+fgkSSDCapacitor1812Height)};    
<span class="lineNum">    2450 </span><span class="lineCov">          3 :   TGeoBBox* capacitor1812shape =  new TGeoBBox(&quot;Capacitor1812Shape&quot;,</span>
<span class="lineNum">    2451 </span><span class="lineCov">          1 :                                                                                          0.5*fgkSSDCapacitor1812Length,</span>
<span class="lineNum">    2452 </span><span class="lineCov">          1 :                                                                                          0.5*fgkSSDCapacitor1812Width,</span>
<span class="lineNum">    2453 </span><span class="lineCov">          1 :                                                0.5*fgkSSDCapacitor1812Height);</span>
<span class="lineNum">    2454 </span>            :   //            ssdcapacitor1812origin);
<span class="lineNum">    2455 </span><span class="lineCov">          3 :   TGeoVolume* capacitor1812 = new TGeoVolume(&quot;Capacitor1812&quot;,capacitor1812shape,</span>
<span class="lineNum">    2456 </span><span class="lineCov">          1 :                                              fSSDStiffener1812CapacitorMedium); </span>
<span class="lineNum">    2457 </span><span class="lineCov">          1 :   capacitor1812-&gt;SetLineColor(fColorAl);</span>
<span class="lineNum">    2458 </span><span class="lineCov">          3 :   TGeoTranslation* capacitor1812trans = new TGeoTranslation(0.0,</span>
<span class="lineNum">    2459 </span><span class="lineCov">          1 :                                         0.5*fgkSSDStiffenerWidth+ssdstiffenerseparation</span>
<span class="lineNum">    2460 </span><span class="lineCov">          2 :                                       - capacitor1812shape-&gt;GetDY()-fgkSSDConnectorPosition[1],0.5*(fgkSSDStiffenerHeight+fgkSSDCapacitor1812Height));</span>
<span class="lineNum">    2461 </span><span class="lineCov">          1 :   ssdhybridcapacitormother-&gt;AddNode(capacitor1812,1,capacitor1812trans);</span>
<span class="lineNum">    2462 </span>            : 
<span class="lineNum">    2463 </span><span class="lineCov">          3 :   TGeoBBox* capacitor1812capshape =  new TGeoBBox(&quot;Capacitor1812CapShape&quot;,</span>
<span class="lineNum">    2464 </span><span class="lineCov">          1 :     0.5*fgkSSDCapacitor1812CapLength, 0.5*fgkSSDCapacitor1812Width,</span>
<span class="lineNum">    2465 </span><span class="lineCov">          1 :     0.5*fgkSSDCapacitor1812Height);</span>
<span class="lineNum">    2466 </span><span class="lineCov">          3 :   TGeoVolume* capacitor1812cap = new TGeoVolume(&quot;Capacitor1812Cap&quot;,capacitor1812capshape,</span>
<span class="lineNum">    2467 </span><span class="lineCov">          1 :                                              fSSDStiffenerCapacitorCapMedium);</span>
<span class="lineNum">    2468 </span><span class="lineCov">          1 :   capacitor1812cap-&gt;SetLineColor(fColorNiSn);</span>
<span class="lineNum">    2469 </span><span class="lineCov">          3 :   TGeoTranslation* capacitor1812captrans1 = new TGeoTranslation(</span>
<span class="lineNum">    2470 </span><span class="lineCov">          3 :         - capacitor1812shape-&gt;GetDX() - capacitor1812capshape-&gt;GetDX(),</span>
<span class="lineNum">    2471 </span><span class="lineCov">          1 :         0.5*fgkSSDStiffenerWidth+ssdstiffenerseparation</span>
<span class="lineNum">    2472 </span><span class="lineCov">          2 :         - capacitor1812shape-&gt;GetDY() - fgkSSDConnectorPosition[1],</span>
<span class="lineNum">    2473 </span><span class="lineCov">          1 :         0.5*(fgkSSDStiffenerHeight+fgkSSDCapacitor1812Height));</span>
<span class="lineNum">    2474 </span><span class="lineCov">          1 :   ssdhybridcapacitormother-&gt;AddNode(capacitor1812cap,1,capacitor1812captrans1);</span>
<span class="lineNum">    2475 </span><span class="lineCov">          3 :   TGeoTranslation* capacitor1812captrans2 = new TGeoTranslation(</span>
<span class="lineNum">    2476 </span><span class="lineCov">          3 :         capacitor1812shape-&gt;GetDX() + capacitor1812capshape-&gt;GetDX(),</span>
<span class="lineNum">    2477 </span><span class="lineCov">          1 :         0.5*fgkSSDStiffenerWidth+ssdstiffenerseparation</span>
<span class="lineNum">    2478 </span><span class="lineCov">          2 :         - capacitor1812shape-&gt;GetDY() - fgkSSDConnectorPosition[1],</span>
<span class="lineNum">    2479 </span><span class="lineCov">          1 :         0.5*(fgkSSDStiffenerHeight+fgkSSDCapacitor1812Height));</span>
<span class="lineNum">    2480 </span><span class="lineCov">          1 :   ssdhybridcapacitormother-&gt;AddNode(capacitor1812cap,2,capacitor1812captrans2);</span>
<span class="lineNum">    2481 </span>            : 
<span class="lineNum">    2482 </span>            : ////////////////////////////
<span class="lineNum">    2483 </span>            : //Hybrid Wire
<span class="lineNum">    2484 </span>            : ////////////////////////////
<span class="lineNum">    2485 </span><span class="lineCov">          2 :   Double_t wirex = 2.*(fgkSSDConnectorPosition[0]-0.5*fgkSSDStiffenerLength</span>
<span class="lineNum">    2486 </span><span class="lineCov">          2 :                                  - 0.5*fgkSSDConnectorLength)-fgkSSDConnectorLength</span>
<span class="lineNum">    2487 </span><span class="lineCov">          1 :                                  - fgkSSDConnectorSeparation;</span>
<span class="lineNum">    2488 </span><span class="lineCov">          1 :   Double_t wirey = ssdstiffenerseparation+fgkSSDStiffenerWidth</span>
<span class="lineNum">    2489 </span><span class="lineCov">          1 :                                  - 2.*fgkSSDConnectorPosition[1]-fgkSSDConnectorWidth;</span>
<span class="lineNum">    2490 </span><span class="lineCov">          1 :   Double_t ssdwireradius = TMath::Sqrt(wirex*wirex+wirey*wirey);</span>
<span class="lineNum">    2491 </span>            : 
<span class="lineNum">    2492 </span><span class="lineCov">          1 :   Double_t wireangle = TMath::ATan(wirex/wirey);</span>
<span class="lineNum">    2493 </span><span class="lineCov">          3 :   TGeoTube *hybridwireshape = new TGeoTube(&quot;HybridWireShape&quot;, 0., </span>
<span class="lineNum">    2494 </span><span class="lineCov">          1 :                                                 fgkSSDWireRadius, 0.5*ssdwireradius);</span>
<span class="lineNum">    2495 </span><span class="lineCov">          3 :   TGeoVolume* hybridwire = new TGeoVolume(&quot;HybridWire&quot;,hybridwireshape,</span>
<span class="lineNum">    2496 </span><span class="lineCov">          1 :                                              fSSDStiffenerHybridWireMedium); </span>
<span class="lineNum">    2497 </span><span class="lineCov">          1 :   hybridwire-&gt;SetLineColor(fColorPhynox);</span>
<span class="lineNum">    2498 </span>            :   TGeoCombiTrans* hybridwirecombitrans[2];
<span class="lineNum">    2499 </span><span class="lineCov">          3 :   hybridwirecombitrans[0] = new TGeoCombiTrans(&quot;HybridWireCombiTrans1&quot;,</span>
<span class="lineNum">    2500 </span><span class="lineCov">          1 :                    0.5*fgkSSDStiffenerLength-fgkSSDConnectorPosition[0]</span>
<span class="lineNum">    2501 </span><span class="lineCov">          1 :                                  + 1.5*fgkSSDConnectorLength+fgkSSDConnectorSeparation,</span>
<span class="lineNum">    2502 </span><span class="lineCov">          1 :                    0.5*ssdwireradius-0.5*fgkSSDStiffenerWidth</span>
<span class="lineNum">    2503 </span><span class="lineCov">          1 :                                  + fgkSSDConnectorPosition[1]+0.5*fgkSSDConnectorWidth,</span>
<span class="lineNum">    2504 </span><span class="lineCov">          1 :                                    ssdstiffenershape-&gt;GetDZ()</span>
<span class="lineNum">    2505 </span><span class="lineCov">          1 :                                  + fgkSSDWireRadius+fgkSSDConnectorAlHeight+fgkSSDConnectorNiHeight+fgkSSDConnectorSnHeight,</span>
<span class="lineNum">    2506 </span><span class="lineCov">          2 :                    new TGeoRotation(&quot;HybridWireRot1&quot;,0.,90.,0.));</span>
<span class="lineNum">    2507 </span><span class="lineCov">          3 :   hybridwirecombitrans[1] = new TGeoCombiTrans(&quot;HybridWireCombiTrans2&quot;,</span>
<span class="lineNum">    2508 </span>            :                             0.0,
<span class="lineNum">    2509 </span><span class="lineCov">          1 :                           - 0.5*fgkSSDConnectorWidth+fgkSSDWireRadius,</span>
<span class="lineNum">    2510 </span>            :                             0.0,        
<span class="lineNum">    2511 </span><span class="lineCov">          3 :                             new TGeoRotation(&quot;HybridWireRot2&quot;,</span>
<span class="lineNum">    2512 </span><span class="lineCov">          1 :                           - wireangle*TMath::RadToDeg(),0.,0.));</span>
<span class="lineNum">    2513 </span><span class="lineCov">          2 :   TGeoHMatrix* hybridwirematrix = new TGeoHMatrix();</span>
<span class="lineNum">    2514 </span><span class="lineCov">          1 :   hybridwirematrix-&gt;MultiplyLeft(hybridwirecombitrans[0]);</span>
<span class="lineNum">    2515 </span><span class="lineCov">          1 :   hybridwirematrix-&gt;MultiplyLeft(hybridwirecombitrans[1]);</span>
<span class="lineNum">    2516 </span><span class="lineCov">          1 :   ssdhybridcapacitormother-&gt;AddNode(hybridwire,1,hybridwirematrix);</span>
<span class="lineNum">    2517 </span><span class="lineCov">          1 :   ssdhybridcapacitormother-&gt;GetShape()-&gt;ComputeBBox(); //RS: enforce recompting of BBox</span>
<span class="lineNum">    2518 </span>            : 
<span class="lineNum">    2519 </span><span class="lineCov">          1 :   ssdhybridlist-&gt;Add(ssdhybridcapacitormother);</span>
<span class="lineNum">    2520 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2521 </span>            :   // Deallocating memory
<span class="lineNum">    2522 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2523 </span><span class="lineCov">          2 :   delete hybridwirecombitrans[0];</span>
<span class="lineNum">    2524 </span><span class="lineCov">          2 :   delete hybridwirecombitrans[1];</span>
<span class="lineNum">    2525 </span>            :   return ssdhybridlist;
<span class="lineNum">    2526 </span>            :   /////////////////////////////////////////////////////////////
<a name="2527"><span class="lineNum">    2527 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">    2528 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    2529 </span>            : TGeoVolume* AliITSv11GeometrySSD::GetCoolingBlockSystem(){
<span class="lineNum">    2530 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2531 </span>            :   // SSD Cooling Block System
<span class="lineNum">    2532 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2533 </span>            :   // SSD Cooling Block and Cooling Tube Transformations
<span class="lineNum">    2534 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2535 </span><span class="lineCov">          2 :   TGeoRotation* localcoolingblockrot = new TGeoRotation();</span>
<span class="lineNum">    2536 </span><span class="lineCov">          1 :   localcoolingblockrot-&gt;SetAngles(0.,90.,0.);</span>
<span class="lineNum">    2537 </span><span class="lineCov">          1 :   TGeoCombiTrans localcoolingblockmatrix(0.,0.5*fgkSSDCoolingBlockWidth,0.,localcoolingblockrot);</span>
<span class="lineNum">    2538 </span>            :   TVector3* coolingblocktransvector;
<span class="lineNum">    2539 </span><span class="lineCov">          3 :   coolingblocktransvector = new TVector3(fgkCoolingTubeSeparation,</span>
<span class="lineNum">    2540 </span><span class="lineCov">          1 :                                                                   fgkSSDSensorLength</span>
<span class="lineNum">    2541 </span><span class="lineCov">          1 :                                                                 - 2.*fgkSSDModuleStiffenerPosition[1]</span>
<span class="lineNum">    2542 </span><span class="lineCov">          1 :                                          - fgkSSDCoolingBlockWidth, 0);</span>
<span class="lineNum">    2543 </span>            :   const Int_t kcoolingblocktransnumber = 2;
<span class="lineNum">    2544 </span>            :   const Int_t kcoolingblocknumber = 4;
<span class="lineNum">    2545 </span><span class="lineCov">          1 :   TGeoHMatrix* coolingblockmatrix[kcoolingblocknumber];</span>
<span class="lineNum">    2546 </span><span class="lineCov">          2 :   TGeoRotation* localcoolingtuberot = new TGeoRotation();</span>
<span class="lineNum">    2547 </span><span class="lineCov">          1 :   localcoolingtuberot-&gt;SetAngles(0.0,90.0,0.0);</span>
<span class="lineNum">    2548 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;kcoolingblocktransnumber; i++){</span>
<span class="lineNum">    2549 </span><span class="lineCov">         12 :     for(Int_t j=0; j&lt;kcoolingblocktransnumber; j++){</span>
<span class="lineNum">    2550 </span><span class="lineCov">          8 :       TGeoTranslation localcoolingblocktrans(i*coolingblocktransvector-&gt;X(),//+2*coolingtubedistance,</span>
<span class="lineNum">    2551 </span><span class="lineCov">          4 :                                              j*coolingblocktransvector-&gt;Y(),</span>
<span class="lineNum">    2552 </span><span class="lineCov">          8 :                                              - 0.5*(fgkSSDCoolingBlockHoleCenter</span>
<span class="lineNum">    2553 </span><span class="lineCov">          4 :                                                     + fgkCoolingTubeRmax));</span>
<span class="lineNum">    2554 </span><span class="lineCov">         16 :       coolingblockmatrix[2*i+j] = new TGeoHMatrix(localcoolingblocktrans*localcoolingblockmatrix);</span>
<span class="lineNum">    2555 </span><span class="lineCov">          4 :     }</span>
<span class="lineNum">    2556 </span>            :   }
<span class="lineNum">    2557 </span><span class="lineCov">          3 :   TGeoVolume* coolingsystemother = new TGeoVolumeAssembly(&quot;CoolingBlockSystem&quot;);</span>
<span class="lineNum">    2558 </span><span class="lineCov">          1 :   TGeoVolume* ssdcoolingblock = GetSSDCoolingBlock(30);</span>
<span class="lineNum">    2559 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2560 </span>            :   // Adding Cooling block to mother volume
<span class="lineNum">    2561 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2562 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;kcoolingblocknumber; i++){ </span>
<span class="lineNum">    2563 </span><span class="lineCov">          4 :     coolingsystemother-&gt;AddNode(ssdcoolingblock,i+1,coolingblockmatrix[i]);</span>
<span class="lineNum">    2564 </span>            :   }
<span class="lineNum">    2565 </span>            :   
<span class="lineNum">    2566 </span><span class="lineCov">          1 :   coolingsystemother-&gt;GetShape()-&gt;ComputeBBox(); //RS: enforce recompting of BBox</span>
<span class="lineNum">    2567 </span>            : 
<span class="lineNum">    2568 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2569 </span>            :   // Deallocating memory
<span class="lineNum">    2570 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2571 </span><span class="lineCov">          2 :   delete coolingblocktransvector;</span>
<span class="lineNum">    2572 </span><span class="lineCov">          2 :   delete localcoolingblockrot;</span>
<span class="lineNum">    2573 </span>            : 
<span class="lineNum">    2574 </span>            :   return coolingsystemother;
<a name="2575"><span class="lineNum">    2575 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">    2576 </span>            : /////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    2577 </span>            : TGeoVolume* AliITSv11GeometrySSD::GetSSDStiffenerFlex()const{
<span class="lineNum">    2578 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2579 </span>            :   // SSD Flex
<span class="lineNum">    2580 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2581 </span>            :   const Int_t kssdflexlayernumber = 2;
<span class="lineNum">    2582 </span><span class="lineCov">          2 :   TGeoXtru* ssdflexshape[kssdflexlayernumber];</span>
<span class="lineNum">    2583 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;kssdflexlayernumber; i++) ssdflexshape[i] = new TGeoXtru(2);</span>
<span class="lineNum">    2584 </span>            :   const Int_t kmothervertexnumber = 17; 
<span class="lineNum">    2585 </span><span class="lineCov">          1 :   Double_t xmothervertex[kmothervertexnumber];</span>
<span class="lineNum">    2586 </span><span class="lineCov">          1 :   Double_t ymothervertex[kmothervertexnumber];</span>
<span class="lineNum">    2587 </span>            :   /////////////////////////////////////////////
<span class="lineNum">    2588 </span>            :   // Auxiliary variables for vertex positioning
<span class="lineNum">    2589 </span>            :   /////////////////////////////////////////////
<span class="lineNum">    2590 </span>            :   const Int_t kssdflexboxnumber = 5;
<span class="lineNum">    2591 </span>            :   Double_t ssdflexboxlength[kssdflexboxnumber];
<span class="lineNum">    2592 </span><span class="lineCov">          1 :   ssdflexboxlength[0] = 0.5*(fgkSSDChipNumber</span>
<span class="lineNum">    2593 </span><span class="lineCov">          2 :                                           *     fgkSSDChipLength+(fgkSSDChipNumber-1)</span>
<span class="lineNum">    2594 </span><span class="lineCov">          1 :                                           *     fgkSSDChipSeparationLength</span>
<span class="lineNum">    2595 </span><span class="lineCov">          1 :                                           - fgkSSDModuleSensorSupportDistance-fgkSSDFlexHoleLength)</span>
<span class="lineNum">    2596 </span><span class="lineCov">          1 :                                           - (fgkSSDFlexLength[0]-fgkSSDFlexLength[1]);</span>
<span class="lineNum">    2597 </span><span class="lineCov">          1 :   ssdflexboxlength[1] = fgkSSDModuleSensorSupportDistance+fgkSSDFlexHoleLength;</span>
<span class="lineNum">    2598 </span><span class="lineCov">          1 :   ssdflexboxlength[2] = 0.5*(fgkSSDModuleSensorSupportDistance</span>
<span class="lineNum">    2599 </span><span class="lineCov">          1 :                                           -     fgkSSDFlexHoleLength-fgkSSDFlexHoleWidth);      </span>
<span class="lineNum">    2600 </span>            :   ssdflexboxlength[3] = fgkSSDFlexHoleWidth;    
<span class="lineNum">    2601 </span><span class="lineCov">          1 :   ssdflexboxlength[4] = fgkSSDFlexLength[1]-ssdflexboxlength[0]</span>
<span class="lineNum">    2602 </span><span class="lineCov">          1 :                                           -     ssdflexboxlength[1];</span>
<span class="lineNum">    2603 </span>            :   Double_t ssdflexboxwidth[kssdflexboxnumber];
<span class="lineNum">    2604 </span>            :   ssdflexboxwidth[0] = fgkSSDFlexWidth[0];
<span class="lineNum">    2605 </span><span class="lineCov">          1 :   ssdflexboxwidth[1] = fgkSSDFlexWidth[0]-fgkSSDFlexHoleWidth;</span>
<span class="lineNum">    2606 </span>            :   ssdflexboxwidth[2] = fgkSSDFlexHoleWidth;
<span class="lineNum">    2607 </span><span class="lineCov">          1 :   ssdflexboxwidth[3] = ssdflexboxwidth[2]-fgkSSDFlexHoleLength;</span>
<span class="lineNum">    2608 </span>            :   ssdflexboxwidth[4] = fgkSSDFlexWidth[0];
<span class="lineNum">    2609 </span>            :   ///////////////////////
<span class="lineNum">    2610 </span>            :   // Setting the vertices 
<span class="lineNum">    2611 </span>            :   ///////////////////////
<span class="lineNum">    2612 </span><span class="lineCov">          1 :   xmothervertex[0]  = 0.0;</span>
<span class="lineNum">    2613 </span><span class="lineCov">          1 :   xmothervertex[1]  = xmothervertex[0];</span>
<span class="lineNum">    2614 </span><span class="lineCov">          1 :   xmothervertex[2]  = fgkSSDFlexLength[0]-fgkSSDFlexLength[1];</span>
<span class="lineNum">    2615 </span><span class="lineCov">          2 :   xmothervertex[3]  = xmothervertex[2]+ssdflexboxlength[0]+ssdflexboxlength[1]</span>
<span class="lineNum">    2616 </span><span class="lineCov">          1 :                                         + ssdflexboxlength[4];</span>
<span class="lineNum">    2617 </span><span class="lineCov">          1 :   xmothervertex[4]  = xmothervertex[3];</span>
<span class="lineNum">    2618 </span><span class="lineCov">          1 :   xmothervertex[5]  = xmothervertex[4]-ssdflexboxlength[4];</span>
<span class="lineNum">    2619 </span><span class="lineCov">          1 :   xmothervertex[6]  = xmothervertex[5];</span>
<span class="lineNum">    2620 </span><span class="lineCov">          1 :   xmothervertex[7]  = xmothervertex[6]-fgkSSDFlexHoleLength;</span>
<span class="lineNum">    2621 </span><span class="lineCov">          1 :   xmothervertex[8]  = xmothervertex[7];</span>
<span class="lineNum">    2622 </span><span class="lineCov">          1 :   xmothervertex[9]  = xmothervertex[8]-ssdflexboxlength[2];</span>
<span class="lineNum">    2623 </span><span class="lineCov">          1 :   xmothervertex[10] = xmothervertex[9]; </span>
<span class="lineNum">    2624 </span><span class="lineCov">          1 :   xmothervertex[11] = xmothervertex[10]-ssdflexboxlength[3];</span>
<span class="lineNum">    2625 </span><span class="lineCov">          1 :   xmothervertex[12] = xmothervertex[11];</span>
<span class="lineNum">    2626 </span><span class="lineCov">          1 :   xmothervertex[13] = xmothervertex[12]-ssdflexboxlength[2];</span>
<span class="lineNum">    2627 </span><span class="lineCov">          1 :   xmothervertex[14] = xmothervertex[13];</span>
<span class="lineNum">    2628 </span><span class="lineCov">          1 :   xmothervertex[15] = xmothervertex[14]-fgkSSDFlexHoleLength;</span>
<span class="lineNum">    2629 </span><span class="lineCov">          1 :   xmothervertex[16] = xmothervertex[15];</span>
<span class="lineNum">    2630 </span><span class="lineCov">          1 :   ymothervertex[0]  = 0.0;</span>
<span class="lineNum">    2631 </span><span class="lineCov">          1 :   ymothervertex[1]  = fgkSSDFlexWidth[1];</span>
<span class="lineNum">    2632 </span><span class="lineCov">          1 :   ymothervertex[2]  = fgkSSDFlexWidth[0];</span>
<span class="lineNum">    2633 </span><span class="lineCov">          1 :   ymothervertex[3]  = ymothervertex[2];</span>
<span class="lineNum">    2634 </span><span class="lineCov">          1 :   ymothervertex[4]  = ymothervertex[0];</span>
<span class="lineNum">    2635 </span><span class="lineCov">          1 :   ymothervertex[5]  = ymothervertex[4];</span>
<span class="lineNum">    2636 </span><span class="lineCov">          1 :   ymothervertex[6]  = ssdflexboxwidth[2];</span>
<span class="lineNum">    2637 </span><span class="lineCov">          1 :   ymothervertex[7]  = ymothervertex[6];</span>
<span class="lineNum">    2638 </span><span class="lineCov">          1 :   ymothervertex[8]  = ymothervertex[0];</span>
<span class="lineNum">    2639 </span><span class="lineCov">          1 :   ymothervertex[9]  = ymothervertex[8];</span>
<span class="lineNum">    2640 </span><span class="lineCov">          1 :   ymothervertex[10] = ssdflexboxwidth[2]-ssdflexboxwidth[3];</span>
<span class="lineNum">    2641 </span><span class="lineCov">          1 :   ymothervertex[11] = ymothervertex[10];</span>
<span class="lineNum">    2642 </span><span class="lineCov">          1 :   ymothervertex[12] = ymothervertex[0];</span>
<span class="lineNum">    2643 </span><span class="lineCov">          1 :   ymothervertex[13] = ymothervertex[12];</span>
<span class="lineNum">    2644 </span><span class="lineCov">          1 :   ymothervertex[14] = ymothervertex[7];</span>
<span class="lineNum">    2645 </span><span class="lineCov">          1 :   ymothervertex[15] = ymothervertex[14];</span>
<span class="lineNum">    2646 </span><span class="lineCov">          1 :   ymothervertex[16] = ymothervertex[0];</span>
<span class="lineNum">    2647 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2648 </span>            :   // First Mother Volume containing SSDFlex
<span class="lineNum">    2649 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2650 </span><span class="lineCov">          1 :   TGeoXtru* ssdflexmothershape = new TGeoXtru(2);</span>
<span class="lineNum">    2651 </span><span class="lineCov">          2 :   ssdflexmothershape-&gt;DefinePolygon(kmothervertexnumber,xmothervertex,</span>
<span class="lineNum">    2652 </span><span class="lineCov">          1 :                                                                     ymothervertex);</span>
<span class="lineNum">    2653 </span><span class="lineCov">          1 :   ssdflexmothershape-&gt;DefineSection(0,-1.5*fgkSSDFlexHeight[0]-2.*fgkSSDFlexHeight[1]);</span>
<span class="lineNum">    2654 </span><span class="lineCov">          1 :   ssdflexmothershape-&gt;DefineSection(1, 0.5*fgkSSDFlexHeight[0]);</span>
<span class="lineNum">    2655 </span><span class="lineCov">          1 :   TGeoVolumeAssembly* ssdflexmother = new TGeoVolumeAssembly(&quot;SSDFlexMother&quot;);</span>
<span class="lineNum">    2656 </span>            : //  TGeoVolume* ssdflexmother = new TGeoVolume(&quot;SSDFlexMother&quot;,ssdflexmothershape,
<span class="lineNum">    2657 </span>            : //                                                                                       fSSDAir);
<span class="lineNum">    2658 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2659 </span>            :   // SSDFlex Layer Shapes
<span class="lineNum">    2660 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2661 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;kssdflexlayernumber; i++){</span>
<span class="lineNum">    2662 </span><span class="lineCov">          2 :         ssdflexshape[i]-&gt;DefinePolygon(kmothervertexnumber,xmothervertex,</span>
<span class="lineNum">    2663 </span>            :                                                                    ymothervertex);
<span class="lineNum">    2664 </span><span class="lineCov">          2 :     ssdflexshape[i]-&gt;DefineSection(0,-0.5*fgkSSDFlexHeight[i]);</span>
<span class="lineNum">    2665 </span><span class="lineCov">          2 :         ssdflexshape[i]-&gt;DefineSection(1, 0.5*fgkSSDFlexHeight[i]);</span>
<span class="lineNum">    2666 </span>            :   }
<span class="lineNum">    2667 </span>            :   /////////////////////////////////////
<span class="lineNum">    2668 </span>            :   // Setting Layers into Mother Volume
<span class="lineNum">    2669 </span>            :   /////////////////////////////////////
<span class="lineNum">    2670 </span><span class="lineCov">          1 :   Int_t ssdflexcolor[kssdflexlayernumber] = {fColorAl,fColorPolyhamide};</span>
<span class="lineNum">    2671 </span><span class="lineCov">          1 :   TGeoMedium* ssdflexmed[kssdflexlayernumber] = {fSSDAlTraceFlexMedium,</span>
<span class="lineNum">    2672 </span><span class="lineCov">          1 :                                                                                                  fSSDKaptonFlexMedium};</span>
<span class="lineNum">    2673 </span><span class="lineCov">          1 :   const char* ssdflexname[2*kssdflexlayernumber] = {&quot;AlFlexLay1&quot;,&quot;KaptonFlexLay1&quot;,</span>
<span class="lineNum">    2674 </span>            :                                                                                                         &quot;AlFlexLay2&quot;,&quot;KaptonFlexLay2&quot;};
<span class="lineNum">    2675 </span><span class="lineCov">          1 :   TGeoVolume* ssdflex[2*kssdflexlayernumber];</span>
<span class="lineNum">    2676 </span><span class="lineCov">          1 :   TGeoTranslation* ssdflextrans[2*kssdflexlayernumber];</span>
<span class="lineNum">    2677 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;2*kssdflexlayernumber; i++){</span>
<span class="lineNum">    2678 </span><span class="lineCov">         12 :         ssdflex[i] = new TGeoVolume(ssdflexname[i],</span>
<span class="lineNum">    2679 </span><span class="lineCov">          4 :                                                                 i%2==0 ? ssdflexshape[0] : ssdflexshape[1],</span>
<span class="lineNum">    2680 </span><span class="lineCov">          4 :                                                                 i%2==0 ? ssdflexmed[0]   : ssdflexmed[1]);</span>
<span class="lineNum">    2681 </span><span class="lineCov">          4 :         ssdflex[i]-&gt;SetLineColor(i%2==0 ? ssdflexcolor[0] : ssdflexcolor[1]);</span>
<span class="lineNum">    2682 </span><span class="lineCov">         12 :     ssdflextrans[i]  = new TGeoTranslation(0.,0.,-0.5*i*(fgkSSDFlexHeight[0]</span>
<span class="lineNum">    2683 </span><span class="lineCov">          4 :                                          +                                         fgkSSDFlexHeight[1])); </span>
<span class="lineNum">    2684 </span><span class="lineCov">          4 :     ssdflexmother-&gt;AddNode(ssdflex[i],1,ssdflextrans[i]);</span>
<span class="lineNum">    2685 </span>            :   }
<span class="lineNum">    2686 </span><span class="lineCov">          1 :   ssdflexmother-&gt;GetShape()-&gt;ComputeBBox(); //RS: enforce recompting of BBox</span>
<span class="lineNum">    2687 </span>            : 
<span class="lineNum">    2688 </span><span class="lineCov">          1 :   return ssdflexmother;</span>
<span class="lineNum">    2689 </span><span class="lineCov">          1 : }</span>
<a name="2690"><span class="lineNum">    2690 </span>            : </a>
<span class="lineNum">    2691 </span>            : /////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    2692 </span>            : TGeoVolume* AliITSv11GeometrySSD::GetSSDEndFlex(){
<span class="lineNum">    2693 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2694 </span>            :   // Method generating SSD End Flex   
<span class="lineNum">    2695 </span>            :   /////////////////////////////////////////
<span class="lineNum">    2696 </span><span class="lineCov">          2 :   Double_t ssdflexradiusmax = (fgkSSDFlexLength[3]-fgkSSDFlexLength[2])</span>
<span class="lineNum">    2697 </span><span class="lineCov">          1 :                                                         /  TMath::Tan(fgkSSDFlexAngle*TMath::DegToRad());</span>
<span class="lineNum">    2698 </span><span class="lineCov">          2 :   Double_t ssdflexboxlength = fgkSSDFlexFullLength-2.*fgkSSDFlexAngle</span>
<span class="lineNum">    2699 </span><span class="lineCov">          1 :                                                 * TMath::DegToRad()*ssdflexradiusmax</span>
<span class="lineNum">    2700 </span><span class="lineCov">          2 :                                                 - fgkSSDFlexLength[2]-TMath::Pi()</span>
<span class="lineNum">    2701 </span><span class="lineCov">          2 :                                                 * fgkSSDStiffenerHeight-fgkSSDFlexLength[0]</span>
<span class="lineNum">    2702 </span><span class="lineCov">          1 :                                                         - 0.1*fgkSSDFlexFullLength;</span>
<span class="lineNum">    2703 </span>            :   const Int_t knedges = 20;  
<span class="lineNum">    2704 </span>            :   const Int_t karcnumber = 2;
<span class="lineNum">    2705 </span><span class="lineCov">          1 :   TVector3* vertexposition[karcnumber*(knedges+1)];</span>
<span class="lineNum">    2706 </span><span class="lineCov">          1 :   Double_t deltangle[karcnumber] = {2.*fgkSSDFlexAngle/knedges,180.0/knedges}; </span>
<span class="lineNum">    2707 </span><span class="lineCov">          1 :   Double_t angle[karcnumber] = {90.-2.*fgkSSDFlexAngle,180.0};  </span>
<span class="lineNum">    2708 </span><span class="lineCov">          1 :   Double_t radius[karcnumber] = {ssdflexradiusmax-fgkSSDStiffenerHeight,fgkSSDStiffenerHeight};</span>
<span class="lineNum">    2709 </span><span class="lineCov">          1 :   Double_t referenceangle[karcnumber] = {-180.0*TMath::DegToRad(),</span>
<span class="lineNum">    2710 </span><span class="lineCov">          1 :                                                                                  - 90.0*TMath::DegToRad()};</span>
<span class="lineNum">    2711 </span><span class="lineCov">          1 :   TVector3* referencetrans[karcnumber];</span>
<span class="lineNum">    2712 </span><span class="lineCov">          4 :   referencetrans[0] = new TVector3(ssdflexboxlength*CosD(2.*fgkSSDFlexAngle)</span>
<span class="lineNum">    2713 </span><span class="lineCov">          2 :                                         +                          radius[0]*SinD(2.*fgkSSDFlexAngle),</span>
<span class="lineNum">    2714 </span><span class="lineCov">          1 :                                    radius[0], 0);</span>
<span class="lineNum">    2715 </span><span class="lineCov">          3 :   referencetrans[1] = new TVector3(referencetrans[0]-&gt;X()</span>
<span class="lineNum">    2716 </span><span class="lineCov">          1 :                                         +              fgkSSDFlexLength[2],</span>
<span class="lineNum">    2717 </span><span class="lineCov">          1 :                                    -              fgkSSDStiffenerHeight, 0);</span>
<span class="lineNum">    2718 </span><span class="lineCov">          6 : for(Int_t i=0; i&lt;karcnumber; i++){</span>
<span class="lineNum">    2719 </span><span class="lineCov">         88 :         for(Int_t j=0; j&lt;knedges+1; j++){</span>
<span class="lineNum">    2720 </span><span class="lineCov">        168 :                 vertexposition[j+i*(knedges+1)] = new TVector3(radius[i]*CosD(angle[i]),</span>
<span class="lineNum">    2721 </span><span class="lineCov">         84 :                                                          radius[i]*SinD(angle[i]), 0);</span>
<span class="lineNum">    2722 </span><span class="lineCov">         42 :                 angle[i] +=  deltangle[i]*(1.0-2.0*i);</span>
<span class="lineNum">    2723 </span>            :         }       
<span class="lineNum">    2724 </span>            :   }
<span class="lineNum">    2725 </span>            :   ///////////////////////
<span class="lineNum">    2726 </span>            :   // Setting the vertices 
<span class="lineNum">    2727 </span>            :   ///////////////////////
<span class="lineNum">    2728 </span>            :   const Int_t kendflexlayernumber = 4;
<span class="lineNum">    2729 </span>            :   const Int_t kendflexvertexnumber = 4*(knedges+1)+2;
<span class="lineNum">    2730 </span><span class="lineCov">          1 :   TVector3** vertex[kendflexlayernumber];</span>
<span class="lineNum">    2731 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;kendflexlayernumber; i++) </span>
<span class="lineNum">    2732 </span><span class="lineCov">          4 :                                         vertex[i] = new TVector3*[kendflexvertexnumber];</span>
<span class="lineNum">    2733 </span><span class="lineCov">          1 :   TVector3* transvector[kendflexlayernumber+1];</span>
<span class="lineNum">    2734 </span><span class="lineCov">          1 :   TVector3* deltatransvector = new TVector3();  </span>
<span class="lineNum">    2735 </span><span class="lineCov">         17 :   for(Int_t i=0; i&lt;kendflexlayernumber+1; i++) transvector[i] = new TVector3();      </span>
<span class="lineNum">    2736 </span><span class="lineCov">          2 :   transvector[0]-&gt;SetXYZ(0.0,ssdflexboxlength*SinD(2.*fgkSSDFlexAngle)</span>
<span class="lineNum">    2737 </span><span class="lineCov">          1 :                                 +                radius[0]*(1.0-CosD(2.*fgkSSDFlexAngle)),0.0);</span>
<span class="lineNum">    2738 </span><span class="lineCov">         10 :   for(Int_t i=1; i&lt;kendflexlayernumber+1; i++){      </span>
<span class="lineNum">    2739 </span><span class="lineCov">          8 :         deltatransvector-&gt;SetXYZ((i%2!=0?fgkSSDFlexHeight[0]:fgkSSDFlexHeight[1])</span>
<span class="lineNum">    2740 </span><span class="lineCov">          4 :                                         *                 CosD(fgkSSDFlexAngle),</span>
<span class="lineNum">    2741 </span><span class="lineCov">          4 :                                                           (i%2!=0?fgkSSDFlexHeight[0]:fgkSSDFlexHeight[1])</span>
<span class="lineNum">    2742 </span><span class="lineCov">          4 :                                         *         SinD(fgkSSDFlexAngle),0.0);   </span>
<span class="lineNum">    2743 </span><span class="lineCov">          4 :         *transvector[i] = *transvector[i-1]+*deltatransvector;</span>
<span class="lineNum">    2744 </span>            :   }
<span class="lineNum">    2745 </span><span class="lineCov">          1 :   Double_t ratioradius[karcnumber][kendflexlayernumber+1];</span>
<span class="lineNum">    2746 </span><span class="lineCov">          1 :   ratioradius[0][0] = 1., ratioradius[1][0] = 1.;</span>
<span class="lineNum">    2747 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;karcnumber; i++){</span>
<span class="lineNum">    2748 </span><span class="lineCov">         20 :         for(Int_t j=1; j&lt;kendflexlayernumber+1; j++){</span>
<span class="lineNum">    2749 </span><span class="lineCov">         16 :                 ratioradius[i][j] = ratioradius[i][j-1]-TMath::Power(-1.0,i)</span>
<span class="lineNum">    2750 </span><span class="lineCov">          8 :                                                   * (j%2!=0?fgkSSDFlexHeight[0]:fgkSSDFlexHeight[1])</span>
<span class="lineNum">    2751 </span><span class="lineCov">          8 :                                               /radius[i];</span>
<span class="lineNum">    2752 </span>            :         }
<span class="lineNum">    2753 </span>            :   }
<span class="lineNum">    2754 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;kendflexlayernumber; i++){</span>
<span class="lineNum">    2755 </span><span class="lineCov">          8 :     vertex[i][0] = new TVector3(transvector[i]-&gt;X(),transvector[i]-&gt;Y(),0);</span>
<span class="lineNum">    2756 </span><span class="lineCov">          8 :     vertex[i][1] = new TVector3(transvector[i+1]-&gt;X(),transvector[i+1]-&gt;Y(),0);</span>
<span class="lineNum">    2757 </span><span class="lineCov">        344 :         for(Int_t j=0; j&lt;karcnumber*(knedges+1); j++){</span>
<span class="lineNum">    2758 </span><span class="lineCov">        336 :                 if(j&lt;(knedges+1)){</span>
<span class="lineNum">    2759 </span><span class="lineCov">        420 :                         vertex[i][j+2] = new TVector3(vertexposition[j]-&gt;X()*ratioradius[0][i+1],</span>
<span class="lineNum">    2760 </span><span class="lineCov">         84 :                                                 vertexposition[j]-&gt;Y()*ratioradius[0][i+1], 0);</span>
<span class="lineNum">    2761 </span><span class="lineCov">         84 :                         vertex[i][j+2]-&gt;RotateZ(referenceangle[0]);</span>
<span class="lineNum">    2762 </span><span class="lineCov">         84 :                         *vertex[i][j+2] += *referencetrans[0];</span>
<span class="lineNum">    2763 </span><span class="lineCov">         84 :                         vertex[i][4*(knedges+1)-j+1] = </span>
<span class="lineNum">    2764 </span><span class="lineCov">        168 :                                                          new TVector3(vertexposition[j]-&gt;X()*ratioradius[0][i],</span>
<span class="lineNum">    2765 </span><span class="lineCov">         84 :                                  vertexposition[j]-&gt;Y()*ratioradius[0][i], 0);</span>
<span class="lineNum">    2766 </span><span class="lineCov">         84 :                         vertex[i][4*(knedges+1)-j+1]-&gt;RotateZ(referenceangle[0]);</span>
<span class="lineNum">    2767 </span><span class="lineCov">         84 :                         *vertex[i][4*(knedges+1)-j+1] += *referencetrans[0];</span>
<span class="lineNum">    2768 </span><span class="lineCov">         84 :                 }</span>
<span class="lineNum">    2769 </span>            :                 else{
<span class="lineNum">    2770 </span>            :                 
<span class="lineNum">    2771 </span><span class="lineCov">        252 :                         vertex[i][j+2] = new TVector3(vertexposition[j]-&gt;X()*ratioradius[1][i+1],</span>
<span class="lineNum">    2772 </span><span class="lineCov">         84 :                                                 vertexposition[j]-&gt;Y()*ratioradius[1][i+1],0);</span>
<span class="lineNum">    2773 </span><span class="lineCov">         84 :                         vertex[i][j+2]-&gt;RotateZ(referenceangle[1]);</span>
<span class="lineNum">    2774 </span><span class="lineCov">         84 :                         *vertex[i][j+2] += *referencetrans[1];</span>
<span class="lineNum">    2775 </span><span class="lineCov">         84 :                         vertex[i][4*(knedges+1)-j+1] = </span>
<span class="lineNum">    2776 </span><span class="lineCov">        168 :                                                          new TVector3(vertexposition[j]-&gt;X()*ratioradius[1][i],</span>
<span class="lineNum">    2777 </span><span class="lineCov">         84 :                                        vertexposition[j]-&gt;Y()*ratioradius[1][i],</span>
<span class="lineNum">    2778 </span>            :                                        0);
<span class="lineNum">    2779 </span><span class="lineCov">         84 :                         vertex[i][4*(knedges+1)-j+1]-&gt;RotateZ(referenceangle[1]);</span>
<span class="lineNum">    2780 </span><span class="lineCov">         84 :                         *vertex[i][4*(knedges+1)-j+1] += *referencetrans[1];</span>
<span class="lineNum">    2781 </span>            :            }
<span class="lineNum">    2782 </span>            :         }
<span class="lineNum">    2783 </span>            :   }
<span class="lineNum">    2784 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2785 </span>            :   // First Mother Volume containing SSDEndFlex
<span class="lineNum">    2786 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2787 </span><span class="lineCov">          1 :   TGeoXtru* ssdendflexmothershape = new TGeoXtru(2);</span>
<span class="lineNum">    2788 </span><span class="lineCov">          1 :   Double_t xmothervertex[kendflexvertexnumber];</span>
<span class="lineNum">    2789 </span><span class="lineCov">          1 :   Double_t ymothervertex[kendflexvertexnumber];</span>
<span class="lineNum">    2790 </span><span class="lineCov">          1 :   xmothervertex[0] = vertex[0][0]-&gt;X();      </span>
<span class="lineNum">    2791 </span><span class="lineCov">          1 :   ymothervertex[0] = vertex[0][0]-&gt;Y();</span>
<span class="lineNum">    2792 </span><span class="lineCov">        172 :   for(Int_t i=1; i&lt;kendflexvertexnumber; i++){</span>
<span class="lineNum">    2793 </span><span class="lineCov">        170 :         if(i&lt;2*(knedges+1)+2){</span>
<span class="lineNum">    2794 </span><span class="lineCov">        128 :                 xmothervertex[i] = vertex[3][i]-&gt;X();</span>
<span class="lineNum">    2795 </span><span class="lineCov">         43 :                 ymothervertex[i] = vertex[3][i]-&gt;Y();</span>
<span class="lineNum">    2796 </span><span class="lineCov">         43 :         }</span>
<span class="lineNum">    2797 </span>            :         else{
<span class="lineNum">    2798 </span><span class="lineCov">         42 :                 xmothervertex[i] = vertex[0][i]-&gt;X();</span>
<span class="lineNum">    2799 </span><span class="lineCov">         42 :                 ymothervertex[i] = vertex[0][i]-&gt;Y();</span>
<span class="lineNum">    2800 </span>            :         }
<span class="lineNum">    2801 </span>            :   }
<span class="lineNum">    2802 </span><span class="lineCov">          1 :   ssdendflexmothershape-&gt;DefinePolygon(kendflexvertexnumber,</span>
<span class="lineNum">    2803 </span><span class="lineCov">          1 :                                                                            xmothervertex,ymothervertex);</span>
<span class="lineNum">    2804 </span><span class="lineCov">          1 :   ssdendflexmothershape-&gt;DefineSection(0,-0.5*fgkSSDFlexWidth[0]);</span>
<span class="lineNum">    2805 </span><span class="lineCov">          1 :   ssdendflexmothershape-&gt;DefineSection(1, 0.5*fgkSSDFlexWidth[0]);</span>
<span class="lineNum">    2806 </span>            : //  TGeoVolume* ssdendflexmother = new TGeoVolume(&quot;SSDEndFlexMother&quot;,
<span class="lineNum">    2807 </span>            : //                                                               ssdendflexmothershape,fSSDAir);        
<span class="lineNum">    2808 </span><span class="lineCov">          1 :   TGeoVolumeAssembly* ssdendflexmother = new TGeoVolumeAssembly(&quot;SSDEndFlexMother&quot;);</span>
<span class="lineNum">    2809 </span>            :   //////////////////////////////////////
<span class="lineNum">    2810 </span>            :   // End Flex TGeoXtru Layer Definition 
<span class="lineNum">    2811 </span>            :   //////////////////////////////////////
<span class="lineNum">    2812 </span><span class="lineCov">          1 :   TGeoXtru* ssdendflexshape[kendflexlayernumber];</span>
<span class="lineNum">    2813 </span><span class="lineCov">          1 :   TGeoVolume* ssdendflex[kendflexlayernumber];</span>
<span class="lineNum">    2814 </span><span class="lineCov">         14 :   for(Int_t i=0; i&lt;kendflexlayernumber; i++) ssdendflexshape[i] = new TGeoXtru(2);</span>
<span class="lineNum">    2815 </span><span class="lineCov">          1 :   Double_t xvertex[kendflexlayernumber][kendflexvertexnumber];</span>
<span class="lineNum">    2816 </span><span class="lineCov">          1 :   Double_t yvertex[kendflexlayernumber][kendflexvertexnumber];</span>
<span class="lineNum">    2817 </span><span class="lineCov">          3 :   Int_t ssdendflexcolor[kendflexlayernumber] = {fColorAl,fColorPolyhamide};</span>
<span class="lineNum">    2818 </span><span class="lineCov">          4 :   TGeoMedium* ssdendflexmed[kendflexlayernumber] = {fSSDAlTraceFlexMedium,</span>
<span class="lineNum">    2819 </span><span class="lineCov">          1 :                                                                                                         fSSDKaptonFlexMedium};</span>
<span class="lineNum">    2820 </span><span class="lineCov">          1 :   const char* ssdendflexname[kendflexlayernumber] = {&quot;AlEndFlexLay1&quot;,&quot;KaptonEndFlexLay1&quot;,</span>
<span class="lineNum">    2821 </span>            :                                                                                                          &quot;AlEndFlexLay2&quot;,&quot;KaptonEndFlexLay2&quot;};
<span class="lineNum">    2822 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;kendflexlayernumber; i++){</span>
<span class="lineNum">    2823 </span><span class="lineCov">        696 :         for(Int_t j=0; j&lt;4*(knedges+1)+2; j++){</span>
<span class="lineNum">    2824 </span><span class="lineCov">        344 :                 xvertex[i][j] = vertex[i][j]-&gt;X();</span>
<span class="lineNum">    2825 </span><span class="lineCov">        344 :                 yvertex[i][j] = vertex[i][j]-&gt;Y();</span>
<span class="lineNum">    2826 </span>            :         }
<span class="lineNum">    2827 </span><span class="lineCov">          4 :   ssdendflexshape[i]-&gt;DefinePolygon(kendflexvertexnumber,xvertex[i],yvertex[i]);</span>
<span class="lineNum">    2828 </span><span class="lineCov">          4 :   ssdendflexshape[i]-&gt;DefineSection(0,-0.5*fgkSSDFlexWidth[0]);</span>
<span class="lineNum">    2829 </span><span class="lineCov">          4 :   ssdendflexshape[i]-&gt;DefineSection(1, 0.5*fgkSSDFlexWidth[0]);</span>
<span class="lineNum">    2830 </span><span class="lineCov">         12 :   ssdendflex[i] = new TGeoVolume(ssdendflexname[i],ssdendflexshape[i],</span>
<span class="lineNum">    2831 </span><span class="lineCov">          4 :                                                                  i%2==0 ? ssdendflexmed[0] : ssdendflexmed[1]);</span>
<span class="lineNum">    2832 </span><span class="lineCov">          4 :   ssdendflex[i]-&gt;SetLineColor(i%2==0 ? ssdendflexcolor[0] : ssdendflexcolor[1]);</span>
<span class="lineNum">    2833 </span><span class="lineCov">          4 :   ssdendflexmother-&gt;AddNode(ssdendflex[i],1);</span>
<span class="lineNum">    2834 </span>            :   }
<span class="lineNum">    2835 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2836 </span>            :   // Deallocating memory
<span class="lineNum">    2837 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2838 </span><span class="lineCov">        170 :   for(Int_t i=0; i&lt;karcnumber*(knedges+1); i++) delete vertexposition[i];</span>
<span class="lineNum">    2839 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;karcnumber; i++) delete referencetrans[i];</span>
<span class="lineNum">    2840 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;kendflexlayernumber; i++){</span>
<span class="lineNum">    2841 </span><span class="lineCov">       1384 :         for(Int_t j=0; j&lt;kendflexvertexnumber; j++) delete vertex[i][j];</span>
<span class="lineNum">    2842 </span><span class="lineCov">          8 :         delete [] vertex[i];</span>
<span class="lineNum">    2843 </span>            :   }
<span class="lineNum">    2844 </span><span class="lineCov">         22 :   for(Int_t i=0; i&lt;kendflexlayernumber+1; i++) delete transvector[i];</span>
<span class="lineNum">    2845 </span>            : 
<span class="lineNum">    2846 </span><span class="lineCov">          1 :   ssdendflexmother-&gt;GetShape()-&gt;ComputeBBox(); //RS: enforce recompting of BBox</span>
<span class="lineNum">    2847 </span>            :         
<span class="lineNum">    2848 </span><span class="lineCov">          2 :   delete deltatransvector;</span>
<span class="lineNum">    2849 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2850 </span>            :   //ssdendflexmother-&gt;CheckOverlaps(0.01);
<span class="lineNum">    2851 </span><span class="lineCov">          1 :   return ssdendflexmother;</span>
<a name="2852"><span class="lineNum">    2852 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">    2853 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    2854 </span>            : TGeoVolume* AliITSv11GeometrySSD::GetSSDMountingBlock(){
<span class="lineNum">    2855 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2856 </span>            :   // Method generating the Mounting Block
<span class="lineNum">    2857 </span>            :   /////////////////////////////////////////////////////////////  
<span class="lineNum">    2858 </span>            :   const Int_t kvertexnumber = 8;
<span class="lineNum">    2859 </span><span class="lineCov">          2 :   Double_t xvertex[kvertexnumber];</span>
<span class="lineNum">    2860 </span><span class="lineCov">          1 :   Double_t yvertex[kvertexnumber];</span>
<span class="lineNum">    2861 </span><span class="lineCov">          1 :   xvertex[0] = -0.25*(fgkSSDMountingBlockLength[0]-fgkSSDMountingBlockLength[1]); </span>
<span class="lineNum">    2862 </span><span class="lineCov">          1 :   xvertex[1] = xvertex[0];</span>
<span class="lineNum">    2863 </span><span class="lineCov">          1 :   xvertex[2] = -xvertex[0];</span>
<span class="lineNum">    2864 </span><span class="lineCov">          1 :   xvertex[3] = xvertex[2];</span>
<span class="lineNum">    2865 </span><span class="lineCov">          2 :   xvertex[4] = xvertex[3]+0.5*(fgkSSDMountingBlockLength[1]</span>
<span class="lineNum">    2866 </span><span class="lineCov">          1 :                          -                                 fgkSSDMountingBlockLength[2]);</span>
<span class="lineNum">    2867 </span><span class="lineCov">          1 :   xvertex[5] = xvertex[4];</span>
<span class="lineNum">    2868 </span><span class="lineCov">          2 :   xvertex[6] = 0.5*fgkSSDMountingBlockLength[0]-xvertex[2]</span>
<span class="lineNum">    2869 </span><span class="lineCov">          1 :                          - 0.5*fgkSSDMountingBlockScrewHoleEdge</span>
<span class="lineNum">    2870 </span><span class="lineCov">          1 :                          -     fgkSSDMountingBlockScrewHoleRadius[0];</span>
<span class="lineNum">    2871 </span><span class="lineCov">          1 :   xvertex[7] = xvertex[6];</span>
<span class="lineNum">    2872 </span><span class="lineCov">          2 :   yvertex[0] = -0.5*fgkCoolingTubeSupportHeight-fgkSSDModuleCoolingBlockToSensor</span>
<span class="lineNum">    2873 </span><span class="lineCov">          1 :                          +      fgkSSDMountingBlockHeight[1]-0.5*fgkSSDMountingBlockHeight[0];</span>
<span class="lineNum">    2874 </span><span class="lineCov">          1 :   yvertex[1] = 0.5*fgkSSDMountingBlockHeight[0];</span>
<span class="lineNum">    2875 </span><span class="lineCov">          1 :   yvertex[2] = yvertex[1]; </span>
<span class="lineNum">    2876 </span><span class="lineCov">          1 :   yvertex[3] = fgkSSDMountingBlockHeight[1]-yvertex[1];</span>
<span class="lineNum">    2877 </span><span class="lineCov">          1 :   yvertex[4] = yvertex[3];</span>
<span class="lineNum">    2878 </span><span class="lineCov">          2 :   yvertex[5] = yvertex[2]+fgkSSDMountingBlockHeight[2]</span>
<span class="lineNum">    2879 </span><span class="lineCov">          1 :                          - fgkSSDMountingBlockHeight[0];</span>
<span class="lineNum">    2880 </span><span class="lineCov">          1 :   yvertex[6] = yvertex[5];</span>
<span class="lineNum">    2881 </span><span class="lineCov">          1 :   yvertex[7] = yvertex[0];</span>
<span class="lineNum">    2882 </span>            : 
<span class="lineNum">    2883 </span>            :   ///////////////////////////////////////////////////////////////////////
<span class="lineNum">    2884 </span>            :   // TGeoXTru Volume definition for Mounting Block Part
<span class="lineNum">    2885 </span>            :   ///////////////////////////////////////////////////////////////////////
<span class="lineNum">    2886 </span><span class="lineCov">          1 :   TGeoXtru* ssdmountingblockshape = new TGeoXtru(2);</span>
<span class="lineNum">    2887 </span><span class="lineCov">          1 :   ssdmountingblockshape-&gt;DefinePolygon(kvertexnumber,xvertex,yvertex);</span>
<span class="lineNum">    2888 </span><span class="lineCov">          1 :   ssdmountingblockshape-&gt;DefineSection(0,-0.5*fgkSSDMountingBlockWidth);</span>
<span class="lineNum">    2889 </span><span class="lineCov">          1 :   ssdmountingblockshape-&gt;DefineSection(1,0.5*fgkSSDMountingBlockWidth);</span>
<span class="lineNum">    2890 </span><span class="lineCov">          2 :   TGeoVolume* ssdmountingblock = new TGeoVolume(&quot;SSDMountingBlock&quot;,</span>
<span class="lineNum">    2891 </span><span class="lineCov">          1 :                                                                           ssdmountingblockshape,</span>
<span class="lineNum">    2892 </span><span class="lineCov">          1 :                                                                                   fSSDMountingBlockMedium);</span>
<span class="lineNum">    2893 </span><span class="lineCov">          1 :   ssdmountingblock-&gt;SetLineColor(fColorG10);</span>
<span class="lineNum">    2894 </span><span class="lineCov">          1 :   TGeoCombiTrans* mountingblockcombitrans = new TGeoCombiTrans();</span>
<span class="lineNum">    2895 </span><span class="lineCov">          1 :   mountingblockcombitrans-&gt;SetTranslation(2.*xvertex[2]+fgkSSDMountingBlockLength[1],0.,0.);</span>
<span class="lineNum">    2896 </span><span class="lineCov">          1 :   TGeoRotation* mountingblockrot = new TGeoRotation();</span>
<span class="lineNum">    2897 </span><span class="lineCov">          1 :   mountingblockrot-&gt;SetAngles(90.,180.,-90.);</span>
<span class="lineNum">    2898 </span><span class="lineCov">          1 :   mountingblockcombitrans-&gt;SetRotation(*mountingblockrot);</span>
<span class="lineNum">    2899 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    2900 </span>            :   // Generating the Mounting Block Screw Vertices 
<span class="lineNum">    2901 </span>            :   /////////////////////////////////////////////////////////////  
<span class="lineNum">    2902 </span>            :   const Int_t kscrewvertexnumber = 15;
<span class="lineNum">    2903 </span><span class="lineCov">          3 :   Double_t alpha = TMath::ACos(0.5*(fgkSSDMountingBlockHeight[1]</span>
<span class="lineNum">    2904 </span><span class="lineCov">          1 :                                  -                                      fgkSSDMountingBlockScrewHoleEdge)</span>
<span class="lineNum">    2905 </span><span class="lineCov">          1 :                                  /                              fgkSSDMountingBlockScrewHoleRadius[0])</span>
<span class="lineNum">    2906 </span><span class="lineCov">          1 :                                  * TMath::RadToDeg();</span>
<span class="lineNum">    2907 </span><span class="lineCov">          1 :   Double_t phi0 = 90.+alpha;</span>
<span class="lineNum">    2908 </span><span class="lineCov">          1 :   Double_t phi = 270.-2*alpha;</span>
<span class="lineNum">    2909 </span><span class="lineCov">          1 :   Double_t deltaphi = phi/kscrewvertexnumber;   </span>
<span class="lineNum">    2910 </span><span class="lineCov">          1 :   TVector3* screwvertex[kscrewvertexnumber+1];</span>
<span class="lineNum">    2911 </span><span class="lineCov">         34 :   for(Int_t i=0; i&lt;kscrewvertexnumber+1; i++)        </span>
<span class="lineNum">    2912 </span><span class="lineCov">         48 :         screwvertex[i] = new TVector3(fgkSSDMountingBlockScrewHoleRadius[0]</span>
<span class="lineNum">    2913 </span><span class="lineCov">         32 :                                    *CosD(phi0+i*deltaphi),</span>
<span class="lineNum">    2914 </span><span class="lineCov">         16 :                                    fgkSSDMountingBlockScrewHoleRadius[0]</span>
<span class="lineNum">    2915 </span><span class="lineCov">         32 :                                       *SinD(phi0+i*deltaphi), 0);</span>
<span class="lineNum">    2916 </span><span class="lineCov">          1 :   Double_t xscrewvertex[kscrewvertexnumber+6];</span>
<span class="lineNum">    2917 </span><span class="lineCov">          1 :   Double_t yscrewvertex[kscrewvertexnumber+6];</span>
<span class="lineNum">    2918 </span><span class="lineCov">          1 :   xscrewvertex[0] = - fgkSSDMountingBlockScrewHoleRadius[0];    </span>
<span class="lineNum">    2919 </span><span class="lineCov">          2 :   yscrewvertex[0] = -0.5*(fgkSSDMountingBlockWidth</span>
<span class="lineNum">    2920 </span><span class="lineCov">          1 :                                   -               fgkSSDMountingBlockScrewHoleEdge);</span>
<span class="lineNum">    2921 </span><span class="lineCov">          1 :   xscrewvertex[1] = xscrewvertex[0];</span>
<span class="lineNum">    2922 </span><span class="lineCov">          1 :   yscrewvertex[1] = 0.5*fgkSSDMountingBlockScrewHoleEdge;</span>
<span class="lineNum">    2923 </span><span class="lineCov">          1 :   xscrewvertex[2] = screwvertex[0]-&gt;X();</span>
<span class="lineNum">    2924 </span><span class="lineCov">          1 :   yscrewvertex[2] = yscrewvertex[1];</span>
<span class="lineNum">    2925 </span><span class="lineCov">         34 :   for(Int_t i=0; i&lt;kscrewvertexnumber+1; i++){</span>
<span class="lineNum">    2926 </span><span class="lineCov">         16 :         xscrewvertex[i+3] = screwvertex[i]-&gt;X();     </span>
<span class="lineNum">    2927 </span><span class="lineCov">         16 :         yscrewvertex[i+3] = screwvertex[i]-&gt;Y();     </span>
<span class="lineNum">    2928 </span>            :   } 
<span class="lineNum">    2929 </span><span class="lineCov">          1 :   xscrewvertex[kscrewvertexnumber+4] = 0.5*fgkSSDMountingBlockScrewHoleEdge;    </span>
<span class="lineNum">    2930 </span><span class="lineCov">          1 :   yscrewvertex[kscrewvertexnumber+4] = yscrewvertex[kscrewvertexnumber+3];      </span>
<span class="lineNum">    2931 </span><span class="lineCov">          1 :   xscrewvertex[kscrewvertexnumber+5] = xscrewvertex[kscrewvertexnumber+4];</span>
<span class="lineNum">    2932 </span><span class="lineCov">          1 :   yscrewvertex[kscrewvertexnumber+5] = yscrewvertex[0];</span>
<span class="lineNum">    2933 </span><span class="lineCov">          1 :   TGeoXtru* ssdmountingblockscrewshape = new TGeoXtru(2);</span>
<span class="lineNum">    2934 </span><span class="lineCov">          1 :   ssdmountingblockscrewshape-&gt;DefinePolygon(kscrewvertexnumber+6,xscrewvertex,yscrewvertex);</span>
<span class="lineNum">    2935 </span><span class="lineCov">          1 :   ssdmountingblockscrewshape-&gt;DefineSection(0,yvertex[0]);</span>
<span class="lineNum">    2936 </span><span class="lineCov">          2 :   ssdmountingblockscrewshape-&gt;DefineSection(1,-0.5*fgkSSDMountingBlockHeight[0]</span>
<span class="lineNum">    2937 </span><span class="lineCov">          1 :                                                         +                                  fgkSSDMountingBlockHeight[2]);</span>
<span class="lineNum">    2938 </span><span class="lineCov">          2 :   TGeoVolume* ssdmountingblockscrew = new TGeoVolume(&quot;SSDMountingBlockScrew&quot;,</span>
<span class="lineNum">    2939 </span><span class="lineCov">          1 :                                                                                 ssdmountingblockscrewshape,</span>
<span class="lineNum">    2940 </span><span class="lineCov">          1 :                                                                                             fSSDMountingBlockMedium);</span>
<span class="lineNum">    2941 </span><span class="lineCov">          1 :   ssdmountingblockscrew-&gt;SetLineColor(fColorG10);</span>
<span class="lineNum">    2942 </span><span class="lineCov">          1 :   TGeoCombiTrans* ssdmountingblockscrewcombitrans[4];</span>
<span class="lineNum">    2943 </span><span class="lineCov">         14 :   for(Int_t i=0; i&lt;4; i++) ssdmountingblockscrewcombitrans[i] = new TGeoCombiTrans();</span>
<span class="lineNum">    2944 </span><span class="lineCov">          2 :   ssdmountingblockscrewcombitrans[0]-&gt;SetTranslation(-0.5*fgkSSDMountingBlockScrewHoleEdge,</span>
<span class="lineNum">    2945 </span><span class="lineCov">          1 :                                                                         -                                yscrewvertex[1],</span>
<span class="lineNum">    2946 </span><span class="lineCov">          1 :                                                                                                          0.5*fgkSSDMountingBlockHeight[0]</span>
<span class="lineNum">    2947 </span><span class="lineCov">          1 :                                                                         -                                fgkSSDMountingBlockHeight[2]</span>
<span class="lineNum">    2948 </span><span class="lineCov">          2 :                                                                         +                                0.5*(-0.5*fgkSSDMountingBlockHeight[0]</span>
<span class="lineNum">    2949 </span><span class="lineCov">          1 :                                                                         +                                fgkSSDMountingBlockHeight[2]</span>
<span class="lineNum">    2950 </span><span class="lineCov">          1 :                                                                         -                                yvertex[0]));</span>
<span class="lineNum">    2951 </span><span class="lineCov">          2 :   ssdmountingblockscrewcombitrans[1]-&gt;SetTranslation(0.5*fgkSSDMountingBlockScrewHoleEdge,</span>
<span class="lineNum">    2952 </span><span class="lineCov">          1 :                                                                                                         -0.5*fgkSSDMountingBlockScrewHoleEdge,</span>
<span class="lineNum">    2953 </span><span class="lineCov">          1 :                                                                                                                  yscrewvertex[1]</span>
<span class="lineNum">    2954 </span><span class="lineCov">          2 :                                                                                                         -0.5*(-0.5*fgkSSDMountingBlockHeight[0]</span>
<span class="lineNum">    2955 </span><span class="lineCov">          1 :                                                                                                          +fgkSSDMountingBlockHeight[2]</span>
<span class="lineNum">    2956 </span><span class="lineCov">          1 :                                                                                                          -yvertex[0]));</span>
<span class="lineNum">    2957 </span><span class="lineCov">          2 :   ssdmountingblockscrewcombitrans[2]-&gt;SetTranslation(-0.5*fgkSSDMountingBlockScrewHoleEdge,</span>
<span class="lineNum">    2958 </span><span class="lineCov">          1 :                                                                                                           yscrewvertex[1],</span>
<span class="lineNum">    2959 </span><span class="lineCov">          1 :                                                                         -                                 0.5*fgkSSDMountingBlockHeight[0]</span>
<span class="lineNum">    2960 </span><span class="lineCov">          1 :                                                                         +                                 fgkSSDMountingBlockHeight[2]</span>
<span class="lineNum">    2961 </span><span class="lineCov">          1 :                                                                         -                                 0.5*(-0.5*fgkSSDMountingBlockHeight[0]</span>
<span class="lineNum">    2962 </span>            :                                                                         +                                 fgkSSDMountingBlockHeight[2]
<span class="lineNum">    2963 </span><span class="lineCov">          1 :                                                                         -                                 yvertex[0]));</span>
<span class="lineNum">    2964 </span><span class="lineCov">          2 :   ssdmountingblockscrewcombitrans[3]-&gt;SetTranslation(0.5*fgkSSDMountingBlockScrewHoleEdge,</span>
<span class="lineNum">    2965 </span><span class="lineCov">          1 :                                                                                                          yscrewvertex[1],</span>
<span class="lineNum">    2966 </span><span class="lineCov">          1 :                                                                         -                                yscrewvertex[1]</span>
<span class="lineNum">    2967 </span><span class="lineCov">          2 :                                                                         +                                0.5*(-0.5*fgkSSDMountingBlockHeight[0]</span>
<span class="lineNum">    2968 </span><span class="lineCov">          1 :                                                                         +                                fgkSSDMountingBlockHeight[2]</span>
<span class="lineNum">    2969 </span><span class="lineCov">          1 :                                                                         -                                yvertex[0]));</span>
<span class="lineNum">    2970 </span><span class="lineCov">          1 :   TGeoRotation* ssdmountingblockscrewrot[4];</span>
<span class="lineNum">    2971 </span><span class="lineCov">         14 :   for(Int_t i=0; i&lt;4; i++) ssdmountingblockscrewrot[i] = new TGeoRotation();</span>
<span class="lineNum">    2972 </span><span class="lineCov">          1 :         ssdmountingblockscrewrot[1]-&gt;SetAngles(90.,-180.,-90.);      </span>
<span class="lineNum">    2973 </span><span class="lineCov">          1 :     ssdmountingblockscrewrot[2]-&gt;SetAngles(0.,180.,0.);      </span>
<span class="lineNum">    2974 </span><span class="lineCov">          1 :     ssdmountingblockscrewrot[3]-&gt;SetAngles(180.,0.,0.);      </span>
<span class="lineNum">    2975 </span><span class="lineCov">          8 :   for(Int_t i=1; i&lt;4; i++) </span>
<span class="lineNum">    2976 </span><span class="lineCov">          3 :         ssdmountingblockscrewcombitrans[i]-&gt;SetRotation(*ssdmountingblockscrewrot[i]);</span>
<span class="lineNum">    2977 </span><span class="lineCov">          1 :   TGeoRotation* ssdmountingblockglobalrot = new TGeoRotation();</span>
<span class="lineNum">    2978 </span><span class="lineCov">          1 :   ssdmountingblockglobalrot-&gt;SetAngles(0.,90.,0.);   </span>
<span class="lineNum">    2979 </span><span class="lineCov">          1 :   TGeoTranslation* ssdmountingblockglobaltrans = new TGeoTranslation();</span>
<span class="lineNum">    2980 </span><span class="lineCov">          2 :   ssdmountingblockglobaltrans-&gt;SetTranslation(0.5*fgkSSDMountingBlockLength[0]</span>
<span class="lineNum">    2981 </span><span class="lineCov">          1 :                                                          +                                xvertex[0],yscrewvertex[1]</span>
<span class="lineNum">    2982 </span><span class="lineCov">          2 :                                                          -                                0.5*(-0.5*fgkSSDMountingBlockHeight[0]</span>
<span class="lineNum">    2983 </span><span class="lineCov">          1 :                                                          +                                fgkSSDMountingBlockHeight[2]</span>
<span class="lineNum">    2984 </span><span class="lineCov">          1 :                                                          -                                yvertex[0]),0.);      </span>
<span class="lineNum">    2985 </span><span class="lineCov">          1 :   TGeoHMatrix* ssdmountingblockscrewmatrix[4];</span>
<span class="lineNum">    2986 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;4; i++){</span>
<span class="lineNum">    2987 </span><span class="lineCov">          4 :         ssdmountingblockscrewmatrix[i] = </span>
<span class="lineNum">    2988 </span><span class="lineCov">          8 :                 new TGeoHMatrix((*ssdmountingblockglobalrot)*(*ssdmountingblockscrewcombitrans[i])); </span>
<span class="lineNum">    2989 </span><span class="lineCov">          4 :         ssdmountingblockscrewmatrix[i]-&gt;MultiplyLeft(ssdmountingblockglobaltrans);</span>
<span class="lineNum">    2990 </span>            :   }
<span class="lineNum">    2991 </span>            :   ///////////////////////////////////////////////////////////////////////
<span class="lineNum">    2992 </span>            :   // TGeoXtru for Mother Volume 
<span class="lineNum">    2993 </span>            :   ///////////////////////////////////////////////////////////////////////
<span class="lineNum">    2994 </span>            :   const Int_t kvertexmothernumber = 12;
<span class="lineNum">    2995 </span><span class="lineCov">          1 :   Double_t xmothervertex[kvertexmothernumber];</span>
<span class="lineNum">    2996 </span><span class="lineCov">          1 :   Double_t ymothervertex[kvertexmothernumber];</span>
<span class="lineNum">    2997 </span><span class="lineCov">         14 :   for(Int_t i=0; i&lt;6; i++){</span>
<span class="lineNum">    2998 </span><span class="lineCov">          6 :         xmothervertex[i] = xvertex[i];</span>
<span class="lineNum">    2999 </span><span class="lineCov">          6 :         ymothervertex[i] = yvertex[i];</span>
<span class="lineNum">    3000 </span>            :   } 
<span class="lineNum">    3001 </span><span class="lineCov">          1 :   xmothervertex[6]  = xvertex[5]+fgkSSDMountingBlockLength[2];</span>
<span class="lineNum">    3002 </span><span class="lineCov">          1 :   ymothervertex[6]  = ymothervertex[5];</span>
<span class="lineNum">    3003 </span><span class="lineCov">          1 :   xmothervertex[7]  = xmothervertex[6];</span>
<span class="lineNum">    3004 </span><span class="lineCov">          1 :   ymothervertex[7]  = ymothervertex[4] - fgkSSDTolerance;</span>
<span class="lineNum">    3005 </span><span class="lineCov">          2 :   xmothervertex[8]  = xmothervertex[7]</span>
<span class="lineNum">    3006 </span><span class="lineCov">          2 :                                         + 0.5*(fgkSSDMountingBlockLength[1]</span>
<span class="lineNum">    3007 </span><span class="lineCov">          1 :                                         -          fgkSSDMountingBlockLength[2]);</span>
<span class="lineNum">    3008 </span><span class="lineCov">          1 :   ymothervertex[8]  = ymothervertex[7];</span>
<span class="lineNum">    3009 </span><span class="lineCov">          1 :   xmothervertex[9]  = xmothervertex[8];</span>
<span class="lineNum">    3010 </span><span class="lineCov">          1 :   ymothervertex[9]  = ymothervertex[2];</span>
<span class="lineNum">    3011 </span><span class="lineCov">          1 :   xmothervertex[10] = xvertex[0]+fgkSSDMountingBlockLength[0];</span>
<span class="lineNum">    3012 </span><span class="lineCov">          1 :   ymothervertex[10] = ymothervertex[1];</span>
<span class="lineNum">    3013 </span><span class="lineCov">          1 :   xmothervertex[11] = xmothervertex[10];</span>
<span class="lineNum">    3014 </span><span class="lineCov">          1 :   ymothervertex[11] = ymothervertex[0];  </span>
<span class="lineNum">    3015 </span><span class="lineCov">          1 :   TGeoXtru* ssdmountingblockmothershape = new TGeoXtru(2);</span>
<span class="lineNum">    3016 </span><span class="lineCov">          1 :   ssdmountingblockmothershape-&gt;DefinePolygon(kvertexmothernumber,xmothervertex,ymothervertex);</span>
<span class="lineNum">    3017 </span><span class="lineCov">          1 :   ssdmountingblockmothershape-&gt;DefineSection(0,-0.5*fgkSSDMountingBlockWidth);</span>
<span class="lineNum">    3018 </span><span class="lineCov">          1 :   ssdmountingblockmothershape-&gt;DefineSection(1,0.5*fgkSSDMountingBlockWidth);</span>
<span class="lineNum">    3019 </span><span class="lineCov">          2 :   TGeoVolume* ssdmountingblockmother = new TGeoVolume(&quot;SSDMountingBlockMother&quot;,</span>
<span class="lineNum">    3020 </span><span class="lineCov">          1 :                                                                           ssdmountingblockmothershape,</span>
<span class="lineNum">    3021 </span><span class="lineCov">          1 :                                                                                   fSSDAir);</span>
<span class="lineNum">    3022 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3023 </span>            :   // Placing the Volumes into Mother Volume 
<span class="lineNum">    3024 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3025 </span><span class="lineCov">          1 :   ssdmountingblockmother-&gt;AddNode(ssdmountingblock,1);</span>
<span class="lineNum">    3026 </span><span class="lineCov">          1 :   ssdmountingblockmother-&gt;AddNode(ssdmountingblock,2,mountingblockcombitrans);</span>
<span class="lineNum">    3027 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;4; i++) </span>
<span class="lineNum">    3028 </span><span class="lineCov">          8 :         ssdmountingblockmother-&gt;AddNode(ssdmountingblockscrew,i+1,</span>
<span class="lineNum">    3029 </span><span class="lineCov">          4 :                                                                         ssdmountingblockscrewmatrix[i]);</span>
<span class="lineNum">    3030 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3031 </span>            :   // Deallocating memory
<span class="lineNum">    3032 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3033 </span><span class="lineCov">          2 :   delete mountingblockrot;</span>
<span class="lineNum">    3034 </span><span class="lineCov">         18 :   for(Int_t i=0; i&lt;4; i++) delete ssdmountingblockscrewrot[i];</span>
<span class="lineNum">    3035 </span><span class="lineCov">          2 :   delete ssdmountingblockglobalrot; </span>
<span class="lineNum">    3036 </span><span class="lineCov">          2 :   delete ssdmountingblockglobaltrans; </span>
<span class="lineNum">    3037 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3038 </span><span class="lineCov">          1 :   return ssdmountingblockmother;</span>
<a name="3039"><span class="lineNum">    3039 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">    3040 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    3041 </span>            :  TGeoVolume* AliITSv11GeometrySSD::GetMountingBlockClip() const {
<span class="lineNum">    3042 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3043 </span>            :   // Method generating the Mounting Block Clip 
<span class="lineNum">    3044 </span>            :   /////////////////////////////////////////////////////////////  
<span class="lineNum">    3045 </span>            :   const Int_t kmothervertexnumber = 10;
<span class="lineNum">    3046 </span><span class="lineCov">          2 :   Double_t xmothervertex[kmothervertexnumber];</span>
<span class="lineNum">    3047 </span><span class="lineCov">          1 :   Double_t ymothervertex[kmothervertexnumber];</span>
<span class="lineNum">    3048 </span><span class="lineCov">          2 :   xmothervertex[0] = -0.25*(fgkSSDMountingBlockLength[0]-fgkSSDMountingBlockLength[1])</span>
<span class="lineNum">    3049 </span><span class="lineCov">          1 :                                    - 0.5*(fgkSSDSensorWidth-fgkSSDMountingBlockLength[0]); </span>
<span class="lineNum">    3050 </span><span class="lineCov">          1 :   xmothervertex[1] = xmothervertex[0];</span>
<span class="lineNum">    3051 </span><span class="lineCov">          2 :   xmothervertex[2] = xmothervertex[0]+0.5*(fgkMountingBlockClibScrewPosition</span>
<span class="lineNum">    3052 </span><span class="lineCov">          1 :                                    - fgkMountingBlockClibScrewRadius);</span>
<span class="lineNum">    3053 </span><span class="lineCov">          1 :   xmothervertex[3] = xmothervertex[2]; </span>
<span class="lineNum">    3054 </span><span class="lineCov">          1 :   xmothervertex[4] = xmothervertex[3]+2.*fgkMountingBlockClibScrewRadius; </span>
<span class="lineNum">    3055 </span><span class="lineCov">          1 :   xmothervertex[5] = xmothervertex[4]; </span>
<span class="lineNum">    3056 </span><span class="lineCov">          1 :   xmothervertex[6] = xmothervertex[0]+fgkMountingBlockClipLength; </span>
<span class="lineNum">    3057 </span><span class="lineCov">          1 :   xmothervertex[7] = xmothervertex[6]; </span>
<span class="lineNum">    3058 </span><span class="lineCov">          1 :   xmothervertex[8] = -0.25*(fgkSSDMountingBlockLength[0]-fgkSSDMountingBlockLength[1]); </span>
<span class="lineNum">    3059 </span><span class="lineCov">          1 :   xmothervertex[9] = xmothervertex[8]; </span>
<span class="lineNum">    3060 </span><span class="lineCov">          2 :   ymothervertex[0] = -0.5*fgkCoolingTubeSupportHeight-fgkSSDModuleCoolingBlockToSensor</span>
<span class="lineNum">    3061 </span><span class="lineCov">          1 :                                + fgkSSDMountingBlockHeight[1]-0.5*fgkSSDMountingBlockHeight[0];</span>
<span class="lineNum">    3062 </span><span class="lineCov">          1 :   ymothervertex[1] = 0.5*fgkSSDMountingBlockHeight[0]+fgkMountingBlockClipThickness;</span>
<span class="lineNum">    3063 </span><span class="lineCov">          1 :   ymothervertex[2] = ymothervertex[1];</span>
<span class="lineNum">    3064 </span><span class="lineCov">          2 :   ymothervertex[3] = ymothervertex[2]+(fgkSSDMountingBlockHeight[1]</span>
<span class="lineNum">    3065 </span><span class="lineCov">          1 :                                    - fgkSSDMountingBlockHeight[0]-fgkMountingBlockClipThickness</span>
<span class="lineNum">    3066 </span><span class="lineCov">          1 :                                    - 0.5*fgkCoolingTubeSupportHeight-fgkCoolingTubeSupportRmax);</span>
<span class="lineNum">    3067 </span><span class="lineCov">          1 :   ymothervertex[4] = ymothervertex[3];</span>
<span class="lineNum">    3068 </span><span class="lineCov">          1 :   ymothervertex[5] = ymothervertex[2];</span>
<span class="lineNum">    3069 </span><span class="lineCov">          1 :   ymothervertex[6] = ymothervertex[5];</span>
<span class="lineNum">    3070 </span><span class="lineCov">          1 :   ymothervertex[7] = ymothervertex[6]-fgkMountingBlockClipThickness;</span>
<span class="lineNum">    3071 </span><span class="lineCov">          1 :   ymothervertex[8] = ymothervertex[7];</span>
<span class="lineNum">    3072 </span><span class="lineCov">          1 :   ymothervertex[9] = ymothervertex[0];</span>
<span class="lineNum">    3073 </span>            : 
<span class="lineNum">    3074 </span>            :   ///////////////////////////////////////////////////////////////////////
<span class="lineNum">    3075 </span>            :   // TGeoXTru Volume definition for Mounting Block Clip Part
<span class="lineNum">    3076 </span>            :   ///////////////////////////////////////////////////////////////////////
<span class="lineNum">    3077 </span><span class="lineCov">          1 :   TGeoXtru* ssdmountingblockclipshape = new TGeoXtru(2);</span>
<span class="lineNum">    3078 </span><span class="lineCov">          1 :   ssdmountingblockclipshape-&gt;DefinePolygon(kmothervertexnumber,xmothervertex,ymothervertex);</span>
<span class="lineNum">    3079 </span><span class="lineCov">          1 :   ssdmountingblockclipshape-&gt;DefineSection(0,0.5*fgkSSDMountingBlockWidth-fgkMountingBlockSupportWidth[0]);</span>
<span class="lineNum">    3080 </span><span class="lineCov">          1 :   ssdmountingblockclipshape-&gt;DefineSection(1,0.5*fgkSSDMountingBlockWidth);</span>
<span class="lineNum">    3081 </span><span class="lineCov">          2 :   TGeoVolume* ssdmountingblockclip = new TGeoVolume(&quot;SSDMountingBlockClip&quot;,</span>
<span class="lineNum">    3082 </span><span class="lineCov">          1 :                                                                           ssdmountingblockclipshape,fSSDAir);</span>
<span class="lineNum">    3083 </span><span class="lineCov">          1 :   ssdmountingblockclip-&gt;SetLineColor(4);</span>
<span class="lineNum">    3084 </span>            :   ///////////////////////////////////////////////////////////////////////
<span class="lineNum">    3085 </span>            :   // TGeoXTru Volume definition for Clip 
<span class="lineNum">    3086 </span>            :   ///////////////////////////////////////////////////////////////////////
<span class="lineNum">    3087 </span>            :   const Int_t kclipvertexnumber = 6;
<span class="lineNum">    3088 </span><span class="lineCov">          1 :   Double_t xclipvertex[kclipvertexnumber];</span>
<span class="lineNum">    3089 </span><span class="lineCov">          1 :   Double_t yclipvertex[kclipvertexnumber];</span>
<span class="lineNum">    3090 </span><span class="lineCov">          1 :   xclipvertex[0] = xmothervertex[0];</span>
<span class="lineNum">    3091 </span><span class="lineCov">          1 :   xclipvertex[1] = xclipvertex[0];</span>
<span class="lineNum">    3092 </span><span class="lineCov">          1 :   xclipvertex[2] = xmothervertex[6];</span>
<span class="lineNum">    3093 </span><span class="lineCov">          1 :   xclipvertex[3] = xclipvertex[2];</span>
<span class="lineNum">    3094 </span><span class="lineCov">          1 :   xclipvertex[4] = xclipvertex[0]+fgkMountingBlockClipThickness;</span>
<span class="lineNum">    3095 </span><span class="lineCov">          1 :   xclipvertex[5] = xclipvertex[4];</span>
<span class="lineNum">    3096 </span><span class="lineCov">          1 :   yclipvertex[0] = ymothervertex[0];</span>
<span class="lineNum">    3097 </span><span class="lineCov">          1 :   yclipvertex[1] = ymothervertex[1];</span>
<span class="lineNum">    3098 </span><span class="lineCov">          1 :   yclipvertex[2] = yclipvertex[1];</span>
<span class="lineNum">    3099 </span><span class="lineCov">          1 :   yclipvertex[3] = yclipvertex[1]-fgkMountingBlockClipThickness;</span>
<span class="lineNum">    3100 </span><span class="lineCov">          1 :   yclipvertex[4] = yclipvertex[3];</span>
<span class="lineNum">    3101 </span><span class="lineCov">          1 :   yclipvertex[5] = yclipvertex[0];</span>
<span class="lineNum">    3102 </span><span class="lineCov">          1 :   TGeoXtru* clipshape = new TGeoXtru(2);</span>
<span class="lineNum">    3103 </span><span class="lineCov">          1 :   clipshape-&gt;DefinePolygon(kclipvertexnumber,xclipvertex,yclipvertex);</span>
<span class="lineNum">    3104 </span><span class="lineCov">          1 :   clipshape-&gt;DefineSection(0,0.5*fgkSSDMountingBlockWidth-fgkMountingBlockClibWidth);</span>
<span class="lineNum">    3105 </span><span class="lineCov">          2 :   clipshape-&gt;DefineSection(1,0.5*fgkSSDMountingBlockWidth-fgkMountingBlockSupportWidth[0]</span>
<span class="lineNum">    3106 </span><span class="lineCov">          1 :                                                          +   fgkMountingBlockClibWidth);</span>
<span class="lineNum">    3107 </span><span class="lineCov">          1 :   TGeoVolume* clip = new TGeoVolume(&quot;SSDClip&quot;,clipshape,fSSDMountingBlockMedium);</span>
<span class="lineNum">    3108 </span><span class="lineCov">          1 :   clip-&gt;SetLineColor(18);</span>
<span class="lineNum">    3109 </span>            :   ///////////////////////////////////////////////////////////////////////
<span class="lineNum">    3110 </span>            :   // Ladder Support Piece  
<span class="lineNum">    3111 </span>            :   ///////////////////////////////////////////////////////////////////////
<span class="lineNum">    3112 </span>            :   const Int_t ksupportvertexnumber = 4;
<span class="lineNum">    3113 </span><span class="lineCov">          1 :   Double_t xsupportvertex[ksupportvertexnumber];</span>
<span class="lineNum">    3114 </span><span class="lineCov">          1 :   Double_t ysupportvertex[ksupportvertexnumber];</span>
<span class="lineNum">    3115 </span><span class="lineCov">          1 :   xsupportvertex[0] = xclipvertex[5];</span>
<span class="lineNum">    3116 </span><span class="lineCov">          1 :   xsupportvertex[1] = xsupportvertex[0];</span>
<span class="lineNum">    3117 </span><span class="lineCov">          1 :   xsupportvertex[2] = xmothervertex[9];</span>
<span class="lineNum">    3118 </span><span class="lineCov">          1 :   xsupportvertex[3] = xsupportvertex[2];</span>
<span class="lineNum">    3119 </span><span class="lineCov">          1 :   ysupportvertex[0] = yclipvertex[0];</span>
<span class="lineNum">    3120 </span><span class="lineCov">          1 :   ysupportvertex[1] = yclipvertex[3];</span>
<span class="lineNum">    3121 </span><span class="lineCov">          1 :   ysupportvertex[2] = ysupportvertex[1];</span>
<span class="lineNum">    3122 </span><span class="lineCov">          1 :   ysupportvertex[3] = ysupportvertex[0];</span>
<span class="lineNum">    3123 </span><span class="lineCov">          1 :   TGeoXtru* supportshape = new TGeoXtru(2);</span>
<span class="lineNum">    3124 </span><span class="lineCov">          1 :   supportshape-&gt;DefinePolygon(ksupportvertexnumber,xsupportvertex,ysupportvertex);</span>
<span class="lineNum">    3125 </span><span class="lineCov">          1 :   supportshape-&gt;DefineSection(0,0.5*fgkSSDMountingBlockWidth-fgkMountingBlockSupportWidth[0]);</span>
<span class="lineNum">    3126 </span><span class="lineCov">          1 :   supportshape-&gt;DefineSection(1,0.5*fgkSSDMountingBlockWidth);</span>
<span class="lineNum">    3127 </span><span class="lineCov">          1 :   TGeoVolume* support = new TGeoVolume(&quot;RingSupport&quot;,supportshape,fSSDMountingBlockMedium);</span>
<span class="lineNum">    3128 </span><span class="lineCov">          1 :   support-&gt;SetLineColor(9);</span>
<span class="lineNum">    3129 </span>            :   ///////////////////////////////////////////////////////////////////////
<span class="lineNum">    3130 </span>            :   // TGeoXTru Volume definition for Screw   
<span class="lineNum">    3131 </span>            :   ///////////////////////////////////////////////////////////////////////
<span class="lineNum">    3132 </span><span class="lineCov">          2 :   Double_t radius[2] = {fgkMountingBlockClibScrewRadius,</span>
<span class="lineNum">    3133 </span><span class="lineCov">          1 :                                                 0.5*fgkMountingBlockClibScrewRadius};</span>
<span class="lineNum">    3134 </span><span class="lineCov">          1 :   Int_t edgesnumber[2] = {50,6};</span>
<span class="lineNum">    3135 </span><span class="lineCov">          2 :   Double_t section[2] = {-0.5*(ymothervertex[3]-ymothervertex[2]),</span>
<span class="lineNum">    3136 </span><span class="lineCov">          1 :                                                  +0.5*(ymothervertex[3]-ymothervertex[2])};</span>
<span class="lineNum">    3137 </span><span class="lineCov">          1 :   TGeoShape* clipscrewshape = GetScrewShape(radius,edgesnumber,section);</span>
<span class="lineNum">    3138 </span><span class="lineCov">          1 :   TGeoVolume* clipscrew = new TGeoVolume(&quot;ClipScrewShape&quot;,clipscrewshape,fSSDSupportRingAl);</span>
<span class="lineNum">    3139 </span><span class="lineCov">          1 :   clipscrew-&gt;SetLineColor(12);</span>
<span class="lineNum">    3140 </span><span class="lineCov">          1 :   TGeoRotation* screwrot = new TGeoRotation();</span>
<span class="lineNum">    3141 </span><span class="lineCov">          1 :   screwrot-&gt;SetAngles(0.,90.,0.);</span>
<span class="lineNum">    3142 </span><span class="lineCov">          1 :   TGeoTranslation* screwtrans = new TGeoTranslation();</span>
<span class="lineNum">    3143 </span><span class="lineCov">          2 :   screwtrans-&gt;SetTranslation(xmothervertex[3]+fgkMountingBlockClibScrewRadius,</span>
<span class="lineNum">    3144 </span><span class="lineCov">          1 :                                                          0.5*(ymothervertex[3]+ymothervertex[2]),</span>
<span class="lineNum">    3145 </span><span class="lineCov">          2 :                                                          0.5*fgkSSDMountingBlockWidth+</span>
<span class="lineNum">    3146 </span><span class="lineCov">          1 :                                                         -0.5*fgkMountingBlockSupportWidth[0]);</span>
<span class="lineNum">    3147 </span><span class="lineCov">          1 :   TGeoCombiTrans* screwcombitrans = new TGeoCombiTrans(*screwtrans,*screwrot);</span>
<span class="lineNum">    3148 </span>            :   ///////////////////////////////////////////////////////////////////////
<span class="lineNum">    3149 </span>            :   // Placing the Volumes
<span class="lineNum">    3150 </span>            :   ///////////////////////////////////////////////////////////////////////
<span class="lineNum">    3151 </span><span class="lineCov">          1 :   ssdmountingblockclip-&gt;AddNode(clip,1);</span>
<span class="lineNum">    3152 </span><span class="lineCov">          1 :   ssdmountingblockclip-&gt;AddNode(support,1);</span>
<span class="lineNum">    3153 </span><span class="lineCov">          1 :   ssdmountingblockclip-&gt;AddNode(clipscrew,1,screwcombitrans);</span>
<span class="lineNum">    3154 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3155 </span>            :   // Deallocating memory
<span class="lineNum">    3156 </span>            :   /////////////////////////////////////////////////////////////  
<span class="lineNum">    3157 </span><span class="lineCov">          2 :   delete screwtrans;</span>
<span class="lineNum">    3158 </span><span class="lineCov">          2 :   delete screwrot;</span>
<span class="lineNum">    3159 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3160 </span><span class="lineCov">          1 :   return ssdmountingblockclip;</span>
<a name="3161"><span class="lineNum">    3161 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">    3162 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    3163 </span>            : void AliITSv11GeometrySSD::CreateCoolingTubes() {
<span class="lineNum">    3164 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3165 </span>            :   // Method generating the Cooling Tube 
<span class="lineNum">    3166 </span>            :   // sets fcoolingtube and returns list for endladdercoolingtube
<span class="lineNum">    3167 </span>            :   /////////////////////////////////////////////////////////////  
<span class="lineNum">    3168 </span>            :   TGeoTube *coolingtubeshape[2];
<span class="lineNum">    3169 </span>            :   // Ladder Cooling Tubes
<span class="lineNum">    3170 </span>            : 
<span class="lineNum">    3171 </span>            :   // MvL: Simplified cooling tubes
<span class="lineNum">    3172 </span><span class="lineCov">          2 :   coolingtubeshape[0] = new TGeoTube(fgkCoolingTubeRmin,fgkCoolingTubeRmax,0.5*fgkCoolingTubeLength);</span>
<span class="lineNum">    3173 </span><span class="lineCov">          2 :   coolingtubeshape[1] = new TGeoTube(0.0,fgkCoolingTubeRmin,coolingtubeshape[0]-&gt;GetDz());</span>
<span class="lineNum">    3174 </span>            : 
<span class="lineNum">    3175 </span>            :   // End Ladder Cooling Tubes   
<span class="lineNum">    3176 </span><span class="lineCov">          1 :   TGeoTube** endladdercoolingtubeshape[fgkendladdercoolingtubenumber];</span>
<span class="lineNum">    3177 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkendladdercoolingtubenumber; i++) </span>
<span class="lineNum">    3178 </span><span class="lineCov">          2 :     endladdercoolingtubeshape[i] = new  TGeoTube*[2];</span>
<span class="lineNum">    3179 </span>            : 
<span class="lineNum">    3180 </span><span class="lineCov">          1 :   Double_t sensZshift = 0.5*fgkCarbonFiberJunctionWidth - fgkCarbonFiberLowerSupportWidth - fgkLowerSupportToSensorZ;</span>
<span class="lineNum">    3181 </span><span class="lineCov">          3 :   endladdercoolingtubeshape[0][0] = new TGeoTube(fgkCoolingTubeRmin,fgkCoolingTubeRmax,</span>
<span class="lineNum">    3182 </span><span class="lineCov">          1 :                                                  0.5*(fgkEndLadderCarbonFiberLowerJunctionLength[0] - sensZshift));</span>
<span class="lineNum">    3183 </span><span class="lineCov">          3 :   endladdercoolingtubeshape[0][1] = new TGeoTube(0.0,fgkCoolingTubeRmin,</span>
<span class="lineNum">    3184 </span><span class="lineCov">          1 :                                                  endladdercoolingtubeshape[0][0]-&gt;GetDz());</span>
<span class="lineNum">    3185 </span><span class="lineCov">          3 :   endladdercoolingtubeshape[1][0] = new TGeoTube(fgkCoolingTubeRmin,fgkCoolingTubeRmax,</span>
<span class="lineNum">    3186 </span><span class="lineCov">          1 :                                                  0.5*(fgkEndLadderCarbonFiberLowerJunctionLength[1] + sensZshift));</span>
<span class="lineNum">    3187 </span><span class="lineCov">          3 :   endladdercoolingtubeshape[1][1] = new TGeoTube(0.0,fgkCoolingTubeRmin,</span>
<span class="lineNum">    3188 </span><span class="lineCov">          2 :                                                  endladdercoolingtubeshape[1][0]-&gt;GetDz()-0.5*fgkSSDTolerance);</span>
<span class="lineNum">    3189 </span>            :   // Ladder Cooling Tubes
<span class="lineNum">    3190 </span>            :   TGeoVolume* coolingtube[2];
<span class="lineNum">    3191 </span><span class="lineCov">          1 :   coolingtube[0] = new TGeoVolume(&quot;OuterCoolingTube1&quot;,coolingtubeshape[0], fSSDCoolingTubePhynox);</span>
<span class="lineNum">    3192 </span><span class="lineCov">          1 :   coolingtube[1] = new TGeoVolume(&quot;InnerCoolingTube1&quot;,coolingtubeshape[1], fSSDCoolingTubeWater);</span>
<span class="lineNum">    3193 </span><span class="lineCov">          1 :   coolingtube[0]-&gt;SetLineColor(fColorPhynox);</span>
<span class="lineNum">    3194 </span><span class="lineCov">          1 :   coolingtube[1]-&gt;SetLineColor(fColorWater);</span>
<span class="lineNum">    3195 </span>            : 
<span class="lineNum">    3196 </span>            :   // End Ladder Cooling Tubes   
<span class="lineNum">    3197 </span><span class="lineCov">          1 :   TGeoVolume** endladdercoolingtube[fgkendladdercoolingtubenumber];</span>
<span class="lineNum">    3198 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkendladdercoolingtubenumber; i++) </span>
<span class="lineNum">    3199 </span><span class="lineCov">          2 :     endladdercoolingtube[i] = new TGeoVolume*[2];</span>
<span class="lineNum">    3200 </span><span class="lineCov">          3 :   endladdercoolingtube[0][0] = new TGeoVolume(&quot;OuterEndLadderCoolingTube1&quot;,</span>
<span class="lineNum">    3201 </span><span class="lineCov">          1 :                                               endladdercoolingtubeshape[0][0],</span>
<span class="lineNum">    3202 </span><span class="lineCov">          1 :                                               fSSDCoolingTubePhynox);</span>
<span class="lineNum">    3203 </span><span class="lineCov">          3 :   endladdercoolingtube[0][1] = new TGeoVolume(&quot;InnerEndlLadderCoolingTube1&quot;,</span>
<span class="lineNum">    3204 </span><span class="lineCov">          1 :                                               endladdercoolingtubeshape[0][1],</span>
<span class="lineNum">    3205 </span><span class="lineCov">          1 :                                               fSSDCoolingTubeWater);</span>
<span class="lineNum">    3206 </span><span class="lineCov">          3 :   endladdercoolingtube[1][0] = new TGeoVolume(&quot;OuterEndLadderCoolingTube2&quot;,</span>
<span class="lineNum">    3207 </span><span class="lineCov">          1 :                                               endladdercoolingtubeshape[1][0],</span>
<span class="lineNum">    3208 </span><span class="lineCov">          1 :                                               fSSDCoolingTubePhynox);</span>
<span class="lineNum">    3209 </span><span class="lineCov">          3 :   endladdercoolingtube[1][1] = new TGeoVolume(&quot;InnerEndlLadderCoolingTube2&quot;,</span>
<span class="lineNum">    3210 </span><span class="lineCov">          1 :                                               endladdercoolingtubeshape[1][1],</span>
<span class="lineNum">    3211 </span><span class="lineCov">          1 :                                               fSSDCoolingTubeWater);</span>
<span class="lineNum">    3212 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkendladdercoolingtubenumber; i++){</span>
<span class="lineNum">    3213 </span><span class="lineCov">          2 :     endladdercoolingtube[i][0]-&gt;SetLineColor(fColorPhynox);</span>
<span class="lineNum">    3214 </span><span class="lineCov">          2 :     endladdercoolingtube[i][1]-&gt;SetLineColor(fColorWater);</span>
<span class="lineNum">    3215 </span>            :   }
<span class="lineNum">    3216 </span>            :   
<span class="lineNum">    3217 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3218 </span>            :   // Virtual Volume containing Cooling Tubes
<span class="lineNum">    3219 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3220 </span>            :   // Ladder Cooling Tubes
<span class="lineNum">    3221 </span><span class="lineCov">          2 :   TGeoTube* virtualcoolingtubeshape = new TGeoTube(coolingtubeshape[1]-&gt;GetRmin(),</span>
<span class="lineNum">    3222 </span><span class="lineCov">          1 :                                                    coolingtubeshape[0]-&gt;GetRmax(),</span>
<span class="lineNum">    3223 </span><span class="lineCov">          1 :                                                    coolingtubeshape[0]-&gt;GetDz());</span>
<span class="lineNum">    3224 </span><span class="lineCov">          2 :   fcoolingtube = new TGeoVolume(&quot;CoolingTube1&quot;,virtualcoolingtubeshape, fSSDAir);</span>
<span class="lineNum">    3225 </span><span class="lineCov">          1 :   fcoolingtube-&gt;AddNode(coolingtube[0],1);</span>
<span class="lineNum">    3226 </span><span class="lineCov">          1 :   fcoolingtube-&gt;AddNode(coolingtube[1],1);</span>
<span class="lineNum">    3227 </span>            : 
<span class="lineNum">    3228 </span>            :   // End Ladder Cooling Tubes
<span class="lineNum">    3229 </span><span class="lineCov">          1 :   TGeoTube* endladdervirtualcoolingtubeshape[fgkendladdercoolingtubenumber];</span>
<span class="lineNum">    3230 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkendladdercoolingtubenumber; i++)</span>
<span class="lineNum">    3231 </span><span class="lineCov">          6 :     endladdervirtualcoolingtubeshape[i] = new TGeoTube(endladdercoolingtubeshape[i][1]-&gt;GetRmin(),</span>
<span class="lineNum">    3232 </span><span class="lineCov">          2 :                                                        endladdercoolingtubeshape[i][0]-&gt;GetRmax(),</span>
<span class="lineNum">    3233 </span><span class="lineCov">          2 :                                                        endladdercoolingtubeshape[i][0]-&gt;GetDz());</span>
<span class="lineNum">    3234 </span><span class="lineCov">          3 :   fendladdercoolingtube[0] = new TGeoVolume(&quot;EndLadderCoolingTube1&quot;,</span>
<span class="lineNum">    3235 </span><span class="lineCov">          1 :                                             endladdervirtualcoolingtubeshape[0],</span>
<span class="lineNum">    3236 </span><span class="lineCov">          1 :                                             fSSDAir);</span>
<span class="lineNum">    3237 </span><span class="lineCov">          3 :   fendladdercoolingtube[1] = new TGeoVolume(&quot;EndLadderCoolingTube2&quot;,</span>
<span class="lineNum">    3238 </span><span class="lineCov">          1 :                                             endladdervirtualcoolingtubeshape[1],</span>
<span class="lineNum">    3239 </span><span class="lineCov">          1 :                                             fSSDAir);</span>
<span class="lineNum">    3240 </span><span class="lineCov">          1 :   fendladdercoolingtube[0]-&gt;AddNode(endladdercoolingtube[0][0],1);</span>
<span class="lineNum">    3241 </span><span class="lineCov">          1 :   fendladdercoolingtube[0]-&gt;AddNode(endladdercoolingtube[0][1],1);</span>
<span class="lineNum">    3242 </span><span class="lineCov">          1 :   fendladdercoolingtube[1]-&gt;AddNode(endladdercoolingtube[1][0],1);</span>
<span class="lineNum">    3243 </span><span class="lineCov">          1 :   fendladdercoolingtube[1]-&gt;AddNode(endladdercoolingtube[1][1],1);  </span>
<a name="3244"><span class="lineNum">    3244 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">    3245 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    3246 </span>            : TGeoVolume* AliITSv11GeometrySSD::GetSSDCoolingBlock(Int_t nedges){
<span class="lineNum">    3247 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3248 </span>            :   // Method generating SSD Cooling Block    
<span class="lineNum">    3249 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3250 </span>            :   const Int_t kvertexnumber = 8;
<span class="lineNum">    3251 </span>            :   ///////////////////////////////////////
<span class="lineNum">    3252 </span>            :   // Vertex Positioning for TGeoXTru
<span class="lineNum">    3253 </span>            :   ///////////////////////////////////////
<span class="lineNum">    3254 </span><span class="lineCov">          2 :   TVector3** vertexposition = new TVector3*[2*kvertexnumber+nedges+1];</span>
<span class="lineNum">    3255 </span><span class="lineCov">          2 :   vertexposition[0] = new TVector3(0.0,0.0, 0.);</span>
<span class="lineNum">    3256 </span><span class="lineCov">          2 :   vertexposition[1] = new TVector3(0.0,fgkSSDCoolingBlockHeight[1],0);</span>
<span class="lineNum">    3257 </span><span class="lineCov">          3 :   vertexposition[2] = new TVector3(fgkSSDCoolingBlockHoleLength[1],</span>
<span class="lineNum">    3258 </span><span class="lineCov">          1 :                                    vertexposition[1]-&gt;Y(),0);</span>
<span class="lineNum">    3259 </span><span class="lineCov">          3 :   vertexposition[3] = new TVector3(vertexposition[2]-&gt;X(),</span>
<span class="lineNum">    3260 </span><span class="lineCov">          1 :                                    vertexposition[2]-&gt;Y()+fgkSSDCoolingBlockHeight[2],0);</span>
<span class="lineNum">    3261 </span><span class="lineCov">          2 :   vertexposition[4] = new TVector3(vertexposition[1]-&gt;X(),vertexposition[3]-&gt;Y(),0);</span>
<span class="lineNum">    3262 </span><span class="lineCov">          3 :   vertexposition[5] = new TVector3(vertexposition[4]-&gt;X(),</span>
<span class="lineNum">    3263 </span><span class="lineCov">          1 :                                    + vertexposition[3]-&gt;Y()+fgkSSDCoolingBlockHoleRadius[1],0);</span>
<span class="lineNum">    3264 </span><span class="lineCov">          4 :   vertexposition[6] = new TVector3(Xfrom2Points(vertexposition[5]-&gt;X(),</span>
<span class="lineNum">    3265 </span><span class="lineCov">          2 :                                           vertexposition[5]-&gt;Y(),0.5*(fgkSSDCoolingBlockLength</span>
<span class="lineNum">    3266 </span><span class="lineCov">          1 :                                         - fgkSSDCoolingBlockHoleLength[0]</span>
<span class="lineNum">    3267 </span><span class="lineCov">          1 :                                         - 4.*fgkSSDCoolingBlockHoleRadius[1]),</span>
<span class="lineNum">    3268 </span><span class="lineCov">          1 :                                           fgkSSDCoolingBlockHeight[0]</span>
<span class="lineNum">    3269 </span><span class="lineCov">          1 :                                         - fgkSSDCoolingBlockHoleRadius[1],</span>
<span class="lineNum">    3270 </span><span class="lineCov">          1 :                                                 fgkSSDCoolingBlockHeight[0]),fgkSSDCoolingBlockHeight[0], 0);</span>
<span class="lineNum">    3271 </span><span class="lineCov">          4 :   vertexposition[7] = new TVector3(0.5*(fgkSSDCoolingBlockLength</span>
<span class="lineNum">    3272 </span><span class="lineCov">          1 :                                         - fgkSSDCoolingBlockHoleLength[0]),</span>
<span class="lineNum">    3273 </span><span class="lineCov">          1 :                                    vertexposition[6]-&gt;Y(), 0);</span>
<span class="lineNum">    3274 </span><span class="lineCov">          2 :   Double_t alpha = TMath::ACos(0.5*fgkSSDCoolingBlockHoleLength[0]</span>
<span class="lineNum">    3275 </span><span class="lineCov">          2 :                            / fgkSSDCoolingBlockHoleRadius[0])*TMath::RadToDeg();</span>
<span class="lineNum">    3276 </span><span class="lineCov">          1 :   Double_t phi = 180.-alpha;</span>
<span class="lineNum">    3277 </span><span class="lineCov">          1 :   Double_t psi = 180.+2.*alpha;</span>
<span class="lineNum">    3278 </span><span class="lineCov">          1 :   Double_t deltapsi = psi/nedges;</span>
<span class="lineNum">    3279 </span><span class="lineCov">          1 :   Double_t radius = fgkSSDCoolingBlockHoleRadius[0]/CosD(0.5*deltapsi);</span>
<span class="lineNum">    3280 </span><span class="lineCov">          2 :   TVector3* transvector = new TVector3(0.5*fgkSSDCoolingBlockLength,</span>
<span class="lineNum">    3281 </span><span class="lineCov">          1 :                                        fgkSSDCoolingBlockHoleCenter, 0);</span>
<span class="lineNum">    3282 </span><span class="lineCov">         64 :   for(Int_t i=0; i&lt;nedges+1; i++){</span>
<span class="lineNum">    3283 </span><span class="lineCov">        124 :         vertexposition[kvertexnumber+i] = new TVector3(radius*CosD(phi+i*deltapsi),</span>
<span class="lineNum">    3284 </span><span class="lineCov">         62 :                                                    radius*SinD(phi+i*deltapsi),</span>
<span class="lineNum">    3285 </span>            :                                                    0);
<span class="lineNum">    3286 </span><span class="lineCov">         31 :    *vertexposition[kvertexnumber+i] += (*transvector);</span>
<span class="lineNum">    3287 </span>            :   }
<span class="lineNum">    3288 </span><span class="lineCov">          1 :   Double_t param[4] = {1.0,0.0,0.0,-0.5*fgkSSDCoolingBlockLength};  </span>
<span class="lineNum">    3289 </span><span class="lineCov">         18 :   for(Int_t i=0; i&lt;kvertexnumber; i++)</span>
<span class="lineNum">    3290 </span><span class="lineCov">          8 :     vertexposition[kvertexnumber+nedges+1+i] = </span>
<span class="lineNum">    3291 </span><span class="lineCov">          8 :                                                 GetReflection(vertexposition[kvertexnumber-1-i],param);</span>
<span class="lineNum">    3292 </span>            :   ///////////////////////////////////////////////////////////////////////
<span class="lineNum">    3293 </span>            :   // TGeoXTru Volume definition for Cooling Tube Support Arc Part
<span class="lineNum">    3294 </span>            :   ///////////////////////////////////////////////////////////////////////
<span class="lineNum">    3295 </span><span class="lineCov">          1 :   TGeoXtru* ssdcoolingblockshape = new TGeoXtru(2);     </span>
<span class="lineNum">    3296 </span><span class="lineCov">          1 :   Double_t* xvertexpoints = new Double_t[2*kvertexnumber+nedges+1]; </span>
<span class="lineNum">    3297 </span><span class="lineCov">          1 :   Double_t* yvertexpoints = new Double_t[2*kvertexnumber+nedges+1];</span>
<span class="lineNum">    3298 </span><span class="lineCov">         96 :   for(Int_t i=0; i&lt;2*kvertexnumber+nedges+1; i++){</span>
<span class="lineNum">    3299 </span><span class="lineCov">         47 :         xvertexpoints[i] = vertexposition[i]-&gt;X();</span>
<span class="lineNum">    3300 </span><span class="lineCov">         47 :         yvertexpoints[i] = vertexposition[i]-&gt;Y();</span>
<span class="lineNum">    3301 </span>            :   } 
<span class="lineNum">    3302 </span><span class="lineCov">          1 :   ssdcoolingblockshape-&gt;DefinePolygon(2*kvertexnumber+nedges+1,xvertexpoints,</span>
<span class="lineNum">    3303 </span>            :                                                                                         yvertexpoints);
<span class="lineNum">    3304 </span><span class="lineCov">          1 :   ssdcoolingblockshape-&gt;DefineSection(0,-0.5*fgkSSDCoolingBlockWidth);</span>
<span class="lineNum">    3305 </span><span class="lineCov">          1 :   ssdcoolingblockshape-&gt;DefineSection(1,0.5*fgkSSDCoolingBlockWidth);</span>
<span class="lineNum">    3306 </span><span class="lineCov">          2 :   TGeoVolume* ssdcoolingblock = new TGeoVolume(&quot;SSDCoolingBlock&quot;,</span>
<span class="lineNum">    3307 </span><span class="lineCov">          1 :                                                                           ssdcoolingblockshape,</span>
<span class="lineNum">    3308 </span><span class="lineCov">          1 :                                                                                   fSSDAlCoolBlockMedium);</span>
<span class="lineNum">    3309 </span><span class="lineCov">          1 :   ssdcoolingblock-&gt;SetLineColor(fColorAl);</span>
<span class="lineNum">    3310 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3311 </span>            :   // Deallocating memory
<span class="lineNum">    3312 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3313 </span><span class="lineCov">          2 :   delete [] vertexposition;</span>
<span class="lineNum">    3314 </span><span class="lineCov">          2 :   delete [] xvertexpoints;</span>
<span class="lineNum">    3315 </span><span class="lineCov">          2 :   delete [] yvertexpoints;</span>
<span class="lineNum">    3316 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3317 </span><span class="lineCov">          1 :   return ssdcoolingblock;</span>
<a name="3318"><span class="lineNum">    3318 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">    3319 </span>            : /////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    3320 </span>            : void AliITSv11GeometrySSD::GetSSDChipCables(TGeoVolume *&amp;cableL, TGeoVolume *&amp;cableR, Double_t SSDChipCablesHeight, Int_t nedges){
<span class="lineNum">    3321 </span>            :   ///////////////////////////////////////////////////////
<span class="lineNum">    3322 </span>            :   static const Int_t kssdchipcablesnumber    = 2;  // Number of cables: left and right
<span class="lineNum">    3323 </span>            :   static const Int_t kssdchipcableslaynumber = 2;  // Number of layers: Al and Kapton
<span class="lineNum">    3324 </span><span class="lineCov">          6 :   static const Int_t kvertexnumber                        = 4*(nedges+1)+4;</span>
<span class="lineNum">    3325 </span><span class="lineCov">          2 :   Int_t ssdchipcablescolor[kssdchipcableslaynumber] = {fColorAl,fColorPolyhamide};</span>
<span class="lineNum">    3326 </span>            :   Double_t ssdchipcablesradius[kssdchipcableslaynumber];
<span class="lineNum">    3327 </span><span class="lineCov">          2 :   ssdchipcablesradius[0] = 0.25*(SSDChipCablesHeight</span>
<span class="lineNum">    3328 </span><span class="lineCov">          2 :                                                  -  fgkSSDChipCablesHeight[0]</span>
<span class="lineNum">    3329 </span><span class="lineCov">          2 :                                                  -  fgkSSDChipCablesHeight[1]);</span>
<span class="lineNum">    3330 </span><span class="lineCov">          2 :   ssdchipcablesradius[1] = ssdchipcablesradius[0]-fgkSSDChipCablesHeight[0];</span>
<span class="lineNum">    3331 </span><span class="lineCov">          2 :   Double_t ssdchipcablespiecelength[kssdchipcablesnumber];</span>
<span class="lineNum">    3332 </span><span class="lineCov">          4 :   ssdchipcablespiecelength[0] = 0.5*(fgkSSDChipCablesWidth[0]</span>
<span class="lineNum">    3333 </span><span class="lineCov">          2 :                                                           - 2.*TMath::Pi()*ssdchipcablesradius[0]</span>
<span class="lineNum">    3334 </span><span class="lineCov">          2 :                                                           - ssdchipcablesradius[0]</span>
<span class="lineNum">    3335 </span><span class="lineCov">          2 :                                                           - fgkSSDChipCablesWidth[1]</span>
<span class="lineNum">    3336 </span><span class="lineCov">          2 :                                                           - fgkSSDChipCablesWidth[2]);</span>
<span class="lineNum">    3337 </span><span class="lineCov">          2 :   ssdchipcablespiecelength[1] = ssdchipcablespiecelength[0]</span>
<span class="lineNum">    3338 </span><span class="lineCov">          4 :                                                           - 0.5*(fgkSSDModuleStiffenerPosition[1]                                                         </span>
<span class="lineNum">    3339 </span><span class="lineCov">          2 :                                                           +      fgkSSDChipCablesHeight[1]</span>
<span class="lineNum">    3340 </span><span class="lineCov">          2 :                                                           +      fgkSSDSensorHeight);</span>
<span class="lineNum">    3341 </span>            :   ///////////////////////////////////////////////////////
<span class="lineNum">    3342 </span>            :   // Vertex Positioning for TGeoXTrue Layer 1 and Layer 2
<span class="lineNum">    3343 </span>            :   ///////////////////////////////////////////////////////
<span class="lineNum">    3344 </span><span class="lineCov">          2 :   TVector3** vertexposition[kssdchipcableslaynumber];</span>
<span class="lineNum">    3345 </span><span class="lineCov">         12 :   for(Int_t i=0; i&lt;kssdchipcableslaynumber; i++) vertexposition[i] = </span>
<span class="lineNum">    3346 </span><span class="lineCov">          4 :                                                                                                   new TVector3*[4*(nedges+1)+4];</span>
<span class="lineNum">    3347 </span><span class="lineCov">          2 :   Double_t ratio[4];</span>
<span class="lineNum">    3348 </span><span class="lineCov">          2 :   ratio[0] = ssdchipcablesradius[1]/ssdchipcablesradius[0]; </span>
<span class="lineNum">    3349 </span><span class="lineCov">          4 :   ratio[1] = (ssdchipcablesradius[1]-fgkSSDChipCablesHeight[1])</span>
<span class="lineNum">    3350 </span><span class="lineCov">          2 :                    /  ssdchipcablesradius[0]; </span>
<span class="lineNum">    3351 </span><span class="lineCov">          4 :   ratio[2] = (ssdchipcablesradius[0]+fgkSSDChipCablesHeight[0])</span>
<span class="lineNum">    3352 </span><span class="lineCov">          2 :                    /  ssdchipcablesradius[0];</span>
<span class="lineNum">    3353 </span><span class="lineCov">          4 :   ratio[3] = (ssdchipcablesradius[0]+fgkSSDChipCablesHeight[0]</span>
<span class="lineNum">    3354 </span><span class="lineCov">          2 :                    +  fgkSSDChipCablesHeight[1])</span>
<span class="lineNum">    3355 </span><span class="lineCov">          2 :                    /  ssdchipcablesradius[0];</span>
<span class="lineNum">    3356 </span>            :   Double_t phi = 180.;
<span class="lineNum">    3357 </span><span class="lineCov">          2 :   Double_t deltaphi = 180./nedges;</span>
<span class="lineNum">    3358 </span>            :   Double_t angle = 0.0;
<span class="lineNum">    3359 </span>            : 
<span class="lineNum">    3360 </span><span class="lineCov">          2 :   Double_t xvertexpoints[kssdchipcableslaynumber][kvertexnumber];</span>
<span class="lineNum">    3361 </span><span class="lineCov">          2 :   Double_t yvertexpoints[kssdchipcableslaynumber][kvertexnumber];</span>
<span class="lineNum">    3362 </span>            : 
<span class="lineNum">    3363 </span><span class="lineCov">          2 :   TVector3* vertex = new TVector3();</span>
<span class="lineNum">    3364 </span><span class="lineCov">          2 :   TVector3* transvector[kssdchipcableslaynumber];</span>
<span class="lineNum">    3365 </span><span class="lineCov">          6 :   transvector[0] = new TVector3(fgkSSDChipWidth,</span>
<span class="lineNum">    3366 </span><span class="lineCov">          2 :                                 SSDChipCablesHeight-ssdchipcablesradius[0], 0);</span>
<span class="lineNum">    3367 </span><span class="lineCov">          4 :   transvector[1] = new TVector3();</span>
<span class="lineNum">    3368 </span><span class="lineCov">          2 :   TGeoXtru* ssdchipcableshape[kssdchipcableslaynumber*kssdchipcablesnumber];</span>
<span class="lineNum">    3369 </span><span class="lineCov">          2 :   TGeoVolume* ssdchipcable[kssdchipcableslaynumber*kssdchipcablesnumber];</span>
<span class="lineNum">    3370 </span><span class="lineCov">          2 :   const char* ssdchipcablename[kssdchipcableslaynumber*kssdchipcablesnumber] = </span>
<span class="lineNum">    3371 </span>            :                 {&quot;SSDChipcableAllay1Left&quot;,&quot;SSDChipcableKaptonlay2Left&quot;,
<span class="lineNum">    3372 </span>            :                  &quot;SSDChipcableAllay1Right&quot;,&quot;SSDChipcableKaptonlay2Right&quot;};
<span class="lineNum">    3373 </span><span class="lineCov">         12 :   for(Int_t k=0; k&lt;kssdchipcablesnumber; k++){</span>
<span class="lineNum">    3374 </span><span class="lineCov">          4 :         transvector[1]-&gt;SetX(fgkSSDChipWidth-ssdchipcablespiecelength[k]);</span>
<span class="lineNum">    3375 </span><span class="lineCov">          8 :         transvector[1]-&gt;SetY(ssdchipcablesradius[0]</span>
<span class="lineNum">    3376 </span><span class="lineCov">          4 :                                  +               fgkSSDChipCablesHeight[0]</span>
<span class="lineNum">    3377 </span><span class="lineCov">          4 :                                  +               fgkSSDChipCablesHeight[1]);  </span>
<span class="lineNum">    3378 </span><span class="lineCov">         24 :         for(Int_t i=0; i&lt;kssdchipcableslaynumber; i++){</span>
<span class="lineNum">    3379 </span><span class="lineCov">         24 :                 vertexposition[i][0] = new TVector3(0.,SSDChipCablesHeight</span>
<span class="lineNum">    3380 </span><span class="lineCov">          8 :                                               - fgkSSDChipCablesHeight[0]-i*fgkSSDChipCablesHeight[1], 0);</span>
<span class="lineNum">    3381 </span><span class="lineCov">         24 :                 vertexposition[i][1] = new TVector3(0.,SSDChipCablesHeight</span>
<span class="lineNum">    3382 </span><span class="lineCov">          8 :                                                     - i*fgkSSDChipCablesHeight[0], 0);</span>
<span class="lineNum">    3383 </span><span class="lineCov">          8 :                 vertexposition[i][2*(nedges+1)+2] = </span>
<span class="lineNum">    3384 </span><span class="lineCov">         16 :                                         new TVector3(fgkSSDChipWidth+ssdchipcablesradius[0]</span>
<span class="lineNum">    3385 </span><span class="lineCov">          8 :                                 +                                fgkSSDChipCablesWidth[1]</span>
<span class="lineNum">    3386 </span><span class="lineCov">          8 :                                 +                                fgkSSDChipCablesWidth[2],</span>
<span class="lineNum">    3387 </span><span class="lineCov">          8 :                                                                 ((1.-i)*fgkSSDChipCablesHeight[i]</span>
<span class="lineNum">    3388 </span><span class="lineCov">          8 :                                 + fgkSSDChipCablesHeight[1]), 0);</span>
<span class="lineNum">    3389 </span><span class="lineCov">          8 :         vertexposition[i][2*(nedges+1)+3] = </span>
<span class="lineNum">    3390 </span><span class="lineCov">         16 :                                         new TVector3(vertexposition[i][2*(nedges+1)+2]-&gt;X(),</span>
<span class="lineNum">    3391 </span><span class="lineCov">          8 :                                                                  vertexposition[i][2*(nedges+1)+2]-&gt;Y()</span>
<span class="lineNum">    3392 </span><span class="lineCov">          8 :                        - fgkSSDChipCablesHeight[i], 0);</span>
<span class="lineNum">    3393 </span><span class="lineCov">        112 :             for(Int_t j=0; j&lt;nedges+1; j++){                 </span>
<span class="lineNum">    3394 </span><span class="lineCov">         48 :                     angle = 0.5*phi+TMath::Power(-1,i+1)*j*deltaphi;</span>
<span class="lineNum">    3395 </span><span class="lineCov">         48 :                         vertex-&gt;SetX(ssdchipcablesradius[0]*CosD(angle));</span>
<span class="lineNum">    3396 </span><span class="lineCov">         48 :                         vertex-&gt;SetY(ssdchipcablesradius[0]*SinD(angle));</span>
<span class="lineNum">    3397 </span><span class="lineCov">         48 :                         vertexposition[0][(nedges+1)*i+j+2] = </span>
<span class="lineNum">    3398 </span><span class="lineCov">         48 :                                                 new TVector3(*vertex+*transvector[i]);</span>
<span class="lineNum">    3399 </span><span class="lineCov">         48 :                         vertexposition[1][(nedges+1)*i+j+2] = </span>
<span class="lineNum">    3400 </span><span class="lineCov">         96 :                                                 new TVector3(vertex-&gt;X()*ratio[2*i]+transvector[i]-&gt;X(),</span>
<span class="lineNum">    3401 </span><span class="lineCov">         48 :                                        vertex-&gt;Y()*ratio[2*i]+transvector[i]-&gt;Y(), 0);</span>
<span class="lineNum">    3402 </span><span class="lineCov">         48 :                         vertexposition[0][(4-i)*(nedges+1)+4-j-1] = </span>
<span class="lineNum">    3403 </span><span class="lineCov">         48 :                                                 new TVector3(*vertexposition[1][(nedges+1)*i+j+2]);</span>
<span class="lineNum">    3404 </span><span class="lineCov">         48 :                         vertexposition[1][(4-i)*(nedges+1)+4-j-1] = </span>
<span class="lineNum">    3405 </span><span class="lineCov">         96 :                                                 new TVector3(vertex-&gt;X()*ratio[2*i+1]</span>
<span class="lineNum">    3406 </span><span class="lineCov">         48 :                                                         +                        transvector[i]-&gt;X(),</span>
<span class="lineNum">    3407 </span><span class="lineCov">         48 :                                                                                  vertex-&gt;Y()*ratio[2*i+1]</span>
<span class="lineNum">    3408 </span><span class="lineCov">         48 :                                        + transvector[i]-&gt;Y(), 0);</span>
<span class="lineNum">    3409 </span>            :                 }
<span class="lineNum">    3410 </span>            :         }
<span class="lineNum">    3411 </span><span class="lineCov">         24 :         for(Int_t i=0; i&lt;kssdchipcableslaynumber; i++){</span>
<span class="lineNum">    3412 </span><span class="lineCov">        464 :                 for(Int_t j=0; j&lt;kvertexnumber; j++){        </span>
<span class="lineNum">    3413 </span><span class="lineCov">        224 :                         xvertexpoints[i][j] = vertexposition[i][j]-&gt;X();</span>
<span class="lineNum">    3414 </span><span class="lineCov">        224 :                         yvertexpoints[i][j] = vertexposition[i][j]-&gt;Y();</span>
<span class="lineNum">    3415 </span>            :                 }
<span class="lineNum">    3416 </span><span class="lineCov">         16 :                 ssdchipcableshape[kssdchipcablesnumber*k+i] = new TGeoXtru(2);</span>
<span class="lineNum">    3417 </span><span class="lineCov">         16 :                 ssdchipcableshape[kssdchipcablesnumber*k+i]-&gt;DefinePolygon(kvertexnumber,</span>
<span class="lineNum">    3418 </span><span class="lineCov">          8 :                                                                                 xvertexpoints[i],yvertexpoints[i]);</span>
<span class="lineNum">    3419 </span><span class="lineCov">          8 :                 ssdchipcableshape[kssdchipcablesnumber*k+i]-&gt;DefineSection(0,-0.5*fgkSSDChipCablesLength[1]);</span>
<span class="lineNum">    3420 </span><span class="lineCov">          8 :                 ssdchipcableshape[kssdchipcablesnumber*k+i]-&gt;DefineSection(1,+0.5*fgkSSDChipCablesLength[1]);</span>
<span class="lineNum">    3421 </span><span class="lineCov">          8 :                 ssdchipcable[kssdchipcablesnumber*k+i] = </span>
<span class="lineNum">    3422 </span><span class="lineCov">         16 :                                 new TGeoVolume(ssdchipcablename[kssdchipcablesnumber*k+i],</span>
<span class="lineNum">    3423 </span><span class="lineCov">          8 :                                                            ssdchipcableshape[kssdchipcablesnumber*k+i],</span>
<span class="lineNum">    3424 </span><span class="lineCov">         24 :                                                           (kssdchipcablesnumber*k+i)%2==0?</span>
<span class="lineNum">    3425 </span><span class="lineCov">          8 :                                                            fSSDAlTraceChipCableMedium:fSSDKaptonChipCableMedium);</span>
<span class="lineNum">    3426 </span><span class="lineCov">          8 :                 ssdchipcable[kssdchipcablesnumber*k+i]-&gt;SetLineColor(ssdchipcablescolor[i]);</span>
<span class="lineNum">    3427 </span>            :         }
<span class="lineNum">    3428 </span><span class="lineCov">         24 :         for(Int_t i=0; i&lt;kssdchipcableslaynumber; i++)</span>
<span class="lineNum">    3429 </span><span class="lineCov">        912 :                 for(Int_t j=0; j&lt;kvertexnumber; j++) delete vertexposition[i][j];</span>
<span class="lineNum">    3430 </span>            :   }
<span class="lineNum">    3431 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3432 </span>            :   // Mother Volume definition 
<span class="lineNum">    3433 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3434 </span>            :   static const Int_t kmothervertexnumber = 8;
<span class="lineNum">    3435 </span><span class="lineCov">          2 :   Double_t xmothervertex[kmothervertexnumber];</span>
<span class="lineNum">    3436 </span><span class="lineCov">          2 :   Double_t ymothervertex[kmothervertexnumber];</span>
<span class="lineNum">    3437 </span><span class="lineCov">          2 :   xmothervertex[0] = xvertexpoints[0][1];</span>
<span class="lineNum">    3438 </span><span class="lineCov">          2 :   ymothervertex[0] = yvertexpoints[0][1];</span>
<span class="lineNum">    3439 </span><span class="lineCov">          2 :   xmothervertex[1] = xvertexpoints[0][2+nedges/2];</span>
<span class="lineNum">    3440 </span><span class="lineCov">          2 :   ymothervertex[1] = yvertexpoints[0][1];</span>
<span class="lineNum">    3441 </span><span class="lineCov">          2 :   xmothervertex[2] = xvertexpoints[0][2+nedges/2];</span>
<span class="lineNum">    3442 </span><span class="lineCov">          2 :   ymothervertex[2] = yvertexpoints[0][2+nedges];</span>
<span class="lineNum">    3443 </span><span class="lineCov">          2 :   xmothervertex[3] = xvertexpoints[0][3+nedges];</span>
<span class="lineNum">    3444 </span><span class="lineCov">          2 :   ymothervertex[3] = yvertexpoints[0][3+nedges];</span>
<span class="lineNum">    3445 </span><span class="lineCov">          2 :   xmothervertex[4] = xvertexpoints[0][3+2*nedges];</span>
<span class="lineNum">    3446 </span><span class="lineCov">          2 :   ymothervertex[4] = yvertexpoints[0][3+2*nedges]+fgkSSDTolerance;</span>
<span class="lineNum">    3447 </span><span class="lineCov">          2 :   xmothervertex[5] = xvertexpoints[0][4+2*nedges];</span>
<span class="lineNum">    3448 </span><span class="lineCov">          2 :   ymothervertex[5] = yvertexpoints[0][4+2*nedges]+fgkSSDTolerance;</span>
<span class="lineNum">    3449 </span><span class="lineCov">          2 :   xmothervertex[6] = xvertexpoints[1][5+2*nedges];</span>
<span class="lineNum">    3450 </span><span class="lineCov">          2 :   ymothervertex[6] = yvertexpoints[1][5+2*nedges];</span>
<span class="lineNum">    3451 </span><span class="lineCov">          2 :   xmothervertex[7] = xvertexpoints[0][1];</span>
<span class="lineNum">    3452 </span><span class="lineCov">          2 :   ymothervertex[7] = yvertexpoints[1][5+2*nedges];</span>
<span class="lineNum">    3453 </span><span class="lineCov">          2 :   TGeoXtru *ssdchipcablemothershape = new TGeoXtru(2);</span>
<span class="lineNum">    3454 </span><span class="lineCov">          2 :   ssdchipcablemothershape-&gt;DefinePolygon(kmothervertexnumber,xmothervertex,ymothervertex);</span>
<span class="lineNum">    3455 </span><span class="lineCov">          2 :   ssdchipcablemothershape-&gt;DefineSection(0,-0.5*fgkSSDChipCablesLength[1]);</span>
<span class="lineNum">    3456 </span><span class="lineCov">          2 :   ssdchipcablemothershape-&gt;DefineSection(1,+0.5*fgkSSDChipCablesLength[1]);</span>
<span class="lineNum">    3457 </span>            : 
<span class="lineNum">    3458 </span><span class="lineCov">          4 :   cableL = new TGeoVolume(&quot;SSDChipCableMotherLeft&quot;,ssdchipcablemothershape,fSSDAir);</span>
<span class="lineNum">    3459 </span><span class="lineCov">          4 :   cableR = new TGeoVolume(&quot;SSDChipCableMotherRight&quot;,ssdchipcablemothershape,fSSDAir);</span>
<span class="lineNum">    3460 </span>            : 
<span class="lineNum">    3461 </span><span class="lineCov">          2 :   cableL-&gt;AddNode(ssdchipcable[0],1);</span>
<span class="lineNum">    3462 </span><span class="lineCov">          2 :   cableL-&gt;AddNode(ssdchipcable[1],1);</span>
<span class="lineNum">    3463 </span><span class="lineCov">          2 :   cableR-&gt;AddNode(ssdchipcable[2],1);</span>
<span class="lineNum">    3464 </span><span class="lineCov">          2 :   cableR-&gt;AddNode(ssdchipcable[3],1);  </span>
<span class="lineNum">    3465 </span>            : 
<span class="lineNum">    3466 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3467 </span>            :   // Deallocating memory
<span class="lineNum">    3468 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3469 </span><span class="lineCov">         20 :   for(Int_t i=0; i&lt;kssdchipcableslaynumber; i++) delete [] vertexposition[i];</span>
<span class="lineNum">    3470 </span><span class="lineCov">         20 :   for(Int_t i=0; i&lt;kssdchipcableslaynumber; i++) delete transvector[i];</span>
<span class="lineNum">    3471 </span><span class="lineCov">          4 :   delete vertex; </span>
<span class="lineNum">    3472 </span>            :   /////////////////////////////////////////////////////////////
<a name="3473"><span class="lineNum">    3473 </span><span class="lineCov">          2 : }</span></a>
<span class="lineNum">    3474 </span>            : //_____________________________________________________________________________
<span class="lineNum">    3475 </span>            : TGeoVolume* AliITSv11GeometrySSD::GetSSDChip() const{
<span class="lineNum">    3476 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3477 </span>            :   // SSD Chip Assembly Generation    
<span class="lineNum">    3478 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3479 </span>            :   TGeoBBox* ssdchipcompshape[2];
<span class="lineNum">    3480 </span><span class="lineCov">          3 :   ssdchipcompshape[0] =  new TGeoBBox(&quot;SSDChipCompShape&quot;,</span>
<span class="lineNum">    3481 </span><span class="lineCov">          1 :                                                                                 0.5*fgkSSDChipLength,</span>
<span class="lineNum">    3482 </span><span class="lineCov">          1 :                                                                                 0.5*fgkSSDChipWidth,</span>
<span class="lineNum">    3483 </span><span class="lineCov">          1 :                                                                                 0.5*(fgkSSDChipHeight-fgkSSDChipGlueHeight));</span>
<span class="lineNum">    3484 </span><span class="lineCov">          2 :   ssdchipcompshape[1] =  new TGeoBBox(&quot;SSDChipGlueCompShape&quot;,</span>
<span class="lineNum">    3485 </span><span class="lineCov">          1 :                                                                                 0.5*fgkSSDChipLength,</span>
<span class="lineNum">    3486 </span><span class="lineCov">          1 :                                                                                 0.5*fgkSSDChipWidth,</span>
<span class="lineNum">    3487 </span><span class="lineCov">          1 :                                                                                 0.5*fgkSSDChipGlueHeight);</span>
<span class="lineNum">    3488 </span><span class="lineCov">          1 :   TGeoVolume* ssdchipcomp[2];</span>
<span class="lineNum">    3489 </span><span class="lineCov">          2 :   ssdchipcomp[0] = new TGeoVolume(&quot;SSDChipComp&quot;,ssdchipcompshape[0],fSSDChipMedium);</span>
<span class="lineNum">    3490 </span><span class="lineCov">          3 :   ssdchipcomp[1] = new TGeoVolume(&quot;SSDChipGlueComp&quot;,ssdchipcompshape[1],</span>
<span class="lineNum">    3491 </span><span class="lineCov">          1 :                                                                   fSSDChipGlueMedium);</span>
<span class="lineNum">    3492 </span><span class="lineCov">          1 :   ssdchipcomp[0]-&gt;SetLineColor(fColorSilicon);  </span>
<span class="lineNum">    3493 </span><span class="lineCov">          1 :   ssdchipcomp[1]-&gt;SetLineColor(fColorEpoxy);</span>
<span class="lineNum">    3494 </span><span class="lineCov">          1 :   TGeoTranslation* ssdchipcomptrans[2];</span>
<span class="lineNum">    3495 </span><span class="lineCov">          3 :   ssdchipcomptrans[0] = new TGeoTranslation(0.,0.,-ssdchipcompshape[1]-&gt;GetDZ());</span>
<span class="lineNum">    3496 </span><span class="lineCov">          3 :   ssdchipcomptrans[1] = new TGeoTranslation(0.,0.,ssdchipcompshape[0]-&gt;GetDZ());</span>
<span class="lineNum">    3497 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3498 </span>            :   // Virtual Volume containing SSDChip   
<span class="lineNum">    3499 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3500 </span><span class="lineCov">          2 :   TGeoBBox* ssdvirtualchipshape = new TGeoBBox(&quot;SSDChipShape&quot;,0.5*fgkSSDChipLength,</span>
<span class="lineNum">    3501 </span><span class="lineCov">          1 :                                                                                                                  0.5*fgkSSDChipWidth,</span>
<span class="lineNum">    3502 </span><span class="lineCov">          1 :                                                                                                                  0.5*fgkSSDChipHeight);</span>
<span class="lineNum">    3503 </span><span class="lineCov">          1 :   TGeoVolume* ssdchip = new TGeoVolume(&quot;SSDChip&quot;,ssdvirtualchipshape,fSSDAir);</span>
<span class="lineNum">    3504 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3505 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;2; i++) ssdchip-&gt;AddNode(ssdchipcomp[i],1,ssdchipcomptrans[i]);</span>
<span class="lineNum">    3506 </span><span class="lineCov">          1 :   return ssdchip;</span>
<a name="3507"><span class="lineNum">    3507 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">    3508 </span>            : /////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    3509 </span>            : TList* AliITSv11GeometrySSD::GetLadderCableSegment(Double_t ssdendladdercablelength){
<span class="lineNum">    3510 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3511 </span>            :   // Method returning a List containing pointers to Ladder Cable Volumes    
<span class="lineNum">    3512 </span>            :   //
<span class="lineNum">    3513 </span>            :   // Return list contains 3 assemblies: cable box, cable arb shape and the end part of the cable
<span class="lineNum">    3514 </span>            :   //                                    each contains 2 volumes, one for polyamide and one for aluminium
<span class="lineNum">    3515 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3516 </span>            :   const Int_t kladdercablesegmentnumber = 2;
<span class="lineNum">    3517 </span>            :   /////////////////////////////////////////
<span class="lineNum">    3518 </span>            :   // LadderSegmentBBox Volume
<span class="lineNum">    3519 </span>            :   /////////////////////////////////////////
<span class="lineNum">    3520 </span>            :   static TGeoBBox* laddercablesegmentbboxshape[kladdercablesegmentnumber] = {0,0};
<span class="lineNum">    3521 </span><span class="lineCov">        188 :   const char* laddercablesegmentbboxshapename[kladdercablesegmentnumber] = </span>
<span class="lineNum">    3522 </span>            :                                 {&quot;LadderCableSegmentBBoxShape1&quot;,&quot;LadderCableSegmentBBoxShape2&quot;};
<span class="lineNum">    3523 </span>            : 
<span class="lineNum">    3524 </span>            : 
<span class="lineNum">    3525 </span><span class="lineCov">         94 :   const char* laddercablesegmentbboxname[kladdercablesegmentnumber] = </span>
<span class="lineNum">    3526 </span>            :                                                   {&quot;LadderCableSegmentBBox1&quot;,&quot;LadderCableSegmentBBox2&quot;};
<span class="lineNum">    3527 </span>            :   static TGeoVolume* laddercablesegmentbbox[kladdercablesegmentnumber];
<span class="lineNum">    3528 </span>            : 
<span class="lineNum">    3529 </span><span class="lineCov">         97 :   static TGeoTranslation* laddercablesegmentbboxtrans[kladdercablesegmentnumber] = {</span>
<span class="lineNum">    3530 </span><span class="lineCov">          3 :                                                    new TGeoTranslation(&quot;LadderCableSegmentBBoxTrans1&quot;,</span>
<span class="lineNum">    3531 </span><span class="lineCov">          1 :                                                                                            0.5*fgkSSDFlexWidth[0],</span>
<span class="lineNum">    3532 </span><span class="lineCov">          1 :                                                                                            0.5*fgkSSDLadderCableWidth,</span>
<span class="lineNum">    3533 </span><span class="lineCov">          1 :                                                                        0.5*fgkSSDLadderCableHeight[0]),</span>
<span class="lineNum">    3534 </span><span class="lineCov">          3 :                                                    new TGeoTranslation(&quot;LadderCableSegmentBBoxTrans2&quot;,</span>
<span class="lineNum">    3535 </span><span class="lineCov">          1 :                                                                                            0.5*fgkSSDFlexWidth[0],</span>
<span class="lineNum">    3536 </span><span class="lineCov">          1 :                                                                                            0.5*fgkSSDLadderCableWidth,</span>
<span class="lineNum">    3537 </span><span class="lineCov">          1 :                                                                                            fgkSSDLadderCableHeight[0]</span>
<span class="lineNum">    3538 </span><span class="lineCov">          1 :                                                                                            +0.5*fgkSSDLadderCableHeight[1])</span>
<span class="lineNum">    3539 </span>            :                                                                                    };
<span class="lineNum">    3540 </span><span class="lineCov">         98 :   static TGeoVolume* laddercablesegmentbboxassembly = new TGeoVolumeAssembly(&quot;LadderCableSegmentBBoxAssembly&quot;) ;</span>
<span class="lineNum">    3541 </span><span class="lineCov">         98 :   static TGeoVolume* laddercablesegmentarbassembly = new TGeoVolumeAssembly(&quot;LadderCableSegmentArbAssembly&quot;); </span>
<span class="lineNum">    3542 </span>            : 
<span class="lineNum">    3543 </span>            :   static TGeoArb8* laddercablesegmentarbshape[kladdercablesegmentnumber];
<span class="lineNum">    3544 </span>            :   static TGeoVolume* laddercablesegmentarb[kladdercablesegmentnumber];
<span class="lineNum">    3545 </span>            : 
<span class="lineNum">    3546 </span><span class="lineCov">         94 :   if (laddercablesegmentbboxshape[0] == 0) { </span>
<span class="lineNum">    3547 </span>            :     // Initialise static shapes and volumes 
<span class="lineNum">    3548 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;kladdercablesegmentnumber; i++) laddercablesegmentbboxshape[i] = </span>
<span class="lineNum">    3549 </span><span class="lineCov">          4 :                                                      new TGeoBBox(laddercablesegmentbboxshapename[i],</span>
<span class="lineNum">    3550 </span><span class="lineCov">          2 :                                                                   0.5*fgkSSDFlexWidth[0],</span>
<span class="lineNum">    3551 </span><span class="lineCov">          2 :                                                                   0.5*fgkSSDLadderCableWidth,</span>
<span class="lineNum">    3552 </span><span class="lineCov">          2 :                                                                   0.5*fgkSSDLadderCableHeight[i]); </span>
<span class="lineNum">    3553 </span>            :   
<span class="lineNum">    3554 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;kladdercablesegmentnumber; i++){ </span>
<span class="lineNum">    3555 </span><span class="lineCov">          2 :     laddercablesegmentbbox[i] =</span>
<span class="lineNum">    3556 </span><span class="lineCov">          4 :       new TGeoVolume(laddercablesegmentbboxname[i],</span>
<span class="lineNum">    3557 </span><span class="lineCov">          2 :                      laddercablesegmentbboxshape[i],</span>
<span class="lineNum">    3558 </span><span class="lineCov">          6 :                      (i==0?fSSDAlTraceLadderCableMedium:</span>
<span class="lineNum">    3559 </span><span class="lineCov">          1 :                       fSSDKaptonLadderCableMedium));</span>
<span class="lineNum">    3560 </span><span class="lineCov">          6 :     laddercablesegmentbbox[i]-&gt;SetLineColor(i==0 ? fColorAl : </span>
<span class="lineNum">    3561 </span><span class="lineCov">          1 :                                             fColorPolyhamide);</span>
<span class="lineNum">    3562 </span>            :   }
<span class="lineNum">    3563 </span>            :   
<span class="lineNum">    3564 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;kladdercablesegmentnumber; i++)  </span>
<span class="lineNum">    3565 </span><span class="lineCov">          4 :     laddercablesegmentbboxassembly-&gt;AddNode(laddercablesegmentbbox[i],1,</span>
<span class="lineNum">    3566 </span><span class="lineCov">          2 :                                             laddercablesegmentbboxtrans[i]);</span>
<span class="lineNum">    3567 </span>            : /////////////////////////////////////////
<span class="lineNum">    3568 </span>            : // LadderSegmentArb8 Volume
<span class="lineNum">    3569 </span>            : /////////////////////////////////////////
<span class="lineNum">    3570 </span>            :   const Int_t kvertexnumber = 4;
<span class="lineNum">    3571 </span><span class="lineCov">          1 :   TVector3** laddercablesegmentvertexposition[kladdercablesegmentnumber];</span>
<span class="lineNum">    3572 </span><span class="lineCov">          6 :   for(Int_t i = 0; i&lt;kladdercablesegmentnumber; i++) laddercablesegmentvertexposition[i] = </span>
<span class="lineNum">    3573 </span><span class="lineCov">          2 :                                                        new TVector3*[kvertexnumber];</span>
<span class="lineNum">    3574 </span>            : //Shape Vertex Positioning
<span class="lineNum">    3575 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;kladdercablesegmentnumber; i++){</span>
<span class="lineNum">    3576 </span><span class="lineCov">          4 :     laddercablesegmentvertexposition[i][0] = new TVector3(0.,i*fgkSSDFlexHeight[0], 0);</span>
<span class="lineNum">    3577 </span><span class="lineCov">          6 :     laddercablesegmentvertexposition[i][1] = new TVector3(fgkSSDLadderCableWidth,</span>
<span class="lineNum">    3578 </span><span class="lineCov">          2 :                                                           i*fgkSSDFlexHeight[0], 0);</span>
<span class="lineNum">    3579 </span><span class="lineCov">          6 :     laddercablesegmentvertexposition[i][2] = new TVector3(0.,fgkSSDFlexHeight[0]</span>
<span class="lineNum">    3580 </span><span class="lineCov">          2 :                                                           +                          fgkSSDFlexHeight[1]</span>
<span class="lineNum">    3581 </span><span class="lineCov">          2 :                                                           + i*fgkSSDFlexHeight[0], 0);</span>
<span class="lineNum">    3582 </span><span class="lineCov">          2 :     laddercablesegmentvertexposition[i][3] = </span>
<span class="lineNum">    3583 </span><span class="lineCov">          4 :       new TVector3(laddercablesegmentvertexposition[i][1]-&gt;X(),</span>
<span class="lineNum">    3584 </span><span class="lineCov">          2 :                    laddercablesegmentvertexposition[i][2]-&gt;Y(), 0);</span>
<span class="lineNum">    3585 </span>            :   }
<span class="lineNum">    3586 </span><span class="lineCov">          1 :   Double_t laddercablesegmentwidth[2][2] = {{fgkSSDFlexHeight[0],fgkSSDFlexHeight[0]},</span>
<span class="lineNum">    3587 </span><span class="lineCov">          1 :                                             {fgkSSDFlexHeight[1],fgkSSDFlexHeight[1]}}; </span>
<span class="lineNum">    3588 </span><span class="lineCov">          1 :   const char* laddercablesegmentarbshapename[kladdercablesegmentnumber] = </span>
<span class="lineNum">    3589 </span>            :     {&quot;LadderCableSegmentArbShape1&quot;,&quot;LadderCableSegmentArbShape2&quot;};
<span class="lineNum">    3590 </span>            :   
<span class="lineNum">    3591 </span><span class="lineCov">          6 :   for(Int_t i = 0; i&lt; kladdercablesegmentnumber; i++) laddercablesegmentarbshape[i] = </span>
<span class="lineNum">    3592 </span><span class="lineCov">          4 :                                                         GetArbShape(laddercablesegmentvertexposition[i],</span>
<span class="lineNum">    3593 </span><span class="lineCov">          2 :                                                                     laddercablesegmentwidth[i],</span>
<span class="lineNum">    3594 </span><span class="lineCov">          2 :                                                                     fgkCarbonFiberJunctionWidth-fgkSSDFlexWidth[0],</span>
<span class="lineNum">    3595 </span><span class="lineCov">          2 :                                                                     laddercablesegmentarbshapename[i]);</span>
<span class="lineNum">    3596 </span><span class="lineCov">          1 :   const char* laddercablesegmentarbname[kladdercablesegmentnumber] = </span>
<span class="lineNum">    3597 </span>            :     {&quot;LadderCableSegmentArb1&quot;,&quot;LadderCableSegmentArb2&quot;};
<span class="lineNum">    3598 </span>            :   
<span class="lineNum">    3599 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;kladdercablesegmentnumber; i++){</span>
<span class="lineNum">    3600 </span><span class="lineCov">          2 :     laddercablesegmentarb[i] =</span>
<span class="lineNum">    3601 </span><span class="lineCov">          4 :       new TGeoVolume(laddercablesegmentarbname[i],</span>
<span class="lineNum">    3602 </span><span class="lineCov">          2 :                      laddercablesegmentarbshape[i],</span>
<span class="lineNum">    3603 </span><span class="lineCov">          6 :                      (i==0?fSSDAlTraceLadderCableMedium:</span>
<span class="lineNum">    3604 </span><span class="lineCov">          1 :                       fSSDKaptonLadderCableMedium)); </span>
<span class="lineNum">    3605 </span><span class="lineCov">          6 :     laddercablesegmentarb[i]-&gt;SetLineColor(i==0 ? fColorAl : </span>
<span class="lineNum">    3606 </span><span class="lineCov">          1 :                                            fColorPolyhamide);</span>
<span class="lineNum">    3607 </span>            :   }
<span class="lineNum">    3608 </span>            :   TGeoRotation* laddercablesegmentarbrot[kladdercablesegmentnumber];
<span class="lineNum">    3609 </span><span class="lineCov">          1 :   laddercablesegmentarbrot[0] = new TGeoRotation(&quot;LadderCableSegmentArbRot1&quot;,</span>
<span class="lineNum">    3610 </span>            :                                                  90.,90,-90.);   
<span class="lineNum">    3611 </span><span class="lineCov">          1 :   laddercablesegmentarbrot[1] = new TGeoRotation(&quot;LadderCableSegmentArbRot2&quot;,</span>
<span class="lineNum">    3612 </span>            :                                                  0.,90.,0.);     
<span class="lineNum">    3613 </span>            :   TGeoCombiTrans* laddercablesegmentarbcombitrans =  
<span class="lineNum">    3614 </span><span class="lineCov">          2 :     new TGeoCombiTrans(&quot;LadderCableSegmentArbCombiTrans&quot;,</span>
<span class="lineNum">    3615 </span><span class="lineCov">          1 :                        0.5*(fgkCarbonFiberJunctionWidth-fgkSSDFlexWidth[0])</span>
<span class="lineNum">    3616 </span><span class="lineCov">          1 :                        + fgkSSDFlexWidth[0],0.,0.,</span>
<span class="lineNum">    3617 </span><span class="lineCov">          3 :                        new TGeoRotation((*laddercablesegmentarbrot[1])</span>
<span class="lineNum">    3618 </span><span class="lineCov">          1 :                                         *(*laddercablesegmentarbrot[0])));</span>
<span class="lineNum">    3619 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;kladdercablesegmentnumber; i++)</span>
<span class="lineNum">    3620 </span><span class="lineCov">          4 :     laddercablesegmentarbassembly-&gt;AddNode(laddercablesegmentarb[i],1,</span>
<span class="lineNum">    3621 </span><span class="lineCov">          2 :                                            laddercablesegmentarbcombitrans);</span>
<span class="lineNum">    3622 </span><span class="lineCov">          1 :   }  // End of static initialisations</span>
<span class="lineNum">    3623 </span>            :   /////////////////////////////////////////
<span class="lineNum">    3624 </span>            :   // End Ladder Cable Volume
<span class="lineNum">    3625 </span>            :   // Note: this part depends explicitly on the length passed as an argument to the function
<span class="lineNum">    3626 </span>            :   /////////////////////////////////////////
<span class="lineNum">    3627 </span><span class="lineCov">         94 :   TGeoBBox* ladderendcablesegmentbboxshape[kladdercablesegmentnumber];</span>
<span class="lineNum">    3628 </span><span class="lineCov">         94 :   const char* ladderendcablesegmentbboxshapename[kladdercablesegmentnumber] = </span>
<span class="lineNum">    3629 </span>            :     {&quot;LadderEndCableSegmentBBoxShape1&quot;,&quot;LadderEndCableSegmentBBoxShape2&quot;};
<span class="lineNum">    3630 </span><span class="lineCov">        564 :   for(Int_t i=0; i&lt;kladdercablesegmentnumber; i++) ladderendcablesegmentbboxshape[i] = </span>
<span class="lineNum">    3631 </span><span class="lineCov">        376 :                                                      new TGeoBBox(ladderendcablesegmentbboxshapename[i],</span>
<span class="lineNum">    3632 </span><span class="lineCov">        188 :                                                                   0.5*ssdendladdercablelength,</span>
<span class="lineNum">    3633 </span><span class="lineCov">        188 :                                                                   0.5*fgkSSDLadderCableWidth,</span>
<span class="lineNum">    3634 </span><span class="lineCov">        188 :                                                                   0.5*fgkSSDLadderCableHeight[i]);</span>
<span class="lineNum">    3635 </span><span class="lineCov">         94 :   const char* ladderendcablesegmentbboxname[kladdercablesegmentnumber] = </span>
<span class="lineNum">    3636 </span>            :     {&quot;LadderEndCableSegmentBBox1&quot;,&quot;LadderEndCableSegmentBBox2&quot;};
<span class="lineNum">    3637 </span><span class="lineCov">         94 :   TGeoVolume* ladderendcablesegmentbbox[kladdercablesegmentnumber];</span>
<span class="lineNum">    3638 </span><span class="lineCov">        564 :   for(Int_t i=0; i&lt;kladdercablesegmentnumber; i++){ </span>
<span class="lineNum">    3639 </span><span class="lineCov">        188 :     ladderendcablesegmentbbox[i] =</span>
<span class="lineNum">    3640 </span><span class="lineCov">        376 :       new TGeoVolume(ladderendcablesegmentbboxname[i],</span>
<span class="lineNum">    3641 </span><span class="lineCov">        188 :                      ladderendcablesegmentbboxshape[i],</span>
<span class="lineNum">    3642 </span><span class="lineCov">        564 :                      (i==0?fSSDAlTraceLadderCableMedium:</span>
<span class="lineNum">    3643 </span><span class="lineCov">         94 :                       fSSDKaptonLadderCableMedium));</span>
<span class="lineNum">    3644 </span><span class="lineCov">        564 :     ladderendcablesegmentbbox[i]-&gt;SetLineColor(i==0 ? fColorAl : </span>
<span class="lineNum">    3645 </span><span class="lineCov">         94 :                                                fColorPolyhamide);</span>
<span class="lineNum">    3646 </span>            :   }
<span class="lineNum">    3647 </span><span class="lineCov">         94 :   TGeoTranslation* ladderendcablesegmentbboxtrans[kladdercablesegmentnumber];                                                                             </span>
<span class="lineNum">    3648 </span><span class="lineCov">         94 :   ladderendcablesegmentbboxtrans[0] = </span>
<span class="lineNum">    3649 </span><span class="lineCov">        188 :     new TGeoTranslation(&quot;LadderEndCableSegmentBBoxTrans0&quot;,</span>
<span class="lineNum">    3650 </span><span class="lineCov">         94 :                         0.5*ssdendladdercablelength,</span>
<span class="lineNum">    3651 </span><span class="lineCov">         94 :                         0.5*fgkSSDLadderCableWidth,</span>
<span class="lineNum">    3652 </span><span class="lineCov">         94 :                         0.5*fgkSSDLadderCableHeight[0]);</span>
<span class="lineNum">    3653 </span><span class="lineCov">         94 :   ladderendcablesegmentbboxtrans[1] = </span>
<span class="lineNum">    3654 </span><span class="lineCov">        188 :     new TGeoTranslation(&quot;LadderEndCableSegmentBBoxTrans1&quot;,</span>
<span class="lineNum">    3655 </span>            :                         0.5*ssdendladdercablelength,
<span class="lineNum">    3656 </span><span class="lineCov">         94 :                         0.5*fgkSSDLadderCableWidth,</span>
<span class="lineNum">    3657 </span><span class="lineCov">         94 :                         fgkSSDLadderCableHeight[0]</span>
<span class="lineNum">    3658 </span><span class="lineCov">         94 :                         +0.5*fgkSSDLadderCableHeight[1]);</span>
<span class="lineNum">    3659 </span>            :   TGeoVolume* ladderendcablesegmentbboxassembly = 
<span class="lineNum">    3660 </span><span class="lineCov">        188 :     new TGeoVolumeAssembly(&quot;LadderEndCableSegmentBBoxAssembly&quot;); </span>
<span class="lineNum">    3661 </span><span class="lineCov">        564 :   for(Int_t i=0; i&lt;kladdercablesegmentnumber; i++)  </span>
<span class="lineNum">    3662 </span><span class="lineCov">        376 :     ladderendcablesegmentbboxassembly-&gt;AddNode(ladderendcablesegmentbbox[i],1,</span>
<span class="lineNum">    3663 </span><span class="lineCov">        188 :                                                ladderendcablesegmentbboxtrans[i]);</span>
<span class="lineNum">    3664 </span>            :   /////////////////////////////////////////
<span class="lineNum">    3665 </span><span class="lineCov">         94 :   TList* laddercablesegmentlist = new TList();</span>
<span class="lineNum">    3666 </span><span class="lineCov">         94 :   laddercablesegmentlist-&gt;Add(laddercablesegmentbboxassembly);</span>
<span class="lineNum">    3667 </span><span class="lineCov">         94 :   laddercablesegmentlist-&gt;Add(laddercablesegmentarbassembly);</span>
<span class="lineNum">    3668 </span><span class="lineCov">         94 :   laddercablesegmentlist-&gt;Add(ladderendcablesegmentbboxassembly);</span>
<span class="lineNum">    3669 </span>            : 
<span class="lineNum">    3670 </span><span class="lineCov">         94 :   laddercablesegmentbboxassembly-&gt;GetShape()-&gt;ComputeBBox(); //RS: enforce recompting of BBox</span>
<span class="lineNum">    3671 </span><span class="lineCov">         94 :   laddercablesegmentarbassembly-&gt;GetShape()-&gt;ComputeBBox();</span>
<span class="lineNum">    3672 </span><span class="lineCov">         94 :   return laddercablesegmentlist;</span>
<span class="lineNum">    3673 </span><span class="lineCov">         94 : }</span>
<a name="3674"><span class="lineNum">    3674 </span>            : </a>
<span class="lineNum">    3675 </span>            : /////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    3676 </span>            : TGeoVolume* AliITSv11GeometrySSD::GetLadderCable(Int_t n, Double_t ssdendladdercablelength){
<span class="lineNum">    3677 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3678 </span>            :   // Method generating Ladder Cable of given length (n modules + end)
<span class="lineNum">    3679 </span>            :   // Called by GetLadderCableAssembly
<span class="lineNum">    3680 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3681 </span><span class="lineCov">        188 :   TList* laddercablesegmentlist = GetLadderCableSegment(ssdendladdercablelength);</span>
<span class="lineNum">    3682 </span><span class="lineCov">        188 :   TGeoVolume* laddercable = new TGeoVolumeAssembly(&quot;LadderCable&quot;); </span>
<span class="lineNum">    3683 </span><span class="lineCov">       1396 :   for(Int_t i=0; i&lt;n; i++){</span>
<span class="lineNum">    3684 </span><span class="lineCov">       1208 :          TGeoTranslation* laddercabletrans = new TGeoTranslation(</span>
<span class="lineNum">    3685 </span><span class="lineCov">        604 :                                                         i*(fgkCarbonFiberJunctionWidth),</span>
<span class="lineNum">    3686 </span><span class="lineCov">        604 :                                                         fgkSSDLadderCableWidth-fgkSSDFlexWidth[0],</span>
<span class="lineNum">    3687 </span><span class="lineCov">        604 :                                                         i*(fgkSSDLadderCableHeight[0]+fgkSSDLadderCableHeight[1]));</span>
<span class="lineNum">    3688 </span><span class="lineCov">        604 :     laddercable-&gt;AddNode((TGeoVolume*)laddercablesegmentlist-&gt;At(0),i+1,laddercabletrans);  </span>
<span class="lineNum">    3689 </span><span class="lineCov">       1114 :     if(i!=n-1) laddercable-&gt;AddNode((TGeoVolume*)laddercablesegmentlist-&gt;At(1),i+1,laddercabletrans);  </span>
<span class="lineNum">    3690 </span>            :  
<span class="lineNum">    3691 </span>            :   }
<span class="lineNum">    3692 </span><span class="lineCov">        188 :   TGeoTranslation* endladdercabletrans = new TGeoTranslation(&quot;EndLadderCableTrans&quot;,</span>
<span class="lineNum">    3693 </span><span class="lineCov">         94 :                                           (n-1)*fgkCarbonFiberJunctionWidth+fgkSSDFlexWidth[0],</span>
<span class="lineNum">    3694 </span><span class="lineCov">         94 :                                                              fgkSSDLadderCableWidth-fgkSSDFlexWidth[0],</span>
<span class="lineNum">    3695 </span><span class="lineCov">         94 :                                                              (n-1)*(fgkSSDLadderCableHeight[0]+fgkSSDLadderCableHeight[1]));</span>
<span class="lineNum">    3696 </span><span class="lineCov">         94 :   laddercable-&gt;AddNode((TGeoVolume*)laddercablesegmentlist-&gt;At(2),1,endladdercabletrans);</span>
<span class="lineNum">    3697 </span>            : 
<span class="lineNum">    3698 </span><span class="lineCov">         94 :   laddercable-&gt;GetShape()-&gt;ComputeBBox(); //RS: enforce recompting of BBox</span>
<span class="lineNum">    3699 </span><span class="lineCov">         94 :   return laddercable;</span>
<a name="3700"><span class="lineNum">    3700 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    3701 </span>            : /////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    3702 </span>            : TGeoVolume* AliITSv11GeometrySSD::GetLadderCableAssembly(Int_t n, Double_t ssdendladdercablelength){
<span class="lineNum">    3703 </span>            :   ///////////////////////////////////////////////////////////////////
<span class="lineNum">    3704 </span>            :   // Main method generating Ladder Cable bundles containing n cables
<span class="lineNum">    3705 </span>            :   ///////////////////////////////////////////////////////////////////
<span class="lineNum">    3706 </span><span class="lineCov">         16 :   Double_t totalLength = ssdendladdercablelength+(n-1)*fgkCarbonFiberJunctionWidth+fgkSSDFlexWidth[0];</span>
<span class="lineNum">    3707 </span><span class="lineCov">          8 :   Double_t cableOrig[3] = {0.5*totalLength,1.5*fgkSSDLadderCableWidth-fgkSSDFlexWidth[0],0.5*n*(fgkSSDLadderCableHeight[0]+fgkSSDLadderCableHeight[1])};</span>
<span class="lineNum">    3708 </span><span class="lineCov">          8 :   TGeoBBox *laddercableshape = new TGeoBBox(0.5*totalLength,0.5*fgkSSDLadderCableWidth,0.5*n*(fgkSSDLadderCableHeight[0]+fgkSSDLadderCableHeight[1]),cableOrig);</span>
<span class="lineNum">    3709 </span><span class="lineCov">          8 :   TGeoVolume* laddercable = new TGeoVolume(&quot;LadderCableMother&quot;, laddercableshape, fSSDAir);</span>
<span class="lineNum">    3710 </span><span class="lineCov">          8 :   char laddercabletransname[100];</span>
<span class="lineNum">    3711 </span><span class="lineCov">        204 :   for(Int_t i=0; i&lt;n; i++){ </span>
<span class="lineNum">    3712 </span><span class="lineCov">         94 :     snprintf(laddercabletransname,100,&quot;LadderCableTrans%i&quot;,i+1);</span>
<span class="lineNum">    3713 </span><span class="lineCov">        188 :     laddercable-&gt;AddNode(GetLadderCable(n-i,ssdendladdercablelength),i+1,</span>
<span class="lineNum">    3714 </span><span class="lineCov">        188 :                          new TGeoTranslation(laddercabletransname,i*fgkCarbonFiberJunctionWidth,0,0));</span>
<span class="lineNum">    3715 </span>            :   }
<span class="lineNum">    3716 </span><span class="lineCov">          8 :   return laddercable;</span>
<a name="3717"><span class="lineNum">    3717 </span><span class="lineCov">          8 : }</span></a>
<span class="lineNum">    3718 </span>            : /////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    3719 </span>            : TList* AliITSv11GeometrySSD::GetLadderCableAssemblyList(Int_t n, Double_t ssdendladdercablelength){
<span class="lineNum">    3720 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3721 </span>            :   // Method generating Ladder Cable List Assemblies  
<span class="lineNum">    3722 </span>            :   // containing two cables bundles, i.e. P+N readout for one endcap
<span class="lineNum">    3723 </span>            :   /////////////////////////////////////////////////////////////  
<span class="lineNum">    3724 </span>            :   const Int_t kladdercableassemblynumber = 2; 
<span class="lineNum">    3725 </span><span class="lineCov">         16 :   TGeoVolume* laddercableassembly = GetLadderCableAssembly(n,ssdendladdercablelength);</span>
<span class="lineNum">    3726 </span><span class="lineCov">          8 :   TGeoVolume* ladderCable[kladdercableassemblynumber];</span>
<span class="lineNum">    3727 </span><span class="lineCov">          8 :   char laddercableassemblyname[100];</span>
<span class="lineNum">    3728 </span><span class="lineCov">          8 :   TList* laddercableassemblylist = new TList();</span>
<span class="lineNum">    3729 </span><span class="lineCov">         48 :   for(Int_t i=0; i&lt;kladdercableassemblynumber; i++){ </span>
<span class="lineNum">    3730 </span><span class="lineCov">         16 :     snprintf(laddercableassemblyname,100,&quot;LadderCableAssembly%i&quot;,i+1);</span>
<span class="lineNum">    3731 </span><span class="lineCov">         32 :     ladderCable[i] = new TGeoVolumeAssembly(laddercableassemblyname);</span>
<span class="lineNum">    3732 </span><span class="lineCov">         32 :     ladderCable[i]-&gt;AddNode(laddercableassembly,i+1,i==0 ? NULL :</span>
<span class="lineNum">    3733 </span><span class="lineCov">         16 :                             new TGeoCombiTrans((n-1)</span>
<span class="lineNum">    3734 </span><span class="lineCov">          8 :                                                *         fgkCarbonFiberJunctionWidth+fgkSSDFlexWidth[0],</span>
<span class="lineNum">    3735 </span><span class="lineCov">          8 :                                                2.*fgkSSDLadderCableWidth+0.5*fgkSSDFlexWidth[0],</span>
<span class="lineNum">    3736 </span><span class="lineCov">         16 :                                                0.,new TGeoRotation(&quot;&quot;,180,0.,0.)));</span>
<span class="lineNum">    3737 </span><span class="lineCov">         16 :     ladderCable[i]-&gt;GetShape()-&gt;ComputeBBox(); //RS: enforce recompting of BBox</span>
<span class="lineNum">    3738 </span><span class="lineCov">         16 :     laddercableassemblylist-&gt;Add(ladderCable[i]);</span>
<span class="lineNum">    3739 </span>            : }
<span class="lineNum">    3740 </span><span class="lineCov">          8 :   return laddercableassemblylist;</span>
<a name="3741"><span class="lineNum">    3741 </span><span class="lineCov">          8 : }</span></a>
<span class="lineNum">    3742 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    3743 </span>            : void AliITSv11GeometrySSD::SetLadderSegment(){
<span class="lineNum">    3744 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3745 </span>            :   // Method Generating Ladder Segment Array
<span class="lineNum">    3746 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3747 </span><span class="lineCov">          3 :   fladdersegment[0] = new TGeoVolumeAssembly(&quot;LadderSegment1&quot;);       </span>
<span class="lineNum">    3748 </span><span class="lineCov">          2 :   fladdersegment[1] = new TGeoVolumeAssembly(&quot;LadderSegment2&quot;);       </span>
<span class="lineNum">    3749 </span>            : 
<span class="lineNum">    3750 </span>            :   /* MvL: tried to create mother volume. Requires changes in all rotations, bc xtru is always along z-axis
<span class="lineNum">    3751 </span>            :   TGeoXtru *laddersegmentshape = new TGeoXtru(2);
<span class="lineNum">    3752 </span>            :   static const Int_t ntrianglevtx = 3;
<span class="lineNum">    3753 </span>            :   Double_t xtrianglevtx[ntrianglevtx]={-0.5*fgkCarbonFiberTriangleLength,fgkCarbonFiberTriangleLength, 0};
<span class="lineNum">    3754 </span>            :   Double_t ytrianglevtx[ntrianglevtx]={0, 0, fgkCarbonFiberTriangleLength * TMath::Sin(fgkCarbonFiberTriangleAngle*TMath::DegToRad())};
<span class="lineNum">    3755 </span>            :   laddersegmentshape-&gt;DefinePolygon(ntrianglevtx,xtrianglevtx,ytrianglevtx);
<span class="lineNum">    3756 </span>            :   laddersegmentshape-&gt;DefineSection(0,0);
<span class="lineNum">    3757 </span>            :   laddersegmentshape-&gt;DefineSection(1,fgkCarbonFiberJunctionWidth);  // MVL
<span class="lineNum">    3758 </span>            :   fladdersegment[0] = new TGeoVolume(&quot;LadderSegment1&quot;,laddersegmentshape,fSSDAir);    
<span class="lineNum">    3759 </span>            :   fladdersegment[1] = new TGeoVolume(&quot;LadderSegment2&quot;,laddersegmentshape,fSSDAir);    
<span class="lineNum">    3760 </span>            :   */
<span class="lineNum">    3761 </span>            : 
<span class="lineNum">    3762 </span><span class="lineCov">          1 :   if(!fCreateMaterials) CreateMaterials();</span>
<span class="lineNum">    3763 </span><span class="lineCov">          1 :   if(!fTransformationMatrices) CreateTransformationMatrices();</span>
<span class="lineNum">    3764 </span><span class="lineCov">          1 :   if(!fBasicObjects) CreateBasicObjects();</span>
<span class="lineNum">    3765 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkladdersegmentnumber; i++){</span>
<span class="lineNum">    3766 </span>            :   // Placing Carbon Fiber Support       
<span class="lineNum">    3767 </span><span class="lineCov">         12 :         for(Int_t j=0; j&lt;fgkcarbonfibersupportnumber; j++){ </span>
<span class="lineNum">    3768 </span><span class="lineCov">          8 :                 fladdersegment[i]-&gt;AddNode(fcarbonfibersupport[0],j+1,</span>
<span class="lineNum">    3769 </span><span class="lineCov">          4 :                                                                                         fcarbonfibersupportmatrix[j]);  </span>
<span class="lineNum">    3770 </span><span class="lineCov">          8 :                 fladdersegment[i]-&gt;AddNode(fcarbonfibersupport[1],j+1,</span>
<span class="lineNum">    3771 </span><span class="lineCov">          4 :                                                                                         fcarbonfibersupportmatrix[j]);</span>
<span class="lineNum">    3772 </span>            :   }
<span class="lineNum">    3773 </span>            :   // Placing Carbon Fiber Junction
<span class="lineNum">    3774 </span><span class="lineCov">         16 :         for(Int_t j=0; j&lt;fgkcarbonfiberjunctionumber; j++) {</span>
<span class="lineNum">    3775 </span><span class="lineCov">         12 :         fladdersegment[i]-&gt;AddNode(fcarbonfiberjunction,j+1,</span>
<span class="lineNum">    3776 </span><span class="lineCov">          6 :                                                                    fcarbonfiberjunctionmatrix[j]);</span>
<span class="lineNum">    3777 </span>            :   }
<span class="lineNum">    3778 </span>            :   // Placing Carbon Fiber Lower Support
<span class="lineNum">    3779 </span><span class="lineCov">         12 :     for(Int_t j=0; j&lt;fgkcarbonfiberlowersupportnumber; j++) {</span>
<span class="lineNum">    3780 </span><span class="lineCov">          8 :                 fladdersegment[i]-&gt;AddNode(fcarbonfiberlowersupport[j],j+1,</span>
<span class="lineNum">    3781 </span><span class="lineCov">          4 :                                                            fcarbonfiberlowersupportrans[j]);    </span>
<span class="lineNum">    3782 </span>            :     }
<span class="lineNum">    3783 </span>            :   // Placing SSD Sensor Support
<span class="lineNum">    3784 </span><span class="lineCov">         16 :     for(Int_t j=0; j&lt;fgkssdsensorsupportnumber; j++) </span>
<span class="lineNum">    3785 </span><span class="lineCov">         24 :         fladdersegment[i]-&gt;AddNode(j&lt;2 ? fssdsensorsupport[0][i] :</span>
<span class="lineNum">    3786 </span><span class="lineCov">          2 :                                                                      fssdsensorsupport[1][i],</span>
<span class="lineNum">    3787 </span><span class="lineCov">          6 :                                                            j+1,fssdsensorsupportmatrix[j]);</span>
<span class="lineNum">    3788 </span>            :   // Placing SSD Cooling Tube Support 
<span class="lineNum">    3789 </span><span class="lineCov">         12 :         for(Int_t j=0; j&lt;fgkcoolingtubesupportnumber; j++)</span>
<span class="lineNum">    3790 </span><span class="lineCov">          8 :                 fladdersegment[i]-&gt;AddNode(fcoolingtubesupport,j+1,</span>
<span class="lineNum">    3791 </span><span class="lineCov">          4 :                                                                    fcoolingtubesupportmatrix[j]);</span>
<span class="lineNum">    3792 </span>            :   // Placing SSD Cooling Tube  
<span class="lineNum">    3793 </span><span class="lineCov">          4 :         fladdersegment[i]-&gt;AddNode(fcoolingtube,1,fcoolingtubematrix[0]);</span>
<span class="lineNum">    3794 </span><span class="lineCov">          4 :         fladdersegment[i]-&gt;AddNode(fcoolingtube,2,fcoolingtubematrix[1]);</span>
<span class="lineNum">    3795 </span>            :   // Placing SSD Hybrid
<span class="lineNum">    3796 </span><span class="lineCov">          4 :     switch(i){</span>
<span class="lineNum">    3797 </span>            :         case 0: 
<span class="lineNum">    3798 </span><span class="lineCov">          1 :                 fladdersegment[i]-&gt;AddNode(fssdhybridcomponent[0],1,fhybridmatrix);</span>
<span class="lineNum">    3799 </span><span class="lineCov">          1 :                 fladdersegment[i]-&gt;AddNode(fssdhybridcomponent[2],1,fhybridmatrix);</span>
<span class="lineNum">    3800 </span><span class="lineCov">          1 :                 break;</span>
<span class="lineNum">    3801 </span>            :     case 1:
<span class="lineNum">    3802 </span><span class="lineCov">          1 :                 fladdersegment[i]-&gt;AddNode(fssdhybridcomponent[1],1,fhybridmatrix);</span>
<span class="lineNum">    3803 </span><span class="lineCov">          1 :                 fladdersegment[i]-&gt;AddNode(fssdhybridcomponent[2],1,fhybridmatrix);</span>
<span class="lineNum">    3804 </span><span class="lineCov">          1 :                 break;</span>
<span class="lineNum">    3805 </span>            :         }
<span class="lineNum">    3806 </span>            :         // Placing Cooling Block System
<span class="lineNum">    3807 </span><span class="lineCov">          2 :       fladdersegment[i]-&gt;AddNode(fssdcoolingblocksystem,1,fcoolingblocksystematrix);</span>
<span class="lineNum">    3808 </span>            :         // Placing SSD Flex
<span class="lineNum">    3809 </span><span class="lineCov">         12 :       for(Int_t j=0; j&lt;fgkflexnumber; j++){</span>
<span class="lineNum">    3810 </span><span class="lineCov">          4 :         fladdersegment[i]-&gt;AddNode(fssdstiffenerflex,j+1,fstiffenerflexmatrix[j]);</span>
<span class="lineNum">    3811 </span><span class="lineCov">          4 :         fladdersegment[i]-&gt;AddNode(fssdendflex,j+1,fendflexmatrix[j]);</span>
<span class="lineNum">    3812 </span>            :       }
<span class="lineNum">    3813 </span>            :    }
<span class="lineNum">    3814 </span><span class="lineCov">          1 :   fladdersegment[0]-&gt;GetShape()-&gt;ComputeBBox(); //RS: enforce recompting of BBox</span>
<span class="lineNum">    3815 </span><span class="lineCov">          1 :   fladdersegment[1]-&gt;GetShape()-&gt;ComputeBBox();</span>
<span class="lineNum">    3816 </span>            :  
<a name="3817"><span class="lineNum">    3817 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">    3818 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    3819 </span>            : void AliITSv11GeometrySSD::SetEndLadderSegment(){
<span class="lineNum">    3820 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3821 </span>            :   // Method Generating End Ladder
<span class="lineNum">    3822 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3823 </span>            :   // End Ladder Carbon Fiber Junction 
<span class="lineNum">    3824 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3825 </span><span class="lineCov">          3 :   fendladdersegment[0] = new TGeoVolumeAssembly(&quot;EndLadder1&quot;);</span>
<span class="lineNum">    3826 </span><span class="lineCov">          2 :   fendladdersegment[1] = new TGeoVolumeAssembly(&quot;EndLadder2&quot;);</span>
<span class="lineNum">    3827 </span><span class="lineCov">          1 :   if(!fCreateMaterials) CreateMaterials();</span>
<span class="lineNum">    3828 </span><span class="lineCov">          1 :   if(!fTransformationMatrices) CreateTransformationMatrices();</span>
<span class="lineNum">    3829 </span><span class="lineCov">          1 :   if(!fBasicObjects) CreateBasicObjects();</span>
<span class="lineNum">    3830 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkendlabbercarbonfiberjunctionumber; i++){</span>
<span class="lineNum">    3831 </span><span class="lineCov">         16 :         for(Int_t j=0; j&lt;fgkendladdercarbonfiberjunctionmatrixnumber; j++)</span>
<span class="lineNum">    3832 </span><span class="lineCov">         30 :                 fendladdersegment[i]-&gt;AddNode(j==2 ? </span>
<span class="lineNum">    3833 </span><span class="lineCov">          8 :                                                         fendladdercarbonfiberjunction[i][1] : </span>
<span class="lineNum">    3834 </span><span class="lineCov">          4 :                                                         fendladdercarbonfiberjunction[i][0],</span>
<span class="lineNum">    3835 </span><span class="lineCov">          6 :                                                         j+1,fendladdercarbonfiberjunctionmatrix[i][j]);</span>
<span class="lineNum">    3836 </span>            :   }
<span class="lineNum">    3837 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3838 </span>            :   // End Ladder Carbon Fiber Support 
<span class="lineNum">    3839 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3840 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkcarbonfibersupportnumber; i++)</span>
<span class="lineNum">    3841 </span><span class="lineCov">         12 :       for(Int_t j=0; j&lt;fgkendladdercarbonfibermatrixnumber; j++){</span>
<span class="lineNum">    3842 </span><span class="lineCov">          8 :                   fendladdersegment[i]-&gt;AddNode(fcarbonfibersupport[0],j+1,</span>
<span class="lineNum">    3843 </span><span class="lineCov">          4 :                   fendladdercarbonfibermatrix[i][j]);   </span>
<span class="lineNum">    3844 </span><span class="lineCov">          8 :           fendladdersegment[i]-&gt;AddNode(fcarbonfibersupport[1],j+1,</span>
<span class="lineNum">    3845 </span><span class="lineCov">          4 :                   fendladdercarbonfibermatrix[i][j]);   </span>
<span class="lineNum">    3846 </span>            :       }
<span class="lineNum">    3847 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3848 </span>            :   // End Ladder Mounting Block
<span class="lineNum">    3849 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3850 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkendladdermountingblocknumber; i++)</span>
<span class="lineNum">    3851 </span><span class="lineCov">          4 :        fendladdersegment[i]-&gt;AddNode(fendladdermountingblock,i+1,</span>
<span class="lineNum">    3852 </span><span class="lineCov">          2 :                                      fendladdermountingblockcombitrans[i]);</span>
<span class="lineNum">    3853 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3854 </span>            :   // End Ladder Mounting Block Clip
<span class="lineNum">    3855 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3856 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkendladdermountingblocknumber; i++)</span>
<span class="lineNum">    3857 </span><span class="lineCov">         12 :         for(Int_t j=0; j&lt;2; j++)</span>
<span class="lineNum">    3858 </span><span class="lineCov">          8 :                 fendladdersegment[i]-&gt;AddNode(fendladdermountingblockclip,j+1,</span>
<span class="lineNum">    3859 </span><span class="lineCov">          4 :                                               fendladdermountingblockclipmatrix[i][j]);</span>
<span class="lineNum">    3860 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3861 </span>            :   // End Ladder Lower Supports
<span class="lineNum">    3862 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3863 </span><span class="lineCov">          2 :   fendladdersegment[0]-&gt;AddNode(fcarbonfiberlowersupport[0],1,</span>
<span class="lineNum">    3864 </span><span class="lineCov">          1 :                                 fendladderlowersupptrans[0]);</span>
<span class="lineNum">    3865 </span><span class="lineCov">          2 :   fendladdersegment[1]-&gt;AddNode(fcarbonfiberlowersupport[0],2,</span>
<span class="lineNum">    3866 </span><span class="lineCov">          1 :                                 fendladderlowersupptrans[1]);</span>
<span class="lineNum">    3867 </span><span class="lineCov">          2 :   fendladdersegment[1]-&gt;AddNode(fcarbonfiberlowersupport[0],3,</span>
<span class="lineNum">    3868 </span><span class="lineCov">          1 :                                 fendladderlowersupptrans[2]);</span>
<span class="lineNum">    3869 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3870 </span>            :   // End Ladder Cooling Tube Support
<span class="lineNum">    3871 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3872 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;2; i++) </span>
<span class="lineNum">    3873 </span><span class="lineCov">         16 :         for(Int_t j=0; j&lt;(i==0?4:2); j++)   </span>
<span class="lineNum">    3874 </span><span class="lineCov">         12 :                 fendladdersegment[i]-&gt;AddNode(fcoolingtubesupport,j+1,</span>
<span class="lineNum">    3875 </span><span class="lineCov">          6 :                                               fendladdercoolingtubesupportmatrix[i][j]);</span>
<span class="lineNum">    3876 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3877 </span>            :   // End Ladder Cooling Tube Support
<span class="lineNum">    3878 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3879 </span><span class="lineCov">          1 :   fendladdersegment[0]-&gt;AddNode(fendladdercoolingtube[0],1,fendladdercoolingtubematrix[0][0]); </span>
<span class="lineNum">    3880 </span><span class="lineCov">          1 :   fendladdersegment[0]-&gt;AddNode(fendladdercoolingtube[0],2,fendladdercoolingtubematrix[0][1]);</span>
<span class="lineNum">    3881 </span><span class="lineCov">          1 :   fendladdersegment[1]-&gt;AddNode(fendladdercoolingtube[1],1,fendladdercoolingtubematrix[1][0]);</span>
<span class="lineNum">    3882 </span><span class="lineCov">          1 :   fendladdersegment[1]-&gt;AddNode(fendladdercoolingtube[1],2,fendladdercoolingtubematrix[1][1]); </span>
<span class="lineNum">    3883 </span>            : 
<span class="lineNum">    3884 </span><span class="lineCov">          1 :   fendladdersegment[0]-&gt;GetShape()-&gt;ComputeBBox(); //RS: enforce recompting of BBox</span>
<span class="lineNum">    3885 </span><span class="lineCov">          1 :   fendladdersegment[1]-&gt;GetShape()-&gt;ComputeBBox();</span>
<span class="lineNum">    3886 </span>            : 
<a name="3887"><span class="lineNum">    3887 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">    3888 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    3889 </span>            : void AliITSv11GeometrySSD::SetLadder(){
<span class="lineNum">    3890 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    3891 </span>            :   // Method Generating Ladder of Layer 5 and 6
<span class="lineNum">    3892 </span>            :   /////////////////////////////////////////////////////////////  
<span class="lineNum">    3893 </span><span class="lineCov">          2 :   Int_t ssdlaysensorsnumber[fgkladdernumber] = {fgkSSDLay5SensorsNumber,</span>
<span class="lineNum">    3894 </span>            :                                                                                                 fgkSSDLay6SensorsNumber};
<span class="lineNum">    3895 </span>            :   /////////////////////////////////////////////////////////////////////////////                                         
<span class="lineNum">    3896 </span>            :   /// Generating Ladder Mother Volume Containing Ladder 
<span class="lineNum">    3897 </span>            :   /////////////////////////////////////////////////////////////////////////////          
<span class="lineNum">    3898 </span>            :   /*  TGeoXtru* laddershape[fgkladdernumber];   
<span class="lineNum">    3899 </span>            :   for(Int_t i=0; i&lt;fgkladdernumber; i++) laddershape[i] = new TGeoXtru(2);
<span class="lineNum">    3900 </span>            :   */
<span class="lineNum">    3901 </span>            :   const Int_t kmothervertexnumber = 8;  
<span class="lineNum">    3902 </span><span class="lineCov">          1 :   Double_t xmothervertex[fgkladdernumber][kmothervertexnumber];</span>
<span class="lineNum">    3903 </span><span class="lineCov">          1 :   Double_t ymothervertex[fgkladdernumber][kmothervertexnumber];</span>
<span class="lineNum">    3904 </span>            :   ///////////////////////
<span class="lineNum">    3905 </span>            :   // Setting the vertices 
<span class="lineNum">    3906 </span>            :   ///////////////////////
<span class="lineNum">    3907 </span>            :   Double_t laddercablethickness = (fgkSSDLay6SensorsNumber+2)
<span class="lineNum">    3908 </span><span class="lineCov">          1 :                                                                 * (fgkSSDLadderCableHeight[0]+fgkSSDLadderCableHeight[1]);</span>
<span class="lineNum">    3909 </span><span class="lineCov">          1 :   xmothervertex[0][0] = -0.5*fgkSSDSensorWidth;</span>
<span class="lineNum">    3910 </span><span class="lineCov">          1 :   ymothervertex[0][0] = -0.5*fgkCoolingTubeSupportHeight-fgkSSDModuleCoolingBlockToSensor;</span>
<span class="lineNum">    3911 </span><span class="lineCov">          1 :   xmothervertex[0][1] = xmothervertex[0][0];</span>
<span class="lineNum">    3912 </span><span class="lineCov">          1 :   ymothervertex[0][1] = -0.5*fgkCoolingTubeSupportHeight; // 0.0; MvL 20-apr-2010</span>
<span class="lineNum">    3913 </span><span class="lineCov">          2 :   xmothervertex[0][2] = - 0.5*fgkSSDModuleSensorSupportDistance-2.*fgkCoolingTubeSupportRmax</span>
<span class="lineNum">    3914 </span><span class="lineCov">          1 :                                                 - laddercablethickness/SinD(2.*fgkSSDFlexAngle);</span>
<span class="lineNum">    3915 </span><span class="lineCov">          1 :   ymothervertex[0][2] = ymothervertex[0][1];</span>
<span class="lineNum">    3916 </span><span class="lineCov">          1 :   ymothervertex[0][3] = 0.5*fgkCarbonFiberTriangleLength*TanD(2.*fgkSSDFlexAngle);</span>
<span class="lineNum">    3917 </span><span class="lineCov">          1 :   xmothervertex[0][3] = xmothervertex[0][2]+ymothervertex[0][3]/TanD(2.*fgkSSDFlexAngle);               </span>
<span class="lineNum">    3918 </span><span class="lineCov">          1 :   xmothervertex[0][4] = -xmothervertex[0][3];</span>
<span class="lineNum">    3919 </span><span class="lineCov">          1 :   ymothervertex[0][4] = ymothervertex[0][3];</span>
<span class="lineNum">    3920 </span><span class="lineCov">          1 :   xmothervertex[0][5] = -xmothervertex[0][2];</span>
<span class="lineNum">    3921 </span><span class="lineCov">          1 :   ymothervertex[0][5] = ymothervertex[0][2];</span>
<span class="lineNum">    3922 </span><span class="lineCov">          1 :   xmothervertex[0][6] = -xmothervertex[0][1];</span>
<span class="lineNum">    3923 </span><span class="lineCov">          1 :   ymothervertex[0][6] = ymothervertex[0][1];</span>
<span class="lineNum">    3924 </span><span class="lineCov">          1 :   xmothervertex[0][7] = -xmothervertex[0][0];</span>
<span class="lineNum">    3925 </span><span class="lineCov">          1 :   ymothervertex[0][7] = ymothervertex[0][0];</span>
<span class="lineNum">    3926 </span><span class="lineCov">         18 :   for(Int_t i=0; i&lt;kmothervertexnumber; i++){</span>
<span class="lineNum">    3927 </span><span class="lineCov">          8 :         xmothervertex[1][i] = xmothervertex[0][i];</span>
<span class="lineNum">    3928 </span><span class="lineCov">          8 :         ymothervertex[1][i] = ymothervertex[0][i];</span>
<span class="lineNum">    3929 </span>            :   }
<span class="lineNum">    3930 </span>            : ///////////////////////////////////////////////////////////////////////////
<span class="lineNum">    3931 </span>            : // Disalignement Mother Volume corrections 25/08/08
<span class="lineNum">    3932 </span>            : ///////////////////////////////////////////////////////////////////////////
<span class="lineNum">    3933 </span><span class="lineCov">          1 :   TGeoXtru* leftladdershape1[fgkladdernumber];  </span>
<span class="lineNum">    3934 </span><span class="lineCov">          1 :   TGeoXtru* leftladdershape2[fgkladdernumber];  </span>
<span class="lineNum">    3935 </span><span class="lineCov">          1 :   TGeoXtru* centersensorladdershape[fgkladdernumber];   </span>
<span class="lineNum">    3936 </span><span class="lineCov">          1 :   TGeoXtru* rightladdershape1[fgkladdernumber]; </span>
<span class="lineNum">    3937 </span><span class="lineCov">          1 :   TGeoXtru* rightladdershape2[fgkladdernumber]; </span>
<span class="lineNum">    3938 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkladdernumber; i++){</span>
<span class="lineNum">    3939 </span><span class="lineCov">          4 :     leftladdershape1[i] = new TGeoXtru(2);</span>
<span class="lineNum">    3940 </span><span class="lineCov">          4 :     leftladdershape2[i] = new TGeoXtru(2);</span>
<span class="lineNum">    3941 </span><span class="lineCov">          4 :     centersensorladdershape[i] = new TGeoXtru(2);</span>
<span class="lineNum">    3942 </span><span class="lineCov">          4 :     rightladdershape1[i] = new TGeoXtru(2);</span>
<span class="lineNum">    3943 </span><span class="lineCov">          4 :     rightladdershape2[i] = new TGeoXtru(2);</span>
<span class="lineNum">    3944 </span>            :   }
<span class="lineNum">    3945 </span>            :   //////////////////////////////////////
<span class="lineNum">    3946 </span>            :   // Setting the names for shapes  
<span class="lineNum">    3947 </span>            :   //////////////////////////////////////
<span class="lineNum">    3948 </span><span class="lineCov">          1 :   leftladdershape1[0]-&gt;SetName(&quot;Lay5Left1LadderSegmentContainer&quot;);</span>
<span class="lineNum">    3949 </span><span class="lineCov">          1 :   leftladdershape2[0]-&gt;SetName(&quot;Lay5Left2LadderSegmentContainer&quot;);</span>
<span class="lineNum">    3950 </span><span class="lineCov">          1 :   leftladdershape1[1]-&gt;SetName(&quot;Lay6Left1LadderSegmentContainer&quot;);</span>
<span class="lineNum">    3951 </span><span class="lineCov">          1 :   leftladdershape2[1]-&gt;SetName(&quot;Lay6Left2LadderSegmentContainer&quot;);</span>
<span class="lineNum">    3952 </span><span class="lineCov">          1 :   centersensorladdershape[0]-&gt;SetName(&quot;Lay5CenterSensorContainer&quot;);</span>
<span class="lineNum">    3953 </span><span class="lineCov">          1 :   centersensorladdershape[1]-&gt;SetName(&quot;Lay6CenterSensorContainer&quot;);</span>
<span class="lineNum">    3954 </span><span class="lineCov">          1 :   rightladdershape1[0]-&gt;SetName(&quot;Lay5Right1LadderSegmentContainer&quot;);</span>
<span class="lineNum">    3955 </span><span class="lineCov">          1 :   rightladdershape2[0]-&gt;SetName(&quot;Lay5Right2LadderSegmentContainer&quot;);</span>
<span class="lineNum">    3956 </span><span class="lineCov">          1 :   rightladdershape1[1]-&gt;SetName(&quot;Lay6Right1LadderSegmentContainer&quot;);</span>
<span class="lineNum">    3957 </span><span class="lineCov">          1 :   rightladdershape2[1]-&gt;SetName(&quot;Lay6Right2LadderSegmentContainer&quot;);</span>
<span class="lineNum">    3958 </span>            :   //////////////////////////////////////
<span class="lineNum">    3959 </span><span class="lineCov">          1 :   Double_t xend1laddervertex[fgkladdernumber][kmothervertexnumber];</span>
<span class="lineNum">    3960 </span><span class="lineCov">          1 :   Double_t yend1laddervertex[fgkladdernumber][kmothervertexnumber];</span>
<span class="lineNum">    3961 </span><span class="lineCov">          1 :   Double_t xcentersensorvertex[fgkladdernumber][kmothervertexnumber];</span>
<span class="lineNum">    3962 </span><span class="lineCov">          1 :   Double_t ycentersensorvertex[fgkladdernumber][kmothervertexnumber];</span>
<span class="lineNum">    3963 </span><span class="lineCov">          1 :   Double_t xend2laddervertex[fgkladdernumber][kmothervertexnumber];</span>
<span class="lineNum">    3964 </span><span class="lineCov">          1 :   Double_t yend2laddervertex[fgkladdernumber][kmothervertexnumber];</span>
<span class="lineNum">    3965 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkladdernumber; i++) {</span>
<span class="lineNum">    3966 </span><span class="lineCov">         36 :     for(Int_t j=0; j&lt;kmothervertexnumber; j++){</span>
<span class="lineNum">    3967 </span><span class="lineCov">         16 :       xcentersensorvertex[i][j] = xmothervertex[i][j];</span>
<span class="lineNum">    3968 </span><span class="lineCov">         16 :       ycentersensorvertex[i][j] = ymothervertex[i][j];</span>
<span class="lineNum">    3969 </span><span class="lineCov">         16 :       xend1laddervertex[i][j] = xmothervertex[i][j];</span>
<span class="lineNum">    3970 </span><span class="lineCov">         16 :       yend1laddervertex[i][j] = ymothervertex[i][j];</span>
<span class="lineNum">    3971 </span><span class="lineCov">         16 :       xend2laddervertex[i][j] = xmothervertex[i][j];</span>
<span class="lineNum">    3972 </span><span class="lineCov">         16 :       yend2laddervertex[i][j] = ymothervertex[i][j];</span>
<span class="lineNum">    3973 </span>            :     }
<span class="lineNum">    3974 </span>            :     // Add some space around sensors to accommodate misalignments
<span class="lineNum">    3975 </span><span class="lineCov">          2 :     xcentersensorvertex[i][0] -= fgkSSDModuleSideDisalignment;  </span>
<span class="lineNum">    3976 </span><span class="lineCov">          2 :     xcentersensorvertex[i][1] =  xcentersensorvertex[0][0];</span>
<span class="lineNum">    3977 </span><span class="lineCov">          2 :     xcentersensorvertex[i][6] = -xcentersensorvertex[0][1];</span>
<span class="lineNum">    3978 </span><span class="lineCov">          2 :     xcentersensorvertex[i][7] = -xcentersensorvertex[0][0];</span>
<span class="lineNum">    3979 </span>            :     
<span class="lineNum">    3980 </span><span class="lineCov">          2 :     ycentersensorvertex[i][0] -= fgkSSDModuleVerticalDisalignment;      </span>
<span class="lineNum">    3981 </span><span class="lineCov">          2 :     ycentersensorvertex[i][7] = ycentersensorvertex[0][0];</span>
<span class="lineNum">    3982 </span>            :     
<span class="lineNum">    3983 </span>            :     // Center Ladder Piece
<span class="lineNum">    3984 </span><span class="lineCov">          4 :     centersensorladdershape[i]-&gt;DefinePolygon(kmothervertexnumber,xcentersensorvertex[i],</span>
<span class="lineNum">    3985 </span><span class="lineCov">          2 :                                               ycentersensorvertex[i]);</span>
<span class="lineNum">    3986 </span><span class="lineCov">          4 :     centersensorladdershape[i]-&gt;DefineSection(0, - fgkEndLadderCarbonFiberLowerJunctionLength[1]</span>
<span class="lineNum">    3987 </span><span class="lineCov">          2 :                                                  + 1.45*fgkSSDMountingBlockWidth);</span>
<span class="lineNum">    3988 </span><span class="lineCov">          4 :     centersensorladdershape[i]-&gt;DefineSection(1,   ssdlaysensorsnumber[i] * fgkCarbonFiberJunctionWidth</span>
<span class="lineNum">    3989 </span><span class="lineCov">          2 :                                                  + fgkEndLadderCarbonFiberLowerJunctionLength[0]</span>
<span class="lineNum">    3990 </span><span class="lineCov">          2 :                                                  - 2.4*fgkSSDMountingBlockWidth);</span>
<span class="lineNum">    3991 </span>            : 
<span class="lineNum">    3992 </span>            :     // Left and Right Ladder Pieces: Mother volumes around ladder mounting areas 
<span class="lineNum">    3993 </span>            : 
<span class="lineNum">    3994 </span>            :     // Cuts off first corner (neg x)
<span class="lineNum">    3995 </span><span class="lineCov">          2 :     xend1laddervertex[i][0] = -0.5*fgkSSDMountingBlockLength[0];</span>
<span class="lineNum">    3996 </span><span class="lineCov">          2 :     xend1laddervertex[i][1] = -0.5*fgkSSDMountingBlockLength[0];</span>
<span class="lineNum">    3997 </span>            :     // Cuts off last part (pos x)
<span class="lineNum">    3998 </span><span class="lineCov">          2 :     xend2laddervertex[i][6] = 0.5*fgkSSDMountingBlockLength[0];</span>
<span class="lineNum">    3999 </span><span class="lineCov">          2 :     xend2laddervertex[i][7] = 0.5*fgkSSDMountingBlockLength[0];</span>
<span class="lineNum">    4000 </span>            : 
<span class="lineNum">    4001 </span><span class="lineCov">          4 :     leftladdershape1[i]-&gt;DefinePolygon(kmothervertexnumber,xend1laddervertex[i],  </span>
<span class="lineNum">    4002 </span><span class="lineCov">          2 :                                        yend1laddervertex[i]);</span>
<span class="lineNum">    4003 </span><span class="lineCov">          2 :     leftladdershape1[i]-&gt;DefineSection(0,-fgkEndLadderCarbonFiberLowerJunctionLength[1]);</span>
<span class="lineNum">    4004 </span><span class="lineCov">          4 :     leftladdershape1[i]-&gt;DefineSection(1,  fendladdersegmentmatrix[0][i]-&gt;GetTranslation()[2]    </span>
<span class="lineNum">    4005 </span><span class="lineCov">          2 :                                          - fgkEndLadderMountingBlockPosition[0]);</span>
<span class="lineNum">    4006 </span>            :     
<span class="lineNum">    4007 </span><span class="lineCov">          4 :     leftladdershape2[i]-&gt;DefinePolygon(kmothervertexnumber,xend2laddervertex[i],  </span>
<span class="lineNum">    4008 </span><span class="lineCov">          2 :                                        yend2laddervertex[i]);</span>
<span class="lineNum">    4009 </span><span class="lineCov">          4 :     leftladdershape2[i]-&gt;DefineSection(0,  fendladdersegmentmatrix[0][i]-&gt;GetTranslation()[2]    </span>
<span class="lineNum">    4010 </span><span class="lineCov">          2 :                                          - fgkEndLadderMountingBlockPosition[0]); </span>
<span class="lineNum">    4011 </span><span class="lineCov">          4 :     leftladdershape2[i]-&gt;DefineSection(1,- fgkEndLadderCarbonFiberLowerJunctionLength[1] </span>
<span class="lineNum">    4012 </span><span class="lineCov">          2 :                                        + 1.45*fgkSSDMountingBlockWidth);  // connect to main volume at -1.6725 cm</span>
<span class="lineNum">    4013 </span>            : 
<span class="lineNum">    4014 </span><span class="lineCov">          2 :     rightladdershape1[i]-&gt;DefinePolygon(kmothervertexnumber,xend1laddervertex[i],</span>
<span class="lineNum">    4015 </span>            :                                         yend1laddervertex[i]);
<span class="lineNum">    4016 </span><span class="lineCov">          4 :     rightladdershape1[i]-&gt;DefineSection(0,ssdlaysensorsnumber[i]*fgkCarbonFiberJunctionWidth</span>
<span class="lineNum">    4017 </span><span class="lineCov">          2 :                                         +fgkEndLadderCarbonFiberLowerJunctionLength[0]</span>
<span class="lineNum">    4018 </span><span class="lineCov">          2 :                                         -2.4*fgkSSDMountingBlockWidth);</span>
<span class="lineNum">    4019 </span><span class="lineCov">          4 :     rightladdershape1[i]-&gt;DefineSection(1,fendladdersegmentmatrix[1][i]-&gt;GetTranslation()[2]</span>
<span class="lineNum">    4020 </span><span class="lineCov">          2 :                                         + fgkEndLadderMountingBlockPosition[1]);</span>
<span class="lineNum">    4021 </span>            : 
<span class="lineNum">    4022 </span><span class="lineCov">          2 :     rightladdershape2[i]-&gt;DefinePolygon(kmothervertexnumber,xend2laddervertex[i],</span>
<span class="lineNum">    4023 </span>            :                                         yend2laddervertex[i]);
<span class="lineNum">    4024 </span><span class="lineCov">          4 :     rightladdershape2[i]-&gt;DefineSection(0, fendladdersegmentmatrix[1][i]-&gt;GetTranslation()[2]</span>
<span class="lineNum">    4025 </span><span class="lineCov">          2 :                                            + fgkEndLadderMountingBlockPosition[1]);</span>
<span class="lineNum">    4026 </span><span class="lineCov">          4 :     rightladdershape2[i]-&gt;DefineSection(1,  ssdlaysensorsnumber[i]*fgkCarbonFiberJunctionWidth</span>
<span class="lineNum">    4027 </span><span class="lineCov">          2 :                                           + fgkEndLadderCarbonFiberLowerJunctionLength[0]);</span>
<span class="lineNum">    4028 </span>            :   }
<span class="lineNum">    4029 </span><span class="lineCov">          1 :   TGeoCompositeShape* laddershapecontainer[2];</span>
<span class="lineNum">    4030 </span><span class="lineCov">          2 :   laddershapecontainer[0] = new TGeoCompositeShape(&quot;Lay5LadderCompositeShape&quot;,</span>
<span class="lineNum">    4031 </span>            :                                                    &quot;Lay5Left1LadderSegmentContainer+Lay5Left2LadderSegmentContainer&quot;
<span class="lineNum">    4032 </span>            :                                                    &quot;+Lay5CenterSensorContainer&quot;
<span class="lineNum">    4033 </span>            :                                                    &quot;+Lay5Right1LadderSegmentContainer+Lay5Right2LadderSegmentContainer&quot;);
<span class="lineNum">    4034 </span><span class="lineCov">          2 :   laddershapecontainer[1] = new TGeoCompositeShape(&quot;Lay6LadderCompositeShape&quot;,</span>
<span class="lineNum">    4035 </span>            :                                                    &quot;Lay6Left1LadderSegmentContainer+Lay6Left2LadderSegmentContainer&quot;
<span class="lineNum">    4036 </span>            :                                                    &quot;+Lay6CenterSensorContainer&quot;
<span class="lineNum">    4037 </span>            :                                                    &quot;+Lay6Right1LadderSegmentContainer+Lay6Right2LadderSegmentContainer&quot;);
<span class="lineNum">    4038 </span><span class="lineCov">          1 :   const char* laddername[fgkladdernumber] = {&quot;ITSssdLay5Ladd&quot;,&quot;ITSssdLay6Ladd&quot;};</span>
<span class="lineNum">    4039 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkladdernumber; i++){</span>
<span class="lineNum">    4040 </span><span class="lineCov">          4 :     fladder[i] = new TGeoVolume(laddername[i],laddershapecontainer[i],fSSDAir);</span>
<span class="lineNum">    4041 </span><span class="lineCov">          2 :     fladder[i]-&gt;SetLineColor(4);</span>
<span class="lineNum">    4042 </span>            :   }
<span class="lineNum">    4043 </span>            : ///////////////////////////////////////////////////////////////////////////
<span class="lineNum">    4044 </span><span class="lineCov">          1 :  if(!fCreateMaterials) CreateMaterials();</span>
<span class="lineNum">    4045 </span><span class="lineCov">          1 :  if(!fTransformationMatrices) CreateTransformationMatrices();</span>
<span class="lineNum">    4046 </span><span class="lineCov">          1 :  if(!fBasicObjects) CreateBasicObjects();</span>
<span class="lineNum">    4047 </span><span class="lineCov">          1 :  SetLadderSegment(); </span>
<span class="lineNum">    4048 </span><span class="lineCov">          1 :  SetEndLadderSegment();</span>
<span class="lineNum">    4049 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkladdernumber; i++){</span>
<span class="lineNum">    4050 </span><span class="lineCov">         98 :         for(Int_t j=0; j&lt;ssdlaysensorsnumber[i]; j++){</span>
<span class="lineNum">    4051 </span>            :         //////////////////////////                                              
<span class="lineNum">    4052 </span>            :         /// Placing Ladder Segment
<span class="lineNum">    4053 </span>            :         //////////////////////////              
<span class="lineNum">    4054 </span><span class="lineCov">        188 :                 fladder[i]-&gt;AddNode(j%2==0 ? fladdersegment[i==0 ? 0 : 1] :</span>
<span class="lineNum">    4055 </span><span class="lineCov">         23 :                                                                      fladdersegment[i==0 ? 1 : 0],</span>
<span class="lineNum">    4056 </span><span class="lineCov">         47 :                                                                          ssdlaysensorsnumber[i]-j-1,fladdermatrix[i][j]);</span>
<span class="lineNum">    4057 </span>            :         //////////////////////////                                              
<span class="lineNum">    4058 </span>            :         /// Placing SSD Sensor
<span class="lineNum">    4059 </span>            :         //////////////////////////              
<span class="lineNum">    4060 </span><span class="lineCov">         70 :         if(i==0&amp;&amp;ssdlaysensorsnumber[i]-j-1==13) fSSDSensor5-&gt;SetLineColor(kRed);</span>
<span class="lineNum">    4061 </span><span class="lineCov">        188 :                 fladder[i]-&gt;AddNode(i==0?fSSDSensor5:fSSDSensor6,ssdlaysensorsnumber[i]-j-1,</span>
<span class="lineNum">    4062 </span><span class="lineCov">         47 :                                                         fssdsensormatrix[i][j]);</span>
<span class="lineNum">    4063 </span>            :         }
<span class="lineNum">    4064 </span>            :         ///////////////////////////////                                         
<span class="lineNum">    4065 </span>            :         /// Placing End Ladder Segment
<span class="lineNum">    4066 </span>            :         ///////////////////////////////         
<span class="lineNum">    4067 </span><span class="lineCov">          2 :         fladder[i]-&gt;AddNode(fendladdersegment[0],1,fendladdersegmentmatrix[0][i]);</span>
<span class="lineNum">    4068 </span><span class="lineCov">          2 :         fladder[i]-&gt;AddNode(fendladdersegment[1],1,fendladdersegmentmatrix[1][i]);</span>
<span class="lineNum">    4069 </span>            :    }
<span class="lineNum">    4070 </span>            : /////////////////////////////////////////////////////////////////////////////                                           
<span class="lineNum">    4071 </span>            : /// Placing Ladder Cables
<span class="lineNum">    4072 </span>            : /////////////////////////////////////////////////////////////////////////////           
<span class="lineNum">    4073 </span><span class="lineCov">          1 :   Int_t sidecablenumber[2][2];</span>
<span class="lineNum">    4074 </span><span class="lineCov">          1 :   sidecablenumber[0][0] = fgkSSDLay5SensorsNumber/2+1; </span>
<span class="lineNum">    4075 </span><span class="lineCov">          1 :   sidecablenumber[0][1] = sidecablenumber[0][0]-2;</span>
<span class="lineNum">    4076 </span><span class="lineCov">          1 :   sidecablenumber[1][0] = (fgkSSDLay6SensorsNumber-1)/2+1;</span>
<span class="lineNum">    4077 </span><span class="lineCov">          1 :   sidecablenumber[1][1] = sidecablenumber[1][0]-1;</span>
<span class="lineNum">    4078 </span>            :   Double_t carbonfibertomoduleposition[3];
<span class="lineNum">    4079 </span><span class="lineCov">          1 :   carbonfibertomoduleposition[0] = -0.5*(fgkSSDSensorWidth-fgkCarbonFiberTriangleLength);</span>
<span class="lineNum">    4080 </span><span class="lineCov">          2 :   carbonfibertomoduleposition[1] = - (2.*fgkSSDSensorLength-fgkSSDSensorOverlap)+</span>
<span class="lineNum">    4081 </span><span class="lineCov">          2 :                          fgkSSDModuleStiffenerPosition[1]+fgkSSDStiffenerWidth</span>
<span class="lineNum">    4082 </span><span class="lineCov">          1 :          +               0.5*fgkSSDFlexHoleLength+2.*fgkCarbonFiberJunctionWidth</span>
<span class="lineNum">    4083 </span><span class="lineCov">          2 :          -               0.5*(fgkCarbonFiberLowerSupportWidth+fgkSSDSensorCenterSupportLength</span>
<span class="lineNum">    4084 </span><span class="lineCov">          1 :          -            fgkSSDSensorCenterSupportThickness[0]);</span>
<span class="lineNum">    4085 </span><span class="lineCov">          1 :   carbonfibertomoduleposition[2] = - (fgkSSDModuleCoolingBlockToSensor</span>
<span class="lineNum">    4086 </span><span class="lineCov">          1 :                                                                  +   0.5*fgkCoolingTubeSupportHeight</span>
<span class="lineNum">    4087 </span><span class="lineCov">          1 :          -         fgkSSDSensorHeight-fgkSSDChipCablesHeight[3]-fgkSSDChipHeight);      </span>
<span class="lineNum">    4088 </span><span class="lineCov">          1 :   const Double_t kendladdercablecorrection = 1.72*fgkmm; //this has to be tuned</span>
<span class="lineNum">    4089 </span><span class="lineCov">          1 :   Double_t ssdendladdercablelength[4];</span>
<span class="lineNum">    4090 </span><span class="lineCov">          1 :   ssdendladdercablelength[0] = carbonfibertomoduleposition[1]</span>
<span class="lineNum">    4091 </span><span class="lineCov">          1 :                                                          + fgkSSDSensorLength</span>
<span class="lineNum">    4092 </span><span class="lineCov">          1 :                                                          - fgkSSDModuleStiffenerPosition[1]</span>
<span class="lineNum">    4093 </span><span class="lineCov">          1 :                                                          - fgkSSDStiffenerWidth </span>
<span class="lineNum">    4094 </span><span class="lineCov">          1 :                                                          - fgkSSDFlexWidth[0]</span>
<span class="lineNum">    4095 </span><span class="lineCov">          1 :                                                          + fgkEndLadderCarbonFiberLowerJunctionLength[1]-0.000001*kendladdercablecorrection;</span>
<span class="lineNum">    4096 </span><span class="lineCov">          1 :   ssdendladdercablelength[1] = carbonfibertomoduleposition[1]</span>
<span class="lineNum">    4097 </span><span class="lineCov">          1 :                                                          + fgkSSDModuleStiffenerPosition[1]</span>
<span class="lineNum">    4098 </span><span class="lineCov">          1 :                                                          + fgkSSDStiffenerWidth</span>
<span class="lineNum">    4099 </span><span class="lineCov">          1 :                                                          + fgkEndLadderCarbonFiberLowerJunctionLength[1]-0.000001*kendladdercablecorrection;</span>
<span class="lineNum">    4100 </span><span class="lineCov">          1 :   ssdendladdercablelength[2] = ssdendladdercablelength[1]</span>
<span class="lineNum">    4101 </span><span class="lineCov">          1 :                                                          - fgkEndLadderCarbonFiberLowerJunctionLength[1]</span>
<span class="lineNum">    4102 </span><span class="lineCov">          1 :                                                          + fgkEndLadderCarbonFiberLowerJunctionLength[0]</span>
<span class="lineNum">    4103 </span><span class="lineCov">          1 :                                                          - kendladdercablecorrection;</span>
<span class="lineNum">    4104 </span><span class="lineCov">          3 :   ssdendladdercablelength[3] = fgkCarbonFiberJunctionWidth-(fgkSSDSensorLength</span>
<span class="lineNum">    4105 </span><span class="lineCov">          1 :                                                          + carbonfibertomoduleposition[1]</span>
<span class="lineNum">    4106 </span><span class="lineCov">          1 :                                                          - fgkSSDModuleStiffenerPosition[1]</span>
<span class="lineNum">    4107 </span><span class="lineCov">          1 :                                                          - fgkSSDStiffenerWidth)</span>
<span class="lineNum">    4108 </span><span class="lineCov">          1 :                                                          + fgkEndLadderCarbonFiberLowerJunctionLength[0]-0.000001*kendladdercablecorrection;</span>
<span class="lineNum">    4109 </span>            : 
<span class="lineNum">    4110 </span><span class="lineCov">          1 :   TList* laddercableassemblylist[4];</span>
<span class="lineNum">    4111 </span>            :   const Int_t kendladdercablesnumber = 4;
<span class="lineNum">    4112 </span><span class="lineCov">          1 :   TGeoRotation *laddercablerot = new TGeoRotation();</span>
<span class="lineNum">    4113 </span><span class="lineCov">          1 :   laddercablerot-&gt;SetAngles(90.,60.,-90.);</span>
<span class="lineNum">    4114 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgkladdercablesnumber; i++)</span>
<span class="lineNum">    4115 </span><span class="lineCov">         20 :         for(Int_t j=0; j&lt;kendladdercablesnumber; j++){</span>
<span class="lineNum">    4116 </span><span class="lineCov">          8 :                 laddercableassemblylist[j] = </span>
<span class="lineNum">    4117 </span><span class="lineCov">         16 :                 GetLadderCableAssemblyList(sidecablenumber[i][j&lt;2?0:1],</span>
<span class="lineNum">    4118 </span><span class="lineCov">          8 :                                                                    ssdendladdercablelength[j]);</span>
<span class="lineNum">    4119 </span><span class="lineCov">         16 :                         fladder[i]-&gt;AddNode((TGeoVolume*)laddercableassemblylist[j]-&gt;At(j%2==0?0:1),</span>
<span class="lineNum">    4120 </span><span class="lineCov">          8 :                                                                         j&lt;2?1:2,fladdercablematrix[i][j]);</span>
<span class="lineNum">    4121 </span>            :   }
<span class="lineNum">    4122 </span><span class="lineCov">          1 : }</span>
<a name="4123"><span class="lineNum">    4123 </span>            : </a>
<span class="lineNum">    4124 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    4125 </span>            : void AliITSv11GeometrySSD::SetLayer(){
<span class="lineNum">    4126 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    4127 </span>            :   // Creating Ladder of Layer 5 and Layer 6
<span class="lineNum">    4128 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    4129 </span><span class="lineCov">          3 :   if(!fCreateMaterials) CreateMaterials();</span>
<span class="lineNum">    4130 </span><span class="lineCov">          2 :   if(!fTransformationMatrices) CreateTransformationMatrices();</span>
<span class="lineNum">    4131 </span><span class="lineCov">          2 :   if(!fBasicObjects) CreateBasicObjects();</span>
<span class="lineNum">    4132 </span><span class="lineCov">          1 :   SetLadder(); // Generating the ladder of Layer5 and Layer6</span>
<span class="lineNum">    4133 </span>            :   const Int_t kssdlayladdernumber[fgklayernumber] = 
<span class="lineNum">    4134 </span>            :                         {fgkSSDLay5LadderNumber,fgkSSDLay6LadderNumber};
<span class="lineNum">    4135 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    4136 </span>            :   // Generating mother volumes for Layer5 and Layer6
<span class="lineNum">    4137 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    4138 </span><span class="lineCov">          2 :   fSSDLayer5 = new TGeoVolumeAssembly(&quot;ITSssdLayer5&quot;);  </span>
<span class="lineNum">    4139 </span><span class="lineCov">          2 :   fSSDLayer6 = new TGeoVolumeAssembly(&quot;ITSssdLayer6&quot;);  </span>
<span class="lineNum">    4140 </span><span class="lineCov">          1 :   Int_t *ladderindex[fgklayernumber];</span>
<span class="lineNum">    4141 </span><span class="lineCov">          1 :   Int_t index[fgklayernumber] = {8,9};</span>
<span class="lineNum">    4142 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++) ladderindex[i] = new Int_t[kssdlayladdernumber[i]];</span>
<span class="lineNum">    4143 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++)      </span>
<span class="lineNum">    4144 </span><span class="lineCov">        148 :         for(Int_t j=0; j&lt;kssdlayladdernumber[i]; j++){</span>
<span class="lineNum">    4145 </span><span class="lineCov">        288 :                 ladderindex[i][j] = ((j&gt;=0)&amp;&amp;(j&lt;=kssdlayladdernumber[i]-index[i]-1)) ? </span>
<span class="lineNum">    4146 </span><span class="lineCov">         72 :                                                           j+index[i] : j+index[i]-kssdlayladdernumber[i]; </span>
<span class="lineNum">    4147 </span><span class="lineCov">        144 :                 i ==0 ? fSSDLayer5-&gt;AddNode(fladder[0],ladderindex[i][j],flayermatrix[i][j]) : </span>
<span class="lineNum">    4148 </span><span class="lineCov">         38 :                         fSSDLayer6-&gt;AddNode(fladder[1],ladderindex[i][j],flayermatrix[i][j]);</span>
<span class="lineNum">    4149 </span>            :         }
<span class="lineNum">    4150 </span>            : 
<span class="lineNum">    4151 </span><span class="lineCov">          1 :   fSSDLayer5-&gt;GetShape()-&gt;ComputeBBox(); //RS: enforce recompting of BBox</span>
<span class="lineNum">    4152 </span><span class="lineCov">          1 :   fSSDLayer6-&gt;GetShape()-&gt;ComputeBBox();</span>
<span class="lineNum">    4153 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    4154 </span>            :   // Deallocating memory
<span class="lineNum">    4155 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    4156 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;fgklayernumber; i++) delete [] ladderindex[i];</span>
<a name="4157"><span class="lineNum">    4157 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">    4158 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    4159 </span>            : void AliITSv11GeometrySSD::Layer5(TGeoVolume* moth){
<span class="lineNum">    4160 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    4161 </span>            :   // Insert the layer 5 in the mother volume. 
<span class="lineNum">    4162 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    4163 </span><span class="lineCov">          2 :   if (! moth) {</span>
<span class="lineNum">    4164 </span><span class="lineNoCov">          0 :     AliError(&quot;Can't insert layer5, mother is null!\n&quot;);</span>
<span class="lineNum">    4165 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    4166 </span>            :   };
<span class="lineNum">    4167 </span><span class="lineCov">          2 :   if(!fSSDLayer5) SetLayer();</span>
<span class="lineNum">    4168 </span><span class="lineCov">          1 :   fMotherVol = moth;</span>
<span class="lineNum">    4169 </span><span class="lineCov">          2 :   TGeoTranslation* centerITSlayer5trans = new TGeoTranslation(0.,0.,-0.5*fgkSSDLay5LadderLength</span>
<span class="lineNum">    4170 </span><span class="lineCov">          1 :                                                                                 + fgkLay5CenterITSPosition);</span>
<span class="lineNum">    4171 </span><span class="lineCov">          1 :   moth-&gt;AddNode(fSSDLayer5,1,centerITSlayer5trans);</span>
<a name="4172"><span class="lineNum">    4172 </span><span class="lineCov">          2 :  }</span></a>
<span class="lineNum">    4173 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    4174 </span>            : void AliITSv11GeometrySSD::Layer6(TGeoVolume* moth){
<span class="lineNum">    4175 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    4176 </span>            :   // Insert the layer 6 in the mother volume. 
<span class="lineNum">    4177 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    4178 </span><span class="lineCov">          2 :   if (! moth) {</span>
<span class="lineNum">    4179 </span><span class="lineNoCov">          0 :     AliError(&quot;AliITSv11GeometrySSD: Can't insert layer6, mother is null!\n&quot;);</span>
<span class="lineNum">    4180 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    4181 </span>            :   };
<span class="lineNum">    4182 </span><span class="lineCov">          1 :   if(!fSSDLayer6) SetLayer();</span>
<span class="lineNum">    4183 </span><span class="lineCov">          1 :   fMotherVol = moth;</span>
<span class="lineNum">    4184 </span><span class="lineCov">          2 :   TGeoTranslation* centerITSlayer6trans = new TGeoTranslation(0.,0.,-0.5*fgkSSDLay6LadderLength</span>
<span class="lineNum">    4185 </span><span class="lineCov">          1 :                                                                                 + fgkLay6CenterITSPosition);</span>
<span class="lineNum">    4186 </span><span class="lineCov">          1 :   moth-&gt;AddNode(fSSDLayer6,1,centerITSlayer6trans);</span>
<a name="4187"><span class="lineNum">    4187 </span><span class="lineCov">          2 :  }</span></a>
<span class="lineNum">    4188 </span>            :  ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    4189 </span>            :  TList* AliITSv11GeometrySSD::GetMountingBlockSupport(Int_t nedges){
<span class="lineNum">    4190 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    4191 </span>            :   // Method generating the Arc structure of Ladder Support 
<span class="lineNum">    4192 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    4193 </span>            :   const Int_t kssdlayladdernumber[fgklayernumber] = 
<span class="lineNum">    4194 </span>            :                         {fgkSSDLay5LadderNumber,fgkSSDLay6LadderNumber};
<span class="lineNum">    4195 </span><span class="lineCov">          2 :   Double_t mountingsupportedge[fgklayernumber];</span>
<span class="lineNum">    4196 </span><span class="lineCov">          1 :   Double_t mountingblockratio[fgklayernumber];</span>
<span class="lineNum">    4197 </span><span class="lineCov">          1 :   Double_t theta[fgklayernumber];</span>
<span class="lineNum">    4198 </span><span class="lineCov">          1 :   Double_t phi[fgklayernumber];</span>
<span class="lineNum">    4199 </span><span class="lineCov">          1 :   Double_t psi0[fgklayernumber];</span>
<span class="lineNum">    4200 </span><span class="lineCov">          1 :   Double_t deltapsi[fgklayernumber];</span>
<span class="lineNum">    4201 </span><span class="lineCov">          1 :   TVector3* mountingsupportedgevector[fgklayernumber];</span>
<span class="lineNum">    4202 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++){</span>
<span class="lineNum">    4203 </span><span class="lineCov">          2 :         mountingblockratio[i] = fgkSSDMountingBlockLength[0]/fgkMountingBlockSupportRadius[i];</span>
<span class="lineNum">    4204 </span><span class="lineCov">          4 :     mountingsupportedge[i]    = 0.5*fgkMountingBlockSupportRadius[i]</span>
<span class="lineNum">    4205 </span><span class="lineCov">          4 :                                                           * (TMath::Sqrt((2.-mountingblockratio[i])*(2.+mountingblockratio[i]))</span>
<span class="lineNum">    4206 </span><span class="lineCov">          2 :                                                           * TMath::Sin(2.0*TMath::Pi()/kssdlayladdernumber[i])</span>
<span class="lineNum">    4207 </span><span class="lineCov">          4 :                                                           - mountingblockratio[i]*(1.0+TMath::Cos(2.0*TMath::Pi()</span>
<span class="lineNum">    4208 </span><span class="lineCov">          2 :                                                           / kssdlayladdernumber[i])));</span>
<span class="lineNum">    4209 </span><span class="lineCov">          2 :     theta[i] = TMath::ASin(0.5*mountingblockratio[i]+mountingsupportedge[i]/fgkMountingBlockSupportRadius[i]);</span>
<span class="lineNum">    4210 </span><span class="lineCov">          2 :     phi[i]   = TMath::ASin(0.5*mountingblockratio[i]);</span>
<span class="lineNum">    4211 </span><span class="lineCov">          4 :         mountingsupportedgevector[i] = new TVector3();</span>
<span class="lineNum">    4212 </span><span class="lineCov">          2 :         mountingsupportedgevector[i]-&gt;SetX(-0.5*fgkSSDMountingBlockLength[0]);</span>
<span class="lineNum">    4213 </span><span class="lineCov">          4 :         mountingsupportedgevector[i]-&gt;SetY(fgkMountingBlockSupportRadius[i]*TMath::Sqrt(</span>
<span class="lineNum">    4214 </span><span class="lineCov">          4 :                                                         (1.-mountingsupportedgevector[i]-&gt;X()/fgkMountingBlockSupportRadius[i])*</span>
<span class="lineNum">    4215 </span><span class="lineCov">          2 :                                                         (1.+mountingsupportedgevector[i]-&gt;X()/fgkMountingBlockSupportRadius[i])));</span>
<span class="lineNum">    4216 </span><span class="lineCov">          2 :     psi0[i] = 0.5*TMath::Pi()-phi[i];   </span>
<span class="lineNum">    4217 </span><span class="lineCov">          2 :     deltapsi[i] = (theta[i]+phi[i])/nedges;</span>
<span class="lineNum">    4218 </span>            :   }
<span class="lineNum">    4219 </span><span class="lineCov">          1 :   TVector3** vertex[fgklayernumber];</span>
<span class="lineNum">    4220 </span><span class="lineCov">          1 :   TList* vertexlist[fgklayernumber];</span>
<span class="lineNum">    4221 </span><span class="lineCov">          1 :   Int_t indexedge[fgklayernumber] = {0,0};</span>
<span class="lineNum">    4222 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++){</span>
<span class="lineNum">    4223 </span><span class="lineCov">          2 :         vertex[i] = new TVector3*[nedges+1];</span>
<span class="lineNum">    4224 </span><span class="lineCov">          4 :         vertexlist[i] = new TList();</span>
<span class="lineNum">    4225 </span>            :   } 
<span class="lineNum">    4226 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++){</span>
<span class="lineNum">    4227 </span><span class="lineCov">         88 :         for(Int_t j=0; j&lt;nedges+1; j++){</span>
<span class="lineNum">    4228 </span><span class="lineCov">        126 :                 vertex[i][j] = new TVector3(fgkMountingBlockSupportRadius[i]*TMath::Cos(psi0[i]+j*deltapsi[i]),</span>
<span class="lineNum">    4229 </span><span class="lineCov">         42 :                                             fgkMountingBlockSupportRadius[i]*TMath::Sin(psi0[i]+j*deltapsi[i]), 0);</span>
<span class="lineNum">    4230 </span><span class="lineCov">         78 :                 if(vertex[i][j]-&gt;X()&gt;mountingsupportedgevector[i]-&gt;X()) indexedge[i]++;</span>
<span class="lineNum">    4231 </span><span class="lineCov">         42 :                 vertexlist[i]-&gt;Add(vertex[i][j]);</span>
<span class="lineNum">    4232 </span>            :         }
<span class="lineNum">    4233 </span><span class="lineCov">          2 :         vertexlist[i]-&gt;AddAt(mountingsupportedgevector[i],indexedge[i]);</span>
<span class="lineNum">    4234 </span>            :   }
<span class="lineNum">    4235 </span><span class="lineCov">          1 :   Double_t** xsidevertex = new Double_t*[fgklayernumber]; </span>
<span class="lineNum">    4236 </span><span class="lineCov">          1 :   Double_t** ysidevertex = new Double_t*[fgklayernumber]; </span>
<span class="lineNum">    4237 </span><span class="lineCov">          1 :   Double_t** xcentervertex = new Double_t*[fgklayernumber]; </span>
<span class="lineNum">    4238 </span><span class="lineCov">          1 :   Double_t** ycentervertex = new Double_t*[fgklayernumber]; </span>
<span class="lineNum">    4239 </span><span class="lineCov">          1 :   Double_t** xsidelowervertex = new Double_t*[fgklayernumber];</span>
<span class="lineNum">    4240 </span><span class="lineCov">          1 :   Double_t** ysidelowervertex = new Double_t*[fgklayernumber];  </span>
<span class="lineNum">    4241 </span><span class="lineCov">          1 :   Double_t** xcenterlowervertex = new Double_t*[fgklayernumber];</span>
<span class="lineNum">    4242 </span><span class="lineCov">          1 :   Double_t** ycenterlowervertex = new Double_t*[fgklayernumber];  </span>
<span class="lineNum">    4243 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++){</span>
<span class="lineNum">    4244 </span><span class="lineCov">          2 :     xsidevertex[i] = new Double_t[vertexlist[i]-&gt;GetSize()+2];</span>
<span class="lineNum">    4245 </span><span class="lineCov">          2 :     ysidevertex[i] = new Double_t[vertexlist[i]-&gt;GetSize()+2];</span>
<span class="lineNum">    4246 </span><span class="lineCov">          2 :     xcentervertex[i] = new Double_t[indexedge[i]+3];</span>
<span class="lineNum">    4247 </span><span class="lineCov">          2 :     ycentervertex[i] = new Double_t[indexedge[i]+3];</span>
<span class="lineNum">    4248 </span><span class="lineCov">          2 :         xsidelowervertex[i] = new Double_t[vertexlist[i]-&gt;GetSize()+1];</span>
<span class="lineNum">    4249 </span><span class="lineCov">          2 :         ysidelowervertex[i] = new Double_t[vertexlist[i]-&gt;GetSize()+1];</span>
<span class="lineNum">    4250 </span><span class="lineCov">          2 :         xcenterlowervertex[i] = new Double_t[indexedge[i]+3];</span>
<span class="lineNum">    4251 </span><span class="lineCov">          2 :         ycenterlowervertex[i] = new Double_t[indexedge[i]+3];</span>
<span class="lineNum">    4252 </span><span class="lineCov">         92 :         for(Int_t j=0; j&lt;vertexlist[i]-&gt;GetSize(); j++){</span>
<span class="lineNum">    4253 </span><span class="lineCov">         44 :                 xsidevertex[i][j!=vertexlist[i]-&gt;GetSize()-1?j+3:0] = </span>
<span class="lineNum">    4254 </span><span class="lineCov">         44 :                                                                                 ((TVector3*)vertexlist[i]-&gt;At(j))-&gt;X();</span>
<span class="lineNum">    4255 </span><span class="lineCov">         44 :                 ysidevertex[i][j!=vertexlist[i]-&gt;GetSize()-1?j+3:0] = </span>
<span class="lineNum">    4256 </span><span class="lineCov">         44 :                                                                                 ((TVector3*)vertexlist[i]-&gt;At(j))-&gt;Y();</span>
<span class="lineNum">    4257 </span><span class="lineCov">         44 :                 xsidelowervertex[i][j] = ((TVector3*)vertexlist[i]-&gt;At(vertexlist[i]-&gt;GetSize()-1-j))-&gt;X();</span>
<span class="lineNum">    4258 </span><span class="lineCov">         44 :                 ysidelowervertex[i][j] = ((TVector3*)vertexlist[i]-&gt;At(vertexlist[i]-&gt;GetSize()-1-j))-&gt;Y();</span>
<span class="lineNum">    4259 </span><span class="lineCov">         44 :                 if(j&lt;indexedge[i]+1){</span>
<span class="lineNum">    4260 </span><span class="lineCov">         38 :                         xcentervertex[i][j!=indexedge[i]?j+3:0] = </span>
<span class="lineNum">    4261 </span><span class="lineCov">         38 :                                                                                 ((TVector3*)vertexlist[i]-&gt;At(j))-&gt;X();</span>
<span class="lineNum">    4262 </span><span class="lineCov">         38 :                         ycentervertex[i][j!=indexedge[i]?j+3:0] = </span>
<span class="lineNum">    4263 </span><span class="lineCov">         38 :                                                                                 ((TVector3*)vertexlist[i]-&gt;At(j))-&gt;Y();</span>
<span class="lineNum">    4264 </span><span class="lineCov">         38 :                         xcenterlowervertex[i][j+1] = ((TVector3*)vertexlist[i]-&gt;At(indexedge[i]-j))-&gt;X();</span>
<span class="lineNum">    4265 </span><span class="lineCov">         38 :                         ycenterlowervertex[i][j+1] = ((TVector3*)vertexlist[i]-&gt;At(indexedge[i]-j))-&gt;Y();</span>
<span class="lineNum">    4266 </span><span class="lineCov">         38 :                 }</span>
<span class="lineNum">    4267 </span>            :         }
<span class="lineNum">    4268 </span><span class="lineCov">          2 :         xsidevertex[i][1] = xsidevertex[i][0]; </span>
<span class="lineNum">    4269 </span><span class="lineCov">          2 :         ysidevertex[i][1] = fgkMountingBlockSupportRadius[i]; </span>
<span class="lineNum">    4270 </span><span class="lineCov">          2 :         xsidevertex[i][2] = xsidevertex[i][3]; </span>
<span class="lineNum">    4271 </span><span class="lineCov">          2 :         ysidevertex[i][2] = fgkMountingBlockSupportRadius[i]; </span>
<span class="lineNum">    4272 </span><span class="lineCov">          2 :         xcentervertex[i][1] = xcentervertex[i][0]; </span>
<span class="lineNum">    4273 </span><span class="lineCov">          2 :         ycentervertex[i][1] = fgkMountingBlockSupportRadius[i]; </span>
<span class="lineNum">    4274 </span><span class="lineCov">          2 :         xcentervertex[i][2] = xcentervertex[i][3]; </span>
<span class="lineNum">    4275 </span><span class="lineCov">          2 :         ycentervertex[i][2] = fgkMountingBlockSupportRadius[i]; </span>
<span class="lineNum">    4276 </span><span class="lineCov">          2 :         xsidelowervertex[i][vertexlist[i]-&gt;GetSize()] = xsidelowervertex[i][vertexlist[i]-&gt;GetSize()-1];</span>
<span class="lineNum">    4277 </span><span class="lineCov">          2 :         ysidelowervertex[i][vertexlist[i]-&gt;GetSize()] = ysidelowervertex[i][0];</span>
<span class="lineNum">    4278 </span><span class="lineCov">          2 :         xcenterlowervertex[i][0] = xcenterlowervertex[i][1];</span>
<span class="lineNum">    4279 </span><span class="lineCov">          2 :         ycenterlowervertex[i][0] = ysidevertex[i][0];</span>
<span class="lineNum">    4280 </span><span class="lineCov">          2 :         xcenterlowervertex[i][indexedge[i]+2] = xsidelowervertex[i][vertexlist[i]-&gt;GetSize()];</span>
<span class="lineNum">    4281 </span><span class="lineCov">          2 :         ycenterlowervertex[i][indexedge[i]+2] = ycenterlowervertex[i][0];</span>
<span class="lineNum">    4282 </span>            :   }
<span class="lineNum">    4283 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    4284 </span>            :   // Building the Arc Structure of Ladder Supports 
<span class="lineNum">    4285 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    4286 </span><span class="lineCov">          1 :   TGeoXtru* sidemountingblocksupportshape[fgklayernumber];</span>
<span class="lineNum">    4287 </span><span class="lineCov">          1 :   TGeoXtru* centermountingsupportshape[fgklayernumber];</span>
<span class="lineNum">    4288 </span><span class="lineCov">          1 :   TGeoXtru* sideladdersupportpieceshape[fgklayernumber];</span>
<span class="lineNum">    4289 </span><span class="lineCov">          1 :   TGeoXtru* centerladdersupportpieceshape[fgklayernumber];</span>
<span class="lineNum">    4290 </span><span class="lineCov">          1 :   TGeoVolume* sidemountingblocksupport[fgklayernumber];</span>
<span class="lineNum">    4291 </span><span class="lineCov">          1 :   TGeoVolume* centermountingblocksupport[fgklayernumber];</span>
<span class="lineNum">    4292 </span><span class="lineCov">          1 :   TGeoVolume* sideladdersupportpiece[fgklayernumber];</span>
<span class="lineNum">    4293 </span><span class="lineCov">          1 :   TGeoVolume* centerladdersupportpiece[fgklayernumber];</span>
<span class="lineNum">    4294 </span><span class="lineCov">          1 :   char sidemountingblockname[100];</span>
<span class="lineNum">    4295 </span><span class="lineCov">          1 :   char centermountingblockname[100];</span>
<span class="lineNum">    4296 </span><span class="lineCov">          1 :   char sideladdersupportpiecename[100];</span>
<span class="lineNum">    4297 </span><span class="lineCov">          1 :   char centerladdersupportpiecename[100];</span>
<span class="lineNum">    4298 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++){ </span>
<span class="lineNum">    4299 </span><span class="lineCov">          2 :     snprintf(sidemountingblockname,100,&quot;MountingBlockSupportSideLay%dArc&quot;,i+5);</span>
<span class="lineNum">    4300 </span><span class="lineCov">          2 :     snprintf(centermountingblockname,100,&quot;MountingBlockSupportCenterLay%dArc&quot;,i+5);</span>
<span class="lineNum">    4301 </span><span class="lineCov">          2 :     snprintf(sideladdersupportpiecename,100,&quot;SideLadderSupportPieceLay%d&quot;,i+5);</span>
<span class="lineNum">    4302 </span><span class="lineCov">          2 :     snprintf(centerladdersupportpiecename,100,&quot;CenterLadderSupportPieceLay%d&quot;,i+5);</span>
<span class="lineNum">    4303 </span><span class="lineCov">          4 :     sidemountingblocksupportshape[i] = new TGeoXtru(2);</span>
<span class="lineNum">    4304 </span><span class="lineCov">          4 :     sidemountingblocksupportshape[i]-&gt;DefinePolygon(vertexlist[i]-&gt;GetSize()+2,</span>
<span class="lineNum">    4305 </span><span class="lineCov">          2 :                                                                                                 xsidevertex[i],ysidevertex[i]);</span>
<span class="lineNum">    4306 </span><span class="lineCov">          4 :     sidemountingblocksupportshape[i]-&gt;DefineSection(0,fgkMountingBlockSupportWidth[1]</span>
<span class="lineNum">    4307 </span><span class="lineCov">          2 :                                                                                                          -fgkMountingBlockSupportWidth[0]);</span>
<span class="lineNum">    4308 </span><span class="lineCov">          2 :     sidemountingblocksupportshape[i]-&gt;DefineSection(1,fgkMountingBlockSupportWidth[1]);</span>
<span class="lineNum">    4309 </span><span class="lineCov">          6 :     sidemountingblocksupport[i] = new TGeoVolume(sidemountingblockname,</span>
<span class="lineNum">    4310 </span><span class="lineCov">          2 :                                                                           sidemountingblocksupportshape[i],</span>
<span class="lineNum">    4311 </span><span class="lineCov">          2 :                                                                                   fSSDAlCoolBlockMedium);</span>
<span class="lineNum">    4312 </span><span class="lineCov">          2 :         sidemountingblocksupport[i]-&gt;SetLineColor(9);</span>
<span class="lineNum">    4313 </span><span class="lineCov">          4 :         centermountingsupportshape[i] = new TGeoXtru(2);</span>
<span class="lineNum">    4314 </span><span class="lineCov">          4 :     centermountingsupportshape[i]-&gt;DefinePolygon(indexedge[i]+3,</span>
<span class="lineNum">    4315 </span><span class="lineCov">          2 :                                                                                                 xcentervertex[i],ycentervertex[i]);</span>
<span class="lineNum">    4316 </span><span class="lineCov">          2 :         centermountingsupportshape[i]-&gt;DefineSection(0,0.);</span>
<span class="lineNum">    4317 </span><span class="lineCov">          4 :     centermountingsupportshape[i]-&gt;DefineSection(1,fgkMountingBlockSupportWidth[1]</span>
<span class="lineNum">    4318 </span><span class="lineCov">          2 :                                                                                                   -fgkMountingBlockSupportWidth[0]);</span>
<span class="lineNum">    4319 </span>            : 
<span class="lineNum">    4320 </span><span class="lineCov">          6 :     centermountingblocksupport[i] = new TGeoVolume(centermountingblockname,</span>
<span class="lineNum">    4321 </span><span class="lineCov">          2 :                                                                           centermountingsupportshape[i],</span>
<span class="lineNum">    4322 </span><span class="lineCov">          2 :                                                                                   fSSDAlCoolBlockMedium);</span>
<span class="lineNum">    4323 </span><span class="lineCov">          2 :         centermountingblocksupport[i]-&gt;SetLineColor(9);</span>
<span class="lineNum">    4324 </span><span class="lineCov">          4 :         sideladdersupportpieceshape[i] = new TGeoXtru(2);</span>
<span class="lineNum">    4325 </span><span class="lineCov">          4 :     sideladdersupportpieceshape[i]-&gt;DefinePolygon(vertexlist[i]-&gt;GetSize()+1,</span>
<span class="lineNum">    4326 </span><span class="lineCov">          2 :                                                                                                 xsidelowervertex[i],ysidelowervertex[i]);</span>
<span class="lineNum">    4327 </span><span class="lineCov">          4 :         sideladdersupportpieceshape[i]-&gt;DefineSection(0,fgkMountingBlockSupportWidth[1]</span>
<span class="lineNum">    4328 </span><span class="lineCov">          2 :                                                                                                          -fgkMountingBlockSupportWidth[0]);</span>
<span class="lineNum">    4329 </span><span class="lineCov">          2 :     sideladdersupportpieceshape[i]-&gt;DefineSection(1,fgkMountingBlockSupportWidth[1]);</span>
<span class="lineNum">    4330 </span><span class="lineCov">          6 :     sideladdersupportpiece[i] = new TGeoVolume(sideladdersupportpiecename,</span>
<span class="lineNum">    4331 </span><span class="lineCov">          2 :                                                                           sideladdersupportpieceshape[i],</span>
<span class="lineNum">    4332 </span><span class="lineCov">          2 :                                                                                   fSSDCarbonFiberMedium);</span>
<span class="lineNum">    4333 </span><span class="lineCov">          2 :         sideladdersupportpiece[i]-&gt;SetLineColor(fColorAl);</span>
<span class="lineNum">    4334 </span><span class="lineCov">          4 :         centerladdersupportpieceshape[i] = new TGeoXtru(2);</span>
<span class="lineNum">    4335 </span><span class="lineCov">          4 :     centerladdersupportpieceshape[i]-&gt;DefinePolygon(indexedge[i]+3,</span>
<span class="lineNum">    4336 </span><span class="lineCov">          2 :                                                                                                 xcenterlowervertex[i],ycenterlowervertex[i]);</span>
<span class="lineNum">    4337 </span><span class="lineCov">          2 :         centerladdersupportpieceshape[i]-&gt;DefineSection(0,0.0);</span>
<span class="lineNum">    4338 </span><span class="lineCov">          4 :     centerladdersupportpieceshape[i]-&gt;DefineSection(1,fgkMountingBlockSupportWidth[1]</span>
<span class="lineNum">    4339 </span><span class="lineCov">          2 :                                                                                                   -fgkMountingBlockSupportWidth[0]);</span>
<span class="lineNum">    4340 </span><span class="lineCov">          6 :     centerladdersupportpiece[i] = new TGeoVolume(centerladdersupportpiecename,</span>
<span class="lineNum">    4341 </span><span class="lineCov">          2 :                                                                           centerladdersupportpieceshape[i],</span>
<span class="lineNum">    4342 </span><span class="lineCov">          2 :                                                                                   fSSDCarbonFiberMedium);</span>
<span class="lineNum">    4343 </span><span class="lineCov">          2 :         centerladdersupportpiece[i]-&gt;SetLineColor(fColorAl);</span>
<span class="lineNum">    4344 </span>            :   }
<span class="lineNum">    4345 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    4346 </span>            :   // Building the Up Structure of Ladder Supports 
<span class="lineNum">    4347 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    4348 </span><span class="lineCov">          1 :   TGeoBBox** mountingblocksupportboxupshape[fgklayernumber];    </span>
<span class="lineNum">    4349 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++) mountingblocksupportboxupshape[i] = new TGeoBBox*[2];</span>
<span class="lineNum">    4350 </span><span class="lineCov">          1 :   TGeoBBox** mountingblocksupportboxdownshape[fgklayernumber];  </span>
<span class="lineNum">    4351 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++) mountingblocksupportboxdownshape[i] = new TGeoBBox*[2];</span>
<span class="lineNum">    4352 </span><span class="lineCov">          1 :   TGeoVolume** mountingblocksupportboxdown[fgklayernumber];</span>
<span class="lineNum">    4353 </span>            :   //////////////////////////////////////////////////////////
<span class="lineNum">    4354 </span>            :   // Setting the volume for TGeoXtru Mounting Block Piece  
<span class="lineNum">    4355 </span>            :   //////////////////////////////////////////////////////////
<span class="lineNum">    4356 </span><span class="lineCov">          1 :   TGeoVolume** mountingblocksupportboxup[fgklayernumber];</span>
<span class="lineNum">    4357 </span><span class="lineCov">          1 :   TGeoXtru* mountingblockpiecedownshape[fgklayernumber];</span>
<span class="lineNum">    4358 </span><span class="lineCov">          1 :   TGeoVolume* mountingblockpiecedown[fgklayernumber];</span>
<span class="lineNum">    4359 </span><span class="lineCov">          1 :   TGeoXtru* mountingblockpieceupshape[fgklayernumber];</span>
<span class="lineNum">    4360 </span><span class="lineCov">          1 :   TGeoVolume* mountingblockpieceup[fgklayernumber];</span>
<span class="lineNum">    4361 </span><span class="lineCov">          1 :   Double_t mountingblockpieceupxvertex[fgklayernumber][8];</span>
<span class="lineNum">    4362 </span><span class="lineCov">          1 :   Double_t mountingblockpieceupyvertex[fgklayernumber][8];</span>
<span class="lineNum">    4363 </span><span class="lineCov">          1 :   Double_t mountingblockpiecedownxvertex[fgklayernumber][8];</span>
<span class="lineNum">    4364 </span><span class="lineCov">          1 :   Double_t mountingblockpiecedownyvertex[fgklayernumber][8];</span>
<span class="lineNum">    4365 </span><span class="lineCov">          1 :   char mountingblockpiecedownname[100];</span>
<span class="lineNum">    4366 </span><span class="lineCov">          1 :   char mountingblockpieceupname[100];</span>
<span class="lineNum">    4367 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++){</span>
<span class="lineNum">    4368 </span>            :     ///////////////////////////
<span class="lineNum">    4369 </span>            :     // Mounting Block Down Vertex
<span class="lineNum">    4370 </span>            :     ///////////////////////////
<span class="lineNum">    4371 </span><span class="lineCov">          4 :         mountingblockpiecedownshape[i] = new TGeoXtru(2);</span>
<span class="lineNum">    4372 </span><span class="lineCov">          2 :         snprintf(mountingblockpiecedownname,100,&quot;MountingBlockPieceDownLay%d&quot;,i+5);</span>
<span class="lineNum">    4373 </span><span class="lineCov">          2 :         mountingblockpiecedownxvertex[i][0] = -0.5*fgkSSDMountingBlockLength[0];        </span>
<span class="lineNum">    4374 </span><span class="lineCov">          4 :         mountingblockpiecedownyvertex[i][0] = fgkMountingBlockSupportRadius[i]</span>
<span class="lineNum">    4375 </span><span class="lineCov">          2 :                                               + fgkMountingBlockSupportDownHeight </span>
<span class="lineNum">    4376 </span><span class="lineCov">          2 :                                               - fgkSSDLadderVerticalDisalignment;</span>
<span class="lineNum">    4377 </span><span class="lineCov">          2 :         mountingblockpiecedownxvertex[i][1] = mountingblockpiecedownxvertex[i][0];      </span>
<span class="lineNum">    4378 </span><span class="lineCov">          4 :         mountingblockpiecedownyvertex[i][1] = mountingblockpiecedownyvertex[i][0]</span>
<span class="lineNum">    4379 </span><span class="lineCov">          2 :                                                                                 + fgkSSDMountingBlockHeight[1]</span>
<span class="lineNum">    4380 </span><span class="lineCov">          2 :                                                                                 - 0.5*fgkCoolingTubeSupportHeight</span>
<span class="lineNum">    4381 </span><span class="lineCov">          2 :                                                                                 - fgkSSDModuleCoolingBlockToSensor;</span>
<span class="lineNum">    4382 </span><span class="lineCov">          2 :         mountingblockpiecedownxvertex[i][2] = 0.5*fgkSSDMountingBlockLength[0]; </span>
<span class="lineNum">    4383 </span><span class="lineCov">          2 :         mountingblockpiecedownyvertex[i][2] = mountingblockpiecedownyvertex[i][1];</span>
<span class="lineNum">    4384 </span><span class="lineCov">          2 :         mountingblockpiecedownxvertex[i][3] = mountingblockpiecedownxvertex[i][2];      </span>
<span class="lineNum">    4385 </span><span class="lineCov">          2 :         mountingblockpiecedownyvertex[i][3] = mountingblockpiecedownyvertex[i][0];</span>
<span class="lineNum">    4386 </span><span class="lineCov">          2 :         mountingblockpiecedownxvertex[i][4] = 0.5*fgkSSDMountingBlockLength[1];</span>
<span class="lineNum">    4387 </span><span class="lineCov">          2 :         mountingblockpiecedownyvertex[i][4] = mountingblockpiecedownyvertex[i][0];</span>
<span class="lineNum">    4388 </span><span class="lineCov">          2 :         mountingblockpiecedownxvertex[i][5] = mountingblockpiecedownxvertex[i][4];</span>
<span class="lineNum">    4389 </span><span class="lineCov">          4 :         mountingblockpiecedownyvertex[i][5] = mountingblockpiecedownyvertex[i][4]</span>
<span class="lineNum">    4390 </span><span class="lineCov">          2 :                                                                                 + fgkSSDMountingBlockHeight[2]</span>
<span class="lineNum">    4391 </span><span class="lineCov">          2 :                                                                                 - fgkSSDMountingBlockHeight[0];</span>
<span class="lineNum">    4392 </span><span class="lineCov">          2 :         mountingblockpiecedownxvertex[i][6] = -mountingblockpiecedownxvertex[i][4];</span>
<span class="lineNum">    4393 </span><span class="lineCov">          2 :         mountingblockpiecedownyvertex[i][6] = mountingblockpiecedownyvertex[i][5];</span>
<span class="lineNum">    4394 </span><span class="lineCov">          2 :         mountingblockpiecedownxvertex[i][7] = mountingblockpiecedownxvertex[i][6];      </span>
<span class="lineNum">    4395 </span><span class="lineCov">          2 :         mountingblockpiecedownyvertex[i][7] = mountingblockpiecedownyvertex[i][0];</span>
<span class="lineNum">    4396 </span><span class="lineCov">          4 :         mountingblockpiecedownshape[i]-&gt;DefinePolygon(8,mountingblockpiecedownxvertex[i],</span>
<span class="lineNum">    4397 </span><span class="lineCov">          2 :                                                                                                          mountingblockpiecedownyvertex[i]);</span>
<span class="lineNum">    4398 </span><span class="lineCov">          2 :         mountingblockpiecedownshape[i]-&gt;DefineSection(0,0.0);</span>
<span class="lineNum">    4399 </span><span class="lineCov">          2 :         mountingblockpiecedownshape[i]-&gt;DefineSection(1,fgkMountingBlockSupportWidth[1]);</span>
<span class="lineNum">    4400 </span><span class="lineCov">          6 :         mountingblockpiecedown[i] = new TGeoVolume(mountingblockpiecedownname,</span>
<span class="lineNum">    4401 </span><span class="lineCov">          2 :                                                                  mountingblockpiecedownshape[i],fSSDMountingBlockMedium);</span>
<span class="lineNum">    4402 </span><span class="lineCov">          2 :         mountingblockpiecedown[i]-&gt;SetLineColor(fColorG10);</span>
<span class="lineNum">    4403 </span>            : 
<span class="lineNum">    4404 </span>            :     ///////////////////////////
<span class="lineNum">    4405 </span>            :     // Mounting Block Up Vertex
<span class="lineNum">    4406 </span>            :     ///////////////////////////
<span class="lineNum">    4407 </span><span class="lineCov">          4 :         mountingblockpieceupshape[i] = new TGeoXtru(2);</span>
<span class="lineNum">    4408 </span><span class="lineCov">          2 :         snprintf(mountingblockpieceupname,100,&quot;MountingBlockPieceUpLay%d&quot;,i+5);</span>
<span class="lineNum">    4409 </span><span class="lineCov">          2 :         mountingblockpieceupxvertex[i][0] = -0.5*fgkSSDMountingBlockLength[0];  </span>
<span class="lineNum">    4410 </span><span class="lineCov">          4 :         mountingblockpieceupyvertex[i][0] = fgkMountingBlockSupportRadius[i]</span>
<span class="lineNum">    4411 </span><span class="lineCov">          2 :                                                                                 + fgkMountingBlockSupportUpHeight[i]</span>
<span class="lineNum">    4412 </span><span class="lineCov">          2 :                                               - fgkSSDLadderVerticalDisalignment;</span>
<span class="lineNum">    4413 </span><span class="lineCov">          2 :         mountingblockpieceupxvertex[i][1] = mountingblockpieceupxvertex[i][0];  </span>
<span class="lineNum">    4414 </span><span class="lineCov">          4 :         mountingblockpieceupyvertex[i][1] = mountingblockpieceupyvertex[i][0]</span>
<span class="lineNum">    4415 </span><span class="lineCov">          2 :                                                                                 + fgkSSDMountingBlockHeight[1]</span>
<span class="lineNum">    4416 </span><span class="lineCov">          2 :                                                                                 - 0.5*fgkCoolingTubeSupportHeight</span>
<span class="lineNum">    4417 </span><span class="lineCov">          2 :                                                                                 - fgkSSDModuleCoolingBlockToSensor;</span>
<span class="lineNum">    4418 </span><span class="lineCov">          2 :         mountingblockpieceupxvertex[i][2] = 0.5*fgkSSDMountingBlockLength[0];   </span>
<span class="lineNum">    4419 </span><span class="lineCov">          2 :         mountingblockpieceupyvertex[i][2] = mountingblockpieceupyvertex[i][1];</span>
<span class="lineNum">    4420 </span><span class="lineCov">          2 :         mountingblockpieceupxvertex[i][3] = mountingblockpieceupxvertex[i][2];  </span>
<span class="lineNum">    4421 </span><span class="lineCov">          2 :         mountingblockpieceupyvertex[i][3] = mountingblockpieceupyvertex[i][0];</span>
<span class="lineNum">    4422 </span><span class="lineCov">          2 :         mountingblockpieceupxvertex[i][4] = 0.5*fgkSSDMountingBlockLength[1];</span>
<span class="lineNum">    4423 </span><span class="lineCov">          2 :         mountingblockpieceupyvertex[i][4] = mountingblockpieceupyvertex[i][0];</span>
<span class="lineNum">    4424 </span><span class="lineCov">          2 :         mountingblockpieceupxvertex[i][5] = mountingblockpieceupxvertex[i][4];</span>
<span class="lineNum">    4425 </span><span class="lineCov">          4 :         mountingblockpieceupyvertex[i][5] = mountingblockpieceupyvertex[i][4]</span>
<span class="lineNum">    4426 </span><span class="lineCov">          2 :                                                                                 + fgkSSDMountingBlockHeight[2]</span>
<span class="lineNum">    4427 </span><span class="lineCov">          2 :                                                                                 - fgkSSDMountingBlockHeight[0];</span>
<span class="lineNum">    4428 </span><span class="lineCov">          2 :         mountingblockpieceupxvertex[i][6] = -mountingblockpieceupxvertex[i][4];</span>
<span class="lineNum">    4429 </span><span class="lineCov">          2 :         mountingblockpieceupyvertex[i][6] = mountingblockpieceupyvertex[i][5];</span>
<span class="lineNum">    4430 </span><span class="lineCov">          2 :         mountingblockpieceupxvertex[i][7] = mountingblockpieceupxvertex[i][6];  </span>
<span class="lineNum">    4431 </span><span class="lineCov">          2 :         mountingblockpieceupyvertex[i][7] = mountingblockpieceupyvertex[i][0];</span>
<span class="lineNum">    4432 </span>            : 
<span class="lineNum">    4433 </span><span class="lineCov">          4 :         mountingblockpieceupshape[i]-&gt;DefinePolygon(8,mountingblockpieceupxvertex[i],</span>
<span class="lineNum">    4434 </span><span class="lineCov">          2 :                                                                                                          mountingblockpieceupyvertex[i]);</span>
<span class="lineNum">    4435 </span><span class="lineCov">          2 :         mountingblockpieceupshape[i]-&gt;DefineSection(0,0.0);</span>
<span class="lineNum">    4436 </span><span class="lineCov">          2 :         mountingblockpieceupshape[i]-&gt;DefineSection(1,fgkMountingBlockSupportWidth[1]);</span>
<span class="lineNum">    4437 </span><span class="lineCov">          6 :         mountingblockpieceup[i] = new TGeoVolume(mountingblockpieceupname,</span>
<span class="lineNum">    4438 </span><span class="lineCov">          2 :                                                                 mountingblockpieceupshape[i],fSSDMountingBlockMedium);</span>
<span class="lineNum">    4439 </span><span class="lineCov">          2 :         mountingblockpieceup[i]-&gt;SetLineColor(fColorG10);</span>
<span class="lineNum">    4440 </span>            :  }
<span class="lineNum">    4441 </span>            :   ///////////////////////////////////////////////////////////////////
<span class="lineNum">    4442 </span>            :   // Setting the volume for TGeoXtru Mounting Block Support Trapezoid  
<span class="lineNum">    4443 </span>            :   ///////////////////////////////////////////////////////////////////
<span class="lineNum">    4444 </span><span class="lineCov">          1 :   TGeoXtru* mountingblocksupportrapezoidownshape[fgklayernumber];</span>
<span class="lineNum">    4445 </span><span class="lineCov">          1 :   TGeoXtru* mountingblocksupportrapezoidupshape[fgklayernumber];</span>
<span class="lineNum">    4446 </span><span class="lineCov">          1 :   TGeoVolume* mountingblocksupportrapezoidown[fgklayernumber];</span>
<span class="lineNum">    4447 </span><span class="lineCov">          1 :   TGeoVolume* mountingblocksupportrapezoidup[fgklayernumber];</span>
<span class="lineNum">    4448 </span><span class="lineCov">          1 :   Double_t mountingblocksupportrapezoidownxvertex[fgklayernumber][5];</span>
<span class="lineNum">    4449 </span><span class="lineCov">          1 :   Double_t mountingblocksupportrapezoidownyvertex[fgklayernumber][5];</span>
<span class="lineNum">    4450 </span><span class="lineCov">          1 :   Double_t mountingblocksupportrapezoidupxvertex[fgklayernumber][5];</span>
<span class="lineNum">    4451 </span><span class="lineCov">          1 :   Double_t mountingblocksupportrapezoidupyvertex[fgklayernumber][5];</span>
<span class="lineNum">    4452 </span><span class="lineCov">          1 :   char mountingblocksupportrapezoidowname[100];</span>
<span class="lineNum">    4453 </span><span class="lineCov">          1 :   char mountingblocksupportrapezoidupname[100];</span>
<span class="lineNum">    4454 </span>            :   Double_t scalefactor = 3./4.;
<span class="lineNum">    4455 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++){</span>
<span class="lineNum">    4456 </span>            :   ////////////////////////////////////////////
<span class="lineNum">    4457 </span>            :   // Mounting Block Support Down Trapezoid Vertex 
<span class="lineNum">    4458 </span>            :   ////////////////////////////////////////////
<span class="lineNum">    4459 </span><span class="lineCov">          4 :         mountingblocksupportrapezoidownshape[i] = new TGeoXtru(2);</span>
<span class="lineNum">    4460 </span><span class="lineCov">          4 :         mountingblocksupportrapezoidownxvertex[i][0] = -0.5*fgkSSDMountingBlockLength[0]</span>
<span class="lineNum">    4461 </span><span class="lineCov">          2 :                                                                                                  - mountingsupportedge[i];</span>
<span class="lineNum">    4462 </span><span class="lineCov">          2 :         mountingblocksupportrapezoidownyvertex[i][0] = mountingblockpiecedownyvertex[i][0];</span>
<span class="lineNum">    4463 </span><span class="lineCov">          2 :         mountingblocksupportrapezoidownxvertex[i][1] = </span>
<span class="lineNum">    4464 </span><span class="lineCov">          2 :                                                                                 mountingblocksupportrapezoidownxvertex[i][0];</span>
<span class="lineNum">    4465 </span><span class="lineCov">          4 :         mountingblocksupportrapezoidownyvertex[i][1] = mountingblockpiecedownyvertex[i][0]</span>
<span class="lineNum">    4466 </span><span class="lineCov">          4 :                                                                                                  + scalefactor*(mountingblockpiecedownyvertex[i][1]</span>
<span class="lineNum">    4467 </span><span class="lineCov">          2 :                                                                                              - mountingblockpiecedownyvertex[i][0]);</span>
<span class="lineNum">    4468 </span><span class="lineCov">          2 :         mountingblocksupportrapezoidownxvertex[i][2] = -0.5*fgkSSDSensorWidth;</span>
<span class="lineNum">    4469 </span><span class="lineCov">          2 :         mountingblocksupportrapezoidownyvertex[i][2] = mountingblockpiecedownyvertex[i][1]; </span>
<span class="lineNum">    4470 </span><span class="lineCov">          2 :         mountingblocksupportrapezoidownxvertex[i][3] = mountingblockpiecedownxvertex[i][0];</span>
<span class="lineNum">    4471 </span><span class="lineCov">          2 :         mountingblocksupportrapezoidownyvertex[i][3] = mountingblocksupportrapezoidownyvertex[i][2];</span>
<span class="lineNum">    4472 </span><span class="lineCov">          2 :         mountingblocksupportrapezoidownxvertex[i][4] = mountingblocksupportrapezoidownxvertex[i][3];</span>
<span class="lineNum">    4473 </span><span class="lineCov">          2 :         mountingblocksupportrapezoidownyvertex[i][4] = mountingblocksupportrapezoidownyvertex[i][0];</span>
<span class="lineNum">    4474 </span>            : 
<span class="lineNum">    4475 </span><span class="lineCov">          4 :         mountingblocksupportrapezoidownshape[i]-&gt;DefinePolygon(5,mountingblocksupportrapezoidownxvertex[i],</span>
<span class="lineNum">    4476 </span><span class="lineCov">          2 :                                                                                                                mountingblocksupportrapezoidownyvertex[i]);</span>
<span class="lineNum">    4477 </span><span class="lineCov">          4 :         mountingblocksupportrapezoidownshape[i]-&gt;DefineSection(0,fgkMountingBlockSupportWidth[1]</span>
<span class="lineNum">    4478 </span><span class="lineCov">          2 :                                                                                                                         -fgkMountingBlockSupportWidth[0]);</span>
<span class="lineNum">    4479 </span><span class="lineCov">          2 :         mountingblocksupportrapezoidownshape[i]-&gt;DefineSection(1,fgkMountingBlockSupportWidth[1]);</span>
<span class="lineNum">    4480 </span><span class="lineCov">          2 :         snprintf(mountingblocksupportrapezoidowname,100,&quot;MountingBlockSuppTrapezoidDownLay%d&quot;,i+5);</span>
<span class="lineNum">    4481 </span><span class="lineCov">          6 :         mountingblocksupportrapezoidown[i] = new TGeoVolume(mountingblocksupportrapezoidowname,</span>
<span class="lineNum">    4482 </span><span class="lineCov">          2 :                                                                 mountingblocksupportrapezoidownshape[i],fSSDCarbonFiberMedium);</span>
<span class="lineNum">    4483 </span><span class="lineCov">          2 :         mountingblocksupportrapezoidown[i]-&gt;SetLineColor(9);</span>
<span class="lineNum">    4484 </span>            :   ////////////////////////////////////////////
<span class="lineNum">    4485 </span>            :   // Mounting Block Support Up Trapezoid Vertex 
<span class="lineNum">    4486 </span>            :   ////////////////////////////////////////////
<span class="lineNum">    4487 </span><span class="lineCov">          4 :         mountingblocksupportrapezoidupshape[i] = new TGeoXtru(2);</span>
<span class="lineNum">    4488 </span><span class="lineCov">          4 :         mountingblocksupportrapezoidupxvertex[i][0] = -0.5*fgkSSDMountingBlockLength[0]</span>
<span class="lineNum">    4489 </span><span class="lineCov">          2 :                                                                                                  - mountingsupportedge[i];</span>
<span class="lineNum">    4490 </span><span class="lineCov">          2 :         mountingblocksupportrapezoidupyvertex[i][0] = mountingblockpieceupyvertex[i][0];</span>
<span class="lineNum">    4491 </span><span class="lineCov">          2 :         mountingblocksupportrapezoidupxvertex[i][1] = </span>
<span class="lineNum">    4492 </span><span class="lineCov">          2 :                                                                                 mountingblocksupportrapezoidupxvertex[i][0];</span>
<span class="lineNum">    4493 </span><span class="lineCov">          2 :         mountingblocksupportrapezoidupyvertex[i][1] = </span>
<span class="lineNum">    4494 </span><span class="lineCov">          2 :                                                                                                mountingblockpieceupyvertex[i][0]</span>
<span class="lineNum">    4495 </span><span class="lineCov">          4 :                                                                                                  + scalefactor*(mountingblockpieceupyvertex[i][1]</span>
<span class="lineNum">    4496 </span><span class="lineCov">          2 :                                                                                              - mountingblockpieceupyvertex[i][0]);</span>
<span class="lineNum">    4497 </span><span class="lineCov">          2 :         mountingblocksupportrapezoidupxvertex[i][2] = -0.5*fgkSSDSensorWidth;</span>
<span class="lineNum">    4498 </span><span class="lineCov">          2 :         mountingblocksupportrapezoidupyvertex[i][2] = mountingblockpieceupyvertex[i][1]; </span>
<span class="lineNum">    4499 </span><span class="lineCov">          2 :         mountingblocksupportrapezoidupxvertex[i][3] = mountingblockpieceupxvertex[i][0];</span>
<span class="lineNum">    4500 </span><span class="lineCov">          2 :         mountingblocksupportrapezoidupyvertex[i][3] = mountingblocksupportrapezoidupyvertex[i][2];</span>
<span class="lineNum">    4501 </span><span class="lineCov">          2 :         mountingblocksupportrapezoidupxvertex[i][4] = mountingblocksupportrapezoidupxvertex[i][3];</span>
<span class="lineNum">    4502 </span><span class="lineCov">          2 :         mountingblocksupportrapezoidupyvertex[i][4] = mountingblocksupportrapezoidupyvertex[i][0];</span>
<span class="lineNum">    4503 </span>            : 
<span class="lineNum">    4504 </span><span class="lineCov">          4 :         mountingblocksupportrapezoidupshape[i]-&gt;DefinePolygon(5,mountingblocksupportrapezoidupxvertex[i],</span>
<span class="lineNum">    4505 </span><span class="lineCov">          2 :                                                                                                                mountingblocksupportrapezoidupyvertex[i]);</span>
<span class="lineNum">    4506 </span><span class="lineCov">          4 :         mountingblocksupportrapezoidupshape[i]-&gt;DefineSection(0,fgkMountingBlockSupportWidth[1]</span>
<span class="lineNum">    4507 </span><span class="lineCov">          2 :                                                                                                                         -fgkMountingBlockSupportWidth[0]);</span>
<span class="lineNum">    4508 </span><span class="lineCov">          2 :         mountingblocksupportrapezoidupshape[i]-&gt;DefineSection(1,fgkMountingBlockSupportWidth[1]);</span>
<span class="lineNum">    4509 </span><span class="lineCov">          2 :         snprintf(mountingblocksupportrapezoidupname,100,&quot;MountingBlockSuppTrapezoidUpLay%d&quot;,i+5);</span>
<span class="lineNum">    4510 </span><span class="lineCov">          6 :         mountingblocksupportrapezoidup[i] = new TGeoVolume(mountingblocksupportrapezoidupname,</span>
<span class="lineNum">    4511 </span><span class="lineCov">          2 :                                                                 mountingblocksupportrapezoidupshape[i],fSSDCarbonFiberMedium);</span>
<span class="lineNum">    4512 </span><span class="lineCov">          2 :         mountingblocksupportrapezoidup[i]-&gt;SetLineColor(9);</span>
<span class="lineNum">    4513 </span>            :   }
<span class="lineNum">    4514 </span>            :   ///////////////////////////////////////////////////////////////////
<span class="lineNum">    4515 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++) mountingblocksupportboxdown[i] = new TGeoVolume*[3];</span>
<span class="lineNum">    4516 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++) mountingblocksupportboxup[i] = new TGeoVolume*[3];</span>
<span class="lineNum">    4517 </span><span class="lineCov">          1 :   Double_t boxoriginup[fgklayernumber][2][3];</span>
<span class="lineNum">    4518 </span><span class="lineCov">          1 :   Double_t boxorigindown[fgklayernumber][2][3];</span>
<span class="lineNum">    4519 </span><span class="lineCov">          1 :   char mountingblocksupportboxdownname[100];</span>
<span class="lineNum">    4520 </span><span class="lineCov">          1 :   char mountingblocksupportboxupname[100];</span>
<span class="lineNum">    4521 </span><span class="lineCov">          1 :   TGeoRotation* mountingblocksupportrot = new TGeoRotation();</span>
<span class="lineNum">    4522 </span><span class="lineCov">          1 :   mountingblocksupportrot-&gt;SetAngles(90.,180.,-90);</span>
<span class="lineNum">    4523 </span><span class="lineCov">          1 :   TGeoRotation* globalrefladdersupportrot = new TGeoRotation();</span>
<span class="lineNum">    4524 </span><span class="lineCov">          1 :   globalrefladdersupportrot-&gt;SetAngles(0.,90.,0.);</span>
<span class="lineNum">    4525 </span><span class="lineCov">          1 :   TGeoHMatrix* laddersupportmatrix[2];</span>
<span class="lineNum">    4526 </span><span class="lineCov">          2 :   laddersupportmatrix[0] = new TGeoHMatrix(*globalrefladdersupportrot);</span>
<span class="lineNum">    4527 </span><span class="lineCov">          3 :   laddersupportmatrix[1] = new TGeoHMatrix((*globalrefladdersupportrot)*(*mountingblocksupportrot));</span>
<span class="lineNum">    4528 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    4529 </span>            :   // Creating Mother Volume for Containment
<span class="lineNum">    4530 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    4531 </span><span class="lineCov">          1 :   Double_t *xmothervertex[fgklayernumber];</span>
<span class="lineNum">    4532 </span><span class="lineCov">          1 :   Double_t *ymothervertex[fgklayernumber];</span>
<span class="lineNum">    4533 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++){</span>
<span class="lineNum">    4534 </span><span class="lineCov">          2 :         xmothervertex[i] = new Double_t[8];</span>
<span class="lineNum">    4535 </span><span class="lineCov">          2 :         ymothervertex[i] = new Double_t[8];</span>
<span class="lineNum">    4536 </span>            :   }  
<span class="lineNum">    4537 </span><span class="lineCov">          1 :   TGeoXtru* downmotherladdersupportshape[fgklayernumber];</span>
<span class="lineNum">    4538 </span><span class="lineCov">          1 :   TGeoVolume* downmotherladdersupport[fgklayernumber]; </span>
<span class="lineNum">    4539 </span><span class="lineCov">          1 :   TGeoXtru* upmotherladdersupportshape[fgklayernumber];</span>
<span class="lineNum">    4540 </span><span class="lineCov">          1 :   TGeoVolume* upmotherladdersupport[fgklayernumber]; </span>
<span class="lineNum">    4541 </span><span class="lineCov">          1 :   char upmotheladdersupportname[100];</span>
<span class="lineNum">    4542 </span><span class="lineCov">          1 :   char downmotheladdersupportname[100];</span>
<span class="lineNum">    4543 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++){</span>
<span class="lineNum">    4544 </span><span class="lineCov">          4 :         xmothervertex[i][0] = -0.5*fgkSSDMountingBlockLength[0]</span>
<span class="lineNum">    4545 </span><span class="lineCov">          2 :                                                     -  mountingsupportedge[i];</span>
<span class="lineNum">    4546 </span><span class="lineCov">          2 :         ymothervertex[i][0] = -fgkMountingBlockSupportWidth[1];</span>
<span class="lineNum">    4547 </span><span class="lineCov">          2 :         xmothervertex[i][1] = xmothervertex[i][0];</span>
<span class="lineNum">    4548 </span><span class="lineCov">          4 :         ymothervertex[i][1] = -fgkMountingBlockSupportWidth[1]</span>
<span class="lineNum">    4549 </span><span class="lineCov">          2 :                                                         + fgkMountingBlockSupportWidth[0];</span>
<span class="lineNum">    4550 </span><span class="lineCov">          2 :         xmothervertex[i][2] = -0.5*fgkSSDMountingBlockLength[0];</span>
<span class="lineNum">    4551 </span><span class="lineCov">          2 :         ymothervertex[i][2] = ymothervertex[i][1];</span>
<span class="lineNum">    4552 </span><span class="lineCov">          2 :         xmothervertex[i][3] = xmothervertex[i][2];</span>
<span class="lineNum">    4553 </span><span class="lineCov">          2 :         ymothervertex[i][3] = -ymothervertex[i][0];</span>
<span class="lineNum">    4554 </span><span class="lineCov">          2 :         xmothervertex[i][4] = -xmothervertex[i][0];</span>
<span class="lineNum">    4555 </span><span class="lineCov">          2 :         ymothervertex[i][4] = ymothervertex[i][3];</span>
<span class="lineNum">    4556 </span><span class="lineCov">          2 :         xmothervertex[i][5] = xmothervertex[i][4];</span>
<span class="lineNum">    4557 </span><span class="lineCov">          2 :         ymothervertex[i][5] = -ymothervertex[i][1];</span>
<span class="lineNum">    4558 </span><span class="lineCov">          2 :         xmothervertex[i][6] = -xmothervertex[i][2];</span>
<span class="lineNum">    4559 </span><span class="lineCov">          2 :         ymothervertex[i][6] = ymothervertex[i][5];</span>
<span class="lineNum">    4560 </span><span class="lineCov">          2 :         xmothervertex[i][7] = xmothervertex[i][6];</span>
<span class="lineNum">    4561 </span><span class="lineCov">          2 :         ymothervertex[i][7] = ymothervertex[i][0];</span>
<span class="lineNum">    4562 </span>            : 
<span class="lineNum">    4563 </span><span class="lineCov">          2 :         snprintf(downmotheladdersupportname,100,&quot;LadderSupportDownLay%d&quot;,i+5);</span>
<span class="lineNum">    4564 </span><span class="lineCov">          2 :         snprintf(upmotheladdersupportname,100,&quot;LadderSupportUpLay%d&quot;,i+5);</span>
<span class="lineNum">    4565 </span>            : 
<span class="lineNum">    4566 </span><span class="lineCov">          4 :         downmotherladdersupportshape[i] = new TGeoXtru(2);</span>
<span class="lineNum">    4567 </span><span class="lineCov">          2 :         downmotherladdersupportshape[i]-&gt;DefinePolygon(8,xmothervertex[i],ymothervertex[i]);</span>
<span class="lineNum">    4568 </span><span class="lineCov">          2 :         downmotherladdersupportshape[i]-&gt;DefineSection(0,ysidevertex[i][0]);</span>
<span class="lineNum">    4569 </span><span class="lineCov">          4 :         downmotherladdersupportshape[i]-&gt;DefineSection(1,ysidevertex[i][1]</span>
<span class="lineNum">    4570 </span><span class="lineCov">          2 :                                                                    +                       fgkMountingBlockSupportDownHeight</span>
<span class="lineNum">    4571 </span><span class="lineCov">          2 :                                                                    +                       fgkSSDMountingBlockHeight[1]</span>
<span class="lineNum">    4572 </span><span class="lineCov">          2 :                                                                    -                       0.5*fgkCoolingTubeSupportHeight</span>
<span class="lineNum">    4573 </span><span class="lineCov">          2 :                                                                    -                       fgkSSDModuleCoolingBlockToSensor</span>
<span class="lineNum">    4574 </span><span class="lineCov">          2 :                                                        - fgkSSDLadderVerticalDisalignment);</span>
<span class="lineNum">    4575 </span>            :         
<span class="lineNum">    4576 </span>            : //                                                 - fgkSSDModuleVerticalDisalignment);
<span class="lineNum">    4577 </span>            :         //downmotherladdersupport[i] = new TGeoVolumeAssembly(downmotheladdersupportname);
<span class="lineNum">    4578 </span>            : 
<span class="lineNum">    4579 </span><span class="lineCov">          6 :         downmotherladdersupport[i] = new TGeoVolume(downmotheladdersupportname,</span>
<span class="lineNum">    4580 </span><span class="lineCov">          2 :                                                                           downmotherladdersupportshape[i],fSSDAir);</span>
<span class="lineNum">    4581 </span><span class="lineCov">          4 :     upmotherladdersupportshape[i] = new TGeoXtru(2);</span>
<span class="lineNum">    4582 </span><span class="lineCov">          2 :         upmotherladdersupportshape[i]-&gt;DefinePolygon(8,xmothervertex[i],ymothervertex[i]);</span>
<span class="lineNum">    4583 </span><span class="lineCov">          2 :         upmotherladdersupportshape[i]-&gt;DefineSection(0,ysidevertex[i][0]);</span>
<span class="lineNum">    4584 </span><span class="lineCov">          4 :     upmotherladdersupportshape[i]-&gt;DefineSection(1,ysidevertex[i][1]</span>
<span class="lineNum">    4585 </span><span class="lineCov">          2 :                                                                    +                       fgkMountingBlockSupportUpHeight[i]</span>
<span class="lineNum">    4586 </span><span class="lineCov">          2 :                                                                    +                       fgkSSDMountingBlockHeight[1]</span>
<span class="lineNum">    4587 </span><span class="lineCov">          2 :                                                                    -                       0.5*fgkCoolingTubeSupportHeight</span>
<span class="lineNum">    4588 </span><span class="lineCov">          2 :                                                                    -                       fgkSSDModuleCoolingBlockToSensor</span>
<span class="lineNum">    4589 </span><span class="lineCov">          2 :                                                  - fgkSSDLadderVerticalDisalignment);</span>
<span class="lineNum">    4590 </span>            : 
<span class="lineNum">    4591 </span><span class="lineCov">          6 :      upmotherladdersupport[i] = new TGeoVolume(upmotheladdersupportname,</span>
<span class="lineNum">    4592 </span><span class="lineCov">          2 :                                                                                           upmotherladdersupportshape[i],fSSDAir);</span>
<span class="lineNum">    4593 </span>            :   }
<span class="lineNum">    4594 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++){</span>
<span class="lineNum">    4595 </span>            :         /////////////////////////
<span class="lineNum">    4596 </span>            :         // Setting the box origin
<span class="lineNum">    4597 </span>            :         /////////////////////////
<span class="lineNum">    4598 </span><span class="lineCov">          2 :         boxorigindown[i][0][0] = -0.5*mountingsupportedge[i];</span>
<span class="lineNum">    4599 </span><span class="lineCov">          4 :         boxorigindown[i][0][1] =  fgkMountingBlockSupportRadius[i]</span>
<span class="lineNum">    4600 </span><span class="lineCov">          2 :                                                    +  0.5*fgkMountingBlockSupportDownHeight</span>
<span class="lineNum">    4601 </span><span class="lineCov">          2 :                                   - 0.5*fgkSSDLadderVerticalDisalignment;</span>
<span class="lineNum">    4602 </span><span class="lineCov">          4 :         boxorigindown[i][0][2] =  fgkMountingBlockSupportWidth[1]</span>
<span class="lineNum">    4603 </span><span class="lineCov">          2 :                                                    -  0.5*fgkMountingBlockSupportWidth[0];</span>
<span class="lineNum">    4604 </span>            :   
<span class="lineNum">    4605 </span><span class="lineCov">          2 :         boxorigindown[i][1][0] = 0.0;</span>
<span class="lineNum">    4606 </span><span class="lineCov">          2 :         boxorigindown[i][1][1] = boxorigindown[i][0][1];</span>
<span class="lineNum">    4607 </span><span class="lineCov">          4 :         boxorigindown[i][1][2] = 0.5*(fgkMountingBlockSupportWidth[1]</span>
<span class="lineNum">    4608 </span><span class="lineCov">          2 :                                                    -      fgkMountingBlockSupportWidth[0]);</span>
<span class="lineNum">    4609 </span>            :                                                    
<span class="lineNum">    4610 </span><span class="lineCov">          2 :         boxoriginup[i][0][0] = -0.5*mountingsupportedge[i];</span>
<span class="lineNum">    4611 </span><span class="lineCov">          4 :         boxoriginup[i][0][1] = fgkMountingBlockSupportRadius[i]</span>
<span class="lineNum">    4612 </span><span class="lineCov">          2 :                                + 0.5*fgkMountingBlockSupportUpHeight[i]</span>
<span class="lineNum">    4613 </span><span class="lineCov">          2 :                                - 0.5*fgkSSDLadderVerticalDisalignment;</span>
<span class="lineNum">    4614 </span><span class="lineCov">          4 :         boxoriginup[i][0][2] = fgkMountingBlockSupportWidth[1]</span>
<span class="lineNum">    4615 </span><span class="lineCov">          2 :                                                  - 0.5*fgkMountingBlockSupportWidth[0];</span>
<span class="lineNum">    4616 </span>            :   
<span class="lineNum">    4617 </span><span class="lineCov">          2 :         boxoriginup[i][1][0] = 0.0;</span>
<span class="lineNum">    4618 </span><span class="lineCov">          2 :         boxoriginup[i][1][1] = boxoriginup[i][0][1];</span>
<span class="lineNum">    4619 </span><span class="lineCov">          4 :         boxoriginup[i][1][2] = 0.5*(fgkMountingBlockSupportWidth[1]</span>
<span class="lineNum">    4620 </span><span class="lineCov">          2 :                                                  - fgkMountingBlockSupportWidth[0]);</span>
<span class="lineNum">    4621 </span>            :   
<span class="lineNum">    4622 </span>            :         /////////////////////////
<span class="lineNum">    4623 </span>            :     // Setting the boxes    
<span class="lineNum">    4624 </span>            :         /////////////////////////
<span class="lineNum">    4625 </span><span class="lineCov">          8 :         mountingblocksupportboxdownshape[i][0] = new TGeoBBox(0.5*(mountingsupportedge[i]</span>
<span class="lineNum">    4626 </span><span class="lineCov">          2 :                                                                                  +  fgkSSDMountingBlockLength[0]),</span>
<span class="lineNum">    4627 </span><span class="lineCov">          2 :                                                                                         0.5*fgkMountingBlockSupportDownHeight - 0.5*fgkSSDLadderVerticalDisalignment,</span>
<span class="lineNum">    4628 </span><span class="lineCov">          2 :                                                                                         0.5*fgkMountingBlockSupportWidth[0],</span>
<span class="lineNum">    4629 </span><span class="lineCov">          2 :                                                                                         boxorigindown[i][0]);</span>
<span class="lineNum">    4630 </span><span class="lineCov">          6 :         mountingblocksupportboxdownshape[i][1] = new TGeoBBox(0.5*fgkSSDMountingBlockLength[0],</span>
<span class="lineNum">    4631 </span><span class="lineCov">          2 :                                                                                         0.5*fgkMountingBlockSupportDownHeight - 0.5*fgkSSDLadderVerticalDisalignment,</span>
<span class="lineNum">    4632 </span><span class="lineCov">          4 :                                                                                         0.5*(fgkMountingBlockSupportWidth[1]</span>
<span class="lineNum">    4633 </span><span class="lineCov">          2 :                                                                                  -  fgkMountingBlockSupportWidth[0]),</span>
<span class="lineNum">    4634 </span><span class="lineCov">          2 :                                                                                         boxorigindown[i][1]);</span>
<span class="lineNum">    4635 </span>            :                                                                                         
<span class="lineNum">    4636 </span><span class="lineCov">          8 :         mountingblocksupportboxupshape[i][0] = new TGeoBBox(0.5*(mountingsupportedge[i]</span>
<span class="lineNum">    4637 </span><span class="lineCov">          2 :                                                                                  +  fgkSSDMountingBlockLength[0]),</span>
<span class="lineNum">    4638 </span><span class="lineCov">          2 :                                                                                         0.5*fgkMountingBlockSupportUpHeight[i] - 0.5*fgkSSDLadderVerticalDisalignment,</span>
<span class="lineNum">    4639 </span><span class="lineCov">          2 :                                                                                         0.5*fgkMountingBlockSupportWidth[0],</span>
<span class="lineNum">    4640 </span><span class="lineCov">          2 :                                                                                         boxoriginup[i][0]);</span>
<span class="lineNum">    4641 </span>            : 
<span class="lineNum">    4642 </span><span class="lineCov">          6 :         mountingblocksupportboxupshape[i][1] = new TGeoBBox(0.5*fgkSSDMountingBlockLength[0],</span>
<span class="lineNum">    4643 </span><span class="lineCov">          2 :                                                                                         0.5*fgkMountingBlockSupportUpHeight[i] - 0.5*fgkSSDLadderVerticalDisalignment,</span>
<span class="lineNum">    4644 </span><span class="lineCov">          4 :                                                                                         0.5*(fgkMountingBlockSupportWidth[1]</span>
<span class="lineNum">    4645 </span><span class="lineCov">          2 :                                                                      -  fgkMountingBlockSupportWidth[0]),</span>
<span class="lineNum">    4646 </span><span class="lineCov">          2 :                                                                                         boxoriginup[i][1]);</span>
<span class="lineNum">    4647 </span>            :         ///////////////////////////////////////
<span class="lineNum">    4648 </span>            :         // Adding the Volumes to Mother Volume    
<span class="lineNum">    4649 </span>            :         ///////////////////////////////////////
<span class="lineNum">    4650 </span><span class="lineCov">         12 :         for(Int_t j=0; j&lt;2; j++){</span>
<span class="lineNum">    4651 </span><span class="lineCov">          4 :           snprintf(mountingblocksupportboxdownname,100,&quot;MountingBlockSuppDownLay%dBox%d&quot;,i+5,j+1);</span>
<span class="lineNum">    4652 </span><span class="lineCov">          4 :           snprintf(mountingblocksupportboxupname,100,&quot;MountingBlockSuppUpLay%dBox%d&quot;,i+5,j+1);</span>
<span class="lineNum">    4653 </span><span class="lineCov">         12 :           mountingblocksupportboxdown[i][j] = new TGeoVolume(mountingblocksupportboxdownname,</span>
<span class="lineNum">    4654 </span><span class="lineCov">          4 :                                                              mountingblocksupportboxdownshape[i][j],</span>
<span class="lineNum">    4655 </span><span class="lineCov">          4 :                                                              fSSDCarbonFiberMedium);</span>
<span class="lineNum">    4656 </span><span class="lineCov">         12 :           mountingblocksupportboxup[i][j] = new TGeoVolume(mountingblocksupportboxupname,</span>
<span class="lineNum">    4657 </span><span class="lineCov">          4 :                                                            mountingblocksupportboxupshape[i][j],</span>
<span class="lineNum">    4658 </span><span class="lineCov">          4 :                                                            fSSDCarbonFiberMedium);</span>
<span class="lineNum">    4659 </span><span class="lineCov">          4 :                 mountingblocksupportboxdown[i][j]-&gt;SetLineColor(9);</span>
<span class="lineNum">    4660 </span><span class="lineCov">          4 :                 mountingblocksupportboxup[i][j]-&gt;SetLineColor(9);</span>
<span class="lineNum">    4661 </span><span class="lineCov">         24 :                 for(Int_t k=0; k&lt;2; k++){</span>
<span class="lineNum">    4662 </span><span class="lineCov">          8 :                         downmotherladdersupport[i]-&gt;AddNode(mountingblocksupportboxdown[i][j],k+1,laddersupportmatrix[k]);</span>
<span class="lineNum">    4663 </span><span class="lineCov">          8 :                         upmotherladdersupport[i]-&gt;AddNode(mountingblocksupportboxup[i][j],k+1,laddersupportmatrix[k]);</span>
<span class="lineNum">    4664 </span>            :                 }
<span class="lineNum">    4665 </span>            :         }
<span class="lineNum">    4666 </span><span class="lineCov">         12 :         for(Int_t k=0; k&lt;2; k++){</span>
<span class="lineNum">    4667 </span><span class="lineCov">          4 :                 downmotherladdersupport[i]-&gt;AddNode(centermountingblocksupport[i],k+1,laddersupportmatrix[k]);</span>
<span class="lineNum">    4668 </span><span class="lineCov">          4 :                 downmotherladdersupport[i]-&gt;AddNode(sidemountingblocksupport[i],k+1,laddersupportmatrix[k]);</span>
<span class="lineNum">    4669 </span><span class="lineCov">          4 :                 downmotherladdersupport[i]-&gt;AddNode(sideladdersupportpiece[i],k+1,laddersupportmatrix[k]);</span>
<span class="lineNum">    4670 </span><span class="lineCov">          4 :                 downmotherladdersupport[i]-&gt;AddNode(centerladdersupportpiece[i],k+1,laddersupportmatrix[k]);</span>
<span class="lineNum">    4671 </span><span class="lineCov">          4 :                 downmotherladdersupport[i]-&gt;AddNode(mountingblockpiecedown[i],k+1,laddersupportmatrix[k]);</span>
<span class="lineNum">    4672 </span><span class="lineCov">          4 :                 downmotherladdersupport[i]-&gt;AddNode(mountingblocksupportrapezoidown[i],k+1,laddersupportmatrix[k]);</span>
<span class="lineNum">    4673 </span><span class="lineCov">          4 :                 upmotherladdersupport[i]-&gt;AddNode(centermountingblocksupport[i],k+1,laddersupportmatrix[k]);</span>
<span class="lineNum">    4674 </span><span class="lineCov">          4 :                 upmotherladdersupport[i]-&gt;AddNode(sidemountingblocksupport[i],k+1,laddersupportmatrix[k]);</span>
<span class="lineNum">    4675 </span><span class="lineCov">          4 :                 upmotherladdersupport[i]-&gt;AddNode(sideladdersupportpiece[i],k+1,laddersupportmatrix[k]);</span>
<span class="lineNum">    4676 </span><span class="lineCov">          4 :                 upmotherladdersupport[i]-&gt;AddNode(centerladdersupportpiece[i],k+1,laddersupportmatrix[k]);</span>
<span class="lineNum">    4677 </span><span class="lineCov">          4 :                 upmotherladdersupport[i]-&gt;AddNode(mountingblockpieceup[i],k+1,laddersupportmatrix[k]);</span>
<span class="lineNum">    4678 </span><span class="lineCov">          4 :                 upmotherladdersupport[i]-&gt;AddNode(mountingblocksupportrapezoidup[i],k+1,laddersupportmatrix[k]);</span>
<span class="lineNum">    4679 </span>            :         }
<span class="lineNum">    4680 </span>            :   }
<span class="lineNum">    4681 </span><span class="lineCov">          1 :   TList* laddersupportlist = new TList();</span>
<span class="lineNum">    4682 </span><span class="lineCov">          1 :   laddersupportlist-&gt;Add(downmotherladdersupport[0]); </span>
<span class="lineNum">    4683 </span><span class="lineCov">          1 :   laddersupportlist-&gt;Add(upmotherladdersupport[0]); </span>
<span class="lineNum">    4684 </span><span class="lineCov">          1 :   laddersupportlist-&gt;Add(downmotherladdersupport[1]); </span>
<span class="lineNum">    4685 </span><span class="lineCov">          1 :   laddersupportlist-&gt;Add(upmotherladdersupport[1]); </span>
<span class="lineNum">    4686 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    4687 </span>            :   // Deallocating memory
<span class="lineNum">    4688 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    4689 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++){</span>
<span class="lineNum">    4690 </span><span class="lineCov">         88 :         for(Int_t j=0; j&lt;nedges+1; j++)</span>
<span class="lineNum">    4691 </span><span class="lineCov">         84 :                 delete vertex[i][j];</span>
<span class="lineNum">    4692 </span><span class="lineCov">          4 :         delete mountingsupportedgevector[i];</span>
<span class="lineNum">    4693 </span><span class="lineCov">          4 :         delete [] vertex[i];</span>
<span class="lineNum">    4694 </span><span class="lineCov">          4 :         delete vertexlist[i];</span>
<span class="lineNum">    4695 </span><span class="lineCov">          4 :         delete [] xsidevertex[i];</span>
<span class="lineNum">    4696 </span><span class="lineCov">          4 :         delete [] ysidevertex[i];</span>
<span class="lineNum">    4697 </span><span class="lineCov">          4 :         delete [] xcentervertex[i];</span>
<span class="lineNum">    4698 </span><span class="lineCov">          4 :         delete [] ycentervertex[i];</span>
<span class="lineNum">    4699 </span><span class="lineCov">          4 :         delete [] xsidelowervertex[i];</span>
<span class="lineNum">    4700 </span><span class="lineCov">          4 :         delete [] ysidelowervertex[i];</span>
<span class="lineNum">    4701 </span><span class="lineCov">          4 :         delete [] xcenterlowervertex[i];</span>
<span class="lineNum">    4702 </span><span class="lineCov">          4 :         delete [] ycenterlowervertex[i];</span>
<span class="lineNum">    4703 </span><span class="lineCov">          4 :         delete [] xmothervertex[i];</span>
<span class="lineNum">    4704 </span><span class="lineCov">          4 :         delete [] ymothervertex[i];</span>
<span class="lineNum">    4705 </span>            :   }
<span class="lineNum">    4706 </span><span class="lineCov">          2 :   delete [] xsidevertex;</span>
<span class="lineNum">    4707 </span><span class="lineCov">          2 :   delete [] ysidevertex;</span>
<span class="lineNum">    4708 </span><span class="lineCov">          2 :   delete [] xcentervertex;</span>
<span class="lineNum">    4709 </span><span class="lineCov">          2 :   delete [] ycentervertex;</span>
<span class="lineNum">    4710 </span><span class="lineCov">          2 :   delete [] xsidelowervertex;</span>
<span class="lineNum">    4711 </span><span class="lineCov">          2 :   delete [] ysidelowervertex;</span>
<span class="lineNum">    4712 </span><span class="lineCov">          2 :   delete [] xcenterlowervertex;</span>
<span class="lineNum">    4713 </span><span class="lineCov">          2 :   delete [] ycenterlowervertex;</span>
<span class="lineNum">    4714 </span><span class="lineCov">          2 :   delete globalrefladdersupportrot;</span>
<span class="lineNum">    4715 </span><span class="lineCov">          2 :   delete mountingblocksupportrot;</span>
<span class="lineNum">    4716 </span>            :   /////////////////////
<span class="lineNum">    4717 </span><span class="lineCov">          1 :   return laddersupportlist;     </span>
<a name="4718"><span class="lineNum">    4718 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">    4719 </span>            :  ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    4720 </span>            : void AliITSv11GeometrySSD::SetLadderSupport(Int_t nedges){ 
<span class="lineNum">    4721 </span>            : //////////////////////////////////////////
<span class="lineNum">    4722 </span>            : // Method Generating Ladder Support Ring
<span class="lineNum">    4723 </span>            : //////////////////////////////////////////
<span class="lineNum">    4724 </span><span class="lineCov">          2 :   if(!fCreateMaterials) CreateMaterials();</span>
<span class="lineNum">    4725 </span><span class="lineCov">          1 :   if(!fTransformationMatrices) CreateTransformationMatrices();</span>
<span class="lineNum">    4726 </span><span class="lineCov">          1 :   if(!fBasicObjects) CreateBasicObjects();</span>
<span class="lineNum">    4727 </span><span class="lineCov">          2 :   fLay5LadderSupportRing = new TGeoVolumeAssembly(&quot;Lay5LadderSupportRing&quot;);</span>
<span class="lineNum">    4728 </span><span class="lineCov">          2 :   fLay6LadderSupportRing = new TGeoVolumeAssembly(&quot;Lay6LadderSupportRing&quot;);</span>
<span class="lineNum">    4729 </span>            :     const Int_t kssdlayladdernumber[fgklayernumber] = 
<span class="lineNum">    4730 </span>            :                         {fgkSSDLay5LadderNumber,fgkSSDLay6LadderNumber};
<span class="lineNum">    4731 </span><span class="lineCov">          1 :   Double_t mountingsupportedge[fgklayernumber];</span>
<span class="lineNum">    4732 </span><span class="lineCov">          1 :   Double_t mountingblockratio[fgklayernumber];</span>
<span class="lineNum">    4733 </span><span class="lineCov">          1 :   Double_t theta[fgklayernumber];</span>
<span class="lineNum">    4734 </span><span class="lineCov">          1 :   Double_t phi[fgklayernumber];</span>
<span class="lineNum">    4735 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++){</span>
<span class="lineNum">    4736 </span><span class="lineCov">          2 :         mountingblockratio[i] = fgkSSDMountingBlockLength[0]/fgkMountingBlockSupportRadius[i];</span>
<span class="lineNum">    4737 </span><span class="lineCov">          4 :     mountingsupportedge[i]    = 0.5*fgkMountingBlockSupportRadius[i]</span>
<span class="lineNum">    4738 </span><span class="lineCov">          4 :                                                           *(TMath::Sqrt((2.-mountingblockratio[i])*(2.+mountingblockratio[i]))</span>
<span class="lineNum">    4739 </span><span class="lineCov">          2 :                                                           * TMath::Sin(2.0*TMath::Pi()/kssdlayladdernumber[i])</span>
<span class="lineNum">    4740 </span><span class="lineCov">          4 :                                                           - mountingblockratio[i]*(1.0+TMath::Cos(2.0*TMath::Pi()</span>
<span class="lineNum">    4741 </span><span class="lineCov">          2 :                                                           / kssdlayladdernumber[i])));</span>
<span class="lineNum">    4742 </span><span class="lineCov">          4 :     theta[i] = TMath::ASin(0.5*mountingblockratio[i]+mountingsupportedge[i]</span>
<span class="lineNum">    4743 </span><span class="lineCov">          2 :                          / fgkMountingBlockSupportRadius[i]);</span>
<span class="lineNum">    4744 </span><span class="lineCov">          2 :     phi[i]   = TMath::ASin(0.5*mountingblockratio[i]);</span>
<span class="lineNum">    4745 </span>            :   }
<span class="lineNum">    4746 </span><span class="lineCov">          1 :   TGeoRotation* globalrot = new TGeoRotation();</span>
<span class="lineNum">    4747 </span><span class="lineCov">          1 :   globalrot-&gt;SetAngles(0.,-90.,0.); </span>
<span class="lineNum">    4748 </span><span class="lineCov">          1 :   TGeoRotation** laddersupportrot[fgklayernumber];</span>
<span class="lineNum">    4749 </span><span class="lineCov">          1 :   TGeoHMatrix**  laddersupportmatrix[fgklayernumber];</span>
<span class="lineNum">    4750 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++){             </span>
<span class="lineNum">    4751 </span><span class="lineCov">          2 :         laddersupportrot[i] = new TGeoRotation*[kssdlayladdernumber[i]];</span>
<span class="lineNum">    4752 </span><span class="lineCov">          2 :         laddersupportmatrix[i] = new TGeoHMatrix*[kssdlayladdernumber[i]];</span>
<span class="lineNum">    4753 </span><span class="lineCov">        148 :         for(Int_t j=0; j&lt;kssdlayladdernumber[i]; j++){</span>
<span class="lineNum">    4754 </span><span class="lineCov">        144 :                 laddersupportrot[i][j] = new TGeoRotation();</span>
<span class="lineNum">    4755 </span><span class="lineCov">         72 :                 laddersupportrot[i][j]-&gt;SetAngles(j*(phi[i]+theta[i])*TMath::RadToDeg(),0.,0.);</span>
<span class="lineNum">    4756 </span><span class="lineCov">         72 :                 switch(i){</span>
<span class="lineNum">    4757 </span>            :                         case 0: //Ladder of Layer5  
<span class="lineNum">    4758 </span><span class="lineCov">        102 :                                 laddersupportmatrix[i][j] = new TGeoHMatrix((*laddersupportrot[i][j])*(*globalrot));</span>
<span class="lineNum">    4759 </span><span class="lineCov">        136 :                                 fLay5LadderSupportRing-&gt;AddNode(j%2==0?fLay5LadderSupport[0]:fLay5LadderSupport[1],j+1,</span>
<span class="lineNum">    4760 </span><span class="lineCov">         34 :                                                                             laddersupportmatrix[i][j]); </span>
<span class="lineNum">    4761 </span><span class="lineCov">         34 :                         break;</span>
<span class="lineNum">    4762 </span>            :                         case 1: //Ladder of Layer6 
<span class="lineNum">    4763 </span><span class="lineCov">        114 :                                 laddersupportmatrix[i][j] = new TGeoHMatrix((*laddersupportrot[i][j])*(*globalrot));</span>
<span class="lineNum">    4764 </span><span class="lineCov">        152 :                                 fLay6LadderSupportRing-&gt;AddNode(j%2==0?fLay6LadderSupport[0]:fLay6LadderSupport[1],j+1,</span>
<span class="lineNum">    4765 </span><span class="lineCov">         38 :                                                                               laddersupportmatrix[i][j]); </span>
<span class="lineNum">    4766 </span><span class="lineCov">         38 :                         break;</span>
<span class="lineNum">    4767 </span>            :                 }
<span class="lineNum">    4768 </span>            :     }
<span class="lineNum">    4769 </span>            :   }
<span class="lineNum">    4770 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    4771 </span>            :   // Creating Lower Ladder Support 
<span class="lineNum">    4772 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    4773 </span><span class="lineCov">          1 :   TVector3** ringsupportvertex[fgklayernumber];         </span>
<span class="lineNum">    4774 </span><span class="lineCov">          1 :   Double_t angle = 360./nedges;</span>
<span class="lineNum">    4775 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++){</span>
<span class="lineNum">    4776 </span><span class="lineCov">          2 :     ringsupportvertex[i] = new TVector3*[2*kssdlayladdernumber[i]+3+nedges];    </span>
<span class="lineNum">    4777 </span><span class="lineCov">          6 :         ringsupportvertex[i][0] = new TVector3(0.,fgkMountingBlockSupportRadius[i]</span>
<span class="lineNum">    4778 </span><span class="lineCov">          2 :                                            * TMath::Cos(theta[i]), 0);</span>
<span class="lineNum">    4779 </span><span class="lineCov">          6 :         ringsupportvertex[i][1] = new TVector3(-0.5*fgkSSDMountingBlockLength[0]</span>
<span class="lineNum">    4780 </span><span class="lineCov">          2 :                                                         -                          mountingsupportedge[i],</span>
<span class="lineNum">    4781 </span><span class="lineCov">          2 :                                                ringsupportvertex[i][0]-&gt;Y(), 0);</span>
<span class="lineNum">    4782 </span><span class="lineCov">          6 :         ringsupportvertex[i][2] = new TVector3(0.5*fgkSSDMountingBlockLength[0],</span>
<span class="lineNum">    4783 </span><span class="lineCov">          2 :                                                ringsupportvertex[i][1]-&gt;Y(),0);                                                                              </span>
<span class="lineNum">    4784 </span><span class="lineCov">          2 :     ringsupportvertex[i][2]-&gt;RotateZ(theta[i]+phi[i]);</span>
<span class="lineNum">    4785 </span><span class="lineCov">        144 :         for(Int_t j=1; j&lt;kssdlayladdernumber[i]; j++){</span>
<span class="lineNum">    4786 </span><span class="lineCov">        140 :            ringsupportvertex[i][2*j+1] = new TVector3(*ringsupportvertex[i][1]);        </span>
<span class="lineNum">    4787 </span><span class="lineCov">         70 :            ringsupportvertex[i][2*j+1]-&gt;RotateZ(j*(theta[i]+phi[i]));        </span>
<span class="lineNum">    4788 </span><span class="lineCov">        140 :            ringsupportvertex[i][2*j+2] = new TVector3(*ringsupportvertex[i][2]);        </span>
<span class="lineNum">    4789 </span><span class="lineCov">         70 :            ringsupportvertex[i][2*j+2]-&gt;RotateZ(j*(theta[i]+phi[i]));        </span>
<span class="lineNum">    4790 </span>            :         }
<span class="lineNum">    4791 </span><span class="lineCov">          4 :         ringsupportvertex[i][2*kssdlayladdernumber[i]+1] = new TVector3(*ringsupportvertex[i][0]);</span>
<span class="lineNum">    4792 </span><span class="lineCov">        408 :     for(Int_t j=0; j&lt;nedges+1; j++){</span>
<span class="lineNum">    4793 </span><span class="lineCov">        202 :                 ringsupportvertex[i][2*kssdlayladdernumber[i]+2+j] = </span>
<span class="lineNum">    4794 </span><span class="lineCov">        606 :                         new TVector3((ringsupportvertex[i][0]-&gt;Y()-fgkLadderSupportHeight)*CosD(90.0-j*angle),</span>
<span class="lineNum">    4795 </span><span class="lineCov">        404 :                                (ringsupportvertex[i][0]-&gt;Y()-fgkLadderSupportHeight)*SinD(90.0-j*angle), 0);</span>
<span class="lineNum">    4796 </span>            :         }
<span class="lineNum">    4797 </span>            :   }
<span class="lineNum">    4798 </span><span class="lineCov">          1 :   Double_t **xmothervertex = new Double_t*[fgklayernumber];</span>
<span class="lineNum">    4799 </span><span class="lineCov">          1 :   Double_t **ymothervertex = new Double_t*[fgklayernumber];</span>
<span class="lineNum">    4800 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++){</span>
<span class="lineNum">    4801 </span><span class="lineCov">          2 :         xmothervertex[i] = new Double_t[2*kssdlayladdernumber[i]+3+nedges];</span>
<span class="lineNum">    4802 </span><span class="lineCov">          2 :         ymothervertex[i] = new Double_t[2*kssdlayladdernumber[i]+3+nedges];</span>
<span class="lineNum">    4803 </span><span class="lineCov">        704 :         for(Int_t j=0; j&lt;2*kssdlayladdernumber[i]+3+nedges; j++){</span>
<span class="lineNum">    4804 </span><span class="lineCov">        350 :                 xmothervertex[i][j] = ringsupportvertex[i][j]-&gt;X();</span>
<span class="lineNum">    4805 </span><span class="lineCov">        350 :                 ymothervertex[i][j] = ringsupportvertex[i][j]-&gt;Y();</span>
<span class="lineNum">    4806 </span>            :         }
<span class="lineNum">    4807 </span>            :   }
<span class="lineNum">    4808 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    4809 </span>            : // Start Corrections 13/06/08
<span class="lineNum">    4810 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    4811 </span><span class="lineCov">          1 :   char lowerladderpconsupportname[100];</span>
<span class="lineNum">    4812 </span><span class="lineCov">          1 :   TGeoPcon* lowerladderpconsupportshape[fgklayernumber];</span>
<span class="lineNum">    4813 </span><span class="lineCov">          1 :   TGeoVolume* lowerladderpconsupport[fgklayernumber]; </span>
<span class="lineNum">    4814 </span><span class="lineCov">          1 :   Double_t lowerladderpconezsection[2] = {0.,fgkMountingBlockSupportWidth[1]};</span>
<span class="lineNum">    4815 </span><span class="lineCov">          1 :   Double_t lowerladderpconradiusmax[fgklayernumber];</span>
<span class="lineNum">    4816 </span><span class="lineCov">          1 :   Double_t lowerladderpconradiusmin[fgklayernumber];</span>
<span class="lineNum">    4817 </span><span class="lineCov">          1 :   TGeoRotation* lowerladdersupportrot = new TGeoRotation();</span>
<span class="lineNum">    4818 </span><span class="lineCov">          1 :   lowerladdersupportrot-&gt;SetAngles(90.,180.,-90);</span>
<span class="lineNum">    4819 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++){</span>
<span class="lineNum">    4820 </span><span class="lineCov">          4 :         lowerladderpconradiusmax[i] = fgkMountingBlockSupportRadius[i]</span>
<span class="lineNum">    4821 </span><span class="lineCov">          2 :                                                                 *                          TMath::Cos(theta[i]);</span>
<span class="lineNum">    4822 </span><span class="lineCov">          2 :     lowerladderpconradiusmin[i] = lowerladderpconradiusmax[i]-fgkLadderSupportHeight;</span>
<span class="lineNum">    4823 </span>            :   } 
<span class="lineNum">    4824 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++){</span>
<span class="lineNum">    4825 </span>            : ///////////////////////////  Modified Version ?///////////////////
<span class="lineNum">    4826 </span><span class="lineCov">          4 :     lowerladderpconsupportshape[i] = new TGeoPcon(0.,360.,2);</span>
<span class="lineNum">    4827 </span><span class="lineCov">         16 :         for(Int_t j=0; j&lt;2; j++) lowerladderpconsupportshape[i]-&gt;DefineSection(j,</span>
<span class="lineNum">    4828 </span><span class="lineCov">          4 :                                                          lowerladderpconezsection[j],lowerladderpconradiusmin[i],</span>
<span class="lineNum">    4829 </span><span class="lineCov">          4 :                                                          lowerladderpconradiusmax[i]);</span>
<span class="lineNum">    4830 </span><span class="lineCov">          2 :         snprintf(lowerladderpconsupportname,100,&quot;LowerLadderPConSupportNameLay%d&quot;,i+5);</span>
<span class="lineNum">    4831 </span><span class="lineCov">          4 :         lowerladderpconsupport[i] = new TGeoVolume(lowerladderpconsupportname,lowerladderpconsupportshape[i],fSSDSupportRingAl);</span>
<span class="lineNum">    4832 </span><span class="lineCov">          2 :     lowerladderpconsupport[i]-&gt;SetLineColor(fColorAl);</span>
<span class="lineNum">    4833 </span><span class="lineCov">          6 :         (i==0 ? fLay5LadderSupportRing: fLay6LadderSupportRing)-&gt;AddNode(lowerladderpconsupport[i],1);</span>
<span class="lineNum">    4834 </span><span class="lineCov">          6 :         (i==0 ? fLay5LadderSupportRing: fLay6LadderSupportRing)-&gt;AddNode(lowerladderpconsupport[i],2,lowerladdersupportrot);</span>
<span class="lineNum">    4835 </span>            :  }
<span class="lineNum">    4836 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    4837 </span>            : // End Corrections 13/06/08
<span class="lineNum">    4838 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    4839 </span>            :   /*char lowerladdersupportname[30];
<span class="lineNum">    4840 </span>            :   TGeoXtru* lowerladdersupportshape[fgklayernumber];
<span class="lineNum">    4841 </span>            :   TGeoVolume* lowerladdersupport[fgklayernumber];
<span class="lineNum">    4842 </span>            :   TGeoRotation* lowerladdersupportrot = new TGeoRotation();
<span class="lineNum">    4843 </span>            :   lowerladdersupportrot-&gt;SetAngles(90.,180.,-90);
<span class="lineNum">    4844 </span>            :   for(Int_t i=0; i&lt;fgklayernumber; i++){
<span class="lineNum">    4845 </span>            :         lowerladdersupportshape[i] = new TGeoXtru(2);
<span class="lineNum">    4846 </span>            :         lowerladdersupportshape[i]-&gt;DefinePolygon(2*kssdlayladdernumber[i]+3+nedges,
<span class="lineNum">    4847 </span>            :                                                                                           xmothervertex[i],ymothervertex[i]);
<span class="lineNum">    4848 </span>            :         lowerladdersupportshape[i]-&gt;DefineSection(0,0.);
<span class="lineNum">    4849 </span>            :     lowerladdersupportshape[i]-&gt;DefineSection(1,fgkMountingBlockSupportWidth[1]);
<span class="lineNum">    4850 </span>            :         sprintf(lowerladdersupportname,&quot;LowerLadderSupportNameLay%d&quot;,i+5);
<span class="lineNum">    4851 </span>            :     lowerladdersupport[i] = new TGeoVolume(lowerladdersupportname,
<span class="lineNum">    4852 </span>            :                                                         lowerladdersupportshape[i],fSSDSupportRingAl);
<span class="lineNum">    4853 </span>            :         lowerladdersupport[i]-&gt;SetLineColor(fColorAl);
<span class="lineNum">    4854 </span>            :         (i==0 ? fLay5LadderSupportRing: fLay6LadderSupportRing)-&gt;AddNode(lowerladdersupport[i],1);
<span class="lineNum">    4855 </span>            :         (i==0 ? fLay5LadderSupportRing: fLay6LadderSupportRing)-&gt;AddNode(lowerladdersupport[i],2,lowerladdersupportrot);
<span class="lineNum">    4856 </span>            :   }*/
<span class="lineNum">    4857 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    4858 </span>            :   // Deallocating memory
<span class="lineNum">    4859 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    4860 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++){</span>
<span class="lineNum">    4861 </span><span class="lineCov">        704 :         for(Int_t j=0; j&lt;2*kssdlayladdernumber[i]+3+nedges; j++)</span>
<span class="lineNum">    4862 </span><span class="lineCov">        700 :                 delete ringsupportvertex[i][j];</span>
<span class="lineNum">    4863 </span><span class="lineCov">          4 :         delete [] ringsupportvertex[i];</span>
<span class="lineNum">    4864 </span>            :   }
<span class="lineNum">    4865 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++){</span>
<span class="lineNum">    4866 </span><span class="lineCov">          4 :         delete [] xmothervertex[i];</span>
<span class="lineNum">    4867 </span><span class="lineCov">          4 :         delete [] ymothervertex[i];</span>
<span class="lineNum">    4868 </span>            :   }
<span class="lineNum">    4869 </span><span class="lineCov">          2 :   delete [] xmothervertex;</span>
<span class="lineNum">    4870 </span><span class="lineCov">          2 :   delete [] ymothervertex; </span>
<span class="lineNum">    4871 </span><span class="lineCov">          2 :   delete globalrot;</span>
<span class="lineNum">    4872 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;fgklayernumber; i++){</span>
<span class="lineNum">    4873 </span><span class="lineCov">        148 :         for(Int_t j=0; j&lt;kssdlayladdernumber[i]; j++)</span>
<span class="lineNum">    4874 </span><span class="lineCov">        144 :                 delete laddersupportrot[i][j];</span>
<span class="lineNum">    4875 </span><span class="lineCov">          4 :         delete [] laddersupportrot[i];</span>
<span class="lineNum">    4876 </span>            :   }
<span class="lineNum">    4877 </span>            :   
<span class="lineNum">    4878 </span><span class="lineCov">          1 :   fLay5LadderSupportRing-&gt;GetShape()-&gt;ComputeBBox(); //RS: enforce recompting of BBox</span>
<span class="lineNum">    4879 </span><span class="lineCov">          1 :   fLay6LadderSupportRing-&gt;GetShape()-&gt;ComputeBBox();</span>
<span class="lineNum">    4880 </span>            :   //
<span class="lineNum">    4881 </span>            : 
<a name="4882"><span class="lineNum">    4882 </span><span class="lineCov">          1 :  }  </span></a>
<span class="lineNum">    4883 </span>            :  ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    4884 </span>            :  TGeoVolume* AliITSv11GeometrySSD::GetEndCapCoverPlate(){
<span class="lineNum">    4885 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    4886 </span>            :   // Method generating Endcap CoverPlate
<span class="lineNum">    4887 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    4888 </span>            :   // Holes Definition 
<span class="lineNum">    4889 </span>            :   ///////////////////
<span class="lineNum">    4890 </span>            :   Int_t nendcapcoverplateholedges = 30;
<span class="lineNum">    4891 </span>            :   const Int_t kendcapcoverplatesmallholenumber[2] = {4,9}; 
<span class="lineNum">    4892 </span><span class="lineCov">          3 :   Double_t holesection[2] = {-0.5*fgkEndCapCoverPlateThickness,</span>
<span class="lineNum">    4893 </span><span class="lineCov">          1 :                                                           0.5*fgkEndCapCoverPlateThickness};</span>
<span class="lineNum">    4894 </span><span class="lineCov">          2 :   TGeoShape* endcapcoverplatesmallholeshape = GetHoleShape(fgkEndCapCoverPlateSmallHoleRadius,</span>
<span class="lineNum">    4895 </span><span class="lineCov">          1 :                                                                                                               nendcapcoverplateholedges,holesection);</span>
<span class="lineNum">    4896 </span><span class="lineCov">          2 :   TGeoVolume* endcapcoverplatesmallhole = new TGeoVolume(&quot;EndCapCoverPlateSmallHole&quot;,</span>
<span class="lineNum">    4897 </span><span class="lineCov">          1 :                                                                                   endcapcoverplatesmallholeshape,fSSDAlCoolBlockMedium);</span>
<span class="lineNum">    4898 </span><span class="lineCov">          1 :   endcapcoverplatesmallhole-&gt;SetLineColor(6);</span>
<span class="lineNum">    4899 </span><span class="lineCov">          1 :   TGeoShape* endcapcoverplatebigholeshape = GetHoleShape(fgkEndCapCoverPlateBigHoleRadius,</span>
<span class="lineNum">    4900 </span>            :                                                                                                               nendcapcoverplateholedges,holesection);
<span class="lineNum">    4901 </span><span class="lineCov">          2 :   TGeoVolume* endcapcoverplatebighole = new TGeoVolume(&quot;EndCapCoverPlateBigHole&quot;,</span>
<span class="lineNum">    4902 </span><span class="lineCov">          1 :                                                                                   endcapcoverplatebigholeshape,fSSDAlCoolBlockMedium);</span>
<span class="lineNum">    4903 </span><span class="lineCov">          1 :   endcapcoverplatebighole-&gt;SetLineColor(6);</span>
<span class="lineNum">    4904 </span>            :   //////////////////////////
<span class="lineNum">    4905 </span>            :   // Screw Piece Definition 
<span class="lineNum">    4906 </span>            :   //////////////////////////
<span class="lineNum">    4907 </span><span class="lineCov">          1 :   Double_t smallscrewangle = 360.0/nendcapcoverplateholedges;</span>
<span class="lineNum">    4908 </span><span class="lineCov">          3 :   TGeoTube* endcapsmallscrewpieceshape = new TGeoTube(0.0,fgkEndCapCoverPlateSmallHoleRadius*</span>
<span class="lineNum">    4909 </span><span class="lineCov">          1 :                                                                                                       CosD(0.5*smallscrewangle),</span>
<span class="lineNum">    4910 </span><span class="lineCov">          1 :                                                                                                       0.5*fgkEndCapCoverPlateThickness);</span>
<span class="lineNum">    4911 </span><span class="lineCov">          2 :   TGeoVolume* endcapsmallscrewpiece = new TGeoVolume(&quot;EndCapCoverPlateSmallScrewPiece&quot;,</span>
<span class="lineNum">    4912 </span><span class="lineCov">          1 :                                                                                                 endcapsmallscrewpieceshape,</span>
<span class="lineNum">    4913 </span><span class="lineCov">          1 :                                                                                                 fSSDCoolingTubePhynox);</span>
<span class="lineNum">    4914 </span><span class="lineCov">          1 :   endcapsmallscrewpiece-&gt;SetLineColor(fColorPhynox);</span>
<span class="lineNum">    4915 </span>            :   ///////////////////
<span class="lineNum">    4916 </span>            :   // Box Definition 
<span class="lineNum">    4917 </span>            :   ///////////////////
<span class="lineNum">    4918 </span>            :   TGeoBBox* endcapcoverplateboxshape[4];
<span class="lineNum">    4919 </span>            :   TGeoVolume* endcapcoverplatebox[4];
<span class="lineNum">    4920 </span><span class="lineCov">          1 :   Double_t boxorigin[5][3];</span>
<span class="lineNum">    4921 </span><span class="lineCov">          1 :   boxorigin[0][0] = 0.;</span>
<span class="lineNum">    4922 </span><span class="lineCov">          1 :   boxorigin[0][1] = 0.5*fgkEndCapCoverPlateSmallHoleSeparation[2];</span>
<span class="lineNum">    4923 </span><span class="lineCov">          1 :   boxorigin[0][2] = 0.;</span>
<span class="lineNum">    4924 </span>            : 
<span class="lineNum">    4925 </span><span class="lineCov">          1 :   boxorigin[1][0] = 0.5*fgkEndCapCoverPlateSmallHoleSeparation[0];</span>
<span class="lineNum">    4926 </span><span class="lineCov">          1 :   boxorigin[1][1] = 4.*fgkEndCapCoverPlateSmallHoleSeparation[2];</span>
<span class="lineNum">    4927 </span><span class="lineCov">          1 :   boxorigin[1][2] = 0.;</span>
<span class="lineNum">    4928 </span>            : 
<span class="lineNum">    4929 </span><span class="lineCov">          2 :   boxorigin[2][0] = 1.5*fgkEndCapCoverPlateSmallHoleSeparation[0]</span>
<span class="lineNum">    4930 </span><span class="lineCov">          1 :                                   + fgkEndCapCoverPlateSmallHoleSeparation[1];</span>
<span class="lineNum">    4931 </span><span class="lineCov">          1 :   boxorigin[2][1] = boxorigin[1][1];</span>
<span class="lineNum">    4932 </span><span class="lineCov">          1 :   boxorigin[2][2] = 0.;</span>
<span class="lineNum">    4933 </span>            : 
<span class="lineNum">    4934 </span><span class="lineCov">          2 :   boxorigin[3][0] = fgkEndCapCoverPlateSmallHoleSeparation[0]</span>
<span class="lineNum">    4935 </span><span class="lineCov">          1 :                                   + 0.5*fgkEndCapCoverPlateSmallHoleSeparation[1];</span>
<span class="lineNum">    4936 </span><span class="lineCov">          1 :   boxorigin[3][1] = boxorigin[1][1];</span>
<span class="lineNum">    4937 </span><span class="lineCov">          1 :   boxorigin[3][2] = 0.;</span>
<span class="lineNum">    4938 </span>            : 
<span class="lineNum">    4939 </span><span class="lineCov">          2 :   endcapcoverplateboxshape[0] = new TGeoBBox(fgkEndCapCoverPlateSmallHoleRadius,</span>
<span class="lineNum">    4940 </span><span class="lineCov">          2 :                                                                                 0.5*(fgkEndCapCoverPlateSmallHoleSeparation[2]</span>
<span class="lineNum">    4941 </span><span class="lineCov">          1 :                                                  -              2.*fgkEndCapCoverPlateSmallHoleRadius),</span>
<span class="lineNum">    4942 </span><span class="lineCov">          1 :                                                                             0.5*fgkEndCapCoverPlateThickness,boxorigin[0]);</span>
<span class="lineNum">    4943 </span>            : 
<span class="lineNum">    4944 </span><span class="lineCov">          3 :   endcapcoverplateboxshape[1] = new TGeoBBox(0.5*(fgkEndCapCoverPlateSmallHoleSeparation[0]</span>
<span class="lineNum">    4945 </span><span class="lineCov">          1 :                                                                         -2.*fgkEndCapCoverPlateSmallHoleRadius),</span>
<span class="lineNum">    4946 </span><span class="lineCov">          1 :                                                                                      4.*fgkEndCapCoverPlateSmallHoleSeparation[2]</span>
<span class="lineNum">    4947 </span><span class="lineCov">          1 :                                                           +                              fgkEndCapCoverPlateSmallHoleRadius,</span>
<span class="lineNum">    4948 </span><span class="lineCov">          1 :                                                                                  0.5*fgkEndCapCoverPlateThickness,boxorigin[1]);</span>
<span class="lineNum">    4949 </span>            : 
<span class="lineNum">    4950 </span><span class="lineCov">          3 :   endcapcoverplateboxshape[2] = new TGeoBBox(0.5*(fgkEndCapCoverPlateSmallHoleSeparation[0]</span>
<span class="lineNum">    4951 </span><span class="lineCov">          1 :                                                                         -2.*fgkEndCapCoverPlateSmallHoleRadius),</span>
<span class="lineNum">    4952 </span><span class="lineCov">          1 :                                                                                      4.*fgkEndCapCoverPlateSmallHoleSeparation[2]</span>
<span class="lineNum">    4953 </span><span class="lineCov">          1 :                                                           +                              fgkEndCapCoverPlateSmallHoleRadius,</span>
<span class="lineNum">    4954 </span><span class="lineCov">          1 :                                                                                  0.5*fgkEndCapCoverPlateThickness,boxorigin[2]);</span>
<span class="lineNum">    4955 </span>            : 
<span class="lineNum">    4956 </span><span class="lineCov">          3 :   endcapcoverplateboxshape[3] = new TGeoBBox(0.5*(fgkEndCapCoverPlateSmallHoleSeparation[1]</span>
<span class="lineNum">    4957 </span><span class="lineCov">          1 :                                                                         -2.*fgkEndCapCoverPlateSmallHoleRadius),</span>
<span class="lineNum">    4958 </span><span class="lineCov">          1 :                                                                                      4.*fgkEndCapCoverPlateSmallHoleSeparation[2]</span>
<span class="lineNum">    4959 </span><span class="lineCov">          1 :                                                           +                              fgkEndCapCoverPlateSmallHoleRadius,</span>
<span class="lineNum">    4960 </span><span class="lineCov">          1 :                                                                                  0.5*fgkEndCapCoverPlateThickness,boxorigin[3]);</span>
<span class="lineNum">    4961 </span>            :   
<span class="lineNum">    4962 </span><span class="lineCov">          2 :   endcapcoverplatebox[0] = new TGeoVolume(&quot;EndCapCoverPlateBox1&quot;,endcapcoverplateboxshape[0],</span>
<span class="lineNum">    4963 </span><span class="lineCov">          1 :                                                                            fSSDAlCoolBlockMedium);</span>
<span class="lineNum">    4964 </span><span class="lineCov">          2 :   endcapcoverplatebox[1] = new TGeoVolume(&quot;EndCapCoverPlateBox2&quot;,endcapcoverplateboxshape[1],</span>
<span class="lineNum">    4965 </span><span class="lineCov">          1 :                                                                            fSSDAlCoolBlockMedium);</span>
<span class="lineNum">    4966 </span><span class="lineCov">          2 :   endcapcoverplatebox[2] = new TGeoVolume(&quot;EndCapCoverPlateBox3&quot;,endcapcoverplateboxshape[2],</span>
<span class="lineNum">    4967 </span><span class="lineCov">          1 :                                                                            fSSDAlCoolBlockMedium);</span>
<span class="lineNum">    4968 </span><span class="lineCov">          2 :   endcapcoverplatebox[3] = new TGeoVolume(&quot;EndCapCoverPlateBox4&quot;,endcapcoverplateboxshape[3],</span>
<span class="lineNum">    4969 </span><span class="lineCov">          1 :                                                                            fSSDAlCoolBlockMedium);</span>
<span class="lineNum">    4970 </span><span class="lineCov">          1 :   endcapcoverplatebox[0]-&gt;SetLineColor(6);</span>
<span class="lineNum">    4971 </span><span class="lineCov">          1 :   endcapcoverplatebox[1]-&gt;SetLineColor(6);</span>
<span class="lineNum">    4972 </span><span class="lineCov">          1 :   endcapcoverplatebox[2]-&gt;SetLineColor(6);</span>
<span class="lineNum">    4973 </span><span class="lineCov">          1 :   endcapcoverplatebox[3]-&gt;SetLineColor(6);</span>
<span class="lineNum">    4974 </span><span class="lineCov">          1 :   Double_t endcapfillingboxorigin[3] = {fgkEndCapCoverPlateSmallHoleSeparation[0],0.,0.};</span>
<span class="lineNum">    4975 </span><span class="lineCov">          2 :   TGeoBBox* endcapfillingboxshape = new TGeoBBox(fgkEndCapCoverPlateSmallHoleRadius,</span>
<span class="lineNum">    4976 </span>            :                                                                                         fgkEndCapCoverPlateSmallHoleRadius,
<span class="lineNum">    4977 </span><span class="lineCov">          1 :                                                                                         0.5*fgkEndCapCoverPlateThickness,</span>
<span class="lineNum">    4978 </span><span class="lineCov">          1 :                                                                                         endcapfillingboxorigin);</span>
<span class="lineNum">    4979 </span><span class="lineCov">          2 :   TGeoVolume* endcapfillingbox = new TGeoVolume(&quot;EndCapFillingBox&quot;,endcapfillingboxshape,</span>
<span class="lineNum">    4980 </span><span class="lineCov">          1 :                                                                            fSSDAlCoolBlockMedium);</span>
<span class="lineNum">    4981 </span><span class="lineCov">          1 :   endcapfillingbox-&gt;SetLineColor(6);</span>
<span class="lineNum">    4982 </span>            :   ////////////////////////////
<span class="lineNum">    4983 </span>            :   // Contour shape Definition 
<span class="lineNum">    4984 </span>            :   ////////////////////////////
<span class="lineNum">    4985 </span>            :   const Int_t kcontourvertexnumber = 10;
<span class="lineNum">    4986 </span>            :   Double_t xcontourvertex[kcontourvertexnumber];
<span class="lineNum">    4987 </span>            :   Double_t ycontourvertex[kcontourvertexnumber];
<span class="lineNum">    4988 </span><span class="lineCov">          1 :   xcontourvertex[0] = -fgkEndCapCoverPlateLength[0];</span>
<span class="lineNum">    4989 </span>            :   xcontourvertex[1] = xcontourvertex[0];
<span class="lineNum">    4990 </span><span class="lineCov">          1 :   xcontourvertex[2] = fgkEndCapCoverPlateLength[1]-xcontourvertex[0];</span>
<span class="lineNum">    4991 </span>            :   xcontourvertex[3] = xcontourvertex[2];
<span class="lineNum">    4992 </span><span class="lineCov">          1 :   xcontourvertex[4] = -fgkEndCapCoverPlateSmallHoleRadius;</span>
<span class="lineNum">    4993 </span>            :   xcontourvertex[5] = xcontourvertex[4];
<span class="lineNum">    4994 </span>            :   xcontourvertex[6] = fgkEndCapCoverPlateLength[1]+fgkEndCapCoverPlateSmallHoleRadius;
<span class="lineNum">    4995 </span>            :   xcontourvertex[7] = xcontourvertex[6];
<span class="lineNum">    4996 </span>            :   xcontourvertex[8] = xcontourvertex[4];
<span class="lineNum">    4997 </span>            :   xcontourvertex[9] = xcontourvertex[8];
<span class="lineNum">    4998 </span><span class="lineCov">          2 :   ycontourvertex[0] = -0.5*(fgkEndCapCoverPlateWidth[0]-fgkEndCapCoverPlateWidth[2]</span>
<span class="lineNum">    4999 </span><span class="lineCov">          1 :                                         - (kendcapcoverplatesmallholenumber[1]-1)</span>
<span class="lineNum">    5000 </span><span class="lineCov">          1 :                                         * fgkEndCapCoverPlateSmallHoleSeparation[2]);</span>
<span class="lineNum">    5001 </span>            :   ycontourvertex[1] = (kendcapcoverplatesmallholenumber[1]-1)
<span class="lineNum">    5002 </span><span class="lineCov">          1 :                                         * fgkEndCapCoverPlateSmallHoleSeparation[2]-ycontourvertex[0];</span>
<span class="lineNum">    5003 </span>            :   ycontourvertex[2] = ycontourvertex[1];
<span class="lineNum">    5004 </span>            :   ycontourvertex[3] = ycontourvertex[0];
<span class="lineNum">    5005 </span>            :   ycontourvertex[4] = ycontourvertex[3];
<span class="lineNum">    5006 </span>            :   ycontourvertex[5] = -fgkEndCapCoverPlateSmallHoleRadius;
<span class="lineNum">    5007 </span>            :   ycontourvertex[6] = ycontourvertex[5];
<span class="lineNum">    5008 </span>            :   ycontourvertex[7] = (kendcapcoverplatesmallholenumber[1]-1)
<span class="lineNum">    5009 </span>            :                                         * fgkEndCapCoverPlateSmallHoleSeparation[2]
<span class="lineNum">    5010 </span>            :                                         + fgkEndCapCoverPlateSmallHoleRadius;
<span class="lineNum">    5011 </span>            :   ycontourvertex[8] = ycontourvertex[7];
<span class="lineNum">    5012 </span>            :   ycontourvertex[9] = ycontourvertex[0];
<span class="lineNum">    5013 </span>            : 
<span class="lineNum">    5014 </span>            :   Double_t xboxin, dxboxin, yboxin, dyboxin;
<span class="lineNum">    5015 </span>            :   Double_t xboxout, dxboxout, yboxout, dyboxout;
<span class="lineNum">    5016 </span>            :   Double_t coordmin, coordmax;
<span class="lineNum">    5017 </span>            :   coordmin = -fgkEndCapCoverPlateLength[0];
<span class="lineNum">    5018 </span><span class="lineCov">          1 :   coordmax = fgkEndCapCoverPlateLength[1]-xcontourvertex[0];</span>
<span class="lineNum">    5019 </span><span class="lineCov">          1 :   xboxout = 0.5*(coordmin+coordmax);</span>
<span class="lineNum">    5020 </span><span class="lineCov">          1 :   dxboxout = 0.5*(coordmax-coordmin);</span>
<span class="lineNum">    5021 </span>            :   coordmin = -0.5*(fgkEndCapCoverPlateWidth[0]-fgkEndCapCoverPlateWidth[2]
<span class="lineNum">    5022 </span>            :                                         - (kendcapcoverplatesmallholenumber[1]-1)
<span class="lineNum">    5023 </span>            :                                         * fgkEndCapCoverPlateSmallHoleSeparation[2]);
<span class="lineNum">    5024 </span>            :   coordmax = (kendcapcoverplatesmallholenumber[1]-1)
<span class="lineNum">    5025 </span>            :                                         * fgkEndCapCoverPlateSmallHoleSeparation[2]-ycontourvertex[0];
<span class="lineNum">    5026 </span><span class="lineCov">          1 :   yboxout = 0.5*(coordmin+coordmax);</span>
<span class="lineNum">    5027 </span><span class="lineCov">          1 :   dyboxout = 0.5*(coordmax-coordmin);</span>
<span class="lineNum">    5028 </span><span class="lineCov">          1 :   coordmin = -fgkEndCapCoverPlateSmallHoleRadius;</span>
<span class="lineNum">    5029 </span><span class="lineCov">          1 :   coordmax = fgkEndCapCoverPlateLength[1]+fgkEndCapCoverPlateSmallHoleRadius;</span>
<span class="lineNum">    5030 </span><span class="lineCov">          1 :   xboxin = 0.5*(coordmin+coordmax);</span>
<span class="lineNum">    5031 </span><span class="lineCov">          1 :   dxboxin = 0.5*(coordmax-coordmin);</span>
<span class="lineNum">    5032 </span>            :   coordmin = -fgkEndCapCoverPlateSmallHoleRadius;
<span class="lineNum">    5033 </span>            :   coordmax = (kendcapcoverplatesmallholenumber[1]-1)
<span class="lineNum">    5034 </span>            :                                         * fgkEndCapCoverPlateSmallHoleSeparation[2]
<span class="lineNum">    5035 </span><span class="lineCov">          1 :                                         + fgkEndCapCoverPlateSmallHoleRadius;</span>
<span class="lineNum">    5036 </span><span class="lineCov">          1 :   yboxin = 0.5*(coordmin+coordmax);</span>
<span class="lineNum">    5037 </span><span class="lineCov">          1 :   dyboxin = 0.5*(coordmax-coordmin);</span>
<span class="lineNum">    5038 </span><span class="lineCov">          1 :   new TGeoBBox(&quot;EndCapCoverPlateContourBoxOut&quot;, dxboxout, dyboxout, 0.5*fgkEndCapCoverPlateThickness);</span>
<span class="lineNum">    5039 </span><span class="lineCov">          1 :   TGeoTranslation *trendCapCoverPlateContourboxout = new TGeoTranslation(&quot;SSD_trEndCapCoverPlateContourBoxOut&quot;,</span>
<span class="lineNum">    5040 </span>            :                                                          xboxout, yboxout, 0.);
<span class="lineNum">    5041 </span><span class="lineCov">          1 :   trendCapCoverPlateContourboxout-&gt;RegisterYourself();</span>
<span class="lineNum">    5042 </span><span class="lineCov">          1 :   new TGeoBBox(&quot;EndCapCoverPlateContourBoxIn&quot;,  dxboxin, dyboxin, 0.5*fgkEndCapCoverPlateThickness+0.01);</span>
<span class="lineNum">    5043 </span><span class="lineCov">          1 :   TGeoTranslation *trendCapCoverPlateContourboxin = new TGeoTranslation(&quot;SSD_trEndCapCoverPlateContourBoxIn&quot;,</span>
<span class="lineNum">    5044 </span>            :                                                          xboxin, yboxin, 0.);
<span class="lineNum">    5045 </span><span class="lineCov">          1 :   trendCapCoverPlateContourboxin-&gt;RegisterYourself();</span>
<span class="lineNum">    5046 </span><span class="lineCov">          1 :   TGeoCompositeShape *contourshape = new TGeoCompositeShape(&quot;contourShape&quot;, </span>
<span class="lineNum">    5047 </span>            :         &quot;EndCapCoverPlateContourBoxOut:SSD_trEndCapCoverPlateContourBoxOut-EndCapCoverPlateContourBoxIn:SSD_trEndCapCoverPlateContourBoxIn&quot;);
<span class="lineNum">    5048 </span>            : 
<span class="lineNum">    5049 </span><span class="lineCov">          2 :   TGeoVolume* contour = new TGeoVolume(&quot;EndCapCoverPlateContour&quot;,contourshape,</span>
<span class="lineNum">    5050 </span><span class="lineCov">          1 :                                                                            fSSDAlCoolBlockMedium);</span>
<span class="lineNum">    5051 </span><span class="lineCov">          1 :   contour-&gt;SetLineColor(6);</span>
<span class="lineNum">    5052 </span>            :   /////////////////////////////
<span class="lineNum">    5053 </span>            :   // Hole Contour Shape Definition 
<span class="lineNum">    5054 </span>            :   ////////////////////////////
<span class="lineNum">    5055 </span>            :   coordmin = xcontourvertex[0];
<span class="lineNum">    5056 </span><span class="lineCov">          1 :   coordmax = coordmin+fgkEndCapCoverPlateLength[2];</span>
<span class="lineNum">    5057 </span><span class="lineCov">          1 :   xboxout = 0.5*(coordmin+coordmax);</span>
<span class="lineNum">    5058 </span><span class="lineCov">          1 :   dxboxout = 0.5*(coordmax-coordmin);</span>
<span class="lineNum">    5059 </span>            :   coordmin = ycontourvertex[1];
<span class="lineNum">    5060 </span><span class="lineCov">          1 :   coordmax = ycontourvertex[1]+fgkEndCapCoverPlateWidth[2];</span>
<span class="lineNum">    5061 </span><span class="lineCov">          1 :   yboxout = 0.5*(coordmin+coordmax);</span>
<span class="lineNum">    5062 </span><span class="lineCov">          1 :   dyboxout = 0.5*(coordmax-coordmin);</span>
<span class="lineNum">    5063 </span><span class="lineCov">          1 :   coordmin = xcontourvertex[0]+ 0.5*(fgkEndCapCoverPlateLength[2]</span>
<span class="lineNum">    5064 </span><span class="lineCov">          1 :                                                    - 2.*fgkEndCapCoverPlateBigHoleRadius);</span>
<span class="lineNum">    5065 </span><span class="lineCov">          1 :   coordmax = coordmin + 2.*fgkEndCapCoverPlateBigHoleRadius;</span>
<span class="lineNum">    5066 </span><span class="lineCov">          1 :   xboxin = 0.5*(coordmin+coordmax);</span>
<span class="lineNum">    5067 </span><span class="lineCov">          1 :   dxboxin = 0.5*(coordmax-coordmin);</span>
<span class="lineNum">    5068 </span><span class="lineCov">          1 :   coordmin = ycontourvertex[1]+0.5*(fgkEndCapCoverPlateWidth[2]</span>
<span class="lineNum">    5069 </span><span class="lineCov">          1 :                                                    - 2.*fgkEndCapCoverPlateBigHoleRadius);;</span>
<span class="lineNum">    5070 </span><span class="lineCov">          1 :   coordmax = coordmin +2.*fgkEndCapCoverPlateBigHoleRadius;</span>
<span class="lineNum">    5071 </span><span class="lineCov">          1 :   yboxin = 0.5*(coordmin+coordmax);</span>
<span class="lineNum">    5072 </span><span class="lineCov">          1 :   dyboxin = 0.5*(coordmax-coordmin);</span>
<span class="lineNum">    5073 </span><span class="lineCov">          1 :   new TGeoBBox(&quot;EndCapCoverPlateContourBoxOut1&quot;, dxboxout, dyboxout, 0.5*fgkEndCapCoverPlateThickness);</span>
<span class="lineNum">    5074 </span><span class="lineCov">          1 :   TGeoTranslation *trendCapCoverPlateContourboxout1 = new TGeoTranslation(&quot;SSD_trEndCapCoverPlateContourBoxOut1&quot;,</span>
<span class="lineNum">    5075 </span>            :                                                          xboxout, yboxout, 0.);
<span class="lineNum">    5076 </span><span class="lineCov">          1 :   trendCapCoverPlateContourboxout1-&gt;RegisterYourself();</span>
<span class="lineNum">    5077 </span><span class="lineCov">          1 :   new TGeoBBox(&quot;EndCapCoverPlateContourBoxIn1&quot;,  dxboxin, dyboxin, 0.5*fgkEndCapCoverPlateThickness+0.01);</span>
<span class="lineNum">    5078 </span><span class="lineCov">          1 :   TGeoTranslation *trendCapCoverPlateContourboxin1 = new TGeoTranslation(&quot;SSD_trEndCapCoverPlateContourBoxIn1&quot;,</span>
<span class="lineNum">    5079 </span>            :                                                          xboxin, yboxin, 0.);
<span class="lineNum">    5080 </span><span class="lineCov">          1 :   trendCapCoverPlateContourboxin1-&gt;RegisterYourself();</span>
<span class="lineNum">    5081 </span><span class="lineCov">          1 :   TGeoCompositeShape *contourshape1 = new TGeoCompositeShape(&quot;contourShape1&quot;, </span>
<span class="lineNum">    5082 </span>            :         &quot;EndCapCoverPlateContourBoxOut1:SSD_trEndCapCoverPlateContourBoxOut1-EndCapCoverPlateContourBoxIn1:SSD_trEndCapCoverPlateContourBoxIn1&quot;);
<span class="lineNum">    5083 </span>            : 
<span class="lineNum">    5084 </span>            : 
<span class="lineNum">    5085 </span><span class="lineCov">          1 :   coordmin = xcontourvertex[0]+fgkEndCapCoverPlateLength[5];</span>
<span class="lineNum">    5086 </span><span class="lineCov">          1 :   coordmax = coordmin+fgkEndCapCoverPlateLength[2];</span>
<span class="lineNum">    5087 </span><span class="lineCov">          1 :   xboxout = 0.5*(coordmin+coordmax);</span>
<span class="lineNum">    5088 </span><span class="lineCov">          1 :   dxboxout = 0.5*(coordmax-coordmin);</span>
<span class="lineNum">    5089 </span><span class="lineCov">          2 :   coordmin = ycontourvertex[0]-(fgkEndCapCoverPlateWidth[1]</span>
<span class="lineNum">    5090 </span><span class="lineCov">          1 :                                                    - fgkEndCapCoverPlateWidth[0]);</span>
<span class="lineNum">    5091 </span>            :   coordmax = ycontourvertex[0];
<span class="lineNum">    5092 </span><span class="lineCov">          1 :   yboxout = 0.5*(coordmin+coordmax);</span>
<span class="lineNum">    5093 </span><span class="lineCov">          1 :   dyboxout = 0.5*(coordmax-coordmin);</span>
<span class="lineNum">    5094 </span><span class="lineCov">          1 :   coordmin = xcontourvertex[0]+fgkEndCapCoverPlateLength[5]+ 0.5*(fgkEndCapCoverPlateLength[2]</span>
<span class="lineNum">    5095 </span><span class="lineCov">          1 :                                                    - 2.*fgkEndCapCoverPlateBigHoleRadius);</span>
<span class="lineNum">    5096 </span><span class="lineCov">          1 :   coordmax = coordmin + 2.*fgkEndCapCoverPlateBigHoleRadius;</span>
<span class="lineNum">    5097 </span><span class="lineCov">          1 :   xboxin = 0.5*(coordmin+coordmax);</span>
<span class="lineNum">    5098 </span><span class="lineCov">          1 :   dxboxin = 0.5*(coordmax-coordmin);</span>
<span class="lineNum">    5099 </span>            :   coordmin = ycontourvertex[0]-(fgkEndCapCoverPlateWidth[1]
<span class="lineNum">    5100 </span><span class="lineCov">          1 :                                                    - fgkEndCapCoverPlateWidth[0])+0.5*(fgkEndCapCoverPlateWidth[1]</span>
<span class="lineNum">    5101 </span>            :                                                    - fgkEndCapCoverPlateWidth[0]
<span class="lineNum">    5102 </span><span class="lineCov">          1 :                                                    - 2.*fgkEndCapCoverPlateBigHoleRadius);</span>
<span class="lineNum">    5103 </span><span class="lineCov">          1 :   coordmax = coordmin+2.*fgkEndCapCoverPlateBigHoleRadius;</span>
<span class="lineNum">    5104 </span><span class="lineCov">          1 :   yboxin = 0.5*(coordmin+coordmax);</span>
<span class="lineNum">    5105 </span><span class="lineCov">          1 :   dyboxin = 0.5*(coordmax-coordmin);</span>
<span class="lineNum">    5106 </span><span class="lineCov">          1 :   new TGeoBBox(&quot;EndCapCoverPlateContourBoxOut2&quot;, dxboxout, dyboxout, 0.5*fgkEndCapCoverPlateThickness);</span>
<span class="lineNum">    5107 </span><span class="lineCov">          1 :   TGeoTranslation *trendCapCoverPlateContourboxout2 = new TGeoTranslation(&quot;SSD_trEndCapCoverPlateContourBoxOut2&quot;,</span>
<span class="lineNum">    5108 </span>            :                                                          xboxout, yboxout, 0.);
<span class="lineNum">    5109 </span><span class="lineCov">          1 :   trendCapCoverPlateContourboxout2-&gt;RegisterYourself();</span>
<span class="lineNum">    5110 </span><span class="lineCov">          1 :   new TGeoBBox(&quot;EndCapCoverPlateContourBoxIn2&quot;,  dxboxin, dyboxin, 0.5*fgkEndCapCoverPlateThickness+0.01);</span>
<span class="lineNum">    5111 </span><span class="lineCov">          1 :   TGeoTranslation *trendCapCoverPlateContourboxin2 = new TGeoTranslation(&quot;SSD_trEndCapCoverPlateContourBoxIn2&quot;,</span>
<span class="lineNum">    5112 </span>            :                                                          xboxin, yboxin, 0.);
<span class="lineNum">    5113 </span><span class="lineCov">          1 :   trendCapCoverPlateContourboxin2-&gt;RegisterYourself();</span>
<span class="lineNum">    5114 </span><span class="lineCov">          1 :   TGeoCompositeShape *contourshape2 = new TGeoCompositeShape(&quot;contourShape2&quot;, </span>
<span class="lineNum">    5115 </span>            :         &quot;EndCapCoverPlateContourBoxOut2:SSD_trEndCapCoverPlateContourBoxOut2-EndCapCoverPlateContourBoxIn2:SSD_trEndCapCoverPlateContourBoxIn2&quot;);
<span class="lineNum">    5116 </span>            :   
<span class="lineNum">    5117 </span>            : //  const Int_t kholecontourvertexnumber = 10;
<span class="lineNum">    5118 </span>            : 
<span class="lineNum">    5119 </span>            :   Double_t xholecontourvertex[2][kcontourvertexnumber];
<span class="lineNum">    5120 </span>            :   Double_t yholecontourvertex[2][kcontourvertexnumber];
<span class="lineNum">    5121 </span>            :   xholecontourvertex[0][0] = xcontourvertex[0];
<span class="lineNum">    5122 </span>            :   xholecontourvertex[0][1] = xholecontourvertex[0][0];
<span class="lineNum">    5123 </span><span class="lineCov">          1 :   xholecontourvertex[0][2] = xholecontourvertex[0][1]+fgkEndCapCoverPlateLength[2];</span>
<span class="lineNum">    5124 </span>            :   xholecontourvertex[0][3] = xholecontourvertex[0][2];
<span class="lineNum">    5125 </span>            :   xholecontourvertex[0][4] = xholecontourvertex[0][0]
<span class="lineNum">    5126 </span><span class="lineCov">          1 :                                                    + 0.5*(fgkEndCapCoverPlateLength[2]</span>
<span class="lineNum">    5127 </span><span class="lineCov">          1 :                                                    - 2.*fgkEndCapCoverPlateBigHoleRadius);</span>
<span class="lineNum">    5128 </span>            :   xholecontourvertex[0][5] = xholecontourvertex[0][4];
<span class="lineNum">    5129 </span>            :   xholecontourvertex[0][6] = xholecontourvertex[0][5]
<span class="lineNum">    5130 </span>            :                                                    + 2.*fgkEndCapCoverPlateBigHoleRadius;
<span class="lineNum">    5131 </span>            :   xholecontourvertex[0][7] = xholecontourvertex[0][6];
<span class="lineNum">    5132 </span>            :   xholecontourvertex[0][8] = xholecontourvertex[0][4];
<span class="lineNum">    5133 </span>            :   xholecontourvertex[0][9] = xholecontourvertex[0][8];
<span class="lineNum">    5134 </span>            :   
<span class="lineNum">    5135 </span>            :   yholecontourvertex[0][0] = ycontourvertex[1];
<span class="lineNum">    5136 </span><span class="lineCov">          1 :   yholecontourvertex[0][1] = yholecontourvertex[0][0]+fgkEndCapCoverPlateWidth[2];</span>
<span class="lineNum">    5137 </span>            :   yholecontourvertex[0][2] = yholecontourvertex[0][1];
<span class="lineNum">    5138 </span>            :   yholecontourvertex[0][3] = yholecontourvertex[0][0];
<span class="lineNum">    5139 </span>            :   yholecontourvertex[0][4] = yholecontourvertex[0][3];
<span class="lineNum">    5140 </span><span class="lineCov">          1 :   yholecontourvertex[0][5] = yholecontourvertex[0][4]+0.5*(fgkEndCapCoverPlateWidth[2]</span>
<span class="lineNum">    5141 </span><span class="lineCov">          1 :                                                    - 2.*fgkEndCapCoverPlateBigHoleRadius);</span>
<span class="lineNum">    5142 </span>            :   yholecontourvertex[0][6] = yholecontourvertex[0][5];
<span class="lineNum">    5143 </span><span class="lineCov">          1 :   yholecontourvertex[0][7] = yholecontourvertex[0][6]+2.*fgkEndCapCoverPlateBigHoleRadius;</span>
<span class="lineNum">    5144 </span>            :   yholecontourvertex[0][8] = yholecontourvertex[0][7];
<span class="lineNum">    5145 </span>            :   yholecontourvertex[0][9] = yholecontourvertex[0][0];
<span class="lineNum">    5146 </span>            : 
<span class="lineNum">    5147 </span><span class="lineCov">          1 :   xholecontourvertex[1][0] = xcontourvertex[0]+fgkEndCapCoverPlateLength[5];</span>
<span class="lineNum">    5148 </span>            :   xholecontourvertex[1][1] = xholecontourvertex[1][0];
<span class="lineNum">    5149 </span>            :   xholecontourvertex[1][2] = xholecontourvertex[1][1]+fgkEndCapCoverPlateLength[2];
<span class="lineNum">    5150 </span>            :   xholecontourvertex[1][3] = xholecontourvertex[1][2];
<span class="lineNum">    5151 </span>            :   xholecontourvertex[1][4] = xholecontourvertex[1][0]
<span class="lineNum">    5152 </span><span class="lineCov">          1 :                                                    + 0.5*(fgkEndCapCoverPlateLength[2]</span>
<span class="lineNum">    5153 </span>            :                                                    - 2.*fgkEndCapCoverPlateBigHoleRadius);
<span class="lineNum">    5154 </span>            :   xholecontourvertex[1][5] = xholecontourvertex[1][4];
<span class="lineNum">    5155 </span>            :   xholecontourvertex[1][6] = xholecontourvertex[1][5]
<span class="lineNum">    5156 </span>            :                                                    + 2.*fgkEndCapCoverPlateBigHoleRadius;
<span class="lineNum">    5157 </span>            :   xholecontourvertex[1][7] = xholecontourvertex[1][6];
<span class="lineNum">    5158 </span>            :   xholecontourvertex[1][8] = xholecontourvertex[1][4];
<span class="lineNum">    5159 </span>            :   xholecontourvertex[1][9] = xholecontourvertex[1][8];
<span class="lineNum">    5160 </span>            :   
<span class="lineNum">    5161 </span><span class="lineCov">          2 :   yholecontourvertex[1][0] = ycontourvertex[0]-(fgkEndCapCoverPlateWidth[1]</span>
<span class="lineNum">    5162 </span><span class="lineCov">          1 :                                                    - fgkEndCapCoverPlateWidth[0]);</span>
<span class="lineNum">    5163 </span>            :   yholecontourvertex[1][1] = ycontourvertex[0];
<span class="lineNum">    5164 </span>            :   yholecontourvertex[1][2] = yholecontourvertex[1][1];
<span class="lineNum">    5165 </span>            :   yholecontourvertex[1][3] = yholecontourvertex[1][0];
<span class="lineNum">    5166 </span>            :   yholecontourvertex[1][4] = yholecontourvertex[1][3];
<span class="lineNum">    5167 </span><span class="lineCov">          1 :   yholecontourvertex[1][5] = yholecontourvertex[1][4]+0.5*(fgkEndCapCoverPlateWidth[1]</span>
<span class="lineNum">    5168 </span>            :                                                    - fgkEndCapCoverPlateWidth[0]
<span class="lineNum">    5169 </span><span class="lineCov">          1 :                                                    - 2.*fgkEndCapCoverPlateBigHoleRadius);</span>
<span class="lineNum">    5170 </span>            :   yholecontourvertex[1][6] = yholecontourvertex[1][5];
<span class="lineNum">    5171 </span>            :   yholecontourvertex[1][7] = yholecontourvertex[1][6]+2.*fgkEndCapCoverPlateBigHoleRadius;
<span class="lineNum">    5172 </span>            :   yholecontourvertex[1][8] = yholecontourvertex[1][7];
<span class="lineNum">    5173 </span>            :   yholecontourvertex[1][9] = yholecontourvertex[1][0];
<span class="lineNum">    5174 </span>            : 
<span class="lineNum">    5175 </span>            :   TGeoVolume* holecontour[2];
<span class="lineNum">    5176 </span><span class="lineCov">          2 :   holecontour[0] = new TGeoVolume(&quot;EndCapCoverPlateContour1&quot;,contourshape1,</span>
<span class="lineNum">    5177 </span><span class="lineCov">          1 :                                                                   fSSDAlCoolBlockMedium);</span>
<span class="lineNum">    5178 </span><span class="lineCov">          1 :   holecontour[0]-&gt;SetLineColor(6);</span>
<span class="lineNum">    5179 </span><span class="lineCov">          2 :   holecontour[1] = new TGeoVolume(&quot;EndCapCoverPlateContour2&quot;,contourshape2,</span>
<span class="lineNum">    5180 </span><span class="lineCov">          1 :                                                                   fSSDAlCoolBlockMedium);</span>
<span class="lineNum">    5181 </span><span class="lineCov">          1 :   holecontour[1]-&gt;SetLineColor(6);</span>
<span class="lineNum">    5182 </span><span class="lineCov">          2 :   TGeoTranslation* holecontourtrans = new TGeoTranslation(fgkEndCapCoverPlateLength[3]</span>
<span class="lineNum">    5183 </span><span class="lineCov">          1 :                                                                         +     fgkEndCapCoverPlateLength[2],0.,0.);</span>
<span class="lineNum">    5184 </span>            :   TGeoTranslation*  bigholetrans[3];
<span class="lineNum">    5185 </span><span class="lineCov">          2 :   bigholetrans[0] = new TGeoTranslation(xholecontourvertex[0][4]+fgkEndCapCoverPlateBigHoleRadius,</span>
<span class="lineNum">    5186 </span><span class="lineCov">          1 :                                                                                 yholecontourvertex[0][7]-fgkEndCapCoverPlateBigHoleRadius,0.0);</span>
<span class="lineNum">    5187 </span><span class="lineCov">          2 :   bigholetrans[1] = new TGeoTranslation(xholecontourvertex[0][4]+fgkEndCapCoverPlateBigHoleRadius</span>
<span class="lineNum">    5188 </span><span class="lineCov">          1 :                                   +                     fgkEndCapCoverPlateLength[4],yholecontourvertex[0][7]</span>
<span class="lineNum">    5189 </span><span class="lineCov">          1 :                                   -                                             fgkEndCapCoverPlateBigHoleRadius,0.0);</span>
<span class="lineNum">    5190 </span><span class="lineCov">          2 :   bigholetrans[2] = new TGeoTranslation(xholecontourvertex[1][4]+fgkEndCapCoverPlateBigHoleRadius,</span>
<span class="lineNum">    5191 </span><span class="lineCov">          1 :                                                                                 yholecontourvertex[1][5]+fgkEndCapCoverPlateBigHoleRadius,0.0);</span>
<span class="lineNum">    5192 </span>            :   /////////////////////////////////
<span class="lineNum">    5193 </span>            :   // Mother Volume Xtru Definition 
<span class="lineNum">    5194 </span>            :   /////////////////////////////////
<span class="lineNum">    5195 </span>            :   const Int_t kmothervertexnumber = 12;
<span class="lineNum">    5196 </span><span class="lineCov">          1 :   Double_t xmothervertex[kmothervertexnumber];  </span>
<span class="lineNum">    5197 </span><span class="lineCov">          1 :   Double_t ymothervertex[kmothervertexnumber];  </span>
<span class="lineNum">    5198 </span><span class="lineCov">          1 :   xmothervertex[0]  = xcontourvertex[0];</span>
<span class="lineNum">    5199 </span><span class="lineCov">          1 :   xmothervertex[1]  = xmothervertex[0];</span>
<span class="lineNum">    5200 </span><span class="lineCov">          1 :   xmothervertex[2]  = xmothervertex[1]+fgkEndCapCoverPlateLength[2];</span>
<span class="lineNum">    5201 </span><span class="lineCov">          1 :   xmothervertex[3]  = xmothervertex[2];</span>
<span class="lineNum">    5202 </span><span class="lineCov">          1 :   xmothervertex[4]  = xmothervertex[3]+fgkEndCapCoverPlateLength[3];</span>
<span class="lineNum">    5203 </span><span class="lineCov">          1 :   xmothervertex[5]  = xmothervertex[4];</span>
<span class="lineNum">    5204 </span><span class="lineCov">          1 :   xmothervertex[6]  = xmothervertex[5]+fgkEndCapCoverPlateLength[2];</span>
<span class="lineNum">    5205 </span><span class="lineCov">          1 :   xmothervertex[7]  = xmothervertex[6];</span>
<span class="lineNum">    5206 </span><span class="lineCov">          2 :   xmothervertex[8]  = xmothervertex[0]+fgkEndCapCoverPlateLength[5]</span>
<span class="lineNum">    5207 </span><span class="lineCov">          1 :                                         + fgkEndCapCoverPlateLength[2]; </span>
<span class="lineNum">    5208 </span><span class="lineCov">          1 :   xmothervertex[9]  = xmothervertex[8];</span>
<span class="lineNum">    5209 </span><span class="lineCov">          1 :   xmothervertex[10] = xmothervertex[9]-fgkEndCapCoverPlateLength[2];</span>
<span class="lineNum">    5210 </span><span class="lineCov">          1 :   xmothervertex[11] = xmothervertex[10];</span>
<span class="lineNum">    5211 </span>            :   
<span class="lineNum">    5212 </span><span class="lineCov">          1 :   ymothervertex[0]  = ycontourvertex[0];</span>
<span class="lineNum">    5213 </span><span class="lineCov">          1 :   ymothervertex[1]  = ymothervertex[0]+fgkEndCapCoverPlateWidth[0];</span>
<span class="lineNum">    5214 </span><span class="lineCov">          1 :   ymothervertex[2]  = ymothervertex[1];</span>
<span class="lineNum">    5215 </span><span class="lineCov">          1 :   ymothervertex[3]  = ycontourvertex[1];</span>
<span class="lineNum">    5216 </span><span class="lineCov">          1 :   ymothervertex[4]  = ymothervertex[3];</span>
<span class="lineNum">    5217 </span><span class="lineCov">          1 :   ymothervertex[5]  = ymothervertex[1];</span>
<span class="lineNum">    5218 </span><span class="lineCov">          1 :   ymothervertex[6]  = ymothervertex[5];</span>
<span class="lineNum">    5219 </span><span class="lineCov">          1 :   ymothervertex[7]  = ymothervertex[0];</span>
<span class="lineNum">    5220 </span><span class="lineCov">          1 :   ymothervertex[8]  = ymothervertex[7];</span>
<span class="lineNum">    5221 </span><span class="lineCov">          1 :   ymothervertex[9]  = ymothervertex[8]</span>
<span class="lineNum">    5222 </span><span class="lineCov">          1 :                                    - (fgkEndCapCoverPlateWidth[1]-fgkEndCapCoverPlateWidth[0]);</span>
<span class="lineNum">    5223 </span><span class="lineCov">          1 :   ymothervertex[10] = ymothervertex[9];</span>
<span class="lineNum">    5224 </span><span class="lineCov">          1 :   ymothervertex[11] = ymothervertex[8];</span>
<span class="lineNum">    5225 </span><span class="lineCov">          1 :   TGeoXtru* mothercoverplateshape = new TGeoXtru(2);</span>
<span class="lineNum">    5226 </span><span class="lineCov">          1 :   mothercoverplateshape-&gt;DefinePolygon(kmothervertexnumber,xmothervertex,ymothervertex);  </span>
<span class="lineNum">    5227 </span><span class="lineCov">          1 :   mothercoverplateshape-&gt;DefineSection(0,-0.5*fgkEndCapCoverPlateThickness);</span>
<span class="lineNum">    5228 </span><span class="lineCov">          1 :   mothercoverplateshape-&gt;DefineSection(1,+0.5*fgkEndCapCoverPlateThickness);</span>
<span class="lineNum">    5229 </span><span class="lineCov">          1 :   TGeoVolume* mothercoverplate = new TGeoVolume(&quot;EndCapCoverPlateMother&quot;,mothercoverplateshape,fSSDAir);</span>
<span class="lineNum">    5230 </span>            :   ////////////////////////////////////////
<span class="lineNum">    5231 </span>            :   // Adding Nodes
<span class="lineNum">    5232 </span>            :   ////////////////////////////////////////
<span class="lineNum">    5233 </span>            : //  TGeoTranslation** endcapcoverplatesmallholetrans[kendcapcoverplatesmallholenumber[0]]; 
<span class="lineNum">    5234 </span>            :   TGeoTranslation*** endcapcoverplatesmallholetrans;
<span class="lineNum">    5235 </span><span class="lineCov">          1 :   endcapcoverplatesmallholetrans = new TGeoTranslation**[kendcapcoverplatesmallholenumber[0]]; </span>
<span class="lineNum">    5236 </span><span class="lineCov">          4 :   Double_t transx[4] = {0,</span>
<span class="lineNum">    5237 </span><span class="lineCov">          1 :                                                 fgkEndCapCoverPlateSmallHoleSeparation[0],</span>
<span class="lineNum">    5238 </span><span class="lineCov">          1 :                                                 fgkEndCapCoverPlateSmallHoleSeparation[0]</span>
<span class="lineNum">    5239 </span><span class="lineCov">          1 :                                          +  fgkEndCapCoverPlateSmallHoleSeparation[1],</span>
<span class="lineNum">    5240 </span><span class="lineCov">          1 :                                          2.*fgkEndCapCoverPlateSmallHoleSeparation[0]</span>
<span class="lineNum">    5241 </span><span class="lineCov">          1 :                                          +  fgkEndCapCoverPlateSmallHoleSeparation[1]};</span>
<span class="lineNum">    5242 </span>            :   Int_t index = 0;
<span class="lineNum">    5243 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;kendcapcoverplatesmallholenumber[0]; i++){</span>
<span class="lineNum">    5244 </span><span class="lineCov">          4 :         endcapcoverplatesmallholetrans[i] = </span>
<span class="lineNum">    5245 </span><span class="lineCov">          4 :                                         new TGeoTranslation*[kendcapcoverplatesmallholenumber[1]];</span>
<span class="lineNum">    5246 </span><span class="lineCov">         80 :     for(Int_t j=0; j&lt;kendcapcoverplatesmallholenumber[1]; j++){</span>
<span class="lineNum">    5247 </span><span class="lineCov">         36 :                 index = kendcapcoverplatesmallholenumber[1]*i+j+1;</span>
<span class="lineNum">    5248 </span><span class="lineCov">         36 :             endcapcoverplatesmallholetrans[i][j] = </span>
<span class="lineNum">    5249 </span><span class="lineCov">         72 :                 new TGeoTranslation(transx[i],</span>
<span class="lineNum">    5250 </span><span class="lineCov">         36 :                                                         j*fgkEndCapCoverPlateSmallHoleSeparation[2],0.);</span>
<span class="lineNum">    5251 </span><span class="lineCov">         36 :             if(index!=10){ </span>
<span class="lineNum">    5252 </span><span class="lineCov">         70 :                         mothercoverplate-&gt;AddNode(endcapcoverplatesmallhole,</span>
<span class="lineNum">    5253 </span><span class="lineCov">         35 :                                                                           index,endcapcoverplatesmallholetrans[i][j]);</span>
<span class="lineNum">    5254 </span><span class="lineCov">         70 :                         mothercoverplate-&gt;AddNode(endcapsmallscrewpiece,</span>
<span class="lineNum">    5255 </span><span class="lineCov">         35 :                                                                           index,endcapcoverplatesmallholetrans[i][j]);</span>
<span class="lineNum">    5256 </span><span class="lineCov">         35 :                 }</span>
<span class="lineNum">    5257 </span><span class="lineCov">         36 :                 if(j&lt;kendcapcoverplatesmallholenumber[1]-1) </span>
<span class="lineNum">    5258 </span><span class="lineCov">         64 :                         mothercoverplate-&gt;AddNode(endcapcoverplatebox[0],</span>
<span class="lineNum">    5259 </span><span class="lineCov">         32 :                                                                           index,endcapcoverplatesmallholetrans[i][j]);</span>
<span class="lineNum">    5260 </span>            :     }
<span class="lineNum">    5261 </span>            :   }
<span class="lineNum">    5262 </span><span class="lineCov">          1 :   mothercoverplate-&gt;AddNode(endcapcoverplatebox[1],1);</span>
<span class="lineNum">    5263 </span><span class="lineCov">          1 :   mothercoverplate-&gt;AddNode(endcapcoverplatebox[2],1);</span>
<span class="lineNum">    5264 </span><span class="lineCov">          1 :   mothercoverplate-&gt;AddNode(endcapcoverplatebox[3],1);</span>
<span class="lineNum">    5265 </span><span class="lineCov">          1 :   mothercoverplate-&gt;AddNode(endcapfillingbox,1);</span>
<span class="lineNum">    5266 </span><span class="lineCov">          1 :   mothercoverplate-&gt;AddNode(endcapcoverplatebighole,1,bigholetrans[0]);</span>
<span class="lineNum">    5267 </span><span class="lineCov">          1 :   mothercoverplate-&gt;AddNode(endcapcoverplatebighole,2,bigholetrans[1]);</span>
<span class="lineNum">    5268 </span><span class="lineCov">          1 :   mothercoverplate-&gt;AddNode(endcapcoverplatebighole,3,bigholetrans[2]);</span>
<span class="lineNum">    5269 </span><span class="lineCov">          1 :   mothercoverplate-&gt;AddNode(holecontour[0],1);</span>
<span class="lineNum">    5270 </span><span class="lineCov">          1 :   mothercoverplate-&gt;AddNode(holecontour[0],2,holecontourtrans);</span>
<span class="lineNum">    5271 </span><span class="lineCov">          1 :   mothercoverplate-&gt;AddNode(holecontour[1],1);  </span>
<span class="lineNum">    5272 </span><span class="lineCov">          1 :   mothercoverplate-&gt;AddNode(contour,1);</span>
<span class="lineNum">    5273 </span>            :   
<span class="lineNum">    5274 </span><span class="lineCov">         10 :   for (Int_t i = 0; i &lt; kendcapcoverplatesmallholenumber[0]; i++) </span>
<span class="lineNum">    5275 </span><span class="lineCov">          8 :     delete [] endcapcoverplatesmallholetrans[i];</span>
<span class="lineNum">    5276 </span><span class="lineCov">          2 :   delete [] endcapcoverplatesmallholetrans;</span>
<span class="lineNum">    5277 </span>            :   /////////////////////////////////
<span class="lineNum">    5278 </span><span class="lineCov">          1 :   return mothercoverplate;      </span>
<a name="5279"><span class="lineNum">    5279 </span><span class="lineCov">          1 :  }</span></a>
<span class="lineNum">    5280 </span>            :  ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    5281 </span>            :  TGeoVolume* AliITSv11GeometrySSD::GetEndCapCoolingTube(){
<span class="lineNum">    5282 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    5283 </span>            :   // Getting EndCap Cooling Tube 
<span class="lineNum">    5284 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    5285 </span><span class="lineCov">          2 :   TGeoTorus* endcapcoolingtubetorushape[5];</span>
<span class="lineNum">    5286 </span><span class="lineCov">          1 :   TGeoVolume* endcapcoolingtubetorus[5];</span>
<span class="lineNum">    5287 </span><span class="lineCov">          1 :   TGeoTube* endcapcoolingtubeshape[4];</span>
<span class="lineNum">    5288 </span><span class="lineCov">          1 :   TGeoVolume* endcapcoolingtube[4];</span>
<span class="lineNum">    5289 </span><span class="lineCov">          1 :   char endcapcoolingtubetorusname[100];</span>
<span class="lineNum">    5290 </span><span class="lineCov">          1 :   char endcapcoolingtubename[100];</span>
<span class="lineNum">    5291 </span><span class="lineCov">          1 :   TGeoTorus* endcapcoolingwatertubetorushape[5];</span>
<span class="lineNum">    5292 </span><span class="lineCov">          1 :   TGeoVolume* endcapcoolingwatertubetorus[5];</span>
<span class="lineNum">    5293 </span><span class="lineCov">          1 :   TGeoTube* endcapcoolingwatertubeshape[4];</span>
<span class="lineNum">    5294 </span><span class="lineCov">          1 :   TGeoVolume* endcapcoolingwatertube[4];</span>
<span class="lineNum">    5295 </span><span class="lineCov">          1 :   char endcapcoolingwatertubetorusname[100];</span>
<span class="lineNum">    5296 </span><span class="lineCov">          1 :   char endcapcoolingwatertubename[100];</span>
<span class="lineNum">    5297 </span><span class="lineCov">         12 :   for(Int_t i=0; i&lt;5; i++){</span>
<span class="lineNum">    5298 </span><span class="lineCov">          5 :     snprintf(endcapcoolingtubetorusname,100,&quot;EndCapCoolingTubeTorus%d&quot;,i+1);</span>
<span class="lineNum">    5299 </span><span class="lineCov">          5 :     snprintf(endcapcoolingtubename,100,&quot;EndCapCoolingTube%d&quot;,i+1);</span>
<span class="lineNum">    5300 </span><span class="lineCov">          5 :     snprintf(endcapcoolingwatertubetorusname,100,&quot;EndCapCoolingWaterTubeTorus%d&quot;,i+1);</span>
<span class="lineNum">    5301 </span><span class="lineCov">          5 :     snprintf(endcapcoolingwatertubename,100,&quot;EndCapCoolingWaterTube%d&quot;,i+1);</span>
<span class="lineNum">    5302 </span><span class="lineCov">         10 :     if(i==3){</span>
<span class="lineNum">    5303 </span><span class="lineCov">          8 :       endcapcoolingtubetorushape[i] = new TGeoTorus(fgkEndCapCoolingTubeAxialRadius[0],</span>
<span class="lineNum">    5304 </span><span class="lineCov">          1 :                                                     fgkEndCapCoolingTubeRadiusMin,</span>
<span class="lineNum">    5305 </span><span class="lineCov">          1 :                                                     fgkEndCapCoolingTubeRadiusMax,</span>
<span class="lineNum">    5306 </span>            :                                                     90.0,fgkEndCapCoolingTubeAngle[3]);
<span class="lineNum">    5307 </span><span class="lineCov">          3 :       endcapcoolingwatertubetorushape[i] = new TGeoTorus(fgkEndCapCoolingTubeAxialRadius[0],</span>
<span class="lineNum">    5308 </span><span class="lineCov">          1 :                                                          0.,fgkEndCapCoolingTubeRadiusMin,</span>
<span class="lineNum">    5309 </span>            :                                                          90.0,fgkEndCapCoolingTubeAngle[3]);
<span class="lineNum">    5310 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">    5311 </span>            :     else{
<span class="lineNum">    5312 </span><span class="lineCov">         16 :       endcapcoolingtubetorushape[i] = new TGeoTorus(i!=4?fgkEndCapCoolingTubeAxialRadius[0]</span>
<span class="lineNum">    5313 </span><span class="lineCov">          4 :                                                     :fgkEndCapCoolingTubeAxialRadius[1],</span>
<span class="lineNum">    5314 </span><span class="lineCov">          4 :                                                     fgkEndCapCoolingTubeRadiusMin,</span>
<span class="lineNum">    5315 </span><span class="lineCov">          4 :                                                     fgkEndCapCoolingTubeRadiusMax,</span>
<span class="lineNum">    5316 </span><span class="lineCov">          4 :                                                     0.,fgkEndCapCoolingTubeAngle[i]);</span>
<span class="lineNum">    5317 </span><span class="lineCov">         16 :       endcapcoolingwatertubetorushape[i] = new TGeoTorus(i!=4?fgkEndCapCoolingTubeAxialRadius[0]</span>
<span class="lineNum">    5318 </span><span class="lineCov">          4 :                                                          :fgkEndCapCoolingTubeAxialRadius[1],</span>
<span class="lineNum">    5319 </span><span class="lineCov">          4 :                                                          0.,fgkEndCapCoolingTubeRadiusMin,</span>
<span class="lineNum">    5320 </span><span class="lineCov">          4 :                                                          0.,fgkEndCapCoolingTubeAngle[i]);</span>
<span class="lineNum">    5321 </span>            :     }
<span class="lineNum">    5322 </span><span class="lineCov">         15 :         endcapcoolingtubetorus[i] = new TGeoVolume(endcapcoolingtubetorusname,</span>
<span class="lineNum">    5323 </span><span class="lineCov">          5 :                                                                                            endcapcoolingtubetorushape[i],</span>
<span class="lineNum">    5324 </span><span class="lineCov">          5 :                                                                                            fSSDCoolingTubePhynox);</span>
<span class="lineNum">    5325 </span><span class="lineCov">         15 :         endcapcoolingwatertubetorus[i] = new TGeoVolume(endcapcoolingwatertubetorusname,</span>
<span class="lineNum">    5326 </span><span class="lineCov">          5 :                                                                                                         endcapcoolingwatertubetorushape[i],</span>
<span class="lineNum">    5327 </span><span class="lineCov">          5 :                                                                                                         fSSDCoolingTubeWater);</span>
<span class="lineNum">    5328 </span><span class="lineCov">          5 :     endcapcoolingtubetorus[i]-&gt;SetLineColor(fColorPhynox);</span>
<span class="lineNum">    5329 </span><span class="lineCov">          5 :     endcapcoolingwatertubetorus[i]-&gt;SetLineColor(fColorWater);</span>
<span class="lineNum">    5330 </span><span class="lineCov">          5 :     if(i&lt;4){</span>
<span class="lineNum">    5331 </span><span class="lineCov">         12 :                 endcapcoolingtubeshape[i] = new TGeoTube(fgkEndCapCoolingTubeRadiusMin,</span>
<span class="lineNum">    5332 </span><span class="lineCov">          4 :                                                                   fgkEndCapCoolingTubeRadiusMax,</span>
<span class="lineNum">    5333 </span><span class="lineCov">          4 :                                                           0.5*fgkEndCapCoolingTubeLength[i]);</span>
<span class="lineNum">    5334 </span><span class="lineCov">         12 :                 endcapcoolingwatertubeshape[i] = new TGeoTube(0.,fgkEndCapCoolingTubeRadiusMin,</span>
<span class="lineNum">    5335 </span><span class="lineCov">          4 :                                                           0.5*fgkEndCapCoolingTubeLength[i]);</span>
<span class="lineNum">    5336 </span><span class="lineCov">         12 :         endcapcoolingtube[i] = new TGeoVolume(endcapcoolingtubename,</span>
<span class="lineNum">    5337 </span><span class="lineCov">          4 :                                                          endcapcoolingtubeshape[i],fSSDCoolingTubePhynox);</span>
<span class="lineNum">    5338 </span><span class="lineCov">         12 :         endcapcoolingwatertube[i] = new TGeoVolume(endcapcoolingwatertubename,</span>
<span class="lineNum">    5339 </span><span class="lineCov">          4 :                                                          endcapcoolingwatertubeshape[i],fSSDCoolingTubeWater);</span>
<span class="lineNum">    5340 </span><span class="lineCov">          4 :                 endcapcoolingtube[i]-&gt;SetLineColor(fColorPhynox);</span>
<span class="lineNum">    5341 </span><span class="lineCov">          4 :                 endcapcoolingwatertube[i]-&gt;SetLineColor(fColorWater);</span>
<span class="lineNum">    5342 </span><span class="lineCov">          4 :         }</span>
<span class="lineNum">    5343 </span>            :   }
<span class="lineNum">    5344 </span><span class="lineCov">          1 :   TGeoVolumeAssembly* endcapcoolingtubemother = new TGeoVolumeAssembly(&quot;MotherEndCapCoolingTube&quot;);</span>
<span class="lineNum">    5345 </span>            :   /////////////////////////////////////////
<span class="lineNum">    5346 </span>            :   // Transformation for Volume Positioning 
<span class="lineNum">    5347 </span>            :   /////////////////////////////////////////
<span class="lineNum">    5348 </span><span class="lineCov">          1 :   TGeoCombiTrans* coolingtubecombitrans[6];</span>
<span class="lineNum">    5349 </span><span class="lineCov">          1 :   TGeoRotation* coolingtuberot[8];</span>
<span class="lineNum">    5350 </span><span class="lineCov">          1 :   TGeoTranslation* coolingtubetrans[6];</span>
<span class="lineNum">    5351 </span>            :   TGeoHMatrix* coolingtubematrix[4];
<span class="lineNum">    5352 </span><span class="lineCov">          1 :   TGeoCombiTrans* torustubecombitrans[4];</span>
<span class="lineNum">    5353 </span><span class="lineCov">          1 :   TGeoRotation* torustuberot[7];</span>
<span class="lineNum">    5354 </span><span class="lineCov">          1 :   TGeoTranslation* torustubetrans[4];</span>
<span class="lineNum">    5355 </span>            :   TGeoHMatrix* torustubematrix[5];
<span class="lineNum">    5356 </span><span class="lineCov">          1 :   TGeoCombiTrans* coolingwatertubecombitrans[6];</span>
<span class="lineNum">    5357 </span><span class="lineCov">          1 :   TGeoRotation* coolingwatertuberot[8];</span>
<span class="lineNum">    5358 </span><span class="lineCov">          1 :   TGeoTranslation* coolingwatertubetrans[6];</span>
<span class="lineNum">    5359 </span>            :   TGeoHMatrix* coolingwatertubematrix[4];
<span class="lineNum">    5360 </span><span class="lineCov">          1 :   TGeoCombiTrans* toruswatertubecombitrans[4];</span>
<span class="lineNum">    5361 </span><span class="lineCov">          1 :   TGeoRotation* toruswatertuberot[7];</span>
<span class="lineNum">    5362 </span><span class="lineCov">          1 :   TGeoTranslation* toruswatertubetrans[4];</span>
<span class="lineNum">    5363 </span>            :   TGeoHMatrix* toruswatertubematrix[5];
<span class="lineNum">    5364 </span><span class="lineCov">         18 :   for(Int_t i=0; i&lt;8; i++){</span>
<span class="lineNum">    5365 </span><span class="lineCov">          8 :     if(i&lt;6){</span>
<span class="lineNum">    5366 </span><span class="lineCov">         12 :          coolingtubetrans[i] = new TGeoTranslation();</span>
<span class="lineNum">    5367 </span><span class="lineCov">         12 :          coolingwatertubetrans[i] = new TGeoTranslation();</span>
<span class="lineNum">    5368 </span><span class="lineCov">          6 :     }</span>
<span class="lineNum">    5369 </span><span class="lineCov">          8 :     if(i&lt;8){</span>
<span class="lineNum">    5370 </span><span class="lineCov">         16 :          coolingtuberot[i] = new TGeoRotation();</span>
<span class="lineNum">    5371 </span><span class="lineCov">         16 :          coolingwatertuberot[i] = new TGeoRotation();</span>
<span class="lineNum">    5372 </span><span class="lineCov">          8 :     }</span>
<span class="lineNum">    5373 </span><span class="lineCov">          8 :     if(i&lt;4){</span>
<span class="lineNum">    5374 </span><span class="lineCov">          8 :          torustubetrans[i] = new TGeoTranslation();</span>
<span class="lineNum">    5375 </span><span class="lineCov">          8 :          toruswatertubetrans[i] = new TGeoTranslation();</span>
<span class="lineNum">    5376 </span><span class="lineCov">          4 :     }</span>
<span class="lineNum">    5377 </span><span class="lineCov">          8 :     if(i&lt;7){</span>
<span class="lineNum">    5378 </span><span class="lineCov">         14 :          torustuberot[i] = new TGeoRotation();</span>
<span class="lineNum">    5379 </span><span class="lineCov">         14 :          toruswatertuberot[i] = new TGeoRotation();</span>
<span class="lineNum">    5380 </span><span class="lineCov">          7 :         }</span>
<span class="lineNum">    5381 </span>            :   }
<span class="lineNum">    5382 </span>            :   /////////////////////////////////////////
<span class="lineNum">    5383 </span>            :   // Transformation for Inox Volume Positioning 
<span class="lineNum">    5384 </span>            :   /////////////////////////////////////////
<span class="lineNum">    5385 </span><span class="lineCov">          2 :   coolingtubetrans[0]-&gt;SetTranslation(fgkEndCapCoolingTubeAxialRadius[0],</span>
<span class="lineNum">    5386 </span><span class="lineCov">          1 :                                                                           -endcapcoolingtubeshape[0]-&gt;GetDz(),0.);</span>
<span class="lineNum">    5387 </span><span class="lineCov">          1 :   coolingtuberot[0]-&gt;SetAngles(0.,90.,0.);</span>
<span class="lineNum">    5388 </span><span class="lineCov">          3 :   coolingtubecombitrans[0] = new TGeoCombiTrans(*coolingtubetrans[0],</span>
<span class="lineNum">    5389 </span><span class="lineCov">          1 :                                                                                                 *coolingtuberot[0]);</span>
<span class="lineNum">    5390 </span>            :                                                                                                 
<span class="lineNum">    5391 </span><span class="lineCov">          1 :   coolingtubetrans[1]-&gt;SetTranslation(0.,-endcapcoolingtubeshape[1]-&gt;GetDz(),0.);</span>
<span class="lineNum">    5392 </span><span class="lineCov">          1 :   coolingtuberot[1]-&gt;SetAngles(0.,90.,0.);</span>
<span class="lineNum">    5393 </span><span class="lineCov">          3 :   coolingtubecombitrans[1] = new TGeoCombiTrans(*coolingtubetrans[1],</span>
<span class="lineNum">    5394 </span><span class="lineCov">          1 :                                                                                                 *coolingtuberot[1]);</span>
<span class="lineNum">    5395 </span>            : 
<span class="lineNum">    5396 </span><span class="lineCov">          2 :   coolingtubetrans[2]-&gt;SetTranslation(fgkEndCapCoolingTubeAxialRadius[0]</span>
<span class="lineNum">    5397 </span><span class="lineCov">          1 :                                                                          *CosD(fgkEndCapCoolingTubeAngle[0]),</span>
<span class="lineNum">    5398 </span><span class="lineCov">          1 :                                                                           fgkEndCapCoolingTubeAxialRadius[0]</span>
<span class="lineNum">    5399 </span><span class="lineCov">          1 :                                                                          *SinD(fgkEndCapCoolingTubeAngle[0]),</span>
<span class="lineNum">    5400 </span>            :                                                                           0.);
<span class="lineNum">    5401 </span><span class="lineCov">          1 :   coolingtuberot[2]-&gt;SetAngles(fgkEndCapCoolingTubeAngle[0]-180.,0.,0.);</span>
<span class="lineNum">    5402 </span><span class="lineCov">          3 :   coolingtubecombitrans[2] = new TGeoCombiTrans(*coolingtubetrans[2],</span>
<span class="lineNum">    5403 </span><span class="lineCov">          1 :                                                                                                 *coolingtuberot[2]);</span>
<span class="lineNum">    5404 </span>            : 
<span class="lineNum">    5405 </span><span class="lineCov">          2 :   coolingtubematrix[0] = new TGeoHMatrix((*coolingtubecombitrans[2])</span>
<span class="lineNum">    5406 </span><span class="lineCov">          1 :                                            *                             (*coolingtubecombitrans[1]));</span>
<span class="lineNum">    5407 </span>            : 
<span class="lineNum">    5408 </span><span class="lineCov">          2 :   torustubetrans[0]-&gt;SetTranslation(-fgkEndCapCoolingTubeAxialRadius[0],0.,</span>
<span class="lineNum">    5409 </span><span class="lineCov">          1 :                                                                          endcapcoolingtubeshape[1]-&gt;GetDz());</span>
<span class="lineNum">    5410 </span><span class="lineCov">          1 :   torustuberot[0]-&gt;SetAngles(0.,90.,0.); </span>
<span class="lineNum">    5411 </span><span class="lineCov">          2 :   torustubecombitrans[0] = new TGeoCombiTrans(*torustubetrans[0],*torustuberot[0]);</span>
<span class="lineNum">    5412 </span>            : 
<span class="lineNum">    5413 </span><span class="lineCov">          2 :   torustubematrix[0] = new TGeoHMatrix((*coolingtubematrix[0])*(*torustubecombitrans[0]));</span>
<span class="lineNum">    5414 </span>            : 
<span class="lineNum">    5415 </span><span class="lineCov">          2 :   coolingtubetrans[3]-&gt;SetTranslation(-fgkEndCapCoolingTubeAxialRadius[0],</span>
<span class="lineNum">    5416 </span><span class="lineCov">          1 :                                                                           -endcapcoolingtubeshape[2]-&gt;GetDz(),0.);</span>
<span class="lineNum">    5417 </span><span class="lineCov">          1 :   coolingtuberot[3]-&gt;SetAngles(0.,90.,0.);</span>
<span class="lineNum">    5418 </span><span class="lineCov">          3 :   coolingtubecombitrans[3] = new TGeoCombiTrans(*coolingtubetrans[3],</span>
<span class="lineNum">    5419 </span><span class="lineCov">          1 :                                                                                                 *coolingtuberot[3]);</span>
<span class="lineNum">    5420 </span><span class="lineCov">          1 :   coolingtuberot[4]-&gt;SetAngles(-180.+fgkEndCapCoolingTubeAngle[1],0.,0.);</span>
<span class="lineNum">    5421 </span><span class="lineCov">          2 :   coolingtubematrix[1] = new TGeoHMatrix((*coolingtuberot[4])*(*coolingtubecombitrans[3]));</span>
<span class="lineNum">    5422 </span><span class="lineCov">          1 :   coolingtubematrix[1]-&gt;MultiplyLeft(torustubematrix[0]);</span>
<span class="lineNum">    5423 </span>            :   
<span class="lineNum">    5424 </span><span class="lineCov">          2 :   torustubetrans[1]-&gt;SetTranslation(-fgkEndCapCoolingTubeAxialRadius[0],0.,</span>
<span class="lineNum">    5425 </span><span class="lineCov">          1 :                                                                         endcapcoolingtubeshape[2]-&gt;GetDz());</span>
<span class="lineNum">    5426 </span><span class="lineCov">          1 :   torustuberot[1]-&gt;SetAngles(0.,90.,0.); </span>
<span class="lineNum">    5427 </span><span class="lineCov">          2 :   torustubecombitrans[1] = new TGeoCombiTrans(*torustubetrans[1],*torustuberot[1]);</span>
<span class="lineNum">    5428 </span><span class="lineCov">          1 :   torustuberot[2]-&gt;SetAngles(180.,0.,0.); </span>
<span class="lineNum">    5429 </span><span class="lineCov">          2 :   torustubematrix[2] = new TGeoHMatrix((*torustuberot[2])*(*torustubecombitrans[1]));</span>
<span class="lineNum">    5430 </span><span class="lineCov">          1 :   torustubematrix[2]-&gt;MultiplyLeft(coolingtubematrix[1]);</span>
<span class="lineNum">    5431 </span>            : 
<span class="lineNum">    5432 </span><span class="lineCov">          2 :   torustubetrans[2]-&gt;SetTranslation(0.,fgkEndCapCoolingTubeAxialRadius[0],</span>
<span class="lineNum">    5433 </span><span class="lineCov">          1 :                                                                         -fgkEndCapCoolingTubeAxialRadius[0]);</span>
<span class="lineNum">    5434 </span><span class="lineCov">          1 :   torustuberot[3]-&gt;SetAngles(0.,90.,0.); </span>
<span class="lineNum">    5435 </span><span class="lineCov">          2 :   torustubecombitrans[2] = new TGeoCombiTrans(*torustubetrans[2],*torustuberot[3]);</span>
<span class="lineNum">    5436 </span><span class="lineCov">          1 :   torustuberot[4]-&gt;SetAngles(fgkEndCapCoolingTubeAngle[2]-90.,0.,0.); </span>
<span class="lineNum">    5437 </span><span class="lineCov">          2 :   torustubematrix[3] = new TGeoHMatrix((*torustuberot[4])*(*torustubecombitrans[2]));</span>
<span class="lineNum">    5438 </span><span class="lineCov">          1 :   torustubematrix[3]-&gt;MultiplyLeft(torustubematrix[2]);</span>
<span class="lineNum">    5439 </span>            : 
<span class="lineNum">    5440 </span><span class="lineCov">          2 :   coolingtubetrans[4]-&gt;SetTranslation(-endcapcoolingtubeshape[3]-&gt;GetDz(),</span>
<span class="lineNum">    5441 </span><span class="lineCov">          1 :                                                                           fgkEndCapCoolingTubeAxialRadius[0],0.);</span>
<span class="lineNum">    5442 </span><span class="lineCov">          1 :   coolingtuberot[5]-&gt;SetAngles(90.,90.,-90.);</span>
<span class="lineNum">    5443 </span><span class="lineCov">          3 :   coolingtubecombitrans[4] = new TGeoCombiTrans(*coolingtubetrans[4],</span>
<span class="lineNum">    5444 </span><span class="lineCov">          1 :                                                                                                 *coolingtuberot[5]);</span>
<span class="lineNum">    5445 </span><span class="lineCov">          1 :   coolingtuberot[6]-&gt;SetAngles(fgkEndCapCoolingTubeAngle[3],0.,0.);</span>
<span class="lineNum">    5446 </span><span class="lineCov">          2 :   coolingtubematrix[2] = new TGeoHMatrix((*coolingtuberot[6])*(*coolingtubecombitrans[4]));</span>
<span class="lineNum">    5447 </span><span class="lineCov">          1 :   coolingtubematrix[2]-&gt;MultiplyLeft(torustubematrix[3]);</span>
<span class="lineNum">    5448 </span>            :   
<span class="lineNum">    5449 </span><span class="lineCov">          2 :   torustubetrans[3]-&gt;SetTranslation(-fgkEndCapCoolingTubeAxialRadius[1],0.,</span>
<span class="lineNum">    5450 </span><span class="lineCov">          1 :                                                                         endcapcoolingtubeshape[0]-&gt;GetDz());</span>
<span class="lineNum">    5451 </span><span class="lineCov">          1 :   torustuberot[5]-&gt;SetAngles(0.,90.,0.); </span>
<span class="lineNum">    5452 </span><span class="lineCov">          2 :   torustubecombitrans[3] = new TGeoCombiTrans(*torustubetrans[3],*torustuberot[5]);</span>
<span class="lineNum">    5453 </span><span class="lineCov">          1 :   torustuberot[6]-&gt;SetAngles(-90.,0.,0.); </span>
<span class="lineNum">    5454 </span><span class="lineCov">          2 :   torustubematrix[4] = new TGeoHMatrix((*torustuberot[6])*(*torustubecombitrans[3]));</span>
<span class="lineNum">    5455 </span><span class="lineCov">          1 :   torustubematrix[4]-&gt;MultiplyLeft(coolingtubecombitrans[0]);</span>
<span class="lineNum">    5456 </span>            :   
<span class="lineNum">    5457 </span><span class="lineCov">          2 :   coolingtubetrans[5]-&gt;SetTranslation(fgkEndCapCoolingTubeAxialRadius[1],</span>
<span class="lineNum">    5458 </span><span class="lineCov">          1 :                                                                           endcapcoolingtubeshape[3]-&gt;GetDz(),0.);</span>
<span class="lineNum">    5459 </span><span class="lineCov">          1 :   coolingtuberot[6]-&gt;SetAngles(0.,90.,0.);</span>
<span class="lineNum">    5460 </span><span class="lineCov">          3 :   coolingtubecombitrans[5] = new TGeoCombiTrans(*coolingtubetrans[5],</span>
<span class="lineNum">    5461 </span><span class="lineCov">          1 :                                                                                                 *coolingtuberot[6]);</span>
<span class="lineNum">    5462 </span><span class="lineCov">          1 :   coolingtuberot[7]-&gt;SetAngles(fgkEndCapCoolingTubeAngle[4],0.,0.);</span>
<span class="lineNum">    5463 </span><span class="lineCov">          2 :   coolingtubematrix[3] = new TGeoHMatrix((*coolingtuberot[7])*(*coolingtubecombitrans[5]));</span>
<span class="lineNum">    5464 </span><span class="lineCov">          1 :   coolingtubematrix[3]-&gt;MultiplyLeft(torustubematrix[4]);</span>
<span class="lineNum">    5465 </span>            :     /////////////////////////////////////////
<span class="lineNum">    5466 </span>            :   // Transformation for Water Volume Positioning 
<span class="lineNum">    5467 </span>            :   /////////////////////////////////////////
<span class="lineNum">    5468 </span><span class="lineCov">          2 :   coolingwatertubetrans[0]-&gt;SetTranslation(fgkEndCapCoolingTubeAxialRadius[0],</span>
<span class="lineNum">    5469 </span><span class="lineCov">          1 :                                                                           -endcapcoolingwatertubeshape[0]-&gt;GetDz(),0.);</span>
<span class="lineNum">    5470 </span><span class="lineCov">          1 :   coolingwatertuberot[0]-&gt;SetAngles(0.,90.,0.);</span>
<span class="lineNum">    5471 </span><span class="lineCov">          3 :   coolingwatertubecombitrans[0] = new TGeoCombiTrans(*coolingwatertubetrans[0],</span>
<span class="lineNum">    5472 </span><span class="lineCov">          1 :                                                                                                      *coolingwatertuberot[0]);</span>
<span class="lineNum">    5473 </span>            : 
<span class="lineNum">    5474 </span><span class="lineCov">          1 :   coolingwatertubetrans[1]-&gt;SetTranslation(0.,-endcapcoolingwatertubeshape[1]-&gt;GetDz(),0.);</span>
<span class="lineNum">    5475 </span><span class="lineCov">          1 :   coolingwatertuberot[1]-&gt;SetAngles(0.,90.,0.);</span>
<span class="lineNum">    5476 </span><span class="lineCov">          3 :   coolingwatertubecombitrans[1] = new TGeoCombiTrans(*coolingwatertubetrans[1],</span>
<span class="lineNum">    5477 </span><span class="lineCov">          1 :                                                                                                      *coolingwatertuberot[1]);</span>
<span class="lineNum">    5478 </span>            : 
<span class="lineNum">    5479 </span><span class="lineCov">          2 :   coolingwatertubetrans[2]-&gt;SetTranslation(fgkEndCapCoolingTubeAxialRadius[0]</span>
<span class="lineNum">    5480 </span><span class="lineCov">          1 :                                                                                   *CosD(fgkEndCapCoolingTubeAngle[0]),</span>
<span class="lineNum">    5481 </span><span class="lineCov">          1 :                                                                                   fgkEndCapCoolingTubeAxialRadius[0]</span>
<span class="lineNum">    5482 </span><span class="lineCov">          1 :                                                                                   *SinD(fgkEndCapCoolingTubeAngle[0]),</span>
<span class="lineNum">    5483 </span>            :                                                                               0.);
<span class="lineNum">    5484 </span><span class="lineCov">          1 :   coolingwatertuberot[2]-&gt;SetAngles(fgkEndCapCoolingTubeAngle[0]-180.,0.,0.);</span>
<span class="lineNum">    5485 </span><span class="lineCov">          3 :   coolingwatertubecombitrans[2] = new TGeoCombiTrans(*coolingwatertubetrans[2],</span>
<span class="lineNum">    5486 </span><span class="lineCov">          1 :                                                                                                     *coolingwatertuberot[2]);</span>
<span class="lineNum">    5487 </span>            : 
<span class="lineNum">    5488 </span><span class="lineCov">          2 :   coolingwatertubematrix[0] = new TGeoHMatrix((*coolingwatertubecombitrans[2])</span>
<span class="lineNum">    5489 </span><span class="lineCov">          1 :                                            *                                 (*coolingwatertubecombitrans[1]));</span>
<span class="lineNum">    5490 </span>            :                                            
<span class="lineNum">    5491 </span><span class="lineCov">          2 :   toruswatertubetrans[0]-&gt;SetTranslation(-fgkEndCapCoolingTubeAxialRadius[0],0.,</span>
<span class="lineNum">    5492 </span><span class="lineCov">          1 :                                                                          endcapcoolingwatertubeshape[1]-&gt;GetDz());</span>
<span class="lineNum">    5493 </span><span class="lineCov">          1 :   toruswatertuberot[0]-&gt;SetAngles(0.,90.,0.); </span>
<span class="lineNum">    5494 </span><span class="lineCov">          3 :   toruswatertubecombitrans[0] = new TGeoCombiTrans(*toruswatertubetrans[0],</span>
<span class="lineNum">    5495 </span><span class="lineCov">          1 :                                                                                                    *toruswatertuberot[0]);</span>
<span class="lineNum">    5496 </span>            : 
<span class="lineNum">    5497 </span><span class="lineCov">          2 :   toruswatertubematrix[0] = new TGeoHMatrix((*coolingwatertubematrix[0])</span>
<span class="lineNum">    5498 </span><span class="lineCov">          1 :                                                   *                                     (*toruswatertubecombitrans[0]));</span>
<span class="lineNum">    5499 </span>            : 
<span class="lineNum">    5500 </span><span class="lineCov">          2 :   coolingwatertubetrans[3]-&gt;SetTranslation(-fgkEndCapCoolingTubeAxialRadius[0],</span>
<span class="lineNum">    5501 </span><span class="lineCov">          1 :                                                                           -endcapcoolingwatertubeshape[2]-&gt;GetDz(),0.);</span>
<span class="lineNum">    5502 </span><span class="lineCov">          1 :   coolingwatertuberot[3]-&gt;SetAngles(0.,90.,0.);</span>
<span class="lineNum">    5503 </span><span class="lineCov">          3 :   coolingwatertubecombitrans[3] = new TGeoCombiTrans(*coolingwatertubetrans[3],</span>
<span class="lineNum">    5504 </span><span class="lineCov">          1 :                                                                                                      *coolingwatertuberot[3]);</span>
<span class="lineNum">    5505 </span><span class="lineCov">          1 :   coolingwatertuberot[4]-&gt;SetAngles(-180.+fgkEndCapCoolingTubeAngle[1],0.,0.);</span>
<span class="lineNum">    5506 </span><span class="lineCov">          2 :   coolingwatertubematrix[1] = new TGeoHMatrix((*coolingwatertuberot[4])</span>
<span class="lineNum">    5507 </span><span class="lineCov">          1 :                                                         *                                 (*coolingwatertubecombitrans[3]));</span>
<span class="lineNum">    5508 </span><span class="lineCov">          1 :   coolingwatertubematrix[1]-&gt;MultiplyLeft(toruswatertubematrix[0]);</span>
<span class="lineNum">    5509 </span>            : 
<span class="lineNum">    5510 </span><span class="lineCov">          2 :   toruswatertubetrans[1]-&gt;SetTranslation(-fgkEndCapCoolingTubeAxialRadius[0],0.,</span>
<span class="lineNum">    5511 </span><span class="lineCov">          1 :                                                                         endcapcoolingwatertubeshape[2]-&gt;GetDz());</span>
<span class="lineNum">    5512 </span><span class="lineCov">          1 :   toruswatertuberot[1]-&gt;SetAngles(0.,90.,0.); </span>
<span class="lineNum">    5513 </span><span class="lineCov">          3 :   toruswatertubecombitrans[1] = new TGeoCombiTrans(*toruswatertubetrans[1],</span>
<span class="lineNum">    5514 </span><span class="lineCov">          1 :                                                                                                    *toruswatertuberot[1]);</span>
<span class="lineNum">    5515 </span><span class="lineCov">          1 :   toruswatertuberot[2]-&gt;SetAngles(180.,0.,0.); </span>
<span class="lineNum">    5516 </span><span class="lineCov">          2 :   toruswatertubematrix[2] = new TGeoHMatrix((*toruswatertuberot[2])</span>
<span class="lineNum">    5517 </span><span class="lineCov">          1 :                                                   *                 (*toruswatertubecombitrans[1]));</span>
<span class="lineNum">    5518 </span><span class="lineCov">          1 :   toruswatertubematrix[2]-&gt;MultiplyLeft(coolingwatertubematrix[1]);</span>
<span class="lineNum">    5519 </span>            :   
<span class="lineNum">    5520 </span><span class="lineCov">          2 :   toruswatertubetrans[2]-&gt;SetTranslation(0.,fgkEndCapCoolingTubeAxialRadius[0],</span>
<span class="lineNum">    5521 </span><span class="lineCov">          1 :                                                                                    -fgkEndCapCoolingTubeAxialRadius[0]);</span>
<span class="lineNum">    5522 </span><span class="lineCov">          1 :   toruswatertuberot[3]-&gt;SetAngles(0.,90.,0.); </span>
<span class="lineNum">    5523 </span><span class="lineCov">          3 :   toruswatertubecombitrans[2] = new TGeoCombiTrans(*toruswatertubetrans[2],</span>
<span class="lineNum">    5524 </span><span class="lineCov">          1 :                                                                                                    *toruswatertuberot[3]);</span>
<span class="lineNum">    5525 </span><span class="lineCov">          1 :   toruswatertuberot[4]-&gt;SetAngles(fgkEndCapCoolingTubeAngle[2]-90.,0.,0.); </span>
<span class="lineNum">    5526 </span><span class="lineCov">          2 :   toruswatertubematrix[3] = new TGeoHMatrix((*toruswatertuberot[4])</span>
<span class="lineNum">    5527 </span><span class="lineCov">          1 :                                                   *                                     (*toruswatertubecombitrans[2]));</span>
<span class="lineNum">    5528 </span><span class="lineCov">          1 :   toruswatertubematrix[3]-&gt;MultiplyLeft(toruswatertubematrix[2]);</span>
<span class="lineNum">    5529 </span>            : 
<span class="lineNum">    5530 </span><span class="lineCov">          2 :   coolingwatertubetrans[4]-&gt;SetTranslation(-endcapcoolingwatertubeshape[3]-&gt;GetDz(),</span>
<span class="lineNum">    5531 </span><span class="lineCov">          1 :                                                                                 fgkEndCapCoolingTubeAxialRadius[0],0.);</span>
<span class="lineNum">    5532 </span><span class="lineCov">          1 :   coolingwatertuberot[5]-&gt;SetAngles(90.,90.,-90.);</span>
<span class="lineNum">    5533 </span><span class="lineCov">          3 :   coolingwatertubecombitrans[4] = new TGeoCombiTrans(*coolingwatertubetrans[4],</span>
<span class="lineNum">    5534 </span><span class="lineCov">          1 :                                                                                                      *coolingwatertuberot[5]);</span>
<span class="lineNum">    5535 </span><span class="lineCov">          1 :   coolingwatertuberot[6]-&gt;SetAngles(fgkEndCapCoolingTubeAngle[3],0.,0.);</span>
<span class="lineNum">    5536 </span><span class="lineCov">          2 :   coolingwatertubematrix[2] = new TGeoHMatrix((*coolingwatertuberot[6])</span>
<span class="lineNum">    5537 </span><span class="lineCov">          1 :                                                         *                                 (*coolingwatertubecombitrans[4]));</span>
<span class="lineNum">    5538 </span><span class="lineCov">          1 :   coolingwatertubematrix[2]-&gt;MultiplyLeft(toruswatertubematrix[3]);</span>
<span class="lineNum">    5539 </span>            :   
<span class="lineNum">    5540 </span><span class="lineCov">          2 :   toruswatertubetrans[3]-&gt;SetTranslation(-fgkEndCapCoolingTubeAxialRadius[1],0.,</span>
<span class="lineNum">    5541 </span><span class="lineCov">          1 :                                                                               endcapcoolingwatertubeshape[0]-&gt;GetDz());</span>
<span class="lineNum">    5542 </span><span class="lineCov">          1 :   toruswatertuberot[5]-&gt;SetAngles(0.,90.,0.); </span>
<span class="lineNum">    5543 </span><span class="lineCov">          3 :   toruswatertubecombitrans[3] = new TGeoCombiTrans(*toruswatertubetrans[3],</span>
<span class="lineNum">    5544 </span><span class="lineCov">          1 :                                                                                                    *toruswatertuberot[5]);</span>
<span class="lineNum">    5545 </span><span class="lineCov">          1 :   toruswatertuberot[6]-&gt;SetAngles(-90.,0.,0.); </span>
<span class="lineNum">    5546 </span><span class="lineCov">          2 :   toruswatertubematrix[4] = new TGeoHMatrix((*toruswatertuberot[6])</span>
<span class="lineNum">    5547 </span><span class="lineCov">          1 :                                                   *                 (*toruswatertubecombitrans[3]));</span>
<span class="lineNum">    5548 </span><span class="lineCov">          1 :   toruswatertubematrix[4]-&gt;MultiplyLeft(coolingwatertubecombitrans[0]);</span>
<span class="lineNum">    5549 </span>            :   
<span class="lineNum">    5550 </span><span class="lineCov">          2 :   coolingwatertubetrans[5]-&gt;SetTranslation(fgkEndCapCoolingTubeAxialRadius[1],</span>
<span class="lineNum">    5551 </span><span class="lineCov">          1 :                                                                           endcapcoolingwatertubeshape[3]-&gt;GetDz(),0.);</span>
<span class="lineNum">    5552 </span><span class="lineCov">          1 :   coolingwatertuberot[6]-&gt;SetAngles(0.,90.,0.);</span>
<span class="lineNum">    5553 </span><span class="lineCov">          3 :   coolingwatertubecombitrans[5] = new TGeoCombiTrans(*coolingwatertubetrans[5],</span>
<span class="lineNum">    5554 </span><span class="lineCov">          1 :                                                                                                      *coolingwatertuberot[6]);</span>
<span class="lineNum">    5555 </span><span class="lineCov">          1 :   coolingwatertuberot[7]-&gt;SetAngles(fgkEndCapCoolingTubeAngle[4],0.,0.);</span>
<span class="lineNum">    5556 </span><span class="lineCov">          2 :   coolingwatertubematrix[3] = new TGeoHMatrix((*coolingwatertuberot[7])</span>
<span class="lineNum">    5557 </span><span class="lineCov">          1 :                                                         *                                 (*coolingwatertubecombitrans[5]));</span>
<span class="lineNum">    5558 </span><span class="lineCov">          1 :   coolingwatertubematrix[3]-&gt;MultiplyLeft(toruswatertubematrix[4]);</span>
<span class="lineNum">    5559 </span>            :   /////////////////////////////////////////
<span class="lineNum">    5560 </span>            :   // Positioning Volumes
<span class="lineNum">    5561 </span>            :   /////////////////////////////////////////
<span class="lineNum">    5562 </span><span class="lineCov">          1 :   endcapcoolingtubemother-&gt;AddNode(endcapcoolingtubetorus[0],1);</span>
<span class="lineNum">    5563 </span><span class="lineCov">          1 :   endcapcoolingtubemother-&gt;AddNode(endcapcoolingwatertubetorus[0],1);</span>
<span class="lineNum">    5564 </span>            :   
<span class="lineNum">    5565 </span><span class="lineCov">          1 :   endcapcoolingtubemother-&gt;AddNode(endcapcoolingtube[0],1,coolingtubecombitrans[0]);</span>
<span class="lineNum">    5566 </span><span class="lineCov">          1 :   endcapcoolingtubemother-&gt;AddNode(endcapcoolingwatertube[0],1,coolingwatertubecombitrans[0]);</span>
<span class="lineNum">    5567 </span>            : 
<span class="lineNum">    5568 </span><span class="lineCov">          1 :   endcapcoolingtubemother-&gt;AddNode(endcapcoolingtube[1],1,coolingtubematrix[0]);</span>
<span class="lineNum">    5569 </span><span class="lineCov">          1 :   endcapcoolingtubemother-&gt;AddNode(endcapcoolingwatertube[1],1,coolingwatertubematrix[0]);</span>
<span class="lineNum">    5570 </span>            :  
<span class="lineNum">    5571 </span><span class="lineCov">          1 :   endcapcoolingtubemother-&gt;AddNode(endcapcoolingtubetorus[1],1,torustubematrix[0]);</span>
<span class="lineNum">    5572 </span><span class="lineCov">          1 :   endcapcoolingtubemother-&gt;AddNode(endcapcoolingwatertubetorus[1],1,toruswatertubematrix[0]);</span>
<span class="lineNum">    5573 </span>            : 
<span class="lineNum">    5574 </span><span class="lineCov">          1 :   endcapcoolingtubemother-&gt;AddNode(endcapcoolingtube[2],1,coolingtubematrix[1]);</span>
<span class="lineNum">    5575 </span><span class="lineCov">          1 :   endcapcoolingtubemother-&gt;AddNode(endcapcoolingwatertube[2],1,coolingwatertubematrix[1]);</span>
<span class="lineNum">    5576 </span>            : 
<span class="lineNum">    5577 </span><span class="lineCov">          1 :   endcapcoolingtubemother-&gt;AddNode(endcapcoolingtubetorus[2],1,torustubematrix[2]);</span>
<span class="lineNum">    5578 </span><span class="lineCov">          1 :   endcapcoolingtubemother-&gt;AddNode(endcapcoolingwatertubetorus[2],1,toruswatertubematrix[2]);</span>
<span class="lineNum">    5579 </span>            : 
<span class="lineNum">    5580 </span><span class="lineCov">          1 :   endcapcoolingtubemother-&gt;AddNode(endcapcoolingtubetorus[3],1,torustubematrix[3]);</span>
<span class="lineNum">    5581 </span><span class="lineCov">          1 :   endcapcoolingtubemother-&gt;AddNode(endcapcoolingwatertubetorus[3],1,toruswatertubematrix[3]);</span>
<span class="lineNum">    5582 </span>            : 
<span class="lineNum">    5583 </span><span class="lineCov">          1 :   endcapcoolingtubemother-&gt;AddNode(endcapcoolingtube[3],1,coolingtubematrix[2]);</span>
<span class="lineNum">    5584 </span><span class="lineCov">          1 :   endcapcoolingtubemother-&gt;AddNode(endcapcoolingwatertube[3],1,coolingwatertubematrix[2]);</span>
<span class="lineNum">    5585 </span>            :   
<span class="lineNum">    5586 </span><span class="lineCov">          1 :   endcapcoolingtubemother-&gt;AddNode(endcapcoolingtubetorus[4],1,torustubematrix[4]);</span>
<span class="lineNum">    5587 </span><span class="lineCov">          1 :   endcapcoolingtubemother-&gt;AddNode(endcapcoolingwatertubetorus[4],1,toruswatertubematrix[4]);</span>
<span class="lineNum">    5588 </span>            :  
<span class="lineNum">    5589 </span><span class="lineCov">          1 :   endcapcoolingtubemother-&gt;AddNode(endcapcoolingtube[3],2,coolingtubematrix[3]);</span>
<span class="lineNum">    5590 </span><span class="lineCov">          1 :   endcapcoolingtubemother-&gt;AddNode(endcapcoolingwatertube[3],2,coolingwatertubematrix[3]);</span>
<span class="lineNum">    5591 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    5592 </span>            :   // Deallocating memory
<span class="lineNum">    5593 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    5594 </span><span class="lineCov">         18 :   for(Int_t i=0; i&lt;8; i++){</span>
<span class="lineNum">    5595 </span><span class="lineCov">          8 :     if(i&lt;6){</span>
<span class="lineNum">    5596 </span><span class="lineCov">         12 :          delete coolingtubetrans[i];</span>
<span class="lineNum">    5597 </span><span class="lineCov">         12 :          delete coolingwatertubetrans[i];</span>
<span class="lineNum">    5598 </span><span class="lineCov">          6 :          if(i!=0){</span>
<span class="lineNum">    5599 </span><span class="lineCov">         10 :           delete coolingtubecombitrans[i];</span>
<span class="lineNum">    5600 </span><span class="lineCov">         10 :           delete coolingwatertubecombitrans[i];</span>
<span class="lineNum">    5601 </span>            :          }
<span class="lineNum">    5602 </span>            :         }
<span class="lineNum">    5603 </span><span class="lineCov">          8 :     if(i&lt;8){</span>
<span class="lineNum">    5604 </span><span class="lineCov">         16 :           delete coolingtuberot[i];</span>
<span class="lineNum">    5605 </span><span class="lineCov">         16 :           delete coolingwatertuberot[i];</span>
<span class="lineNum">    5606 </span>            :     }
<span class="lineNum">    5607 </span><span class="lineCov">          8 :     if(i&lt;4){</span>
<span class="lineNum">    5608 </span><span class="lineCov">          8 :                 delete torustubetrans[i];</span>
<span class="lineNum">    5609 </span><span class="lineCov">          8 :                 delete toruswatertubetrans[i];</span>
<span class="lineNum">    5610 </span><span class="lineCov">          8 :                 delete torustubecombitrans[i];</span>
<span class="lineNum">    5611 </span><span class="lineCov">          8 :                 delete toruswatertubecombitrans[i];</span>
<span class="lineNum">    5612 </span>            :         } 
<span class="lineNum">    5613 </span><span class="lineCov">          8 :     if(i&lt;7){</span>
<span class="lineNum">    5614 </span><span class="lineCov">         14 :          delete torustuberot[i];</span>
<span class="lineNum">    5615 </span><span class="lineCov">         14 :          delete toruswatertuberot[i];</span>
<span class="lineNum">    5616 </span>            :         }
<span class="lineNum">    5617 </span>            :   }
<span class="lineNum">    5618 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    5619 </span><span class="lineCov">          1 :   endcapcoolingtubemother-&gt;GetShape()-&gt;ComputeBBox(); //RS: enforce recompting of BBox</span>
<span class="lineNum">    5620 </span>            : 
<span class="lineNum">    5621 </span><span class="lineCov">          1 :   return endcapcoolingtubemother;</span>
<a name="5622"><span class="lineNum">    5622 </span><span class="lineCov">          1 :  }</span></a>
<span class="lineNum">    5623 </span>            :  ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    5624 </span>            :  TGeoVolume* AliITSv11GeometrySSD::GetEndCapSideCover() const {
<span class="lineNum">    5625 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    5626 </span>            :   // Getting EndCap Cover Side 
<span class="lineNum">    5627 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    5628 </span>            :   const Int_t kendcapcoverholenumber[2] = {7,5}; 
<span class="lineNum">    5629 </span>            :   const Int_t kvertexnumber = 15; 
<span class="lineNum">    5630 </span><span class="lineCov">          2 :   Double_t xvertex[kvertexnumber], yvertex[kvertexnumber];</span>
<span class="lineNum">    5631 </span><span class="lineCov">          1 :   xvertex[0]  = 0.0;</span>
<span class="lineNum">    5632 </span><span class="lineCov">          1 :   xvertex[1]  = xvertex[0];</span>
<span class="lineNum">    5633 </span><span class="lineCov">          1 :   xvertex[2]  = fgkEndCapSideCoverLength[0];</span>
<span class="lineNum">    5634 </span><span class="lineCov">          1 :   xvertex[3]  = fgkEndCapSideCoverLength[1];</span>
<span class="lineNum">    5635 </span><span class="lineCov">          1 :   xvertex[4]  = xvertex[3];</span>
<span class="lineNum">    5636 </span><span class="lineCov">          1 :   xvertex[5]  = fgkEndCapSideCoverLength[2];</span>
<span class="lineNum">    5637 </span><span class="lineCov">          1 :   xvertex[6]  = xvertex[5];</span>
<span class="lineNum">    5638 </span><span class="lineCov">          1 :   xvertex[7]  = xvertex[2];</span>
<span class="lineNum">    5639 </span><span class="lineCov">          1 :   xvertex[8]  = xvertex[7];</span>
<span class="lineNum">    5640 </span><span class="lineCov">          1 :   xvertex[9]  = xvertex[6]-fgkEndCapSideCoverLength[0];</span>
<span class="lineNum">    5641 </span><span class="lineCov">          1 :   xvertex[10] = xvertex[9];</span>
<span class="lineNum">    5642 </span><span class="lineCov">          3 :   xvertex[11] = xvertex[5]-fgkEndCapSideCoverLength[0]-kendcapcoverholenumber[1]</span>
<span class="lineNum">    5643 </span><span class="lineCov">          2 :                           * fgkEndCapSideCoverLength[3]-(kendcapcoverholenumber[1]-1)</span>
<span class="lineNum">    5644 </span><span class="lineCov">          1 :                           * fgkEndCapSideCoverLength[4];</span>
<span class="lineNum">    5645 </span><span class="lineCov">          1 :   xvertex[12] = xvertex[11];</span>
<span class="lineNum">    5646 </span><span class="lineCov">          3 :   xvertex[13] = xvertex[5]-fgkEndCapSideCoverLength[0]-kendcapcoverholenumber[0]</span>
<span class="lineNum">    5647 </span><span class="lineCov">          2 :                           * fgkEndCapSideCoverLength[3]-(kendcapcoverholenumber[0]-1)</span>
<span class="lineNum">    5648 </span><span class="lineCov">          1 :                           * fgkEndCapSideCoverLength[4];</span>
<span class="lineNum">    5649 </span><span class="lineCov">          1 :   xvertex[14] = xvertex[13];</span>
<span class="lineNum">    5650 </span><span class="lineCov">          1 :   yvertex[0]  = 0.0;</span>
<span class="lineNum">    5651 </span><span class="lineCov">          1 :   yvertex[1]  = fgkEndCapSideCoverWidth[0];</span>
<span class="lineNum">    5652 </span><span class="lineCov">          1 :   yvertex[2]  = fgkEndCapSideCoverWidth[1]-fgkEndCapSideCoverWidth[2];</span>
<span class="lineNum">    5653 </span><span class="lineCov">          1 :   yvertex[3]  = yvertex[2];</span>
<span class="lineNum">    5654 </span><span class="lineCov">          1 :   yvertex[4]  = fgkEndCapSideCoverWidth[1];</span>
<span class="lineNum">    5655 </span><span class="lineCov">          1 :   yvertex[5]  = yvertex[4];</span>
<span class="lineNum">    5656 </span><span class="lineCov">          1 :   yvertex[6]  = yvertex[0];</span>
<span class="lineNum">    5657 </span><span class="lineCov">          1 :   yvertex[7]  = yvertex[6];</span>
<span class="lineNum">    5658 </span><span class="lineCov">          1 :   yvertex[8]  = fgkEndCapSideCoverWidth[6];</span>
<span class="lineNum">    5659 </span><span class="lineCov">          1 :   yvertex[9]  = yvertex[8];</span>
<span class="lineNum">    5660 </span><span class="lineCov">          1 :   yvertex[10] = fgkEndCapSideCoverWidth[1]-fgkEndCapSideCoverWidth[3];</span>
<span class="lineNum">    5661 </span><span class="lineCov">          1 :   yvertex[11] = yvertex[10];</span>
<span class="lineNum">    5662 </span><span class="lineCov">          1 :   yvertex[12] = yvertex[9]+2.*fgkEndCapSideCoverWidth[5]+fgkEndCapSideCoverLength[4]; </span>
<span class="lineNum">    5663 </span><span class="lineCov">          1 :   yvertex[13] = yvertex[12];</span>
<span class="lineNum">    5664 </span><span class="lineCov">          1 :   yvertex[14] = yvertex[6];</span>
<span class="lineNum">    5665 </span><span class="lineCov">          1 :   TGeoXtru* endcapsidecovershapeout = new TGeoXtru(2);</span>
<span class="lineNum">    5666 </span><span class="lineCov">          1 :   endcapsidecovershapeout-&gt;SetName(&quot;endcapsidecovershapeout&quot;);</span>
<span class="lineNum">    5667 </span><span class="lineCov">          1 :   endcapsidecovershapeout-&gt;DefinePolygon(7,xvertex,yvertex); </span>
<span class="lineNum">    5668 </span><span class="lineCov">          1 :   endcapsidecovershapeout-&gt;DefineSection(0,-0.5*fgkEndCapSideCoverThickness);</span>
<span class="lineNum">    5669 </span><span class="lineCov">          1 :   endcapsidecovershapeout-&gt;DefineSection(1,0.5*fgkEndCapSideCoverThickness);</span>
<span class="lineNum">    5670 </span><span class="lineCov">          1 :   TGeoXtru* endcapsidecovershapein = new TGeoXtru(2);</span>
<span class="lineNum">    5671 </span><span class="lineCov">          1 :   endcapsidecovershapein-&gt;SetName(&quot;endcapsidecovershapein&quot;);</span>
<span class="lineNum">    5672 </span><span class="lineCov">          1 :   endcapsidecovershapein-&gt;DefinePolygon(6,&amp;xvertex[8],&amp;yvertex[8]); </span>
<span class="lineNum">    5673 </span><span class="lineCov">          1 :   endcapsidecovershapein-&gt;DefineSection(0,-0.5*fgkEndCapSideCoverThickness-0.01);</span>
<span class="lineNum">    5674 </span><span class="lineCov">          1 :   endcapsidecovershapein-&gt;DefineSection(1,0.5*fgkEndCapSideCoverThickness+0.01);</span>
<span class="lineNum">    5675 </span>            : 
<span class="lineNum">    5676 </span>            : 
<span class="lineNum">    5677 </span><span class="lineCov">          1 :   TGeoCompositeShape* endcapsidecovershape = new TGeoCompositeShape(&quot;endcapsidecovershape&quot;, &quot;endcapsidecovershapeout-endcapsidecovershapein&quot;);</span>
<span class="lineNum">    5678 </span><span class="lineCov">          2 :   TGeoVolume* endcapsidecover = new TGeoVolume(&quot;EndCapSideCover&quot;,</span>
<span class="lineNum">    5679 </span><span class="lineCov">          1 :                                                                 endcapsidecovershape,fSSDCoolingTubePhynox);</span>
<span class="lineNum">    5680 </span><span class="lineCov">          1 :   endcapsidecover-&gt;SetLineColor(fColorPhynox);</span>
<span class="lineNum">    5681 </span>            :   ////////////////////////////////////////////
<span class="lineNum">    5682 </span>            :   // Defininition of Mother Volume
<span class="lineNum">    5683 </span>            :   ////////////////////////////////////////////
<span class="lineNum">    5684 </span>            :   const Int_t kmothervertexnumber = 7;
<span class="lineNum">    5685 </span><span class="lineCov">          1 :   Double_t xmothervertex[kmothervertexnumber]; </span>
<span class="lineNum">    5686 </span><span class="lineCov">          1 :   Double_t ymothervertex[kmothervertexnumber]; </span>
<span class="lineNum">    5687 </span><span class="lineCov">         16 :   for(Int_t i=0; i&lt;kmothervertexnumber; i++){</span>
<span class="lineNum">    5688 </span><span class="lineCov">          7 :         xmothervertex[i] = xvertex[i];</span>
<span class="lineNum">    5689 </span><span class="lineCov">          7 :         ymothervertex[i] = yvertex[i];</span>
<span class="lineNum">    5690 </span>            :   }
<span class="lineNum">    5691 </span><span class="lineCov">          1 :   TGeoXtru* endcapsidecovermothershape = new TGeoXtru(2);</span>
<span class="lineNum">    5692 </span><span class="lineCov">          1 :   endcapsidecovermothershape-&gt;DefinePolygon(kmothervertexnumber,xmothervertex,ymothervertex); </span>
<span class="lineNum">    5693 </span><span class="lineCov">          1 :   endcapsidecovermothershape-&gt;DefineSection(0,-0.5*fgkEndCapSideCoverThickness);</span>
<span class="lineNum">    5694 </span><span class="lineCov">          1 :   endcapsidecovermothershape-&gt;DefineSection(1,0.5*fgkEndCapSideCoverThickness);</span>
<span class="lineNum">    5695 </span><span class="lineCov">          2 :   TGeoVolume* endcapsidecovermother = new TGeoVolume(&quot;EndCapSideCoverMother&quot;,</span>
<span class="lineNum">    5696 </span><span class="lineCov">          1 :                                                                 endcapsidecovermothershape,fSSDAir);</span>
<span class="lineNum">    5697 </span>            :   ////////////////////////////////////////////
<span class="lineNum">    5698 </span><span class="lineCov">          1 :   endcapsidecovermother-&gt;AddNode(endcapsidecover,1);</span>
<span class="lineNum">    5699 </span>            :   TGeoBBox* endcapsidecoverboxshape[4];
<span class="lineNum">    5700 </span><span class="lineCov">          3 :   endcapsidecoverboxshape[0] = new TGeoBBox(0.5*(kendcapcoverholenumber[0]*fgkEndCapSideCoverLength[3]</span>
<span class="lineNum">    5701 </span><span class="lineCov">          1 :                                                          +     (kendcapcoverholenumber[0]-1)*fgkEndCapSideCoverLength[4]),</span>
<span class="lineNum">    5702 </span><span class="lineCov">          1 :                                                                0.5*fgkEndCapSideCoverLength[4],</span>
<span class="lineNum">    5703 </span><span class="lineCov">          1 :                                                                    0.5*fgkEndCapSideCoverThickness); </span>
<span class="lineNum">    5704 </span><span class="lineCov">          3 :   endcapsidecoverboxshape[1] = new TGeoBBox(0.5*(kendcapcoverholenumber[1]*fgkEndCapSideCoverLength[3]</span>
<span class="lineNum">    5705 </span><span class="lineCov">          1 :                                                          +     (kendcapcoverholenumber[1]-1)*fgkEndCapSideCoverLength[4]),</span>
<span class="lineNum">    5706 </span><span class="lineCov">          2 :                                                                0.5*(fgkEndCapSideCoverWidth[4]-2.*fgkEndCapSideCoverWidth[5]</span>
<span class="lineNum">    5707 </span><span class="lineCov">          1 :                                                          -     fgkEndCapSideCoverLength[4]),</span>
<span class="lineNum">    5708 </span><span class="lineCov">          1 :                                                                    0.5*fgkEndCapSideCoverThickness); </span>
<span class="lineNum">    5709 </span><span class="lineCov">          2 :   endcapsidecoverboxshape[2] = new TGeoBBox(endcapsidecoverboxshape[1]-&gt;GetDX(),</span>
<span class="lineNum">    5710 </span><span class="lineCov">          1 :                                                                0.5*fgkEndCapSideCoverLength[4],</span>
<span class="lineNum">    5711 </span><span class="lineCov">          1 :                                                                    0.5*fgkEndCapSideCoverThickness); </span>
<span class="lineNum">    5712 </span><span class="lineCov">          2 :   endcapsidecoverboxshape[3] = new TGeoBBox(0.5*fgkEndCapSideCoverLength[4],</span>
<span class="lineNum">    5713 </span><span class="lineCov">          1 :                                                                0.5*fgkEndCapSideCoverWidth[5],</span>
<span class="lineNum">    5714 </span><span class="lineCov">          1 :                                                                    0.5*fgkEndCapSideCoverThickness); </span>
<span class="lineNum">    5715 </span><span class="lineCov">          1 :   TGeoVolume* endcapsidecoverbox[4];</span>
<span class="lineNum">    5716 </span><span class="lineCov">          2 :   endcapsidecoverbox[0] = new TGeoVolume(&quot;EndCapSideCoverBox1&quot;,endcapsidecoverboxshape[0],fSSDCoolingTubePhynox);</span>
<span class="lineNum">    5717 </span><span class="lineCov">          2 :   endcapsidecoverbox[1] = new TGeoVolume(&quot;EndCapSideCoverBox2&quot;,endcapsidecoverboxshape[1],fSSDCoolingTubePhynox);</span>
<span class="lineNum">    5718 </span><span class="lineCov">          2 :   endcapsidecoverbox[2] = new TGeoVolume(&quot;EndCapSideCoverBox3&quot;,endcapsidecoverboxshape[2],fSSDCoolingTubePhynox);</span>
<span class="lineNum">    5719 </span><span class="lineCov">          2 :   endcapsidecoverbox[3] = new TGeoVolume(&quot;EndCapSideCoverBox4&quot;,endcapsidecoverboxshape[3],fSSDCoolingTubePhynox);</span>
<span class="lineNum">    5720 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;4; i++)   endcapsidecoverbox[i]-&gt;SetLineColor(fColorPhynox);</span>
<span class="lineNum">    5721 </span>            : //  TGeoTranslation* endcapsidecoverboxtrans[3+2*(kendcapcoverholenumber[0]-1)+2*(kendcapcoverholenumber[1]-1)];
<span class="lineNum">    5722 </span>            :   TGeoTranslation** endcapsidecoverboxtrans;
<span class="lineNum">    5723 </span><span class="lineCov">          1 :   endcapsidecoverboxtrans = new TGeoTranslation*[3+2*(kendcapcoverholenumber[0]-1)+2*(kendcapcoverholenumber[1]-1)];</span>
<span class="lineNum">    5724 </span><span class="lineCov">          3 :   endcapsidecoverboxtrans[0] = new TGeoTranslation(endcapsidecoverboxshape[0]-&gt;GetDX()</span>
<span class="lineNum">    5725 </span><span class="lineCov">          1 :                                                          +                                         fgkEndCapSideCoverLength[0],</span>
<span class="lineNum">    5726 </span><span class="lineCov">          1 :                                                                                                    endcapsidecoverboxshape[0]-&gt;GetDY()</span>
<span class="lineNum">    5727 </span><span class="lineCov">          1 :                                                          +                     yvertex[9]+fgkEndCapSideCoverWidth[5],0.);</span>
<span class="lineNum">    5728 </span><span class="lineCov">          3 :   endcapsidecoverboxtrans[1] = new TGeoTranslation(endcapsidecoverboxshape[1]-&gt;GetDX()</span>
<span class="lineNum">    5729 </span><span class="lineCov">          1 :                                                          +                     xvertex[11],</span>
<span class="lineNum">    5730 </span><span class="lineCov">          1 :                                                                                                    endcapsidecoverboxshape[1]-&gt;GetDY()</span>
<span class="lineNum">    5731 </span><span class="lineCov">          1 :                                                          +                     yvertex[12],0.);</span>
<span class="lineNum">    5732 </span><span class="lineCov">          3 :   endcapsidecoverboxtrans[2] = new TGeoTranslation(endcapsidecoverboxshape[2]-&gt;GetDX()</span>
<span class="lineNum">    5733 </span><span class="lineCov">          1 :                                                          +                     xvertex[11],</span>
<span class="lineNum">    5734 </span><span class="lineCov">          1 :                                                                                                    endcapsidecoverboxshape[2]-&gt;GetDY()</span>
<span class="lineNum">    5735 </span><span class="lineCov">          1 :                                                          +                     yvertex[12]</span>
<span class="lineNum">    5736 </span><span class="lineCov">          2 :                                                          +                                         2.*endcapsidecoverboxshape[1]-&gt;GetDY() </span>
<span class="lineNum">    5737 </span><span class="lineCov">          1 :                                                          +                     fgkEndCapSideCoverWidth[5],0.);</span>
<span class="lineNum">    5738 </span><span class="lineCov">          1 :   endcapsidecovermother-&gt;AddNode(endcapsidecoverbox[0],1,endcapsidecoverboxtrans[0]);</span>
<span class="lineNum">    5739 </span><span class="lineCov">          1 :   endcapsidecovermother-&gt;AddNode(endcapsidecoverbox[1],1,endcapsidecoverboxtrans[1]);</span>
<span class="lineNum">    5740 </span><span class="lineCov">          1 :   endcapsidecovermother-&gt;AddNode(endcapsidecoverbox[2],1,endcapsidecoverboxtrans[2]);</span>
<span class="lineNum">    5741 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;2; i++)</span>
<span class="lineNum">    5742 </span><span class="lineCov">         28 :         for(Int_t j=0; j&lt;kendcapcoverholenumber[0]-1; j++){</span>
<span class="lineNum">    5743 </span><span class="lineCov">         12 :                 endcapsidecoverboxtrans[i*(kendcapcoverholenumber[0]-1)+j+3] = </span>
<span class="lineNum">    5744 </span><span class="lineCov">         36 :                         new TGeoTranslation(endcapsidecoverboxshape[3]-&gt;GetDX()+fgkEndCapSideCoverLength[0]</span>
<span class="lineNum">    5745 </span><span class="lineCov">         12 :                                                                 +(j+1)*fgkEndCapSideCoverLength[3]+j*fgkEndCapSideCoverLength[4],</span>
<span class="lineNum">    5746 </span><span class="lineCov">         24 :                                                                 endcapsidecoverboxshape[3]-&gt;GetDY()+fgkEndCapSideCoverWidth[6]</span>
<span class="lineNum">    5747 </span><span class="lineCov">         12 :                                                                 +i*(fgkEndCapSideCoverWidth[5]+fgkEndCapSideCoverLength[4]),0.0);</span>
<span class="lineNum">    5748 </span><span class="lineCov">         24 :                 endcapsidecovermother-&gt;AddNode(endcapsidecoverbox[3],i*(kendcapcoverholenumber[0]-1)+j+1,</span>
<span class="lineNum">    5749 </span><span class="lineCov">         12 :                                                                 endcapsidecoverboxtrans[i*(kendcapcoverholenumber[0]-1)+j+3]);</span>
<span class="lineNum">    5750 </span>            :         }
<span class="lineNum">    5751 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;2; i++)</span>
<span class="lineNum">    5752 </span><span class="lineCov">         20 :         for(Int_t j=0; j&lt;kendcapcoverholenumber[1]-1; j++){</span>
<span class="lineNum">    5753 </span><span class="lineCov">          8 :                 endcapsidecoverboxtrans[2*(kendcapcoverholenumber[0]-1)+3+i*(kendcapcoverholenumber[1]-1)+j] = </span>
<span class="lineNum">    5754 </span><span class="lineCov">         24 :                 new TGeoTranslation(endcapsidecoverboxshape[3]-&gt;GetDX()+xvertex[12]</span>
<span class="lineNum">    5755 </span><span class="lineCov">          8 :                                                         +(j+1)*fgkEndCapSideCoverLength[3]+j*fgkEndCapSideCoverLength[4],</span>
<span class="lineNum">    5756 </span><span class="lineCov">         16 :                                                         endcapsidecoverboxshape[3]-&gt;GetDY()+fgkEndCapSideCoverWidth[6]</span>
<span class="lineNum">    5757 </span><span class="lineCov">         16 :                                                         +fgkEndCapSideCoverWidth[4]+i*(fgkEndCapSideCoverWidth[5]</span>
<span class="lineNum">    5758 </span><span class="lineCov">          8 :                                                         +fgkEndCapSideCoverLength[4]),0.0);</span>
<span class="lineNum">    5759 </span><span class="lineCov">         16 :                 endcapsidecovermother-&gt;AddNode(endcapsidecoverbox[3],</span>
<span class="lineNum">    5760 </span>            :                                                                 2*(kendcapcoverholenumber[0]-1)+3+i*(kendcapcoverholenumber[1]-1)+j,
<span class="lineNum">    5761 </span><span class="lineCov">          8 :                                                                 endcapsidecoverboxtrans[2*(kendcapcoverholenumber[0]-1)+3</span>
<span class="lineNum">    5762 </span>            :                                                                 +i*(kendcapcoverholenumber[1]-1)+j]);
<span class="lineNum">    5763 </span>            :         }
<span class="lineNum">    5764 </span><span class="lineCov">          2 :   delete [] endcapsidecoverboxtrans;</span>
<span class="lineNum">    5765 </span><span class="lineCov">          1 :   return endcapsidecovermother;</span>
<a name="5766"><span class="lineNum">    5766 </span><span class="lineCov">          1 :  } </span></a>
<span class="lineNum">    5767 </span>            :  ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    5768 </span>            :  TGeoVolume** AliITSv11GeometrySSD::GetEndCapCards() const { 
<span class="lineNum">    5769 </span>            :  ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    5770 </span>            :  // Method returning Interface Card A, Interface Card B, Supply Card 
<span class="lineNum">    5771 </span>            :  ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    5772 </span>            :  /////////////////////
<span class="lineNum">    5773 </span>            :  // Supply Card
<span class="lineNum">    5774 </span>            :  /////////////////////
<span class="lineNum">    5775 </span>            :  // Electronic Board Back Al Plane
<span class="lineNum">    5776 </span>            :  const Int_t kelectboardbackvertexnumber = 8;
<span class="lineNum">    5777 </span><span class="lineCov">          2 :  Double_t xelectboardback[kelectboardbackvertexnumber];</span>
<span class="lineNum">    5778 </span><span class="lineCov">          1 :  Double_t yelectboardback[kelectboardbackvertexnumber];</span>
<span class="lineNum">    5779 </span><span class="lineCov">          1 :  xelectboardback[0] = 0.0;</span>
<span class="lineNum">    5780 </span><span class="lineCov">          1 :  xelectboardback[1] = xelectboardback[0];</span>
<span class="lineNum">    5781 </span><span class="lineCov">          1 :  xelectboardback[2] = fgkEndCapCardElectBoardBackLength[0];</span>
<span class="lineNum">    5782 </span><span class="lineCov">          1 :  xelectboardback[3] = xelectboardback[2];</span>
<span class="lineNum">    5783 </span><span class="lineCov">          1 :  xelectboardback[4] = xelectboardback[3]-fgkEndCapCardElectBoardBackLength[1];</span>
<span class="lineNum">    5784 </span><span class="lineCov">          1 :  xelectboardback[5] = xelectboardback[4];</span>
<span class="lineNum">    5785 </span><span class="lineCov">          1 :  xelectboardback[6] = fgkEndCapCardElectBoardBackLength[1];</span>
<span class="lineNum">    5786 </span><span class="lineCov">          1 :  xelectboardback[7] = xelectboardback[6];</span>
<span class="lineNum">    5787 </span>            :  
<span class="lineNum">    5788 </span><span class="lineCov">          1 :  yelectboardback[0] = 0.0;</span>
<span class="lineNum">    5789 </span><span class="lineCov">          1 :  yelectboardback[1] = fgkEndCapCardElectBoardBackWidth[0];</span>
<span class="lineNum">    5790 </span><span class="lineCov">          1 :  yelectboardback[2] = yelectboardback[1];</span>
<span class="lineNum">    5791 </span><span class="lineCov">          1 :  yelectboardback[3] = yelectboardback[0];</span>
<span class="lineNum">    5792 </span><span class="lineCov">          1 :  yelectboardback[4] = yelectboardback[3];</span>
<span class="lineNum">    5793 </span><span class="lineCov">          1 :  yelectboardback[5] = yelectboardback[4]+fgkEndCapCardElectBoardBackWidth[1];</span>
<span class="lineNum">    5794 </span><span class="lineCov">          1 :  yelectboardback[6] = yelectboardback[5];</span>
<span class="lineNum">    5795 </span><span class="lineCov">          1 :  yelectboardback[7] = yelectboardback[4];</span>
<span class="lineNum">    5796 </span><span class="lineCov">          1 :  TGeoXtru* electboardbackshape = new TGeoXtru(2);</span>
<span class="lineNum">    5797 </span><span class="lineCov">          1 :  electboardbackshape-&gt;DefinePolygon(kelectboardbackvertexnumber,</span>
<span class="lineNum">    5798 </span><span class="lineCov">          1 :                                                                         xelectboardback,yelectboardback); </span>
<span class="lineNum">    5799 </span><span class="lineCov">          1 :  electboardbackshape-&gt;DefineSection(0,0.0);</span>
<span class="lineNum">    5800 </span><span class="lineCov">          1 :  electboardbackshape-&gt;DefineSection(1,fgkEndCapCardElectBoardBackThickness);</span>
<span class="lineNum">    5801 </span><span class="lineCov">          2 :  TGeoVolume* electboardback = new TGeoVolume(&quot;EndCapCardElectBoardBackPlane&quot;,</span>
<span class="lineNum">    5802 </span><span class="lineCov">          1 :                                                                                          electboardbackshape,fSSDSupportRingAl);</span>
<span class="lineNum">    5803 </span><span class="lineCov">          1 :  electboardback-&gt;SetLineColor(fColorAl);</span>
<span class="lineNum">    5804 </span>            :  // Electronic Board Kapton Layer
<span class="lineNum">    5805 </span>            :  const Int_t kelectlayervertexnumber = 8;
<span class="lineNum">    5806 </span><span class="lineCov">          1 :  Double_t xelectlayer[kelectlayervertexnumber];</span>
<span class="lineNum">    5807 </span><span class="lineCov">          1 :  Double_t yelectlayer[kelectlayervertexnumber];</span>
<span class="lineNum">    5808 </span><span class="lineCov">          1 :  xelectlayer[0] = fgkEndCapCardElectBoardBackLength[0]-fgkEndCapCardElectBoardLength;</span>
<span class="lineNum">    5809 </span><span class="lineCov">          1 :  xelectlayer[1] = xelectlayer[0];</span>
<span class="lineNum">    5810 </span><span class="lineCov">          1 :  xelectlayer[2] = fgkEndCapCardElectBoardLength;</span>
<span class="lineNum">    5811 </span><span class="lineCov">          1 :  xelectlayer[3] = xelectlayer[2];</span>
<span class="lineNum">    5812 </span><span class="lineCov">         10 :  for(Int_t i=4; i&lt;kelectlayervertexnumber; i++) xelectlayer[i] = xelectboardback[i]; </span>
<span class="lineNum">    5813 </span>            :      
<span class="lineNum">    5814 </span><span class="lineCov">          1 :  yelectlayer[0] = 0.0;</span>
<span class="lineNum">    5815 </span><span class="lineCov">          1 :  yelectlayer[1] = fgkEndCapCardElectBoardLayerWidth[0];</span>
<span class="lineNum">    5816 </span><span class="lineCov">          1 :  yelectlayer[2] = yelectlayer[1];</span>
<span class="lineNum">    5817 </span><span class="lineCov">          1 :  yelectlayer[3] = yelectlayer[0];</span>
<span class="lineNum">    5818 </span><span class="lineCov">          1 :  yelectlayer[4] = yelectlayer[3];</span>
<span class="lineNum">    5819 </span><span class="lineCov">          1 :  yelectlayer[5] = yelectlayer[4]+fgkEndCapCardElectBoardLayerWidth[1];</span>
<span class="lineNum">    5820 </span><span class="lineCov">          1 :  yelectlayer[6] = yelectlayer[5];</span>
<span class="lineNum">    5821 </span><span class="lineCov">          1 :  yelectlayer[7] = yelectlayer[4];</span>
<span class="lineNum">    5822 </span><span class="lineCov">          1 :  TGeoXtru* electlayershape = new TGeoXtru(2);</span>
<span class="lineNum">    5823 </span><span class="lineCov">          1 :  electlayershape-&gt;DefinePolygon(kelectlayervertexnumber,xelectlayer,yelectlayer); </span>
<span class="lineNum">    5824 </span><span class="lineCov">          1 :  electlayershape-&gt;DefineSection(0,0.0);</span>
<span class="lineNum">    5825 </span><span class="lineCov">          1 :  electlayershape-&gt;DefineSection(1,fgkEndCapCardElectBoardLayerThickness);</span>
<span class="lineNum">    5826 </span><span class="lineCov">          2 :  TGeoVolume* electlayer = new TGeoVolume(&quot;EndCapCardElectBoardLayer&quot;,</span>
<span class="lineNum">    5827 </span><span class="lineCov">          1 :                                                                                          electlayershape,fSSDKaptonFlexMedium);</span>
<span class="lineNum">    5828 </span><span class="lineCov">          1 :  electlayer-&gt;SetLineColor(fColorKapton);</span>
<span class="lineNum">    5829 </span>            :  // JMD Connector Female
<span class="lineNum">    5830 </span>            :  const Int_t kjmdconnectorvertexnumber = 6;
<span class="lineNum">    5831 </span><span class="lineCov">          1 :  Double_t xjmdconnectorvertex[kjmdconnectorvertexnumber]; </span>
<span class="lineNum">    5832 </span><span class="lineCov">          1 :  Double_t yjmdconnectorvertex[kjmdconnectorvertexnumber]; </span>
<span class="lineNum">    5833 </span><span class="lineCov">          1 :  xjmdconnectorvertex[0] = 0.0; </span>
<span class="lineNum">    5834 </span><span class="lineCov">          1 :  xjmdconnectorvertex[1] = xjmdconnectorvertex[0]; </span>
<span class="lineNum">    5835 </span><span class="lineCov">          1 :  xjmdconnectorvertex[2] = fgkEndCapCardJMDConnectorLength[1]; </span>
<span class="lineNum">    5836 </span><span class="lineCov">          1 :  xjmdconnectorvertex[3] = xjmdconnectorvertex[2];  </span>
<span class="lineNum">    5837 </span><span class="lineCov">          1 :  xjmdconnectorvertex[4] = fgkEndCapCardJMDConnectorLength[0]; </span>
<span class="lineNum">    5838 </span><span class="lineCov">          1 :  xjmdconnectorvertex[5] = xjmdconnectorvertex[4]; </span>
<span class="lineNum">    5839 </span>            : 
<span class="lineNum">    5840 </span><span class="lineCov">          1 :  yjmdconnectorvertex[0] = 0.0; </span>
<span class="lineNum">    5841 </span><span class="lineCov">          1 :  yjmdconnectorvertex[1] = fgkEndCapCardJMDConnectorWidth[0]; </span>
<span class="lineNum">    5842 </span><span class="lineCov">          1 :  yjmdconnectorvertex[2] = yjmdconnectorvertex[1]; </span>
<span class="lineNum">    5843 </span><span class="lineCov">          1 :  yjmdconnectorvertex[3] = yjmdconnectorvertex[2]+fgkEndCapCardJMDConnectorWidth[1]; </span>
<span class="lineNum">    5844 </span><span class="lineCov">          1 :  yjmdconnectorvertex[4] = yjmdconnectorvertex[3]; </span>
<span class="lineNum">    5845 </span><span class="lineCov">          1 :  yjmdconnectorvertex[5] = yjmdconnectorvertex[0]; </span>
<span class="lineNum">    5846 </span><span class="lineCov">          1 :  TGeoXtru* jmdconnectorshape = new TGeoXtru(2);</span>
<span class="lineNum">    5847 </span><span class="lineCov">          2 :  jmdconnectorshape-&gt;DefinePolygon(kjmdconnectorvertexnumber,xjmdconnectorvertex,</span>
<span class="lineNum">    5848 </span><span class="lineCov">          1 :                                                                   yjmdconnectorvertex); </span>
<span class="lineNum">    5849 </span><span class="lineCov">          1 :  jmdconnectorshape-&gt;DefineSection(0,0.0);</span>
<span class="lineNum">    5850 </span><span class="lineCov">          1 :  jmdconnectorshape-&gt;DefineSection(1,fgkEndCapCardJMDConnectorThickness);</span>
<span class="lineNum">    5851 </span><span class="lineCov">          2 :  TGeoVolume* jmdconnector = new TGeoVolume(&quot;EndCapCardJMDConnector&quot;,</span>
<span class="lineNum">    5852 </span><span class="lineCov">          1 :                                                                                    jmdconnectorshape,fSSDMountingBlockMedium);</span>
<span class="lineNum">    5853 </span><span class="lineCov">          1 :  jmdconnector-&gt;SetLineColor(fColorG10);</span>
<span class="lineNum">    5854 </span>            :  // Top Cable Connector
<span class="lineNum">    5855 </span>            :  const Int_t kcableconnectorvertexnumber = 8;
<span class="lineNum">    5856 </span><span class="lineCov">          1 :  Double_t xconnectorvertex[kcableconnectorvertexnumber]; </span>
<span class="lineNum">    5857 </span><span class="lineCov">          1 :  Double_t yconnectorvertex[kcableconnectorvertexnumber]; </span>
<span class="lineNum">    5858 </span><span class="lineCov">          1 :  xconnectorvertex[0] = 0.0;</span>
<span class="lineNum">    5859 </span><span class="lineCov">          1 :  xconnectorvertex[1] = xconnectorvertex[0];</span>
<span class="lineNum">    5860 </span><span class="lineCov">          1 :  xconnectorvertex[2] = xconnectorvertex[1]+fgkEndCapCardCableConnectorLength[1];</span>
<span class="lineNum">    5861 </span><span class="lineCov">          1 :  xconnectorvertex[3] = xconnectorvertex[2];</span>
<span class="lineNum">    5862 </span><span class="lineCov">          2 :  xconnectorvertex[4] = fgkEndCapCardCableConnectorLength[0]</span>
<span class="lineNum">    5863 </span><span class="lineCov">          1 :                                          - fgkEndCapCardCableConnectorLength[2];</span>
<span class="lineNum">    5864 </span><span class="lineCov">          1 :  xconnectorvertex[5] = xconnectorvertex[4];</span>
<span class="lineNum">    5865 </span><span class="lineCov">          1 :  xconnectorvertex[6] = fgkEndCapCardCableConnectorLength[0];</span>
<span class="lineNum">    5866 </span><span class="lineCov">          1 :  xconnectorvertex[7] = xconnectorvertex[6];</span>
<span class="lineNum">    5867 </span>            : 
<span class="lineNum">    5868 </span><span class="lineCov">          1 :  yconnectorvertex[0] = 0.0;</span>
<span class="lineNum">    5869 </span><span class="lineCov">          1 :  yconnectorvertex[1] = fgkEndCapCardCableConnectorWidth[0];</span>
<span class="lineNum">    5870 </span><span class="lineCov">          1 :  yconnectorvertex[2] = yconnectorvertex[1];</span>
<span class="lineNum">    5871 </span><span class="lineCov">          1 :  yconnectorvertex[3] = fgkEndCapCardCableConnectorWidth[1];</span>
<span class="lineNum">    5872 </span><span class="lineCov">          1 :  yconnectorvertex[4] = yconnectorvertex[3];</span>
<span class="lineNum">    5873 </span><span class="lineCov">          1 :  yconnectorvertex[5] = yconnectorvertex[1];</span>
<span class="lineNum">    5874 </span><span class="lineCov">          1 :  yconnectorvertex[6] = yconnectorvertex[5];</span>
<span class="lineNum">    5875 </span><span class="lineCov">          1 :  yconnectorvertex[7] = yconnectorvertex[0];</span>
<span class="lineNum">    5876 </span><span class="lineCov">          1 :  TGeoXtru* cableconnectorshape = new TGeoXtru(2);</span>
<span class="lineNum">    5877 </span><span class="lineCov">          2 :  cableconnectorshape-&gt;DefinePolygon(kcableconnectorvertexnumber,xconnectorvertex,</span>
<span class="lineNum">    5878 </span><span class="lineCov">          1 :                                                                     yconnectorvertex); </span>
<span class="lineNum">    5879 </span><span class="lineCov">          1 :  cableconnectorshape-&gt;DefineSection(0,0.0);</span>
<span class="lineNum">    5880 </span><span class="lineCov">          1 :  cableconnectorshape-&gt;DefineSection(1,fgkEndCapCardCableConnectorThickness);</span>
<span class="lineNum">    5881 </span><span class="lineCov">          2 :  TGeoVolume* cableconnector = new TGeoVolume(&quot;EndCapCardTopCableConnector&quot;,</span>
<span class="lineNum">    5882 </span><span class="lineCov">          1 :                                                                                    cableconnectorshape,fSSDMountingBlockMedium);</span>
<span class="lineNum">    5883 </span><span class="lineCov">          1 :  cableconnector-&gt;SetLineColor(fColorG10);</span>
<span class="lineNum">    5884 </span>            :  // Strip Connection
<span class="lineNum">    5885 </span>            :  TGeoBBox* endcapstripconnectionshape = 
<span class="lineNum">    5886 </span><span class="lineCov">          2 :                                                                 new TGeoBBox(0.5*fgkEndCapStripConnectionLength,</span>
<span class="lineNum">    5887 </span><span class="lineCov">          1 :                                                                                          0.5*fgkEndCapStripConnectionThickness,</span>
<span class="lineNum">    5888 </span><span class="lineCov">          1 :                                                                                          0.5*fgkEndCapStripConnectionWidth);</span>
<span class="lineNum">    5889 </span><span class="lineCov">          2 :  TGeoVolume* endcapstripconnection = new TGeoVolume(&quot;EndCapStripConnection&quot;,</span>
<span class="lineNum">    5890 </span><span class="lineCov">          1 :                                                                                                         endcapstripconnectionshape,</span>
<span class="lineNum">    5891 </span><span class="lineCov">          1 :                                                                                                         fSSDSupportRingAl);</span>
<span class="lineNum">    5892 </span><span class="lineCov">          1 :  endcapstripconnection-&gt;SetLineColor(fColorAl);</span>
<span class="lineNum">    5893 </span>            :  // Interface Card B
<span class="lineNum">    5894 </span>            :  const Int_t kcardBvertexnumber = 12; 
<span class="lineNum">    5895 </span><span class="lineCov">          1 :  Double_t xcardBvertexnumber[kcardBvertexnumber];</span>
<span class="lineNum">    5896 </span><span class="lineCov">          1 :  Double_t ycardBvertexnumber[kcardBvertexnumber];</span>
<span class="lineNum">    5897 </span>            : 
<span class="lineNum">    5898 </span><span class="lineCov">          1 :  xcardBvertexnumber[0]  = 0.0;</span>
<span class="lineNum">    5899 </span><span class="lineCov">          1 :  xcardBvertexnumber[1]  = xcardBvertexnumber[0];</span>
<span class="lineNum">    5900 </span><span class="lineCov">          1 :  xcardBvertexnumber[2]  = xcardBvertexnumber[1]+fgkEndCapInterfaceCardBLength[0];</span>
<span class="lineNum">    5901 </span><span class="lineCov">          1 :  xcardBvertexnumber[3]  = xcardBvertexnumber[2];</span>
<span class="lineNum">    5902 </span><span class="lineCov">          1 :  xcardBvertexnumber[4]  = xcardBvertexnumber[1];</span>
<span class="lineNum">    5903 </span><span class="lineCov">          1 :  xcardBvertexnumber[5]  = xcardBvertexnumber[4];</span>
<span class="lineNum">    5904 </span><span class="lineCov">          1 :  xcardBvertexnumber[6]  = xcardBvertexnumber[5]+fgkEndCapInterfaceCardBLength[1];</span>
<span class="lineNum">    5905 </span><span class="lineCov">          1 :  xcardBvertexnumber[7]  = xcardBvertexnumber[6];</span>
<span class="lineNum">    5906 </span><span class="lineCov">          1 :  xcardBvertexnumber[8]  = xcardBvertexnumber[7]-fgkEndCapInterfaceCardBLength[0];</span>
<span class="lineNum">    5907 </span><span class="lineCov">          1 :  xcardBvertexnumber[9]  = xcardBvertexnumber[8];</span>
<span class="lineNum">    5908 </span><span class="lineCov">          1 :  xcardBvertexnumber[10] = xcardBvertexnumber[7];</span>
<span class="lineNum">    5909 </span><span class="lineCov">          1 :  xcardBvertexnumber[11] = xcardBvertexnumber[10];</span>
<span class="lineNum">    5910 </span>            :  
<span class="lineNum">    5911 </span><span class="lineCov">          1 :  ycardBvertexnumber[0]  = 0.0;</span>
<span class="lineNum">    5912 </span><span class="lineCov">          1 :  ycardBvertexnumber[1]  = fgkEndCapInterfaceCardBWidth[0];</span>
<span class="lineNum">    5913 </span><span class="lineCov">          1 :  ycardBvertexnumber[2]  = ycardBvertexnumber[1];</span>
<span class="lineNum">    5914 </span><span class="lineCov">          1 :  ycardBvertexnumber[3]  = ycardBvertexnumber[2]+fgkEndCapInterfaceCardBWidth[1];</span>
<span class="lineNum">    5915 </span><span class="lineCov">          1 :  ycardBvertexnumber[4]  = ycardBvertexnumber[3];</span>
<span class="lineNum">    5916 </span><span class="lineCov">          1 :  ycardBvertexnumber[5]  = ycardBvertexnumber[4]+fgkEndCapInterfaceCardBWidth[2];</span>
<span class="lineNum">    5917 </span><span class="lineCov">          1 :  ycardBvertexnumber[6]  = ycardBvertexnumber[5];</span>
<span class="lineNum">    5918 </span><span class="lineCov">          1 :  ycardBvertexnumber[7]  = ycardBvertexnumber[4];</span>
<span class="lineNum">    5919 </span><span class="lineCov">          1 :  ycardBvertexnumber[8]  = ycardBvertexnumber[7];</span>
<span class="lineNum">    5920 </span><span class="lineCov">          1 :  ycardBvertexnumber[9]  = ycardBvertexnumber[1];</span>
<span class="lineNum">    5921 </span><span class="lineCov">          1 :  ycardBvertexnumber[10] = ycardBvertexnumber[9];</span>
<span class="lineNum">    5922 </span><span class="lineCov">          1 :  ycardBvertexnumber[11] = ycardBvertexnumber[0];</span>
<span class="lineNum">    5923 </span>            : 
<span class="lineNum">    5924 </span><span class="lineCov">          1 :  TGeoXtru* interfacecardBshape = new TGeoXtru(2);</span>
<span class="lineNum">    5925 </span><span class="lineCov">          1 :  interfacecardBshape-&gt;DefinePolygon(kcardBvertexnumber,xcardBvertexnumber,ycardBvertexnumber);</span>
<span class="lineNum">    5926 </span><span class="lineCov">          1 :  interfacecardBshape-&gt;DefineSection(0,0.);</span>
<span class="lineNum">    5927 </span><span class="lineCov">          1 :  interfacecardBshape-&gt;DefineSection(1,fgkEndCapInterfaceCardBThickness);</span>
<span class="lineNum">    5928 </span><span class="lineCov">          2 :  TGeoVolume* interfacecardB = new TGeoVolume(&quot;EndCapInterfaceCardB&quot;,interfacecardBshape,</span>
<span class="lineNum">    5929 </span><span class="lineCov">          1 :                                                                                          fSSDMountingBlockMedium);</span>
<span class="lineNum">    5930 </span><span class="lineCov">          1 :  interfacecardB-&gt;SetLineColor(46);</span>
<span class="lineNum">    5931 </span>            :  // Interface Card B Electronic Board
<span class="lineNum">    5932 </span>            :  const Int_t kelectboardcardBvertexnumber = 14; 
<span class="lineNum">    5933 </span><span class="lineCov">          1 :  Double_t xelectboardcardBvertex[kelectboardcardBvertexnumber];</span>
<span class="lineNum">    5934 </span><span class="lineCov">          1 :  Double_t yelectboardcardBvertex[kelectboardcardBvertexnumber];</span>
<span class="lineNum">    5935 </span>            : 
<span class="lineNum">    5936 </span><span class="lineCov">          1 :  xelectboardcardBvertex[0]  = xcardBvertexnumber[0]+fgkEndCapInterfaceCardBLength[2];</span>
<span class="lineNum">    5937 </span><span class="lineCov">          1 :  xelectboardcardBvertex[1]  = xelectboardcardBvertex[0]; </span>
<span class="lineNum">    5938 </span><span class="lineCov">          1 :  xelectboardcardBvertex[2]  = xelectboardcardBvertex[1]+fgkEndCapInterfaceCardBLength[3];</span>
<span class="lineNum">    5939 </span><span class="lineCov">          1 :  xelectboardcardBvertex[3]  = xelectboardcardBvertex[2]; </span>
<span class="lineNum">    5940 </span><span class="lineCov">          1 :  xelectboardcardBvertex[4]  = xelectboardcardBvertex[3]+fgkEndCapInterfaceCardBLength[4];</span>
<span class="lineNum">    5941 </span><span class="lineCov">          1 :  xelectboardcardBvertex[5]  = xelectboardcardBvertex[4];</span>
<span class="lineNum">    5942 </span><span class="lineCov">          1 :  xelectboardcardBvertex[6]  = xelectboardcardBvertex[5]+fgkEndCapInterfaceCardBLength[5];</span>
<span class="lineNum">    5943 </span><span class="lineCov">          1 :  xelectboardcardBvertex[7]  = xelectboardcardBvertex[6];</span>
<span class="lineNum">    5944 </span><span class="lineCov">          1 :  xelectboardcardBvertex[8]  = xelectboardcardBvertex[7]+8.0*fgkEndCapInterfaceCardBLength[4];</span>
<span class="lineNum">    5945 </span><span class="lineCov">          1 :  xelectboardcardBvertex[9]  = xelectboardcardBvertex[8];</span>
<span class="lineNum">    5946 </span><span class="lineCov">          1 :  xelectboardcardBvertex[10] = xelectboardcardBvertex[9]+fgkEndCapInterfaceCardBLength[6];</span>
<span class="lineNum">    5947 </span><span class="lineCov">          1 :  xelectboardcardBvertex[11] = xelectboardcardBvertex[10];</span>
<span class="lineNum">    5948 </span><span class="lineCov">          1 :  xelectboardcardBvertex[12] = xelectboardcardBvertex[11]-9.0*fgkEndCapInterfaceCardBLength[4];</span>
<span class="lineNum">    5949 </span><span class="lineCov">          1 :  xelectboardcardBvertex[13] = xelectboardcardBvertex[12];</span>
<span class="lineNum">    5950 </span>            : 
<span class="lineNum">    5951 </span><span class="lineCov">          1 :  yelectboardcardBvertex[0]  = ycardBvertexnumber[0]+fgkEndCapInterfaceCardBWidth[1];</span>
<span class="lineNum">    5952 </span><span class="lineCov">          1 :  yelectboardcardBvertex[1]  = yelectboardcardBvertex[0]+fgkEndCapInterfaceCardBWidth[3];</span>
<span class="lineNum">    5953 </span><span class="lineCov">          1 :  yelectboardcardBvertex[2]  = yelectboardcardBvertex[1];</span>
<span class="lineNum">    5954 </span><span class="lineCov">          1 :  yelectboardcardBvertex[3]  = yelectboardcardBvertex[2]+fgkEndCapInterfaceCardBWidth[3];</span>
<span class="lineNum">    5955 </span><span class="lineCov">          1 :  yelectboardcardBvertex[4]  = yelectboardcardBvertex[3];</span>
<span class="lineNum">    5956 </span><span class="lineCov">          1 :  yelectboardcardBvertex[5]  = yelectboardcardBvertex[2];</span>
<span class="lineNum">    5957 </span><span class="lineCov">          1 :  yelectboardcardBvertex[6]  = yelectboardcardBvertex[5];</span>
<span class="lineNum">    5958 </span><span class="lineCov">          1 :  yelectboardcardBvertex[7]  = yelectboardcardBvertex[6]+fgkEndCapInterfaceCardBWidth[4];</span>
<span class="lineNum">    5959 </span><span class="lineCov">          1 :  yelectboardcardBvertex[8]  = yelectboardcardBvertex[7];</span>
<span class="lineNum">    5960 </span><span class="lineCov">          1 :  yelectboardcardBvertex[9]  = yelectboardcardBvertex[8]-fgkEndCapInterfaceCardBWidth[3];</span>
<span class="lineNum">    5961 </span><span class="lineCov">          1 :  yelectboardcardBvertex[10] = yelectboardcardBvertex[9];</span>
<span class="lineNum">    5962 </span><span class="lineCov">          1 :  yelectboardcardBvertex[11] = yelectboardcardBvertex[10]-fgkEndCapInterfaceCardBWidth[3];</span>
<span class="lineNum">    5963 </span><span class="lineCov">          1 :  yelectboardcardBvertex[12] = yelectboardcardBvertex[11];</span>
<span class="lineNum">    5964 </span><span class="lineCov">          1 :  yelectboardcardBvertex[13] = yelectboardcardBvertex[0];</span>
<span class="lineNum">    5965 </span>            : 
<span class="lineNum">    5966 </span><span class="lineCov">          1 :  TGeoXtru* electboardcardBshape = new TGeoXtru(2);</span>
<span class="lineNum">    5967 </span><span class="lineCov">          1 :  electboardcardBshape-&gt;DefinePolygon(kelectboardcardBvertexnumber,</span>
<span class="lineNum">    5968 </span><span class="lineCov">          1 :                                                                          xelectboardcardBvertex,yelectboardcardBvertex);</span>
<span class="lineNum">    5969 </span><span class="lineCov">          1 :  electboardcardBshape-&gt;DefineSection(0,fgkEndCapInterfaceCardBThickness);</span>
<span class="lineNum">    5970 </span><span class="lineCov">          2 :  electboardcardBshape-&gt;DefineSection(1,fgkEndCapInterfaceCardBThickness</span>
<span class="lineNum">    5971 </span><span class="lineCov">          1 :                                                                          + fgkEndCapInterfaceElectBoardCardBThickness);</span>
<span class="lineNum">    5972 </span><span class="lineCov">          2 :  TGeoVolume* electboardcardB = new TGeoVolume(&quot;EndCapInterfaceElectBoardCardB&quot;,electboardcardBshape,</span>
<span class="lineNum">    5973 </span><span class="lineCov">          1 :                                                                                           fSSDSupportRingAl);</span>
<span class="lineNum">    5974 </span><span class="lineCov">          1 :  electboardcardB-&gt;SetLineColor(fColorAl);</span>
<span class="lineNum">    5975 </span>            :  // Generating Stiffener 2
<span class="lineNum">    5976 </span><span class="lineCov">          2 :  TGeoBBox* endcapstiffenershape = new TGeoBBox(0.5*fgkEndCapStiffenerWidth,</span>
<span class="lineNum">    5977 </span><span class="lineCov">          1 :                                                                                            0.5*fgkEndCapStiffenerThickness,</span>
<span class="lineNum">    5978 </span><span class="lineCov">          1 :                                                                                            0.5*fgkEndCapStiffenerLength);</span>
<span class="lineNum">    5979 </span><span class="lineCov">          1 :  TGeoVolume* endcapstiffener = new TGeoVolume(&quot;EndCapStiffener&quot;,endcapstiffenershape,fSSDSupportRingAl);</span>
<span class="lineNum">    5980 </span><span class="lineCov">          1 :  endcapstiffener-&gt;SetLineColor(fColorAl);   </span>
<span class="lineNum">    5981 </span>            :  // Generating Mother Interface Card B Container
<span class="lineNum">    5982 </span>            :  const Int_t kinterfacecardBmothervertexnumber = 10;
<span class="lineNum">    5983 </span><span class="lineCov">          1 :  Double_t xinterfacecardBmothervertex[kinterfacecardBmothervertexnumber];</span>
<span class="lineNum">    5984 </span><span class="lineCov">          1 :  Double_t yinterfacecardBmothervertex[kinterfacecardBmothervertexnumber];</span>
<span class="lineNum">    5985 </span>            : 
<span class="lineNum">    5986 </span><span class="lineCov">          1 :  xinterfacecardBmothervertex[0] = 0.0;</span>
<span class="lineNum">    5987 </span><span class="lineCov">          1 :  xinterfacecardBmothervertex[1] = xinterfacecardBmothervertex[0];</span>
<span class="lineNum">    5988 </span><span class="lineCov">          1 :  xinterfacecardBmothervertex[2] = xinterfacecardBmothervertex[1]</span>
<span class="lineNum">    5989 </span><span class="lineCov">          1 :                                                                 + fgkEndCapInterfaceCardBThickness;</span>
<span class="lineNum">    5990 </span><span class="lineCov">          1 :  xinterfacecardBmothervertex[3] = xinterfacecardBmothervertex[2];</span>
<span class="lineNum">    5991 </span><span class="lineCov">          1 :  xinterfacecardBmothervertex[4] = xinterfacecardBmothervertex[3]</span>
<span class="lineNum">    5992 </span><span class="lineCov">          1 :                                                                 + fgkEndCapInterfaceElectBoardCardBThickness;</span>
<span class="lineNum">    5993 </span><span class="lineCov">          1 :  xinterfacecardBmothervertex[5] = xinterfacecardBmothervertex[4];</span>
<span class="lineNum">    5994 </span><span class="lineCov">          1 :  xinterfacecardBmothervertex[6] = xinterfacecardBmothervertex[3];</span>
<span class="lineNum">    5995 </span><span class="lineCov">          1 :  xinterfacecardBmothervertex[7] = xinterfacecardBmothervertex[6];</span>
<span class="lineNum">    5996 </span><span class="lineCov">          1 :  xinterfacecardBmothervertex[8] = xinterfacecardBmothervertex[7]</span>
<span class="lineNum">    5997 </span><span class="lineCov">          1 :                                                                 + fgkEndCapCardJMDConnectorLength[0];</span>
<span class="lineNum">    5998 </span><span class="lineCov">          1 :  xinterfacecardBmothervertex[9] = xinterfacecardBmothervertex[8];</span>
<span class="lineNum">    5999 </span>            : 
<span class="lineNum">    6000 </span><span class="lineCov">          1 :  yinterfacecardBmothervertex[0] = 0.0;</span>
<span class="lineNum">    6001 </span><span class="lineCov">          2 :  yinterfacecardBmothervertex[1] = fgkEndCapInterfaceCardBWidth[0]</span>
<span class="lineNum">    6002 </span><span class="lineCov">          1 :                                                                 + fgkEndCapInterfaceCardBWidth[1]</span>
<span class="lineNum">    6003 </span><span class="lineCov">          1 :                                                                 + fgkEndCapInterfaceCardBWidth[2];</span>
<span class="lineNum">    6004 </span><span class="lineCov">          1 :  yinterfacecardBmothervertex[2] = yinterfacecardBmothervertex[1];</span>
<span class="lineNum">    6005 </span><span class="lineCov">          1 :  yinterfacecardBmothervertex[3] = yelectboardcardBvertex[3];</span>
<span class="lineNum">    6006 </span><span class="lineCov">          1 :  yinterfacecardBmothervertex[4] = yinterfacecardBmothervertex[3];</span>
<span class="lineNum">    6007 </span><span class="lineCov">          1 :  yinterfacecardBmothervertex[5] = yelectboardcardBvertex[11];</span>
<span class="lineNum">    6008 </span><span class="lineCov">          1 :  yinterfacecardBmothervertex[6] = yinterfacecardBmothervertex[5];</span>
<span class="lineNum">    6009 </span><span class="lineCov">          2 :  yinterfacecardBmothervertex[7] = fgkEndCapCardElectBoardLayerWidth[1]</span>
<span class="lineNum">    6010 </span><span class="lineCov">          1 :                                                                 + fgkEndCapCardJMDConnectorWidth[0]</span>
<span class="lineNum">    6011 </span><span class="lineCov">          1 :                                                                 + fgkEndCapCardJMDConnectorWidth[1];</span>
<span class="lineNum">    6012 </span><span class="lineCov">          1 :  yinterfacecardBmothervertex[8] = yinterfacecardBmothervertex[7];</span>
<span class="lineNum">    6013 </span><span class="lineCov">          1 :  yinterfacecardBmothervertex[9] = yinterfacecardBmothervertex[0];</span>
<span class="lineNum">    6014 </span><span class="lineCov">          1 :  TGeoXtru* interfacecardBmothershape = new TGeoXtru(2);</span>
<span class="lineNum">    6015 </span><span class="lineCov">          1 :  interfacecardBmothershape-&gt;DefinePolygon(kinterfacecardBmothervertexnumber,</span>
<span class="lineNum">    6016 </span><span class="lineCov">          1 :                                                                                   xinterfacecardBmothervertex,</span>
<span class="lineNum">    6017 </span><span class="lineCov">          1 :                                                                                   yinterfacecardBmothervertex);</span>
<span class="lineNum">    6018 </span><span class="lineCov">          1 :  interfacecardBmothershape-&gt;DefineSection(0,-1.e-15);</span>
<span class="lineNum">    6019 </span><span class="lineCov">          1 :  interfacecardBmothershape-&gt;DefineSection(1,fgkEndCapInterfaceCardBLength[1]);</span>
<span class="lineNum">    6020 </span><span class="lineCov">          2 :  TGeoVolume* interfacecardBmother = new TGeoVolume(&quot;EndCapInterfaceCardBMother&quot;,</span>
<span class="lineNum">    6021 </span><span class="lineCov">          1 :                                                                                                    interfacecardBmothershape,fSSDAir);</span>
<span class="lineNum">    6022 </span><span class="lineCov">          1 :  electboardcardB-&gt;SetLineColor(fColorAl);</span>
<span class="lineNum">    6023 </span>            :  // Positioning Volumes Mother Interface Card B Container 
<span class="lineNum">    6024 </span><span class="lineCov">          1 :  TGeoRotation* interfacecardBrot = new TGeoRotation();</span>
<span class="lineNum">    6025 </span><span class="lineCov">          1 :  TGeoTranslation* interfacecardBtrans = new TGeoTranslation(); </span>
<span class="lineNum">    6026 </span><span class="lineCov">          1 :  interfacecardBrot-&gt;SetAngles(90.,-90.,-90.);</span>
<span class="lineNum">    6027 </span><span class="lineCov">          1 :  interfacecardBtrans-&gt;SetTranslation(fgkEndCapInterfaceCardBThickness,0.,0.);</span>
<span class="lineNum">    6028 </span><span class="lineCov">          1 :  TGeoCombiTrans* interfacecardBcombitrans = new TGeoCombiTrans(*interfacecardBtrans,*interfacecardBrot);</span>
<span class="lineNum">    6029 </span><span class="lineCov">          1 :  TGeoRotation* electboardcardBrot = new TGeoRotation();</span>
<span class="lineNum">    6030 </span><span class="lineCov">          1 :  TGeoTranslation* electboardcardBtrans = new TGeoTranslation(); </span>
<span class="lineNum">    6031 </span><span class="lineCov">          1 :  electboardcardBrot-&gt;SetAngles(90.,90.,-90.);</span>
<span class="lineNum">    6032 </span><span class="lineCov">          1 :  electboardcardBtrans-&gt;SetTranslation(0.,0.,fgkEndCapInterfaceCardBLength[1]);</span>
<span class="lineNum">    6033 </span>            :  TGeoCombiTrans* electboardcardBcombitrans = 
<span class="lineNum">    6034 </span><span class="lineCov">          1 :                                   new TGeoCombiTrans(*electboardcardBtrans,*electboardcardBrot);</span>
<span class="lineNum">    6035 </span><span class="lineCov">          1 :  interfacecardBmother-&gt;AddNode(interfacecardB,1,interfacecardBcombitrans);</span>
<span class="lineNum">    6036 </span><span class="lineCov">          1 :  interfacecardBmother-&gt;AddNode(electboardcardB,1,electboardcardBcombitrans);</span>
<span class="lineNum">    6037 </span><span class="lineCov">          1 :  TGeoRotation* jmdconnectorcardBrot = new TGeoRotation();</span>
<span class="lineNum">    6038 </span><span class="lineCov">          1 :  jmdconnectorcardBrot-&gt;SetAngles(90.,180.,-90.);</span>
<span class="lineNum">    6039 </span><span class="lineCov">          1 :  TGeoTranslation* jmdconnectorcardBtrans[3];</span>
<span class="lineNum">    6040 </span><span class="lineCov">          1 :  TGeoCombiTrans* jmdconnectorcardBcombitrans[3];</span>
<span class="lineNum">    6041 </span><span class="lineCov">          8 :  for(Int_t i=0; i&lt;3; i++){</span>
<span class="lineNum">    6042 </span><span class="lineCov">          9 :    jmdconnectorcardBtrans[i] = new TGeoTranslation(fgkEndCapInterfaceCardBThickness</span>
<span class="lineNum">    6043 </span><span class="lineCov">          3 :                                                          + fgkEndCapCardJMDConnectorLength[0], </span>
<span class="lineNum">    6044 </span><span class="lineCov">          3 :                                                            fgkEndCapCardElectBoardLayerWidth[1],</span>
<span class="lineNum">    6045 </span><span class="lineCov">          3 :                                                            0.5*fgkEndCapCardJMDConnectorThickness</span>
<span class="lineNum">    6046 </span><span class="lineCov">          6 :                                                          + 0.5*(fgkEndCapInterfaceCardBLength[1]</span>
<span class="lineNum">    6047 </span><span class="lineCov">          3 :                                                          - 2.*fgkEndCapInterfaceCardBJMDConnectorSeparation)</span>
<span class="lineNum">    6048 </span><span class="lineCov">          3 :                                                          + i *fgkEndCapInterfaceCardBJMDConnectorSeparation);    </span>
<span class="lineNum">    6049 </span><span class="lineCov">          6 :    jmdconnectorcardBcombitrans[i] = new TGeoCombiTrans(*jmdconnectorcardBtrans[i],</span>
<span class="lineNum">    6050 </span>            :                                                                                                            *jmdconnectorcardBrot);
<span class="lineNum">    6051 </span><span class="lineCov">          3 :    interfacecardBmother-&gt;AddNode(jmdconnector,i+1,jmdconnectorcardBcombitrans[i]);</span>
<span class="lineNum">    6052 </span>            :  }
<span class="lineNum">    6053 </span>            :  // Mother Supply Card Container 
<span class="lineNum">    6054 </span><span class="lineCov">          1 :  TGeoVolumeAssembly* mothersupplycard = new TGeoVolumeAssembly(&quot;EndCapCardMotherSupply&quot;);</span>
<span class="lineNum">    6055 </span>            :  // Interface Card Container
<span class="lineNum">    6056 </span><span class="lineCov">          1 :  TGeoVolumeAssembly* motherinterfacecardcontainer = new TGeoVolumeAssembly(&quot;EndCapMotherInterfaceCardA&quot;);</span>
<span class="lineNum">    6057 </span>            :  // Placing Volumes in Mother Supply Card Container
<span class="lineNum">    6058 </span>            :  // JMD Connector Positioning
<span class="lineNum">    6059 </span><span class="lineCov">          1 :  TGeoTranslation* jmdconnectortrans[2];</span>
<span class="lineNum">    6060 </span><span class="lineCov">          8 :  for(Int_t i=0; i&lt;2; i++) jmdconnectortrans[i] = new TGeoTranslation();</span>
<span class="lineNum">    6061 </span><span class="lineCov">          2 :  jmdconnectortrans[0]-&gt;SetTranslation(0.,fgkEndCapCardElectBoardLayerWidth[1],</span>
<span class="lineNum">    6062 </span><span class="lineCov">          1 :                                                                                         fgkEndCapCardElectBoardBackLength[0]</span>
<span class="lineNum">    6063 </span><span class="lineCov">          1 :                                           -                                             fgkEndCapCardJMDConnectorThickness</span>
<span class="lineNum">    6064 </span><span class="lineCov">          1 :                                           -                                             fgkEndCapCardJMDConnectorToLayer);</span>
<span class="lineNum">    6065 </span><span class="lineCov">          1 :  TGeoRotation* jmdconnectorot = new TGeoRotation();</span>
<span class="lineNum">    6066 </span><span class="lineCov">          2 :  jmdconnectortrans[1]-&gt;SetTranslation(fgkEndCapCardElectBoardBackThickness</span>
<span class="lineNum">    6067 </span><span class="lineCov">          1 :                                                                  + 2.*fgkEndCapCardJMDConnectorLength[0]</span>
<span class="lineNum">    6068 </span><span class="lineCov">          1 :                                                                  + 2.*fgkEndCapCardElectBoardLayerThickness,</span>
<span class="lineNum">    6069 </span><span class="lineCov">          1 :                                                                           fgkEndCapCardElectBoardLayerWidth[1],</span>
<span class="lineNum">    6070 </span><span class="lineCov">          1 :                                                                       fgkEndCapCardJMDConnectorThickness</span>
<span class="lineNum">    6071 </span><span class="lineCov">          1 :                                                                  +    fgkEndCapCardJMDConnectorToLayer);</span>
<span class="lineNum">    6072 </span><span class="lineCov">          1 :  jmdconnectorot-&gt;SetAngles(90.,180.,-90);</span>
<span class="lineNum">    6073 </span><span class="lineCov">          1 :  TGeoCombiTrans* jmdconnectorcombitrans = new TGeoCombiTrans(*jmdconnectortrans[1],</span>
<span class="lineNum">    6074 </span>            :                                                                                 * jmdconnectorot);
<span class="lineNum">    6075 </span><span class="lineCov">          1 :  mothersupplycard-&gt;AddNode(jmdconnector,1,jmdconnectortrans[0]);</span>
<span class="lineNum">    6076 </span><span class="lineCov">          1 :  mothersupplycard-&gt;AddNode(jmdconnector,2,jmdconnectorcombitrans);</span>
<span class="lineNum">    6077 </span>            :  // Top Cable Connector Placing
<span class="lineNum">    6078 </span><span class="lineCov">          1 :  TGeoRotation* cableconnectorot[2];</span>
<span class="lineNum">    6079 </span><span class="lineCov">          8 :  for(Int_t i=0; i&lt;2; i++) cableconnectorot[i] = new TGeoRotation();</span>
<span class="lineNum">    6080 </span><span class="lineCov">          1 :  TGeoTranslation* cableconnectortrans[3];</span>
<span class="lineNum">    6081 </span><span class="lineCov">         11 :  for(Int_t i=0; i&lt;3; i++) cableconnectortrans[i] = new TGeoTranslation();</span>
<span class="lineNum">    6082 </span><span class="lineCov">          1 :  cableconnectorot[0]-&gt;SetAngles(90.,0.,0.); </span>
<span class="lineNum">    6083 </span><span class="lineCov">          1 :  cableconnectorot[1]-&gt;SetAngles(0.,-90.,0.); </span>
<span class="lineNum">    6084 </span><span class="lineCov">          1 :  cableconnectortrans[0]-&gt;SetTranslation(fgkEndCapCardJMDConnectorLength[0],0.,0.);</span>
<span class="lineNum">    6085 </span><span class="lineCov">          2 :  TGeoCombiTrans* cableconnectorcombitrans = new TGeoCombiTrans(*cableconnectortrans[0],</span>
<span class="lineNum">    6086 </span><span class="lineCov">          1 :                                                                                                                            *cableconnectorot[0]);</span>
<span class="lineNum">    6087 </span><span class="lineCov">          1 :  TGeoHMatrix* cableconnectormatrix[2];</span>
<span class="lineNum">    6088 </span><span class="lineCov">          6 :  for(Int_t i=0; i&lt;2; i++) cableconnectormatrix[i] =</span>
<span class="lineNum">    6089 </span><span class="lineCov">          4 :                                                         new TGeoHMatrix((*cableconnectorot[1])</span>
<span class="lineNum">    6090 </span><span class="lineCov">          2 :                                                                                    *(*cableconnectorcombitrans));</span>
<span class="lineNum">    6091 </span><span class="lineCov">          2 :  cableconnectortrans[1]-&gt;SetTranslation(0.,fgkEndCapCardElectBoardLayerWidth[0]</span>
<span class="lineNum">    6092 </span><span class="lineCov">          1 :                                            -                               fgkEndCapCardCableConnectorThickness,</span>
<span class="lineNum">    6093 </span><span class="lineCov">          1 :                                                                                 fgkEndCapCardCableConnectorLength[0]</span>
<span class="lineNum">    6094 </span><span class="lineCov">          1 :                                            +                            fgkEndCapCardCableConnectorToLayer);</span>
<span class="lineNum">    6095 </span><span class="lineCov">          2 :  cableconnectortrans[2]-&gt;SetTranslation(0.,fgkEndCapCardElectBoardLayerWidth[0]</span>
<span class="lineNum">    6096 </span><span class="lineCov">          1 :                                            -                2.*fgkEndCapCardCableConnectorThickness</span>
<span class="lineNum">    6097 </span><span class="lineCov">          1 :                                            -                            fgkEndCapCardCableConnectorDistance,</span>
<span class="lineNum">    6098 </span><span class="lineCov">          1 :                                                                                 fgkEndCapCardCableConnectorLength[0]</span>
<span class="lineNum">    6099 </span><span class="lineCov">          1 :                                            +                            fgkEndCapCardCableConnectorToLayer);</span>
<span class="lineNum">    6100 </span><span class="lineCov">          6 :  for(Int_t i=0; i&lt;2; i++){</span>
<span class="lineNum">    6101 </span><span class="lineCov">          2 :         cableconnectormatrix[i]-&gt;MultiplyLeft(cableconnectortrans[i+1]);</span>
<span class="lineNum">    6102 </span><span class="lineCov">          2 :     mothersupplycard-&gt;AddNode(cableconnector,i+1,cableconnectormatrix[i]);</span>
<span class="lineNum">    6103 </span>            :  }
<span class="lineNum">    6104 </span><span class="lineCov">          1 :  TGeoRotation* electboardbackrot = new TGeoRotation(); </span>
<span class="lineNum">    6105 </span><span class="lineCov">          1 :  TGeoTranslation* electboardbacktrans = new TGeoTranslation();</span>
<span class="lineNum">    6106 </span><span class="lineCov">          1 :  electboardbackrot-&gt;SetAngles(90.,-90.,-90.);</span>
<span class="lineNum">    6107 </span><span class="lineCov">          2 :  electboardbacktrans-&gt;SetTranslation(fgkEndCapCardElectBoardBackThickness</span>
<span class="lineNum">    6108 </span><span class="lineCov">          1 :                                                         +                fgkEndCapCardJMDConnectorLength[0]</span>
<span class="lineNum">    6109 </span><span class="lineCov">          1 :                                                         +                fgkEndCapCardElectBoardLayerThickness,0.,0.);</span>
<span class="lineNum">    6110 </span><span class="lineCov">          1 :  TGeoCombiTrans* electboardbackcombitrans = new TGeoCombiTrans(*electboardbacktrans,</span>
<span class="lineNum">    6111 </span>            :                                                                                                                            *electboardbackrot);
<span class="lineNum">    6112 </span><span class="lineCov">          1 :  mothersupplycard-&gt;AddNode(electboardback,1,electboardbackcombitrans);</span>
<span class="lineNum">    6113 </span>            :  // Electronic Board Kapton Layer Positioning
<span class="lineNum">    6114 </span><span class="lineCov">          1 :  TGeoRotation* electlayerrot = new TGeoRotation();</span>
<span class="lineNum">    6115 </span><span class="lineCov">          1 :  TGeoTranslation* electlayertrans[2];</span>
<span class="lineNum">    6116 </span><span class="lineCov">          1 :  TGeoCombiTrans* electlayercombitrans[2];</span>
<span class="lineNum">    6117 </span><span class="lineCov">          8 :  for(Int_t i=0; i&lt;2; i++) electlayertrans[i] = new TGeoTranslation();</span>
<span class="lineNum">    6118 </span><span class="lineCov">          1 :  electlayerrot-&gt;SetAngles(90.,-90.,-90.);</span>
<span class="lineNum">    6119 </span><span class="lineCov">          2 :  electlayertrans[0]-&gt;SetTranslation(fgkEndCapCardJMDConnectorLength[0]</span>
<span class="lineNum">    6120 </span><span class="lineCov">          1 :                                                                  + fgkEndCapCardElectBoardLayerThickness,0.,0.);</span>
<span class="lineNum">    6121 </span><span class="lineCov">          2 :  electlayertrans[1]-&gt;SetTranslation(fgkEndCapCardJMDConnectorLength[0]</span>
<span class="lineNum">    6122 </span><span class="lineCov">          1 :                                                                  + 2.*fgkEndCapCardElectBoardLayerThickness</span>
<span class="lineNum">    6123 </span><span class="lineCov">          1 :                                                                  + fgkEndCapCardElectBoardBackThickness,0.,0.);</span>
<span class="lineNum">    6124 </span><span class="lineCov">          6 :  for(Int_t i=0; i&lt;2; i++){</span>
<span class="lineNum">    6125 </span><span class="lineCov">          4 :         electlayercombitrans[i] = new TGeoCombiTrans(*electlayertrans[i],*electlayerrot);</span>
<span class="lineNum">    6126 </span><span class="lineCov">          2 :         mothersupplycard-&gt;AddNode(electlayer,i+1,electlayercombitrans[i]);</span>
<span class="lineNum">    6127 </span>            :  }
<span class="lineNum">    6128 </span>            :  // Placing Volumes in Mother Interface Card Container
<span class="lineNum">    6129 </span><span class="lineCov">          1 :  motherinterfacecardcontainer-&gt;AddNode(jmdconnector,1,jmdconnectorcombitrans);</span>
<span class="lineNum">    6130 </span><span class="lineCov">          1 :  motherinterfacecardcontainer-&gt;AddNode(electboardback,1,electboardbackcombitrans);</span>
<span class="lineNum">    6131 </span><span class="lineCov">          6 :  for(Int_t i=0; i&lt;2; i++){</span>
<span class="lineNum">    6132 </span><span class="lineCov">          2 :         motherinterfacecardcontainer-&gt;AddNode(electlayer,i+1,electlayercombitrans[i]);</span>
<span class="lineNum">    6133 </span>            :  }
<span class="lineNum">    6134 </span>            :  /////////////////////////////////////////////////////////////
<span class="lineNum">    6135 </span>            :  // Generation of Card Interface Container
<span class="lineNum">    6136 </span>            :  /////////////////////////////////////////////////////////////
<span class="lineNum">    6137 </span><span class="lineCov">          1 :  Double_t stiffenertransx = fgkEndCapKaptonFoilWidth-fgkEndCapStiffenerWidth</span>
<span class="lineNum">    6138 </span><span class="lineCov">          1 :                                                   - fgkEndCapCardJMDConnectorLength[0]</span>
<span class="lineNum">    6139 </span><span class="lineCov">          1 :                                                   - fgkEndCapInterfaceCardBThickness</span>
<span class="lineNum">    6140 </span><span class="lineCov">          1 :                                                   - 9.*fgkEndCapStripConnectionThickness</span>
<span class="lineNum">    6141 </span><span class="lineCov">          1 :                                                   - 8.*fgkEndCapCardElectBoardBackThickness;</span>
<span class="lineNum">    6142 </span>            :  const Int_t kcardinterfacecontainervertexnumber = 14;
<span class="lineNum">    6143 </span><span class="lineCov">          1 :  Double_t xcardinterfacecontainervertex[kcardinterfacecontainervertexnumber];</span>
<span class="lineNum">    6144 </span><span class="lineCov">          1 :  Double_t ycardinterfacecontainervertex[kcardinterfacecontainervertexnumber];</span>
<span class="lineNum">    6145 </span><span class="lineCov">          2 :  xcardinterfacecontainervertex[0]  =-6.5*fgkEndCapCardElectBoardBackThickness</span>
<span class="lineNum">    6146 </span><span class="lineCov">          1 :                                                                    - 7.0*fgkEndCapStripConnectionThickness;</span>
<span class="lineNum">    6147 </span><span class="lineCov">          1 :  xcardinterfacecontainervertex[1]  = xcardinterfacecontainervertex[0];</span>
<span class="lineNum">    6148 </span><span class="lineCov">          1 :  xcardinterfacecontainervertex[2]  = xcardinterfacecontainervertex[1]</span>
<span class="lineNum">    6149 </span><span class="lineCov">          1 :                                                                    + fgkEndCapStripConnectionThickness</span>
<span class="lineNum">    6150 </span><span class="lineCov">          1 :                                                                    - fgkEndCapCardElectBoardLayerThickness</span>
<span class="lineNum">    6151 </span><span class="lineCov">          1 :                                                                    - fgkEndCapCardCableConnectorWidth[0];</span>
<span class="lineNum">    6152 </span><span class="lineCov">          1 :  xcardinterfacecontainervertex[3]  = xcardinterfacecontainervertex[2];</span>
<span class="lineNum">    6153 </span><span class="lineCov">          1 :  xcardinterfacecontainervertex[4]  = xcardinterfacecontainervertex[1];</span>
<span class="lineNum">    6154 </span><span class="lineCov">          1 :  xcardinterfacecontainervertex[5]  = xcardinterfacecontainervertex[4];</span>
<span class="lineNum">    6155 </span><span class="lineCov">          2 :  xcardinterfacecontainervertex[6]  = 1.5*fgkEndCapCardElectBoardBackThickness</span>
<span class="lineNum">    6156 </span><span class="lineCov">          1 :                                                                    + 2.0*fgkEndCapStripConnectionThickness;</span>
<span class="lineNum">    6157 </span><span class="lineCov">          1 :  xcardinterfacecontainervertex[7]  = xcardinterfacecontainervertex[6];</span>
<span class="lineNum">    6158 </span><span class="lineCov">          1 :  xcardinterfacecontainervertex[8]  = xcardinterfacecontainervertex[7]</span>
<span class="lineNum">    6159 </span><span class="lineCov">          1 :                                                                    + fgkEndCapInterfaceCardBThickness;</span>
<span class="lineNum">    6160 </span><span class="lineCov">          1 :  xcardinterfacecontainervertex[9]  = xcardinterfacecontainervertex[8];</span>
<span class="lineNum">    6161 </span><span class="lineCov">          1 :  xcardinterfacecontainervertex[10] = xcardinterfacecontainervertex[9]</span>
<span class="lineNum">    6162 </span><span class="lineCov">          1 :                                                                    + fgkEndCapInterfaceElectBoardCardBThickness;</span>
<span class="lineNum">    6163 </span><span class="lineCov">          1 :  xcardinterfacecontainervertex[11] = xcardinterfacecontainervertex[10];</span>
<span class="lineNum">    6164 </span><span class="lineCov">          1 :  xcardinterfacecontainervertex[12] = xcardinterfacecontainervertex[11]</span>
<span class="lineNum">    6165 </span><span class="lineCov">          1 :                                    - fgkEndCapInterfaceElectBoardCardBThickness</span>
<span class="lineNum">    6166 </span><span class="lineCov">          1 :                                                                    + fgkEndCapCardJMDConnectorLength[0]</span>
<span class="lineNum">    6167 </span><span class="lineCov">          1 :                                                                    + stiffenertransx+fgkEndCapStiffenerWidth;</span>
<span class="lineNum">    6168 </span><span class="lineCov">          1 :  xcardinterfacecontainervertex[13] = xcardinterfacecontainervertex[12];                                                            </span>
<span class="lineNum">    6169 </span>            : 
<span class="lineNum">    6170 </span><span class="lineCov">          1 :  ycardinterfacecontainervertex[0]  = 0.;</span>
<span class="lineNum">    6171 </span><span class="lineCov">          2 :  ycardinterfacecontainervertex[1]  = fgkEndCapCardElectBoardLayerWidth[1]</span>
<span class="lineNum">    6172 </span><span class="lineCov">          1 :                                                                    + fgkEndCapCardJMDConnectorWidth[0]</span>
<span class="lineNum">    6173 </span><span class="lineCov">          1 :                                                                    + fgkEndCapCardJMDConnectorWidth[1];</span>
<span class="lineNum">    6174 </span><span class="lineCov">          1 :  ycardinterfacecontainervertex[2]  = ycardinterfacecontainervertex[1];</span>
<span class="lineNum">    6175 </span><span class="lineCov">          2 :  ycardinterfacecontainervertex[3]  = fgkEndCapCardElectBoardBackWidth[0]</span>
<span class="lineNum">    6176 </span><span class="lineCov">          1 :                                                                    - fgkEndCapStripConnectionWidth;</span>
<span class="lineNum">    6177 </span><span class="lineCov">          1 :  ycardinterfacecontainervertex[4]  = ycardinterfacecontainervertex[3];</span>
<span class="lineNum">    6178 </span><span class="lineCov">          1 :  ycardinterfacecontainervertex[5]  = fgkEndCapCardElectBoardBackWidth[0];</span>
<span class="lineNum">    6179 </span><span class="lineCov">          1 :  ycardinterfacecontainervertex[6]  = ycardinterfacecontainervertex[5];</span>
<span class="lineNum">    6180 </span><span class="lineCov">          2 :  ycardinterfacecontainervertex[7]  = fgkEndCapInterfaceCardBWidth[0]</span>
<span class="lineNum">    6181 </span><span class="lineCov">          1 :                                                                    + fgkEndCapInterfaceCardBWidth[1]</span>
<span class="lineNum">    6182 </span><span class="lineCov">          1 :                                                                    + fgkEndCapInterfaceCardBWidth[2];</span>
<span class="lineNum">    6183 </span><span class="lineCov">          1 :  ycardinterfacecontainervertex[8]  = ycardinterfacecontainervertex[7];</span>
<span class="lineNum">    6184 </span><span class="lineCov">          1 :  ycardinterfacecontainervertex[9]  = yelectboardcardBvertex[3];</span>
<span class="lineNum">    6185 </span><span class="lineCov">          1 :  ycardinterfacecontainervertex[10] = ycardinterfacecontainervertex[9];</span>
<span class="lineNum">    6186 </span><span class="lineCov">          1 :  ycardinterfacecontainervertex[11] = ycardinterfacecontainervertex[1];</span>
<span class="lineNum">    6187 </span><span class="lineCov">          1 :  ycardinterfacecontainervertex[12] = ycardinterfacecontainervertex[11];</span>
<span class="lineNum">    6188 </span><span class="lineCov">          1 :  ycardinterfacecontainervertex[13] = ycardinterfacecontainervertex[0];</span>
<span class="lineNum">    6189 </span>            :  
<span class="lineNum">    6190 </span><span class="lineCov">          1 :  TGeoXtru* interfacecardmothershape = new TGeoXtru(2);</span>
<span class="lineNum">    6191 </span><span class="lineCov">          1 :  interfacecardmothershape-&gt;DefinePolygon(kcardinterfacecontainervertexnumber,</span>
<span class="lineNum">    6192 </span><span class="lineCov">          1 :                                                                                   xcardinterfacecontainervertex,</span>
<span class="lineNum">    6193 </span><span class="lineCov">          1 :                                                                                   ycardinterfacecontainervertex);</span>
<span class="lineNum">    6194 </span><span class="lineCov">          2 :  interfacecardmothershape-&gt;DefineSection(0,-1.e-15-0.5*(fgkEndCapStiffenerLength</span>
<span class="lineNum">    6195 </span><span class="lineCov">          1 :                                                                            -    fgkEndCapCardElectBoardBackLength[0]));</span>
<span class="lineNum">    6196 </span><span class="lineCov">          2 :  interfacecardmothershape-&gt;DefineSection(1,0.5*(fgkEndCapStiffenerLength</span>
<span class="lineNum">    6197 </span><span class="lineCov">          1 :                                                                            +    fgkEndCapCardElectBoardBackLength[0]));</span>
<span class="lineNum">    6198 </span>            :  TGeoVolume** cardinterfacecontainer;
<span class="lineNum">    6199 </span><span class="lineCov">          1 :  cardinterfacecontainer = new TGeoVolume*[4];</span>
<span class="lineNum">    6200 </span><span class="lineCov">          3 :  cardinterfacecontainer[0] = new TGeoVolume(&quot;EndCapCardsContainerLayer5Sx&quot;,</span>
<span class="lineNum">    6201 </span><span class="lineCov">          1 :                                                                                         interfacecardmothershape,fSSDAir); </span>
<span class="lineNum">    6202 </span><span class="lineCov">          3 :  cardinterfacecontainer[1] = new TGeoVolume(&quot;EndCapCardsContainerLayer5Dx&quot;,</span>
<span class="lineNum">    6203 </span><span class="lineCov">          1 :                                                                                         interfacecardmothershape,fSSDAir); </span>
<span class="lineNum">    6204 </span><span class="lineCov">          3 :  cardinterfacecontainer[2] = new TGeoVolume(&quot;EndCapCardsContainerLayer6Sx&quot;,</span>
<span class="lineNum">    6205 </span><span class="lineCov">          1 :                                                                                         interfacecardmothershape,fSSDAir); </span>
<span class="lineNum">    6206 </span><span class="lineCov">          3 :  cardinterfacecontainer[3] = new TGeoVolume(&quot;EndCapCardsContainerLayer6Dx&quot;,</span>
<span class="lineNum">    6207 </span><span class="lineCov">          1 :                                                                                         interfacecardmothershape,fSSDAir); </span>
<span class="lineNum">    6208 </span>            :  /////////////////////////////////
<span class="lineNum">    6209 </span>            :  // cardinterfacecontainer[0]: Card Container End Cap Layer 5 Bellegarde Side
<span class="lineNum">    6210 </span>            :  // cardinterfacecontainer[1]: Card Container End Cap Layer 5 Gex Side
<span class="lineNum">    6211 </span>            :  // cardinterfacecontainer[2]: Card Container End Cap Layer 6 Bellegarde Side
<span class="lineNum">    6212 </span>            :  // cardinterfacecontainer[3]: Card Container End Cap Layer 6 Gex Side
<span class="lineNum">    6213 </span>            :  /////////////////////////////////
<span class="lineNum">    6214 </span><span class="lineCov">          1 :  TGeoRotation* endcapstripconnectionrot[2];</span>
<span class="lineNum">    6215 </span><span class="lineCov">          8 :  for(Int_t i=0; i&lt;2; i++) endcapstripconnectionrot[i] = new TGeoRotation();</span>
<span class="lineNum">    6216 </span><span class="lineCov">          1 :  endcapstripconnectionrot[0]-&gt;SetAngles(0.,90.,0.);</span>
<span class="lineNum">    6217 </span><span class="lineCov">          1 :  endcapstripconnectionrot[1]-&gt;SetAngles(90.,90.,-90.);</span>
<span class="lineNum">    6218 </span><span class="lineCov">          2 :  TGeoHMatrix* endcapstripconnectionmatrix = new TGeoHMatrix((*endcapstripconnectionrot[1])</span>
<span class="lineNum">    6219 </span><span class="lineCov">          1 :                                                                         *                                 (*endcapstripconnectionrot[0]));</span>
<span class="lineNum">    6220 </span><span class="lineCov">          1 :  TGeoTranslation* endcapstripconnectiontrans = new TGeoTranslation();</span>
<span class="lineNum">    6221 </span><span class="lineCov">          2 :  endcapstripconnectiontrans-&gt;SetTranslation(-endcapstripconnectionshape-&gt;GetDY()</span>
<span class="lineNum">    6222 </span><span class="lineCov">          1 :                                                                                         -0.5*fgkEndCapCardElectBoardBackThickness,</span>
<span class="lineNum">    6223 </span><span class="lineCov">          1 :                                                                                          fgkEndCapCardElectBoardBackWidth[0]</span>
<span class="lineNum">    6224 </span><span class="lineCov">          1 :                                                                                         -endcapstripconnectionshape-&gt;GetDZ(),</span>
<span class="lineNum">    6225 </span><span class="lineCov">          1 :                                                                                          0.5*fgkEndCapCardElectBoardBackLength[0]);</span>
<span class="lineNum">    6226 </span><span class="lineCov">          1 :  endcapstripconnectionmatrix-&gt;MultiplyLeft(endcapstripconnectiontrans);</span>
<span class="lineNum">    6227 </span><span class="lineCov">          1 :  TGeoTranslation* cardinterfacetrans[9];</span>
<span class="lineNum">    6228 </span><span class="lineCov">          1 :  TGeoHMatrix* cardinterfacematrix[9]; </span>
<span class="lineNum">    6229 </span><span class="lineCov">         16 :  for(Int_t i=0; i&lt;7; i++){ </span>
<span class="lineNum">    6230 </span><span class="lineCov">         21 :         cardinterfacetrans[i] = new TGeoTranslation(-i*(fgkEndCapStripConnectionThickness</span>
<span class="lineNum">    6231 </span><span class="lineCov">          7 :                                                   +                                                     fgkEndCapCardElectBoardBackThickness),</span>
<span class="lineNum">    6232 </span>            :                                                                                                 0.0,0.0);  
<span class="lineNum">    6233 </span><span class="lineCov">         21 :         cardinterfacematrix[i] = new TGeoHMatrix((*cardinterfacetrans[i])</span>
<span class="lineNum">    6234 </span><span class="lineCov">          7 :                                                    *                             (*endcapstripconnectionmatrix));</span>
<span class="lineNum">    6235 </span>            :  }
<span class="lineNum">    6236 </span><span class="lineCov">          3 :  cardinterfacetrans[7] = new TGeoTranslation((fgkEndCapStripConnectionThickness</span>
<span class="lineNum">    6237 </span><span class="lineCov">          1 :                                                   +                                             fgkEndCapCardElectBoardBackThickness),</span>
<span class="lineNum">    6238 </span>            :                                                                                                 0.0,0.0);  
<span class="lineNum">    6239 </span><span class="lineCov">          3 :  cardinterfacematrix[7] = new TGeoHMatrix((*cardinterfacetrans[7])</span>
<span class="lineNum">    6240 </span><span class="lineCov">          1 :                                                 *                                 (*endcapstripconnectionmatrix));</span>
<span class="lineNum">    6241 </span><span class="lineCov">          3 :  cardinterfacetrans[8] = new TGeoTranslation(2.*(fgkEndCapStripConnectionThickness</span>
<span class="lineNum">    6242 </span><span class="lineCov">          1 :                                                   +                                             fgkEndCapCardElectBoardBackThickness),</span>
<span class="lineNum">    6243 </span>            :                                                                                                 0.0,0.0);  
<span class="lineNum">    6244 </span><span class="lineCov">          3 :  cardinterfacematrix[8] = new TGeoHMatrix((*cardinterfacetrans[8])</span>
<span class="lineNum">    6245 </span><span class="lineCov">          1 :                                                 *                                 (*endcapstripconnectionmatrix));</span>
<span class="lineNum">    6246 </span>            : 
<span class="lineNum">    6247 </span><span class="lineCov">         10 :  for(Int_t i=0; i&lt;4; i++){</span>
<span class="lineNum">    6248 </span><span class="lineCov">          8 :         cardinterfacecontainer[i]-&gt;AddNode(endcapstripconnection,1,</span>
<span class="lineNum">    6249 </span><span class="lineCov">          4 :                                                                            cardinterfacematrix[7]);                             </span>
<span class="lineNum">    6250 </span><span class="lineCov">          8 :         cardinterfacecontainer[i]-&gt;AddNode(endcapstripconnection,2,</span>
<span class="lineNum">    6251 </span><span class="lineCov">          4 :                                                                            cardinterfacematrix[8]);                             </span>
<span class="lineNum">    6252 </span>            :  }
<span class="lineNum">    6253 </span>            :  TGeoTranslation* mothersupplycardtrans = 
<span class="lineNum">    6254 </span><span class="lineCov">          2 :                                         new TGeoTranslation(-0.5*(fgkEndCapCardElectBoardBackThickness</span>
<span class="lineNum">    6255 </span><span class="lineCov">          1 :                                                                                 + 2.*fgkEndCapCardJMDConnectorLength[0]</span>
<span class="lineNum">    6256 </span><span class="lineCov">          1 :                                                                                 + 2.*fgkEndCapCardElectBoardLayerThickness),0.0,0.0);</span>
<span class="lineNum">    6257 </span><span class="lineCov">          1 :  TGeoHMatrix* mothersupplycardmatrix[7];</span>
<span class="lineNum">    6258 </span><span class="lineCov">          1 :  Int_t index[4] = {1,1,1,1};</span>
<span class="lineNum">    6259 </span><span class="lineCov">         16 :  for(Int_t i=0; i&lt;7; i++){</span>
<span class="lineNum">    6260 </span><span class="lineCov">         21 :         mothersupplycardmatrix[i] = new TGeoHMatrix((*cardinterfacetrans[i])</span>
<span class="lineNum">    6261 </span><span class="lineCov">          7 :                                                         *                                 (*mothersupplycardtrans));</span>
<span class="lineNum">    6262 </span><span class="lineCov">         70 :         for(Int_t j=0; j&lt;4; j++){</span>
<span class="lineNum">    6263 </span><span class="lineCov">         56 :                 switch(j){</span>
<span class="lineNum">    6264 </span>            :                         case 0: //Layer5 EndCap Left Side  
<span class="lineNum">    6265 </span><span class="lineCov">         14 :                                 cardinterfacecontainer[j]-&gt;AddNode(endcapstripconnection,i+3,</span>
<span class="lineNum">    6266 </span><span class="lineCov">          7 :                                                                                                    cardinterfacematrix[i]);                             </span>
<span class="lineNum">    6267 </span><span class="lineCov">          7 :                                 if(i!=0){</span>
<span class="lineNum">    6268 </span><span class="lineCov">         12 :                                         cardinterfacecontainer[j]-&gt;AddNode(mothersupplycard,index[j],</span>
<span class="lineNum">    6269 </span><span class="lineCov">          6 :                                                                                                            mothersupplycardmatrix[i]);                  </span>
<span class="lineNum">    6270 </span><span class="lineCov">          6 :                                         index[j]++;</span>
<span class="lineNum">    6271 </span>            : 
<span class="lineNum">    6272 </span><span class="lineCov">          6 :                                 }</span>
<span class="lineNum">    6273 </span>            :                         break;
<span class="lineNum">    6274 </span>            :                         case 1: //Layer5 EndCap Rigth Side  
<span class="lineNum">    6275 </span><span class="lineCov">         14 :                                 cardinterfacecontainer[j]-&gt;AddNode(endcapstripconnection,i+3,</span>
<span class="lineNum">    6276 </span><span class="lineCov">          7 :                                                                                                    cardinterfacematrix[i]);                     </span>
<span class="lineNum">    6277 </span><span class="lineCov">          7 :                                 if(i&gt;0&amp;&amp;i&lt;6){</span>
<span class="lineNum">    6278 </span><span class="lineCov">         10 :                                         cardinterfacecontainer[j]-&gt;AddNode(mothersupplycard,index[j],</span>
<span class="lineNum">    6279 </span><span class="lineCov">          5 :                                                                                                            mothersupplycardmatrix[i]);                  </span>
<span class="lineNum">    6280 </span><span class="lineCov">          5 :                                         index[j]++;</span>
<span class="lineNum">    6281 </span><span class="lineCov">          5 :                                 }</span>
<span class="lineNum">    6282 </span>            :                         break;
<span class="lineNum">    6283 </span>            :                         case 2: //Layer6 EndCap Left Side  
<span class="lineNum">    6284 </span><span class="lineCov">         14 :                                 cardinterfacecontainer[j]-&gt;AddNode(endcapstripconnection,i+3,</span>
<span class="lineNum">    6285 </span><span class="lineCov">          7 :                                                                                                    cardinterfacematrix[i]);                             </span>
<span class="lineNum">    6286 </span><span class="lineCov">          7 :                                 if(i!=6){</span>
<span class="lineNum">    6287 </span><span class="lineCov">         12 :                                         cardinterfacecontainer[j]-&gt;AddNode(mothersupplycard,index[j],</span>
<span class="lineNum">    6288 </span><span class="lineCov">          6 :                                                                                                            mothersupplycardmatrix[i]);                  </span>
<span class="lineNum">    6289 </span><span class="lineCov">          6 :                                         index[j]++;</span>
<span class="lineNum">    6290 </span><span class="lineCov">          6 :                                 }</span>
<span class="lineNum">    6291 </span>            :                         break;
<span class="lineNum">    6292 </span>            :                         case 3: //Layer6 EndCap Right Side  
<span class="lineNum">    6293 </span><span class="lineCov">         14 :                                 cardinterfacecontainer[j]-&gt;AddNode(endcapstripconnection,i+3,</span>
<span class="lineNum">    6294 </span><span class="lineCov">          7 :                                                                                                    cardinterfacematrix[i]);                             </span>
<span class="lineNum">    6295 </span><span class="lineCov">         14 :                                 cardinterfacecontainer[j]-&gt;AddNode(mothersupplycard,index[j],</span>
<span class="lineNum">    6296 </span><span class="lineCov">          7 :                                                                                                    mothersupplycardmatrix[i]);                  </span>
<span class="lineNum">    6297 </span><span class="lineCov">          7 :                                 index[j]++;</span>
<span class="lineNum">    6298 </span><span class="lineCov">          7 :                         break;</span>
<span class="lineNum">    6299 </span>            :                 }
<span class="lineNum">    6300 </span>            :         }
<span class="lineNum">    6301 </span>            :  }
<span class="lineNum">    6302 </span>            :  // Positioning Interface 
<span class="lineNum">    6303 </span>            :  TGeoTranslation* motherinterfacecardtrans = 
<span class="lineNum">    6304 </span><span class="lineCov">          2 :                 new TGeoTranslation( -fgkEndCapCardJMDConnectorLength[0]</span>
<span class="lineNum">    6305 </span><span class="lineCov">          1 :                                                          +0.5*fgkEndCapCardElectBoardBackThickness</span>
<span class="lineNum">    6306 </span><span class="lineCov">          1 :                                                          -fgkEndCapCardElectBoardLayerThickness</span>
<span class="lineNum">    6307 </span><span class="lineCov">          1 :                                                          +fgkEndCapStripConnectionThickness,0.,0.);</span>
<span class="lineNum">    6308 </span><span class="lineCov">         14 :  for(Int_t i=0; i&lt;4; i++) cardinterfacecontainer[i]-&gt;AddNode(</span>
<span class="lineNum">    6309 </span><span class="lineCov">          4 :                                         motherinterfacecardcontainer,i+1,motherinterfacecardtrans);</span>
<span class="lineNum">    6310 </span>            :  // Positioning Interface Card B 
<span class="lineNum">    6311 </span>            :  TGeoTranslation* interfacecardBmothertrans = 
<span class="lineNum">    6312 </span><span class="lineCov">          2 :                                         new TGeoTranslation(0.5 * fgkEndCapCardElectBoardBackThickness</span>
<span class="lineNum">    6313 </span><span class="lineCov">          1 :                                                                                 + 2.*fgkEndCapStripConnectionThickness</span>
<span class="lineNum">    6314 </span><span class="lineCov">          1 :                                                                                         + fgkEndCapCardElectBoardBackThickness,0.,</span>
<span class="lineNum">    6315 </span><span class="lineCov">          2 :                                                                            -0.5 * (fgkEndCapInterfaceCardBLength[1]</span>
<span class="lineNum">    6316 </span><span class="lineCov">          1 :                                                                                         -  fgkEndCapCardElectBoardBackLength[0]));                              </span>
<span class="lineNum">    6317 </span><span class="lineCov">         14 :  for(Int_t i=0; i&lt;4; i++) cardinterfacecontainer[i]-&gt;AddNode(interfacecardBmother,1,</span>
<span class="lineNum">    6318 </span><span class="lineCov">          4 :                                                                                                                          interfacecardBmothertrans);</span>
<span class="lineNum">    6319 </span>            :  // Positioning Stiffener 
<span class="lineNum">    6320 </span>            :  TGeoTranslation* endcapstiffenertrans = 
<span class="lineNum">    6321 </span><span class="lineCov">          2 :                                                 new TGeoTranslation(1.5*fgkEndCapCardElectBoardBackThickness</span>
<span class="lineNum">    6322 </span><span class="lineCov">          1 :                                                                            +    2.0*fgkEndCapStripConnectionThickness</span>
<span class="lineNum">    6323 </span><span class="lineCov">          1 :                                                                            +    fgkEndCapInterfaceCardBThickness</span>
<span class="lineNum">    6324 </span><span class="lineCov">          1 :                                                                            +    fgkEndCapCardJMDConnectorLength[0]</span>
<span class="lineNum">    6325 </span><span class="lineCov">          1 :                                                                            +    stiffenertransx</span>
<span class="lineNum">    6326 </span><span class="lineCov">          2 :                                                                            +    endcapstiffenershape-&gt;GetDX(),endcapstiffenershape-&gt;GetDY(),</span>
<span class="lineNum">    6327 </span><span class="lineCov">          1 :                                                                                         endcapstiffenershape-&gt;GetDZ()</span>
<span class="lineNum">    6328 </span><span class="lineCov">          2 :                                                                            -    0.5*(fgkEndCapStiffenerLength</span>
<span class="lineNum">    6329 </span><span class="lineCov">          1 :                                                                            -    fgkEndCapCardElectBoardBackLength[0]));</span>
<span class="lineNum">    6330 </span><span class="lineCov">         10 :  for(Int_t i=0; i&lt;4; i++) cardinterfacecontainer[i]-&gt;AddNode(endcapstiffener,1,endcapstiffenertrans);  </span>
<span class="lineNum">    6331 </span>            :  /////////////////////////////////////////////////////////////
<span class="lineNum">    6332 </span>            :  // Deallocating memory
<span class="lineNum">    6333 </span>            :  /////////////////////////////////////////////////////////////
<span class="lineNum">    6334 </span><span class="lineCov">          2 :  delete interfacecardBrot;</span>
<span class="lineNum">    6335 </span><span class="lineCov">          2 :  delete interfacecardBtrans;</span>
<span class="lineNum">    6336 </span><span class="lineCov">          2 :  delete electboardcardBtrans;</span>
<span class="lineNum">    6337 </span><span class="lineCov">          2 :  delete electboardcardBrot; </span>
<span class="lineNum">    6338 </span><span class="lineCov">          2 :  delete jmdconnectorcardBrot;</span>
<span class="lineNum">    6339 </span><span class="lineCov">         14 :  for(Int_t i=0; i&lt;3; i++) delete jmdconnectorcardBtrans[i];</span>
<span class="lineNum">    6340 </span><span class="lineCov">          2 :  delete jmdconnectorot;</span>
<span class="lineNum">    6341 </span><span class="lineCov">          2 :  delete jmdconnectortrans[1];</span>
<span class="lineNum">    6342 </span><span class="lineCov">         10 :  for(Int_t i=0; i&lt;2; i++) delete cableconnectorot[i];</span>
<span class="lineNum">    6343 </span><span class="lineCov">          2 :  delete cableconnectorcombitrans;</span>
<span class="lineNum">    6344 </span><span class="lineCov">          2 :  delete electboardbacktrans;</span>
<span class="lineNum">    6345 </span><span class="lineCov">          2 :  delete electboardbackrot;</span>
<span class="lineNum">    6346 </span><span class="lineCov">          2 :  delete electlayerrot;</span>
<span class="lineNum">    6347 </span><span class="lineCov">         10 :  for(Int_t i=0; i&lt;2; i++) delete electlayertrans[i];</span>
<span class="lineNum">    6348 </span><span class="lineCov">         10 :  for(Int_t i=0; i&lt;2; i++) delete endcapstripconnectionrot[i];</span>
<span class="lineNum">    6349 </span><span class="lineCov">          2 :  delete mothersupplycardtrans;</span>
<span class="lineNum">    6350 </span><span class="lineCov">         30 :  for(Int_t i=0; i&lt;7; i++) delete cardinterfacetrans[i];</span>
<span class="lineNum">    6351 </span>            :  /////////////////////////////////////////////////////////////
<span class="lineNum">    6352 </span>            : 
<span class="lineNum">    6353 </span><span class="lineCov">          1 :  mothersupplycard-&gt;GetShape()-&gt;ComputeBBox(); //RS: enforce recompting of BBox</span>
<span class="lineNum">    6354 </span><span class="lineCov">          1 :  motherinterfacecardcontainer-&gt;GetShape()-&gt;ComputeBBox();</span>
<span class="lineNum">    6355 </span>            : 
<span class="lineNum">    6356 </span><span class="lineCov">          1 :  return cardinterfacecontainer;</span>
<a name="6357"><span class="lineNum">    6357 </span><span class="lineCov">          1 :  }</span></a>
<span class="lineNum">    6358 </span>            :  ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    6359 </span>            :  TGeoVolume** AliITSv11GeometrySSD::GetEndCapAssembly(){ 
<span class="lineNum">    6360 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    6361 </span>            :   // Method returning EndCap Mother Volume
<span class="lineNum">    6362 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    6363 </span>            :   const Int_t kendcapcoverplatesmallholenumber = 9;
<span class="lineNum">    6364 </span><span class="lineCov">          2 :   Double_t endcapmotherorigin[3];</span>
<span class="lineNum">    6365 </span><span class="lineCov">          2 :   endcapmotherorigin[0] = -fgkEndCapCoverPlateLength[0]</span>
<span class="lineNum">    6366 </span><span class="lineCov">          2 :                                                 +  0.5 *(fgkEndCapCoverPlateLength[3]</span>
<span class="lineNum">    6367 </span><span class="lineCov">          1 :                                             +  2.0 * fgkEndCapCoverPlateLength[2]);</span>
<span class="lineNum">    6368 </span><span class="lineCov">          3 :   endcapmotherorigin[1] = - 0.5 * (fgkEndCapCoverPlateWidth[0]</span>
<span class="lineNum">    6369 </span><span class="lineCov">          1 :                                           -                      fgkEndCapCoverPlateWidth[2]</span>
<span class="lineNum">    6370 </span><span class="lineCov">          1 :                                           -       (kendcapcoverplatesmallholenumber-1)</span>
<span class="lineNum">    6371 </span><span class="lineCov">          1 :                                           *        fgkEndCapCoverPlateSmallHoleSeparation[2])</span>
<span class="lineNum">    6372 </span><span class="lineCov">          2 :                                           +  0.5*(fgkEndCapSideCoverLength[2]</span>
<span class="lineNum">    6373 </span><span class="lineCov">          1 :                                           +               fgkEndCapCoverPlateWidth[1]</span>
<span class="lineNum">    6374 </span><span class="lineCov">          1 :                                           -       fgkEndCapCoverPlateWidth[0])</span>
<span class="lineNum">    6375 </span><span class="lineCov">          1 :                                           -      (fgkEndCapCoverPlateWidth[1]</span>
<span class="lineNum">    6376 </span><span class="lineCov">          1 :                                           -       fgkEndCapCoverPlateWidth[0]);</span>
<span class="lineNum">    6377 </span><span class="lineCov">          2 :   endcapmotherorigin[2] = 0.5*fgkEndCapCoverPlateThickness</span>
<span class="lineNum">    6378 </span><span class="lineCov">          1 :                                                 + 2.*fgkEndCapCoolingTubeRadiusMax</span>
<span class="lineNum">    6379 </span><span class="lineCov">          1 :                                                 - 0.5*(2.*fgkEndCapCoolingTubeRadiusMax</span>
<span class="lineNum">    6380 </span><span class="lineCov">          1 :                                                 +      fgkEndCapSideCoverWidth[1]</span>
<span class="lineNum">    6381 </span><span class="lineCov">          1 :                                                 +      fgkEndCapSideCoverThickness</span>
<span class="lineNum">    6382 </span><span class="lineCov">          1 :                                                 +      fgkEndCapKaptonFoilThickness);</span>
<span class="lineNum">    6383 </span><span class="lineCov">          3 :   TGeoBBox* endcapmothershape = new TGeoBBox(0.5*(fgkEndCapCoverPlateLength[3]</span>
<span class="lineNum">    6384 </span><span class="lineCov">          1 :                                                           +                              2.0* fgkEndCapCoverPlateLength[2]</span>
<span class="lineNum">    6385 </span><span class="lineCov">          1 :                                                           +              2.0* fgkEndCapSideCoverThickness),</span>
<span class="lineNum">    6386 </span><span class="lineCov">          2 :                                                                          0.5* (fgkEndCapSideCoverLength[2]</span>
<span class="lineNum">    6387 </span><span class="lineCov">          1 :                                                           +                    fgkEndCapCoverPlateWidth[1]</span>
<span class="lineNum">    6388 </span><span class="lineCov">          1 :                                                           -                                        fgkEndCapCoverPlateWidth[0]),</span>
<span class="lineNum">    6389 </span><span class="lineCov">          2 :                                                                                          0.5* (2.*fgkEndCapCoolingTubeRadiusMax</span>
<span class="lineNum">    6390 </span><span class="lineCov">          1 :                                                       +                                    fgkEndCapSideCoverWidth[1]</span>
<span class="lineNum">    6391 </span><span class="lineCov">          1 :                                                           +                                       fgkEndCapSideCoverThickness</span>
<span class="lineNum">    6392 </span><span class="lineCov">          1 :                                                       +                                   fgkEndCapKaptonFoilThickness),</span>
<span class="lineNum">    6393 </span><span class="lineCov">          1 :                                                                                          endcapmotherorigin);</span>
<span class="lineNum">    6394 </span>            :   TGeoVolume** endcapassembly;  
<span class="lineNum">    6395 </span><span class="lineCov">          1 :   endcapassembly = new TGeoVolume*[4];</span>
<span class="lineNum">    6396 </span><span class="lineCov">          3 :   endcapassembly[0] = new TGeoVolume(&quot;EndCapContainerLayer5Sx&quot;,</span>
<span class="lineNum">    6397 </span><span class="lineCov">          1 :                                                                                         endcapmothershape,fSSDAir); </span>
<span class="lineNum">    6398 </span><span class="lineCov">          3 :   endcapassembly[1] = new TGeoVolume(&quot;EndCapContainerLayer5Dx&quot;,</span>
<span class="lineNum">    6399 </span><span class="lineCov">          1 :                                                                                         endcapmothershape,fSSDAir); </span>
<span class="lineNum">    6400 </span><span class="lineCov">          3 :   endcapassembly[2] = new TGeoVolume(&quot;EndCapContainerLayer6Sx&quot;,</span>
<span class="lineNum">    6401 </span><span class="lineCov">          1 :                                                                                         endcapmothershape,fSSDAir); </span>
<span class="lineNum">    6402 </span><span class="lineCov">          3 :   endcapassembly[3] = new TGeoVolume(&quot;EndCapContainerLayer6Dx&quot;,</span>
<span class="lineNum">    6403 </span><span class="lineCov">          1 :                                                                                         endcapmothershape,fSSDAir); </span>
<span class="lineNum">    6404 </span>            :  /////////////////////////////////
<span class="lineNum">    6405 </span>            :  // endcapassembly[0]:  Container End Cap Layer 5 Bellegarde Side
<span class="lineNum">    6406 </span>            :  // endcapassembly[1]:  Container End Cap Layer 5 Gex Side
<span class="lineNum">    6407 </span>            :  // endcapassembly[2]:  Container End Cap Layer 6 Bellegarde Side
<span class="lineNum">    6408 </span>            :  // endcapassembly[3]:  Container End Cap Layer 6 Gex Side
<span class="lineNum">    6409 </span>            :  /////////////////////////////////
<span class="lineNum">    6410 </span>            :   /////////////////////////////////////////////////////
<span class="lineNum">    6411 </span>            :   // Placing Endcap Cover Plate
<span class="lineNum">    6412 </span>            :   /////////////////////////////////////////////////////
<span class="lineNum">    6413 </span><span class="lineCov">          1 :   TGeoVolume* endcapcoverplate = GetEndCapCoverPlate();</span>
<span class="lineNum">    6414 </span><span class="lineCov">          1 :   TGeoRotation* endcapcoverplaterot = new TGeoRotation();</span>
<span class="lineNum">    6415 </span><span class="lineCov">          1 :   endcapcoverplaterot-&gt;SetAngles(90.0,180.0,-90.0);</span>
<span class="lineNum">    6416 </span>            :   TGeoCombiTrans* endcapcoverplatecombitrans = 
<span class="lineNum">    6417 </span><span class="lineCov">          1 :                                                   new TGeoCombiTrans(-0.5*fgkEndCapCoverPlateLength[1],0.,0.,</span>
<span class="lineNum">    6418 </span>            :                                                                                          endcapcoverplaterot);
<span class="lineNum">    6419 </span>            :   TGeoTranslation* endcapcoverplatetrans = 
<span class="lineNum">    6420 </span><span class="lineCov">          1 :                                                   new TGeoTranslation(1.5*fgkEndCapCoverPlateLength[1],0.,0.);</span>
<span class="lineNum">    6421 </span>            :   TGeoHMatrix* endcapcoverplatematrix = 
<span class="lineNum">    6422 </span><span class="lineCov">          2 :                                                   new TGeoHMatrix((*endcapcoverplatetrans)</span>
<span class="lineNum">    6423 </span><span class="lineCov">          1 :                                                                           *       (*endcapcoverplatecombitrans));</span>
<span class="lineNum">    6424 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;4; i++) endcapassembly[i]-&gt;AddNode(endcapcoverplate,1,endcapcoverplatematrix);</span>
<span class="lineNum">    6425 </span>            :   /////////////////////////////////////////////////////
<span class="lineNum">    6426 </span>            :   // Placing Endcap Side Cover
<span class="lineNum">    6427 </span>            :   /////////////////////////////////////////////////////
<span class="lineNum">    6428 </span><span class="lineCov">          1 :   TGeoVolume* endcapsidecover = GetEndCapSideCover();</span>
<span class="lineNum">    6429 </span><span class="lineCov">          1 :   TGeoRotation* endcapsidecoverot[2];</span>
<span class="lineNum">    6430 </span><span class="lineCov">          1 :   TGeoCombiTrans* endcapsidecovercombitrans[3];</span>
<span class="lineNum">    6431 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;2; i++) endcapsidecoverot[i] = new TGeoRotation();</span>
<span class="lineNum">    6432 </span><span class="lineCov">          1 :   endcapsidecoverot[0]-&gt;SetAngles(-90.,0.,0.);</span>
<span class="lineNum">    6433 </span><span class="lineCov">          3 :   endcapsidecovercombitrans[0] = new TGeoCombiTrans(0.0,</span>
<span class="lineNum">    6434 </span><span class="lineCov">          2 :                                                                                         - 0.5*(fgkEndCapCoverPlateWidth[0]</span>
<span class="lineNum">    6435 </span><span class="lineCov">          1 :                                                                                         - fgkEndCapCoverPlateWidth[2]</span>
<span class="lineNum">    6436 </span><span class="lineCov">          1 :                                                                                     - (kendcapcoverplatesmallholenumber-1)</span>
<span class="lineNum">    6437 </span><span class="lineCov">          1 :                                                                                         * fgkEndCapCoverPlateSmallHoleSeparation[2])</span>
<span class="lineNum">    6438 </span><span class="lineCov">          1 :                                                                                         + 0.*fgkEndCapCoverPlateWidth[0]</span>
<span class="lineNum">    6439 </span><span class="lineCov">          1 :                                                                                         + fgkEndCapSideCoverLength[2],</span>
<span class="lineNum">    6440 </span><span class="lineCov">          2 :                                                                                           0.5*(fgkEndCapSideCoverThickness</span>
<span class="lineNum">    6441 </span><span class="lineCov">          1 :                                                                                         + fgkEndCapCoverPlateThickness)</span>
<span class="lineNum">    6442 </span><span class="lineCov">          1 :                                                                                         - 0.5*fgkEndCapCoverPlateThickness,</span>
<span class="lineNum">    6443 </span><span class="lineCov">          1 :                                                                                           endcapsidecoverot[0]);</span>
<span class="lineNum">    6444 </span><span class="lineCov">          1 :   endcapsidecoverot[1]-&gt;SetAngles(90.,-90.,-90.); </span>
<span class="lineNum">    6445 </span><span class="lineCov">          3 :   endcapsidecovercombitrans[1] = new TGeoCombiTrans(-fgkEndCapCoverPlateLength[0],0.0,</span>
<span class="lineNum">    6446 </span><span class="lineCov">          1 :                                                                                                         0.5*fgkEndCapCoverPlateThickness</span>
<span class="lineNum">    6447 </span><span class="lineCov">          1 :                                                                                                         -fgkEndCapSideCoverWidth[1],</span>
<span class="lineNum">    6448 </span><span class="lineCov">          1 :                                                                                                         endcapsidecoverot[1]);</span>
<span class="lineNum">    6449 </span><span class="lineCov">          3 :   endcapsidecovercombitrans[2] = new TGeoCombiTrans(-fgkEndCapCoverPlateLength[0]</span>
<span class="lineNum">    6450 </span><span class="lineCov">          1 :                                                                                                         +fgkEndCapCoverPlateLength[3]</span>
<span class="lineNum">    6451 </span><span class="lineCov">          1 :                                                                                                         +2.*fgkEndCapCoverPlateLength[2]</span>
<span class="lineNum">    6452 </span><span class="lineCov">          1 :                                                                                                         +fgkEndCapSideCoverThickness,0.0,</span>
<span class="lineNum">    6453 </span><span class="lineCov">          1 :                                                                                                         0.5*fgkEndCapCoverPlateThickness</span>
<span class="lineNum">    6454 </span><span class="lineCov">          1 :                                                                                                         -fgkEndCapSideCoverWidth[1],</span>
<span class="lineNum">    6455 </span><span class="lineCov">          1 :                                                                                                         endcapsidecoverot[1]);</span>
<span class="lineNum">    6456 </span><span class="lineCov">          1 :   TGeoHMatrix* endcapsidecovermatrix[2];</span>
<span class="lineNum">    6457 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;2; i++){</span>
<span class="lineNum">    6458 </span><span class="lineCov">          6 :    endcapsidecovermatrix[i] = new TGeoHMatrix((*endcapsidecovercombitrans[i+1])</span>
<span class="lineNum">    6459 </span><span class="lineCov">          2 :                                                         *                                 (*endcapsidecovercombitrans[0]));</span>
<span class="lineNum">    6460 </span><span class="lineCov">         28 :         for(Int_t k=0; k&lt;4; k++) endcapassembly[k]-&gt;AddNode(endcapsidecover,i+1,</span>
<span class="lineNum">    6461 </span><span class="lineCov">          8 :                                                                                                                 endcapsidecovermatrix[i]);</span>
<span class="lineNum">    6462 </span>            :   }
<span class="lineNum">    6463 </span>            :   /////////////////////////////////////////////////////
<span class="lineNum">    6464 </span>            :   // Placing Endcap Cooling Tube
<span class="lineNum">    6465 </span>            :   /////////////////////////////////////////////////////
<span class="lineNum">    6466 </span><span class="lineCov">          1 :   TGeoVolume* endcapcoolingtube = GetEndCapCoolingTube();</span>
<span class="lineNum">    6467 </span><span class="lineCov">          1 :   TGeoRotation* endcapcoolingtuberot = new TGeoRotation();</span>
<span class="lineNum">    6468 </span><span class="lineCov">          1 :   endcapcoolingtuberot-&gt;SetAngles(0.,180.,0.); </span>
<span class="lineNum">    6469 </span>            :   TGeoCombiTrans* endcapccolingtubecombitrans 
<span class="lineNum">    6470 </span><span class="lineCov">          3 :                                                 = new TGeoCombiTrans(-0.5*(fgkEndCapCoolingTubeAxialRadius[0]</span>
<span class="lineNum">    6471 </span><span class="lineCov">          1 :                                                 + fgkEndCapCoolingTubeAxialRadius[1])</span>
<span class="lineNum">    6472 </span><span class="lineCov">          1 :                                                 + fgkEndCapCoverPlateLength[0]+fgkEndCapCoverPlateLength[1]</span>
<span class="lineNum">    6473 </span><span class="lineCov">          1 :                                                 - fgkEndCapCoolingTubeToCoverSide,</span>
<span class="lineNum">    6474 </span><span class="lineCov">          1 :                                                   fgkEndCapCoolingTubeAxialRadius[0],fgkEndCapCoolingTubeRadiusMax</span>
<span class="lineNum">    6475 </span><span class="lineCov">          1 :                                                 + 0.5*fgkEndCapCoverPlateThickness,endcapcoolingtuberot);</span>
<span class="lineNum">    6476 </span><span class="lineCov">         14 :   for(Int_t i=0; i&lt;4; i++) endcapassembly[i]-&gt;AddNode(endcapcoolingtube,1,</span>
<span class="lineNum">    6477 </span><span class="lineCov">          4 :                                                                                                           endcapccolingtubecombitrans);</span>
<span class="lineNum">    6478 </span>            :   /////////////////////////////////////////////////////
<span class="lineNum">    6479 </span>            :   // Placing Screws 
<span class="lineNum">    6480 </span>            :   /////////////////////////////////////////////////////
<span class="lineNum">    6481 </span><span class="lineCov">          2 :   Double_t screwcoverplateradius[2] = {fgkEndCapCoverPlateScrewRadiusMax,</span>
<span class="lineNum">    6482 </span><span class="lineCov">          1 :                                                                            fgkEndCapCoverPlateScrewRadiusMin};</span>
<span class="lineNum">    6483 </span><span class="lineCov">          1 :   Int_t screwcoverplatedgesnumber[2] = {20,20};</span>
<span class="lineNum">    6484 </span><span class="lineCov">          2 :   Double_t screwcoverplatesection[2] = {0.5*fgkEndCapCoverPlateThickness,</span>
<span class="lineNum">    6485 </span><span class="lineCov">          1 :                                                                                 fgkEndCapCoverPlateThickness</span>
<span class="lineNum">    6486 </span><span class="lineCov">          1 :                                                                          +  fgkEndCapCoolingTubeRadiusMax};</span>
<span class="lineNum">    6487 </span><span class="lineCov">          2 :   TGeoShape* screwcoverplateshape = GetScrewShape(screwcoverplateradius,</span>
<span class="lineNum">    6488 </span><span class="lineCov">          1 :                                                                                                  screwcoverplatedgesnumber,</span>
<span class="lineNum">    6489 </span><span class="lineCov">          1 :                                                                                                  screwcoverplatesection);</span>
<span class="lineNum">    6490 </span><span class="lineCov">          2 :   TGeoVolume* screwcoverplate = new TGeoVolume(&quot;EndCapScrewCoverPlate&quot;,</span>
<span class="lineNum">    6491 </span>            :                                                                                            screwcoverplateshape,
<span class="lineNum">    6492 </span><span class="lineCov">          1 :                                                                                            fSSDCoolingTubePhynox); </span>
<span class="lineNum">    6493 </span><span class="lineCov">          1 :   screwcoverplate-&gt;SetLineColor(12);</span>
<span class="lineNum">    6494 </span><span class="lineCov">          4 :   Double_t transx[4] = {0,</span>
<span class="lineNum">    6495 </span><span class="lineCov">          1 :                                                 fgkEndCapCoverPlateSmallHoleSeparation[0],</span>
<span class="lineNum">    6496 </span><span class="lineCov">          1 :                                                 fgkEndCapCoverPlateSmallHoleSeparation[0]</span>
<span class="lineNum">    6497 </span><span class="lineCov">          1 :                                          +  fgkEndCapCoverPlateSmallHoleSeparation[1],</span>
<span class="lineNum">    6498 </span><span class="lineCov">          1 :                                          2.*fgkEndCapCoverPlateSmallHoleSeparation[0]</span>
<span class="lineNum">    6499 </span><span class="lineCov">          1 :                                          +  fgkEndCapCoverPlateSmallHoleSeparation[1]};</span>
<span class="lineNum">    6500 </span>            :   const Int_t kendcapcoverplatescrewnumber[2] = {4,9}; 
<span class="lineNum">    6501 </span>            : //  TGeoTranslation** endcapcoverplatescrewtrans[kendcapcoverplatescrewnumber[0]]; 
<span class="lineNum">    6502 </span>            :   TGeoTranslation*** endcapcoverplatescrewtrans;
<span class="lineNum">    6503 </span><span class="lineCov">          1 :   endcapcoverplatescrewtrans = new TGeoTranslation**[kendcapcoverplatescrewnumber[0]]; </span>
<span class="lineNum">    6504 </span>            :   Int_t index = 0;
<span class="lineNum">    6505 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;kendcapcoverplatescrewnumber[0]; i++){</span>
<span class="lineNum">    6506 </span><span class="lineCov">          4 :         endcapcoverplatescrewtrans[i] = </span>
<span class="lineNum">    6507 </span><span class="lineCov">          4 :                                         new TGeoTranslation*[kendcapcoverplatescrewnumber[1]];</span>
<span class="lineNum">    6508 </span><span class="lineCov">         80 :     for(Int_t j=0; j&lt;kendcapcoverplatescrewnumber[1]; j++){</span>
<span class="lineNum">    6509 </span><span class="lineCov">         36 :                 index = kendcapcoverplatescrewnumber[1]*i+j+1;</span>
<span class="lineNum">    6510 </span><span class="lineCov">         72 :         if(index==1||index==9||index==28||index==36){</span>
<span class="lineNum">    6511 </span><span class="lineCov">          4 :                         endcapcoverplatescrewtrans[i][j] = </span>
<span class="lineNum">    6512 </span><span class="lineCov">         40 :                                 new TGeoTranslation(transx[i],</span>
<span class="lineNum">    6513 </span><span class="lineCov">         36 :                                                                         j*fgkEndCapCoverPlateSmallHoleSeparation[2],</span>
<span class="lineNum">    6514 </span><span class="lineCov">          4 :                                                                         fgkEndCapSideCoverThickness);</span>
<span class="lineNum">    6515 </span><span class="lineCov">          4 :                 }</span>
<span class="lineNum">    6516 </span>            :                 else{
<span class="lineNum">    6517 </span><span class="lineCov">         32 :                         endcapcoverplatescrewtrans[i][j] = </span>
<span class="lineNum">    6518 </span><span class="lineCov">         32 :                                 new TGeoTranslation(transx[i],</span>
<span class="lineNum">    6519 </span>            :                                                                         j*fgkEndCapCoverPlateSmallHoleSeparation[2],
<span class="lineNum">    6520 </span>            :                                                                         0.);
<span class="lineNum">    6521 </span>            :                 }
<span class="lineNum">    6522 </span><span class="lineCov">         36 :             if(index!=19) </span>
<span class="lineNum">    6523 </span><span class="lineCov">        490 :                 for(Int_t k=0; k&lt;4; k++) endcapassembly[k]-&gt;AddNode(screwcoverplate,index,</span>
<span class="lineNum">    6524 </span><span class="lineCov">        175 :                                                                                           endcapcoverplatescrewtrans[i][j]);</span>
<span class="lineNum">    6525 </span>            :         }
<span class="lineNum">    6526 </span>            :   }
<span class="lineNum">    6527 </span>            :   /////////////////////////////////////////////////////
<span class="lineNum">    6528 </span>            :   // Placing Cover Plate Clips 
<span class="lineNum">    6529 </span>            :   /////////////////////////////////////////////////////
<span class="lineNum">    6530 </span><span class="lineCov">          2 :   TGeoBBox* endcapcoverplateclipshape = new TGeoBBox(0.5*fgkEndCapCoverPlateClipLength,</span>
<span class="lineNum">    6531 </span><span class="lineCov">          1 :                                                                                                          0.5*fgkEndCapCoverPlateClipWidth,</span>
<span class="lineNum">    6532 </span><span class="lineCov">          1 :                                                                                                          0.5*fgkEndCapSideCoverThickness);</span>
<span class="lineNum">    6533 </span><span class="lineCov">          2 :   TGeoVolume* endcapcoverplateclip = new TGeoVolume(&quot;EndCapCoverPlateUpClip&quot;,</span>
<span class="lineNum">    6534 </span><span class="lineCov">          1 :                                                                                                         endcapcoverplateclipshape,</span>
<span class="lineNum">    6535 </span><span class="lineCov">          1 :                                                                                                         fSSDCoolingTubePhynox);</span>
<span class="lineNum">    6536 </span><span class="lineCov">          2 :   TGeoBBox* endcapcoverplatedownclipshape = new TGeoBBox(0.5*fgkEndCapCoverPlateDownClipLength,</span>
<span class="lineNum">    6537 </span><span class="lineCov">          1 :                                                                                                          0.5*fgkEndCapCoverPlateDownClipWidth,</span>
<span class="lineNum">    6538 </span><span class="lineCov">          1 :                                                                                                          0.5*fgkEndCapSideCoverThickness);</span>
<span class="lineNum">    6539 </span><span class="lineCov">          2 :   TGeoVolume* endcapcoverplatedownclip = new TGeoVolume(&quot;EndCapCoverPlateDownClip&quot;,</span>
<span class="lineNum">    6540 </span><span class="lineCov">          1 :                                                                                                         endcapcoverplatedownclipshape,</span>
<span class="lineNum">    6541 </span><span class="lineCov">          1 :                                                                                                         fSSDCoolingTubePhynox);</span>
<span class="lineNum">    6542 </span><span class="lineCov">          1 :   TGeoTranslation* endcapcoverplatecliptrans[4];</span>
<span class="lineNum">    6543 </span><span class="lineCov">          3 :   endcapcoverplatecliptrans[0] = new TGeoTranslation(0.5*fgkEndCapCoverPlateClipLength</span>
<span class="lineNum">    6544 </span><span class="lineCov">          1 :                                                            -                     fgkEndCapCoverPlateLength[0]</span>
<span class="lineNum">    6545 </span><span class="lineCov">          1 :                                                            -                     fgkEndCapSideCoverThickness,</span>
<span class="lineNum">    6546 </span>            :                                                                                                          0.0,
<span class="lineNum">    6547 </span><span class="lineCov">          1 :                                                                                                  0.5*(fgkEndCapSideCoverThickness</span>
<span class="lineNum">    6548 </span><span class="lineCov">          1 :                                                            +                                              fgkEndCapCoverPlateThickness));</span>
<span class="lineNum">    6549 </span><span class="lineCov">          3 :   endcapcoverplatecliptrans[1] = new TGeoTranslation(0.5*fgkEndCapCoverPlateClipLength</span>
<span class="lineNum">    6550 </span><span class="lineCov">          1 :                                                            -                     fgkEndCapCoverPlateLength[0]</span>
<span class="lineNum">    6551 </span><span class="lineCov">          1 :                                                            -                     fgkEndCapSideCoverThickness,</span>
<span class="lineNum">    6552 </span>            :                                                                                                          (kendcapcoverplatescrewnumber[1]-1)
<span class="lineNum">    6553 </span><span class="lineCov">          1 :                                                            *                                     fgkEndCapSideCoverWidth[5],</span>
<span class="lineNum">    6554 </span><span class="lineCov">          1 :                                                                                                  0.5*(fgkEndCapSideCoverThickness</span>
<span class="lineNum">    6555 </span><span class="lineCov">          1 :                                                            +                                              fgkEndCapCoverPlateThickness));</span>
<span class="lineNum">    6556 </span><span class="lineCov">          3 :   endcapcoverplatecliptrans[2] = new TGeoTranslation(0.5*fgkEndCapCoverPlateClipLength</span>
<span class="lineNum">    6557 </span><span class="lineCov">          1 :                                                            -                     fgkEndCapCoverPlateLength[0]</span>
<span class="lineNum">    6558 </span><span class="lineCov">          1 :                                                            +                                     fgkEndCapCoverPlateLength[1]</span>
<span class="lineNum">    6559 </span><span class="lineCov">          1 :                                                            +                              2.*fgkEndCapCoverPlateLength[0]</span>
<span class="lineNum">    6560 </span><span class="lineCov">          1 :                                                            -                                     fgkEndCapCoverPlateClipLength</span>
<span class="lineNum">    6561 </span><span class="lineCov">          1 :                                                            +                                 fgkEndCapSideCoverThickness,</span>
<span class="lineNum">    6562 </span>            :                                                                                                          0.0,
<span class="lineNum">    6563 </span><span class="lineCov">          1 :                                                                                                  0.5*(fgkEndCapSideCoverThickness</span>
<span class="lineNum">    6564 </span><span class="lineCov">          1 :                                                            +                                              fgkEndCapCoverPlateThickness));</span>
<span class="lineNum">    6565 </span><span class="lineCov">          3 :   endcapcoverplatecliptrans[3] = new TGeoTranslation(0.5*fgkEndCapCoverPlateClipLength</span>
<span class="lineNum">    6566 </span><span class="lineCov">          1 :                                                            -                     fgkEndCapCoverPlateLength[0]</span>
<span class="lineNum">    6567 </span><span class="lineCov">          1 :                                                            +                                     fgkEndCapCoverPlateLength[1]</span>
<span class="lineNum">    6568 </span><span class="lineCov">          1 :                                                            +                              2.*fgkEndCapCoverPlateLength[0]</span>
<span class="lineNum">    6569 </span><span class="lineCov">          1 :                                                            -                                     fgkEndCapCoverPlateClipLength</span>
<span class="lineNum">    6570 </span><span class="lineCov">          1 :                                                            +                                 fgkEndCapSideCoverThickness,</span>
<span class="lineNum">    6571 </span>            :                                                                                                          (kendcapcoverplatescrewnumber[1]-1)
<span class="lineNum">    6572 </span><span class="lineCov">          1 :                                                            *                                     fgkEndCapSideCoverWidth[5],</span>
<span class="lineNum">    6573 </span><span class="lineCov">          1 :                                                                                                  0.5*(fgkEndCapSideCoverThickness</span>
<span class="lineNum">    6574 </span><span class="lineCov">          1 :                                                            +                                              fgkEndCapCoverPlateThickness));</span>
<span class="lineNum">    6575 </span><span class="lineCov">          1 :   endcapcoverplateclip-&gt;SetLineColor(fColorPhynox);</span>
<span class="lineNum">    6576 </span><span class="lineCov">          1 :   endcapcoverplatedownclip-&gt;SetLineColor(fColorPhynox);  </span>
<span class="lineNum">    6577 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;4; i++) </span>
<span class="lineNum">    6578 </span><span class="lineCov">         56 :         for(Int_t j=0; j&lt;4; j++) endcapassembly[j]-&gt;AddNode(endcapcoverplateclip,i+1,</span>
<span class="lineNum">    6579 </span><span class="lineCov">         16 :                                                                                                    endcapcoverplatecliptrans[i]);  </span>
<span class="lineNum">    6580 </span><span class="lineCov">          1 :   TGeoTranslation* endcapcoverplatedowncliptrans[4];</span>
<span class="lineNum">    6581 </span><span class="lineCov">          3 :   endcapcoverplatedowncliptrans[0] = new TGeoTranslation(0.5*fgkEndCapCoverPlateDownClipLength</span>
<span class="lineNum">    6582 </span><span class="lineCov">          1 :                                                                    -                     fgkEndCapCoverPlateLength[0]</span>
<span class="lineNum">    6583 </span><span class="lineCov">          1 :                                                                    -                     fgkEndCapSideCoverThickness,</span>
<span class="lineNum">    6584 </span><span class="lineCov">          2 :                                                                                     0.5*(fgkEndCapCoverPlateDownClipWidth</span>
<span class="lineNum">    6585 </span><span class="lineCov">          1 :                                                                    -                                 fgkEndCapCoverPlateClipWidth),</span>
<span class="lineNum">    6586 </span><span class="lineCov">          1 :                                                                                                         0.5*(fgkEndCapSideCoverThickness</span>
<span class="lineNum">    6587 </span><span class="lineCov">          1 :                                                                +                                         fgkEndCapCoverPlateThickness)</span>
<span class="lineNum">    6588 </span><span class="lineCov">          1 :                                                                    -                     fgkEndCapSideCoverWidth[1]</span>
<span class="lineNum">    6589 </span><span class="lineCov">          1 :                                                                    -                                     fgkEndCapSideCoverThickness);</span>
<span class="lineNum">    6590 </span><span class="lineCov">          3 :   endcapcoverplatedowncliptrans[1] = new TGeoTranslation(0.5*fgkEndCapCoverPlateDownClipLength</span>
<span class="lineNum">    6591 </span><span class="lineCov">          1 :                                                                    -                     fgkEndCapCoverPlateLength[0]</span>
<span class="lineNum">    6592 </span><span class="lineCov">          1 :                                                                    -                     fgkEndCapSideCoverThickness,</span>
<span class="lineNum">    6593 </span><span class="lineCov">          2 :                                                                                     0.5*(fgkEndCapCoverPlateDownClipWidth</span>
<span class="lineNum">    6594 </span><span class="lineCov">          1 :                                                                    -                                 fgkEndCapCoverPlateClipWidth)</span>
<span class="lineNum">    6595 </span><span class="lineCov">          1 :                                                                    +                            fgkEndCapSideCoverLength[2]</span>
<span class="lineNum">    6596 </span><span class="lineCov">          1 :                                                                    -                            fgkEndCapCoverPlateDownClipWidth,</span>
<span class="lineNum">    6597 </span><span class="lineCov">          1 :                                                                                                         0.5*(fgkEndCapSideCoverThickness</span>
<span class="lineNum">    6598 </span><span class="lineCov">          1 :                                                                +                                         fgkEndCapCoverPlateThickness)</span>
<span class="lineNum">    6599 </span><span class="lineCov">          1 :                                                                    -                     fgkEndCapSideCoverWidth[1]</span>
<span class="lineNum">    6600 </span><span class="lineCov">          1 :                                                                    -                                     fgkEndCapSideCoverThickness);</span>
<span class="lineNum">    6601 </span><span class="lineCov">          3 :   endcapcoverplatedowncliptrans[2] = new TGeoTranslation(0.5*fgkEndCapCoverPlateDownClipLength</span>
<span class="lineNum">    6602 </span><span class="lineCov">          1 :                                                                    -                     fgkEndCapCoverPlateLength[0]</span>
<span class="lineNum">    6603 </span><span class="lineCov">          1 :                                                                    +                     fgkEndCapSideCoverThickness</span>
<span class="lineNum">    6604 </span><span class="lineCov">          1 :                                                                    +                     fgkEndCapCoverPlateLength[1]</span>
<span class="lineNum">    6605 </span><span class="lineCov">          1 :                                                                    +                 2.0*fgkEndCapCoverPlateLength[0]</span>
<span class="lineNum">    6606 </span><span class="lineCov">          1 :                                                                    -                     fgkEndCapCoverPlateDownClipLength,</span>
<span class="lineNum">    6607 </span><span class="lineCov">          2 :                                                                                     0.5*(fgkEndCapCoverPlateDownClipWidth</span>
<span class="lineNum">    6608 </span><span class="lineCov">          1 :                                                                    -                                 fgkEndCapCoverPlateClipWidth),</span>
<span class="lineNum">    6609 </span><span class="lineCov">          1 :                                                                                                         0.5*(fgkEndCapSideCoverThickness</span>
<span class="lineNum">    6610 </span><span class="lineCov">          1 :                                                                +                                         fgkEndCapCoverPlateThickness)</span>
<span class="lineNum">    6611 </span><span class="lineCov">          1 :                                                                    -                     fgkEndCapSideCoverWidth[1]</span>
<span class="lineNum">    6612 </span><span class="lineCov">          1 :                                                                    -                                     fgkEndCapSideCoverThickness);</span>
<span class="lineNum">    6613 </span><span class="lineCov">          3 :   endcapcoverplatedowncliptrans[3] = new TGeoTranslation(0.5*fgkEndCapCoverPlateDownClipLength</span>
<span class="lineNum">    6614 </span><span class="lineCov">          1 :                                                                    -                     fgkEndCapCoverPlateLength[0]</span>
<span class="lineNum">    6615 </span><span class="lineCov">          1 :                                                                    +                     fgkEndCapSideCoverThickness</span>
<span class="lineNum">    6616 </span><span class="lineCov">          1 :                                                                    +                     fgkEndCapCoverPlateLength[1]</span>
<span class="lineNum">    6617 </span><span class="lineCov">          1 :                                                                    +                 2.0*fgkEndCapCoverPlateLength[0]</span>
<span class="lineNum">    6618 </span><span class="lineCov">          1 :                                                                    -                     fgkEndCapCoverPlateDownClipLength,</span>
<span class="lineNum">    6619 </span><span class="lineCov">          2 :                                                                                     0.5*(fgkEndCapCoverPlateDownClipWidth</span>
<span class="lineNum">    6620 </span><span class="lineCov">          1 :                                                                    -                                 fgkEndCapCoverPlateClipWidth)</span>
<span class="lineNum">    6621 </span><span class="lineCov">          1 :                                                                    +                                 fgkEndCapSideCoverLength[2]</span>
<span class="lineNum">    6622 </span><span class="lineCov">          1 :                                                                    -                                 fgkEndCapCoverPlateDownClipWidth,</span>
<span class="lineNum">    6623 </span><span class="lineCov">          1 :                                                                                                         0.5*(fgkEndCapSideCoverThickness</span>
<span class="lineNum">    6624 </span><span class="lineCov">          1 :                                                                +                                         fgkEndCapCoverPlateThickness)</span>
<span class="lineNum">    6625 </span><span class="lineCov">          1 :                                                                    -                     fgkEndCapSideCoverWidth[1]</span>
<span class="lineNum">    6626 </span><span class="lineCov">          1 :                                                                    -                                     fgkEndCapSideCoverThickness);</span>
<span class="lineNum">    6627 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;4; i++)</span>
<span class="lineNum">    6628 </span><span class="lineCov">         56 :         for(Int_t k=0; k&lt;4; k++) endcapassembly[k]-&gt;AddNode(endcapcoverplatedownclip,i+1,</span>
<span class="lineNum">    6629 </span><span class="lineCov">         16 :                                                                                                    endcapcoverplatedowncliptrans[i]);</span>
<span class="lineNum">    6630 </span>            :   /////////////////////////////////////////////////////
<span class="lineNum">    6631 </span>            :   // Placing Kapton Foil
<span class="lineNum">    6632 </span>            :   /////////////////////////////////////////////////////
<span class="lineNum">    6633 </span><span class="lineCov">          2 :   TGeoBBox* endcapkaptonfoilshape = new TGeoBBox(0.5*fgkEndCapKaptonFoilLength,</span>
<span class="lineNum">    6634 </span><span class="lineCov">          1 :                                                                                                  0.5*fgkEndCapKaptonFoilWidth,</span>
<span class="lineNum">    6635 </span><span class="lineCov">          1 :                                                                                                  0.5*fgkEndCapKaptonFoilThickness); </span>
<span class="lineNum">    6636 </span><span class="lineCov">          2 :   TGeoVolume* endcapkaptonfoil = new TGeoVolume(&quot;EndCapKaptonFoil&quot;,</span>
<span class="lineNum">    6637 </span><span class="lineCov">          1 :                                                                                                 endcapkaptonfoilshape,</span>
<span class="lineNum">    6638 </span><span class="lineCov">          1 :                                                                                                 fSSDKaptonFlexMedium);</span>
<span class="lineNum">    6639 </span><span class="lineCov">          1 :   endcapkaptonfoil-&gt;SetLineColor(8);</span>
<span class="lineNum">    6640 </span><span class="lineCov">          2 :   TGeoTranslation* endcapkaptonfoiltrans = new TGeoTranslation(0.5*fgkEndCapCoverPlateLength[1],</span>
<span class="lineNum">    6641 </span><span class="lineCov">          1 :                                                                                                                            0.5*fgkEndCapKaptonFoilWidth</span>
<span class="lineNum">    6642 </span><span class="lineCov">          1 :                                                                                  -                     0.5*fgkEndCapCoverPlateClipWidth,</span>
<span class="lineNum">    6643 </span><span class="lineCov">          1 :                                                                                                                            0.5*fgkEndCapCoverPlateThickness</span>
<span class="lineNum">    6644 </span><span class="lineCov">          1 :                                                                                  -                     0.5*fgkEndCapKaptonFoilThickness</span>
<span class="lineNum">    6645 </span><span class="lineCov">          1 :                                                                              -                     fgkEndCapSideCoverWidth[1]</span>
<span class="lineNum">    6646 </span><span class="lineCov">          1 :                                                                                  -                     fgkEndCapSideCoverThickness);</span>
<span class="lineNum">    6647 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;4; i++) endcapassembly[i]-&gt;AddNode(endcapkaptonfoil,1,endcapkaptonfoiltrans);</span>
<span class="lineNum">    6648 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    6649 </span>            :   // Placing Electronic Tubes
<span class="lineNum">    6650 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    6651 </span><span class="lineCov">          1 :   Double_t endcapeffectivecableswidth[2] = {fgkEndCapKaptonFoilWidth</span>
<span class="lineNum">    6652 </span><span class="lineCov">          1 :                                                                              - fgkEndCapInterfaceCardBThickness</span>
<span class="lineNum">    6653 </span><span class="lineCov">          1 :                                                                              - 9.*fgkEndCapStripConnectionThickness</span>
<span class="lineNum">    6654 </span><span class="lineCov">          1 :                                                                              - 8.*fgkEndCapCardElectBoardBackThickness,</span>
<span class="lineNum">    6655 </span>            :                                                                                fgkEndCapKaptonFoilWidth
<span class="lineNum">    6656 </span>            :                                                                              - fgkEndCapInterfaceCardBThickness
<span class="lineNum">    6657 </span>            :                                                                              - 9.*fgkEndCapStripConnectionThickness
<span class="lineNum">    6658 </span>            :                                                                              - 8.*fgkEndCapCardElectBoardBackThickness
<span class="lineNum">    6659 </span><span class="lineCov">          1 :                                                                                  - fgkEndCapInterfaceElectBoardCardBThickness};</span>
<span class="lineNum">    6660 </span>            :   TGeoVolume* endcapeffectivecables[2];
<span class="lineNum">    6661 </span><span class="lineCov">          2 :   endcapeffectivecables[0] = GetEndCapEffectiveCables(fgkEndCapEffectiveCableRadiusMin,</span>
<span class="lineNum">    6662 </span><span class="lineCov">          1 :                                                                                          fgkEndCapEffectiveCableRadiusMax,</span>
<span class="lineNum">    6663 </span>            :                                                                                          endcapeffectivecableswidth[0],
<span class="lineNum">    6664 </span>            :                                                                                          10,&quot;EndCapEffectiveCables1&quot;); 
<span class="lineNum">    6665 </span><span class="lineCov">          2 :   endcapeffectivecables[1] = GetEndCapEffectiveCables(fgkEndCapEffectiveCableRadiusMin,</span>
<span class="lineNum">    6666 </span><span class="lineCov">          1 :                                                                                          fgkEndCapEffectiveCableRadiusMax,</span>
<span class="lineNum">    6667 </span>            :                                                                                          endcapeffectivecableswidth[1],
<span class="lineNum">    6668 </span>            :                                                                                          25,&quot;EndCapEffectiveCables2&quot;); 
<span class="lineNum">    6669 </span><span class="lineCov">          1 :   TGeoRotation* endcapeffectivecablesrot = new TGeoRotation();</span>
<span class="lineNum">    6670 </span>            :   TGeoTranslation* endcapeffectivecablestrans[2];
<span class="lineNum">    6671 </span><span class="lineCov">          2 :   endcapeffectivecablestrans[0] = new TGeoTranslation(0.5*fgkEndCapCoverPlateLength[1],</span>
<span class="lineNum">    6672 </span><span class="lineCov">          1 :                                           -                                                        0.5*endcapeffectivecableswidth[0]</span>
<span class="lineNum">    6673 </span><span class="lineCov">          2 :                                           -                            0.5*(fgkEndCapCoverPlateWidth[0]</span>
<span class="lineNum">    6674 </span><span class="lineCov">          1 :                                           -                                                               fgkEndCapCoverPlateWidth[2]</span>
<span class="lineNum">    6675 </span><span class="lineCov">          1 :                                           -                                             (kendcapcoverplatesmallholenumber-1)</span>
<span class="lineNum">    6676 </span><span class="lineCov">          1 :                                           *                                             fgkEndCapCoverPlateSmallHoleSeparation[2])</span>
<span class="lineNum">    6677 </span><span class="lineCov">          1 :                                           +                                             fgkEndCapSideCoverLength[2],</span>
<span class="lineNum">    6678 </span><span class="lineCov">          1 :                                           -                     0.5*fgkEndCapCoverPlateThickness</span>
<span class="lineNum">    6679 </span><span class="lineCov">          2 :                                           -                                             (fgkEndCapCardElectBoardBackWidth[0]</span>
<span class="lineNum">    6680 </span><span class="lineCov">          1 :                                           -                                              fgkEndCapInterfaceCardBWidth[0]</span>
<span class="lineNum">    6681 </span><span class="lineCov">          1 :                                           -                                              fgkEndCapInterfaceCardBWidth[1]));</span>
<span class="lineNum">    6682 </span><span class="lineCov">          2 :   endcapeffectivecablestrans[1] = new TGeoTranslation(0.5*fgkEndCapCoverPlateLength[1],</span>
<span class="lineNum">    6683 </span><span class="lineCov">          1 :                                           -                                                        0.5*endcapeffectivecableswidth[1]</span>
<span class="lineNum">    6684 </span><span class="lineCov">          2 :                                           -                            0.5*(fgkEndCapCoverPlateWidth[0]</span>
<span class="lineNum">    6685 </span><span class="lineCov">          1 :                                           -                                                               fgkEndCapCoverPlateWidth[2]</span>
<span class="lineNum">    6686 </span><span class="lineCov">          1 :                                           -                                             (kendcapcoverplatesmallholenumber-1)</span>
<span class="lineNum">    6687 </span><span class="lineCov">          1 :                                           *                                             fgkEndCapCoverPlateSmallHoleSeparation[2])</span>
<span class="lineNum">    6688 </span><span class="lineCov">          1 :                                           +                                         fgkEndCapSideCoverLength[2],</span>
<span class="lineNum">    6689 </span><span class="lineCov">          1 :                                           -                     0.5*fgkEndCapCoverPlateThickness</span>
<span class="lineNum">    6690 </span><span class="lineCov">          2 :                                           -                                             (fgkEndCapCardElectBoardBackWidth[0]</span>
<span class="lineNum">    6691 </span><span class="lineCov">          1 :                                           -                                              fgkEndCapInterfaceCardBWidth[0])</span>
<span class="lineNum">    6692 </span><span class="lineCov">          1 :                                           -                     0.5*fgkEndCapInterfaceCardBWidth[2]);</span>
<span class="lineNum">    6693 </span><span class="lineCov">          1 :   endcapeffectivecablesrot-&gt;SetAngles(0.,90.,0.);</span>
<span class="lineNum">    6694 </span>            :   TGeoCombiTrans* endcapeffectivecablescombitrans[2];
<span class="lineNum">    6695 </span><span class="lineCov">          1 :   endcapeffectivecablescombitrans[0]  = new TGeoCombiTrans(*endcapeffectivecablestrans[0],</span>
<span class="lineNum">    6696 </span>            :                                                                                                                    *endcapeffectivecablesrot);
<span class="lineNum">    6697 </span><span class="lineCov">          1 :   endcapeffectivecablescombitrans[1]  = new TGeoCombiTrans(*endcapeffectivecablestrans[1],</span>
<span class="lineNum">    6698 </span>            :                                                                                                                    *endcapeffectivecablesrot);
<span class="lineNum">    6699 </span>            : //  for(Int_t i=0; i&lt;4; i++) endcapassembly[i]-&gt;AddNode(endcapeffectivecables[0],1,
<span class="lineNum">    6700 </span>            : //                                                                                                        endcapeffectivecablescombitrans[0]);
<span class="lineNum">    6701 </span><span class="lineCov">         14 :   for(Int_t i=0; i&lt;4; i++) endcapassembly[i]-&gt;AddNode(endcapeffectivecables[1],1,</span>
<span class="lineNum">    6702 </span><span class="lineCov">          4 :                                                                                                           endcapeffectivecablescombitrans[1]);</span>
<span class="lineNum">    6703 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    6704 </span>            :   // Placing End Cap Cards
<span class="lineNum">    6705 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    6706 </span><span class="lineCov">          1 :   TGeoVolume** endcapcards = GetEndCapCards();</span>
<span class="lineNum">    6707 </span><span class="lineCov">          1 :   TGeoRotation* endcapcardsrot[2];</span>
<span class="lineNum">    6708 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;2; i++) endcapcardsrot[i] = new TGeoRotation();</span>
<span class="lineNum">    6709 </span><span class="lineCov">          1 :   endcapcardsrot[0]-&gt;SetAngles(90.,0.,0.); </span>
<span class="lineNum">    6710 </span><span class="lineCov">          1 :   TGeoTranslation* endcapcardstrans[2]; </span>
<span class="lineNum">    6711 </span><span class="lineCov">          3 :   endcapcardstrans[0] = new TGeoTranslation(0.,0.,0.5*(fgkEndCapInterfaceCardBLength[1]</span>
<span class="lineNum">    6712 </span><span class="lineCov">          1 :                                                                                         -  fgkEndCapCardElectBoardBackLength[0]));</span>
<span class="lineNum">    6713 </span><span class="lineCov">          1 :   TGeoCombiTrans* endcapcardscombitrans = new TGeoCombiTrans(*endcapcardstrans[0],*endcapcardsrot[0]);</span>
<span class="lineNum">    6714 </span><span class="lineCov">          1 :   endcapcardsrot[1]-&gt;SetAngles(90.,90.,-90.); </span>
<span class="lineNum">    6715 </span>            :   TGeoHMatrix* endcapcardsmatrix[2];
<span class="lineNum">    6716 </span><span class="lineCov">          2 :   endcapcardsmatrix[0] = new TGeoHMatrix((*endcapcardsrot[1])*(*endcapcardscombitrans));</span>
<span class="lineNum">    6717 </span><span class="lineCov">          1 :   Double_t stiffenertransx = fgkEndCapKaptonFoilWidth-fgkEndCapStiffenerWidth</span>
<span class="lineNum">    6718 </span><span class="lineCov">          1 :                                                   - fgkEndCapCardJMDConnectorLength[0]</span>
<span class="lineNum">    6719 </span><span class="lineCov">          1 :                                                   - fgkEndCapInterfaceCardBThickness</span>
<span class="lineNum">    6720 </span><span class="lineCov">          1 :                                                   - 9.*fgkEndCapStripConnectionThickness</span>
<span class="lineNum">    6721 </span><span class="lineCov">          1 :                                                   - 8.*fgkEndCapCardElectBoardBackThickness;  </span>
<span class="lineNum">    6722 </span><span class="lineCov">          3 :   endcapcardstrans[1] = new TGeoTranslation(-0.5*fgkEndCapStiffenerLength</span>
<span class="lineNum">    6723 </span><span class="lineCov">          1 :                                           -                                             fgkEndCapCoverPlateLength[0]</span>
<span class="lineNum">    6724 </span><span class="lineCov">          2 :                                           + 0.5 *              (fgkEndCapCoverPlateLength[3]</span>
<span class="lineNum">    6725 </span><span class="lineCov">          1 :                                           + 2.0 *                               fgkEndCapCoverPlateLength[2]),  </span>
<span class="lineNum">    6726 </span><span class="lineCov">          1 :                                           -                                                     stiffenertransx-fgkEndCapStiffenerWidth</span>
<span class="lineNum">    6727 </span><span class="lineCov">          1 :                                           -                                                               fgkEndCapCardJMDConnectorLength[0]</span>
<span class="lineNum">    6728 </span><span class="lineCov">          1 :                                           -                                                               fgkEndCapInterfaceCardBThickness</span>
<span class="lineNum">    6729 </span><span class="lineCov">          1 :                                           -     2.0 *                                             fgkEndCapStripConnectionThickness</span>
<span class="lineNum">    6730 </span><span class="lineCov">          1 :                                           - 1.5 *                                             fgkEndCapInterfaceCardBThickness</span>
<span class="lineNum">    6731 </span><span class="lineCov">          2 :                                           - 0.5 *                                                (fgkEndCapCoverPlateWidth[0]</span>
<span class="lineNum">    6732 </span><span class="lineCov">          1 :                                           -                                                               fgkEndCapCoverPlateWidth[2]</span>
<span class="lineNum">    6733 </span><span class="lineCov">          1 :                                           -                                             (kendcapcoverplatesmallholenumber-1)</span>
<span class="lineNum">    6734 </span><span class="lineCov">          1 :                                           *                                             fgkEndCapCoverPlateSmallHoleSeparation[2])</span>
<span class="lineNum">    6735 </span><span class="lineCov">          1 :                                           +                     fgkEndCapKaptonFoilWidth,</span>
<span class="lineNum">    6736 </span><span class="lineCov">          1 :                                                                                           0.5*fgkEndCapCoverPlateThickness</span>
<span class="lineNum">    6737 </span><span class="lineCov">          1 :                                           -                                                     fgkEndCapSideCoverWidth[1]);</span>
<span class="lineNum">    6738 </span><span class="lineCov">          2 :   endcapcardsmatrix[1] = new TGeoHMatrix((*endcapcardstrans[1])*(*endcapcardsmatrix[0]));</span>
<span class="lineNum">    6739 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;4; i++) endcapassembly[i]-&gt;AddNode(endcapcards[i],1,endcapcardsmatrix[1]);</span>
<span class="lineNum">    6740 </span>            :    /////////////////////////////////////////////////////////////
<span class="lineNum">    6741 </span>            :   // Deallocating memory
<span class="lineNum">    6742 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    6743 </span><span class="lineCov">          2 :   delete endcapcoverplaterot;</span>
<span class="lineNum">    6744 </span><span class="lineCov">          2 :   delete endcapcoverplatecombitrans;</span>
<span class="lineNum">    6745 </span><span class="lineCov">          2 :   delete endcapcoverplatetrans;</span>
<span class="lineNum">    6746 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;3; i++){</span>
<span class="lineNum">    6747 </span><span class="lineCov">          6 :    delete endcapsidecovercombitrans[i];</span>
<span class="lineNum">    6748 </span><span class="lineCov">          7 :    if(i&lt;2) delete endcapsidecoverot[i];      </span>
<span class="lineNum">    6749 </span>            :   }
<span class="lineNum">    6750 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;2; i++) delete endcapcardsrot[i];</span>
<span class="lineNum">    6751 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;2; i++) delete endcapcardstrans[i];</span>
<span class="lineNum">    6752 </span><span class="lineCov">          2 :   delete endcapcardsmatrix[0];</span>
<span class="lineNum">    6753 </span>            : 
<span class="lineNum">    6754 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;4; i++) endcapassembly[i]-&gt;GetShape()-&gt;ComputeBBox(); //RS: enforce recompting of BBox</span>
<span class="lineNum">    6755 </span>            : 
<span class="lineNum">    6756 </span><span class="lineCov">          1 :   return endcapassembly;</span>
<a name="6757"><span class="lineNum">    6757 </span><span class="lineCov">          1 :  } </span></a>
<span class="lineNum">    6758 </span>            :  ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    6759 </span>            :  TGeoVolume* AliITSv11GeometrySSD::GetEndCapEffectiveCables(Double_t radiusmin, 
<span class="lineNum">    6760 </span>            :                                                                                                                         Double_t radiusmax, 
<span class="lineNum">    6761 </span>            :                                                                                                                         Double_t width, 
<span class="lineNum">    6762 </span>            :                                                                                                                         Int_t ncables,
<span class="lineNum">    6763 </span>            :                                                                                                                         const char* volname){
<span class="lineNum">    6764 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    6765 </span>            :   // Generating EndCap High Voltage Tubes 
<span class="lineNum">    6766 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    6767 </span><span class="lineCov">          4 :   Double_t effectiveinneradius = TMath::Sqrt(ncables)*radiusmin;</span>
<span class="lineNum">    6768 </span><span class="lineCov">          2 :   Double_t effectiveouteradius = TMath::Sqrt(effectiveinneradius*effectiveinneradius+(radiusmax-radiusmin)*(radiusmax-radiusmin));</span>
<span class="lineNum">    6769 </span>            : 
<span class="lineNum">    6770 </span><span class="lineCov">          2 :   TGeoTube* effectiveinnertubeshape = new TGeoTube(0.,effectiveinneradius,0.5*width);</span>
<span class="lineNum">    6771 </span><span class="lineCov">          2 :   TGeoTube* effectiveoutertubeshape = new TGeoTube(effectiveinneradius,</span>
<span class="lineNum">    6772 </span>            :                                                                                                    effectiveouteradius,0.5*width);
<span class="lineNum">    6773 </span><span class="lineCov">          4 :   TGeoVolume* effectiveinnertube = new TGeoVolume(&quot;EffectiveEndCapInnerTube&quot;,</span>
<span class="lineNum">    6774 </span><span class="lineCov">          2 :                                                                                                 effectiveinnertubeshape,</span>
<span class="lineNum">    6775 </span><span class="lineCov">          2 :                                                                                                 fSSDStiffenerConnectorMedium);</span>
<span class="lineNum">    6776 </span><span class="lineCov">          2 :   effectiveinnertube-&gt;SetLineColor(41);</span>
<span class="lineNum">    6777 </span><span class="lineCov">          4 :   TGeoVolume* effectiveoutertube = new TGeoVolume(&quot;EffectiveEndCapOuterTube&quot;,</span>
<span class="lineNum">    6778 </span><span class="lineCov">          2 :                                                                                                 effectiveoutertubeshape,</span>
<span class="lineNum">    6779 </span><span class="lineCov">          2 :                                                                                                 fSSDKaptonChipCableMedium);</span>
<span class="lineNum">    6780 </span><span class="lineCov">          2 :   effectiveoutertube-&gt;SetLineColor(39);</span>
<span class="lineNum">    6781 </span><span class="lineCov">          2 :   TGeoTube* effectivemothertubeshape = new TGeoTube(0.,effectiveouteradius,0.5*width);  </span>
<span class="lineNum">    6782 </span><span class="lineCov">          2 :   TGeoVolume* effectivemothertube = new TGeoVolume(volname,effectivemothertubeshape,fSSDAir);</span>
<span class="lineNum">    6783 </span><span class="lineCov">          2 :   effectivemothertube-&gt;AddNode(effectiveinnertube,1);</span>
<span class="lineNum">    6784 </span><span class="lineCov">          2 :   effectivemothertube-&gt;AddNode(effectiveoutertube,1);</span>
<span class="lineNum">    6785 </span><span class="lineCov">          2 :   return effectivemothertube;</span>
<a name="6786"><span class="lineNum">    6786 </span><span class="lineNoCov">          0 :  } </span></a>
<span class="lineNum">    6787 </span>            :  ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    6788 </span>            :  TGeoVolume** AliITSv11GeometrySSD::EndCapSupport(){ 
<span class="lineNum">    6789 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    6790 </span>            :   // Generating EndCap Support Layer 5 and Layer 6 
<span class="lineNum">    6791 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    6792 </span>            :   const Int_t knedges = 5;
<span class="lineNum">    6793 </span>            :   ///////////////////////////////////////////////
<span class="lineNum">    6794 </span>            :   // Setting the vertices for TGeoXtru Up Volume
<span class="lineNum">    6795 </span>            :   ///////////////////////////////////////////////
<span class="lineNum">    6796 </span>            :   const Int_t klayernumber = 2;
<span class="lineNum">    6797 </span><span class="lineCov">          2 :   Double_t xupvertex[klayernumber][knedges+3];</span>
<span class="lineNum">    6798 </span><span class="lineCov">          1 :   Double_t yupvertex[klayernumber][knedges+3];</span>
<span class="lineNum">    6799 </span><span class="lineCov">          1 :   Double_t upedgeangle[klayernumber] = {360./fgkSSDLay5LadderNumber,360./fgkSSDLay6LadderNumber};</span>
<span class="lineNum">    6800 </span><span class="lineCov">          1 :   Double_t middledgeangle[klayernumber] = {0.0,0.0};</span>
<span class="lineNum">    6801 </span><span class="lineCov">          1 :   Double_t middlepsi[klayernumber] = {0.0,0.0};</span>
<span class="lineNum">    6802 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;klayernumber; i++){</span>
<span class="lineNum">    6803 </span><span class="lineCov">          2 :         xupvertex[i][0] = -fgkEndCapSupportMiddleRadius[i]*SinD(0.5*upedgeangle[i]);</span>
<span class="lineNum">    6804 </span><span class="lineCov">          2 :         xupvertex[i][1] = -0.5*fgkEndCapSupportLength[i];</span>
<span class="lineNum">    6805 </span><span class="lineCov">          2 :         xupvertex[i][2] = -xupvertex[i][1];</span>
<span class="lineNum">    6806 </span><span class="lineCov">          2 :         xupvertex[i][3] = -xupvertex[i][0];</span>
<span class="lineNum">    6807 </span>            : 
<span class="lineNum">    6808 </span><span class="lineCov">          2 :         yupvertex[i][0] =  fgkEndCapSupportMiddleRadius[i]*CosD(0.5*upedgeangle[i]);</span>
<span class="lineNum">    6809 </span><span class="lineCov">          2 :         yupvertex[i][1] =  0.5*fgkEndCapSupportLength[i]/TanD(0.5*upedgeangle[i]);</span>
<span class="lineNum">    6810 </span><span class="lineCov">          2 :         yupvertex[i][2] =  yupvertex[i][1];</span>
<span class="lineNum">    6811 </span><span class="lineCov">          2 :         yupvertex[i][3] =  yupvertex[i][0];</span>
<span class="lineNum">    6812 </span>            :         
<span class="lineNum">    6813 </span><span class="lineCov">          2 :     middledgeangle[i] = upedgeangle[i]/knedges;</span>
<span class="lineNum">    6814 </span><span class="lineCov">          2 :     middlepsi[i] = 90.0-0.5*upedgeangle[i];</span>
<span class="lineNum">    6815 </span><span class="lineCov">         20 :     for(Int_t j=1; j&lt;knedges; j++){</span>
<span class="lineNum">    6816 </span><span class="lineCov">          8 :                 xupvertex[i][j+3] = fgkEndCapSupportMiddleRadius[i]*CosD(middlepsi[i]+j*middledgeangle[i]);</span>
<span class="lineNum">    6817 </span><span class="lineCov">          8 :                 yupvertex[i][j+3] = fgkEndCapSupportMiddleRadius[i]*SinD(middlepsi[i]+j*middledgeangle[i]);</span>
<span class="lineNum">    6818 </span>            :         }
<span class="lineNum">    6819 </span>            :   }
<span class="lineNum">    6820 </span>            :   ////////////////////////////////////
<span class="lineNum">    6821 </span>            :   // Generating Up TGeoXtru
<span class="lineNum">    6822 </span>            :   ////////////////////////////////////
<span class="lineNum">    6823 </span><span class="lineCov">          1 :   TGeoXtru* upendcapsupportshape[klayernumber];</span>
<span class="lineNum">    6824 </span><span class="lineCov">          1 :   TGeoVolume* upendcapsupport[klayernumber]; </span>
<span class="lineNum">    6825 </span><span class="lineCov">          1 :   char upendcapsupportname[100]; </span>
<span class="lineNum">    6826 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;klayernumber; i++){</span>
<span class="lineNum">    6827 </span><span class="lineCov">          4 :    upendcapsupportshape[i] = new TGeoXtru(2);</span>
<span class="lineNum">    6828 </span><span class="lineCov">          2 :    snprintf(upendcapsupportname,100,&quot;UpEndCapSupportPieceLayer%i&quot;,i+5);</span>
<span class="lineNum">    6829 </span><span class="lineCov">          2 :    upendcapsupportshape[i]-&gt;DefinePolygon(knedges+3,xupvertex[i],yupvertex[i]); </span>
<span class="lineNum">    6830 </span><span class="lineCov">          2 :    upendcapsupportshape[i]-&gt;DefineSection(0,0.);</span>
<span class="lineNum">    6831 </span><span class="lineCov">          2 :    upendcapsupportshape[i]-&gt;DefineSection(1,fgkEndCapSupportHighWidth);</span>
<span class="lineNum">    6832 </span><span class="lineCov">          6 :    upendcapsupport[i] = new TGeoVolume(upendcapsupportname,upendcapsupportshape[i],</span>
<span class="lineNum">    6833 </span><span class="lineCov">          2 :                                                                         fSSDSupportRingAl);</span>
<span class="lineNum">    6834 </span><span class="lineCov">          2 :    upendcapsupport[i]-&gt;SetLineColor(5);</span>
<span class="lineNum">    6835 </span>            :   }
<span class="lineNum">    6836 </span>            :   ///////////////////////////////////////////////
<span class="lineNum">    6837 </span>            :   // Setting the vertices for TGeoXtru Down Volume
<span class="lineNum">    6838 </span>            :   ///////////////////////////////////////////////
<span class="lineNum">    6839 </span><span class="lineCov">          1 :   Double_t xdownvertex[klayernumber][2*(knedges+1)];</span>
<span class="lineNum">    6840 </span><span class="lineCov">          1 :   Double_t ydownvertex[klayernumber][2*(knedges+1)];</span>
<span class="lineNum">    6841 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;klayernumber; i++){</span>
<span class="lineNum">    6842 </span><span class="lineCov">          2 :         xdownvertex[i][0] = -fgkEndCapSupportLowRadius[i]*SinD(0.5*upedgeangle[i]);</span>
<span class="lineNum">    6843 </span><span class="lineCov">          2 :         xdownvertex[i][1] =  xupvertex[i][0];</span>
<span class="lineNum">    6844 </span><span class="lineCov">          2 :         ydownvertex[i][0] = fgkEndCapSupportLowRadius[i]*CosD(0.5*upedgeangle[i]);</span>
<span class="lineNum">    6845 </span><span class="lineCov">          2 :         ydownvertex[i][1] =  yupvertex[i][0];</span>
<span class="lineNum">    6846 </span><span class="lineCov">         24 :         for(Int_t j=0; j&lt;knedges; j++){</span>
<span class="lineNum">    6847 </span><span class="lineCov">         10 :                 xdownvertex[i][j+2] = xupvertex[i][knedges+2-j];</span>
<span class="lineNum">    6848 </span><span class="lineCov">         10 :                 ydownvertex[i][j+2] = yupvertex[i][knedges+2-j];</span>
<span class="lineNum">    6849 </span>            :         } 
<span class="lineNum">    6850 </span><span class="lineCov">         24 :         for(Int_t j=0; j&lt;knedges; j++){</span>
<span class="lineNum">    6851 </span><span class="lineCov">         20 :                 xdownvertex[i][knedges+j+2] = fgkEndCapSupportLowRadius[i]</span>
<span class="lineNum">    6852 </span><span class="lineCov">         10 :                                                                         * CosD(middlepsi[i]+j*middledgeangle[i]);</span>
<span class="lineNum">    6853 </span><span class="lineCov">         20 :                 ydownvertex[i][knedges+j+2] = fgkEndCapSupportLowRadius[i]</span>
<span class="lineNum">    6854 </span><span class="lineCov">         10 :                                                                         * SinD(middlepsi[i]+j*middledgeangle[i]);</span>
<span class="lineNum">    6855 </span>            :         }
<span class="lineNum">    6856 </span>            :   }
<span class="lineNum">    6857 </span>            :   ////////////////////////////////////
<span class="lineNum">    6858 </span>            :   // Generating Down TGeoXtru
<span class="lineNum">    6859 </span>            :   ////////////////////////////////////  
<span class="lineNum">    6860 </span><span class="lineCov">          1 :   TGeoXtru* downendcapsupportshape[klayernumber];</span>
<span class="lineNum">    6861 </span><span class="lineCov">          1 :   TGeoVolume* downendcapsupport[klayernumber]; </span>
<span class="lineNum">    6862 </span><span class="lineCov">          1 :   char downendcapsupportname[100]; </span>
<span class="lineNum">    6863 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;klayernumber; i++){</span>
<span class="lineNum">    6864 </span><span class="lineCov">          4 :         downendcapsupportshape[i] = new TGeoXtru(2);</span>
<span class="lineNum">    6865 </span><span class="lineCov">          2 :         snprintf(downendcapsupportname,100,&quot;DownEndCapSupportPieceLayer%i&quot;,i+5);</span>
<span class="lineNum">    6866 </span><span class="lineCov">          4 :         downendcapsupportshape[i] = new TGeoXtru(2);</span>
<span class="lineNum">    6867 </span><span class="lineCov">          2 :         downendcapsupportshape[i]-&gt;DefinePolygon(2*(knedges+1),xdownvertex[i],ydownvertex[i]); </span>
<span class="lineNum">    6868 </span><span class="lineCov">          4 :     if(i==0){</span>
<span class="lineNum">    6869 </span><span class="lineCov">          3 :                 downendcapsupportshape[i]-&gt;DefineSection(0,0.);</span>
<span class="lineNum">    6870 </span><span class="lineCov">          1 :                 downendcapsupportshape[i]-&gt;DefineSection(1,fgkEndCapSupportLowWidth[i]);</span>
<span class="lineNum">    6871 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">    6872 </span>            :         else{
<span class="lineNum">    6873 </span><span class="lineCov">          2 :                 downendcapsupportshape[i]-&gt;DefineSection(0,fgkEndCapSupportHighWidth</span>
<span class="lineNum">    6874 </span><span class="lineCov">          1 :                                                                  -                 fgkEndCapSupportLowWidth[i]);</span>
<span class="lineNum">    6875 </span><span class="lineCov">          1 :                 downendcapsupportshape[i]-&gt;DefineSection(1,fgkEndCapSupportHighWidth);</span>
<span class="lineNum">    6876 </span>            :         }
<span class="lineNum">    6877 </span><span class="lineCov">          6 :     downendcapsupport[i] = new TGeoVolume(downendcapsupportname,</span>
<span class="lineNum">    6878 </span><span class="lineCov">          2 :                                                                 downendcapsupportshape[i],fSSDSupportRingAl);</span>
<span class="lineNum">    6879 </span><span class="lineCov">          2 :         downendcapsupport[i]-&gt;SetLineColor(5);</span>
<span class="lineNum">    6880 </span>            :   }
<span class="lineNum">    6881 </span>            :   ///////////////////////////////////////////////
<span class="lineNum">    6882 </span>            :   // Setting TGeoPgon Volume
<span class="lineNum">    6883 </span>            :   ///////////////////////////////////////////////
<span class="lineNum">    6884 </span>            :   const Int_t kssdlayladdernumber[klayernumber] = {fgkSSDLay5LadderNumber,
<span class="lineNum">    6885 </span>            :                                                                                                    fgkSSDLay6LadderNumber};
<span class="lineNum">    6886 </span><span class="lineCov">          1 :   TGeoPgon* endcapsupportmothershape[klayernumber];</span>
<span class="lineNum">    6887 </span>            :   TGeoVolume** endcapsupportmother;
<span class="lineNum">    6888 </span><span class="lineCov">          1 :   endcapsupportmother = new TGeoVolume*[klayernumber];</span>
<span class="lineNum">    6889 </span><span class="lineCov">          1 :   char endcapsupportmothername[100];</span>
<span class="lineNum">    6890 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;klayernumber; i++){</span>
<span class="lineNum">    6891 </span><span class="lineCov">          4 :         endcapsupportmothershape[i] = new TGeoPgon(0.0,360.0,kssdlayladdernumber[i],2);</span>
<span class="lineNum">    6892 </span><span class="lineCov">          2 :         snprintf(endcapsupportmothername,100,&quot;EndCapSupportMotherLayer%i&quot;,i+5);</span>
<span class="lineNum">    6893 </span><span class="lineCov">          2 :         endcapsupportmothershape[i]-&gt;DefineSection(0,0.,ydownvertex[i][0],yupvertex[i][1]);  </span>
<span class="lineNum">    6894 </span><span class="lineCov">          4 :     endcapsupportmothershape[i]-&gt;DefineSection(1,fgkEndCapSupportHighWidth,</span>
<span class="lineNum">    6895 </span><span class="lineCov">          2 :                                                                                           ydownvertex[i][0],yupvertex[i][1]);</span>
<span class="lineNum">    6896 </span><span class="lineCov">          6 :     endcapsupportmother[i] = new TGeoVolume(endcapsupportmothername,endcapsupportmothershape[i],</span>
<span class="lineNum">    6897 </span><span class="lineCov">          2 :                                                                                         fSSDAir);       </span>
<span class="lineNum">    6898 </span>            :   }
<span class="lineNum">    6899 </span>            :   ////////////////////////////////////
<span class="lineNum">    6900 </span><span class="lineCov">          1 :   TGeoRotation** endcapsupportrot[klayernumber];</span>
<span class="lineNum">    6901 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;2; i++){</span>
<span class="lineNum">    6902 </span><span class="lineCov">          2 :         endcapsupportrot[i] = new TGeoRotation*[kssdlayladdernumber[i]];        </span>
<span class="lineNum">    6903 </span><span class="lineCov">        148 :         for(Int_t j=0; j&lt;kssdlayladdernumber[i]; j++){</span>
<span class="lineNum">    6904 </span><span class="lineCov">        144 :            endcapsupportrot[i][j] = new TGeoRotation();</span>
<span class="lineNum">    6905 </span><span class="lineCov">         72 :            endcapsupportrot[i][j]-&gt;SetAngles(j*upedgeangle[i],0.,0.);</span>
<span class="lineNum">    6906 </span><span class="lineCov">         72 :        endcapsupportmother[i]-&gt;AddNode(upendcapsupport[i],j+1,endcapsupportrot[i][j]);</span>
<span class="lineNum">    6907 </span><span class="lineCov">         72 :        endcapsupportmother[i]-&gt;AddNode(downendcapsupport[i],j+1,endcapsupportrot[i][j]);</span>
<span class="lineNum">    6908 </span>            :         }
<span class="lineNum">    6909 </span>            :   }
<span class="lineNum">    6910 </span><span class="lineCov">          1 :   return endcapsupportmother;</span>
<a name="6911"><span class="lineNum">    6911 </span><span class="lineCov">          1 :  } </span></a>
<span class="lineNum">    6912 </span>            :  ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    6913 </span>            :  void AliITSv11GeometrySSD::SetEndCapSupportAssembly(){
<span class="lineNum">    6914 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    6915 </span>            :   // Setting End Cap Support Layer 5 and 6. 
<span class="lineNum">    6916 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    6917 </span>            :   const Int_t kendcapcoverplatesmallholenumber = 9;
<span class="lineNum">    6918 </span>            :   const Int_t klayernumber = 2;
<span class="lineNum">    6919 </span>            :   const Int_t kssdlayladdernumber[klayernumber] = {fgkSSDLay5LadderNumber,
<span class="lineNum">    6920 </span>            :                                                                                                    fgkSSDLay6LadderNumber};
<span class="lineNum">    6921 </span><span class="lineCov">          3 :   Double_t upedgeangle[klayernumber] = {360.0/kssdlayladdernumber[0],</span>
<span class="lineNum">    6922 </span><span class="lineCov">          1 :                                                                                 360.0/kssdlayladdernumber[1]};</span>
<span class="lineNum">    6923 </span><span class="lineCov">          1 :   TGeoVolume** endcapsupport = EndCapSupport();</span>
<span class="lineNum">    6924 </span><span class="lineCov">          1 :   TGeoVolume** endcapassembly = GetEndCapAssembly();</span>
<span class="lineNum">    6925 </span><span class="lineCov">          1 :   TGeoPgon* endcapsupportshape[klayernumber];</span>
<span class="lineNum">    6926 </span><span class="lineCov">          1 :   Double_t* radiusmin[klayernumber];</span>
<span class="lineNum">    6927 </span><span class="lineCov">          1 :   Double_t* radiusmax[klayernumber];</span>
<span class="lineNum">    6928 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;klayernumber; i++){</span>
<span class="lineNum">    6929 </span><span class="lineCov">          2 :     endcapsupportshape[i] = (TGeoPgon*)endcapsupport[i]-&gt;GetShape();</span>
<span class="lineNum">    6930 </span><span class="lineCov">          2 :         radiusmin[i] = endcapsupportshape[i]-&gt;GetRmin();</span>
<span class="lineNum">    6931 </span><span class="lineCov">          2 :         radiusmax[i] = endcapsupportshape[i]-&gt;GetRmax();</span>
<span class="lineNum">    6932 </span>            :   }  
<span class="lineNum">    6933 </span><span class="lineCov">          1 :   TGeoBBox* endcapassemblyshape = (TGeoBBox*)endcapassembly[0]-&gt;GetShape();</span>
<span class="lineNum">    6934 </span><span class="lineCov">          1 :   Double_t endcapassemblycenter[3] = {endcapassemblyshape-&gt;GetDX(),</span>
<span class="lineNum">    6935 </span><span class="lineCov">          1 :                                                                           endcapassemblyshape-&gt;GetDY(),</span>
<span class="lineNum">    6936 </span><span class="lineCov">          1 :                                                                           endcapassemblyshape-&gt;GetDZ()};</span>
<span class="lineNum">    6937 </span>            :   ///////////////////////////////////////////////
<span class="lineNum">    6938 </span>            :   // Setting TGeoPgon Volume for Mother Container
<span class="lineNum">    6939 </span>            :   ///////////////////////////////////////////////
<span class="lineNum">    6940 </span><span class="lineCov">          1 :   TGeoPgon* endcapsupportsystemshape[klayernumber];</span>
<span class="lineNum">    6941 </span><span class="lineCov">          1 :   char endcapsupportsystemothername[100];</span>
<span class="lineNum">    6942 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;klayernumber; i++){</span>
<span class="lineNum">    6943 </span><span class="lineCov">          4 :         endcapsupportsystemshape[i] = new TGeoPgon(0.0,360.0,kssdlayladdernumber[i],2);</span>
<span class="lineNum">    6944 </span><span class="lineCov">          2 :         snprintf(endcapsupportsystemothername,100,&quot;EndCapSupportSystemLayer%i&quot;,i+5);</span>
<span class="lineNum">    6945 </span><span class="lineCov">          6 :         endcapsupportsystemshape[i]-&gt;DefineSection(0,-(fgkEndCapCoverPlateWidth[1]</span>
<span class="lineNum">    6946 </span><span class="lineCov">          4 :                                                                                              - fgkEndCapCoverPlateWidth[0]),*radiusmin[i],</span>
<span class="lineNum">    6947 </span><span class="lineCov">          2 :                                                                                           (*radiusmax[i]*CosD(0.5*upedgeangle[i])</span>
<span class="lineNum">    6948 </span><span class="lineCov">          2 :                                                                                            +2.*endcapassemblycenter[2])</span>
<span class="lineNum">    6949 </span><span class="lineCov">          2 :                                                                                            /CosD(0.5*upedgeangle[i]));  </span>
<span class="lineNum">    6950 </span><span class="lineCov">          4 :     endcapsupportsystemshape[i]-&gt;DefineSection(1,2.*endcapassemblycenter[1]</span>
<span class="lineNum">    6951 </span><span class="lineCov">          4 :                                                                                                  -(fgkEndCapCoverPlateWidth[1]</span>
<span class="lineNum">    6952 </span><span class="lineCov">          2 :                                                                                              - fgkEndCapCoverPlateWidth[0]),</span>
<span class="lineNum">    6953 </span><span class="lineCov">          2 :                                                                                            *radiusmin[i],</span>
<span class="lineNum">    6954 </span><span class="lineCov">          2 :                                                                                           (*radiusmax[i]*CosD(0.5*upedgeangle[i])</span>
<span class="lineNum">    6955 </span><span class="lineCov">          2 :                                                                                            +2.*endcapassemblycenter[2])</span>
<span class="lineNum">    6956 </span><span class="lineCov">          2 :                                                                                            /CosD(0.5*upedgeangle[i]));</span>
<span class="lineNum">    6957 </span>            :   }
<span class="lineNum">    6958 </span><span class="lineCov">          1 :   fgkEndCapSupportSystem = new TGeoVolume*[4];</span>
<span class="lineNum">    6959 </span><span class="lineCov">          3 :   fgkEndCapSupportSystem[0] = new TGeoVolume(&quot;EndCapSupportSystemLayer5Sx&quot;,</span>
<span class="lineNum">    6960 </span><span class="lineCov">          1 :                                                                           endcapsupportsystemshape[0],fSSDAir); </span>
<span class="lineNum">    6961 </span><span class="lineCov">          3 :   fgkEndCapSupportSystem[1] = new TGeoVolume(&quot;EndCapSupportSystemLayer5Dx&quot;,</span>
<span class="lineNum">    6962 </span><span class="lineCov">          1 :                                                                           endcapsupportsystemshape[0],fSSDAir); </span>
<span class="lineNum">    6963 </span><span class="lineCov">          3 :   fgkEndCapSupportSystem[2] = new TGeoVolume(&quot;EndCapSupportSystemLayer6Sx&quot;,</span>
<span class="lineNum">    6964 </span><span class="lineCov">          1 :                                                                           endcapsupportsystemshape[1],fSSDAir); </span>
<span class="lineNum">    6965 </span><span class="lineCov">          3 :   fgkEndCapSupportSystem[3] = new TGeoVolume(&quot;EndCapSupportSystemLayer6Dx&quot;,</span>
<span class="lineNum">    6966 </span><span class="lineCov">          1 :                                                                           endcapsupportsystemshape[1],fSSDAir); </span>
<span class="lineNum">    6967 </span>            :   ///////////////////////////////////////////////
<span class="lineNum">    6968 </span><span class="lineCov">          1 :   TGeoTranslation* endcapassemblytrans[klayernumber];</span>
<span class="lineNum">    6969 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;klayernumber; i++)</span>
<span class="lineNum">    6970 </span><span class="lineCov">          6 :         endcapassemblytrans[i] = new TGeoTranslation(-fgkEndCapCoverPlateLength[0]</span>
<span class="lineNum">    6971 </span><span class="lineCov">          2 :                                                                            -  fgkEndCapSideCoverThickness</span>
<span class="lineNum">    6972 </span><span class="lineCov">          2 :                                                                            +  endcapassemblycenter[0],</span>
<span class="lineNum">    6973 </span><span class="lineCov">          2 :                                                                            -  0.5*fgkEndCapCoverPlateThickness</span>
<span class="lineNum">    6974 </span><span class="lineCov">          2 :                                                                            -  2.0*fgkEndCapCoolingTubeRadiusMax</span>
<span class="lineNum">    6975 </span><span class="lineCov">          2 :                                                                            +  2.0*endcapassemblycenter[2]</span>
<span class="lineNum">    6976 </span><span class="lineCov">          4 :                                                                            +  0.5*fgkEndCapSupportLength[i]</span>
<span class="lineNum">    6977 </span><span class="lineCov">          4 :                                                                            /  TanD(0.5*upedgeangle[i]),</span>
<span class="lineNum">    6978 </span><span class="lineCov">          4 :                                                                                   0.5*(fgkEndCapCoverPlateWidth[0]</span>
<span class="lineNum">    6979 </span><span class="lineCov">          2 :                                                                            -  fgkEndCapCoverPlateWidth[2]</span>
<span class="lineNum">    6980 </span><span class="lineCov">          2 :                                                                            - (kendcapcoverplatesmallholenumber-1)</span>
<span class="lineNum">    6981 </span><span class="lineCov">          2 :                                                                            *  fgkEndCapCoverPlateSmallHoleSeparation[2]));</span>
<span class="lineNum">    6982 </span><span class="lineCov">          1 :   TGeoRotation** endcapassemblyrot[klayernumber];</span>
<span class="lineNum">    6983 </span><span class="lineCov">          1 :   TGeoHMatrix** endcapassemblymatrix[klayernumber];</span>
<span class="lineNum">    6984 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;klayernumber; i++){</span>
<span class="lineNum">    6985 </span><span class="lineCov">          2 :    endcapassemblyrot[i] = new TGeoRotation*[kssdlayladdernumber[i]+2];</span>
<span class="lineNum">    6986 </span><span class="lineCov">          2 :    endcapassemblymatrix[i] = new TGeoHMatrix*[kssdlayladdernumber[i]+2];        </span>
<span class="lineNum">    6987 </span><span class="lineCov">        232 :    for(Int_t j=0; j&lt;kssdlayladdernumber[i]+2; j++) endcapassemblyrot[i][j] = new TGeoRotation();</span>
<span class="lineNum">    6988 </span><span class="lineCov">          2 :    endcapassemblyrot[i][0]-&gt;SetAngles(0.,-90.,0.);   </span>
<span class="lineNum">    6989 </span><span class="lineCov">          2 :    endcapassemblyrot[i][1]-&gt;SetAngles(90.,180.,-90.);        </span>
<span class="lineNum">    6990 </span><span class="lineCov">          6 :    endcapassemblymatrix[i][0] = new TGeoHMatrix((*endcapassemblyrot[i][1])*(*endcapassemblyrot[i][0]));</span>
<span class="lineNum">    6991 </span><span class="lineCov">          6 :    endcapassemblymatrix[i][1] = new TGeoHMatrix((*endcapassemblytrans[i])*(*endcapassemblymatrix[i][0]));</span>
<span class="lineNum">    6992 </span><span class="lineCov">        148 :    for(Int_t j=0; j&lt;kssdlayladdernumber[i]; j++){</span>
<span class="lineNum">    6993 </span><span class="lineCov">         72 :         endcapassemblyrot[i][j+2]-&gt;SetAngles(j*upedgeangle[i],0.,0.); </span>
<span class="lineNum">    6994 </span><span class="lineCov">        216 :         endcapassemblymatrix[i][j+2] = new TGeoHMatrix((*endcapassemblyrot[i][j+2])*(*endcapassemblymatrix[i][1]));</span>
<span class="lineNum">    6995 </span>            :    }
<span class="lineNum">    6996 </span>            :   }
<span class="lineNum">    6997 </span><span class="lineCov">          2 :   TGeoTranslation* lay6endcapassemblytrans = new TGeoTranslation(0.,0.,</span>
<span class="lineNum">    6998 </span><span class="lineCov">          1 :                                                         fgkEndCapKaptonFoilWidth-fgkEndCapSupportHighWidth);</span>
<span class="lineNum">    6999 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;2*klayernumber; i++){</span>
<span class="lineNum">    7000 </span><span class="lineCov">        296 :         for(Int_t j=0; j&lt;(i&lt;2? kssdlayladdernumber[0]:kssdlayladdernumber[1]); j++){</span>
<span class="lineNum">    7001 </span><span class="lineCov">        432 :                 fgkEndCapSupportSystem[i]-&gt;AddNode(endcapassembly[i],j+1,i&lt;2?endcapassemblymatrix[0][j+2]:</span>
<span class="lineNum">    7002 </span><span class="lineCov">         76 :                                                                                                                                            endcapassemblymatrix[1][j+2]);</span>
<span class="lineNum">    7003 </span>            :         }
<span class="lineNum">    7004 </span><span class="lineCov">         12 :         fgkEndCapSupportSystem[i]-&gt;AddNode(i&lt;2?endcapsupport[0]:endcapsupport[1],1,i&lt;2?0:lay6endcapassemblytrans);</span>
<span class="lineNum">    7005 </span>            :   }
<span class="lineNum">    7006 </span>            :    /////////////////////////////////////////////////////////////
<span class="lineNum">    7007 </span>            :   // Deallocating memory
<span class="lineNum">    7008 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7009 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;klayernumber; i++){</span>
<span class="lineNum">    7010 </span><span class="lineCov">        156 :         for(Int_t j=0; j&lt;kssdlayladdernumber[i]+2; j++){</span>
<span class="lineNum">    7011 </span><span class="lineCov">        152 :                 delete endcapassemblyrot[i][j];</span>
<span class="lineNum">    7012 </span>            :         }
<span class="lineNum">    7013 </span><span class="lineCov">          4 :         delete [] endcapassemblyrot[i];</span>
<span class="lineNum">    7014 </span><span class="lineCov">          4 :         delete endcapassemblymatrix[i][0];</span>
<span class="lineNum">    7015 </span><span class="lineCov">          4 :         delete endcapassemblymatrix[i][1];</span>
<span class="lineNum">    7016 </span>            :   }
<a name="7017"><span class="lineNum">    7017 </span>            :   /////////////////////////////////////////////////////////////</a>
<span class="lineNum">    7018 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">    7019 </span>            :   void AliITSv11GeometrySSD::EndCapSupportSystemLayer5(TGeoVolume* moth){
<span class="lineNum">    7020 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7021 </span>            :   // Setting End Cap Support + End Cap Assembly of Layer 5. 
<span class="lineNum">    7022 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7023 </span><span class="lineCov">          2 :   if (! moth) {</span>
<span class="lineNum">    7024 </span><span class="lineNoCov">          0 :     AliError(&quot;Can't insert end cap support of layer5, mother is null!\n&quot;);</span>
<span class="lineNum">    7025 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    7026 </span>            :   };
<span class="lineNum">    7027 </span><span class="lineCov">          1 :   if(!fgkEndCapSupportSystem) SetEndCapSupportAssembly();</span>
<span class="lineNum">    7028 </span>            :   TGeoTranslation* endcapsupportsystemITSCentertrans[2];
<span class="lineNum">    7029 </span><span class="lineCov">          2 :   endcapsupportsystemITSCentertrans[0] = new TGeoTranslation(0.,0.,</span>
<span class="lineNum">    7030 </span><span class="lineCov">          1 :                                                                                                 fgkEndCapSupportCenterLay5ITSPosition</span>
<span class="lineNum">    7031 </span><span class="lineCov">          1 :                                                                            +            fgkEndCapSupportCenterLay5Position</span>
<span class="lineNum">    7032 </span><span class="lineCov">          1 :                                                                            -            fgkEndCapSideCoverLength[2]);</span>
<span class="lineNum">    7033 </span><span class="lineCov">          2 :   endcapsupportsystemITSCentertrans[1] = new TGeoTranslation(0.,0.,</span>
<span class="lineNum">    7034 </span><span class="lineCov">          1 :                                                                                                 fgkEndCapSideCoverLength[2]</span>
<span class="lineNum">    7035 </span><span class="lineCov">          1 :                                                                            -        fgkEndCapSupportCenterLay5Position</span>
<span class="lineNum">    7036 </span><span class="lineCov">          1 :                                                                            -        fgkEndCapSupportCenterLay5ITSPosition);</span>
<span class="lineNum">    7037 </span><span class="lineCov">          1 :   TGeoRotation* endcapsupportsystemrot = new TGeoRotation();</span>
<span class="lineNum">    7038 </span><span class="lineCov">          1 :   endcapsupportsystemrot-&gt;SetAngles(90.,180.,-90.);</span>
<span class="lineNum">    7039 </span>            :   TGeoCombiTrans* endcapsupportsystemITSCentercombitrans = 
<span class="lineNum">    7040 </span><span class="lineCov">          1 :         new TGeoCombiTrans(*endcapsupportsystemITSCentertrans[1],*endcapsupportsystemrot);</span>
<span class="lineNum">    7041 </span><span class="lineCov">          1 :   moth-&gt;AddNode(fgkEndCapSupportSystem[0],1,endcapsupportsystemITSCentertrans[0]);</span>
<span class="lineNum">    7042 </span><span class="lineCov">          1 :   moth-&gt;AddNode(fgkEndCapSupportSystem[1],1,endcapsupportsystemITSCentercombitrans);</span>
<span class="lineNum">    7043 </span>            :    /////////////////////////////////////////////////////////////
<span class="lineNum">    7044 </span>            :   // Deallocating memory
<span class="lineNum">    7045 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7046 </span><span class="lineCov">          2 :   delete endcapsupportsystemrot;</span>
<span class="lineNum">    7047 </span><span class="lineCov">          2 :   delete endcapsupportsystemITSCentertrans[1];</span>
<a name="7048"><span class="lineNum">    7048 </span><span class="lineCov">          2 :  }</span></a>
<span class="lineNum">    7049 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7050 </span>            :   void AliITSv11GeometrySSD::EndCapSupportSystemLayer6(TGeoVolume* moth){
<span class="lineNum">    7051 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7052 </span>            :   // Setting End Cap Support + End Cap Assembly of Layer 6. 
<span class="lineNum">    7053 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7054 </span><span class="lineCov">          2 :   if (! moth) {</span>
<span class="lineNum">    7055 </span><span class="lineNoCov">          0 :     AliError(&quot;Can't insert end cap support of layer6, mother is null!\n&quot;);</span>
<span class="lineNum">    7056 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    7057 </span>            :   };
<span class="lineNum">    7058 </span><span class="lineCov">          2 :   if(!fgkEndCapSupportSystem) SetEndCapSupportAssembly();</span>
<span class="lineNum">    7059 </span>            :   TGeoTranslation* endcapsupportsystemITSCentertrans[2];
<span class="lineNum">    7060 </span><span class="lineCov">          2 :   endcapsupportsystemITSCentertrans[0] = new TGeoTranslation(0.,0.,</span>
<span class="lineNum">    7061 </span><span class="lineCov">          1 :                                                                                                 fgkEndCapSupportCenterLay6ITSPosition</span>
<span class="lineNum">    7062 </span><span class="lineCov">          1 :                                                                            +            fgkEndCapSupportCenterLay6Position</span>
<span class="lineNum">    7063 </span><span class="lineCov">          1 :                                                                            -            fgkEndCapSideCoverLength[2]);</span>
<span class="lineNum">    7064 </span><span class="lineCov">          2 :   endcapsupportsystemITSCentertrans[1] = new TGeoTranslation(0.,0.,</span>
<span class="lineNum">    7065 </span><span class="lineCov">          1 :                                                                                                 fgkEndCapSideCoverLength[2]</span>
<span class="lineNum">    7066 </span><span class="lineCov">          1 :                                                                            -        fgkEndCapSupportCenterLay6Position</span>
<span class="lineNum">    7067 </span><span class="lineCov">          1 :                                                                            -        fgkEndCapSupportCenterLay6ITSPosition);</span>
<span class="lineNum">    7068 </span><span class="lineCov">          1 :   TGeoRotation* endcapsupportsystemrot = new TGeoRotation();</span>
<span class="lineNum">    7069 </span><span class="lineCov">          1 :   endcapsupportsystemrot-&gt;SetAngles(90.,180.,-90.);</span>
<span class="lineNum">    7070 </span>            :   TGeoCombiTrans* endcapsupportsystemITSCentercombitrans = 
<span class="lineNum">    7071 </span><span class="lineCov">          1 :         new TGeoCombiTrans(*endcapsupportsystemITSCentertrans[1],*endcapsupportsystemrot);</span>
<span class="lineNum">    7072 </span><span class="lineCov">          1 :   moth-&gt;AddNode(fgkEndCapSupportSystem[2],1,endcapsupportsystemITSCentertrans[0]);</span>
<span class="lineNum">    7073 </span><span class="lineCov">          1 :   moth-&gt;AddNode(fgkEndCapSupportSystem[3],1,endcapsupportsystemITSCentercombitrans);</span>
<span class="lineNum">    7074 </span>            :    /////////////////////////////////////////////////////////////
<span class="lineNum">    7075 </span>            :   // Deallocating memory
<span class="lineNum">    7076 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7077 </span><span class="lineCov">          2 :   delete endcapsupportsystemrot;</span>
<span class="lineNum">    7078 </span><span class="lineCov">          2 :   delete endcapsupportsystemITSCentertrans[1];</span>
<a name="7079"><span class="lineNum">    7079 </span><span class="lineCov">          2 :  }</span></a>
<span class="lineNum">    7080 </span>            :  ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    7081 </span>            :  void AliITSv11GeometrySSD::LadderSupportLayer5(TGeoVolume* moth){
<span class="lineNum">    7082 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7083 </span>            :   // Setting Ladder Support of Layer 5. 
<span class="lineNum">    7084 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7085 </span><span class="lineCov">          2 :   if (! moth) {</span>
<span class="lineNum">    7086 </span><span class="lineNoCov">          0 :     AliError(&quot;Can't insert ladder lupport of layer5, mother is null!\n&quot;);</span>
<span class="lineNum">    7087 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    7088 </span>            :   };
<span class="lineNum">    7089 </span><span class="lineCov">          2 :   if(!fLay5LadderSupportRing) SetLadderSupport(100);</span>
<span class="lineNum">    7090 </span><span class="lineCov">          1 :   fMotherVol = moth;</span>
<span class="lineNum">    7091 </span><span class="lineCov">          1 :   TGeoTranslation* centerITSRingSupportLay5trans[2];</span>
<span class="lineNum">    7092 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;2; i++){</span>
<span class="lineNum">    7093 </span><span class="lineCov">          2 :         centerITSRingSupportLay5trans[i] = </span>
<span class="lineNum">    7094 </span><span class="lineCov">          2 :                 new TGeoTranslation(0.,0.,TMath::Power(-1.,i)*fgkLadderSupportRingLay5Position);</span>
<span class="lineNum">    7095 </span><span class="lineCov">          2 :     moth-&gt;AddNode(fLay5LadderSupportRing,i+1,centerITSRingSupportLay5trans[i]);</span>
<span class="lineNum">    7096 </span>            :   }
<a name="7097"><span class="lineNum">    7097 </span><span class="lineCov">          2 :  }</span></a>
<span class="lineNum">    7098 </span>            :  ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    7099 </span>            :  void AliITSv11GeometrySSD::LadderSupportLayer6(TGeoVolume* moth){
<span class="lineNum">    7100 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7101 </span>            :   // Setting Ladder Support of Layer 6. 
<span class="lineNum">    7102 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7103 </span><span class="lineCov">          2 :   if (! moth) {</span>
<span class="lineNum">    7104 </span><span class="lineNoCov">          0 :     AliError(&quot;Can't insert ladder lupport of layer6, mother is null!\n&quot;);</span>
<span class="lineNum">    7105 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    7106 </span>            :   };
<span class="lineNum">    7107 </span><span class="lineCov">          1 :   if(!fLay6LadderSupportRing) SetLadderSupport(100);</span>
<span class="lineNum">    7108 </span><span class="lineCov">          1 :   fMotherVol = moth;</span>
<span class="lineNum">    7109 </span><span class="lineCov">          1 :   TGeoTranslation* centerITSRingSupportLay6trans[2];</span>
<span class="lineNum">    7110 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;2; i++){</span>
<span class="lineNum">    7111 </span><span class="lineCov">          2 :         centerITSRingSupportLay6trans[i] = </span>
<span class="lineNum">    7112 </span><span class="lineCov">          2 :                 new TGeoTranslation(0.,0.,TMath::Power(-1.,i)*fgkLadderSupportRingLay6Position);</span>
<span class="lineNum">    7113 </span><span class="lineCov">          2 :     moth-&gt;AddNode(fLay6LadderSupportRing,i+1,centerITSRingSupportLay6trans[i]);</span>
<span class="lineNum">    7114 </span>            :   }
<a name="7115"><span class="lineNum">    7115 </span><span class="lineCov">          2 :  }</span></a>
<span class="lineNum">    7116 </span>            :  ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    7117 </span>            :  void AliITSv11GeometrySSD::SSDCone(TGeoVolume* moth){
<span class="lineNum">    7118 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7119 </span>            :   // Setting Ladder Support of Layer 6. 
<span class="lineNum">    7120 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7121 </span><span class="lineNoCov">          0 :   if (! moth) {</span>
<span class="lineNum">    7122 </span><span class="lineNoCov">          0 :     AliError(&quot;Can't insert SSD Cone, mother is null!\n&quot;);</span>
<span class="lineNum">    7123 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    7124 </span>            :   };
<span class="lineNum">    7125 </span><span class="lineNoCov">          0 :   if(!fSSDCone) SetSSDCone();</span>
<span class="lineNum">    7126 </span><span class="lineNoCov">          0 :   TGeoTranslation* ssdconetrans = new TGeoTranslation(0.,0.,0.5*fgkSSDCentralSupportLength</span>
<span class="lineNum">    7127 </span><span class="lineNoCov">          0 :                                                                 +                                         fgkSSDCentralAL3SupportLength);</span>
<span class="lineNum">    7128 </span><span class="lineNoCov">          0 :     moth-&gt;AddNode(fSSDCone,1,ssdconetrans);</span>
<a name="7129"><span class="lineNum">    7129 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    7130 </span>            :  ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    7131 </span>            :  void AliITSv11GeometrySSD::SetSSDCone(){
<span class="lineNum">    7132 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7133 </span>            :   // Method generating SSDCone 
<span class="lineNum">    7134 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7135 </span><span class="lineNoCov">          0 :   if(!fCreateMaterials) CreateMaterials();</span>
<span class="lineNum">    7136 </span><span class="lineNoCov">          0 :   fSSDCone = new TGeoVolumeAssembly(&quot;ITSssdCone&quot;);</span>
<span class="lineNum">    7137 </span><span class="lineNoCov">          0 :   Double_t ssdpconesectionradiusmax[16];</span>
<span class="lineNum">    7138 </span><span class="lineNoCov">          0 :   Double_t ssdpconesectionradiusmin[16];</span>
<span class="lineNum">    7139 </span><span class="lineNoCov">          0 :   Double_t ssdpconezsection[16];</span>
<span class="lineNum">    7140 </span>            :   TGeoPcon* ssdpconelittleholeshape[8];
<span class="lineNum">    7141 </span>            :   TGeoVolume* ssdpconelittlehole[8];
<span class="lineNum">    7142 </span><span class="lineNoCov">          0 :   ssdpconezsection[0] = (fgkSSDPConeZLength[0]-fgkSSDPConeZLength[1]);</span>
<span class="lineNum">    7143 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmin[0] = fgkSSDLowerPConeRadius;</span>
<span class="lineNum">    7144 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmax[0] = ssdpconezsection[0]*CosD(fgkSSDPConeAngle)</span>
<span class="lineNum">    7145 </span><span class="lineNoCov">          0 :                                                       / SinD(fgkSSDPConeAngle)</span>
<span class="lineNum">    7146 </span><span class="lineNoCov">          0 :                                                           + ssdpconesectionradiusmin[0];</span>
<span class="lineNum">    7147 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmin[1] = fgkSSDPConeLittleHoleRadius</span>
<span class="lineNum">    7148 </span><span class="lineNoCov">          0 :                                                           - ssdpconezsection[0]*CosD(fgkSSDPConeAngle)</span>
<span class="lineNum">    7149 </span><span class="lineNoCov">          0 :                                                           / SinD(fgkSSDPConeAngle);</span>
<span class="lineNum">    7150 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmax[1] = fgkSSDPConeLittleHoleRadius; </span>
<span class="lineNum">    7151 </span><span class="lineNoCov">          0 :   ssdpconezsection[1] = (ssdpconesectionradiusmin[1]-ssdpconesectionradiusmin[0])</span>
<span class="lineNum">    7152 </span><span class="lineNoCov">          0 :                                           * TanD(fgkSSDPConeAngle)+ssdpconezsection[0];</span>
<span class="lineNum">    7153 </span><span class="lineNoCov">          0 :   ssdpconelittleholeshape[0] = new TGeoPcon(0.,360.,2);    </span>
<span class="lineNum">    7154 </span><span class="lineNoCov">          0 :   for(Int_t i=0; i&lt;2;i++) ssdpconelittleholeshape[0]-&gt;DefineSection(i,ssdpconezsection[i],</span>
<span class="lineNum">    7155 </span><span class="lineNoCov">          0 :                                                   ssdpconesectionradiusmin[i],ssdpconesectionradiusmax[i]); </span>
<span class="lineNum">    7156 </span><span class="lineNoCov">          0 :   ssdpconelittlehole[0] = new TGeoVolume(&quot;SSDConeLittleHole1&quot;,ssdpconelittleholeshape[0],fSSDCarbonFiberMedium);</span>
<span class="lineNum">    7157 </span><span class="lineNoCov">          0 :   ssdpconelittlehole[0]-&gt;SetLineColor(4);</span>
<span class="lineNum">    7158 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7159 </span><span class="lineNoCov">          0 :   ssdpconezsection[2] = ssdpconezsection[1];  </span>
<span class="lineNum">    7160 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmin[2] = ssdpconesectionradiusmin[1];</span>
<span class="lineNum">    7161 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmax[2] = ssdpconesectionradiusmax[1];</span>
<span class="lineNum">    7162 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmin[3] = fgkSSDPConeLittleHoleRadius+fgkSSDPConeLittleHoleLength</span>
<span class="lineNum">    7163 </span><span class="lineNoCov">          0 :                                                           - ssdpconezsection[0]*CosD(fgkSSDPConeAngle)</span>
<span class="lineNum">    7164 </span><span class="lineNoCov">          0 :                                                           / SinD(fgkSSDPConeAngle);</span>
<span class="lineNum">    7165 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmax[3] = ssdpconezsection[0]*CosD(fgkSSDPConeAngle)</span>
<span class="lineNum">    7166 </span><span class="lineNoCov">          0 :                                                           / SinD(fgkSSDPConeAngle)+ssdpconesectionradiusmin[3];</span>
<span class="lineNum">    7167 </span><span class="lineNoCov">          0 :   ssdpconezsection[3] = (ssdpconesectionradiusmin[3]-ssdpconesectionradiusmin[2])</span>
<span class="lineNum">    7168 </span><span class="lineNoCov">          0 :                                           * TanD(fgkSSDPConeAngle)+ssdpconezsection[2];</span>
<span class="lineNum">    7169 </span><span class="lineNoCov">          0 :   Double_t ssdpconelittleholeangle = fgkSSDPConeLittleHoleLength/fgkSSDPConeLittleHoleRadius</span>
<span class="lineNum">    7170 </span><span class="lineNoCov">          0 :                                                                    * TMath::RadToDeg();</span>
<span class="lineNum">    7171 </span><span class="lineNoCov">          0 :   ssdpconelittleholeshape[1] = new TGeoPcon(30.+0.5*ssdpconelittleholeangle,</span>
<span class="lineNum">    7172 </span><span class="lineNoCov">          0 :                                                                                                           60.-ssdpconelittleholeangle,2);    </span>
<span class="lineNum">    7173 </span><span class="lineNoCov">          0 :   for(Int_t i=2;i&lt;4;i++) ssdpconelittleholeshape[1]-&gt;DefineSection(i-2,ssdpconezsection[i],</span>
<span class="lineNum">    7174 </span><span class="lineNoCov">          0 :                                                   ssdpconesectionradiusmin[i],ssdpconesectionradiusmax[i]); </span>
<span class="lineNum">    7175 </span><span class="lineNoCov">          0 :   ssdpconelittlehole[1] = new TGeoVolume(&quot;SSDConeLittleHole2&quot;,ssdpconelittleholeshape[1],fSSDCarbonFiberMedium);</span>
<span class="lineNum">    7176 </span><span class="lineNoCov">          0 :   ssdpconelittlehole[1]-&gt;SetLineColor(4);</span>
<span class="lineNum">    7177 </span><span class="lineNoCov">          0 :   TGeoRotation* ssdconelittleholerot[6];</span>
<span class="lineNum">    7178 </span><span class="lineNoCov">          0 :   for(Int_t i=0; i&lt;6; i++){</span>
<span class="lineNum">    7179 </span><span class="lineNoCov">          0 :         ssdconelittleholerot[i] = new TGeoRotation();</span>
<span class="lineNum">    7180 </span><span class="lineNoCov">          0 :     ssdconelittleholerot[i]-&gt;SetAngles(i*60,0.,0.);</span>
<span class="lineNum">    7181 </span>            :   }
<span class="lineNum">    7182 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7183 </span><span class="lineNoCov">          0 :   ssdpconezsection[4] = ssdpconezsection[3];  </span>
<span class="lineNum">    7184 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmin[4] = ssdpconesectionradiusmin[3];</span>
<span class="lineNum">    7185 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmax[4] = ssdpconesectionradiusmax[3];</span>
<span class="lineNum">    7186 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmin[5] = fgkSSDConeMiddleRadius-ssdpconezsection[0]</span>
<span class="lineNum">    7187 </span><span class="lineNoCov">          0 :                                                           * CosD(fgkSSDPConeAngle)</span>
<span class="lineNum">    7188 </span><span class="lineNoCov">          0 :                                                           / SinD(fgkSSDPConeAngle);</span>
<span class="lineNum">    7189 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmax[5] = fgkSSDConeMiddleRadius;</span>
<span class="lineNum">    7190 </span><span class="lineNoCov">          0 :   ssdpconezsection[5] = (ssdpconesectionradiusmin[5]-ssdpconesectionradiusmin[4])</span>
<span class="lineNum">    7191 </span><span class="lineNoCov">          0 :                                           * TanD(fgkSSDPConeAngle)+ssdpconezsection[4];</span>
<span class="lineNum">    7192 </span><span class="lineNoCov">          0 :   ssdpconelittleholeshape[2] = new TGeoPcon(0.,360.,2);</span>
<span class="lineNum">    7193 </span><span class="lineNoCov">          0 :   for(Int_t i=4; i&lt;6;i++) ssdpconelittleholeshape[2]-&gt;DefineSection(i-4,ssdpconezsection[i],</span>
<span class="lineNum">    7194 </span><span class="lineNoCov">          0 :                                                   ssdpconesectionradiusmin[i],ssdpconesectionradiusmax[i]); </span>
<span class="lineNum">    7195 </span><span class="lineNoCov">          0 :   ssdpconelittlehole[2] = new TGeoVolume(&quot;SSDConeLittleHole3&quot;,ssdpconelittleholeshape[2],fSSDCarbonFiberMedium);</span>
<span class="lineNum">    7196 </span><span class="lineNoCov">          0 :   ssdpconelittlehole[2]-&gt;SetLineColor(4);</span>
<span class="lineNum">    7197 </span>            :   ///////////////////////////////////////////////////
<span class="lineNum">    7198 </span><span class="lineNoCov">          0 :   ssdpconezsection[6] = ssdpconezsection[5];  </span>
<span class="lineNum">    7199 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmin[6] = ssdpconesectionradiusmin[5];</span>
<span class="lineNum">    7200 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmax[6] = ssdpconesectionradiusmax[5];</span>
<span class="lineNum">    7201 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmin[7] = fgkSSDConeMiddleRadius+fgkSSDPConeMiddleLength</span>
<span class="lineNum">    7202 </span><span class="lineNoCov">          0 :                                                           -ssdpconezsection[0]</span>
<span class="lineNum">    7203 </span><span class="lineNoCov">          0 :                                                           * CosD(fgkSSDPConeAngle)</span>
<span class="lineNum">    7204 </span><span class="lineNoCov">          0 :                                                           / SinD(fgkSSDPConeAngle);</span>
<span class="lineNum">    7205 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmax[7] = fgkSSDConeMiddleRadius+fgkSSDPConeMiddleLength;</span>
<span class="lineNum">    7206 </span><span class="lineNoCov">          0 :   ssdpconezsection[7] = (ssdpconesectionradiusmin[7]-ssdpconesectionradiusmin[6])</span>
<span class="lineNum">    7207 </span><span class="lineNoCov">          0 :                                           * TanD(fgkSSDPConeAngle)+ssdpconezsection[6];</span>
<span class="lineNum">    7208 </span><span class="lineNoCov">          0 :   Double_t ssdpconemiddleholeangle = fgkSSDPConeMiddleWidth/fgkSSDConeMiddleRadius</span>
<span class="lineNum">    7209 </span><span class="lineNoCov">          0 :                                                                    * TMath::RadToDeg();</span>
<span class="lineNum">    7210 </span><span class="lineNoCov">          0 :   ssdpconelittleholeshape[3] = new TGeoPcon(22.5+0.5*ssdpconemiddleholeangle,</span>
<span class="lineNum">    7211 </span><span class="lineNoCov">          0 :                                                                                                           45.-ssdpconemiddleholeangle,2);    </span>
<span class="lineNum">    7212 </span><span class="lineNoCov">          0 :   for(Int_t i=6;i&lt;8;i++) ssdpconelittleholeshape[3]-&gt;DefineSection(i-6,ssdpconezsection[i],</span>
<span class="lineNum">    7213 </span><span class="lineNoCov">          0 :                                                   ssdpconesectionradiusmin[i],ssdpconesectionradiusmax[i]); </span>
<span class="lineNum">    7214 </span><span class="lineNoCov">          0 :   ssdpconelittlehole[3] = new TGeoVolume(&quot;SSDConeLittleHole4&quot;,ssdpconelittleholeshape[3],fSSDCarbonFiberMedium);</span>
<span class="lineNum">    7215 </span><span class="lineNoCov">          0 :   ssdpconelittlehole[3]-&gt;SetLineColor(4);</span>
<span class="lineNum">    7216 </span><span class="lineNoCov">          0 :   TGeoRotation* ssdconemiddleholerot[8];</span>
<span class="lineNum">    7217 </span><span class="lineNoCov">          0 :   for(Int_t i=0; i&lt;8; i++){</span>
<span class="lineNum">    7218 </span><span class="lineNoCov">          0 :         ssdconemiddleholerot[i] = new TGeoRotation();</span>
<span class="lineNum">    7219 </span><span class="lineNoCov">          0 :     ssdconemiddleholerot[i]-&gt;SetAngles(i*45,0.,0.);</span>
<span class="lineNum">    7220 </span>            :   }
<span class="lineNum">    7221 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7222 </span><span class="lineNoCov">          0 :   ssdpconezsection[8] = ssdpconezsection[7];  </span>
<span class="lineNum">    7223 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmin[8] = ssdpconesectionradiusmin[7];</span>
<span class="lineNum">    7224 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmax[8] = ssdpconesectionradiusmax[7];</span>
<span class="lineNum">    7225 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmin[9] = fgkSSDPConeUpRadius-ssdpconezsection[0]</span>
<span class="lineNum">    7226 </span><span class="lineNoCov">          0 :                                                           * CosD(fgkSSDPConeAngle)</span>
<span class="lineNum">    7227 </span><span class="lineNoCov">          0 :                                                           / SinD(fgkSSDPConeAngle);</span>
<span class="lineNum">    7228 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmax[9] = fgkSSDPConeUpRadius;</span>
<span class="lineNum">    7229 </span><span class="lineNoCov">          0 :   ssdpconezsection[9] = (ssdpconesectionradiusmin[9]-ssdpconesectionradiusmin[8])</span>
<span class="lineNum">    7230 </span><span class="lineNoCov">          0 :                                           * TanD(fgkSSDPConeAngle)+ssdpconezsection[8];</span>
<span class="lineNum">    7231 </span><span class="lineNoCov">          0 :   ssdpconelittleholeshape[4] = new TGeoPcon(0.,360.,2);</span>
<span class="lineNum">    7232 </span><span class="lineNoCov">          0 :   for(Int_t i=8; i&lt;10;i++) ssdpconelittleholeshape[4]-&gt;DefineSection(i-8,ssdpconezsection[i],</span>
<span class="lineNum">    7233 </span><span class="lineNoCov">          0 :                                                   ssdpconesectionradiusmin[i],ssdpconesectionradiusmax[i]); </span>
<span class="lineNum">    7234 </span><span class="lineNoCov">          0 :   ssdpconelittlehole[4] = new TGeoVolume(&quot;SSDConeLittleHole5&quot;,ssdpconelittleholeshape[4],fSSDCarbonFiberMedium);</span>
<span class="lineNum">    7235 </span><span class="lineNoCov">          0 :   ssdpconelittlehole[4]-&gt;SetLineColor(4);</span>
<span class="lineNum">    7236 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7237 </span><span class="lineNoCov">          0 :   Double_t ssdconetrapezoidheight = fgkSSDPConeUpMaxRadius-fgkSSDPConeUpRadius;</span>
<span class="lineNum">    7238 </span><span class="lineNoCov">          0 :   Double_t ssdconetrapezoidbasis = fgkSSDPConeTrapezoidBasis-2.0</span>
<span class="lineNum">    7239 </span><span class="lineNoCov">          0 :                                                                  * (0.5*ssdconetrapezoidheight/TanD(fgkSSDPConeTrapezoidAngle)</span>
<span class="lineNum">    7240 </span><span class="lineNoCov">          0 :                                                                  -  0.5*ssdconetrapezoidheight/(fgkSSDPConeUpMaxRadius</span>
<span class="lineNum">    7241 </span><span class="lineNoCov">          0 :                                                                  -  0.5*ssdconetrapezoidheight)*(0.5*fgkSSDPConeTrapezoidBasis</span>
<span class="lineNum">    7242 </span><span class="lineNoCov">          0 :                                                                  -  0.5*ssdconetrapezoidheight/TanD(fgkSSDPConeTrapezoidAngle)));</span>
<span class="lineNum">    7243 </span><span class="lineNoCov">          0 :   Double_t ssdconetrapezoidsection = (2.0*TMath::Pi()*fgkSSDPConeUpMaxRadius-8.0*ssdconetrapezoidbasis)/8.;</span>
<span class="lineNum">    7244 </span><span class="lineNoCov">          0 :   Double_t ssdpconetrapezoidsectionangle = ssdconetrapezoidsection/fgkSSDPConeUpMaxRadius</span>
<span class="lineNum">    7245 </span><span class="lineNoCov">          0 :                                                                                  * TMath::RadToDeg();</span>
<span class="lineNum">    7246 </span><span class="lineNoCov">          0 :   ssdpconezsection[10] = ssdpconezsection[9];</span>
<span class="lineNum">    7247 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmin[10] = ssdpconesectionradiusmin[9];</span>
<span class="lineNum">    7248 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmax[10] = ssdpconesectionradiusmax[9];</span>
<span class="lineNum">    7249 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmin[11] = fgkSSDPConeUpMaxRadius-ssdpconezsection[0]</span>
<span class="lineNum">    7250 </span><span class="lineNoCov">          0 :                                                           * CosD(fgkSSDPConeAngle)</span>
<span class="lineNum">    7251 </span><span class="lineNoCov">          0 :                                                           / SinD(fgkSSDPConeAngle);</span>
<span class="lineNum">    7252 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmax[11] = fgkSSDPConeUpMaxRadius;</span>
<span class="lineNum">    7253 </span><span class="lineNoCov">          0 :   ssdpconezsection[11] = (ssdpconesectionradiusmin[11]-ssdpconesectionradiusmin[10])</span>
<span class="lineNum">    7254 </span><span class="lineNoCov">          0 :                                            * TanD(fgkSSDPConeAngle)+ssdpconezsection[10];</span>
<span class="lineNum">    7255 </span><span class="lineNoCov">          0 :   ssdpconelittleholeshape[5] = new TGeoPcon(90.-0.5*ssdpconetrapezoidsectionangle,</span>
<span class="lineNum">    7256 </span>            :                                                                                         ssdpconetrapezoidsectionangle,2);    
<span class="lineNum">    7257 </span><span class="lineNoCov">          0 :   for(Int_t i=10;i&lt;12;i++) ssdpconelittleholeshape[5]-&gt;DefineSection(i-10,ssdpconezsection[i],</span>
<span class="lineNum">    7258 </span><span class="lineNoCov">          0 :                                                   ssdpconesectionradiusmin[i],ssdpconesectionradiusmax[i]); </span>
<span class="lineNum">    7259 </span><span class="lineNoCov">          0 :   ssdpconelittlehole[5] = new TGeoVolume(&quot;SSDConeLittleHole6&quot;,ssdpconelittleholeshape[5],fSSDCarbonFiberMedium);</span>
<span class="lineNum">    7260 </span><span class="lineNoCov">          0 :   ssdpconelittlehole[5]-&gt;SetLineColor(4);</span>
<span class="lineNum">    7261 </span><span class="lineNoCov">          0 :   TGeoRotation* ssdconeupradiusrot[8];</span>
<span class="lineNum">    7262 </span><span class="lineNoCov">          0 :   for(Int_t i=0; i&lt;8; i++){</span>
<span class="lineNum">    7263 </span><span class="lineNoCov">          0 :         ssdconeupradiusrot[i] = new TGeoRotation();</span>
<span class="lineNum">    7264 </span><span class="lineNoCov">          0 :     ssdconeupradiusrot[i]-&gt;SetAngles(i*45,0.,0.);</span>
<span class="lineNum">    7265 </span>            :   }
<span class="lineNum">    7266 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7267 </span><span class="lineNoCov">          0 :   ssdpconezsection[12] = ssdpconezsection[11];</span>
<span class="lineNum">    7268 </span><span class="lineNoCov">          0 :   ssdpconezsection[13] = ssdpconezsection[12]+fgkSSDPConeRadiusWidth;   </span>
<span class="lineNum">    7269 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmin[12] = ssdpconesectionradiusmin[11]; </span>
<span class="lineNum">    7270 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmax[12] = fgkSSDPConeExternalRadius;</span>
<span class="lineNum">    7271 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmin[13] = ssdpconesectionradiusmin[12];</span>
<span class="lineNum">    7272 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmax[13] = fgkSSDPConeExternalRadius;</span>
<span class="lineNum">    7273 </span><span class="lineNoCov">          0 :   ssdpconelittleholeshape[6] = new TGeoPcon(0.,360.,2);</span>
<span class="lineNum">    7274 </span><span class="lineNoCov">          0 :   for(Int_t i=12; i&lt;14;i++) ssdpconelittleholeshape[6]-&gt;DefineSection(i-12,ssdpconezsection[i],</span>
<span class="lineNum">    7275 </span><span class="lineNoCov">          0 :                                                   ssdpconesectionradiusmin[i],ssdpconesectionradiusmax[i]); </span>
<span class="lineNum">    7276 </span><span class="lineNoCov">          0 :   ssdpconelittlehole[6] = new TGeoVolume(&quot;SSDConeLittleHole7&quot;,ssdpconelittleholeshape[6],fSSDCarbonFiberMedium);</span>
<span class="lineNum">    7277 </span><span class="lineNoCov">          0 :   ssdpconelittlehole[6]-&gt;SetLineColor(4);</span>
<span class="lineNum">    7278 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7279 </span><span class="lineNoCov">          0 :   ssdpconezsection[14] = 0.0;</span>
<span class="lineNum">    7280 </span><span class="lineNoCov">          0 :   ssdpconezsection[15] = ssdpconezsection[0];</span>
<span class="lineNum">    7281 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmin[14] = ssdpconesectionradiusmin[0];</span>
<span class="lineNum">    7282 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmax[14] = ssdpconesectionradiusmin[14];</span>
<span class="lineNum">    7283 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmin[15] = ssdpconesectionradiusmin[0];</span>
<span class="lineNum">    7284 </span><span class="lineNoCov">          0 :   ssdpconesectionradiusmax[15] = ssdpconesectionradiusmax[0];</span>
<span class="lineNum">    7285 </span><span class="lineNoCov">          0 :   ssdpconelittleholeshape[7] = new TGeoPcon(0.,360.,2);</span>
<span class="lineNum">    7286 </span><span class="lineNoCov">          0 :   for(Int_t i=14; i&lt;16;i++) ssdpconelittleholeshape[7]-&gt;DefineSection(i-14,ssdpconezsection[i],</span>
<span class="lineNum">    7287 </span><span class="lineNoCov">          0 :                                                   ssdpconesectionradiusmin[i],ssdpconesectionradiusmax[i]); </span>
<span class="lineNum">    7288 </span><span class="lineNoCov">          0 :   ssdpconelittlehole[7] = new TGeoVolume(&quot;SSDConeLittleHole8&quot;,ssdpconelittleholeshape[7],fSSDCarbonFiberMedium);</span>
<span class="lineNum">    7289 </span><span class="lineNoCov">          0 :   ssdpconelittlehole[7]-&gt;SetLineColor(4);</span>
<span class="lineNum">    7290 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7291 </span>            :   TGeoTube* ssdtubeconeshape[2];
<span class="lineNum">    7292 </span>            :   TGeoVolume* ssdtubecone[2];
<span class="lineNum">    7293 </span>            :   TGeoTranslation* ssdtubeconetrans[2];
<span class="lineNum">    7294 </span><span class="lineNoCov">          0 :   ssdtubeconeshape[0] = new TGeoTube(fgkSSDPConeUpMiddleRadius,</span>
<span class="lineNum">    7295 </span><span class="lineNoCov">          0 :                                                                            fgkSSDPConeExternalRadius,</span>
<span class="lineNum">    7296 </span><span class="lineNoCov">          0 :                                                                            0.5*(fgkSSDPConeLength-ssdpconezsection[13]));</span>
<span class="lineNum">    7297 </span><span class="lineNoCov">          0 :   ssdtubeconeshape[1] = new TGeoTube(fgkSSDPConeDownRadius,ssdpconesectionradiusmin[0],</span>
<span class="lineNum">    7298 </span><span class="lineNoCov">          0 :                                                                            0.5*ssdpconezsection[0]); </span>
<span class="lineNum">    7299 </span><span class="lineNoCov">          0 :   ssdtubecone[0] = new TGeoVolume(&quot;SSDConeTube1&quot;,ssdtubeconeshape[0],fSSDSupportRingAl);</span>
<span class="lineNum">    7300 </span><span class="lineNoCov">          0 :   ssdtubecone[1] = new TGeoVolume(&quot;SSDConeTube2&quot;,ssdtubeconeshape[1],fSSDSupportRingAl);</span>
<span class="lineNum">    7301 </span><span class="lineNoCov">          0 :   ssdtubeconetrans[0] = new TGeoTranslation(0.,0.,</span>
<span class="lineNum">    7302 </span><span class="lineNoCov">          0 :                                                 0.5*(fgkSSDPConeLength-ssdpconezsection[13])</span>
<span class="lineNum">    7303 </span><span class="lineNoCov">          0 :                                           + ssdpconezsection[13]);</span>
<span class="lineNum">    7304 </span><span class="lineNoCov">          0 :   ssdtubeconetrans[1] = new TGeoTranslation(0.,0.,0.5*ssdpconezsection[0]);</span>
<span class="lineNum">    7305 </span><span class="lineNoCov">          0 :   ssdtubecone[0]-&gt;SetLineColor(4);</span>
<span class="lineNum">    7306 </span><span class="lineNoCov">          0 :   ssdtubecone[1]-&gt;SetLineColor(4);</span>
<span class="lineNum">    7307 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7308 </span>            :   // Mother Volume Container
<span class="lineNum">    7309 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7310 </span><span class="lineNoCov">          0 :   Double_t ssdconemotherradiusmin[8];</span>
<span class="lineNum">    7311 </span><span class="lineNoCov">          0 :   Double_t ssdconemotherradiusmax[8];</span>
<span class="lineNum">    7312 </span><span class="lineNoCov">          0 :   Double_t ssdconemothersection[8]; </span>
<span class="lineNum">    7313 </span><span class="lineNoCov">          0 :   ssdconemotherradiusmin[0] = fgkSSDPConeDownRadius;</span>
<span class="lineNum">    7314 </span><span class="lineNoCov">          0 :   ssdconemotherradiusmax[0] = ssdpconesectionradiusmin[0];</span>
<span class="lineNum">    7315 </span><span class="lineNoCov">          0 :   ssdconemotherradiusmin[1] = fgkSSDPConeDownRadius;</span>
<span class="lineNum">    7316 </span><span class="lineNoCov">          0 :   ssdconemotherradiusmax[1] = ssdpconesectionradiusmax[0];</span>
<span class="lineNum">    7317 </span><span class="lineNoCov">          0 :   ssdconemotherradiusmin[2] = ssdpconesectionradiusmin[0];</span>
<span class="lineNum">    7318 </span><span class="lineNoCov">          0 :   ssdconemotherradiusmax[2] = ssdpconesectionradiusmax[0];</span>
<span class="lineNum">    7319 </span><span class="lineNoCov">          0 :   ssdconemotherradiusmin[3] = ssdpconesectionradiusmin[11];</span>
<span class="lineNum">    7320 </span><span class="lineNoCov">          0 :   ssdconemotherradiusmax[3] = ssdpconesectionradiusmax[11];</span>
<span class="lineNum">    7321 </span><span class="lineNoCov">          0 :   ssdconemotherradiusmin[4] = ssdpconesectionradiusmin[12];</span>
<span class="lineNum">    7322 </span><span class="lineNoCov">          0 :   ssdconemotherradiusmax[4] = ssdpconesectionradiusmax[12];</span>
<span class="lineNum">    7323 </span><span class="lineNoCov">          0 :   ssdconemotherradiusmin[5] = ssdpconesectionradiusmin[13];</span>
<span class="lineNum">    7324 </span><span class="lineNoCov">          0 :   ssdconemotherradiusmax[5] = ssdpconesectionradiusmax[13];</span>
<span class="lineNum">    7325 </span><span class="lineNoCov">          0 :   ssdconemotherradiusmin[6] = fgkSSDPConeUpMiddleRadius;</span>
<span class="lineNum">    7326 </span><span class="lineNoCov">          0 :   ssdconemotherradiusmax[6] = fgkSSDPConeExternalRadius;</span>
<span class="lineNum">    7327 </span><span class="lineNoCov">          0 :   ssdconemotherradiusmin[7] = fgkSSDPConeUpMiddleRadius;</span>
<span class="lineNum">    7328 </span><span class="lineNoCov">          0 :   ssdconemotherradiusmax[7] = fgkSSDPConeExternalRadius;</span>
<span class="lineNum">    7329 </span><span class="lineNoCov">          0 :   ssdconemothersection[0] = 0.0;</span>
<span class="lineNum">    7330 </span><span class="lineNoCov">          0 :   ssdconemothersection[1] = ssdpconezsection[0];</span>
<span class="lineNum">    7331 </span><span class="lineNoCov">          0 :   ssdconemothersection[2] = ssdpconezsection[0];</span>
<span class="lineNum">    7332 </span><span class="lineNoCov">          0 :   ssdconemothersection[3] = ssdpconezsection[11];</span>
<span class="lineNum">    7333 </span><span class="lineNoCov">          0 :   ssdconemothersection[4] = ssdpconezsection[11];</span>
<span class="lineNum">    7334 </span><span class="lineNoCov">          0 :   ssdconemothersection[5] = ssdpconezsection[13];</span>
<span class="lineNum">    7335 </span><span class="lineNoCov">          0 :   ssdconemothersection[6] = ssdpconezsection[13];</span>
<span class="lineNum">    7336 </span><span class="lineNoCov">          0 :   ssdconemothersection[7] = fgkSSDPConeLength;</span>
<span class="lineNum">    7337 </span><span class="lineNoCov">          0 :   TGeoPcon* ssdconemothershape = new TGeoPcon(0.,360,8);</span>
<span class="lineNum">    7338 </span><span class="lineNoCov">          0 :   for(Int_t i=0; i&lt;8; i++) ssdconemothershape-&gt;DefineSection(i,ssdconemothersection[i],</span>
<span class="lineNum">    7339 </span><span class="lineNoCov">          0 :                                                                         ssdconemotherradiusmin[i],ssdconemotherradiusmax[i]);</span>
<span class="lineNum">    7340 </span><span class="lineNoCov">          0 :   TGeoVolume* ssdconemother = new TGeoVolume(&quot;SSDMotherCone&quot;,ssdconemothershape,fSSDAir);</span>
<span class="lineNum">    7341 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7342 </span>            :   //Placing the Volumes into Mother 
<span class="lineNum">    7343 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7344 </span><span class="lineNoCov">          0 :   ssdconemother-&gt;AddNode(ssdpconelittlehole[0],1);</span>
<span class="lineNum">    7345 </span><span class="lineNoCov">          0 :   for(Int_t i=0; i&lt;6; i++){</span>
<span class="lineNum">    7346 </span><span class="lineNoCov">          0 :         ssdconemother-&gt;AddNode(ssdpconelittlehole[1],i+1,ssdconelittleholerot[i]);</span>
<span class="lineNum">    7347 </span>            :   }
<span class="lineNum">    7348 </span><span class="lineNoCov">          0 :   ssdconemother-&gt;AddNode(ssdpconelittlehole[2],1);</span>
<span class="lineNum">    7349 </span><span class="lineNoCov">          0 :   for(Int_t i=0; i&lt;8; i++){</span>
<span class="lineNum">    7350 </span><span class="lineNoCov">          0 :     ssdconemother-&gt;AddNode(ssdpconelittlehole[3],i+1,ssdconemiddleholerot[i]);</span>
<span class="lineNum">    7351 </span>            :   }
<span class="lineNum">    7352 </span><span class="lineNoCov">          0 :   ssdconemother-&gt;AddNode(ssdpconelittlehole[4],1);</span>
<span class="lineNum">    7353 </span><span class="lineNoCov">          0 :   for(Int_t i=0; i&lt;8; i++){</span>
<span class="lineNum">    7354 </span><span class="lineNoCov">          0 :     ssdconemother-&gt;AddNode(ssdpconelittlehole[5],i+1,ssdconeupradiusrot[i]);</span>
<span class="lineNum">    7355 </span>            :   }
<span class="lineNum">    7356 </span><span class="lineNoCov">          0 :   ssdconemother-&gt;AddNode(ssdpconelittlehole[6],1);</span>
<span class="lineNum">    7357 </span><span class="lineNoCov">          0 :   ssdconemother-&gt;AddNode(ssdpconelittlehole[7],1);</span>
<span class="lineNum">    7358 </span><span class="lineNoCov">          0 :   ssdconemother-&gt;AddNode(ssdtubecone[0],1,ssdtubeconetrans[0]);</span>
<span class="lineNum">    7359 </span><span class="lineNoCov">          0 :   ssdconemother-&gt;AddNode(ssdtubecone[1],1,ssdtubeconetrans[1]);</span>
<span class="lineNum">    7360 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7361 </span>            :   // ITS General Support
<span class="lineNum">    7362 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7363 </span><span class="lineNoCov">          0 :   TGeoTube* ssdcentralsupportshape = new TGeoTube(fgkSSDCentralSupportRadius-fgkSSDCentralSupportWidth,</span>
<span class="lineNum">    7364 </span><span class="lineNoCov">          0 :                                                                 fgkSSDCentralSupportRadius,0.5*fgkSSDCentralSupportLength); </span>
<span class="lineNum">    7365 </span><span class="lineNoCov">          0 :   TGeoVolume* ssdcentralsupport = new TGeoVolume(&quot;SSDCentralSupport&quot;,ssdcentralsupportshape,fSSDRohaCellCone);</span>
<span class="lineNum">    7366 </span><span class="lineNoCov">          0 :   TGeoTranslation* ssdcentralsupportrans = new TGeoTranslation(0.,0.,-0.5*fgkSSDCentralSupportLength</span>
<span class="lineNum">    7367 </span><span class="lineNoCov">          0 :                                                                              - fgkSSDCentralAL3SupportLength);</span>
<span class="lineNum">    7368 </span><span class="lineNoCov">          0 :   ssdcentralsupport-&gt;SetLineColor(4);</span>
<span class="lineNum">    7369 </span><span class="lineNoCov">          0 :   fSSDCone-&gt;AddNode(ssdcentralsupport,1,ssdcentralsupportrans);</span>
<span class="lineNum">    7370 </span><span class="lineNoCov">          0 :   TGeoTube* ssdcentralal3supportshape = new TGeoTube(fgkSSDCentralSupportRadius-fgkSSDCentralSupportWidth,</span>
<span class="lineNum">    7371 </span><span class="lineNoCov">          0 :                                                                 fgkSSDCentralSupportRadius,0.25*fgkSSDCentralAL3SupportLength);</span>
<span class="lineNum">    7372 </span><span class="lineNoCov">          0 :   TGeoVolume* ssdcentralal3support = new TGeoVolume(&quot;SSDCentralAl3Support&quot;,ssdcentralal3supportshape,fSSDSupportRingAl);</span>
<span class="lineNum">    7373 </span>            :   TGeoTranslation* ssdcentralal3supportrans[3]; 
<span class="lineNum">    7374 </span><span class="lineNoCov">          0 :   ssdcentralal3supportrans[0] = new TGeoTranslation(0.,0.,-0.75*fgkSSDCentralAL3SupportLength);</span>
<span class="lineNum">    7375 </span><span class="lineNoCov">          0 :   ssdcentralal3supportrans[1] = new TGeoTranslation(0.,0.,-fgkSSDCentralSupportLength</span>
<span class="lineNum">    7376 </span><span class="lineNoCov">          0 :                                                           - 1.25*fgkSSDCentralAL3SupportLength);</span>
<span class="lineNum">    7377 </span><span class="lineNoCov">          0 :   ssdcentralal3support-&gt;SetLineColor(4);</span>
<span class="lineNum">    7378 </span><span class="lineNoCov">          0 :   fSSDCone-&gt;AddNode(ssdcentralal3support,1,ssdcentralal3supportrans[0]);</span>
<span class="lineNum">    7379 </span><span class="lineNoCov">          0 :   fSSDCone-&gt;AddNode(ssdcentralal3support,2,ssdcentralal3supportrans[1]);</span>
<span class="lineNum">    7380 </span><span class="lineNoCov">          0 :   TGeoPcon* ssdpconcentralal3shape = new TGeoPcon(0.,360.,2);</span>
<span class="lineNum">    7381 </span><span class="lineNoCov">          0 :   Double_t ssdpconcentralradiusmin[2];</span>
<span class="lineNum">    7382 </span><span class="lineNoCov">          0 :   Double_t ssdpconcentralradiusmax[2];</span>
<span class="lineNum">    7383 </span><span class="lineNoCov">          0 :   Double_t ssdpconcentralsection[2];</span>
<span class="lineNum">    7384 </span><span class="lineNoCov">          0 :   ssdpconcentralradiusmin[0] = fgkSSDCentralSupportRadius-fgkSSDCentralSupportWidth;  </span>
<span class="lineNum">    7385 </span><span class="lineNoCov">          0 :   ssdpconcentralradiusmin[1] = fgkSSDCentralSupportRadius-fgkSSDCentralAL3SupportWidth;  </span>
<span class="lineNum">    7386 </span><span class="lineNoCov">          0 :   ssdpconcentralradiusmax[0] = fgkSSDCentralSupportRadius;</span>
<span class="lineNum">    7387 </span><span class="lineNoCov">          0 :   ssdpconcentralradiusmax[1] = fgkSSDCentralSupportRadius;</span>
<span class="lineNum">    7388 </span><span class="lineNoCov">          0 :   ssdpconcentralsection[0] = -0.5*fgkSSDCentralAL3SupportLength; </span>
<span class="lineNum">    7389 </span><span class="lineNoCov">          0 :   ssdpconcentralsection[1] = 0.;</span>
<span class="lineNum">    7390 </span><span class="lineNoCov">          0 :   for(Int_t i=0; i&lt;2;i++) ssdpconcentralal3shape-&gt;DefineSection(i,ssdpconcentralsection[i],</span>
<span class="lineNum">    7391 </span><span class="lineNoCov">          0 :                                                   ssdpconcentralradiusmin[i],ssdpconcentralradiusmax[i]); </span>
<span class="lineNum">    7392 </span><span class="lineNoCov">          0 :   TGeoVolume* ssdpconcentralal3 = new TGeoVolume(&quot;SSDPConeCentralAl3&quot;,ssdpconcentralal3shape,fSSDSupportRingAl);</span>
<span class="lineNum">    7393 </span><span class="lineNoCov">          0 :   ssdpconcentralal3-&gt;SetLineColor(4);</span>
<span class="lineNum">    7394 </span><span class="lineNoCov">          0 :   fSSDCone-&gt;AddNode(ssdpconcentralal3,1);</span>
<span class="lineNum">    7395 </span><span class="lineNoCov">          0 :   TGeoRotation* ssdcentralal3supportrot = new TGeoRotation();</span>
<span class="lineNum">    7396 </span><span class="lineNoCov">          0 :   ssdcentralal3supportrot-&gt;SetAngles(90.,180,-90.);</span>
<span class="lineNum">    7397 </span><span class="lineNoCov">          0 :   ssdcentralal3supportrans[2] = new TGeoTranslation(0.,0.,-fgkSSDCentralSupportLength</span>
<span class="lineNum">    7398 </span><span class="lineNoCov">          0 :                                                                 -2.*fgkSSDCentralAL3SupportLength);</span>
<span class="lineNum">    7399 </span><span class="lineNoCov">          0 :   TGeoCombiTrans* ssdcentralal3supporcombitrans = new TGeoCombiTrans(*ssdcentralal3supportrans[2],</span>
<span class="lineNum">    7400 </span>            :                                                                                                                      *ssdcentralal3supportrot);
<span class="lineNum">    7401 </span><span class="lineNoCov">          0 :   fSSDCone-&gt;AddNode(ssdpconcentralal3,2,ssdcentralal3supporcombitrans);</span>
<span class="lineNum">    7402 </span><span class="lineNoCov">          0 :   TGeoRotation* ssdconemotherot = new TGeoRotation();</span>
<span class="lineNum">    7403 </span><span class="lineNoCov">          0 :   ssdconemotherot-&gt;SetAngles(90.,180.,-90.);</span>
<span class="lineNum">    7404 </span><span class="lineNoCov">          0 :   TGeoTranslation* ssdconemothertrans = new TGeoTranslation(0.,0.,-fgkSSDCentralSupportLength</span>
<span class="lineNum">    7405 </span><span class="lineNoCov">          0 :                                                                                                                         -2.*fgkSSDCentralAL3SupportLength);</span>
<span class="lineNum">    7406 </span><span class="lineNoCov">          0 :   TGeoCombiTrans* ssdconemothercombitrans = new TGeoCombiTrans(*ssdconemothertrans,*ssdconemotherot);</span>
<span class="lineNum">    7407 </span><span class="lineNoCov">          0 :   fSSDCone-&gt;AddNode(ssdconemother,1);</span>
<span class="lineNum">    7408 </span><span class="lineNoCov">          0 :   fSSDCone-&gt;AddNode(ssdconemother,2,ssdconemothercombitrans);</span>
<span class="lineNum">    7409 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7410 </span>            :   // Deallocating memory
<span class="lineNum">    7411 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7412 </span><span class="lineNoCov">          0 :   delete ssdcentralal3supportrot;</span>
<span class="lineNum">    7413 </span><span class="lineNoCov">          0 :   delete ssdcentralal3supportrans[2];</span>
<span class="lineNum">    7414 </span><span class="lineNoCov">          0 :   delete ssdconemotherot;</span>
<span class="lineNum">    7415 </span><span class="lineNoCov">          0 :   delete ssdconemothertrans;</span>
<span class="lineNum">    7416 </span>            :   /////////////////////////////////////////////////////////////
<a name="7417"><span class="lineNum">    7417 </span><span class="lineNoCov">          0 :  }</span></a>
<span class="lineNum">    7418 </span>            :  ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    7419 </span>            :  void AliITSv11GeometrySSD::SSDCables(TGeoVolume* moth){
<span class="lineNum">    7420 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7421 </span>            :   // Setting SSD Cables
<span class="lineNum">    7422 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7423 </span><span class="lineCov">          2 :   if (! moth) {</span>
<span class="lineNum">    7424 </span><span class="lineNoCov">          0 :     AliError(&quot;Can't insert SSD Cables, mother is null!\n&quot;);</span>
<span class="lineNum">    7425 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    7426 </span>            :   };
<span class="lineNum">    7427 </span><span class="lineCov">          1 :   TGeoVolume* ssdcables = SetSSDCables();</span>
<span class="lineNum">    7428 </span><span class="lineCov">          1 :   moth-&gt;AddNode(ssdcables,1);</span>
<a name="7429"><span class="lineNum">    7429 </span><span class="lineCov">          2 : }</span></a>
<span class="lineNum">    7430 </span>            :  ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    7431 </span>            :  TGeoVolume* AliITSv11GeometrySSD::SetSSDCables(){
<span class="lineNum">    7432 </span>            :    /////////////////////////////////////////////////////////////
<span class="lineNum">    7433 </span>            :    // Method generating SSDCables
<span class="lineNum">    7434 </span>            :    /////////////////////////////////////////////////////////////
<span class="lineNum">    7435 </span>            : 
<span class="lineNum">    7436 </span>            :    /////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    7437 </span>            :    // SSD Cables Parameters (lengths are in mm and angles in degrees)
<span class="lineNum">    7438 </span>            :    /////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    7439 </span>            :    
<span class="lineNum">    7440 </span><span class="lineCov">          2 :    const Double_t kSSDCablesLay5TubeRadiusMin = 11.9*fgkmm;</span>
<span class="lineNum">    7441 </span>            :    const Double_t kSSDCablesLay6TubeRadiusMin = 11.9*fgkmm;
<span class="lineNum">    7442 </span>            :    
<span class="lineNum">    7443 </span>            :    // Cable thickness for rings at outer Z
<span class="lineNum">    7444 </span>            :    // Average: 9/2 = 4.5 cables per quadrant
<span class="lineNum">    7445 </span>            :    // Ideally 1/16 * 38(34) cables, but take factor to (1/8) to accomodate kinks and loops (there are only 2 different cable lengths); 21 mm^2 Cu each
<span class="lineNum">    7446 </span>            : 
<span class="lineNum">    7447 </span><span class="lineCov">          1 :    const Double_t kSSDCablesLay5RingArea = 21.*34./8.*fgkmm*fgkmm;  // to be fixed in order to reproduce material budget</span>
<span class="lineNum">    7448 </span><span class="lineCov">          1 :    const Double_t kSSDCablesLay6RingArea = 21.*38./8.*fgkmm*fgkmm;  // to be fixed in order to reproduce material budget</span>
<span class="lineNum">    7449 </span>            :    
<span class="lineNum">    7450 </span>            :    
<span class="lineNum">    7451 </span><span class="lineCov">          1 :    const Double_t kSSDCablesHeight = 3.2*fgkmm;  // 3.2 mm*13 cm width = 18 cables, 185g/m each Add fudge factor of 2 to get to ~25 kg measured</span>
<span class="lineNum">    7452 </span>            : 
<span class="lineNum">    7453 </span>            :    const Double_t kSSDCableAngle = 22.5;
<span class="lineNum">    7454 </span>            :    // MvL: remove water?
<span class="lineNum">    7455 </span><span class="lineCov">          1 :    const Double_t kSSDCablesLay5RightSideWaterHeight = 2.5*fgkmm;  // to be fixed in order to reproduce material budget</span>
<span class="lineNum">    7456 </span>            :    const Double_t kSSDCablesPatchPanel2RB26Angle[2] = {25.0,53.2};
<span class="lineNum">    7457 </span>            :    const Double_t kSSDCablesPatchPanel2RB24Angle[2] = {23.0,53.6};
<span class="lineNum">    7458 </span><span class="lineCov">          1 :    const Double_t kSSDPatchPanel2RB26ITSDistance = 975.0*fgkmm;</span>
<span class="lineNum">    7459 </span><span class="lineCov">          1 :    const Double_t kSSDPatchPanel2RB24ITSDistance = 1020.0*fgkmm;</span>
<span class="lineNum">    7460 </span><span class="lineCov">          1 :    const Double_t kSSDPatchPanel2RB26Radius = 451.3*fgkmm;</span>
<span class="lineNum">    7461 </span>            :    const Double_t kSSDPatchPanel2RB24Radius = 451.3*fgkmm;
<span class="lineNum">    7462 </span><span class="lineCov">          1 :    const Double_t kSSDPatchPanelHeight = 87.5*fgkmm;</span>
<span class="lineNum">    7463 </span>            :    
<span class="lineNum">    7464 </span>            :    // SSD Layer 5 Cables
<span class="lineNum">    7465 </span>            :    //////////////////////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    7466 </span><span class="lineCov">          1 :    TGeoVolumeAssembly* ssdcablesmother = new TGeoVolumeAssembly(&quot;SSDCables&quot;);</span>
<span class="lineNum">    7467 </span>            :    Double_t ssdcablelayvertical = 0.05; // Internal variables to control overlapping with SDD cables
<span class="lineNum">    7468 </span>            :    Double_t ssdcablelaylateral = 0.55;   // Internal variables to control overlapping with SDD cables
<span class="lineNum">    7469 </span>            :    //////////////////////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    7470 </span>            :   // Printf(Form(&quot;Cable ring: rad min: %g length %g thick %g&quot;, ssdcableslay5rigthsideradiusmin, ssdcablelay5rightsidelength, kSSDCablesLay5RingArea/ssdcablelay5rightsidelength));
<span class="lineNum">    7471 </span>            :   
<span class="lineNum">    7472 </span>            : 
<span class="lineNum">    7473 </span>            :   
<span class="lineNum">    7474 </span>            :   ////////////////////////////////////
<span class="lineNum">    7475 </span>            :   //  Double_t cablescapacity[20];
<span class="lineNum">    7476 </span>            :   //  cablescapacity[0] = ssdcablelay5rightubeshape-&gt;Capacity();
<span class="lineNum">    7477 </span>            :   ////////////////////////////////////
<span class="lineNum">    7478 </span>            :   //ssdcablesmother-&gt;AddNode(ssdcablelay5righttube,1,ssdcablelay5rightrans);
<span class="lineNum">    7479 </span>            :   ////////////////////////////////////
<span class="lineNum">    7480 </span>            :   // TGeoPCone Volumes
<span class="lineNum">    7481 </span>            :   ///////////////////////////////////
<span class="lineNum">    7482 </span>            :   TGeoPcon* ssdcableslay5pconshape[3];
<span class="lineNum">    7483 </span>            :   TGeoVolume* ssdcableslay5pcon[3]; 
<span class="lineNum">    7484 </span><span class="lineCov">          1 :   ssdcableslay5pconshape[0] = new TGeoPcon(0.,360.,2);   </span>
<span class="lineNum">    7485 </span><span class="lineCov">          1 :   Double_t ssdcableslay5pconzsection[6];</span>
<span class="lineNum">    7486 </span><span class="lineCov">          1 :   Double_t ssdcableslay5pconrmin[6];</span>
<span class="lineNum">    7487 </span><span class="lineCov">          1 :   Double_t ssdcableslay5pconrmax[6];</span>
<span class="lineNum">    7488 </span><span class="lineCov">          1 :   ssdcableslay5pconrmin[0] = fgkEndCapSupportMiddleRadius[0]+kSSDCablesLay5TubeRadiusMin;</span>
<span class="lineNum">    7489 </span><span class="lineCov">          1 :   ssdcableslay5pconrmin[1] = fgkSSDPConeUpRadius*(1.0+ssdcablelayvertical);</span>
<span class="lineNum">    7490 </span>            : 
<span class="lineNum">    7491 </span><span class="lineCov">          2 :   ssdcableslay5pconzsection[0] = fgkEndCapSupportCenterLay5ITSPosition</span>
<span class="lineNum">    7492 </span><span class="lineCov">          1 :                                  + fgkEndCapSupportCenterLay5Position;</span>
<span class="lineNum">    7493 </span>            :                                 //+ 2.*ssdcablelay5rightsidelength;  // removing this generates overlap with the water ring 
<span class="lineNum">    7494 </span>            :                                 // Keeping it generates overlap with the cones...
<span class="lineNum">    7495 </span>            :   // SSDCables/SSDCableLay5RightSideWaterTube_2 ovlp=0.0939792
<span class="lineNum">    7496 </span><span class="lineCov">          2 :   ssdcableslay5pconzsection[1] = 0.5*fgkSSDCentralSupportLength</span>
<span class="lineNum">    7497 </span><span class="lineCov">          1 :                                                            + fgkSSDCentralAL3SupportLength</span>
<span class="lineNum">    7498 </span><span class="lineCov">          2 :                                                            + (fgkSSDPConeUpRadius-fgkSSDLowerPConeRadius)</span>
<span class="lineNum">    7499 </span><span class="lineCov">          1 :                                                            * TanD(fgkSSDPConeAngle);      </span>
<span class="lineNum">    7500 </span><span class="lineCov">          1 :   Double_t dz = ssdcableslay5pconzsection[1]-ssdcableslay5pconzsection[0];</span>
<span class="lineNum">    7501 </span><span class="lineCov">          1 :   Double_t pconethickness = kSSDCablesLay5RingArea/TMath::Abs(dz);</span>
<span class="lineNum">    7502 </span><span class="lineCov">          1 :   ssdcableslay5pconrmax[0] = ssdcableslay5pconrmin[0]+pconethickness;</span>
<span class="lineNum">    7503 </span><span class="lineCov">          1 :   ssdcableslay5pconrmax[1] = ssdcableslay5pconrmin[1]+pconethickness;</span>
<span class="lineNum">    7504 </span>            :   //Printf(Form(&quot;pcone: r1 %g  r2 %g z1 %g z2 %g thickness %g&quot;, ssdcableslay5pconrmax[0], ssdcableslay5pconrmax[1], 
<span class="lineNum">    7505 </span>            :   //          ssdcableslay5pconzsection[0],ssdcableslay5pconzsection[1],pconethickness));
<span class="lineNum">    7506 </span>            :   
<span class="lineNum">    7507 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;2;i++) ssdcableslay5pconshape[0]-&gt;DefineSection(i,ssdcableslay5pconzsection[i],</span>
<span class="lineNum">    7508 </span><span class="lineCov">          2 :                                                   ssdcableslay5pconrmin[i],ssdcableslay5pconrmax[i]); </span>
<span class="lineNum">    7509 </span><span class="lineCov">          2 :   ssdcableslay5pcon[0] = new TGeoVolume(&quot;SSDCableLay5RightSidePCon1&quot;,</span>
<span class="lineNum">    7510 </span><span class="lineCov">          1 :                                                            ssdcableslay5pconshape[0],fSSDCopper);</span>
<span class="lineNum">    7511 </span><span class="lineCov">          1 :   ssdcableslay5pcon[0]-&gt;SetLineColor(9);</span>
<span class="lineNum">    7512 </span><span class="lineCov">          1 :   ssdcablesmother-&gt;AddNode(ssdcableslay5pcon[0],1);</span>
<span class="lineNum">    7513 </span>            : 
<span class="lineNum">    7514 </span><span class="lineCov">          1 :   Double_t totvol = ssdcableslay5pcon[0]-&gt;Capacity();</span>
<span class="lineNum">    7515 </span>            :   // Printf(Form(&quot;Cables, lay5, pCone,volume: %g&quot;, ssdcableslay5pcon[0]-&gt;Capacity()));
<span class="lineNum">    7516 </span>            : ////////////////////////////////////
<span class="lineNum">    7517 </span>            : //  cablescapacity[1] = ssdcableslay5pconshape[0]-&gt;Capacity();
<span class="lineNum">    7518 </span>            : ////////////////////////////////////
<span class="lineNum">    7519 </span>            : 
<span class="lineNum">    7520 </span>            :   //
<span class="lineNum">    7521 </span>            :   //   PCon 2 and 3 are cables going through/towards holes in supports
<span class="lineNum">    7522 </span>            :   //
<span class="lineNum">    7523 </span><span class="lineCov">          1 :   ssdcableslay5pconzsection[2] = ssdcableslay5pconzsection[1];</span>
<span class="lineNum">    7524 </span><span class="lineCov">          2 :   ssdcableslay5pconzsection[3] = 0.5*fgkSSDCentralSupportLength</span>
<span class="lineNum">    7525 </span><span class="lineCov">          1 :                                                            + fgkSSDCentralAL3SupportLength</span>
<span class="lineNum">    7526 </span><span class="lineCov">          2 :                                                            + 0.25*TanD(fgkSSDPConeAngle)*(fgkSSDPConeUpMaxRadius</span>
<span class="lineNum">    7527 </span><span class="lineCov">          1 :                                                            + 3.*fgkSSDPConeUpRadius-4.*fgkSSDLowerPConeRadius);</span>
<span class="lineNum">    7528 </span><span class="lineCov">          3 :   Double_t ssdcableangle = (fgkSSDPConeTrapezoidBasis-2.*(fgkSSDPConeUpMaxRadius</span>
<span class="lineNum">    7529 </span><span class="lineCov">          2 :                                              -  fgkSSDPConeUpRadius)/TanD(fgkSSDPConeTrapezoidAngle))</span>
<span class="lineNum">    7530 </span><span class="lineCov">          1 :                                                  /  fgkSSDPConeUpRadius*TMath::RadToDeg()*2;</span>
<span class="lineNum">    7531 </span><span class="lineCov">          1 :   ssdcableslay5pconshape[1] = new TGeoPcon(90.0-kSSDCableAngle-0.5*ssdcableangle,</span>
<span class="lineNum">    7532 </span>            :                                                                                    ssdcableangle,2);
<span class="lineNum">    7533 </span>            :   // Printf(Form(&quot;PCon2, phi %g dphi %g &quot;,90.0-kSSDCableAngle-0.5*ssdcableangle, ssdcableangle));
<span class="lineNum">    7534 </span><span class="lineCov">          1 :   ssdcableslay5pconrmin[2] = ssdcableslay5pconrmin[1];</span>
<span class="lineNum">    7535 </span><span class="lineCov">          1 :   ssdcableslay5pconrmax[2] = ssdcableslay5pconrmax[1]; </span>
<span class="lineNum">    7536 </span><span class="lineCov">          3 :   ssdcableslay5pconrmin[3] = 0.25*(fgkSSDPConeUpMaxRadius+3.*fgkSSDPConeUpRadius</span>
<span class="lineNum">    7537 </span><span class="lineCov">          2 :                                                    - 4.*fgkSSDLowerPConeRadius)+fgkSSDLowerPConeRadius;</span>
<span class="lineNum">    7538 </span><span class="lineCov">          1 :   ssdcableslay5pconrmin[3]*=(1.0+ssdcablelayvertical);</span>
<span class="lineNum">    7539 </span><span class="lineCov">          1 :   ssdcableslay5pconrmax[3] = ssdcableslay5pconrmin[3] + kSSDCablesHeight; </span>
<span class="lineNum">    7540 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;2;i++) ssdcableslay5pconshape[1]-&gt;DefineSection(i,ssdcableslay5pconzsection[i+2],</span>
<span class="lineNum">    7541 </span><span class="lineCov">          2 :                                                   ssdcableslay5pconrmin[i+2],ssdcableslay5pconrmax[i+2]); </span>
<span class="lineNum">    7542 </span><span class="lineCov">          1 :   ssdcableslay5pcon[1] = new TGeoVolume(&quot;SSDCableLay5RightSidePCon2&quot;,ssdcableslay5pconshape[1],fSSDCopper);</span>
<span class="lineNum">    7543 </span><span class="lineCov">          1 :   ssdcableslay5pcon[1]-&gt;SetLineColor(9);</span>
<span class="lineNum">    7544 </span>            :   ////////////////////////////////////
<span class="lineNum">    7545 </span><span class="lineCov">          1 :   ssdcableslay5pconshape[2] = new TGeoPcon(90.0-kSSDCableAngle-0.5*ssdcableangle,</span>
<span class="lineNum">    7546 </span>            :                                                                                    ssdcableangle,2);   
<span class="lineNum">    7547 </span><span class="lineCov">          1 :   ssdcableslay5pconrmin[4] = ssdcableslay5pconrmin[3];</span>
<span class="lineNum">    7548 </span><span class="lineCov">          1 :   ssdcableslay5pconrmax[4] = ssdcableslay5pconrmax[3];</span>
<span class="lineNum">    7549 </span><span class="lineCov">          1 :   ssdcableslay5pconrmin[5] = ssdcableslay5pconrmin[4];</span>
<span class="lineNum">    7550 </span><span class="lineCov">          1 :   ssdcableslay5pconrmax[5] = ssdcableslay5pconrmax[4];</span>
<span class="lineNum">    7551 </span><span class="lineCov">          1 :   ssdcableslay5pconzsection[4] = ssdcableslay5pconzsection[3];</span>
<span class="lineNum">    7552 </span><span class="lineCov">          2 :   ssdcableslay5pconzsection[5] = (ssdcableslay5pconrmin[5]-fgkSSDLowerPConeRadius)</span>
<span class="lineNum">    7553 </span><span class="lineCov">          1 :                                                            * TanD(fgkSSDPConeAngle)</span>
<span class="lineNum">    7554 </span><span class="lineCov">          1 :                                                            + 0.5*fgkSSDCentralSupportLength</span>
<span class="lineNum">    7555 </span><span class="lineCov">          1 :                                                            + fgkSSDCentralAL3SupportLength;</span>
<span class="lineNum">    7556 </span><span class="lineCov">          1 :   ssdcableslay5pconzsection[5]-= ssdcablelaylateral;</span>
<span class="lineNum">    7557 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;2;i++) ssdcableslay5pconshape[2]-&gt;DefineSection(i,ssdcableslay5pconzsection[i+4],</span>
<span class="lineNum">    7558 </span><span class="lineCov">          2 :                                                   ssdcableslay5pconrmin[i+4],ssdcableslay5pconrmax[i+4]); </span>
<span class="lineNum">    7559 </span><span class="lineCov">          1 :   ssdcableslay5pcon[2] = new TGeoVolume(&quot;SSDCableLay5RightSidePCon3&quot;,ssdcableslay5pconshape[2],fSSDCopper);</span>
<span class="lineNum">    7560 </span><span class="lineCov">          1 :   ssdcableslay5pcon[2]-&gt;SetLineColor(9);</span>
<span class="lineNum">    7561 </span>            : ////////////////////////////////////
<span class="lineNum">    7562 </span><span class="lineCov">          1 :   TGeoRotation* ssdcableslay5pconrot[4];        </span>
<span class="lineNum">    7563 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;4; i++){</span>
<span class="lineNum">    7564 </span><span class="lineCov">          8 :    ssdcableslay5pconrot[i] = new TGeoRotation();</span>
<span class="lineNum">    7565 </span><span class="lineCov">          4 :    ssdcableslay5pconrot[i]-&gt;SetAngles(90.0*i,0.,0.);</span>
<span class="lineNum">    7566 </span><span class="lineCov">          4 :    ssdcablesmother-&gt;AddNode(ssdcableslay5pcon[1],i+1,ssdcableslay5pconrot[i]);</span>
<span class="lineNum">    7567 </span><span class="lineCov">          4 :    ssdcablesmother-&gt;AddNode(ssdcableslay5pcon[2],i+1,ssdcableslay5pconrot[i]);       </span>
<span class="lineNum">    7568 </span>            :    // Printf(Form(&quot;Pcon2, Pcon3, vol %g %g&quot;,ssdcableslay5pcon[1]-&gt;Capacity(),ssdcableslay5pcon[2]-&gt;Capacity()));
<span class="lineNum">    7569 </span><span class="lineCov">          4 :    totvol += ssdcableslay5pcon[1]-&gt;Capacity()+ssdcableslay5pcon[2]-&gt;Capacity();</span>
<span class="lineNum">    7570 </span>            :   }
<span class="lineNum">    7571 </span>            :   ////////////////////////////////////
<span class="lineNum">    7572 </span>            :   //cablescapacity[2] = 4.0*ssdcableslay5pconshape[1]-&gt;Capacity();
<span class="lineNum">    7573 </span>            :   //cablescapacity[3] = 4.0*ssdcableslay5pconshape[2]-&gt;Capacity();
<span class="lineNum">    7574 </span>            :   ////////////////////////////////////
<span class="lineNum">    7575 </span>            :   // Positioning Left SSD Cables Part
<span class="lineNum">    7576 </span>            :   ////////////////////////////////////
<span class="lineNum">    7577 </span><span class="lineCov">          1 :   TGeoRotation* ssdcablesLay5RightPConToLeftRot = new TGeoRotation();</span>
<span class="lineNum">    7578 </span><span class="lineCov">          1 :   ssdcablesLay5RightPConToLeftRot-&gt;SetAngles(90.,180.,-90);</span>
<span class="lineNum">    7579 </span><span class="lineCov">          1 :   ssdcablesmother-&gt;AddNode(ssdcableslay5pcon[0],2,ssdcablesLay5RightPConToLeftRot);  </span>
<span class="lineNum">    7580 </span><span class="lineCov">          1 :   TGeoHMatrix* ssdcablesLay5RightPConToLeftMatrix[4];  </span>
<span class="lineNum">    7581 </span><span class="lineCov">         14 :   for(Int_t i=0; i&lt;4; i++){ ssdcablesLay5RightPConToLeftMatrix[i] = </span>
<span class="lineNum">    7582 </span><span class="lineCov">          8 :         new TGeoHMatrix((*ssdcablesLay5RightPConToLeftRot)*(*ssdcableslay5pconrot[i]));</span>
<span class="lineNum">    7583 </span><span class="lineCov">          4 :         ssdcablesmother-&gt;AddNode(ssdcableslay5pcon[1],i+5,ssdcablesLay5RightPConToLeftMatrix[i]);</span>
<span class="lineNum">    7584 </span><span class="lineCov">          4 :     ssdcablesmother-&gt;AddNode(ssdcableslay5pcon[2],i+5,ssdcablesLay5RightPConToLeftMatrix[i]);        </span>
<span class="lineNum">    7585 </span>            :   }
<span class="lineNum">    7586 </span>            :   ////////////////////////////////////
<span class="lineNum">    7587 </span>            :   //cablescapacity[4] = ssdcablelay5rightubeshape-&gt;Capacity();
<span class="lineNum">    7588 </span>            :   //cablescapacity[5] = ssdcableslay5pconshape[0]-&gt;Capacity();
<span class="lineNum">    7589 </span>            :   //cablescapacity[6] = 4.*ssdcableslay5pconshape[1]-&gt;Capacity();
<span class="lineNum">    7590 </span>            :   //cablescapacity[7] = 4.*ssdcableslay5pconshape[2]-&gt;Capacity();
<span class="lineNum">    7591 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    7592 </span>            :   // Water Tubes Layer 5
<span class="lineNum">    7593 </span>            :   /////////////////////////
<span class="lineNum">    7594 </span>            :   /*  Remove ring; could be replaced with a PCone next to/on top of the cables
<span class="lineNum">    7595 </span>            : 
<span class="lineNum">    7596 </span>            :    //
<span class="lineNum">    7597 </span>            :    // MvL: Remove ring; put everything in PCone
<span class="lineNum">    7598 </span>            :    //
<span class="lineNum">    7599 </span>            :    // Need to keep dimensions for water ring...
<span class="lineNum">    7600 </span>            : 
<span class="lineNum">    7601 </span>            :    Double_t ssdcablesfactor = 0.5;     // Internal variables to control overlapping with SDD cables
<span class="lineNum">    7602 </span>            : 
<span class="lineNum">    7603 </span>            :   Double_t ssdcableslay5rigthsideradiusmin = fgkEndCapSupportMiddleRadius[0]+kSSDCablesLay5TubeRadiusMin;  
<span class="lineNum">    7604 </span>            :   Double_t ssdcableslay5endconedistance = (ssdcableslay5rigthsideradiusmin
<span class="lineNum">    7605 </span>            :                                                                             -  fgkSSDLowerPConeRadius)
<span class="lineNum">    7606 </span>            :                                                                             * TanD(fgkSSDPConeAngle);
<span class="lineNum">    7607 </span>            :   Double_t ssdcableslay5startconedistance = fgkEndCapSupportCenterLay5ITSPosition
<span class="lineNum">    7608 </span>            :                                                                               + fgkEndCapSupportCenterLay5Position
<span class="lineNum">    7609 </span>            :                                                                               - 0.5*fgkSSDCentralSupportLength-fgkSSDCentralAL3SupportLength;
<span class="lineNum">    7610 </span>            :   Double_t ssdcablelay5rightsidelength = ssdcableslay5endconedistance
<span class="lineNum">    7611 </span>            :                                                                            - ssdcableslay5startconedistance; 
<span class="lineNum">    7612 </span>            :   ssdcablelay5rightsidelength *= ssdcablesfactor;
<span class="lineNum">    7613 </span>            :   Double_t ssdcableslay5rightsideradiusmax = ssdcableslay5rigthsideradiusmin+kSSDCablesLay5RingArea/ssdcablelay5rightsidelength; 
<span class="lineNum">    7614 </span>            : 
<span class="lineNum">    7615 </span>            : 
<span class="lineNum">    7616 </span>            :   TGeoTranslation* ssdcablelay5rightrans = 
<span class="lineNum">    7617 </span>            :                                           new TGeoTranslation(0.,0.,fgkEndCapSupportCenterLay5ITSPosition
<span class="lineNum">    7618 </span>            :                                                                     + fgkEndCapSupportCenterLay5Position
<span class="lineNum">    7619 </span>            :                                                                     + 0.5*ssdcablelay5rightsidelength);
<span class="lineNum">    7620 </span>            : 
<span class="lineNum">    7621 </span>            :   TGeoTranslation* ssdcablesLay5RightTubeToLeftrans = new TGeoTranslation(0.,0.,
<span class="lineNum">    7622 </span>            :                                                                                                         - 0.5*ssdcablelay5rightsidelength
<span class="lineNum">    7623 </span>            :                                                                                                         - fgkEndCapSupportCenterLay5Position
<span class="lineNum">    7624 </span>            :                                                                                                     - fgkEndCapSupportCenterLay5ITSPosition);
<span class="lineNum">    7625 </span>            : 
<span class="lineNum">    7626 </span>            :   TGeoTube* ssdcablelay5rightubewatershape = new TGeoTube(ssdcableslay5rightsideradiusmax,
<span class="lineNum">    7627 </span>            :                                                                                      ssdcableslay5rightsideradiusmax
<span class="lineNum">    7628 </span>            :                                                                                + kSSDCablesLay5RightSideWaterHeight,
<span class="lineNum">    7629 </span>            :                                                                                      0.5*ssdcablelay5rightsidelength); 
<span class="lineNum">    7630 </span>            :   TGeoVolume* ssdcablelay5rightwatertube = new TGeoVolume(&quot;SSDCableLay5RightSideWaterTube&quot;,
<span class="lineNum">    7631 </span>            :                                                                                                          ssdcablelay5rightubewatershape,
<span class="lineNum">    7632 </span>            :                                                                                                          fSSDCoolingTubeWater);
<span class="lineNum">    7633 </span>            :   ssdcablelay5rightwatertube-&gt;SetLineColor(7);
<span class="lineNum">    7634 </span>            :   ssdcablesmother-&gt;AddNode(ssdcablelay5rightwatertube,1,ssdcablelay5rightrans);
<span class="lineNum">    7635 </span>            :   ssdcablesmother-&gt;AddNode(ssdcablelay5rightwatertube,2,ssdcablesLay5RightTubeToLeftrans);
<span class="lineNum">    7636 </span>            :   */
<span class="lineNum">    7637 </span>            :   ////////////////////////////////////
<span class="lineNum">    7638 </span>            :   // TGeoPCone Water Volumes Layer 
<span class="lineNum">    7639 </span>            :   ///////////////////////////////////
<span class="lineNum">    7640 </span>            :   TGeoPcon* ssdcableslay5pconwatershape[3];
<span class="lineNum">    7641 </span>            :   TGeoVolume* ssdcableslay5pconwater[3]; 
<span class="lineNum">    7642 </span><span class="lineCov">          1 :   ssdcableslay5pconwatershape[0] = new TGeoPcon(0.,360.,2);   </span>
<span class="lineNum">    7643 </span><span class="lineCov">          1 :   Double_t ssdcableslay5pconwaterzsection[6];</span>
<span class="lineNum">    7644 </span><span class="lineCov">          1 :   Double_t ssdcableslay5pcwateronrmin[6];</span>
<span class="lineNum">    7645 </span><span class="lineCov">          1 :   Double_t ssdcableslay5pconwaterrmax[6];</span>
<span class="lineNum">    7646 </span><span class="lineCov">          1 :   ssdcableslay5pcwateronrmin[0] = ssdcableslay5pconrmax[0];</span>
<span class="lineNum">    7647 </span><span class="lineCov">          1 :   ssdcableslay5pconwaterrmax[0] = ssdcableslay5pcwateronrmin[0]</span>
<span class="lineNum">    7648 </span><span class="lineCov">          1 :                                                                 + kSSDCablesLay5RightSideWaterHeight;</span>
<span class="lineNum">    7649 </span><span class="lineCov">          1 :   ssdcableslay5pcwateronrmin[1] = ssdcableslay5pconrmax[1];</span>
<span class="lineNum">    7650 </span><span class="lineCov">          1 :   ssdcableslay5pconwaterrmax[1] = ssdcableslay5pcwateronrmin[1]</span>
<span class="lineNum">    7651 </span><span class="lineCov">          1 :                                                                 + kSSDCablesLay5RightSideWaterHeight;</span>
<span class="lineNum">    7652 </span><span class="lineCov">          1 :   ssdcableslay5pconwaterzsection[0] = ssdcableslay5pconzsection[0];</span>
<span class="lineNum">    7653 </span><span class="lineCov">          1 :   ssdcableslay5pconwaterzsection[1] = ssdcableslay5pconzsection[1];</span>
<span class="lineNum">    7654 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;2;i++) ssdcableslay5pconwatershape[0]-&gt;DefineSection(i,ssdcableslay5pconwaterzsection[i],</span>
<span class="lineNum">    7655 </span><span class="lineCov">          2 :                                                   ssdcableslay5pcwateronrmin[i],ssdcableslay5pconwaterrmax[i]); </span>
<span class="lineNum">    7656 </span><span class="lineCov">          2 :   ssdcableslay5pconwater[0] = new TGeoVolume(&quot;SSDCableLay5RightSidePConWater1&quot;,</span>
<span class="lineNum">    7657 </span><span class="lineCov">          1 :                                                            ssdcableslay5pconwatershape[0],fSSDCoolingTubeWater);</span>
<span class="lineNum">    7658 </span><span class="lineCov">          1 :   ssdcableslay5pconwater[0]-&gt;SetLineColor(7);</span>
<span class="lineNum">    7659 </span><span class="lineCov">          1 :   ssdcablesmother-&gt;AddNode(ssdcableslay5pconwater[0],1);</span>
<span class="lineNum">    7660 </span><span class="lineCov">          1 :   ssdcablesmother-&gt;AddNode(ssdcableslay5pconwater[0],2,ssdcablesLay5RightPConToLeftRot);</span>
<span class="lineNum">    7661 </span>            : ////////////////////////////////////
<span class="lineNum">    7662 </span><span class="lineCov">          1 :   ssdcableslay5pconwaterzsection[2] = ssdcableslay5pconzsection[2];</span>
<span class="lineNum">    7663 </span><span class="lineCov">          1 :   ssdcableslay5pconwaterzsection[3] = ssdcableslay5pconzsection[3];</span>
<span class="lineNum">    7664 </span><span class="lineCov">          1 :   ssdcableslay5pconwatershape[1] = new TGeoPcon(90.0-kSSDCableAngle-0.5*ssdcableangle,</span>
<span class="lineNum">    7665 </span>            :                                                                                                 ssdcableangle,2);   
<span class="lineNum">    7666 </span><span class="lineCov">          1 :   ssdcableslay5pcwateronrmin[2] = ssdcableslay5pconrmax[1];</span>
<span class="lineNum">    7667 </span><span class="lineCov">          1 :   ssdcableslay5pconwaterrmax[2] = ssdcableslay5pcwateronrmin[2]</span>
<span class="lineNum">    7668 </span><span class="lineCov">          1 :                                                                 + kSSDCablesLay5RightSideWaterHeight;</span>
<span class="lineNum">    7669 </span><span class="lineCov">          1 :   ssdcableslay5pcwateronrmin[3] = ssdcableslay5pconrmax[3];</span>
<span class="lineNum">    7670 </span><span class="lineCov">          1 :   ssdcableslay5pconwaterrmax[3] = ssdcableslay5pcwateronrmin[3]</span>
<span class="lineNum">    7671 </span><span class="lineCov">          1 :                                                                 + kSSDCablesLay5RightSideWaterHeight;</span>
<span class="lineNum">    7672 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;2;i++) ssdcableslay5pconwatershape[1]-&gt;DefineSection(i,ssdcableslay5pconwaterzsection[i+2],</span>
<span class="lineNum">    7673 </span><span class="lineCov">          2 :                                                   ssdcableslay5pcwateronrmin[i+2],ssdcableslay5pconwaterrmax[i+2]); </span>
<span class="lineNum">    7674 </span><span class="lineCov">          2 :   ssdcableslay5pconwater[1] = new TGeoVolume(&quot;SSDCableLay5RightSidePConWater2&quot;,</span>
<span class="lineNum">    7675 </span><span class="lineCov">          1 :                                                            ssdcableslay5pconwatershape[1],fSSDCoolingTubeWater);</span>
<span class="lineNum">    7676 </span><span class="lineCov">          1 :   ssdcableslay5pconwater[1]-&gt;SetLineColor(7);</span>
<span class="lineNum">    7677 </span>            : ////////////////////////////////////
<span class="lineNum">    7678 </span><span class="lineCov">          1 :   ssdcableslay5pconwatershape[2] = new TGeoPcon(90.0-kSSDCableAngle-0.5*ssdcableangle,</span>
<span class="lineNum">    7679 </span>            :                                                                                                 ssdcableangle,2);   
<span class="lineNum">    7680 </span><span class="lineCov">          1 :   ssdcableslay5pcwateronrmin[4] = ssdcableslay5pconrmax[3];</span>
<span class="lineNum">    7681 </span><span class="lineCov">          1 :   ssdcableslay5pconwaterrmax[4] = ssdcableslay5pcwateronrmin[4]</span>
<span class="lineNum">    7682 </span><span class="lineCov">          1 :                                                                 + kSSDCablesLay5RightSideWaterHeight;</span>
<span class="lineNum">    7683 </span><span class="lineCov">          1 :   ssdcableslay5pcwateronrmin[5] = ssdcableslay5pconrmax[4];</span>
<span class="lineNum">    7684 </span><span class="lineCov">          2 :   ssdcableslay5pconwaterrmax[5] = ssdcableslay5pcwateronrmin[4]</span>
<span class="lineNum">    7685 </span><span class="lineCov">          1 :                                                                 + kSSDCablesLay5RightSideWaterHeight;</span>
<span class="lineNum">    7686 </span><span class="lineCov">          1 :   ssdcableslay5pconwaterzsection[4] = ssdcableslay5pconzsection[4];</span>
<span class="lineNum">    7687 </span><span class="lineCov">          1 :   ssdcableslay5pconwaterzsection[5] = ssdcableslay5pconzsection[5];</span>
<span class="lineNum">    7688 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;2;i++) ssdcableslay5pconwatershape[2]-&gt;DefineSection(i,ssdcableslay5pconwaterzsection[i+4],</span>
<span class="lineNum">    7689 </span><span class="lineCov">          2 :                                                   ssdcableslay5pcwateronrmin[i+4],ssdcableslay5pconwaterrmax[i+4]); </span>
<span class="lineNum">    7690 </span><span class="lineCov">          2 :   ssdcableslay5pconwater[2] = new TGeoVolume(&quot;SSDCableLay5RightSidePConWater3&quot;,</span>
<span class="lineNum">    7691 </span><span class="lineCov">          1 :                                                            ssdcableslay5pconwatershape[2],fSSDCoolingTubeWater);</span>
<span class="lineNum">    7692 </span><span class="lineCov">          1 :   ssdcableslay5pconwater[2]-&gt;SetLineColor(7);</span>
<span class="lineNum">    7693 </span>            : ////////////////////////////////////
<span class="lineNum">    7694 </span><span class="lineCov">          1 :   TGeoRotation* ssdcableslay5pconwaterot[4];    </span>
<span class="lineNum">    7695 </span><span class="lineCov">          1 :   TGeoHMatrix* ssdcablesLay5RightPConWaterToLeftMatrix[4];  </span>
<span class="lineNum">    7696 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;4; i++){</span>
<span class="lineNum">    7697 </span><span class="lineCov">          8 :    ssdcableslay5pconwaterot[i] = new TGeoRotation();</span>
<span class="lineNum">    7698 </span><span class="lineCov">          4 :    ssdcableslay5pconwaterot[i]-&gt;SetAngles(90.0*i+45.0,0.,0.);</span>
<span class="lineNum">    7699 </span><span class="lineCov">          4 :    ssdcablesLay5RightPConWaterToLeftMatrix[i] = </span>
<span class="lineNum">    7700 </span><span class="lineCov">          8 :         new TGeoHMatrix((*ssdcablesLay5RightPConToLeftRot)*(*ssdcableslay5pconwaterot[i]));</span>
<span class="lineNum">    7701 </span><span class="lineCov">          4 :         ssdcablesmother-&gt;AddNode(ssdcableslay5pconwater[1],i+1,ssdcableslay5pconwaterot[i]);</span>
<span class="lineNum">    7702 </span><span class="lineCov">          4 :         ssdcablesmother-&gt;AddNode(ssdcableslay5pconwater[1],i+5,ssdcablesLay5RightPConWaterToLeftMatrix[i]);</span>
<span class="lineNum">    7703 </span><span class="lineCov">          4 :         ssdcablesmother-&gt;AddNode(ssdcableslay5pconwater[2],i+1,ssdcableslay5pconwaterot[i]);</span>
<span class="lineNum">    7704 </span><span class="lineCov">          4 :         ssdcablesmother-&gt;AddNode(ssdcableslay5pconwater[2],i+5,ssdcablesLay5RightPConWaterToLeftMatrix[i]);</span>
<span class="lineNum">    7705 </span>            :   }
<span class="lineNum">    7706 </span>            :   /////////////////////////
<span class="lineNum">    7707 </span>            :   // SSD Layer 6 Cables
<span class="lineNum">    7708 </span>            :   /////////////////////////
<span class="lineNum">    7709 </span><span class="lineCov">          1 :   Double_t ssdcableslay6rigthsideradiusmin = fgkEndCapSupportMiddleRadius[1]+kSSDCablesLay6TubeRadiusMin;  </span>
<span class="lineNum">    7710 </span>            :   Double_t ssdcablelay6rightsidelength = 2.; // cm  was 2.*ssdcablelay5rightsidelength;
<span class="lineNum">    7711 </span><span class="lineCov">          1 :   Double_t ssdcableslay6rightsideradiusmax = ssdcableslay6rigthsideradiusmin+kSSDCablesLay6RingArea/ssdcablelay6rightsidelength;</span>
<span class="lineNum">    7712 </span>            :   // Printf(Form(&quot;Lay 6 cables, length %g, radius %g, thickness %g&quot;, ssdcablelay6rightsidelength, ssdcableslay6rigthsideradiusmin, kSSDCablesLay6RingArea/ssdcablelay6rightsidelength));
<span class="lineNum">    7713 </span><span class="lineCov">          1 :   TGeoTube* ssdcablelay6rightubeshape = new TGeoTube(ssdcableslay6rigthsideradiusmin,</span>
<span class="lineNum">    7714 </span>            :                                                                                                 ssdcableslay6rightsideradiusmax,
<span class="lineNum">    7715 </span>            :                                                                                                 0.5*ssdcablelay6rightsidelength); 
<span class="lineNum">    7716 </span><span class="lineCov">          2 :   TGeoVolume* ssdcablelay6righttube = new TGeoVolume(&quot;SSDCableLay6RightSideTube&quot;,</span>
<span class="lineNum">    7717 </span><span class="lineCov">          1 :                                                                                                          ssdcablelay6rightubeshape,</span>
<span class="lineNum">    7718 </span><span class="lineCov">          1 :                                                                                                          fSSDCopper);</span>
<span class="lineNum">    7719 </span><span class="lineCov">          1 :   ssdcablelay6righttube-&gt;SetLineColor(9);</span>
<span class="lineNum">    7720 </span>            :   TGeoTranslation* ssdcablelay6rightrans = 
<span class="lineNum">    7721 </span><span class="lineCov">          2 :                                           new TGeoTranslation(0.,0.,fgkEndCapSupportCenterLay6ITSPosition</span>
<span class="lineNum">    7722 </span><span class="lineCov">          1 :                                                                                  +              fgkEndCapSupportCenterLay6Position</span>
<span class="lineNum">    7723 </span><span class="lineCov">          1 :                                                                                  +      0.5*ssdcablelay6rightsidelength);</span>
<span class="lineNum">    7724 </span><span class="lineCov">          2 :   TGeoTranslation* ssdcablesLay6RightTubeToLeftrans = new TGeoTranslation(0.,0.,</span>
<span class="lineNum">    7725 </span>            :                                                                                                         - 0.5*ssdcablelay6rightsidelength
<span class="lineNum">    7726 </span><span class="lineCov">          1 :                                                                                                         - fgkEndCapSupportCenterLay6Position</span>
<span class="lineNum">    7727 </span><span class="lineCov">          1 :                                                                                                     - fgkEndCapSupportCenterLay6ITSPosition);</span>
<span class="lineNum">    7728 </span><span class="lineCov">          1 :   ssdcablesmother-&gt;AddNode(ssdcablelay6righttube,1,ssdcablelay6rightrans);</span>
<span class="lineNum">    7729 </span><span class="lineCov">          1 :   ssdcablesmother-&gt;AddNode(ssdcablelay6righttube,2,ssdcablesLay6RightTubeToLeftrans);</span>
<span class="lineNum">    7730 </span>            :   // Printf(Form(&quot;Cables; ring layer 6, volume: %g&quot;,ssdcablelay6rightubeshape-&gt;Capacity()));
<span class="lineNum">    7731 </span><span class="lineCov">          1 :   totvol += ssdcablelay6rightubeshape-&gt;Capacity();</span>
<span class="lineNum">    7732 </span>            :   ////////////////////////////////////
<span class="lineNum">    7733 </span>            :   //cablescapacity[8] = 2.*ssdcablelay6rightubeshape-&gt;Capacity();
<span class="lineNum">    7734 </span>            :   ////////////////////////////////////
<span class="lineNum">    7735 </span>            :   // MvL: PCon is part of connection to patch panels;
<span class="lineNum">    7736 </span>            :   // removed since current volume is too thick; now absorbed in rings+connections
<span class="lineNum">    7737 </span>            :   /*
<span class="lineNum">    7738 </span>            :   TGeoPcon* ssdcableslay6pconshape = new TGeoPcon(90.0-kSSDCableAngle-0.5*ssdcableangle,
<span class="lineNum">    7739 </span>            :                                                                                    ssdcableangle,2);   
<span class="lineNum">    7740 </span>            :   TGeoVolume* ssdcableslay6pcon;
<span class="lineNum">    7741 </span>            :   Double_t ssdcableslay6pconrmin[2];
<span class="lineNum">    7742 </span>            :   Double_t ssdcableslay6pconrmax[2];
<span class="lineNum">    7743 </span>            :   Double_t ssdcableslay6pconzsection[2];
<span class="lineNum">    7744 </span>            :   ssdcableslay6pconrmin[0] = ssdcableslay6rigthsideradiusmin;
<span class="lineNum">    7745 </span>            :   ssdcableslay6pconrmax[0] = ssdcableslay6rightsideradiusmax;
<span class="lineNum">    7746 </span>            :   ssdcableslay6pconrmin[1] = ssdcableslay6pconrmin[0];
<span class="lineNum">    7747 </span>            :   ssdcableslay6pconrmax[1] = ssdcableslay6pconrmax[0];
<span class="lineNum">    7748 </span>            :   ssdcableslay6pconzsection[0] = fgkEndCapSupportCenterLay6ITSPosition
<span class="lineNum">    7749 </span>            :                                                            + fgkEndCapSupportCenterLay6Position
<span class="lineNum">    7750 </span>            :                                                            + ssdcablelay6rightsidelength;
<span class="lineNum">    7751 </span>            :   ssdcableslay6pconzsection[1] = ssdcableslay5pconwaterzsection[5];
<span class="lineNum">    7752 </span>            :   for(Int_t i=0; i&lt;2;i++) ssdcableslay6pconshape-&gt;DefineSection(i,ssdcableslay6pconzsection[i],
<span class="lineNum">    7753 </span>            :                                                   ssdcableslay6pconrmin[i],ssdcableslay6pconrmax[i]); 
<span class="lineNum">    7754 </span>            :   
<span class="lineNum">    7755 </span>            :   ssdcableslay6pcon = new TGeoVolume(&quot;SSDCableLay6RightSidePCon&quot;,
<span class="lineNum">    7756 </span>            :                                                            ssdcableslay6pconshape,fSSDCopper);
<span class="lineNum">    7757 </span>            :   ssdcableslay6pcon-&gt;SetLineColor(9);
<span class="lineNum">    7758 </span>            :   for(Int_t i=0; i&lt;4; i++){
<span class="lineNum">    7759 </span>            :    ssdcablesmother-&gt;AddNode(ssdcableslay6pcon,i+1,ssdcableslay5pconrot[i]);
<span class="lineNum">    7760 </span>            :    ssdcablesmother-&gt;AddNode(ssdcableslay6pcon,i+5,ssdcablesLay5RightPConToLeftMatrix[i]);
<span class="lineNum">    7761 </span>            :   }
<span class="lineNum">    7762 </span>            :   */
<span class="lineNum">    7763 </span>            :   ////////////////////////////////////
<span class="lineNum">    7764 </span>            :   //cablescapacity[9] = 8.*ssdcableslay6pconshape-&gt;Capacity();
<span class="lineNum">    7765 </span>            :   /////////////////////////
<span class="lineNum">    7766 </span>            :   // Water Tubes Layer 6
<span class="lineNum">    7767 </span>            :   /////////////////////////
<span class="lineNum">    7768 </span><span class="lineCov">          2 :   TGeoTube* ssdcablelay6righwatertubeshape = new TGeoTube(ssdcableslay6rightsideradiusmax,</span>
<span class="lineNum">    7769 </span>            :                                                                                                                   ssdcableslay6rightsideradiusmax
<span class="lineNum">    7770 </span><span class="lineCov">          1 :                                                                                    +                      kSSDCablesLay5RightSideWaterHeight,</span>
<span class="lineNum">    7771 </span>            :                                                                                                                   0.5*ssdcablelay6rightsidelength); 
<span class="lineNum">    7772 </span><span class="lineCov">          2 :   TGeoVolume* ssdcablelay6rightwatertube = new TGeoVolume(&quot;SSDCableLay6RightSideWaterTube&quot;,</span>
<span class="lineNum">    7773 </span><span class="lineCov">          1 :                                                                                                          ssdcablelay6righwatertubeshape,</span>
<span class="lineNum">    7774 </span><span class="lineCov">          1 :                                                                                                          fSSDCoolingTubeWater);</span>
<span class="lineNum">    7775 </span><span class="lineCov">          1 :   ssdcablelay6rightwatertube-&gt;SetLineColor(7);</span>
<span class="lineNum">    7776 </span><span class="lineCov">          1 :   ssdcablesmother-&gt;AddNode(ssdcablelay6rightwatertube,1,ssdcablelay6rightrans);</span>
<span class="lineNum">    7777 </span><span class="lineCov">          1 :   ssdcablesmother-&gt;AddNode(ssdcablelay6rightwatertube,2,ssdcablesLay6RightTubeToLeftrans);</span>
<span class="lineNum">    7778 </span><span class="lineCov">          1 :   TGeoPcon* ssdcableslay6waterpconshape = new TGeoPcon(90.0-kSSDCableAngle-0.5*ssdcableangle,</span>
<span class="lineNum">    7779 </span>            :                                                                                    ssdcableangle,2);   
<span class="lineNum">    7780 </span>            :   TGeoVolume* ssdcableslay6waterpcon;
<span class="lineNum">    7781 </span><span class="lineCov">          1 :   Double_t ssdcableslay6waterpconrmin[2];</span>
<span class="lineNum">    7782 </span><span class="lineCov">          1 :   Double_t ssdcableslay6waterpconrmax[2];</span>
<span class="lineNum">    7783 </span><span class="lineCov">          1 :   Double_t ssdcableslay6waterpconzsection[2];</span>
<span class="lineNum">    7784 </span><span class="lineCov">          1 :   ssdcableslay6waterpconrmin[0] = ssdcableslay6rightsideradiusmax;</span>
<span class="lineNum">    7785 </span><span class="lineCov">          1 :   ssdcableslay6waterpconrmax[0] = ssdcableslay6rightsideradiusmax</span>
<span class="lineNum">    7786 </span>            :                                                             + kSSDCablesLay5RightSideWaterHeight;
<span class="lineNum">    7787 </span><span class="lineCov">          1 :   ssdcableslay6waterpconrmin[1] = ssdcableslay6waterpconrmin[0];</span>
<span class="lineNum">    7788 </span><span class="lineCov">          1 :   ssdcableslay6waterpconrmax[1] = ssdcableslay6waterpconrmax[0];</span>
<span class="lineNum">    7789 </span><span class="lineCov">          2 :   ssdcableslay6waterpconzsection[0] = fgkEndCapSupportCenterLay6ITSPosition</span>
<span class="lineNum">    7790 </span><span class="lineCov">          1 :                                                            + fgkEndCapSupportCenterLay6Position</span>
<span class="lineNum">    7791 </span><span class="lineCov">          1 :                                                            + ssdcablelay6rightsidelength;</span>
<span class="lineNum">    7792 </span><span class="lineCov">          1 :   ssdcableslay6waterpconzsection[1] = ssdcableslay5pconwaterzsection[5];</span>
<span class="lineNum">    7793 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;2;i++) ssdcableslay6waterpconshape-&gt;DefineSection(i,ssdcableslay6waterpconzsection[i],</span>
<span class="lineNum">    7794 </span><span class="lineCov">          2 :                                                   ssdcableslay6waterpconrmin[i],ssdcableslay6waterpconrmax[i]); </span>
<span class="lineNum">    7795 </span><span class="lineCov">          2 :   ssdcableslay6waterpcon = new TGeoVolume(&quot;SSDCableLay6RightSideWaterPCon&quot;,</span>
<span class="lineNum">    7796 </span><span class="lineCov">          1 :                                                            ssdcableslay6waterpconshape,fSSDCoolingTubeWater);</span>
<span class="lineNum">    7797 </span><span class="lineCov">          1 :   ssdcableslay6waterpcon-&gt;SetLineColor(7);</span>
<span class="lineNum">    7798 </span><span class="lineCov">          1 :   TGeoRotation* ssdcableslay6pconwaterot[4];    </span>
<span class="lineNum">    7799 </span><span class="lineCov">          1 :   TGeoRotation* ssdcablesLay6RightPConToLeftRot = new TGeoRotation();</span>
<span class="lineNum">    7800 </span><span class="lineCov">          1 :   ssdcablesLay6RightPConToLeftRot-&gt;SetAngles(90.,180.,-90);</span>
<span class="lineNum">    7801 </span><span class="lineCov">          1 :   TGeoHMatrix* ssdcablesLay6RightPConToLeftMatrix[4];  </span>
<span class="lineNum">    7802 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;4; i++){</span>
<span class="lineNum">    7803 </span><span class="lineCov">          8 :    ssdcableslay6pconwaterot[i] = new TGeoRotation();</span>
<span class="lineNum">    7804 </span><span class="lineCov">          4 :    ssdcableslay6pconwaterot[i]-&gt;SetAngles(90.0*i+45.0,0.,0.);</span>
<span class="lineNum">    7805 </span><span class="lineCov">         12 :    ssdcablesLay6RightPConToLeftMatrix[i] = new TGeoHMatrix((*ssdcablesLay6RightPConToLeftRot)</span>
<span class="lineNum">    7806 </span><span class="lineCov">          4 :                                                                                  * (*ssdcableslay6pconwaterot[i]));   </span>
<span class="lineNum">    7807 </span><span class="lineCov">          4 :    ssdcablesmother-&gt;AddNode(ssdcableslay6waterpcon,i+1,ssdcableslay6pconwaterot[i]);</span>
<span class="lineNum">    7808 </span><span class="lineCov">          4 :    ssdcablesmother-&gt;AddNode(ssdcableslay6waterpcon,i+5,ssdcablesLay6RightPConToLeftMatrix[i]);</span>
<span class="lineNum">    7809 </span>            :   }
<span class="lineNum">    7810 </span>            :   ////////////////////////////////////////
<span class="lineNum">    7811 </span>            :   // From ITS Ring to Patch Panel3-RB26
<span class="lineNum">    7812 </span>            :   ////////////////////////////////////////
<span class="lineNum">    7813 </span><span class="lineCov">          1 :   Double_t ssdcablepatchpanel3BB26radiusmin[2];</span>
<span class="lineNum">    7814 </span><span class="lineCov">          1 :   Double_t ssdcablepatchpanel3BB26radiusmax[2];</span>
<span class="lineNum">    7815 </span><span class="lineCov">          1 :   Double_t ssdcablepatchpanel3RB26zsection[2];</span>
<span class="lineNum">    7816 </span><span class="lineCov">          1 :   ssdcablepatchpanel3BB26radiusmin[0] = ssdcableslay5pconrmin[3]-0.5*kSSDPatchPanelHeight;// +2.8+0.003;//Avoid small overlap with SPDshieldring;</span>
<span class="lineNum">    7817 </span><span class="lineCov">          1 :   ssdcablepatchpanel3BB26radiusmax[0] = ssdcablepatchpanel3BB26radiusmin[0]</span>
<span class="lineNum">    7818 </span><span class="lineCov">          1 :                                         + kSSDCablesHeight;</span>
<span class="lineNum">    7819 </span><span class="lineCov">          1 :   ssdcablepatchpanel3BB26radiusmin[1] = kSSDPatchPanel2RB26Radius;</span>
<span class="lineNum">    7820 </span><span class="lineCov">          1 :   ssdcablepatchpanel3BB26radiusmax[1] = ssdcablepatchpanel3BB26radiusmin[1]</span>
<span class="lineNum">    7821 </span><span class="lineCov">          1 :                                         + kSSDCablesHeight;</span>
<span class="lineNum">    7822 </span><span class="lineCov">          2 :   ssdcablepatchpanel3RB26zsection[0] = 0.5*fgkSSDCentralSupportLength</span>
<span class="lineNum">    7823 </span><span class="lineCov">          1 :                                         + fgkSSDCentralAL3SupportLength</span>
<span class="lineNum">    7824 </span><span class="lineCov">          1 :                                                                                  + fgkSSDPConeZLength[0];</span>
<span class="lineNum">    7825 </span><span class="lineCov">          1 :   ssdcablepatchpanel3RB26zsection[1] = kSSDPatchPanel2RB26ITSDistance;  </span>
<span class="lineNum">    7826 </span>            :   // Printf(Form(&quot;RB26 cable length %g&quot;,ssdcablepatchpanel3RB26zsection[1]-ssdcablepatchpanel3RB26zsection[0]));
<span class="lineNum">    7827 </span>            :   // Printf(Form(&quot;Angular range %g&quot;,ssdcableangle));
<span class="lineNum">    7828 </span>            : 
<span class="lineNum">    7829 </span>            :   TGeoPcon* ssdcablepatchpanel3RB26pconshape = 
<span class="lineNum">    7830 </span><span class="lineCov">          2 :                                                                 new TGeoPcon(90.0-kSSDCablesPatchPanel2RB26Angle[0]</span>
<span class="lineNum">    7831 </span><span class="lineCov">          1 :                                                                                                 - 0.5*ssdcableangle,ssdcableangle,2);   </span>
<span class="lineNum">    7832 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;2;i++) ssdcablepatchpanel3RB26pconshape-&gt;DefineSection(i,ssdcablepatchpanel3RB26zsection[i],</span>
<span class="lineNum">    7833 </span><span class="lineCov">          2 :                                                   ssdcablepatchpanel3BB26radiusmin[i],ssdcablepatchpanel3BB26radiusmax[i]); </span>
<span class="lineNum">    7834 </span><span class="lineCov">          2 :   TGeoVolume* ssdcablepatchpanel3RB26pcon = new TGeoVolume(&quot;SSDCablePatchPanel3RB26&quot;,</span>
<span class="lineNum">    7835 </span><span class="lineCov">          1 :                                                                                                 ssdcablepatchpanel3RB26pconshape,fSSDCopper);</span>
<span class="lineNum">    7836 </span><span class="lineCov">          1 :   ssdcablepatchpanel3RB26pcon-&gt;SetLineColor(9);</span>
<span class="lineNum">    7837 </span><span class="lineCov">          1 :   TGeoRotation* ssdcablepatchpanel3B26rot[4];</span>
<span class="lineNum">    7838 </span><span class="lineCov">         14 :   for(Int_t i=0; i&lt;4; i++) ssdcablepatchpanel3B26rot[i] = new TGeoRotation();</span>
<span class="lineNum">    7839 </span><span class="lineCov">          1 :   ssdcablepatchpanel3B26rot[0]-&gt;SetAngles(0.0,0.0,0.0);</span>
<span class="lineNum">    7840 </span><span class="lineCov">          1 :   ssdcablepatchpanel3B26rot[1]-&gt;SetAngles(kSSDCablesPatchPanel2RB26Angle[0]</span>
<span class="lineNum">    7841 </span>            :                                           + kSSDCablesPatchPanel2RB26Angle[1]+6.0,0.0,0.0);
<span class="lineNum">    7842 </span><span class="lineCov">          1 :   ssdcablepatchpanel3B26rot[2]-&gt;SetAngles(180.0,0.0,0.0);</span>
<span class="lineNum">    7843 </span><span class="lineCov">          1 :   ssdcablepatchpanel3B26rot[3]-&gt;SetAngles(180.0 + kSSDCablesPatchPanel2RB26Angle[0]</span>
<span class="lineNum">    7844 </span>            :                                                 + kSSDCablesPatchPanel2RB26Angle[1]+6.0,0.0,0.0);
<span class="lineNum">    7845 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;4; i++) ssdcablesmother-&gt;AddNode(ssdcablepatchpanel3RB26pcon,i+1,ssdcablepatchpanel3B26rot[i]);</span>
<span class="lineNum">    7846 </span>            :   // Printf(Form(&quot;Cable to patch panels RB26 volume: %g (x4)&quot;,ssdcablepatchpanel3RB26pcon-&gt;Capacity()));
<span class="lineNum">    7847 </span>            :   ////////////////////////////////////
<span class="lineNum">    7848 </span>            :   //cablescapacity[10] = 4.*ssdcablepatchpanel3RB26pconshape-&gt;Capacity();
<span class="lineNum">    7849 </span>            :   ////////////////////////////////////////
<span class="lineNum">    7850 </span>            :   //  ITS Ring Cables RB26 Part
<span class="lineNum">    7851 </span>            :   ////////////////////////////////////////
<span class="lineNum">    7852 </span><span class="lineCov">          1 :   Double_t ssdcableitsring3BB26pconzsection[2];</span>
<span class="lineNum">    7853 </span><span class="lineCov">          1 :   Double_t ssdcableitsring3BB26pconrmin[2];</span>
<span class="lineNum">    7854 </span><span class="lineCov">          1 :   Double_t ssdcableitsring3BB26pconrmax[2];</span>
<span class="lineNum">    7855 </span><span class="lineCov">          2 :   ssdcableitsring3BB26pconzsection[0] = 0.5*fgkSSDCentralSupportLength</span>
<span class="lineNum">    7856 </span><span class="lineCov">          1 :                                                                           + fgkSSDCentralAL3SupportLength</span>
<span class="lineNum">    7857 </span><span class="lineCov">          1 :                                                                           + (4.0/5.0)*fgkSSDPConeZLength[0];</span>
<span class="lineNum">    7858 </span><span class="lineCov">          1 :   ssdcableitsring3BB26pconzsection[1] = ssdcablepatchpanel3RB26zsection[0];</span>
<span class="lineNum">    7859 </span><span class="lineCov">          1 :   ssdcableitsring3BB26pconrmin[0] = fgkSSDPConeUpRadius-0.5*kSSDPatchPanelHeight;</span>
<span class="lineNum">    7860 </span><span class="lineCov">          1 :   ssdcableitsring3BB26pconrmax[0] = ssdcableitsring3BB26pconrmin[0] + 2.5*kSSDCablesHeight; // widths of cable bunch is about half of patch panels; need factor 2.5</span>
<span class="lineNum">    7861 </span>            : 
<span class="lineNum">    7862 </span><span class="lineCov">          1 :   ssdcableitsring3BB26pconrmin[1] = ssdcablepatchpanel3BB26radiusmin[0];</span>
<span class="lineNum">    7863 </span><span class="lineCov">          1 :   ssdcableitsring3BB26pconrmax[1] = ssdcablepatchpanel3BB26radiusmax[0];</span>
<span class="lineNum">    7864 </span><span class="lineCov">          1 :   TGeoPcon* ssdcableitsring3BB26pconshape[4];</span>
<span class="lineNum">    7865 </span><span class="lineCov">          3 :   ssdcableitsring3BB26pconshape[0] = new TGeoPcon(90.0 - kSSDCablesPatchPanel2RB26Angle[0]</span>
<span class="lineNum">    7866 </span>            :                                                                    -              0.5*ssdcableangle,ssdcableangle
<span class="lineNum">    7867 </span><span class="lineCov">          1 :                                                                    +                            (kSSDCablesPatchPanel2RB26Angle[0]</span>
<span class="lineNum">    7868 </span>            :                                                                    -                             kSSDCableAngle),2);
<span class="lineNum">    7869 </span><span class="lineCov">          3 :   ssdcableitsring3BB26pconshape[1] = new TGeoPcon(90.0 + kSSDCablesPatchPanel2RB26Angle[1]</span>
<span class="lineNum">    7870 </span><span class="lineCov">          1 :                                                                    -              0.5*ssdcableangle,ssdcableangle</span>
<span class="lineNum">    7871 </span><span class="lineCov">          1 :                                                                    +                      3.0*kSSDCableAngle</span>
<span class="lineNum">    7872 </span><span class="lineCov">          1 :                                                                    -                      kSSDCablesPatchPanel2RB26Angle[1],2);</span>
<span class="lineNum">    7873 </span><span class="lineCov">          3 :   ssdcableitsring3BB26pconshape[2] = new TGeoPcon(270-kSSDCablesPatchPanel2RB26Angle[0]</span>
<span class="lineNum">    7874 </span><span class="lineCov">          1 :                                                                    -              0.5*ssdcableangle,ssdcableangle</span>
<span class="lineNum">    7875 </span><span class="lineCov">          1 :                                                                    -                      kSSDCableAngle</span>
<span class="lineNum">    7876 </span><span class="lineCov">          1 :                                                                    +                      kSSDCablesPatchPanel2RB26Angle[0],2);</span>
<span class="lineNum">    7877 </span><span class="lineCov">          3 :   ssdcableitsring3BB26pconshape[3] = new TGeoPcon(270.0+kSSDCablesPatchPanel2RB26Angle[1]</span>
<span class="lineNum">    7878 </span><span class="lineCov">          1 :                                                                    -              0.5*ssdcableangle,ssdcableangle</span>
<span class="lineNum">    7879 </span>            :                                                                    +                      3.0*kSSDCableAngle
<span class="lineNum">    7880 </span>            :                                                                    -                      kSSDCablesPatchPanel2RB26Angle[1],2);
<span class="lineNum">    7881 </span><span class="lineCov">         10 :   for(Int_t i=0;i&lt;4;i++)</span>
<span class="lineNum">    7882 </span><span class="lineCov">         32 :         for(Int_t j=0; j&lt;2; j++) ssdcableitsring3BB26pconshape[i]-&gt;DefineSection(j,ssdcableitsring3BB26pconzsection[j],</span>
<span class="lineNum">    7883 </span><span class="lineCov">          8 :                                                          ssdcableitsring3BB26pconrmin[j],</span>
<span class="lineNum">    7884 </span><span class="lineCov">          8 :                                                          ssdcableitsring3BB26pconrmax[j]); </span>
<span class="lineNum">    7885 </span><span class="lineCov">          1 :   TGeoVolume* ssdcableitsring3BB26pcon[4];</span>
<span class="lineNum">    7886 </span><span class="lineCov">          3 :   ssdcableitsring3BB26pcon[0] = new TGeoVolume(&quot;SSDCableITSRing3RB26Part1&quot;,</span>
<span class="lineNum">    7887 </span><span class="lineCov">          1 :                                                                                                 ssdcableitsring3BB26pconshape[0],fSSDCopper);</span>
<span class="lineNum">    7888 </span><span class="lineCov">          3 :   ssdcableitsring3BB26pcon[1] = new TGeoVolume(&quot;SSDCableITSRing3RB26Part2&quot;,</span>
<span class="lineNum">    7889 </span><span class="lineCov">          1 :                                                                                                 ssdcableitsring3BB26pconshape[1],fSSDCopper);</span>
<span class="lineNum">    7890 </span><span class="lineCov">          3 :   ssdcableitsring3BB26pcon[2] = new TGeoVolume(&quot;SSDCableITSRing3RB26Part3&quot;,</span>
<span class="lineNum">    7891 </span><span class="lineCov">          1 :                                                                                                 ssdcableitsring3BB26pconshape[2],fSSDCopper);</span>
<span class="lineNum">    7892 </span><span class="lineCov">          3 :   ssdcableitsring3BB26pcon[3] = new TGeoVolume(&quot;SSDCableITSRing3RB26Part4&quot;,</span>
<span class="lineNum">    7893 </span><span class="lineCov">          1 :                                                                                                 ssdcableitsring3BB26pconshape[3],fSSDCopper);</span>
<span class="lineNum">    7894 </span><span class="lineCov">         10 :   for(Int_t i=0;i&lt;4;i++){</span>
<span class="lineNum">    7895 </span><span class="lineCov">          4 :         ssdcableitsring3BB26pcon[i]-&gt;SetLineColor(9);</span>
<span class="lineNum">    7896 </span><span class="lineCov">          4 :         ssdcablesmother-&gt;AddNode(ssdcableitsring3BB26pcon[i],1);</span>
<span class="lineNum">    7897 </span>            :         //Printf(Form(&quot;Cable to patch panels RB26 volume part 2: %g (%d)&quot;,ssdcableitsring3BB26pcon[i]-&gt;Capacity(),i));
<span class="lineNum">    7898 </span>            : }
<span class="lineNum">    7899 </span>            : 
<span class="lineNum">    7900 </span>            :   ////////////////////////////////////
<span class="lineNum">    7901 </span>            :   //cablescapacity[11] = ssdcableitsring3BB26pconshape[0]-&gt;Capacity()
<span class="lineNum">    7902 </span>            :   //                             + ssdcableitsring3BB26pconshape[1]-&gt;Capacity() 
<span class="lineNum">    7903 </span>            :   //                             + ssdcableitsring3BB26pconshape[2]-&gt;Capacity() 
<span class="lineNum">    7904 </span>            :   //                             + ssdcableitsring3BB26pconshape[3]-&gt;Capacity(); 
<span class="lineNum">    7905 </span>            :   ////////////////////////////////////////
<span class="lineNum">    7906 </span>            :   // From ITS Ring to Patch Panel2-RB24
<span class="lineNum">    7907 </span>            :   ////////////////////////////////////////
<span class="lineNum">    7908 </span><span class="lineCov">          1 :   Double_t ssdcablepatchpanel3BB24radiusmin[2];</span>
<span class="lineNum">    7909 </span><span class="lineCov">          1 :   Double_t ssdcablepatchpanel3BB24radiusmax[2];</span>
<span class="lineNum">    7910 </span><span class="lineCov">          1 :   Double_t ssdcablepatchpanel3RB24zsection[2];</span>
<span class="lineNum">    7911 </span><span class="lineCov">          1 :   ssdcablepatchpanel3BB24radiusmin[0] = ssdcablepatchpanel3BB26radiusmin[0];</span>
<span class="lineNum">    7912 </span><span class="lineCov">          1 :   ssdcablepatchpanel3BB24radiusmax[0] = ssdcablepatchpanel3BB26radiusmax[0];</span>
<span class="lineNum">    7913 </span><span class="lineCov">          1 :   ssdcablepatchpanel3BB24radiusmin[1] = kSSDPatchPanel2RB24Radius;</span>
<span class="lineNum">    7914 </span><span class="lineCov">          1 :   ssdcablepatchpanel3BB24radiusmax[1] = ssdcablepatchpanel3BB24radiusmin[1]</span>
<span class="lineNum">    7915 </span>            :                                         + kSSDCablesHeight;
<span class="lineNum">    7916 </span><span class="lineCov">          2 :   ssdcablepatchpanel3RB24zsection[0] = -0.5*fgkSSDCentralSupportLength</span>
<span class="lineNum">    7917 </span><span class="lineCov">          1 :                                                                          -  fgkSSDCentralAL3SupportLength</span>
<span class="lineNum">    7918 </span><span class="lineCov">          1 :                                                                          -  fgkSSDPConeZLength[0];</span>
<span class="lineNum">    7919 </span><span class="lineCov">          1 :   ssdcablepatchpanel3RB24zsection[1] = -kSSDPatchPanel2RB24ITSDistance;  </span>
<span class="lineNum">    7920 </span>            :   //Printf(Form(&quot;RB24 cable length %g&quot;,ssdcablepatchpanel3RB24zsection[1]-ssdcablepatchpanel3RB24zsection[0]));
<span class="lineNum">    7921 </span>            :   TGeoPcon* ssdcablepatchpanel3RB24pconshape = 
<span class="lineNum">    7922 </span><span class="lineCov">          2 :                                                                 new TGeoPcon(90.0-kSSDCablesPatchPanel2RB24Angle[1]</span>
<span class="lineNum">    7923 </span><span class="lineCov">          1 :                                                                                                 - 0.5*ssdcableangle,ssdcableangle,2);   </span>
<span class="lineNum">    7924 </span><span class="lineCov">          8 :   for(Int_t i=0; i&lt;2;i++) ssdcablepatchpanel3RB24pconshape-&gt;DefineSection(i,ssdcablepatchpanel3RB24zsection[i],</span>
<span class="lineNum">    7925 </span><span class="lineCov">          2 :                                                   ssdcablepatchpanel3BB24radiusmin[i],ssdcablepatchpanel3BB24radiusmax[i]); </span>
<span class="lineNum">    7926 </span><span class="lineCov">          2 :   TGeoVolume* ssdcablepatchpanel3RB24pcon = new TGeoVolume(&quot;SSDCablePatchPanel3RB24&quot;,</span>
<span class="lineNum">    7927 </span><span class="lineCov">          1 :                                                                                                 ssdcablepatchpanel3RB24pconshape,</span>
<span class="lineNum">    7928 </span><span class="lineCov">          1 :                                                                                                 fSSDCopper);</span>
<span class="lineNum">    7929 </span><span class="lineCov">          1 :   ssdcablepatchpanel3RB24pcon-&gt;SetLineColor(9);</span>
<span class="lineNum">    7930 </span><span class="lineCov">          1 :   TGeoRotation* ssdcablepatchpanel3B24rot[4];</span>
<span class="lineNum">    7931 </span><span class="lineCov">         14 :   for(Int_t i=0; i&lt;4; i++) ssdcablepatchpanel3B24rot[i] = new TGeoRotation();</span>
<span class="lineNum">    7932 </span><span class="lineCov">          1 :   ssdcablepatchpanel3B24rot[0]-&gt;SetAngles(-6.0,0.0,0.0);</span>
<span class="lineNum">    7933 </span><span class="lineCov">          1 :   ssdcablepatchpanel3B24rot[1]-&gt;SetAngles(kSSDCablesPatchPanel2RB24Angle[0]</span>
<span class="lineNum">    7934 </span>            :                                           + kSSDCablesPatchPanel2RB24Angle[1],0.0,0.0);
<span class="lineNum">    7935 </span><span class="lineCov">          1 :   ssdcablepatchpanel3B24rot[2]-&gt;SetAngles(174.0,0.0,0.0);</span>
<span class="lineNum">    7936 </span><span class="lineCov">          1 :   ssdcablepatchpanel3B24rot[3]-&gt;SetAngles(180.0+kSSDCablesPatchPanel2RB24Angle[0]</span>
<span class="lineNum">    7937 </span>            :                                           + kSSDCablesPatchPanel2RB24Angle[1],0.0,0.0);
<span class="lineNum">    7938 </span><span class="lineCov">         10 :   for(Int_t i=0; i&lt;4; i++) ssdcablesmother-&gt;AddNode(ssdcablepatchpanel3RB24pcon,i+1,ssdcablepatchpanel3B24rot[i]);</span>
<span class="lineNum">    7939 </span>            :   //Printf(Form(&quot;Cable to patch panels RB24 volume: %g (x4)&quot;,ssdcablepatchpanel3RB24pcon-&gt;Capacity()));
<span class="lineNum">    7940 </span>            :   ////////////////////////////////////
<span class="lineNum">    7941 </span>            :   //cablescapacity[12] = 4.*ssdcablepatchpanel3RB24pconshape-&gt;Capacity();
<span class="lineNum">    7942 </span>            :   ////////////////////////////////////////
<span class="lineNum">    7943 </span>            :   //  ITS Ring Cables RB24 Part
<span class="lineNum">    7944 </span>            :   ////////////////////////////////////////
<span class="lineNum">    7945 </span><span class="lineCov">          1 :   Double_t ssdcableitsring3BB24pconzsection[2];</span>
<span class="lineNum">    7946 </span><span class="lineCov">          1 :   Double_t ssdcableitsring3BB24pconrmin[2];</span>
<span class="lineNum">    7947 </span><span class="lineCov">          1 :   Double_t ssdcableitsring3BB24pconrmax[2];</span>
<span class="lineNum">    7948 </span><span class="lineCov">          1 :   ssdcableitsring3BB24pconzsection[0] = -ssdcableitsring3BB26pconzsection[0];</span>
<span class="lineNum">    7949 </span><span class="lineCov">          1 :   ssdcableitsring3BB24pconzsection[1] = ssdcablepatchpanel3RB24zsection[0];</span>
<span class="lineNum">    7950 </span><span class="lineCov">          1 :   ssdcableitsring3BB24pconrmin[0] = fgkSSDPConeUpRadius-0.5*kSSDPatchPanelHeight;</span>
<span class="lineNum">    7951 </span><span class="lineCov">          1 :   ssdcableitsring3BB24pconrmax[0] = ssdcableitsring3BB24pconrmin[0] + 2.5*kSSDCablesHeight;  // Cable bunch width smaller; make it thicker</span>
<span class="lineNum">    7952 </span>            : 
<span class="lineNum">    7953 </span><span class="lineCov">          1 :   ssdcableitsring3BB24pconrmin[1] = ssdcablepatchpanel3BB24radiusmin[0];</span>
<span class="lineNum">    7954 </span><span class="lineCov">          1 :   ssdcableitsring3BB24pconrmax[1] = ssdcablepatchpanel3BB24radiusmax[0];</span>
<span class="lineNum">    7955 </span><span class="lineCov">          1 :   TGeoPcon* ssdcableitsring3BB24pconshape[4];</span>
<span class="lineNum">    7956 </span><span class="lineCov">          3 :   ssdcableitsring3BB24pconshape[0] = new TGeoPcon(kSSDCableAngle-0.5*ssdcableangle,ssdcableangle</span>
<span class="lineNum">    7957 </span><span class="lineCov">          1 :                                                                + (90.0-kSSDCablesPatchPanel2RB24Angle[1]</span>
<span class="lineNum">    7958 </span>            :                                                                    - kSSDCableAngle),2);
<span class="lineNum">    7959 </span><span class="lineCov">          3 :   ssdcableitsring3BB24pconshape[1] = new TGeoPcon(90.0+kSSDCableAngle-0.5*ssdcableangle,</span>
<span class="lineNum">    7960 </span>            :                                                                      ssdcableangle-kSSDCableAngle
<span class="lineNum">    7961 </span><span class="lineCov">          1 :                                                                    + kSSDCablesPatchPanel2RB24Angle[0],2);</span>
<span class="lineNum">    7962 </span><span class="lineCov">          3 :   ssdcableitsring3BB24pconshape[2] = new TGeoPcon(180.0+kSSDCableAngle-0.5*ssdcableangle,ssdcableangle</span>
<span class="lineNum">    7963 </span>            :                                                                    - kSSDCableAngle
<span class="lineNum">    7964 </span><span class="lineCov">          1 :                                                                    + 90.0 - kSSDCablesPatchPanel2RB24Angle[1],2);</span>
<span class="lineNum">    7965 </span><span class="lineCov">          2 :   ssdcableitsring3BB24pconshape[3] = new TGeoPcon(270.0+kSSDCableAngle-0.5*ssdcableangle,</span>
<span class="lineNum">    7966 </span>            :                                                                    ssdcableangle-kSSDCableAngle
<span class="lineNum">    7967 </span>            :                                                                    + kSSDCablesPatchPanel2RB24Angle[0],2);
<span class="lineNum">    7968 </span><span class="lineCov">         10 :   for(Int_t i=0;i&lt;4;i++)</span>
<span class="lineNum">    7969 </span><span class="lineCov">         32 :         for(Int_t j=0; j&lt;2; j++) ssdcableitsring3BB24pconshape[i]-&gt;DefineSection(j,ssdcableitsring3BB24pconzsection[j],</span>
<span class="lineNum">    7970 </span><span class="lineCov">          8 :                                                          ssdcableitsring3BB24pconrmin[j],</span>
<span class="lineNum">    7971 </span><span class="lineCov">          8 :                                                          ssdcableitsring3BB24pconrmax[j]); </span>
<span class="lineNum">    7972 </span><span class="lineCov">          1 :   TGeoVolume* ssdcableitsring3BB24pcon[4];</span>
<span class="lineNum">    7973 </span><span class="lineCov">          3 :   ssdcableitsring3BB24pcon[0] = new TGeoVolume(&quot;SSDCableITSRing3RB24Part1&quot;,</span>
<span class="lineNum">    7974 </span><span class="lineCov">          1 :                                                                                                 ssdcableitsring3BB24pconshape[0],fSSDCopper);</span>
<span class="lineNum">    7975 </span><span class="lineCov">          3 :   ssdcableitsring3BB24pcon[1] = new TGeoVolume(&quot;SSDCableITSRing3RB24Part2&quot;,</span>
<span class="lineNum">    7976 </span><span class="lineCov">          1 :                                                                                                 ssdcableitsring3BB24pconshape[1],fSSDCopper);</span>
<span class="lineNum">    7977 </span><span class="lineCov">          3 :   ssdcableitsring3BB24pcon[2] = new TGeoVolume(&quot;SSDCableITSRing3RB24Part3&quot;,</span>
<span class="lineNum">    7978 </span><span class="lineCov">          1 :                                                                                                 ssdcableitsring3BB24pconshape[2],fSSDCopper);</span>
<span class="lineNum">    7979 </span><span class="lineCov">          3 :   ssdcableitsring3BB24pcon[3] = new TGeoVolume(&quot;SSDCableITSRing3RB24Part4&quot;,</span>
<span class="lineNum">    7980 </span><span class="lineCov">          1 :                                                                                                 ssdcableitsring3BB24pconshape[3],fSSDCopper);</span>
<span class="lineNum">    7981 </span><span class="lineCov">         10 :   for(Int_t i=0;i&lt;4;i++){</span>
<span class="lineNum">    7982 </span><span class="lineCov">          4 :         ssdcableitsring3BB24pcon[i]-&gt;SetLineColor(9);</span>
<span class="lineNum">    7983 </span><span class="lineCov">          4 :         ssdcablesmother-&gt;AddNode(ssdcableitsring3BB24pcon[i],1);</span>
<span class="lineNum">    7984 </span>            :         // Printf(Form(&quot;Cable to patch panels RB24 (part 2) volume: %g (%d)&quot;,ssdcableitsring3BB24pcon[i]-&gt;Capacity(),i));
<span class="lineNum">    7985 </span>            : }
<span class="lineNum">    7986 </span>            : 
<span class="lineNum">    7987 </span>            :   ////////////////////////////////////
<span class="lineNum">    7988 </span>            :   //cablescapacity[13] = ssdcableitsring3BB24pconshape[0]-&gt;Capacity()
<span class="lineNum">    7989 </span>            :   //                                     + ssdcableitsring3BB24pconshape[1]-&gt;Capacity()
<span class="lineNum">    7990 </span>            :   //                                     + ssdcableitsring3BB24pconshape[2]-&gt;Capacity()
<span class="lineNum">    7991 </span>            :   //                                     + ssdcableitsring3BB24pconshape[3]-&gt;Capacity();
<span class="lineNum">    7992 </span>            : 
<span class="lineNum">    7993 </span>            :   // MvL: Pcon are connection to patch panels (part of)
<span class="lineNum">    7994 </span>            :   // Removed; do not contribute much; put into ring structure
<span class="lineNum">    7995 </span>            :   /*
<span class="lineNum">    7996 </span>            :   TGeoPcon* ssdcablelay6materialbudgetpconshape = 
<span class="lineNum">    7997 </span>            :                                         new TGeoPcon(90.0-kSSDCableAngle-0.5*ssdcableangle,ssdcableangle,2); 
<span class="lineNum">    7998 </span>            :   TGeoVolume* ssdcablelay6materialbudgetpcon;
<span class="lineNum">    7999 </span>            :   Double_t ssdcablelay6materialbudgetpconrmin[2];
<span class="lineNum">    8000 </span>            :   Double_t ssdcablelay6materialbudgetpconrmax[2];
<span class="lineNum">    8001 </span>            :   Double_t ssdcablelay6materialbudgetpconzsection[2];
<span class="lineNum">    8002 </span>            :   ssdcablelay6materialbudgetpconrmin[0] = ssdcableslay6rightsideradiusmax
<span class="lineNum">    8003 </span>            :                                                                                 + kSSDCablesLay5RightSideWaterHeight;
<span class="lineNum">    8004 </span>            :   ssdcablelay6materialbudgetpconrmax[0] = ssdcablelay6materialbudgetpconrmin[0]
<span class="lineNum">    8005 </span>            :                                                                                 + kSSDCableMaterialBudgetHeight;
<span class="lineNum">    8006 </span>            :   ssdcablelay6materialbudgetpconrmin[1] = ssdcablelay6materialbudgetpconrmin[0];
<span class="lineNum">    8007 </span>            :   ssdcablelay6materialbudgetpconrmax[1] = ssdcablelay6materialbudgetpconrmax[0];
<span class="lineNum">    8008 </span>            :   ssdcablelay6materialbudgetpconzsection[0] = fgkEndCapSupportCenterLay6ITSPosition
<span class="lineNum">    8009 </span>            :                                                                                         + fgkEndCapSupportCenterLay6Position
<span class="lineNum">    8010 </span>            :                                                                                         + ssdcablelay6rightsidelength;
<span class="lineNum">    8011 </span>            :   ssdcablelay6materialbudgetpconzsection[1] = ssdcableslay5pconwaterzsection[5];
<span class="lineNum">    8012 </span>            :   for(Int_t i=0; i&lt;2;i++) ssdcablelay6materialbudgetpconshape-&gt;DefineSection(i,
<span class="lineNum">    8013 </span>            :                                                   ssdcablelay6materialbudgetpconzsection[i],
<span class="lineNum">    8014 </span>            :                                                   ssdcablelay6materialbudgetpconrmin[i],
<span class="lineNum">    8015 </span>            :                                                   ssdcablelay6materialbudgetpconrmax[i]); 
<span class="lineNum">    8016 </span>            :   ssdcablelay6materialbudgetpcon = new TGeoVolume(&quot;SSDCableLay6MaterialBudgetPCon&quot;,
<span class="lineNum">    8017 </span>            :                                                            ssdcablelay6materialbudgetpconshape,fSSDCopper);
<span class="lineNum">    8018 </span>            :   ssdcablelay6materialbudgetpcon-&gt;SetLineColor(9);
<span class="lineNum">    8019 </span>            :   for(Int_t i=0; i&lt;4; i++){
<span class="lineNum">    8020 </span>            :    ssdcablesmother-&gt;AddNode(ssdcablelay6materialbudgetpcon,i+1,ssdcableslay5pconrot[i]);
<span class="lineNum">    8021 </span>            :    ssdcablesmother-&gt;AddNode(ssdcablelay6materialbudgetpcon,i+5,ssdcablesLay5RightPConToLeftMatrix[i]);
<span class="lineNum">    8022 </span>            :   }
<span class="lineNum">    8023 </span>            :   */
<span class="lineNum">    8024 </span>            : ////////////////////////////////////
<span class="lineNum">    8025 </span>            :  /* cablescapacity[14] = 2.*ssdcablelay6materialbudgetubeshape-&gt;Capacity();
<span class="lineNum">    8026 </span>            :   cablescapacity[15] = 2.*ssdcablelay6materialbudgetpconshape-&gt;Capacity();
<span class="lineNum">    8027 </span>            :   Double_t ssdcablesvolume = 0.0;
<span class="lineNum">    8028 </span>            :   for(Int_t i=0;i&lt;16;i++) ssdcablesvolume+=cablescapacity[i];
<span class="lineNum">    8029 </span>            :   std::cout &lt;&lt; ssdcablesvolume &lt;&lt; std::endl;*/
<span class="lineNum">    8030 </span>            :   // Printf(Form(&quot;Total volume (one side; without conn to patch panel): %g&quot;,totvol));
<span class="lineNum">    8031 </span>            : 
<span class="lineNum">    8032 </span><span class="lineCov">          1 :   ssdcablesmother-&gt;GetShape()-&gt;ComputeBBox(); //RS: enforce recompting of BBox</span>
<span class="lineNum">    8033 </span><span class="lineCov">          1 :   return ssdcablesmother;</span>
<a name="8034"><span class="lineNum">    8034 </span><span class="lineCov">          1 :  }</span></a>
<span class="lineNum">    8035 </span>            :  ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    8036 </span>            : TGeoArb8* AliITSv11GeometrySSD::GetArbShape(TVector3 const * const vertexpos[4] , const Double_t* width, 
<span class="lineNum">    8037 </span>            :                                             Double_t height, const char* shapename, Int_t isign) const{
<span class="lineNum">    8038 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    8039 </span>            :   // Method generating an Arb shape 
<span class="lineNum">    8040 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    8041 </span>            :   const Int_t kvertexnumber = 8;
<span class="lineNum">    8042 </span>            :   const Int_t ktransvectnumber = 2;
<span class="lineNum">    8043 </span><span class="lineCov">        108 :   TVector3 vertex[kvertexnumber];</span>
<span class="lineNum">    8044 </span><span class="lineCov">         30 :   TVector3 transvector[2];</span>
<span class="lineNum">    8045 </span><span class="lineCov">         36 :   for(Int_t i=0; i&lt;ktransvectnumber; i++) transvector[i].SetY(width[i]);</span>
<span class="lineNum">    8046 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    8047 </span>            :   //Setting the vertices for TGeoArb8
<span class="lineNum">    8048 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    8049 </span><span class="lineCov">          6 :   vertex[0] = *vertexpos[0];</span>
<span class="lineNum">    8050 </span><span class="lineCov">          6 :   vertex[1] = *vertexpos[1];</span>
<span class="lineNum">    8051 </span><span class="lineCov">          6 :   vertex[2] = vertex[1]; </span>
<span class="lineNum">    8052 </span><span class="lineCov">          6 :   vertex[3] = vertex[0]; </span>
<span class="lineNum">    8053 </span><span class="lineCov">          6 :   vertex[4] = *vertexpos[2];</span>
<span class="lineNum">    8054 </span><span class="lineCov">          6 :   vertex[5] = *vertexpos[3];</span>
<span class="lineNum">    8055 </span><span class="lineCov">          6 :   vertex[6] = vertex[5];</span>
<span class="lineNum">    8056 </span><span class="lineCov">          6 :   vertex[7] = vertex[4];</span>
<span class="lineNum">    8057 </span>            : 
<span class="lineNum">    8058 </span>            :   // NB: order of points is clockwise
<span class="lineNum">    8059 </span><span class="lineCov">          6 :   if (isign &lt; 0) {</span>
<span class="lineNum">    8060 </span><span class="lineCov">          1 :     vertex[2] -= transvector[0];</span>
<span class="lineNum">    8061 </span><span class="lineCov">          1 :     vertex[3] -= transvector[0];</span>
<span class="lineNum">    8062 </span><span class="lineCov">          1 :     vertex[6] -= transvector[1];</span>
<span class="lineNum">    8063 </span><span class="lineCov">          1 :     vertex[7] -= transvector[1];</span>
<span class="lineNum">    8064 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">    8065 </span>            :   else {
<span class="lineNum">    8066 </span><span class="lineCov">          5 :     vertex[0] += transvector[0];</span>
<span class="lineNum">    8067 </span><span class="lineCov">          5 :     vertex[1] += transvector[0];</span>
<span class="lineNum">    8068 </span><span class="lineCov">          5 :     vertex[4] += transvector[1];</span>
<span class="lineNum">    8069 </span><span class="lineCov">          5 :     vertex[5] += transvector[1];</span>
<span class="lineNum">    8070 </span>            :   }
<span class="lineNum">    8071 </span>            : 
<span class="lineNum">    8072 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    8073 </span><span class="lineCov">         12 :   TGeoArb8* arbshape = new TGeoArb8(shapename,0.5*height);</span>
<span class="lineNum">    8074 </span><span class="lineCov">        108 :   for(Int_t i = 0; i&lt;kvertexnumber;i++) {</span>
<span class="lineNum">    8075 </span><span class="lineCov">         48 :     arbshape-&gt;SetVertex(i,vertex[i].X(),vertex[i].Y());</span>
<span class="lineNum">    8076 </span>            :   }
<span class="lineNum">    8077 </span>            : 
<span class="lineNum">    8078 </span>            :   return arbshape;
<a name="8079"><span class="lineNum">    8079 </span><span class="lineCov">         78 : } </span></a>
<span class="lineNum">    8080 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    8081 </span>            : TGeoXtru* AliITSv11GeometrySSD::GetArcShape(Double_t phi, Double_t rmin, 
<span class="lineNum">    8082 </span>            :                                                                 Double_t rmax, Int_t nedges, Double_t height){
<span class="lineNum">    8083 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    8084 </span>            :   // Method generating Arc shape 
<span class="lineNum">    8085 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    8086 </span><span class="lineCov">          2 :         const Int_t kvertexnumber = 2*nedges+2;</span>
<span class="lineNum">    8087 </span><span class="lineCov">          1 :         TGeoXtru* arcshape = new TGeoXtru(2);   </span>
<span class="lineNum">    8088 </span><span class="lineCov">          1 :         TVector3** vertexposition[2];</span>
<span class="lineNum">    8089 </span><span class="lineCov">          6 :         for(Int_t i=0; i&lt;2; i++) vertexposition[i] = new TVector3*[nedges+1];</span>
<span class="lineNum">    8090 </span>            :         Double_t angle = 0.;
<span class="lineNum">    8091 </span><span class="lineCov">          8 :     for(Int_t i=0; i&lt;nedges+1; i++){ </span>
<span class="lineNum">    8092 </span><span class="lineCov">          3 :                 angle = 90.+0.5*phi-i*(phi/nedges);</span>
<span class="lineNum">    8093 </span><span class="lineCov">         12 :                 vertexposition[0][i] = new TVector3(rmin*CosD(angle),rmin*SinD(angle),0);</span>
<span class="lineNum">    8094 </span><span class="lineCov">         12 :                 vertexposition[1][i] = new TVector3(rmax*CosD(angle),rmax*SinD(angle),0);</span>
<span class="lineNum">    8095 </span>            :         }
<span class="lineNum">    8096 </span><span class="lineCov">          1 :         Double_t *xvertexpoints = new Double_t[kvertexnumber];</span>
<span class="lineNum">    8097 </span><span class="lineCov">          1 :         Double_t *yvertexpoints = new Double_t[kvertexnumber];</span>
<span class="lineNum">    8098 </span><span class="lineCov">         14 :         for(Int_t i=0; i&lt;kvertexnumber; i++){ </span>
<span class="lineNum">    8099 </span><span class="lineCov">          7 :                 if(i==0){ xvertexpoints[i] = vertexposition[0][i]-&gt;X(),</span>
<span class="lineNum">    8100 </span><span class="lineCov">          1 :                                   yvertexpoints[i] = vertexposition[0][i]-&gt;Y();      </span>
<span class="lineNum">    8101 </span><span class="lineCov">          1 :                 }</span>
<span class="lineNum">    8102 </span><span class="lineCov">         10 :                 else if(i&gt;=1&amp;&amp;i&lt;nedges+2)</span>
<span class="lineNum">    8103 </span>            :                 {
<span class="lineNum">    8104 </span><span class="lineCov">          3 :                         xvertexpoints[i] = vertexposition[1][i-1]-&gt;X(); </span>
<span class="lineNum">    8105 </span><span class="lineCov">          3 :                         yvertexpoints[i] = vertexposition[1][i-1]-&gt;Y(); </span>
<span class="lineNum">    8106 </span><span class="lineCov">          3 :                 }</span>
<span class="lineNum">    8107 </span>            :         else
<span class="lineNum">    8108 </span>            :                 {
<span class="lineNum">    8109 </span><span class="lineCov">          2 :                         xvertexpoints[i] = vertexposition[0][kvertexnumber-i]-&gt;X(); </span>
<span class="lineNum">    8110 </span><span class="lineCov">          2 :                         yvertexpoints[i] = vertexposition[0][kvertexnumber-i]-&gt;Y(); </span>
<span class="lineNum">    8111 </span>            :                 }
<span class="lineNum">    8112 </span>            :     }
<span class="lineNum">    8113 </span><span class="lineCov">          1 :   arcshape-&gt;DefinePolygon(kvertexnumber,xvertexpoints,yvertexpoints);</span>
<span class="lineNum">    8114 </span><span class="lineCov">          1 :   arcshape-&gt;DefineSection(0,-0.5*height);</span>
<span class="lineNum">    8115 </span><span class="lineCov">          1 :   arcshape-&gt;DefineSection(1,0.5*height);</span>
<span class="lineNum">    8116 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    8117 </span>            :   // Deallocating memory
<span class="lineNum">    8118 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    8119 </span><span class="lineCov">          6 :   for(Int_t i=0; i&lt;2; i++){</span>
<span class="lineNum">    8120 </span><span class="lineCov">         16 :         for(Int_t j=0; j&lt;nedges+1; j++)</span>
<span class="lineNum">    8121 </span><span class="lineCov">         12 :                 delete vertexposition[i][j];</span>
<span class="lineNum">    8122 </span><span class="lineCov">          4 :         delete [] vertexposition[i];</span>
<span class="lineNum">    8123 </span>            :   }
<span class="lineNum">    8124 </span><span class="lineCov">          2 :   delete [] xvertexpoints;</span>
<span class="lineNum">    8125 </span><span class="lineCov">          2 :   delete [] yvertexpoints;</span>
<span class="lineNum">    8126 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    8127 </span><span class="lineCov">          1 :         return arcshape;</span>
<a name="8128"><span class="lineNum">    8128 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">    8129 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    8130 </span>            : TGeoShape* AliITSv11GeometrySSD::GetScrewShape(const Double_t* radius,const Int_t* edgesnumber,const Double_t* section) const {
<span class="lineNum">    8131 </span>            :   ///////////////////////////////////////////////////////////////////////
<span class="lineNum">    8132 </span>            :   // Method Generating the Screw Shape  
<span class="lineNum">    8133 </span>            :   // radius[0]: outer radius
<span class="lineNum">    8134 </span>            :   // radius[1]: inner radius
<span class="lineNum">    8135 </span>            :   // edgesnumber[0]: outer number of edges
<span class="lineNum">    8136 </span>            :   // edgesnumber[1]: inner number of edges
<span class="lineNum">    8137 </span>            :   // section[0]: lower section position
<span class="lineNum">    8138 </span>            :   // section[1]: higher section position
<span class="lineNum">    8139 </span>            :   ///////////////////////////////////////////////////////////////////////
<span class="lineNum">    8140 </span><span class="lineCov">          4 :   Double_t outradius = radius[0];</span>
<span class="lineNum">    8141 </span><span class="lineCov">          2 :   Double_t inradius = radius[1];</span>
<span class="lineNum">    8142 </span><span class="lineCov">          2 :   Int_t outvertexnumber = edgesnumber[0];</span>
<span class="lineNum">    8143 </span><span class="lineCov">          2 :   Int_t invertexnumber = edgesnumber[1];</span>
<span class="lineNum">    8144 </span><span class="lineCov">          2 :   Double_t* xscrewvertex = new Double_t[outvertexnumber+invertexnumber];</span>
<span class="lineNum">    8145 </span><span class="lineCov">          2 :   Double_t* yscrewvertex = new Double_t[outvertexnumber+invertexnumber];</span>
<span class="lineNum">    8146 </span><span class="lineCov">        144 :   for(Int_t i=0; i&lt;outvertexnumber; i++){</span>
<span class="lineNum">    8147 </span><span class="lineCov">         70 :         xscrewvertex[i] = outradius*CosD(90.+i*360./outvertexnumber);</span>
<span class="lineNum">    8148 </span><span class="lineCov">         70 :         yscrewvertex[i] = outradius*SinD(90.+i*360./outvertexnumber);</span>
<span class="lineNum">    8149 </span>            :   }
<span class="lineNum">    8150 </span><span class="lineCov">         56 :   for(Int_t i=0; i&lt;invertexnumber; i++){</span>
<span class="lineNum">    8151 </span><span class="lineCov">         26 :         xscrewvertex[outvertexnumber+i] = inradius*CosD(90.+i*360./invertexnumber);</span>
<span class="lineNum">    8152 </span><span class="lineCov">         26 :         yscrewvertex[outvertexnumber+i] = inradius*SinD(90.+i*360./invertexnumber);</span>
<span class="lineNum">    8153 </span>            :   }
<span class="lineNum">    8154 </span><span class="lineCov">          2 :   TGeoXtru* screwshapeout = new TGeoXtru(2);</span>
<span class="lineNum">    8155 </span><span class="lineCov">          2 :   screwshapeout-&gt;DefinePolygon(outvertexnumber,xscrewvertex,yscrewvertex);</span>
<span class="lineNum">    8156 </span><span class="lineCov">          2 :   screwshapeout-&gt;DefineSection(0,section[0]);</span>
<span class="lineNum">    8157 </span><span class="lineCov">          2 :   screwshapeout-&gt;DefineSection(1,section[1]);</span>
<span class="lineNum">    8158 </span><span class="lineCov">          2 :   TGeoXtru* screwshapein = new TGeoXtru(2);</span>
<span class="lineNum">    8159 </span><span class="lineCov">          2 :   screwshapein-&gt;DefinePolygon(invertexnumber,&amp;xscrewvertex[outvertexnumber],&amp;yscrewvertex[outvertexnumber]);</span>
<span class="lineNum">    8160 </span><span class="lineCov">          2 :   screwshapein-&gt;DefineSection(0,section[0]-0.01); // make inner part bigger in Z</span>
<span class="lineNum">    8161 </span><span class="lineCov">          2 :   screwshapein-&gt;DefineSection(1,section[1]+0.01); // safer when we subtract it</span>
<span class="lineNum">    8162 </span><span class="lineCov">          2 :   TGeoSubtraction *snode = new TGeoSubtraction(screwshapeout, screwshapein);</span>
<span class="lineNum">    8163 </span><span class="lineCov">          2 :   TGeoCompositeShape *screwshape = new TGeoCompositeShape(&quot;&quot;, snode);</span>
<span class="lineNum">    8164 </span>            :   
<span class="lineNum">    8165 </span><span class="lineCov">          4 :   delete [] xscrewvertex;</span>
<span class="lineNum">    8166 </span><span class="lineCov">          4 :   delete [] yscrewvertex;</span>
<span class="lineNum">    8167 </span><span class="lineCov">          2 :   return screwshape;</span>
<a name="8168"><span class="lineNum">    8168 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    8169 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    8170 </span>            : TGeoShape* AliITSv11GeometrySSD::GetHoleShape(Double_t radius, Int_t nedges, const Double_t *section) const {
<span class="lineNum">    8171 </span>            :   ///////////////////////////////////////////////////////////////////////
<span class="lineNum">    8172 </span>            :   // Method Generating the Hole Shape  
<span class="lineNum">    8173 </span>            :   // radius of the Hole
<span class="lineNum">    8174 </span>            :   // nedges: number of edges to approximate the circle
<span class="lineNum">    8175 </span>            :   ///////////////////////////////////////////////////////////////////////
<span class="lineNum">    8176 </span><span class="lineCov">          4 :   Double_t* xholevertex = new Double_t[nedges];</span>
<span class="lineNum">    8177 </span><span class="lineCov">          2 :   Double_t* yholevertex = new Double_t[nedges];</span>
<span class="lineNum">    8178 </span><span class="lineCov">          2 :   Double_t z  = 0.5*(section[0]+section[1]);</span>
<span class="lineNum">    8179 </span><span class="lineCov">          2 :   Double_t dz = 0.5*(section[1]-section[0]);</span>
<span class="lineNum">    8180 </span>            :   TGeoTranslation *tr = 0;
<span class="lineNum">    8181 </span><span class="lineCov">          2 :   if (TMath::Abs(z) &gt; TGeoShape::Tolerance()) {</span>
<span class="lineNum">    8182 </span><span class="lineNoCov">          0 :      tr = new TGeoTranslation(0.,0.,z);</span>
<span class="lineNum">    8183 </span><span class="lineNoCov">          0 :      tr-&gt;RegisterYourself();</span>
<span class="lineNum">    8184 </span><span class="lineNoCov">          0 :   }   </span>
<span class="lineNum">    8185 </span><span class="lineCov">          2 :   TGeoBBox *box = new TGeoBBox(&quot;&quot;,radius,radius,dz);</span>
<span class="lineNum">    8186 </span><span class="lineCov">        124 :   for(Int_t i=0; i&lt;nedges; i++){</span>
<span class="lineNum">    8187 </span><span class="lineCov">         60 :         xholevertex[i] = radius*CosD(i*360./nedges);</span>
<span class="lineNum">    8188 </span><span class="lineCov">         60 :         yholevertex[i] = radius*SinD(i*360./nedges);</span>
<span class="lineNum">    8189 </span>            :   }
<span class="lineNum">    8190 </span><span class="lineCov">          2 :   TGeoXtru* holeshapeout = new TGeoXtru(2);</span>
<span class="lineNum">    8191 </span><span class="lineCov">          2 :   holeshapeout-&gt;DefinePolygon(nedges,xholevertex,yholevertex);</span>
<span class="lineNum">    8192 </span><span class="lineCov">          2 :   holeshapeout-&gt;DefineSection(0,section[0]-0.01); // make subtracted part larger in Z</span>
<span class="lineNum">    8193 </span><span class="lineCov">          2 :   holeshapeout-&gt;DefineSection(1,section[1]+0.01);</span>
<span class="lineNum">    8194 </span><span class="lineCov">          2 :   TGeoSubtraction *snode = new TGeoSubtraction(box,holeshapeout,tr);</span>
<span class="lineNum">    8195 </span><span class="lineCov">          2 :   TGeoCompositeShape *holeshape = new TGeoCompositeShape(&quot;&quot;, snode);</span>
<span class="lineNum">    8196 </span>            :   
<span class="lineNum">    8197 </span><span class="lineCov">          4 :   delete [] xholevertex;</span>
<span class="lineNum">    8198 </span><span class="lineCov">          4 :   delete [] yholevertex;</span>
<span class="lineNum">    8199 </span><span class="lineCov">          2 :   return holeshape;</span>
<a name="8200"><span class="lineNum">    8200 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    8201 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    8202 </span>            : TVector3* AliITSv11GeometrySSD::GetReflection(const TVector3* vector,const Double_t* param) const{
<span class="lineNum">    8203 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    8204 </span>            :   // Given an axis specified by param, it gives the reflection of the point
<span class="lineNum">    8205 </span>            :   // respect to the axis
<span class="lineNum">    8206 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    8207 </span><span class="lineCov">         52 :   TVector3* n = new TVector3(param[0],param[1],param[2]);</span>
<span class="lineNum">    8208 </span><span class="lineCov">         26 :   Double_t d = ((*vector)*(*n)+param[3])/n-&gt;Mag2();</span>
<span class="lineNum">    8209 </span><span class="lineCov">         78 :   TVector3* reflectedvector = new TVector3(*vector-2*d*(*n));</span>
<span class="lineNum">    8210 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    8211 </span>            :   // Deallocating memory
<span class="lineNum">    8212 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    8213 </span><span class="lineCov">         52 :   delete n;</span>
<span class="lineNum">    8214 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    8215 </span><span class="lineCov">         26 :   return reflectedvector;</span>
<a name="8216"><span class="lineNum">    8216 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    8217 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    8218 </span>            : TGeoHMatrix* AliITSv11GeometrySSD::AddTranslationToHMatrix(const TGeoHMatrix* ct,
<span class="lineNum">    8219 </span>            :                                                        Double_t dx,
<span class="lineNum">    8220 </span>            :                                                        Double_t dy,
<span class="lineNum">    8221 </span>            :                                                        Double_t dz) const{
<span class="lineNum">    8222 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    8223 </span>            :   // Add a dx,dy,dz translation to the initial TGeoCombiTrans
<span class="lineNum">    8224 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    8225 </span><span class="lineCov">          8 :   TGeoHMatrix* hmatrix = new TGeoHMatrix(*ct);</span>
<span class="lineNum">    8226 </span><span class="lineCov">          4 :   const Double_t *vect = hmatrix-&gt;GetTranslation();</span>
<span class="lineNum">    8227 </span><span class="lineCov">          4 :   Double_t newvect[3] = {vect[0]+dx, vect[1]+dy, vect[2]+dz};</span>
<span class="lineNum">    8228 </span><span class="lineCov">          4 :   hmatrix-&gt;SetTranslation(newvect);</span>
<span class="lineNum">    8229 </span><span class="lineCov">          4 :   TGeoHMatrix* matrix = new TGeoHMatrix(*hmatrix);</span>
<span class="lineNum">    8230 </span><span class="lineCov">          8 :   delete hmatrix;</span>
<span class="lineNum">    8231 </span><span class="lineCov">          4 :   return matrix;</span>
<a name="8232"><span class="lineNum">    8232 </span><span class="lineCov">          4 : }</span></a>
<span class="lineNum">    8233 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    8234 </span>            : TGeoMedium* AliITSv11GeometrySSD::GetMedium(const char* mediumName) {
<span class="lineNum">    8235 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    8236 </span>            :   // Method returning the Medium type 
<span class="lineNum">    8237 </span>            :   /////////////////////////////////////////////////////////////
<span class="lineNum">    8238 </span><span class="lineCov">         56 :   char ch[100];</span>
<span class="lineNum">    8239 </span><span class="lineCov">         28 :   snprintf(ch,100, &quot;ITS_%s&quot;,mediumName);</span>
<span class="lineNum">    8240 </span><span class="lineCov">         28 :   TGeoMedium* medium =  gGeoManager-&gt;GetMedium(ch);</span>
<span class="lineNum">    8241 </span><span class="lineCov">         28 :   if (! medium)</span>
<span class="lineNum">    8242 </span><span class="lineNoCov">          0 :     AliError(Form(&quot;medium %s not found !\n&quot;, mediumName));</span>
<span class="lineNum">    8243 </span><span class="lineCov">         28 :   return medium;</span>
<a name="8244"><span class="lineNum">    8244 </span><span class="lineCov">         28 : }</span></a>
<span class="lineNum">    8245 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    8246 </span>            : void AliITSv11GeometrySSD::CreateMaterials(){
<span class="lineNum">    8247 </span>            : ///////////////////////////////////
<span class="lineNum">    8248 </span>            : // This part has to be modified
<span class="lineNum">    8249 </span>            : ///////////////////////////////////
<span class="lineNum">    8250 </span>            :   ///////////////////////////////////
<span class="lineNum">    8251 </span>            :   // Silicon for Sensor
<span class="lineNum">    8252 </span>            :   /////////////////////////////////// 
<span class="lineNum">    8253 </span><span class="lineCov">          2 :   fSSDSensorMedium = GetMedium(&quot;SI$&quot;);</span>
<span class="lineNum">    8254 </span>            :   ///////////////////////////////////
<span class="lineNum">    8255 </span>            :   // Silicon Mixture for Sensor
<span class="lineNum">    8256 </span>            :   /////////////////////////////////// 
<span class="lineNum">    8257 </span><span class="lineCov">          1 :   fSSDChipMedium = GetMedium(&quot;SPD SI CHIP$&quot;);</span>
<span class="lineNum">    8258 </span><span class="lineCov">          1 :   fSSDChipGlueMedium = GetMedium(&quot;EPOXY$&quot;);</span>
<span class="lineNum">    8259 </span>            :   ///////////////////////////////////
<span class="lineNum">    8260 </span>            :   // Stiffener Components Materials
<span class="lineNum">    8261 </span>            :   /////////////////////////////////// 
<span class="lineNum">    8262 </span><span class="lineCov">          1 :   fSSDStiffenerMedium = GetMedium(&quot;SDD C AL (M55J)$&quot;);</span>
<span class="lineNum">    8263 </span>            :   ///////////////////////////  
<span class="lineNum">    8264 </span>            :   // Stiffener Connectors 
<span class="lineNum">    8265 </span>            :   ///////////////////////////  
<span class="lineNum">    8266 </span><span class="lineCov">          1 :   fSSDStiffenerConnectorMedium = GetMedium(&quot;COPPER$&quot;);</span>
<span class="lineNum">    8267 </span>            :   ////////////////////////////////  
<span class="lineNum">    8268 </span>            :   // Stiffener 0603-1812 Capacitor
<span class="lineNum">    8269 </span>            :   ////////////////////////////////  
<span class="lineNum">    8270 </span><span class="lineCov">          1 :   fSSDStiffener0603CapacitorMedium = GetMedium(&quot;SDD ruby sph. Al2O3$&quot;);</span>
<span class="lineNum">    8271 </span><span class="lineCov">          1 :   fSSDStiffener1812CapacitorMedium = GetMedium(&quot;SDD ruby sph. Al2O3$&quot;);</span>
<span class="lineNum">    8272 </span><span class="lineCov">          1 :   fSSDStiffenerCapacitorCapMedium = GetMedium(&quot;NiSn$&quot;);</span>
<span class="lineNum">    8273 </span>            :   ///////////////////////////  
<span class="lineNum">    8274 </span>            :   // Stiffener Hybrid Wire 
<span class="lineNum">    8275 </span>            :   ///////////////////////////  
<span class="lineNum">    8276 </span><span class="lineCov">          1 :   fSSDStiffenerHybridWireMedium = GetMedium(&quot;COPPER$&quot;);</span>
<span class="lineNum">    8277 </span>            :   ///////////////////////////  
<span class="lineNum">    8278 </span>            :   // Al for Cooling Block
<span class="lineNum">    8279 </span>            :   ///////////////////////////  
<span class="lineNum">    8280 </span><span class="lineCov">          1 :   fSSDAlCoolBlockMedium = GetMedium(&quot;AL$&quot;);</span>
<span class="lineNum">    8281 </span>            :   //////////////////////////////////////////////////////  
<span class="lineNum">    8282 </span>            :   // Kapton and Al for Chip Cable Flex and Ladder Cables
<span class="lineNum">    8283 </span>            :   //////////////////////////////////////////////////////  
<span class="lineNum">    8284 </span><span class="lineCov">          1 :   fSSDKaptonChipCableMedium = GetMedium(&quot;KAPTONH(POLYCH2)$&quot;);</span>
<span class="lineNum">    8285 </span><span class="lineCov">          1 :   fSSDAlTraceChipCableMedium = GetMedium(&quot;AL$&quot;);</span>
<span class="lineNum">    8286 </span><span class="lineCov">          1 :   fSSDKaptonFlexMedium = GetMedium(&quot;KAPTONH(POLYCH2)$&quot;);</span>
<span class="lineNum">    8287 </span><span class="lineCov">          1 :   fSSDAlTraceFlexMedium = GetMedium(&quot;AL$&quot;);</span>
<span class="lineNum">    8288 </span><span class="lineCov">          1 :   fSSDKaptonLadderCableMedium = GetMedium(&quot;KAPTONH(POLYCH2)$&quot;);</span>
<span class="lineNum">    8289 </span><span class="lineCov">          1 :   fSSDAlTraceLadderCableMedium = GetMedium(&quot;AL$&quot;);</span>
<span class="lineNum">    8290 </span>            :   /////////////////////////////////////////////////////////////////  
<span class="lineNum">    8291 </span>            :   // M55J for Carbon Fiber, CarbonFiber Lower Support and Junction
<span class="lineNum">    8292 </span>            :   //////////////////////////////////////////////////////////////////  
<span class="lineNum">    8293 </span><span class="lineCov">          1 :   fSSDCarbonFiberMedium = GetMedium(&quot;GEN C (M55J)$&quot;);</span>
<span class="lineNum">    8294 </span>            :   /////////////////////////////////////////////////////////////////  
<span class="lineNum">    8295 </span>            :   // G10 for Detector Leg, TubeHolder
<span class="lineNum">    8296 </span>            :   //////////////////////////////////////////////////////////////////  
<span class="lineNum">    8297 </span><span class="lineCov">          1 :   fSSDTubeHolderMedium = GetMedium(&quot;G10FR4$&quot;);</span>
<span class="lineNum">    8298 </span><span class="lineCov">          1 :   fSSDSensorSupportMedium = GetMedium(&quot;G10FR4$&quot;);</span>
<span class="lineNum">    8299 </span><span class="lineCov">          1 :   fSSDMountingBlockMedium = GetMedium(&quot;G10FR4$&quot;);</span>
<span class="lineNum">    8300 </span><span class="lineCov">          1 :   fSSDMountingBlockMedium = GetMedium(&quot;G10FR4$&quot;);</span>
<span class="lineNum">    8301 </span>            :   /////////////////////////////////////////////////////////////////  
<span class="lineNum">    8302 </span>            :   // Water and Phynox for Cooling Tube
<span class="lineNum">    8303 </span>            :   //////////////////////////////////////////////////////////////////  
<span class="lineNum">    8304 </span><span class="lineCov">          1 :   fSSDCoolingTubeWater = GetMedium(&quot;WATER$&quot;);</span>
<span class="lineNum">    8305 </span><span class="lineCov">          1 :   fSSDCoolingTubePhynox = GetMedium(&quot;INOX$&quot;);</span>
<span class="lineNum">    8306 </span>            :   /////////////////////////////////////////////////////////////////////
<span class="lineNum">    8307 </span>            :   // Material for Support Rings
<span class="lineNum">    8308 </span>            :   /////////////////////////////////////////////////////////////////////
<span class="lineNum">    8309 </span><span class="lineCov">          1 :   fSSDSupportRingAl = GetMedium(&quot;AL$&quot;);</span>
<span class="lineNum">    8310 </span><span class="lineCov">          1 :   fSSDRohaCellCone = GetMedium(&quot;ROHACELL$&quot;);</span>
<span class="lineNum">    8311 </span>            :   /////////////////////////////////////////////////////////////////////
<span class="lineNum">    8312 </span><span class="lineCov">          1 :   fSSDAir = GetMedium(&quot;SDD AIR$&quot;);</span>
<span class="lineNum">    8313 </span><span class="lineCov">          1 :   fSSDCopper = GetMedium(&quot;COPPER$&quot;);</span>
<span class="lineNum">    8314 </span><span class="lineCov">          1 :   fSSDSn = GetMedium(&quot;Sn$&quot;);</span>
<span class="lineNum">    8315 </span><span class="lineCov">          1 :   fCreateMaterials = kTRUE;</span>
<span class="lineNum">    8316 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    8317 </span>            : /////////////////////////////////////////////////////////////////////
<span class="lineNum">    8318 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
