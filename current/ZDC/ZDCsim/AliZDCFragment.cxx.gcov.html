<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - ZDC/ZDCsim/AliZDCFragment.cxx</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">ZDC/ZDCsim</a> - AliZDCFragment.cxx<span style="font-size: 80%;"> (source / <a href="AliZDCFragment.cxx.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">144</td>
            <td class="headerCovTableEntryLo">0.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">9</td>
            <td class="headerCovTableEntryLo">11.1 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**************************************************************************</a>
<span class="lineNum">       2 </span>            :  * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
<span class="lineNum">       3 </span>            :  *                                                                        *
<span class="lineNum">       4 </span>            :  * Author: The ALICE Off-line Project.                                    *
<span class="lineNum">       5 </span>            :  * Contributors are mentioned in the code where appropriate.              *
<span class="lineNum">       6 </span>            :  *                                                                        *
<span class="lineNum">       7 </span>            :  * Permission to use, copy, modify and distribute this software and its   *
<span class="lineNum">       8 </span>            :  * documentation strictly for non-commercial purposes is hereby granted   *
<span class="lineNum">       9 </span>            :  * without fee, provided that the above copyright notice appears in all   *
<span class="lineNum">      10 </span>            :  * copies and that both the copyright notice and this permission notice   *
<span class="lineNum">      11 </span>            :  * appear in the supporting documentation. The authors make no claims     *
<span class="lineNum">      12 </span>            :  * about the suitability of this software for any purpose. It is          *
<span class="lineNum">      13 </span>            :  * provided &quot;as is&quot; without express or implied warranty.                  *
<span class="lineNum">      14 </span>            :  **************************************************************************/
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : // ******************************************************************
<span class="lineNum">      18 </span>            : //
<span class="lineNum">      19 </span>            : //      Class for nuclear fragments formation
<span class="lineNum">      20 </span>            : //
<span class="lineNum">      21 </span>            : // ******************************************************************
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : // --- Standard libraries
<span class="lineNum">      24 </span>            : #include &lt;stdlib.h&gt;
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : // --- ROOT system
<span class="lineNum">      27 </span>            : #include &lt;TRandom.h&gt;
<span class="lineNum">      28 </span>            : #include &lt;TF1.h&gt;
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : // --- AliRoot classes
<a name="31"><span class="lineNum">      31 </span>            : #include &quot;AliZDCFragment.h&quot;</a>
<span class="lineNum">      32 </span>            :  
<a name="33"><span class="lineNum">      33 </span><span class="lineCov">         12 : ClassImp(AliZDCFragment)</span></a>
<span class="lineNum">      34 </span>            :    
<span class="lineNum">      35 </span><span class="lineNoCov">          0 : int comp(const void *i,const void *j) {return *(int *)i - *(int *)j;}</span>
<span class="lineNum">      36 </span>            : 
<a name="37"><span class="lineNum">      37 </span>            : </a>
<span class="lineNum">      38 </span>            : //_____________________________________________________________________________
<span class="lineNum">      39 </span><span class="lineNoCov">          0 : AliZDCFragment::AliZDCFragment():</span>
<span class="lineNum">      40 </span><span class="lineNoCov">          0 :   fB(0),</span>
<span class="lineNum">      41 </span><span class="lineNoCov">          0 :   fZbAverage(0),</span>
<span class="lineNum">      42 </span><span class="lineNoCov">          0 :   fNimf(0),</span>
<span class="lineNum">      43 </span><span class="lineNoCov">          0 :   fZmax(0),</span>
<span class="lineNum">      44 </span><span class="lineNoCov">          0 :   fTau(0),</span>
<span class="lineNum">      45 </span><span class="lineNoCov">          0 :   fNalpha(0),</span>
<span class="lineNum">      46 </span><span class="lineNoCov">          0 :   fZtot(0),</span>
<span class="lineNum">      47 </span><span class="lineNoCov">          0 :   fNtot(0)</span>
<span class="lineNum">      48 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">      49 </span>            :   //
<span class="lineNum">      50 </span>            :   // Default constructor
<span class="lineNum">      51 </span>            :   //
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :   for(Int_t i=0; i&lt;=99; i++){</span>
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :      fZZ[i] = 0;</span>
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :      fNN[i] = 0;</span>
<span class="lineNum">      55 </span>            :   }
<span class="lineNum">      56 </span><span class="lineNoCov">          0 : }</span>
<a name="57"><span class="lineNum">      57 </span>            : </a>
<span class="lineNum">      58 </span>            : //_____________________________________________________________________________
<span class="lineNum">      59 </span>            : AliZDCFragment::AliZDCFragment(Float_t b): 
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :   TNamed(&quot; &quot;,&quot; &quot;),</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :   fB(b),</span>
<span class="lineNum">      62 </span><span class="lineNoCov">          0 :   fZbAverage(0),</span>
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :   fNimf(0),</span>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :   fZmax(0),</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :   fTau(0),</span>
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :   fNalpha(0),</span>
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :   fZtot(0),</span>
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :   fNtot(0)</span>
<span class="lineNum">      69 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">      70 </span>            :   //
<span class="lineNum">      71 </span>            :   // Standard constructor
<span class="lineNum">      72 </span>            :   //
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :   for(Int_t i=0; i&lt;=99; i++){</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :      fZZ[i] = 0;</span>
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :      fNN[i] = 0;</span>
<span class="lineNum">      76 </span>            :   }
<span class="lineNum">      77 </span>            :   
<span class="lineNum">      78 </span><span class="lineNoCov">          0 : }</span>
<a name="79"><span class="lineNum">      79 </span>            : </a>
<span class="lineNum">      80 </span>            : //_____________________________________________________________________________
<span class="lineNum">      81 </span>            : void AliZDCFragment::GenerateIMF()
<span class="lineNum">      82 </span>            : {
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span>            :    // Loop variables
<span class="lineNum">      85 </span>            :   Int_t i,j;
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            :    // Coefficients of polynomial for average number of IMF
<span class="lineNum">      88 </span>            :    const Float_t  kParamNimf[5]={0.011236,1.8364,56.572,-116.24,58.289}; 
<span class="lineNum">      89 </span>            :    // Coefficients of polynomial for fluctuations on average number of IMF
<span class="lineNum">      90 </span>            :    const Float_t  kParamFluctNimf[4]={-0.13176,2.9392,-5.2147,2.3092}; 
<span class="lineNum">      91 </span>            :    // Coefficients of polynomial for average maximum Z of fragments
<span class="lineNum">      92 </span>            :    //const Float_t  kParamZmax[4]={0.16899,14.203,-2.8284,65.036}; 
<span class="lineNum">      93 </span>            :    const Float_t  kParamZmax[4]={0.16899,14.203,-2.8284,70.5}; 
<span class="lineNum">      94 </span>            :    // Coefficients of polynomial for fluctuations on maximum Z of fragments
<span class="lineNum">      95 </span>            :    const Float_t  kParamFluctZmax[5]={0.013782,-0.17282,1.5065,1.0654,-2.4317}; 
<span class="lineNum">      96 </span>            :    // Coefficients of polynomial for exponent tau of fragments Z distribution
<span class="lineNum">      97 </span>            :    const Float_t  kParamTau[3]={6.7233,-15.85,13.047};  
<span class="lineNum">      98 </span>            :    //Coefficients of polynomial for average number of alphas
<span class="lineNum">      99 </span>            :    const Float_t  kParamNalpha[4]={-0.68554,39.605,-68.311,30.165}; 
<span class="lineNum">     100 </span>            :    // Coefficients of polynomial for fluctuations on average number of alphas
<span class="lineNum">     101 </span>            :    const Float_t  kParamFluctNalpha[5]={0.283,6.2141,-17.113,17.394,-6.6084}; 
<span class="lineNum">     102 </span>            :    // Coefficients of function for Pb nucleus skin
<span class="lineNum">     103 </span>            :    const Float_t  kParamSkinPb[2]={0.762408, 20.};
<span class="lineNum">     104 </span>            :    
<span class="lineNum">     105 </span>            :    // Thickness of nuclear surface
<span class="lineNum">     106 </span>            :    //const Float_t  kNuclearThick = 0.52;
<span class="lineNum">     107 </span>            :    // Maximum impact parameter for U [r0*A**(1/3)]
<span class="lineNum">     108 </span>            :    const Float_t  kbMaxU = 14.87;
<span class="lineNum">     109 </span>            :    // Maximum impact parameter for Pb [r0*A**(1/3)]
<span class="lineNum">     110 </span>            :    //const Float_t  kbMaxPb = 14.22+4*kNuclearThick;
<span class="lineNum">     111 </span>            :    const Float_t  kbMaxPb = 14.22;
<span class="lineNum">     112 </span>            :    // Z of the projectile
<span class="lineNum">     113 </span>            :    const Float_t  kZProj = 82.;
<span class="lineNum">     114 </span>            :    
<span class="lineNum">     115 </span>            :    // From b(Pb) to b(U)
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :    if(fB&gt;kbMaxPb) fB = 2*kbMaxPb-fB;</span>
<span class="lineNum">     117 </span>            :    
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :    Float_t  bU = fB*kbMaxU/kbMaxPb;</span>
<span class="lineNum">     119 </span>            :     
<span class="lineNum">     120 </span>            :    // From b(U) to Zbound(U) 
<span class="lineNum">     121 </span>            :    // --- A.Schuttauf et al, Nuc.Phys. A607 (1996) 457 ---------------
<span class="lineNum">     122 </span>            :    // From geometrical consideration and from dsigma/dZbound for U+U,
<span class="lineNum">     123 </span>            :    // which is approx. constant, the constant value is found  
<span class="lineNum">     124 </span>            :    // integrating the nucleus cross surface from 0 to bmax=R1+R2 where 
<span class="lineNum">     125 </span>            :    // R = 1.2*A**(1/3). This value has been measured in Aladin (U+U).
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :    Float_t  zbU = bU*bU*TMath::Pi()/7.48;</span>
<span class="lineNum">     127 </span>            :    
<span class="lineNum">     128 </span>            :    //  Rescale Zbound for Pb
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :    fZbAverage = kZProj/92.*zbU;</span>
<span class="lineNum">     130 </span>            :    
<span class="lineNum">     131 </span>            :    // Zbound is proportional to b**2 up to b &lt; kbMaxPb-2*kNuclearThick
<span class="lineNum">     132 </span>            :    // and then it is an increasing exponential, imposing that at 
<span class="lineNum">     133 </span>            :    // b=kbMaxPb-2kNuclearThick the two functions have the same derivative
<span class="lineNum">     134 </span>            :    //Float_t bCore = kbMaxPb-2*kNuclearThick;
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :    if(fB&gt;kbMaxPb){</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :      fZbAverage = TMath::Exp(-kParamSkinPb[0]*(fB-kParamSkinPb[1]));</span>
<span class="lineNum">     137 </span>            :      //printf(&quot; b = %1.2f fm   Z_bound %1.2f\n&quot;, fB, fZbAverage);
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :    }</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :    if(fZbAverage&gt;kZProj) fZbAverage = kZProj;</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :    Float_t zbNorm = fZbAverage/kZProj;</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :    Float_t bNorm = fB/kbMaxPb;</span>
<span class="lineNum">     142 </span>            :    
<span class="lineNum">     143 </span>            :    // From Zbound to &lt;Nimf&gt;,&lt;Zmax&gt;,tau
<span class="lineNum">     144 </span>            :    // Polinomial fits to Aladin distribution
<span class="lineNum">     145 </span>            :    // --- A.Schuttauf et al, Nuc.Phys. A607 (1996) 457.
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :    Float_t averageNimf = kParamNimf[0]+kParamNimf[1]*zbNorm+kParamNimf[2]*</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :            TMath::Power(zbNorm,2)+kParamNimf[3]*TMath::Power(zbNorm,3)+</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :            kParamNimf[4]*TMath::Power(zbNorm,4);</span>
<span class="lineNum">     149 </span>            :    
<span class="lineNum">     150 </span>            :    // Add fluctuation: from Singh et al. 
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :    Float_t fluctNimf = kParamFluctNimf[0]+kParamFluctNimf[1]*zbNorm+</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :            kParamFluctNimf[2]*TMath::Power(zbNorm,2)+kParamFluctNimf[3]</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :            *TMath::Power(zbNorm,3);</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :    Float_t xx = gRandom-&gt;Gaus(0.0,1.0);</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :    fluctNimf = fluctNimf*xx;</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :    fNimf = Int_t(averageNimf+fluctNimf);</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :    Float_t y = gRandom-&gt;Rndm();</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :    if(y &lt; ((averageNimf+fluctNimf)-fNimf)) fNimf += 1;</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :    if(fNimf ==0 &amp;&amp; zbNorm&gt;0.75) fNimf = 1;</span>
<span class="lineNum">     160 </span>            :    
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :    Float_t averageZmax = kParamZmax[0]+kParamZmax[1]*zbNorm+kParamZmax[2]*</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :            TMath::Power(zbNorm,2)+kParamZmax[3]*TMath::Power(zbNorm,3);</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :    fTau = kParamTau[0]+kParamTau[1]*zbNorm+kParamTau[2]*TMath::Power(zbNorm,2);</span>
<span class="lineNum">     164 </span>            :    
<span class="lineNum">     165 </span>            :    // Add fluctuation to mean value of Zmax (see Hubele)
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :    Float_t fluctZmax = kParamFluctZmax[0]+kParamFluctZmax[1]*zbNorm+</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :            kParamFluctZmax[2]*TMath::Power(zbNorm,2)+kParamFluctZmax[3]*</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :            TMath::Power(zbNorm,3)+kParamFluctZmax[4]*TMath::Power(zbNorm,4);</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :    fluctZmax = fluctZmax*kZProj/6.;</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :    Float_t xg = gRandom-&gt;Gaus(0.0,1.0);</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :    fluctZmax = fluctZmax*xg;</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :    fZmax = (averageZmax+fluctZmax);</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :    if(fZmax&gt;kZProj) fZmax = kZProj;</span>
<span class="lineNum">     174 </span>            :    
<span class="lineNum">     175 </span>            : //   printf(&quot;\n\n ------------------------------------------------------------&quot;);   
<span class="lineNum">     176 </span>            : //   printf(&quot;\n Generation of nuclear fragments\n&quot;);   
<span class="lineNum">     177 </span>            : //   printf(&quot;\n fNimf = %d\n&quot;, fNimf);   
<span class="lineNum">     178 </span>            : //   printf(&quot;\n fZmax = %f\n&quot;, fZmax); 
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span>            :    // Find the number of alpha particles 
<span class="lineNum">     181 </span>            :    // from Singh et al. : Pb+emulsion
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :    Float_t averageAlpha = kParamNalpha[0]+kParamNalpha[1]*zbNorm+</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :            kParamNalpha[2]*TMath::Power(zbNorm,2)+kParamNalpha[3]*</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :            TMath::Power(zbNorm,3);</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :    Float_t fluctAlpha = kParamFluctNalpha[0]+kParamFluctNalpha[1]*</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :            zbNorm+kParamFluctNalpha[2]*TMath::Power(zbNorm,2)+</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :            kParamFluctNalpha[3]*TMath::Power(zbNorm,3)+</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :            kParamFluctNalpha[4]*TMath::Power(zbNorm,4);</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :    Float_t xxx = gRandom-&gt;Gaus(0.0,1.0);</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :    fluctAlpha = fluctAlpha*xxx;</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :    fNalpha = Int_t(averageAlpha+fluctAlpha);</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :    Float_t yy = gRandom-&gt;Rndm();</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :    if(yy &lt; ((averageAlpha+fluctAlpha)-fNalpha)) fNalpha += 1;</span>
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            :    // 2 possibilities:
<span class="lineNum">     196 </span>            :    // 1) for bNorm &lt; 0.9 ==&gt; first remove alphas, then fragments
<span class="lineNum">     197 </span>            :    // 2) for bNorm &gt; 0.9 ==&gt; first remove fragments, then alphas
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span>            :    Int_t choice = 0;
<span class="lineNum">     200 </span>            :    Float_t zbFrag = 0, sumZ = 0.;
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :    if(bNorm&lt;=0.9) {</span>
<span class="lineNum">     203 </span>            :    // remove alpha from zbound to find zbound for fragments  (Z&gt;=3)
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :      zbFrag = fZbAverage-fNalpha*2;</span>
<span class="lineNum">     205 </span>            :      choice = 1;
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :    }</span>
<span class="lineNum">     207 </span>            :    else {
<span class="lineNum">     208 </span>            :      zbFrag = fZbAverage;
<span class="lineNum">     209 </span>            :      choice = 0;
<span class="lineNum">     210 </span>            :    }
<span class="lineNum">     211 </span>            : //   printf(&quot;\n choice = %d, fZbAverage = %f, zbFrag = %f \n&quot;, choice, fZbAverage, zbFrag);
<span class="lineNum">     212 </span>            :    
<span class="lineNum">     213 </span>            :    
<span class="lineNum">     214 </span>            :    // Check if zbFrag &lt; fZmax
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :    if(zbFrag&lt;=fZmax) {</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :      if(fNimf&gt;0 &amp;&amp; zbFrag&gt;=2){</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :        fNimf = 1;</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :        fZZ[0] = Int_t(zbFrag);</span>
<span class="lineNum">     219 </span>            :        sumZ = zbFrag;
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :      }</span>
<span class="lineNum">     221 </span>            :      else {
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :        fNimf = 0;</span>
<span class="lineNum">     223 </span>            :      }
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :      return;</span>
<span class="lineNum">     225 </span>            :    }
<span class="lineNum">     226 </span>            :    
<span class="lineNum">     227 </span>            :    // Prepare the exponential charge distribution dN/dZ
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :    if(fZmax &lt;= 0.01) {</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :      fNimf = 0;</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :      return;</span>
<span class="lineNum">     231 </span>            :    }
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :    if(fNimf == 0) {</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :      fNimf = 0;</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :      return;</span>
<span class="lineNum">     235 </span>            :    }
<span class="lineNum">     236 </span>            :    
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :    TF1 *funTau = new TF1(&quot;funTau&quot;,&quot;1./(x**[0])&quot;,0.01,fZmax);</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :    funTau-&gt;SetParameter(0,fTau);</span>
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            :    // Extract randomly the charge of the fragments from the distribution
<span class="lineNum">     241 </span>            :  
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :    Float_t * zz = new Float_t[fNimf];</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :    for(j=0; j&lt;fNimf; j++){</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :       zz[j] =0;</span>
<span class="lineNum">     245 </span>            :    }
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :    for(i=0; i&lt;fNimf; i++){</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :       zz[i] = Float_t(funTau-&gt;GetRandom());</span>
<span class="lineNum">     248 </span>            : //      printf(&quot;\n zz[%d] = %f \n&quot;,i,zz[i]);
<span class="lineNum">     249 </span>            :    }
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :    delete funTau;</span>
<span class="lineNum">     251 </span>            :    
<span class="lineNum">     252 </span>            :    // Sorting vector in ascending order with C function QSORT 
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :    qsort((void*)zz,fNimf,sizeof(Float_t),comp);</span>
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            :    
<span class="lineNum">     256 </span>            : //   for(Int_t i=0; i&lt;fNimf; i++){
<span class="lineNum">     257 </span>            : //      printf(&quot;\n After sorting -&gt; zz[%d] = %f \n&quot;,i,zz[i]);
<span class="lineNum">     258 </span>            : //   }
<span class="lineNum">     259 </span>            :    
<span class="lineNum">     260 </span>            :    // Rescale the maximum charge to fZmax
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :    for(j=0; j&lt;fNimf; j++){</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :      fZZ[j] = Int_t (zz[j]*fZmax/zz[fNimf-1]);</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :      if(fZZ[j]&lt;3) fZZ[j] = 3;</span>
<span class="lineNum">     264 </span>            : //     printf(&quot;\n  fZZ[%d] = %d \n&quot;,j,fZZ[j]);
<span class="lineNum">     265 </span>            :    }
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :    delete[] zz;</span>
<span class="lineNum">     268 </span>            :    
<span class="lineNum">     269 </span>            :    // Check that the sum of the bound charges is not &gt; than Zbound-Zalfa
<span class="lineNum">     270 </span>            :    
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :    for(Int_t ii=0; ii&lt;fNimf; ii++){</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :      sumZ += fZZ[ii];</span>
<span class="lineNum">     273 </span>            :    }
<span class="lineNum">     274 </span>            :    
<span class="lineNum">     275 </span>            :    Int_t k = 0;
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :    if(sumZ&gt;zbFrag){</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :      for(i=0; i&lt; fNimf; i++){</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :        k += 1;</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :        sumZ -= fZZ[i];</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :        if(sumZ&lt;=zbFrag){</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :          fNimf -= (i+1);</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :          break;</span>
<span class="lineNum">     283 </span>            :        }
<span class="lineNum">     284 </span>            :      }
<span class="lineNum">     285 </span>            :    }
<span class="lineNum">     286 </span>            :    else {
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :      if(choice == 1) return;</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :      Int_t iDiff = Int_t((zbFrag-sumZ)/2);</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :      if(iDiff&lt;fNalpha){</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :        fNalpha=iDiff;</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :        return;</span>
<span class="lineNum">     292 </span>            :      }
<span class="lineNum">     293 </span>            :      else{
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :        return;</span>
<span class="lineNum">     295 </span>            :      }
<span class="lineNum">     296 </span>            :    }
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :    fNimf += k;</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :    for(i=0; i&lt;fNimf; i++){</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :      fZZ[i] = fZZ[i+k];</span>
<span class="lineNum">     301 </span>            :    }
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :    fNimf -= k;</span>
<span class="lineNum">     303 </span>            :    
<span class="lineNum">     304 </span>            :    sumZ=0;
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :    for(i=0; i&lt;fNimf; i++){</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :      sumZ += fZZ[i];</span>
<span class="lineNum">     307 </span>            :    }
<span class="lineNum">     308 </span>            :    
<span class="lineNum">     309 </span><span class="lineNoCov">          0 : }</span>
<a name="310"><span class="lineNum">     310 </span>            : </a>
<span class="lineNum">     311 </span>            : //_____________________________________________________________________________
<span class="lineNum">     312 </span>            : void AliZDCFragment::AttachNeutrons()
<span class="lineNum">     313 </span>            : {
<span class="lineNum">     314 </span>            : //
<span class="lineNum">     315 </span>            : // Prepare nuclear fragment by attaching a suitable number of neutrons
<span class="lineNum">     316 </span>            : //
<span class="lineNum">     317 </span>            :    const Float_t kAIon[68]={1.87612,2.80943,3.7284,5.60305,6.53536,
<span class="lineNum">     318 </span>            :                      6.53622,8.39479,9.32699,10.2551,11.17793,
<span class="lineNum">     319 </span>            :                      13.04378,14.89917,17.6969,18.62284,21.41483,
<span class="lineNum">     320 </span>            :                      22.34193,25.13314,26.06034,28.85188,29.7818,
<span class="lineNum">     321 </span>            :                      32.57328,33.50356,36.29447,37.22492,41.87617,
<span class="lineNum">     322 </span>            :                      44.66324,47.45401,48.38228,51.17447,52.10307,
<span class="lineNum">     323 </span>            :                      54.89593,53.96644,58.61856,59.54963,68.85715,
<span class="lineNum">     324 </span>            :                      74.44178,78.16309,81.88358,83.74571,91.19832,
<span class="lineNum">     325 </span>            :                      98.64997,106.10997,111.68821,122.86796,
<span class="lineNum">     326 </span>            :                      128.45793,
<span class="lineNum">     327 </span>            :                      130.32111,141.51236,
<span class="lineNum">     328 </span>            :                      141.55,146.477,148.033,152.699,153.631,
<span class="lineNum">     329 </span>            :                      155.802,157.357,162.022,162.984,166.2624,
<span class="lineNum">     330 </span>            :                      168.554,171.349,173.4536,177.198,179.0518,
<span class="lineNum">     331 </span>            :                      180.675,183.473,188.1345,190.77,193.729,
<span class="lineNum">     332 </span>            :                      221.74295};
<span class="lineNum">     333 </span>            :    const Int_t kZIon[68]={1,1,2,3,3,
<span class="lineNum">     334 </span>            :                      4,4,5,5,6,
<span class="lineNum">     335 </span>            :                      7,8,9,10,11,
<span class="lineNum">     336 </span>            :                      12,13,14,15,16,
<span class="lineNum">     337 </span>            :                      17,18,19,20,21,
<span class="lineNum">     338 </span>            :                      22,23,24,25,26,
<span class="lineNum">     339 </span>            :                      27,28,29,30,32,
<span class="lineNum">     340 </span>            :                      34,36,38,40,42,
<span class="lineNum">     341 </span>            :                      46,48,50,54,56,
<span class="lineNum">     342 </span>            :                      58,62,
<span class="lineNum">     343 </span>            :                      63,64,65,66,67,
<span class="lineNum">     344 </span>            :                      68,69,70,71,72,
<span class="lineNum">     345 </span>            :                      73,74,75,76,77,
<span class="lineNum">     346 </span>            :                      78,79,80,81,82,
<span class="lineNum">     347 </span>            :                      92};
<span class="lineNum">     348 </span>            :     
<span class="lineNum">     349 </span>            :    Int_t iZ, iA;  
<span class="lineNum">     350 </span>            : //   printf(&quot;\n fNimf=%d\n&quot;,fNimf);  
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :    for(Int_t i=0; i&lt;fNimf; i++) {</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :       for(Int_t j=0; j&lt;68; j++) {</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :         iZ = kZIon[j];</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :         if((fZZ[i]-iZ) == 0){</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :           iA = Int_t(kAIon[j]/0.93149432+0.5);</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :           fNN[i] = iA - iZ;</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     359 </span>            :         }
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :         else if((fZZ[i]-iZ) &lt; 0){</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :           fZZ[i] = kZIon[j-1];</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :           iA = Int_t (kAIon[j-1]/0.93149432+0.5);</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :           fNN[i] = iA - kZIon[j-1];</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     365 </span>            :         }
<span class="lineNum">     366 </span>            :       }
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :       fZtot += fZZ[i];</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :       fNtot += fNN[i];</span>
<span class="lineNum">     369 </span>            :    }                 
<span class="lineNum">     370 </span>            :    
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span><span class="lineNoCov">          0 : }</span>
<a name="373"><span class="lineNum">     373 </span>            : </a>
<span class="lineNum">     374 </span>            : //_____________________________________________________________________________
<span class="lineNum">     375 </span>            : Float_t AliZDCFragment::DeuteronNumber()
<span class="lineNum">     376 </span>            : {
<span class="lineNum">     377 </span>            :     // Calculates the fraction of deuterum nucleus produced
<span class="lineNum">     378 </span>            :     //
<span class="lineNum">     379 </span>            :     Float_t deuteronProdPar[2] = {-0.068,0.0385};
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :     Float_t deutNum = deuteronProdPar[0] + deuteronProdPar[1]*fB;</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :     if(deutNum&lt;0.) deutNum = 0.;</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     return deutNum;</span>
<span class="lineNum">     383 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
