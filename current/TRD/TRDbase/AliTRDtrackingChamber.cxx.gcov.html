<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - TRD/TRDbase/AliTRDtrackingChamber.cxx</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">TRD/TRDbase</a> - AliTRDtrackingChamber.cxx<span style="font-size: 80%;"> (source / <a href="AliTRDtrackingChamber.cxx.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">39</td>
            <td class="headerCovTableEntry">209</td>
            <td class="headerCovTableEntryLo">18.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">6</td>
            <td class="headerCovTableEntry">12</td>
            <td class="headerCovTableEntryLo">50.0 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**************************************************************************</a>
<span class="lineNum">       2 </span>            : * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
<span class="lineNum">       3 </span>            : *                                                                        *
<span class="lineNum">       4 </span>            : * Author: The ALICE Off-line Project.                                    *
<span class="lineNum">       5 </span>            : * Contributors are mentioned in the code where appropriate.              *
<span class="lineNum">       6 </span>            : *                                                                        *
<span class="lineNum">       7 </span>            : * Permission to use, copy, modify and distribute this software and its   *
<span class="lineNum">       8 </span>            : * documentation strictly for non-commercial purposes is hereby granted   *
<span class="lineNum">       9 </span>            : * without fee, provided that the above copyright notice appears in all   *
<span class="lineNum">      10 </span>            : * copies and that both the copyright notice and this permission notice   *
<span class="lineNum">      11 </span>            : * appear in the supporting documentation. The authors make no claims     *
<span class="lineNum">      12 </span>            : * about the suitability of this software for any purpose. It is          *
<span class="lineNum">      13 </span>            : * provided &quot;as is&quot; without express or implied warranty.                  *
<span class="lineNum">      14 </span>            : **************************************************************************/
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : /* $Id: AliTRDtrackingChamber.cxx 23810 2008-02-08 09:00:27Z hristov $ */
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : ////////////////////////////////////////////////////////////////////////////
<span class="lineNum">      19 </span>            : //                                                                        //
<span class="lineNum">      20 </span>            : //  Tracking in one chamber                                               //
<span class="lineNum">      21 </span>            : //                                                                        //
<span class="lineNum">      22 </span>            : //  Authors:                                                              //
<span class="lineNum">      23 </span>            : //    Alex Bercuci &lt;A.Bercuci@gsi.de&gt;                                     //
<span class="lineNum">      24 </span>            : //    Markus Fasel &lt;M.Fasel@gsi.de&gt;                                       //
<span class="lineNum">      25 </span>            : //                                                                        //
<span class="lineNum">      26 </span>            : ////////////////////////////////////////////////////////////////////////////
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : #include &quot;AliTRDtrackingChamber.h&quot;
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : #include &quot;TMath.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;TMatrixTBase.h&quot;
<span class="lineNum">      32 </span>            : #include &lt;TTreeStream.h&gt;
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : #include &quot;AliTRDReconstructor.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;AliTRDrecoParam.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;AliTRDtrackerV1.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;AliTRDgeometry.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;AliTRDpadPlane.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;AliTRDcalibDB.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;AliTRDCommonParam.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;AliTRDCalDet.h&quot;
<a name="42"><span class="lineNum">      42 </span>            : #include &quot;AliTRDCalROC.h&quot;</a>
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span><span class="lineCov">         48 : ClassImp(AliTRDtrackingChamber)</span>
<a name="45"><span class="lineNum">      45 </span>            : </a>
<span class="lineNum">      46 </span>            : //_______________________________________________________
<span class="lineNum">      47 </span><span class="lineCov">      21987 : AliTRDtrackingChamber::AliTRDtrackingChamber() </span>
<span class="lineNum">      48 </span><span class="lineCov">        349 :   :TObject()</span>
<span class="lineNum">      49 </span><span class="lineCov">        349 :   ,fDetector(-1)</span>
<span class="lineNum">      50 </span><span class="lineCov">        349 :   ,fX0(0.)</span>
<span class="lineNum">      51 </span>            :   // ,fExB(0.)
<span class="lineNum">      52 </span>            :   // ,fVD(0.)
<span class="lineNum">      53 </span>            :   // ,fT0(0.)
<span class="lineNum">      54 </span>            :   // ,fS2PRF(0.)
<span class="lineNum">      55 </span>            :   // ,fDiffL(0.)
<span class="lineNum">      56 </span>            :   // ,fDiffT(0.)
<span class="lineNum">      57 </span><span class="lineCov">       2094 : {}  </span>
<a name="58"><span class="lineNum">      58 </span>            : </a>
<span class="lineNum">      59 </span>            : //_______________________________________________________
<span class="lineNum">      60 </span>            : void AliTRDtrackingChamber::Clear(const Option_t *opt)
<span class="lineNum">      61 </span>            : {
<span class="lineNum">      62 </span><span class="lineCov">      22685 :   for(Int_t itb=0; itb&lt;AliTRDseedV1::kNtb; itb++) fTB[itb].Clear(opt);</span>
<span class="lineNum">      63 </span><span class="lineCov">        349 : }</span>
<a name="64"><span class="lineNum">      64 </span>            : </a>
<span class="lineNum">      65 </span>            : //_______________________________________________________
<span class="lineNum">      66 </span>            : Bool_t AliTRDtrackingChamber::Build(AliTRDgeometry *const geo, Bool_t hlt)
<span class="lineNum">      67 </span>            : {
<span class="lineNum">      68 </span>            : // Init chamber and all time bins (AliTRDchamberTimeBin)
<span class="lineNum">      69 </span>            : // Calculates radial position of the chamber based on 
<span class="lineNum">      70 </span>            : // radial positions of the time bins (calibration/alignment aware)
<span class="lineNum">      71 </span>            : //
<span class="lineNum">      72 </span><span class="lineCov">        698 :   if(fDetector &lt; 0 || fDetector &gt;= AliTRDgeometry::kNdet){</span>
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :     AliWarning(Form(&quot;Detector index not set correctly to %d&quot;, fDetector));</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :     return kFALSE;</span>
<span class="lineNum">      75 </span>            :   }
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span><span class="lineCov">        349 :   Int_t stack = AliTRDgeometry::GetStack(fDetector);</span>
<span class="lineNum">      78 </span><span class="lineCov">        349 :   Int_t layer = AliTRDgeometry::GetLayer(fDetector);</span>
<span class="lineNum">      79 </span><span class="lineCov">        349 :   AliTRDpadPlane *pp = geo-&gt;GetPadPlane(layer, stack);</span>
<span class="lineNum">      80 </span><span class="lineCov">        349 :   Double_t zl = pp-&gt;GetRow0ROC() - pp-&gt;GetRowEndROC();</span>
<span class="lineNum">      81 </span><span class="lineCov">        349 :   Double_t z0 = geo-&gt;GetRow0(layer, stack, 0) - zl;</span>
<span class="lineNum">      82 </span><span class="lineCov">        349 :   Int_t nrows = pp-&gt;GetNrows();</span>
<span class="lineNum">      83 </span>            :   
<span class="lineNum">      84 </span><span class="lineCov">        349 :   Int_t index[50], jtb = 0;</span>
<span class="lineNum">      85 </span><span class="lineCov">      22336 :   for(Int_t itb=0; itb&lt;AliTRDseedV1::kNtb; itb++){ </span>
<span class="lineNum">      86 </span><span class="lineCov">      10819 :     if(!fTB[itb]) continue;</span>
<span class="lineNum">      87 </span><span class="lineCov">       7797 :     fTB[itb].SetRange(z0, zl);</span>
<span class="lineNum">      88 </span><span class="lineCov">       7797 :     fTB[itb].SetNRows(nrows);</span>
<span class="lineNum">      89 </span><span class="lineCov">       7797 :     fTB[itb].SetPlane(layer);</span>
<span class="lineNum">      90 </span><span class="lineCov">       7797 :     fTB[itb].SetStack(stack);</span>
<span class="lineNum">      91 </span><span class="lineCov">       7797 :     fTB[itb].SetSector(AliTRDgeometry::GetSector(fDetector));</span>
<span class="lineNum">      92 </span><span class="lineCov">       7797 :     fTB[itb].BuildIndices();</span>
<span class="lineNum">      93 </span><span class="lineCov">       7797 :     index[jtb++] = itb;</span>
<span class="lineNum">      94 </span><span class="lineCov">       7797 :   }     </span>
<span class="lineNum">      95 </span><span class="lineCov">        351 :   if(jtb&lt;2) return kFALSE;</span>
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span><span class="lineCov">        347 :   AliTRDcalibDB *calib = AliTRDcalibDB::Instance();</span>
<span class="lineNum">      98 </span>            :   Float_t t0;
<span class="lineNum">      99 </span><span class="lineCov">        347 :   if(!hlt){</span>
<span class="lineNum">     100 </span><span class="lineCov">        347 :     t0    = calib-&gt;GetT0Average(fDetector);</span>
<span class="lineNum">     101 </span><span class="lineCov">        347 :   }else{</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :     t0    = calib-&gt;GetT0Det()-&gt;GetValue(fDetector);</span>
<span class="lineNum">     103 </span>            :   }
<span class="lineNum">     104 </span>            :   // fVD    = calib-&gt;GetVdriftAverage(fDetector);
<span class="lineNum">     105 </span>            :   // fS2PRF = calib-&gt;GetPRFROC(fDetector)-&gt;GetMean(); fS2PRF *= fS2PRF;
<span class="lineNum">     106 </span>            :   // fExB   = AliTRDCommonParam::Instance()-&gt;GetOmegaTau(fVD);
<span class="lineNum">     107 </span>            :   // AliTRDCommonParam::Instance()-&gt;GetDiffCoeff(fDiffL, fDiffT, fVD);  
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            :   // ESTIMATE POSITION OF PAD PLANE FOR THIS CHAMBER
<span class="lineNum">     110 </span>            :   //fTB[Int_t(t0)].SetT0();
<span class="lineNum">     111 </span><span class="lineCov">        347 :   Double_t x0 = fTB[index[0]].GetX();</span>
<span class="lineNum">     112 </span><span class="lineCov">        347 :   Double_t x1 = fTB[index[1]].GetX();</span>
<span class="lineNum">     113 </span><span class="lineCov">        347 :   Double_t dx = (x0 - x1)/(index[1] - index[0]); </span>
<span class="lineNum">     114 </span><span class="lineCov">        347 :   fX0 = x0 + dx*(index[0] - t0);        </span>
<span class="lineNum">     115 </span>            :   return kTRUE;
<span class="lineNum">     116 </span><span class="lineCov">        698 : }</span>
<a name="117"><span class="lineNum">     117 </span>            : </a>
<span class="lineNum">     118 </span>            : //_______________________________________________________       
<span class="lineNum">     119 </span>            : Int_t AliTRDtrackingChamber::GetNClusters() const
<span class="lineNum">     120 </span>            : {
<span class="lineNum">     121 </span>            : // Basic loop method
<span class="lineNum">     122 </span>            : // Returns number of clusters in chamber
<span class="lineNum">     123 </span>            : //
<span class="lineNum">     124 </span>            :   Int_t n = 0;
<span class="lineNum">     125 </span><span class="lineCov">      17160 :   for(Int_t itb=0; itb&lt;AliTRDseedV1::kNtb; itb++){ </span>
<span class="lineNum">     126 </span><span class="lineCov">       8184 :     n += Int_t(fTB[itb]);</span>
<span class="lineNum">     127 </span>            :   }
<span class="lineNum">     128 </span><span class="lineCov">        264 :   return n;     </span>
<span class="lineNum">     129 </span>            : }       
<a name="130"><span class="lineNum">     130 </span>            : </a>
<span class="lineNum">     131 </span>            : //_______________________________________________________
<span class="lineNum">     132 </span>            : void AliTRDtrackingChamber::Bootstrap(const AliTRDReconstructor *rec)
<span class="lineNum">     133 </span>            : {
<span class="lineNum">     134 </span>            : // Basic loop method
<span class="lineNum">     135 </span>            : // Bootstrap each time bin
<span class="lineNum">     136 </span>            : //
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :   AliTRDchamberTimeBin *jtb = &amp;fTB[0];</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :   for(Int_t itb=0; itb&lt;AliTRDseedV1::kNtb; itb++, ++jtb){ </span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :     (*jtb).Bootstrap(rec, fDetector);</span>
<span class="lineNum">     140 </span>            :   }
<span class="lineNum">     141 </span><span class="lineNoCov">          0 : }</span>
<a name="142"><span class="lineNum">     142 </span>            : </a>
<span class="lineNum">     143 </span>            : //_______________________________________________________
<span class="lineNum">     144 </span>            : void  AliTRDtrackingChamber::SetOwner()
<span class="lineNum">     145 </span>            : {
<span class="lineNum">     146 </span>            : // Basic loop method
<span class="lineNum">     147 </span>            : // Set ownership in time bins
<span class="lineNum">     148 </span>            : //
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :   AliTRDchamberTimeBin *jtb = &amp;fTB[0];</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :   for(Int_t itb=0; itb&lt;AliTRDseedV1::kNtb; itb++, ++jtb){ </span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :     if(!(Int_t(*jtb))) continue;</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :     (*jtb).SetOwner();</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 : }</span>
<a name="155"><span class="lineNum">     155 </span>            : </a>
<span class="lineNum">     156 </span>            : //_______________________________________________________
<span class="lineNum">     157 </span>            : Double_t AliTRDtrackingChamber::GetQuality()
<span class="lineNum">     158 </span>            : {
<span class="lineNum">     159 </span>            :   //
<span class="lineNum">     160 </span>            :   // Calculate chamber quality for seeding.
<span class="lineNum">     161 </span>            :   // 
<span class="lineNum">     162 </span>            :   //
<span class="lineNum">     163 </span>            :   // Parameters :
<span class="lineNum">     164 </span>            :   //   layers : Array of propagation layers for this plane.
<span class="lineNum">     165 </span>            :   //
<span class="lineNum">     166 </span>            :   // Output :
<span class="lineNum">     167 </span>            :   //   plane quality factor for seeding
<span class="lineNum">     168 </span>            :   // 
<span class="lineNum">     169 </span>            :   // Detailed description
<span class="lineNum">     170 </span>            :   //
<span class="lineNum">     171 </span>            :   // The quality of the plane for seeding is higher if:
<span class="lineNum">     172 </span>            :   //  1. the average timebin population is closer to an integer number
<span class="lineNum">     173 </span>            :   //  2. the distribution of clusters/timebin is closer to a uniform distribution.
<span class="lineNum">     174 </span>            :   //    - the slope of the first derivative of a parabolic fit is small or
<span class="lineNum">     175 </span>            :   //    - the slope of a linear fit is small
<span class="lineNum">     176 </span>            :   //
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            :   Int_t ncl   = 0;
<span class="lineNum">     179 </span>            :   Int_t nused = 0;
<span class="lineNum">     180 </span>            :   Int_t nClLayer;
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :   for(int itb=0; itb&lt;AliTRDseedV1::kNtb; itb++){</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :     if(!(nClLayer = fTB[itb].GetNClusters())) continue;</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :     ncl += nClLayer;</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :     for(Int_t incl = 0; incl &lt; nClLayer; incl++){</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :       if((fTB[itb].GetCluster(incl))-&gt;IsUsed()) nused++;</span>
<span class="lineNum">     186 </span>            :     }
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     188 </span>            :   
<span class="lineNum">     189 </span>            :   // calculate the deviation of the mean number of clusters from the
<span class="lineNum">     190 </span>            :   // closest integer values
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :   Float_t nclMed = float(ncl-nused)/AliTRDtrackerV1::GetNTimeBins();</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :   Int_t ncli = Int_t(nclMed);</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :   Float_t nclDev = TMath::Abs(nclMed - TMath::Max(ncli, 1));</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :   nclDev -= (nclDev&gt;.5) &amp;&amp; ncli ? 1. : 0.;</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :   return TMath::Exp(-5.*TMath::Abs(nclDev));</span>
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span>            : //      // get slope of the derivative
<span class="lineNum">     198 </span>            : //      if(!fitter.Eval()) return quality;
<span class="lineNum">     199 </span>            : //      fitter.PrintResults(3);
<span class="lineNum">     200 </span>            : //      Double_t a = fitter.GetParameter(1);
<span class="lineNum">     201 </span>            : // 
<span class="lineNum">     202 </span>            : //      printf(&quot;ncl_dev(%f)  a(%f)\n&quot;, ncl_dev, a);
<span class="lineNum">     203 </span>            : //      return quality*TMath::Exp(-a);
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span>            : }
<span class="lineNum">     206 </span>            : 
<a name="207"><span class="lineNum">     207 </span>            : </a>
<span class="lineNum">     208 </span>            : //_______________________________________________________
<span class="lineNum">     209 </span>            : Bool_t AliTRDtrackingChamber::GetSeedingLayer(AliTRDchamberTimeBin *&amp;fakeLayer, AliTRDgeometry * const geo, const AliTRDReconstructor *rec)
<span class="lineNum">     210 </span>            : {
<span class="lineNum">     211 </span>            :   //
<span class="lineNum">     212 </span>            :   // Creates a seeding layer
<span class="lineNum">     213 </span>            :   //
<span class="lineNum">     214 </span>            :   
<span class="lineNum">     215 </span>            :   // constants
<span class="lineNum">     216 </span>            :   const Int_t kMaxRows = 16;
<span class="lineNum">     217 </span>            :   const Int_t kMaxCols = 144;
<span class="lineNum">     218 </span>            :   const Int_t kMaxPads = 2304;
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :   Int_t timeBinMin = rec-&gt;GetRecoParam()-&gt;GetNumberOfPresamples();</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :   Int_t timeBinMax = rec-&gt;GetRecoParam()-&gt;GetNumberOfPostsamples();</span>
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            :   // Get the geometrical data of the chamber
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :   Int_t layer = geo-&gt;GetLayer(fDetector);</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :   Int_t stack = geo-&gt;GetStack(fDetector);</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :   Int_t sector= geo-&gt;GetSector(fDetector);</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :   AliTRDpadPlane *pp = geo-&gt;GetPadPlane(layer, stack);</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :   Int_t nCols = pp-&gt;GetNcols();</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :   Float_t ymin = TMath::Min(pp-&gt;GetCol0(), pp-&gt;GetColEnd());</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :   Float_t ymax = TMath::Max(pp-&gt;GetCol0(), pp-&gt;GetColEnd());</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :   Float_t zmin = TMath::Min(pp-&gt;GetRow0(), pp-&gt;GetRowEnd());</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :   Float_t zmax = TMath::Max(pp-&gt;GetRow0(), pp-&gt;GetRowEnd());</span>
<span class="lineNum">     232 </span>            :   Float_t z0 = -1., zl = -1.;
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :   Int_t nRows = pp-&gt;GetNrows();</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :   Float_t binlength = (ymax - ymin)/nCols; </span>
<span class="lineNum">     235 </span>            :   //AliInfo(Form(&quot;ymin(%f) ymax(%f) zmin(%f) zmax(%f) nRows(%d) binlength(%f)&quot;, ymin, ymax, zmin, zmax, nRows, binlength));
<span class="lineNum">     236 </span>            :   
<span class="lineNum">     237 </span>            :   // Fill the histogram
<span class="lineNum">     238 </span>            :   Int_t nClusters;      
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :   Int_t *histogram[kMaxRows];                                                                                   // 2D-Histogram</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :   Int_t hvals[kMaxPads + 1];    memset(hvals, 0, sizeof(Int_t)*kMaxPads);        // one entry in addition for termination flag</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :   Float_t *sigmas[kMaxRows];</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :   Float_t svals[kMaxPads];      memset(svals, 0, sizeof(Float_t)*kMaxPads);     </span>
<span class="lineNum">     243 </span>            :   AliTRDcluster *c = NULL;
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :   for(Int_t irs = 0; irs &lt; kMaxRows; irs++){</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :     histogram[irs] = &amp;hvals[irs*kMaxCols];</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :     sigmas[irs] = &amp;svals[irs*kMaxCols];</span>
<span class="lineNum">     247 </span>            :   }
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :   for(Int_t iTime = timeBinMin; iTime &lt; AliTRDseedV1::kNtb-timeBinMax; iTime++){</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :     if(!(nClusters = fTB[iTime].GetNClusters())) continue;</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :     z0 = fTB[iTime].GetZ0();</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :     zl = fTB[iTime].GetDZ0();</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :     for(Int_t incl = 0; incl &lt; nClusters; incl++){</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :       c = fTB[iTime].GetCluster(incl);  </span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :       histogram[c-&gt;GetPadRow()][c-&gt;GetPadCol()]++;</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :       sigmas[c-&gt;GetPadRow()][c-&gt;GetPadCol()] += c-&gt;GetSigmaZ2();</span>
<span class="lineNum">     256 </span>            :     }
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     258 </span>            :   
<span class="lineNum">     259 </span>            : // Now I have everything in the histogram, do the selection
<span class="lineNum">     260 </span>            :   //Int_t nPads = nCols * nRows;
<span class="lineNum">     261 </span>            :   // This is what we are interested in: The center of gravity of the best candidates
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :   Float_t cogyvals[kMaxPads]; memset(cogyvals, 0, sizeof(Float_t)*kMaxPads);</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :   Float_t cogzvals[kMaxPads]; memset(cogzvals, 0, sizeof(Float_t)*kMaxPads);</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :   Float_t *cogy[kMaxRows];</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :   Float_t *cogz[kMaxRows];</span>
<span class="lineNum">     266 </span>            :   
<span class="lineNum">     267 </span>            :   // Lookup-Table storing coordinates according to the bins
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :   Float_t yLengths[kMaxCols]; memset(yLengths, 0, kMaxCols*sizeof(Float_t));</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :   Float_t zLengths[kMaxRows]; memset(zLengths, 0, kMaxRows*sizeof(Float_t));</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :   for(Int_t icnt = 0; icnt &lt; nCols; icnt++){</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :     yLengths[icnt] = pp-&gt;GetColPos(nCols - 1 - icnt) + binlength/2;</span>
<span class="lineNum">     272 </span>            :   }
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :   for(Int_t icnt = 0; icnt &lt; nRows; icnt++){</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :     zLengths[icnt] = pp-&gt;GetRowPos(icnt) - pp-&gt;GetRowSize(icnt)/2;</span>
<span class="lineNum">     275 </span>            :   }
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            :   // A bitfield is used to mask the pads as usable
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :   Short_t mask[kMaxCols]; memset(mask, 0 ,sizeof(Short_t) * kMaxCols);//bool mvals[kMaxPads];</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :   for(UChar_t icount = 0; icount &lt; nRows; icount++){</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :     cogy[icount] = &amp;cogyvals[icount*kMaxCols];</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :     cogz[icount] = &amp;cogzvals[icount*kMaxCols];</span>
<span class="lineNum">     282 </span>            :   }
<span class="lineNum">     283 </span>            :   // In this array the array position of the best candidates will be stored
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :   Int_t   cand[AliTRDtrackerV1::kMaxTracksStack];</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :   Float_t sigcands[AliTRDtrackerV1::kMaxTracksStack];</span>
<span class="lineNum">     286 </span>            :   
<span class="lineNum">     287 </span>            :   // helper variables
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :   Int_t indices[kMaxPads]; memset(indices, -1, sizeof(Int_t)*kMaxPads);</span>
<span class="lineNum">     289 </span>            :   Int_t nCandidates = 0;
<span class="lineNum">     290 </span>            :   Float_t norm, cogv;
<span class="lineNum">     291 </span>            :   // histogram filled -&gt; Select best bins
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :   Int_t nPads = nCols * nRows;</span>
<span class="lineNum">     293 </span>            :   // take out all the bins which have less than 3 entries (faster sorting)
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :   Int_t content[kMaxPads], dictionary[kMaxPads], nCont = 0, padnumber = 0;</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :   Int_t *iter = &amp;hvals[0], *citer = &amp;content[0], *diter =  &amp;dictionary[0]; // iterators for preselection</span>
<span class="lineNum">     296 </span>            :   const Int_t threshold = 2;
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :   hvals[nPads] = -1; // termination for iterator</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :   do{</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :     if(*iter &gt; threshold){</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :       *(citer++) = *iter;</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :       *(diter++) = padnumber;</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :       nCont++;</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :     padnumber++;</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :   }while(*(++iter) != -1);</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :   TMath::Sort(nCont, content, indices);         </span>
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            :   Int_t col, row, lower, lower1, upper, upper1;
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :   for(Int_t ib = 0; ib &lt; nCont; ib++){</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :     if(nCandidates &gt;= AliTRDtrackerV1::kMaxTracksStack){</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :       AliDebug(1, Form(&quot;Number of seed candidates %d exceeded maximum allowed per stack %d&quot;, nCandidates, AliTRDtrackerV1::kMaxTracksStack));</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     313 </span>            :     }
<span class="lineNum">     314 </span>            :     // Positions
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :     row = dictionary[indices[ib]]/nCols;</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :     col = dictionary[indices[ib]]%nCols;</span>
<span class="lineNum">     317 </span>            :     // here will be the threshold condition:
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :     if((mask[col] &amp; (1 &lt;&lt; row)) != 0) continue;               // Pad is masked: continue</span>
<span class="lineNum">     319 </span>            :     //  if(histogram[row][col] &lt; TMath::Max(threshold, 1)){  // of course at least one cluster is needed
<span class="lineNum">     320 </span>            :     //          break;                  // number of clusters below threshold: break;
<span class="lineNum">     321 </span>            :     //  } 
<span class="lineNum">     322 </span>            :     // passing: Mark the neighbors
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :     lower  = TMath::Max(col - 1, 0); upper  = TMath::Min(col + 2, nCols);</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :     lower1 = TMath::Max(row - 1, 0); upper1 = TMath::Min(row + 2, nCols);</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :     for(Int_t ic = lower; ic &lt; upper; ++ic)</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :       for(Int_t ir = lower1; ir &lt; upper1; ++ir){</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :         if(ic == col &amp;&amp; ir == row) continue;</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :         mask[ic] |= (1 &lt;&lt; ir);</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     330 </span>            :     // Storing the position in an array
<span class="lineNum">     331 </span>            :     // testing for neigboring
<span class="lineNum">     332 </span>            :     cogv = 0;
<span class="lineNum">     333 </span>            :     norm = 0;
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :     lower = TMath::Max(col - 1, 0);</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :     upper = TMath::Min(col + 2, nCols);</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :     for(Int_t inb = lower; inb &lt; upper; ++inb){</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :       cogv += yLengths[inb] * histogram[row][inb];</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :       norm += histogram[row][inb];</span>
<span class="lineNum">     339 </span>            :     }
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :     cogy[row][col] = cogv / norm;</span>
<span class="lineNum">     341 </span>            :     cogv = 0; norm = 0;
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :     lower = TMath::Max(row - 1, 0);</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :     upper = TMath::Min(row + 2, nRows);</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :     for(Int_t inb = lower; inb &lt; upper; ++inb){</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :       cogv += zLengths[inb] * histogram[inb][col];</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :       norm += histogram[inb][col];</span>
<span class="lineNum">     347 </span>            :     }
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :     cogz[row][col] = Float_t(cogv) /  norm;</span>
<span class="lineNum">     349 </span>            :     // passed the filter
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :     cand[nCandidates] = row*nCols + col;        // store the position of a passig candidate into an Array</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :     sigcands[nCandidates] = sigmas[row][col] / histogram[row][col]; // never be a floating point exeption</span>
<span class="lineNum">     352 </span>            :     // Analysis output
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :     nCandidates++;</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :   if(!nCandidates) return kFALSE;</span>
<span class="lineNum">     356 </span>            :   
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :   Float_t pos[3], sig[2];</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :   Short_t signal[7]; memset(&amp;signal[0], 0, 7*sizeof(Short_t));</span>
<span class="lineNum">     359 </span>            :   
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :   new(fakeLayer) AliTRDchamberTimeBin(layer, stack, sector, z0, zl);</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :   fakeLayer-&gt;SetReconstructor(rec);</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :   fakeLayer-&gt;SetNRows(nRows);</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :   fakeLayer-&gt;SetOwner(kFALSE);</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :   if(nCandidates){</span>
<span class="lineNum">     365 </span>            :     UInt_t fakeIndex = 0;
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :     for(Int_t ican = 0; ican &lt; nCandidates; ican++){</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :       row = cand[ican] / nCols;</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :       col = cand[ican] % nCols;</span>
<span class="lineNum">     369 </span>            :       //temporary
<span class="lineNum">     370 </span>            :       Int_t n = 0; Double_t x = 0., y = 0., z = 0.;
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :       for(int itb=0; itb&lt;AliTRDseedV1::kNtb; itb++){</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :         if(!(nClusters = fTB[itb].GetNClusters())) continue;</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :         for(Int_t incl = 0; incl &lt; nClusters; incl++){</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :           c = fTB[itb].GetCluster(incl);        </span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :           if(c-&gt;GetPadRow() != row) continue;</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :           if(TMath::Abs(c-&gt;GetPadCol() - col) &gt; 2) continue;</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :           x += c-&gt;GetX();</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :           y += c-&gt;GetY();</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :           z += c-&gt;GetZ();</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :           n++;</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :       if(!n) continue;</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :       pos[0] = x/n;</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :       pos[1] = y/n;</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :       pos[2] = z/n;</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :       sig[0] = .02;</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :       sig[1] = sigcands[ican];</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :       fakeLayer-&gt;InsertCluster(new AliTRDcluster(fDetector, 0., pos, sig, NULL, 3, signal, col, row, 0, 0, 0., 0), fakeIndex++);</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :   fakeLayer-&gt;BuildIndices();</span>
<span class="lineNum">     393 </span>            :   //fakeLayer-&gt;Print();
<span class="lineNum">     394 </span>            :   
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :   if(rec-&gt;GetRecoParam()-&gt;GetStreamLevel(AliTRDrecoParam::kTracker) &gt;= 3){</span>
<span class="lineNum">     396 </span>            :     //TMatrixD hist(nRows, nCols);
<span class="lineNum">     397 </span>            :     //for(Int_t i = 0; i &lt; nRows; i++)
<span class="lineNum">     398 </span>            :     //  for(Int_t j = 0; j &lt; nCols; j++)
<span class="lineNum">     399 </span>            :     //          hist(i,j) = histogram[i][j];
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :     TTreeSRedirector &amp;cstreamer = *rec-&gt;GetDebugStream(AliTRDrecoParam::kTracker);</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :     cstreamer &lt;&lt; &quot;GetSeedingLayer&quot;</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :     &lt;&lt; &quot;layer=&quot;      &lt;&lt; layer</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :     &lt;&lt; &quot;ymin=&quot;       &lt;&lt; ymin</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :     &lt;&lt; &quot;ymax=&quot;       &lt;&lt; ymax</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :     &lt;&lt; &quot;zmin=&quot;       &lt;&lt; zmin</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :     &lt;&lt; &quot;zmax=&quot;       &lt;&lt; zmax</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :     &lt;&lt; &quot;L.=&quot;         &lt;&lt; fakeLayer</span>
<span class="lineNum">     408 </span>            :     //&lt;&lt; &quot;Histogram.=&quot; &lt;&lt; &amp;hist
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :     &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     411 </span>            :   
<span class="lineNum">     412 </span>            :   return kTRUE;
<span class="lineNum">     413 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     414 </span>            : 
<a name="415"><span class="lineNum">     415 </span>            : </a>
<span class="lineNum">     416 </span>            : //_______________________________________________________
<span class="lineNum">     417 </span>            : void AliTRDtrackingChamber::Print(Option_t *opt) const
<span class="lineNum">     418 </span>            : {
<span class="lineNum">     419 </span>            :   // Print the chamber status
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :   if(!GetNClusters()) return;</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :   AliInfo(Form(&quot;fDetector   = %d&quot;, fDetector));</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :   AliInfo(Form(&quot;fX0         = %7.3f&quot;, fX0));</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :   const AliTRDchamberTimeBin *itb = &amp;fTB[0];</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :   for(Int_t jtb=0; jtb&lt;AliTRDseedV1::kNtb; jtb++, itb++) (*itb).Print(opt);</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     426 </span>            : 
<a name="427"><span class="lineNum">     427 </span>            : </a>
<span class="lineNum">     428 </span>            : //_______________________________________________________
<span class="lineNum">     429 </span>            : void AliTRDtrackingChamber::Update()
<span class="lineNum">     430 </span>            : {
<span class="lineNum">     431 </span>            : // Steer purging of used and shared clusters 
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :   AliTRDchamberTimeBin *jtb = &amp;fTB[0];</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :   for(Int_t itb=AliTRDseedV1::kNtb; itb--; ++jtb){ </span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :     if(!(Int_t(*jtb))) continue;</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :     (*jtb).BuildIndices();</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     439 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
