<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - PHOS/PHOSsim/AliPHOSv1.cxx</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">PHOS/PHOSsim</a> - AliPHOSv1.cxx<span style="font-size: 80%;"> (source / <a href="AliPHOSv1.cxx.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">97</td>
            <td class="headerCovTableEntry">264</td>
            <td class="headerCovTableEntryLo">36.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">12</td>
            <td class="headerCovTableEntry">15</td>
            <td class="headerCovTableEntryMed">80.0 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**************************************************************************</a>
<span class="lineNum">       2 </span>            :  * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
<span class="lineNum">       3 </span>            :  *                                                                        *
<span class="lineNum">       4 </span>            :  * Author: The ALICE Off-line Project.                                    *
<span class="lineNum">       5 </span>            :  * Contributors are mentioned in the code where appropriate.              *
<span class="lineNum">       6 </span>            :  *                                                                        *
<span class="lineNum">       7 </span>            :  * Permission to use, copy, modify and distribute this software and its   *
<span class="lineNum">       8 </span>            :  * documentation strictly for non-commercial purposes is hereby granted   *
<span class="lineNum">       9 </span>            :  * without fee, provided that the above copyright notice appears in all   *
<span class="lineNum">      10 </span>            :  * copies and that both the copyright notice and this permission notice   *
<span class="lineNum">      11 </span>            :  * appear in the supporting documentation. The authors make no claims     *
<span class="lineNum">      12 </span>            :  * about the suitability of this software for any purpose. It is          *
<span class="lineNum">      13 </span>            :  * provided &quot;as is&quot; without express or implied warranty.                  *
<span class="lineNum">      14 </span>            :  **************************************************************************/
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : /* $Id$ */
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : /* History of cvs commits:
<span class="lineNum">      19 </span>            :  *
<span class="lineNum">      20 </span>            :  * $Log$
<span class="lineNum">      21 </span>            :  * Revision 1.111  2007/07/24 09:41:19  morsch
<span class="lineNum">      22 </span>            :  * AliStack included for kKeepBit.
<span class="lineNum">      23 </span>            :  *
<span class="lineNum">      24 </span>            :  * Revision 1.110  2007/03/10 08:58:52  kharlov
<span class="lineNum">      25 </span>            :  * Protection for noCPV geometry
<span class="lineNum">      26 </span>            :  *
<span class="lineNum">      27 </span>            :  * Revision 1.109  2007/03/01 11:37:37  kharlov
<span class="lineNum">      28 </span>            :  * Strip units changed from 8x1 to 8x2 (T.Pocheptsov)
<span class="lineNum">      29 </span>            :  *
<span class="lineNum">      30 </span>            :  * Revision 1.108  2007/02/02 09:40:50  alibrary
<span class="lineNum">      31 </span>            :  * Includes required by ROOT head
<span class="lineNum">      32 </span>            :  *
<span class="lineNum">      33 </span>            :  * Revision 1.107  2007/02/01 10:34:47  hristov
<span class="lineNum">      34 </span>            :  * Removing warnings on Solaris x86
<span class="lineNum">      35 </span>            :  *
<span class="lineNum">      36 </span>            :  * Revision 1.106  2006/11/14 17:11:15  hristov
<span class="lineNum">      37 </span>            :  * Removing inheritances from TAttLine, TAttMarker and AliRndm in AliModule. The copy constructor and assignment operators are moved to the private part of the class and not implemented. The corresponding changes are propagated to the detectors
<span class="lineNum">      38 </span>            :  *
<span class="lineNum">      39 </span>            :  * Revision 1.105  2006/09/13 07:31:01  kharlov
<span class="lineNum">      40 </span>            :  * Effective C++ corrections (T.Pocheptsov)
<span class="lineNum">      41 </span>            :  *
<span class="lineNum">      42 </span>            :  * Revision 1.104  2005/05/28 14:19:05  schutz
<span class="lineNum">      43 </span>            :  * Compilation warnings fixed by T.P.
<span class="lineNum">      44 </span>            :  *
<span class="lineNum">      45 </span>            :  */
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : //_________________________________________________________________________
<span class="lineNum">      48 </span>            : // Implementation version v1 of PHOS Manager class 
<span class="lineNum">      49 </span>            : //---
<span class="lineNum">      50 </span>            : //---
<span class="lineNum">      51 </span>            : // Layout EMC + CPV  has name IHEP:
<span class="lineNum">      52 </span>            : // Produces hits for CPV, cumulated hits
<span class="lineNum">      53 </span>            : //---
<span class="lineNum">      54 </span>            : //---
<span class="lineNum">      55 </span>            : //*-- Author: Yves Schutz (SUBATECH)
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : // --- ROOT system ---
<span class="lineNum">      59 </span>            : #include &lt;TClonesArray.h&gt;
<span class="lineNum">      60 </span>            : #include &lt;TParticle.h&gt;
<span class="lineNum">      61 </span>            : #include &lt;TVirtualMC.h&gt;
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : // --- Standard library ---
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            : // --- AliRoot header files ---
<span class="lineNum">      67 </span>            : #include &quot;AliPHOSCPVDigit.h&quot;
<span class="lineNum">      68 </span>            : #include &quot;AliPHOSGeometry.h&quot;
<span class="lineNum">      69 </span>            : #include &quot;AliPHOSHit.h&quot;
<span class="lineNum">      70 </span>            : #include &quot;AliPHOSv1.h&quot;
<span class="lineNum">      71 </span>            : #include &quot;AliRun.h&quot;
<span class="lineNum">      72 </span>            : #include &quot;AliMC.h&quot;
<span class="lineNum">      73 </span>            : #include &quot;AliStack.h&quot;
<a name="74"><span class="lineNum">      74 </span>            : #include &quot;AliPHOSSimParam.h&quot;</a>
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span><span class="lineCov">         20 : ClassImp(AliPHOSv1)</span>
<a name="77"><span class="lineNum">      77 </span>            : </a>
<span class="lineNum">      78 </span>            : //____________________________________________________________________________
<span class="lineNum">      79 </span><span class="lineCov">         24 : AliPHOSv1::AliPHOSv1() : fCPVDigits(&quot;AliPHOSCPVDigit&quot;,20)</span>
<span class="lineNum">      80 </span><span class="lineCov">         60 : {</span>
<span class="lineNum">      81 </span>            :   //Def ctor.
<span class="lineNum">      82 </span><span class="lineCov">         24 : }</span>
<a name="83"><span class="lineNum">      83 </span>            : </a>
<span class="lineNum">      84 </span>            : //____________________________________________________________________________
<span class="lineNum">      85 </span>            : AliPHOSv1::AliPHOSv1(const char *name, const char *title):
<span class="lineNum">      86 </span><span class="lineCov">          2 :   AliPHOSv0(name,title), fCPVDigits(&quot;AliPHOSCPVDigit&quot;,20)</span>
<span class="lineNum">      87 </span><span class="lineCov">          5 : {</span>
<span class="lineNum">      88 </span>            :   //
<span class="lineNum">      89 </span>            :   // We store hits :
<span class="lineNum">      90 </span>            :   //   - fHits (the &quot;normal&quot; one), which retains the hits associated with
<span class="lineNum">      91 </span>            :   //     the current primary particle being tracked
<span class="lineNum">      92 </span>            :   //     (this array is reset after each primary has been tracked).
<span class="lineNum">      93 </span>            :   //
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            :   // We do not want to save in TreeH the raw hits
<span class="lineNum">      98 </span>            :   // But save the cumulated hits instead (need to create the branch myself)
<span class="lineNum">      99 </span>            :   // It is put in the Digit Tree because the TreeH is filled after each primary
<span class="lineNum">     100 </span>            :   // and the TreeD at the end of the event (branch is set in FinishEvent() ). 
<span class="lineNum">     101 </span>            :   
<span class="lineNum">     102 </span><span class="lineCov">          3 :   fHits= new TClonesArray(&quot;AliPHOSHit&quot;,1000) ;</span>
<span class="lineNum">     103 </span>            : //   fCPVDigits(&quot;AliPHOSCPVDigit&quot;,20);
<span class="lineNum">     104 </span><span class="lineCov">          1 :   gAlice-&gt;GetMCApp()-&gt;AddHitList(fHits) ; </span>
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span><span class="lineCov">          1 :   fNhits = 0 ;</span>
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span><span class="lineCov">          1 :   fIshunt     =  2 ; // All hits are associated with primary particles</span>
<span class="lineNum">     109 </span><span class="lineCov">          2 : }</span>
<a name="110"><span class="lineNum">     110 </span>            : </a>
<span class="lineNum">     111 </span>            : //____________________________________________________________________________
<span class="lineNum">     112 </span>            : AliPHOSv1::~AliPHOSv1()
<span class="lineNum">     113 </span><span class="lineCov">         78 : {</span>
<span class="lineNum">     114 </span>            :   // dtor
<span class="lineNum">     115 </span><span class="lineCov">         13 :  if ( fHits) {</span>
<span class="lineNum">     116 </span><span class="lineCov">          3 :     fHits-&gt;Delete() ; </span>
<span class="lineNum">     117 </span><span class="lineCov">          6 :     delete fHits ;</span>
<span class="lineNum">     118 </span><span class="lineCov">          3 :     fHits = 0 ; </span>
<span class="lineNum">     119 </span><span class="lineCov">          3 :  }</span>
<span class="lineNum">     120 </span><span class="lineCov">         39 : }</span>
<a name="121"><span class="lineNum">     121 </span>            : </a>
<span class="lineNum">     122 </span>            : //____________________________________________________________________________
<span class="lineNum">     123 </span>            : void AliPHOSv1::AddHit(Int_t shunt, Int_t primary, Int_t Id, Float_t * hits)
<span class="lineNum">     124 </span>            : {
<span class="lineNum">     125 </span>            :   // Add a hit to the hit list.
<span class="lineNum">     126 </span>            :   // A PHOS hit is the sum of all hits in a single crystal from one primary and within some time gate
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            :   Int_t hitCounter ;
<span class="lineNum">     129 </span>            :   AliPHOSHit *newHit ;
<span class="lineNum">     130 </span>            :   AliPHOSHit *curHit ;
<span class="lineNum">     131 </span>            :   Bool_t deja = kFALSE ;
<span class="lineNum">     132 </span><span class="lineCov">     558606 :   AliPHOSGeometry * geom = GetGeometry() ; </span>
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span><span class="lineCov">     279303 :   newHit = new AliPHOSHit(shunt, primary, Id, hits) ;</span>
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span><span class="lineCov">   37911098 :   for ( hitCounter = fNhits-1 ; hitCounter &gt;= 0 &amp;&amp; !deja ; hitCounter-- ) {</span>
<span class="lineNum">     137 </span><span class="lineCov">   12406769 :     curHit = static_cast&lt;AliPHOSHit*&gt;((*fHits)[hitCounter]) ;</span>
<span class="lineNum">     138 </span><span class="lineCov">   12406769 :     if(curHit-&gt;GetPrimary() != primary) break ; </span>
<span class="lineNum">     139 </span>            :            // We add hits with the same primary, while GEANT treats primaries succesively 
<span class="lineNum">     140 </span><span class="lineCov">   12406705 :     if( *curHit == *newHit ) {</span>
<span class="lineNum">     141 </span><span class="lineCov">     278938 :       *curHit + *newHit ;</span>
<span class="lineNum">     142 </span>            :       deja = kTRUE ;
<span class="lineNum">     143 </span><span class="lineCov">     278938 :     }</span>
<span class="lineNum">     144 </span>            :   }
<span class="lineNum">     145 </span>            :          
<span class="lineNum">     146 </span><span class="lineCov">     279303 :   if ( !deja ) {</span>
<span class="lineNum">     147 </span><span class="lineCov">        365 :     new((*fHits)[fNhits]) AliPHOSHit(*newHit) ;</span>
<span class="lineNum">     148 </span>            :     // get the block Id number
<span class="lineNum">     149 </span><span class="lineCov">        365 :     Int_t relid[4] ;</span>
<span class="lineNum">     150 </span><span class="lineCov">        365 :     geom-&gt;AbsToRelNumbering(Id, relid) ;</span>
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span><span class="lineCov">        365 :     fNhits++ ;</span>
<span class="lineNum">     153 </span><span class="lineCov">        365 :   }</span>
<span class="lineNum">     154 </span>            :   
<span class="lineNum">     155 </span><span class="lineCov">     558606 :   delete newHit;</span>
<span class="lineNum">     156 </span><span class="lineCov">     279303 : }</span>
<a name="157"><span class="lineNum">     157 </span>            : </a>
<span class="lineNum">     158 </span>            : //____________________________________________________________________________
<span class="lineNum">     159 </span>            : void AliPHOSv1::FinishPrimary() 
<span class="lineNum">     160 </span>            : {
<span class="lineNum">     161 </span>            :   // called at the end of each track (primary) by AliRun
<span class="lineNum">     162 </span>            :   // hits are reset for each new track
<span class="lineNum">     163 </span>            :   // accumulate the total hit-multiplicity
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span><span class="lineCov">        224 : }</span>
<a name="166"><span class="lineNum">     166 </span>            : </a>
<span class="lineNum">     167 </span>            : //____________________________________________________________________________
<span class="lineNum">     168 </span>            : void AliPHOSv1::FinishEvent() 
<span class="lineNum">     169 </span>            : {
<span class="lineNum">     170 </span>            :   // called at the end of each event by AliRun
<span class="lineNum">     171 </span>            :   // accumulate the hit-multiplicity and total energy per block 
<span class="lineNum">     172 </span>            :   // if the values have been updated check it
<span class="lineNum">     173 </span>            :   
<span class="lineNum">     174 </span><span class="lineCov">          8 :   AliDetector::FinishEvent(); </span>
<a name="175"><span class="lineNum">     175 </span><span class="lineCov">          4 : }</span></a>
<span class="lineNum">     176 </span>            : //____________________________________________________________________________
<span class="lineNum">     177 </span>            : void AliPHOSv1::StepManager(void)
<span class="lineNum">     178 </span>            : {
<span class="lineNum">     179 </span>            :    // Accumulates hits as long as the track stays in a single crystal or CPV gas Cell
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span><span class="lineCov">     911176 :   Int_t          relid[4] ;           // (box, layer, row, column) indices</span>
<span class="lineNum">     182 </span><span class="lineCov">     455588 :   Int_t          absid    ;           // absolute cell ID number</span>
<span class="lineNum">     183 </span><span class="lineCov">     455588 :   Float_t        xyzte[5]={-1000.,-1000.,-1000.,0.,0.}  ; // position wrt MRS, time and energy deposited</span>
<span class="lineNum">     184 </span><span class="lineCov">     455588 :   TLorentzVector pos      ;           // Lorentz vector of the track current position</span>
<span class="lineNum">     185 </span><span class="lineCov">     455588 :   Int_t          copy     ;</span>
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span><span class="lineCov">     455588 :   Int_t moduleNumber ;</span>
<span class="lineNum">     188 </span>            :   
<span class="lineNum">     189 </span>            :   static Int_t idPCPQ = -1;
<span class="lineNum">     190 </span><span class="lineCov">     455588 :   if (fCreateCPV) </span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :     idPCPQ = TVirtualMC::GetMC()-&gt;VolId(&quot;PCPQ&quot;);</span>
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span><span class="lineCov">    1366764 :   if( TVirtualMC::GetMC()-&gt;CurrentVolID(copy) == idPCPQ &amp;&amp;</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :      (TVirtualMC::GetMC()-&gt;IsTrackEntering() ) &amp;&amp;</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :       TVirtualMC::GetMC()-&gt;TrackCharge() != 0) {      </span>
<span class="lineNum">     196 </span>            :     
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :     TVirtualMC::GetMC() -&gt; TrackPosition(pos);</span>
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :     Float_t xyzm[3], xyzd[3] ;</span>
<span class="lineNum">     200 </span>            :     Int_t i;
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :     for (i=0; i&lt;3; i++) xyzm[i] = pos[i];</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :     TVirtualMC::GetMC() -&gt; Gmtod (xyzm, xyzd, 1);    // transform coordinate from master to daughter system    </span>
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :     Float_t        xyd[3]={0,0,0}   ;   //local position of the entering</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :     xyd[0]  = xyzd[0];</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :     xyd[1]  =-xyzd[2];</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :     xyd[2]  =-xyzd[1];</span>
<span class="lineNum">     209 </span>            :     
<span class="lineNum">     210 </span>            :     // Current momentum of the hit's track in the local ref. system
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :     TLorentzVector pmom     ;        //momentum of the particle initiated hit</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :     TVirtualMC::GetMC() -&gt; TrackMomentum(pmom);</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :     Float_t pm[3], pd[3];</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :     for (i=0; i&lt;3; i++)  </span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :       pm[i]   = pmom[i];</span>
<span class="lineNum">     216 </span>            :     
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :     TVirtualMC::GetMC() -&gt; Gmtod (pm, pd, 2);        // transform 3-momentum from master to daughter system</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :     pmom[0] = pd[0];</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :     pmom[1] =-pd[1];</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :     pmom[2] =-pd[2];</span>
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            :     // Digitize the current CPV hit:
<span class="lineNum">     223 </span>            :     
<span class="lineNum">     224 </span>            :     // 1. find pad response and    
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :     TVirtualMC::GetMC()-&gt;CurrentVolOffID(3,moduleNumber);</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :     moduleNumber--;</span>
<span class="lineNum">     227 </span>            :     
<span class="lineNum">     228 </span>            : //     TClonesArray *cpvDigits = new TClonesArray(&quot;AliPHOSCPVDigit&quot;,0);   // array of digits for current hit
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :     CPVDigitize(pmom,xyd,&amp;fCPVDigits);</span>
<span class="lineNum">     230 </span>            :       
<span class="lineNum">     231 </span>            :     Float_t xmean = 0;
<span class="lineNum">     232 </span>            :     Float_t zmean = 0;
<span class="lineNum">     233 </span>            :     Float_t qsum  = 0;
<span class="lineNum">     234 </span>            :     Int_t   idigit,ndigits;
<span class="lineNum">     235 </span>            :     
<span class="lineNum">     236 </span>            :     // 2. go through the current digit list and sum digits in pads
<span class="lineNum">     237 </span>            :     
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :     ndigits = fCPVDigits.GetEntriesFast();</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :     for (idigit=0; idigit&lt;ndigits-1; idigit++) {</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :       AliPHOSCPVDigit  *cpvDigit1 = static_cast&lt;AliPHOSCPVDigit*&gt;(fCPVDigits.UncheckedAt(idigit));</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :       Float_t x1 = cpvDigit1-&gt;GetXpad() ;</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :       Float_t z1 = cpvDigit1-&gt;GetYpad() ;</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :       for (Int_t jdigit=idigit+1; jdigit&lt;ndigits; jdigit++) {</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :         AliPHOSCPVDigit  *cpvDigit2 = static_cast&lt;AliPHOSCPVDigit*&gt;(fCPVDigits.UncheckedAt(jdigit));</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :         Float_t x2 = cpvDigit2-&gt;GetXpad() ;</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :         Float_t z2 = cpvDigit2-&gt;GetYpad() ;</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :         if (x1==x2 &amp;&amp; z1==z2) {</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :           Float_t qsumpad = cpvDigit1-&gt;GetQpad() + cpvDigit2-&gt;GetQpad() ;</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :           cpvDigit2-&gt;SetQpad(qsumpad) ;</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :           fCPVDigits.RemoveAt(idigit) ;</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     252 </span>            :       }
<span class="lineNum">     253 </span>            :     }
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :     fCPVDigits.Compress() ;</span>
<span class="lineNum">     255 </span>            :     
<span class="lineNum">     256 </span>            :     // 3. add digits to temporary hit list fTmpHits
<span class="lineNum">     257 </span>            :     
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :     ndigits = fCPVDigits.GetEntriesFast();</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :     for (idigit=0; idigit&lt;ndigits; idigit++) {</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :       AliPHOSCPVDigit  *cpvDigit = static_cast&lt;AliPHOSCPVDigit*&gt;(fCPVDigits.UncheckedAt(idigit));</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :       relid[0] = moduleNumber + 1 ;                             // CPV (or PHOS) module number</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :       relid[1] =-1 ;                                            // means CPV</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :       relid[2] = cpvDigit-&gt;GetXpad() ;                          // column number of a pad</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :       relid[3] = cpvDigit-&gt;GetYpad() ;                          // row    number of a pad</span>
<span class="lineNum">     265 </span>            :       
<span class="lineNum">     266 </span>            :       // get the absolute Id number
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :       GetGeometry()-&gt;RelToAbsNumbering(relid, absid) ; </span>
<span class="lineNum">     268 </span>            :       
<span class="lineNum">     269 </span>            :       // add current digit to the temporary hit list
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :       xyzte[3] = TVirtualMC::GetMC()-&gt;TrackTime() ;</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :       xyzte[4] = cpvDigit-&gt;GetQpad() ;                          // amplitude in a pad</span>
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :       Int_t primary  =  gAlice-&gt;GetMCApp()-&gt;GetPrimary( gAlice-&gt;GetMCApp()-&gt;GetCurrentTrackNumber() ); </span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :       AddHit(fIshunt, primary, absid, xyzte);  </span>
<span class="lineNum">     276 </span>            :       
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :       if (cpvDigit-&gt;GetQpad() &gt; 0.02) {</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :         xmean += cpvDigit-&gt;GetQpad() * (cpvDigit-&gt;GetXpad() + 0.5);</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :         zmean += cpvDigit-&gt;GetQpad() * (cpvDigit-&gt;GetYpad() + 0.5);</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :         qsum  += cpvDigit-&gt;GetQpad();</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     282 </span>            :     }
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :     fCPVDigits.Clear();</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            :  
<span class="lineNum">     287 </span><span class="lineCov">     455592 :   static Int_t idPXTL = TVirtualMC::GetMC()-&gt;VolId(&quot;PXTL&quot;);  </span>
<span class="lineNum">     288 </span><span class="lineCov">    1366764 :   if(TVirtualMC::GetMC()-&gt;CurrentVolID(copy) == idPXTL ) { //  We are inside a PBWO crystal</span>
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span><span class="lineCov">     763524 :     TVirtualMC::GetMC()-&gt;TrackPosition(pos) ;</span>
<span class="lineNum">     291 </span><span class="lineCov">     763524 :     xyzte[0] = pos[0] ;</span>
<span class="lineNum">     292 </span><span class="lineCov">     763524 :     xyzte[1] = pos[1] ;</span>
<span class="lineNum">     293 </span><span class="lineCov">     763524 :     xyzte[2] = pos[2] ;</span>
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span><span class="lineCov">    1145286 :     Float_t lostenergy = TVirtualMC::GetMC()-&gt;Edep(); </span>
<span class="lineNum">     296 </span>            :     
<span class="lineNum">     297 </span>            :     //Put in the TreeK particle entering PHOS and all its parents
<span class="lineNum">     298 </span><span class="lineCov">    1145286 :     if ( TVirtualMC::GetMC()-&gt;IsTrackEntering() ){</span>
<span class="lineNum">     299 </span><span class="lineCov">      77721 :       Float_t xyzd[3] ;</span>
<span class="lineNum">     300 </span><span class="lineCov">     155442 :       TVirtualMC::GetMC() -&gt; Gmtod (xyzte, xyzd, 1);    // transform coordinate from master to daughter system    </span>
<span class="lineNum">     301 </span><span class="lineCov">     233163 :       if (xyzd[1] &lt; -GetGeometry()-&gt;GetCrystalSize(1)/2.+0.1){   //Entered close to forward surface  </span>
<span class="lineNum">     302 </span><span class="lineCov">         31 :         Int_t parent = gAlice-&gt;GetMCApp()-&gt;GetCurrentTrackNumber() ; </span>
<span class="lineNum">     303 </span><span class="lineCov">         31 :         TParticle * part = gAlice-&gt;GetMCApp()-&gt;Particle(parent) ; </span>
<span class="lineNum">     304 </span><span class="lineCov">         31 :         Float_t vert[3],vertd[3] ;</span>
<span class="lineNum">     305 </span><span class="lineCov">         31 :         vert[0]=part-&gt;Vx() ;</span>
<span class="lineNum">     306 </span><span class="lineCov">         31 :         vert[1]=part-&gt;Vy() ;</span>
<span class="lineNum">     307 </span><span class="lineCov">         31 :         vert[2]=part-&gt;Vz() ;</span>
<span class="lineNum">     308 </span><span class="lineCov">         62 :         TVirtualMC::GetMC() -&gt; Gmtod (vert, vertd, 1);    // transform coordinate from master to daughter system</span>
<span class="lineNum">     309 </span><span class="lineCov">         93 :         if(vertd[1]&lt;-GetGeometry()-&gt;GetCrystalSize(1)/2.-0.1){ //Particle is created in foront of PHOS </span>
<span class="lineNum">     310 </span>            :                                                                //0.1 to get rid of numerical errors 
<span class="lineNum">     311 </span><span class="lineCov">         16 :           part-&gt;SetBit(kKeepBit);</span>
<span class="lineNum">     312 </span><span class="lineCov">        172 :           while ( parent != -1 ) {</span>
<span class="lineNum">     313 </span><span class="lineCov">         70 :             part = gAlice-&gt;GetMCApp()-&gt;Particle(parent) ; </span>
<span class="lineNum">     314 </span><span class="lineCov">         70 :             part-&gt;SetBit(kKeepBit);</span>
<span class="lineNum">     315 </span><span class="lineCov">         70 :             parent = part-&gt;GetFirstMother() ; </span>
<span class="lineNum">     316 </span>            :           }
<span class="lineNum">     317 </span>            :         }
<span class="lineNum">     318 </span><span class="lineCov">         31 :       }</span>
<span class="lineNum">     319 </span><span class="lineCov">      77721 :     }</span>
<span class="lineNum">     320 </span><span class="lineCov">     381762 :     if ( lostenergy != 0 ) {  // Track is inside the crystal and deposits some energy </span>
<span class="lineNum">     321 </span><span class="lineCov">     837909 :       xyzte[3] = TVirtualMC::GetMC()-&gt;TrackTime() ;     </span>
<span class="lineNum">     322 </span>            :       
<span class="lineNum">     323 </span><span class="lineCov">     558606 :       TVirtualMC::GetMC()-&gt;CurrentVolOffID(10, moduleNumber) ; // get the PHOS module number ;</span>
<span class="lineNum">     324 </span>            :       
<span class="lineNum">     325 </span><span class="lineCov">     279303 :       Int_t strip ;</span>
<span class="lineNum">     326 </span><span class="lineCov">     558606 :       TVirtualMC::GetMC()-&gt;CurrentVolOffID(3, strip);</span>
<span class="lineNum">     327 </span><span class="lineCov">     279303 :       Int_t cell ;</span>
<span class="lineNum">     328 </span><span class="lineCov">     558606 :       TVirtualMC::GetMC()-&gt;CurrentVolOffID(2, cell);</span>
<span class="lineNum">     329 </span>            :       
<span class="lineNum">     330 </span>            :       //Old formula for row is wrong. For example, I have strip 56 (28 for 2 x 8), row must be 1.
<span class="lineNum">     331 </span>            :       //But row == 1 + 56 - 56 % 56 == 57 (row == 1 + 28 - 28 % 28 == 29)
<span class="lineNum">     332 </span>            :       //Int_t row = 1 + GetGeometry()-&gt;GetEMCAGeometry()-&gt;GetNStripZ() - strip % (GetGeometry()-&gt;GetEMCAGeometry()-&gt;GetNStripZ()) ;
<span class="lineNum">     333 </span><span class="lineCov">     837909 :       Int_t row = GetGeometry()-&gt;GetEMCAGeometry()-&gt;GetNStripZ() - (strip - 1) % (GetGeometry()-&gt;GetEMCAGeometry()-&gt;GetNStripZ()) ;</span>
<span class="lineNum">     334 </span><span class="lineCov">     558606 :       Int_t col = (Int_t) TMath::Ceil((Double_t) strip/(GetGeometry()-&gt;GetEMCAGeometry()-&gt;GetNStripZ())) -1 ;</span>
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            :       // Absid for 8x2-strips. Looks nice :) 
<span class="lineNum">     337 </span><span class="lineCov">    1396515 :       absid = (moduleNumber-1)*GetGeometry()-&gt;GetNCristalsInModule() + </span>
<span class="lineNum">     338 </span><span class="lineCov">    1117212 :                     row * 2 + (col*GetGeometry()-&gt;GetEMCAGeometry()-&gt;GetNCellsXInStrip() + (cell - 1) / 2)*GetGeometry()-&gt;GetNZ() - (cell &amp; 1 ? 1 : 0);</span>
<span class="lineNum">     339 </span>            :                     
<span class="lineNum">     340 </span>            :       //Calculates the light yield, the number of photons produced in the
<span class="lineNum">     341 </span>            :       //crystal 
<span class="lineNum">     342 </span>            :       //There is no dependence of reponce on distance from energy deposition to APD
<span class="lineNum">     343 </span><span class="lineCov">     837909 :       Float_t lightYield = gRandom-&gt;Poisson(AliPHOSSimParam::GetInstance()-&gt;GetLightFactor() * lostenergy) ;</span>
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            :       //Calculates de energy deposited in the crystal  
<span class="lineNum">     346 </span><span class="lineCov">     558606 :       xyzte[4] = AliPHOSSimParam::GetInstance()-&gt;GetAPDFactor() * lightYield ;</span>
<span class="lineNum">     347 </span>            :       
<span class="lineNum">     348 </span>            :       Int_t primary ;
<span class="lineNum">     349 </span><span class="lineCov">     558606 :       if(fIshunt == 2){</span>
<span class="lineNum">     350 </span><span class="lineCov">     558606 :         primary = gAlice-&gt;GetMCApp()-&gt;GetCurrentTrackNumber() ;</span>
<span class="lineNum">     351 </span><span class="lineCov">     279303 :         TParticle * part = gAlice-&gt;GetMCApp()-&gt;Particle(primary) ;</span>
<span class="lineNum">     352 </span><span class="lineCov">    4247876 :         while ( !part-&gt;TestBit(kKeepBit) ) {</span>
<span class="lineNum">     353 </span><span class="lineCov">    1844635 :           primary = part-&gt;GetFirstMother() ;</span>
<span class="lineNum">     354 </span><span class="lineCov">    3689270 :           if(primary == -1){        </span>
<span class="lineNum">     355 </span><span class="lineCov">    1844635 :             primary  =  gAlice-&gt;GetMCApp()-&gt;GetPrimary( gAlice-&gt;GetMCApp()-&gt;GetCurrentTrackNumber() ); </span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :             break ; //there is a possibility that particle passed e.g. thermal isulator and hits a side </span>
<span class="lineNum">     357 </span>            :           //surface of the crystal. In this case it may have no primary at all. 
<span class="lineNum">     358 </span>            :           //We can not easily separate this case from the case when this is part of the shower, 
<span class="lineNum">     359 </span>            :           //developed in the neighboring crystal.
<span class="lineNum">     360 </span>            :           }
<span class="lineNum">     361 </span><span class="lineCov">    1844635 :           part = gAlice-&gt;GetMCApp()-&gt;Particle(primary) ;</span>
<span class="lineNum">     362 </span>            :         }
<span class="lineNum">     363 </span><span class="lineCov">     279303 :       }</span>
<span class="lineNum">     364 </span>            :       else{
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :         primary  =  gAlice-&gt;GetMCApp()-&gt;GetPrimary( gAlice-&gt;GetMCApp()-&gt;GetCurrentTrackNumber() ); </span>
<span class="lineNum">     366 </span>            :       }
<span class="lineNum">     367 </span>            :       
<span class="lineNum">     368 </span>            :       // add current hit to the hit list
<span class="lineNum">     369 </span>            :       // Info(&quot;StepManager&quot;,&quot;%d %d&quot;, primary, tracknumber) ; 
<span class="lineNum">     370 </span><span class="lineCov">     279303 :       AddHit(fIshunt, primary, absid, xyzte);</span>
<span class="lineNum">     371 </span>            :         
<span class="lineNum">     372 </span><span class="lineCov">     279303 :     } // there is deposited energy</span>
<span class="lineNum">     373 </span><span class="lineCov">     381762 :   } // we are inside a PHOS Xtal</span>
<span class="lineNum">     374 </span>            :   
<span class="lineNum">     375 </span><span class="lineCov">     455588 : }</span>
<a name="376"><span class="lineNum">     376 </span>            : </a>
<span class="lineNum">     377 </span>            : //____________________________________________________________________________
<span class="lineNum">     378 </span>            : void AliPHOSv1::CPVDigitize (TLorentzVector p, Float_t *zxhit, TClonesArray *cpvDigits)
<span class="lineNum">     379 </span>            : {
<span class="lineNum">     380 </span>            :   // ------------------------------------------------------------------------
<span class="lineNum">     381 </span>            :   // Digitize one CPV hit:
<span class="lineNum">     382 </span>            :   // On input take exact 4-momentum p and position zxhit of the hit,
<span class="lineNum">     383 </span>            :   // find the pad response around this hit and
<span class="lineNum">     384 </span>            :   // put the amplitudes in the pads into array digits
<span class="lineNum">     385 </span>            :   //
<span class="lineNum">     386 </span>            :   // Author: Yuri Kharlov (after Serguei Sadovsky)
<span class="lineNum">     387 </span>            :   // 2 October 2000
<span class="lineNum">     388 </span>            :   // ------------------------------------------------------------------------
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :   const Float_t kCelWr  = GetGeometry()-&gt;GetPadSizePhi()/2;  // Distance between wires (2 wires above 1 pad)</span>
<span class="lineNum">     391 </span>            :   const Float_t kDetR   = 0.1;     // Relative energy fluctuation in track for 100 e-
<span class="lineNum">     392 </span>            :   const Float_t kdEdx   = 4.0;     // Average energy loss in CPV;
<span class="lineNum">     393 </span>            :   const Int_t   kNgamz  = 5;       // Ionization size in Z
<span class="lineNum">     394 </span>            :   const Int_t   kNgamx  = 9;       // Ionization size in Phi
<span class="lineNum">     395 </span>            :   const Float_t kNoise = 0.03;    // charge noise in one pad
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :   Float_t rnor1,rnor2;</span>
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span>            :   // Just a reminder on axes notation in the CPV module:
<span class="lineNum">     400 </span>            :   // axis Z goes along the beam
<span class="lineNum">     401 </span>            :   // axis X goes across the beam in the module plane
<span class="lineNum">     402 </span>            :   // axis Y is a normal to the module plane showing from the IP
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :   Float_t hitX  = zxhit[0];</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :   Float_t hitZ  =-zxhit[1];</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :   Float_t pX    = p.Px();</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :   Float_t pZ    =-p.Pz();</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :   Float_t pNorm = p.Py();</span>
<span class="lineNum">     409 </span>            :   Float_t eloss = kdEdx;
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :   Float_t dZY   = pZ/pNorm * GetGeometry()-&gt;GetCPVGasThickness();</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :   Float_t dXY   = pX/pNorm * GetGeometry()-&gt;GetCPVGasThickness();</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :   gRandom-&gt;Rannor(rnor1,rnor2);</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :   eloss *= (1 + kDetR*rnor1) *</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :            TMath::Sqrt((1 + ( pow(dZY,2) + pow(dXY,2) ) / pow(GetGeometry()-&gt;GetCPVGasThickness(),2)));</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :   Float_t zhit1 = hitZ + GetGeometry()-&gt;GetCPVActiveSize(1)/2 - dZY/2;</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :   Float_t xhit1 = hitX + GetGeometry()-&gt;GetCPVActiveSize(0)/2 - dXY/2;</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :   Float_t zhit2 = zhit1 + dZY;</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :   Float_t xhit2 = xhit1 + dXY;</span>
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :   Int_t   iwht1 = (Int_t) (xhit1 / kCelWr);           // wire (x) coordinate &quot;in&quot;</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :   Int_t   iwht2 = (Int_t) (xhit2 / kCelWr);           // wire (x) coordinate &quot;out&quot;</span>
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span>            :   Int_t   nIter;
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :   Float_t zxe[3][5];</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :   if (iwht1==iwht2) {                      // incline 1-wire hit</span>
<span class="lineNum">     427 </span>            :     nIter = 2;
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :     zxe[0][0] = (zhit1 + zhit2 - dZY*0.57735) / 2;</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :     zxe[1][0] = (iwht1 + 0.5) * kCelWr;</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :     zxe[2][0] =  eloss/2;</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :     zxe[0][1] = (zhit1 + zhit2 + dZY*0.57735) / 2;</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :     zxe[1][1] = (iwht1 + 0.5) * kCelWr;</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :     zxe[2][1] =  eloss/2;</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :   else if (TMath::Abs(iwht1-iwht2) != 1) { // incline 3-wire hit</span>
<span class="lineNum">     436 </span>            :     nIter = 3;
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :     Int_t iwht3 = (iwht1 + iwht2) / 2;</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :     Float_t xwht1 = (iwht1 + 0.5) * kCelWr; // wire 1</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :     Float_t xwht2 = (iwht2 + 0.5) * kCelWr; // wire 2</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :     Float_t xwht3 = (iwht3 + 0.5) * kCelWr; // wire 3</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :     Float_t xwr13 = (xwht1 + xwht3) / 2;   // center 13</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :     Float_t xwr23 = (xwht2 + xwht3) / 2;   // center 23</span>
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :     Float_t dxw1  = xhit1 - xwr13;</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :     Float_t dxw2  = xhit2 - xwr23;</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :     Float_t egm1  = TMath::Abs(dxw1) / ( TMath::Abs(dxw1) + TMath::Abs(dxw2) + kCelWr );</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :     Float_t egm2  = TMath::Abs(dxw2) / ( TMath::Abs(dxw1) + TMath::Abs(dxw2) + kCelWr );</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :     Float_t egm3  =           kCelWr / ( TMath::Abs(dxw1) + TMath::Abs(dxw2) + kCelWr );</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :     zxe[0][0] = (dXY*(xwr13-xwht1)/dXY + zhit1 + zhit1) / 2;</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :     zxe[1][0] =  xwht1;</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :     zxe[2][0] =  eloss * egm1;</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :     zxe[0][1] = (dXY*(xwr23-xwht1)/dXY + zhit1 + zhit2) / 2;</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :     zxe[1][1] =  xwht2;</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :     zxe[2][1] =  eloss * egm2;</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :     zxe[0][2] =  dXY*(xwht3-xwht1)/dXY + zhit1;</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :     zxe[1][2] =  xwht3;</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :     zxe[2][2] =  eloss * egm3;</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     458 </span>            :   else {                                   // incline 2-wire hit
<span class="lineNum">     459 </span>            :     nIter = 2;
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :     Float_t xwht1 = (iwht1 + 0.5) * kCelWr;</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :     Float_t xwht2 = (iwht2 + 0.5) * kCelWr;</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :     Float_t xwr12 = (xwht1 + xwht2) / 2;</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :     Float_t dxw1  = xhit1 - xwr12;</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :     Float_t dxw2  = xhit2 - xwr12;</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :     Float_t egm1  = TMath::Abs(dxw1) / ( TMath::Abs(dxw1) + TMath::Abs(dxw2) );</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :     Float_t egm2  = TMath::Abs(dxw2) / ( TMath::Abs(dxw1) + TMath::Abs(dxw2) );</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :     zxe[0][0] = (zhit1 + zhit2 - dZY*egm1) / 2;</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :     zxe[1][0] =  xwht1;</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :     zxe[2][0] =  eloss * egm1;</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :     zxe[0][1] = (zhit1 + zhit2 + dZY*egm2) / 2;</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :     zxe[1][1] =  xwht2;</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :     zxe[2][1] =  eloss * egm2;</span>
<span class="lineNum">     473 </span>            :   }
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span>            :   // Finite size of ionization region
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :   Int_t nCellZ  = GetGeometry()-&gt;GetNumberOfCPVPadsZ();</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :   Int_t nCellX  = GetGeometry()-&gt;GetNumberOfCPVPadsPhi();</span>
<span class="lineNum">     479 </span>            :   Int_t nz3     = (kNgamz+1)/2;
<span class="lineNum">     480 </span>            :   Int_t nx3     = (kNgamx+1)/2;
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :   cpvDigits-&gt;Expand(nIter*kNgamx*kNgamz);</span>
<span class="lineNum">     482 </span>            :   TClonesArray &amp;ldigits = *(static_cast&lt;TClonesArray *&gt;(cpvDigits));
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :   for (Int_t iter=0; iter&lt;nIter; iter++) {</span>
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :     Float_t zhit = zxe[0][iter];</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :     Float_t xhit = zxe[1][iter];</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :     Float_t qhit = zxe[2][iter];</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :     Float_t zcell = zhit / GetGeometry()-&gt;GetPadSizeZ();</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :     Float_t xcell = xhit / GetGeometry()-&gt;GetPadSizePhi();</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :     if ( zcell&lt;=0      || xcell&lt;=0 ||</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :          zcell&gt;=nCellZ || xcell&gt;=nCellX) return;</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :     Int_t izcell = (Int_t) zcell;</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :     Int_t ixcell = (Int_t) xcell;</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :     Float_t zc = zcell - izcell - 0.5;</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :     Float_t xc = xcell - ixcell - 0.5;</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :     for (Int_t iz=1; iz&lt;=kNgamz; iz++) {</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :       Int_t kzg = izcell + iz - nz3;</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :       if (kzg&lt;=0 || kzg&gt;nCellZ) continue;</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :       Float_t zg = (Float_t)(iz-nz3) - zc;</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :       for (Int_t ix=1; ix&lt;=kNgamx; ix++) {</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :         Int_t kxg = ixcell + ix - nx3;</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :         if (kxg&lt;=0 || kxg&gt;nCellX) continue;</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :         Float_t xg = (Float_t)(ix-nx3) - xc;</span>
<span class="lineNum">     505 </span>            :         
<span class="lineNum">     506 </span>            :         // Now calculate pad response
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :         Float_t qpad = CPVPadResponseFunction(qhit,zg,xg);</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :         qpad += kNoise*rnor2;</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :         if (qpad&lt;0) continue;</span>
<span class="lineNum">     510 </span>            :         
<span class="lineNum">     511 </span>            :         // Fill the array with pad response ID and amplitude
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :         new(ldigits[cpvDigits-&gt;GetEntriesFast()]) AliPHOSCPVDigit(kxg,kzg,qpad);</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 : }</span>
<a name="517"><span class="lineNum">     517 </span>            : </a>
<span class="lineNum">     518 </span>            : //____________________________________________________________________________
<span class="lineNum">     519 </span>            : Float_t AliPHOSv1::CPVPadResponseFunction(Float_t qhit, Float_t zhit, Float_t xhit) {
<span class="lineNum">     520 </span>            :   // ------------------------------------------------------------------------
<span class="lineNum">     521 </span>            :   // Calculate the amplitude in one CPV pad using the
<span class="lineNum">     522 </span>            :   // cumulative pad response function
<span class="lineNum">     523 </span>            :   // Author: Yuri Kharlov (after Serguei Sadovski)
<span class="lineNum">     524 </span>            :   // 3 October 2000
<span class="lineNum">     525 </span>            :   // ------------------------------------------------------------------------
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :   Double_t dz = GetGeometry()-&gt;GetPadSizeZ()   / 2;</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :   Double_t dx = GetGeometry()-&gt;GetPadSizePhi() / 2;</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :   Double_t z  = zhit * GetGeometry()-&gt;GetPadSizeZ();</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :   Double_t x  = xhit * GetGeometry()-&gt;GetPadSizePhi();</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :   Double_t amplitude = qhit *</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :     (CPVCumulPadResponse(z+dz,x+dx) - CPVCumulPadResponse(z+dz,x-dx) -</span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :      CPVCumulPadResponse(z-dz,x+dx) + CPVCumulPadResponse(z-dz,x-dx));</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :   return (Float_t)amplitude;</span>
<span class="lineNum">     535 </span>            : }
<a name="536"><span class="lineNum">     536 </span>            : </a>
<span class="lineNum">     537 </span>            : //____________________________________________________________________________
<span class="lineNum">     538 </span>            : Double_t AliPHOSv1::CPVCumulPadResponse(Double_t x, Double_t y) {
<span class="lineNum">     539 </span>            :   // ------------------------------------------------------------------------
<span class="lineNum">     540 </span>            :   // Cumulative pad response function
<span class="lineNum">     541 </span>            :   // It includes several terms from the CF decomposition in electrostatics
<span class="lineNum">     542 </span>            :   // Note: this cumulative function is wrong since omits some terms
<span class="lineNum">     543 </span>            :   //       but the cell amplitude obtained with it is correct because
<span class="lineNum">     544 </span>            :   //       these omitting terms cancel
<span class="lineNum">     545 </span>            :   // Author: Yuri Kharlov (after Serguei Sadovski)
<span class="lineNum">     546 </span>            :   // 3 October 2000
<span class="lineNum">     547 </span>            :   // ------------------------------------------------------------------------
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span>            :   const Double_t kA=1.0;
<span class="lineNum">     550 </span>            :   const Double_t kB=0.7;
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :   Double_t r2       = x*x + y*y;</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :   Double_t xy       = x*y;</span>
<span class="lineNum">     554 </span>            :   Double_t cumulPRF = 0;
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;=4; i++) {</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :     Double_t b1 = (2*i + 1) * kB;</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :     cumulPRF += TMath::Power(-1,i) * TMath::ATan( xy / (b1*TMath::Sqrt(b1*b1 + r2)) );</span>
<span class="lineNum">     558 </span>            :   }
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :   cumulPRF *= kA/(2*TMath::Pi());</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :   return cumulPRF;</span>
<span class="lineNum">     561 </span>            : }
<span class="lineNum">     562 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
