<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - EMCAL/EMCALrec/AliEMCALQADataMakerRec.cxx</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">EMCAL/EMCALrec</a> - AliEMCALQADataMakerRec.cxx<span style="font-size: 80%;"> (source / <a href="AliEMCALQADataMakerRec.cxx.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">39</td>
            <td class="headerCovTableEntry">697</td>
            <td class="headerCovTableEntryLo">5.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">4</td>
            <td class="headerCovTableEntry">21</td>
            <td class="headerCovTableEntryLo">19.0 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**************************************************************************</a>
<span class="lineNum">       2 </span>            :  * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
<span class="lineNum">       3 </span>            :  *                                                                        *
<span class="lineNum">       4 </span>            :  * Author: The ALICE Off-line Project.                                    *
<span class="lineNum">       5 </span>            :  * Contributors are mentioned in the code where appropriate.              *
<span class="lineNum">       6 </span>            :  *                                                                        *
<span class="lineNum">       7 </span>            :  * Permission to use, copy, modify and distribute this software and its   *
<span class="lineNum">       8 </span>            :  * documentation strictly for non-commercial purposes is hereby granted   *
<span class="lineNum">       9 </span>            :  * without fee, provided that the above copyright notice appears in all   *
<span class="lineNum">      10 </span>            :  * copies and that both the copyright notice and this permission notice   *
<span class="lineNum">      11 </span>            :  * appear in the supporting documentation. The authors make no claims     *
<span class="lineNum">      12 </span>            :  * about the suitability of this software for any purpose. It is          *
<span class="lineNum">      13 </span>            :  * provided &quot;as is&quot; without express or implied warranty.                  *
<span class="lineNum">      14 </span>            :  **************************************************************************/
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : // --- ROOT system ---
<span class="lineNum">      17 </span>            : #include &lt;TClonesArray.h&gt;
<span class="lineNum">      18 </span>            : #include &lt;TFile.h&gt; 
<span class="lineNum">      19 </span>            : #include &lt;TH1F.h&gt; 
<span class="lineNum">      20 </span>            : #include &lt;TH1I.h&gt; 
<span class="lineNum">      21 </span>            : #include &lt;TH2F.h&gt; 
<span class="lineNum">      22 </span>            : #include &lt;TH3I.h&gt;
<span class="lineNum">      23 </span>            : #include &lt;TLine.h&gt;
<span class="lineNum">      24 </span>            : #include &lt;TText.h&gt;
<span class="lineNum">      25 </span>            : #include &lt;TProfile.h&gt; 
<span class="lineNum">      26 </span>            : #include &lt;TProfile2D.h&gt; 
<span class="lineNum">      27 </span>            : #include &lt;TStyle.h&gt;
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : // --- AliRoot header files ---
<span class="lineNum">      30 </span>            : #include &quot;AliDAQ.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;AliESDCaloCluster.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;AliESDCaloCells.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;AliESDEvent.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;AliLog.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;AliEMCALQADataMakerRec.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;AliQAChecker.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;AliEMCALDigit.h&quot; 
<span class="lineNum">      38 </span>            : #include &quot;AliEMCALRecPoint.h&quot; 
<span class="lineNum">      39 </span>            : #include &quot;AliEMCALRawUtils.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;AliEMCALReconstructor.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;AliEMCALRecParam.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;AliRawReader.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;AliCaloRawStreamV3.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;AliEMCALGeoParams.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;AliRawEventHeaderBase.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;AliQAManager.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;AliCDBEntry.h&quot;
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            : #include &quot;AliCaloBunchInfo.h&quot;
<span class="lineNum">      50 </span>            : #include &quot;AliCaloFitResults.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;AliCaloRawAnalyzer.h&quot;
<span class="lineNum">      52 </span>            : #include &quot;AliCaloRawAnalyzerFactory.h&quot;
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : #include &quot;AliEMCALGeometry.h&quot;
<span class="lineNum">      55 </span>            : #include &quot;AliEMCALTriggerSTURawStream.h&quot;
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            : using namespace std;
<a name="58"><span class="lineNum">      58 </span>            : </a>
<span class="lineNum">      59 </span>            : /// \cond CLASSIMP
<span class="lineNum">      60 </span><span class="lineCov">         42 : ClassImp(AliEMCALQADataMakerRec) ;</span>
<span class="lineNum">      61 </span>            : /// \endcond
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : //____________________________________________________________________________ 
<span class="lineNum">      64 </span>            : /// Constructor.
<span class="lineNum">      65 </span>            : ///
<span class="lineNum">      66 </span>            : /// \param fitAlgo: an Integer value to specify the fitting Algorithm to be used
<a name="67"><span class="lineNum">      67 </span>            : ///                 see EMCALUtils/AliCaloConstants.h enum fitAlgorithm</a>
<span class="lineNum">      68 </span>            : /// 
<span class="lineNum">      69 </span>            : AliEMCALQADataMakerRec::AliEMCALQADataMakerRec(Int_t fitAlgo) :
<span class="lineNum">      70 </span><span class="lineCov">          6 :   AliQADataMakerRec(AliQAv1::GetDetName(AliQAv1::kEMCAL), &quot;EMCAL Quality Assurance Data Maker&quot;),</span>
<span class="lineNum">      71 </span><span class="lineCov">          2 :   fFittingAlgorithm(0),</span>
<span class="lineNum">      72 </span><span class="lineCov">          2 :   fRawAnalyzer(0),</span>
<span class="lineNum">      73 </span><span class="lineCov">          2 :   fRawAnalyzerTRU(0),</span>
<span class="lineNum">      74 </span><span class="lineCov">          2 :   fGeom(0),</span>
<span class="lineNum">      75 </span><span class="lineCov">          2 :   fSuperModules(20), // number of SuperModules; updated to 20 for EMCal + DCal </span>
<span class="lineNum">      76 </span><span class="lineCov">          2 :   fFirstPedestalSample(0),</span>
<span class="lineNum">      77 </span><span class="lineCov">          2 :   fLastPedestalSample(3),</span>
<span class="lineNum">      78 </span><span class="lineCov">          2 :   fFirstPedestalSampleTRU(0),</span>
<span class="lineNum">      79 </span><span class="lineCov">          2 :   fLastPedestalSampleTRU(3),</span>
<span class="lineNum">      80 </span><span class="lineCov">          2 :   fMinSignalLG(0),</span>
<span class="lineNum">      81 </span><span class="lineCov">          2 :   fMaxSignalLG(AliEMCALGeoParams::fgkSampleMax),</span>
<span class="lineNum">      82 </span><span class="lineCov">          2 :   fMinSignalHG(0),</span>
<span class="lineNum">      83 </span><span class="lineCov">          2 :   fMaxSignalHG(AliEMCALGeoParams::fgkSampleMax),</span>
<span class="lineNum">      84 </span><span class="lineCov">          2 :   fMinSignalTRU(0),</span>
<span class="lineNum">      85 </span><span class="lineCov">          2 :   fMaxSignalTRU(AliEMCALGeoParams::fgkSampleMax),</span>
<span class="lineNum">      86 </span><span class="lineCov">          2 :   fMinSignalLGLEDMon(0),</span>
<span class="lineNum">      87 </span><span class="lineCov">          2 :   fMaxSignalLGLEDMon(AliEMCALGeoParams::fgkSampleMax),</span>
<span class="lineNum">      88 </span><span class="lineCov">          2 :   fMinSignalHGLEDMon(0),</span>
<span class="lineNum">      89 </span><span class="lineCov">          2 :   fMaxSignalHGLEDMon(AliEMCALGeoParams::fgkSampleMax),</span>
<span class="lineNum">      90 </span><span class="lineCov">          2 :   fCalibRefHistoPro(NULL),</span>
<span class="lineNum">      91 </span><span class="lineCov">          2 :   fCalibRefHistoH2F(NULL),</span>
<span class="lineNum">      92 </span><span class="lineCov">          2 :   fLEDMonRefHistoPro(NULL),</span>
<span class="lineNum">      93 </span><span class="lineCov">          2 :   fHighEmcHistoH2F(NULL)</span>
<span class="lineNum">      94 </span>            : //  fTextSM(new TText*[fSuperModules]) ,
<span class="lineNum">      95 </span>            : //  fLineCol(NULL),
<span class="lineNum">      96 </span>            : //  fLineRow(NULL)
<span class="lineNum">      97 </span><span class="lineCov">         10 : {</span>
<span class="lineNum">      98 </span><span class="lineCov">          2 :   SetFittingAlgorithm(fitAlgo);</span>
<span class="lineNum">      99 </span>            :   
<span class="lineNum">     100 </span><span class="lineCov">          4 :   fGeom = AliEMCALGeometry::GetInstance();</span>
<span class="lineNum">     101 </span>            :   
<span class="lineNum">     102 </span><span class="lineCov">          2 :   if(!fGeom)</span>
<span class="lineNum">     103 </span>            :   {
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :     AliCDBManager* man = AliCDBManager::Instance();</span>
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :     Int_t runNumber = man-&gt;GetRun();</span>
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :     fGeom =  AliEMCALGeometry::GetInstanceFromRunNumber(runNumber);</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     108 </span>            :   
<span class="lineNum">     109 </span><span class="lineCov">          2 :   if(!fGeom) </span>
<span class="lineNum">     110 </span>            :   {
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :     AliWarning(Form(&quot;Using default geometry in reconstruction!!!&quot;));</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :     fGeom =  AliEMCALGeometry::GetInstance(AliEMCALGeometry::GetDefaultGeometryName());</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     114 </span>            :   
<span class="lineNum">     115 </span><span class="lineCov">          2 :   if ( !fGeom ) AliFatal(Form(&quot;Could not get geometry!&quot;));</span>
<span class="lineNum">     116 </span><span class="lineCov">          8 :   else          AliInfo (Form(&quot;Geometry name: &lt;&lt;%s&gt;&gt;&quot;,fGeom-&gt;GetName())); </span>
<span class="lineNum">     117 </span>            :   
<span class="lineNum">     118 </span>            :   //  for (Int_t sm = 0 ; sm &lt; fSuperModules ; sm++){
<span class="lineNum">     119 </span>            :   //    fTextSM[sm] = NULL ;
<span class="lineNum">     120 </span>            :   //  }
<span class="lineNum">     121 </span><span class="lineCov">          4 : }</span>
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            : //____________________________________________________________________________
<span class="lineNum">     124 </span>            : ///
<span class="lineNum">     125 </span>            : /// Copy constructor.
<span class="lineNum">     126 </span>            : ///
<a name="127"><span class="lineNum">     127 </span>            : /// \param qadm: AliEMCALQADataMakerRec</a>
<span class="lineNum">     128 </span>            : ///
<span class="lineNum">     129 </span>            : AliEMCALQADataMakerRec::AliEMCALQADataMakerRec(const AliEMCALQADataMakerRec&amp; qadm) :
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :   AliQADataMakerRec(), </span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :   fFittingAlgorithm(0),</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :   fRawAnalyzer(0),</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :   fRawAnalyzerTRU(0),</span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :   fGeom(0),</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :   fSuperModules(qadm.GetSuperModules()), </span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :   fFirstPedestalSample(qadm.GetFirstPedestalSample()), </span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :   fLastPedestalSample(qadm.GetLastPedestalSample()),  </span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :   fFirstPedestalSampleTRU(qadm.GetFirstPedestalSampleTRU()), </span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :   fLastPedestalSampleTRU(qadm.GetLastPedestalSampleTRU()),  </span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :   fMinSignalLG(qadm.GetMinSignalLG()),</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :   fMaxSignalLG(qadm.GetMaxSignalLG()),</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :   fMinSignalHG(qadm.GetMinSignalHG()),</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :   fMaxSignalHG(qadm.GetMaxSignalHG()),</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :   fMinSignalTRU(qadm.GetMinSignalTRU()),</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :   fMaxSignalTRU(qadm.GetMaxSignalTRU()),</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :   fMinSignalLGLEDMon(qadm.GetMinSignalLGLEDMon()),</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :   fMaxSignalLGLEDMon(qadm.GetMaxSignalLGLEDMon()),</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :   fMinSignalHGLEDMon(qadm.GetMinSignalHGLEDMon()),</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :   fMaxSignalHGLEDMon(qadm.GetMaxSignalHGLEDMon()),</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :   fCalibRefHistoPro(NULL),</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :   fCalibRefHistoH2F(NULL),</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :   fLEDMonRefHistoPro(NULL),</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :   fHighEmcHistoH2F(NULL)</span>
<span class="lineNum">     154 </span>            : //  fTextSM(new TText*[fSuperModules]) ,
<span class="lineNum">     155 </span>            : //  fLineCol(NULL),
<span class="lineNum">     156 </span>            : //  fLineRow(NULL)
<span class="lineNum">     157 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :   SetName((const char*)qadm.GetName()) ; </span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :   SetTitle((const char*)qadm.GetTitle()); </span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :   SetFittingAlgorithm(qadm.GetFittingAlgorithm());</span>
<span class="lineNum">     161 </span>            :   
<span class="lineNum">     162 </span>            :   //  for (Int_t sm = 0 ; sm &lt; fSuperModules ; sm++){
<span class="lineNum">     163 </span>            :   //    fTextSM[sm] = qadm.fTextSM[sm] ;
<span class="lineNum">     164 </span>            :   //  }  
<span class="lineNum">     165 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span>            : //__________________________________________________________________
<span class="lineNum">     168 </span>            : ///
<span class="lineNum">     169 </span>            : /// Assignment operator.
<span class="lineNum">     170 </span>            : ///
<a name="171"><span class="lineNum">     171 </span>            : /// \param qadm: AliEMCALQADataMakerRec</a>
<span class="lineNum">     172 </span>            : ///
<span class="lineNum">     173 </span>            : AliEMCALQADataMakerRec&amp; AliEMCALQADataMakerRec::operator = (const AliEMCALQADataMakerRec&amp; qadm )
<span class="lineNum">     174 </span>            : {
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :   this-&gt;~AliEMCALQADataMakerRec();</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :   new(this) AliEMCALQADataMakerRec(qadm);</span>
<span class="lineNum">     177 </span>            :   //  fLineCol = NULL;
<span class="lineNum">     178 </span>            :   //  fLineRow = NULL;
<span class="lineNum">     179 </span>            :   //  for (Int_t sm = 0 ; sm &lt; fSuperModules ; sm++){
<span class="lineNum">     180 </span>            :   //    fTextSM[sm] = qadm.fTextSM[sm] ;
<span class="lineNum">     181 </span>            :   //  }    
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :   return *this;</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     184 </span>            :  
<span class="lineNum">     185 </span>            : //____________________________________________________________________________ 
<span class="lineNum">     186 </span>            : ///
<span class="lineNum">     187 </span>            : /// Detector specific actions at end of cycle
<span class="lineNum">     188 </span>            : ///
<span class="lineNum">     189 </span>            : /// \param task
<a name="190"><span class="lineNum">     190 </span>            : /// \param list of histograms</a>
<span class="lineNum">     191 </span>            : ///
<span class="lineNum">     192 </span>            : void AliEMCALQADataMakerRec::EndOfDetectorCycle(AliQAv1::TASKINDEX_t task, TObjArray ** list)
<span class="lineNum">     193 </span>            : {
<span class="lineNum">     194 </span>            :   //TH1I *rmsL0=(TH1I*)list[fEventSpecie]-&gt;At(kNL0TRUSamples);
<span class="lineNum">     195 </span>            :   //  if(fCycleCounter)
<span class="lineNum">     196 </span>            :   //      GetRawsData(kNEventsPerTower)-&gt;Scale(1./fCycleCounter);
<span class="lineNum">     197 </span>            :   /*for(int i=0; i&lt;AliEMCALTriggerMappingV2::fSTURegionNEta; i++)
<span class="lineNum">     198 </span>            :    for(int j=0; j&lt;AliEMCALTriggerMappingV2::fSTURegionNPhi; j++)
<span class="lineNum">     199 </span>            :                         FillRawsData(kNL0TRURMS,i,j,rmsL0-&gt;GetBinError(i,j));
<span class="lineNum">     200 </span>            :    */
<span class="lineNum">     201 </span>            :   // reset triggers list to select all histos
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :   ResetEventTrigClasses(); </span>
<span class="lineNum">     203 </span>            :   // do the QA checking
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :   AliQAChecker::Instance()-&gt;Run(AliQAv1::kEMCAL, task, list) ;  </span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span>            : //____________________________________________________________________________ 
<span class="lineNum">     208 </span>            : ///
<a name="209"><span class="lineNum">     209 </span>            : /// Get the reference histogram from OCDB</a>
<span class="lineNum">     210 </span>            : ///
<span class="lineNum">     211 </span>            : void AliEMCALQADataMakerRec::GetCalibRefFromOCDB()
<span class="lineNum">     212 </span>            : {
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :   TString sName1(&quot;hHighEmcalRawMaxMinusMin&quot;) ;</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :   TString sName2(&quot;hLowLEDMonEmcalRawMaxMinusMin&quot;) ;</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :   sName1.Prepend(Form(&quot;%s_&quot;, AliRecoParam::GetEventSpecieName(AliRecoParam::kCalib))) ; </span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :   sName2.Prepend(Form(&quot;%s_&quot;, AliRecoParam::GetEventSpecieName(AliRecoParam::kCalib))) ; </span>
<span class="lineNum">     217 </span>            :   
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :   TString refStorage(AliQAv1::GetQARefStorage()) ;</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :   if (!refStorage.Contains(AliQAv1::GetLabLocalOCDB()) &amp;&amp; !refStorage.Contains(AliQAv1::GetLabAliEnOCDB())) {</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :     AliFatal(Form(&quot;%s is not a valid location for reference data&quot;, refStorage.Data())) ; </span>
<span class="lineNum">     221 </span>            :   } else {
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :     AliQAManager* manQA = AliQAManager::QAManager(AliQAv1::kRAWS) ;    </span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :     AliQAv1::SetQARefDataDirName(AliRecoParam::kCalib) ;</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :     if ( ! manQA-&gt;GetLock() ) { </span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :       manQA-&gt;SetDefaultStorage(AliQAv1::GetQARefStorage()) ; </span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :       manQA-&gt;SetSpecificStorage(&quot;*&quot;, AliQAv1::GetQARefStorage()) ;</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :       manQA-&gt;SetRun(AliCDBManager::Instance()-&gt;GetRun()) ; </span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :       manQA-&gt;SetLock() ; </span>
<span class="lineNum">     229 </span>            :     }
<span class="lineNum">     230 </span>            :   
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :     char * detOCDBDir = Form(&quot;%s/%s/%s&quot;, GetName(), AliQAv1::GetRefOCDBDirName(), AliQAv1::GetRefDataDirName()) ; </span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :     AliCDBEntry * entry = manQA-&gt;Get(detOCDBDir, manQA-&gt;GetRun()) ;</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :     if (entry) {</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :       TList * listDetQAD =static_cast&lt;TList *&gt;(entry-&gt;GetObject()) ;</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :       if ( strcmp(listDetQAD-&gt;ClassName(), &quot;TList&quot;) != 0 ) {</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :         AliError(Form(&quot;Expected a Tlist and found a %s for detector %s&quot;, listDetQAD-&gt;ClassName(), GetName())) ; </span>
<span class="lineNum">     237 </span>            :         listDetQAD = NULL ; 
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     239 </span>            :   
<span class="lineNum">     240 </span>            :       TObjArray * dirOCDB= NULL ; 
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :       if ( listDetQAD )</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :         dirOCDB = static_cast&lt;TObjArray *&gt;(listDetQAD-&gt;FindObject(Form(&quot;%s/%s&quot;, AliQAv1::GetTaskName(AliQAv1::kRAWS).Data(), AliRecoParam::GetEventSpecieName(AliRecoParam::kCalib)))) ;       </span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :       if (dirOCDB){</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :         fCalibRefHistoPro = dynamic_cast&lt;TProfile *&gt;(dirOCDB-&gt;FindObject(sName1.Data())) ; </span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :         fLEDMonRefHistoPro = dynamic_cast&lt;TProfile *&gt;(dirOCDB-&gt;FindObject(sName2.Data())) ; </span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     248 </span>            :   }
<span class="lineNum">     249 </span>            :   
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :   if(fCalibRefHistoPro &amp;&amp; fLEDMonRefHistoPro)</span>
<span class="lineNum">     251 </span>            :   {
<span class="lineNum">     252 </span>            :     // Defining histograms binning, each 2D histogram covers all SMs
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :     Int_t nSMSectors = fSuperModules / 2; // 2 SMs per sector</span>
<span class="lineNum">     254 </span>            :     
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :     AliCDBManager* man = AliCDBManager::Instance();</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :     Int_t runNumber = man-&gt;GetRun();</span>
<span class="lineNum">     257 </span>            :     Int_t nbinsZ, nbinsPhi;
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :     if (!(fGeom-&gt; GetEMCGeometry()-&gt;GetGeoName().Contains(&quot;DCAL&quot;))){</span>
<span class="lineNum">     259 </span>            :       nbinsZ = AliEMCALGeoParams::fgkEMCALCols;
<span class="lineNum">     260 </span>            :       nbinsPhi = AliEMCALGeoParams::fgkEMCALRows;
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     262 </span>            :     else{
<span class="lineNum">     263 </span>            :       nbinsZ = AliEMCALTriggerMappingV2::fSTURegionNEta;
<span class="lineNum">     264 </span>            :       nbinsPhi = AliEMCALTriggerMappingV2::fSTURegionNPhi;
<span class="lineNum">     265 </span>            :     } 
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :     if(!fCalibRefHistoH2F)</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :       fCalibRefHistoH2F =  new TH2F(&quot;hCalibRefHisto&quot;, &quot;hCalibRefHisto&quot;, nbinsZ, -0.5, nbinsZ - 0.5, nbinsPhi, -0.5, nbinsPhi -0.5);</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :     ConvertProfile2H(fCalibRefHistoPro,fCalibRefHistoH2F) ; </span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :     AliFatal(Form(&quot;No reference object with name %s or %s found&quot;, sName1.Data(), sName2.Data())) ; </span>
<span class="lineNum">     271 </span>            :   }
<span class="lineNum">     272 </span>            :   
<span class="lineNum">     273 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            : //____________________________________________________________________________ 
<span class="lineNum">     276 </span>            : ///
<span class="lineNum">     277 </span>            : /// Create histograms to controll ESD.
<a name="278"><span class="lineNum">     278 </span>            : /// Multiple paragraphs are split on multiple lines.</a>
<span class="lineNum">     279 </span>            : ///
<span class="lineNum">     280 </span>            : void AliEMCALQADataMakerRec::InitESDs()
<span class="lineNum">     281 </span>            : {
<span class="lineNum">     282 </span>            :   const Bool_t expert   = kTRUE ; 
<span class="lineNum">     283 </span>            :   const Bool_t image    = kTRUE ; 
<span class="lineNum">     284 </span>            :   
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :   TH1F * h1 = new TH1F(&quot;hESDCaloClusterE&quot;,  &quot;ESDs CaloCluster energy in EMCAL;Energy [GeV];Counts&quot;,    200, 0., 100.) ; </span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :   h1-&gt;Sumw2() ;</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :   Add2ESDsList(h1, kESDCaloClusE, !expert, image)  ;                                                     </span>
<span class="lineNum">     288 </span>            :   
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :   TH1I * h2 = new TH1I(&quot;hESDCaloClusterM&quot;, &quot;ESDs CaloCluster multiplicity in EMCAL;# of Clusters;Entries&quot;, 100, 0,  100) ; </span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :   h2-&gt;Sumw2() ;</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :   Add2ESDsList(h2, kESDCaloClusM, !expert, image)  ;</span>
<span class="lineNum">     292 </span>            :   
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :   TH1F * h3 = new TH1F(&quot;hESDCaloCellA&quot;,  &quot;ESDs CaloCell amplitude in EMCAL;Energy [GeV];Counts&quot;,    500, 0., 50.) ; </span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :   h3-&gt;Sumw2() ;</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :   Add2ESDsList(h3, kESDCaloCellA, !expert, image)  ;  </span>
<span class="lineNum">     296 </span>            :   
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :   TH1I * h4 = new TH1I(&quot;hESDCaloCellM&quot;, &quot;ESDs CaloCell multiplicity in EMCAL;# of Clusters;Entries&quot;, 200, 0,  1000) ; </span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :   h4-&gt;Sumw2() ;</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :   Add2ESDsList(h4, kESDCaloCellM, !expert, image) ;</span>
<span class="lineNum">     300 </span>            :   // 
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :   ClonePerTrigClass(AliQAv1::kESDS); // this should be the last line    </span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span>            : //____________________________________________________________________________ 
<a name="305"><span class="lineNum">     305 </span>            : /// Create Digits histograms in Digits subdir. </a>
<span class="lineNum">     306 </span>            : ///
<span class="lineNum">     307 </span>            : void AliEMCALQADataMakerRec::InitDigits()
<span class="lineNum">     308 </span>            : {
<span class="lineNum">     309 </span>            :   const Bool_t expert   = kTRUE ; 
<span class="lineNum">     310 </span>            :   const Bool_t image    = kTRUE ; 
<span class="lineNum">     311 </span>            :   
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :   TH1I * h0 = new TH1I(&quot;hEmcalDigits&quot;,    &quot;Digits amplitude distribution in EMCAL;Amplitude [ADC counts];Counts&quot;,    500, 0, 500) ; </span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :   h0-&gt;Sumw2() ;</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :   Add2DigitsList(h0, 0, !expert, image) ;</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :   TH1I * h1 = new TH1I(&quot;hEmcalDigitsMul&quot;, &quot;Digits multiplicity distribution in EMCAL;# of Digits;Entries&quot;, 200, 0, 2000) ; </span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :   h1-&gt;Sumw2() ;</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :   Add2DigitsList(h1, 1, !expert, image) ;</span>
<span class="lineNum">     318 </span>            :   //
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :   ClonePerTrigClass(AliQAv1::kDIGITS); // this should be the last line</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            : //____________________________________________________________________________ 
<span class="lineNum">     323 </span>            : ///
<a name="324"><span class="lineNum">     324 </span>            : /// Create Reconstructed PoInt_ts histograms in RecPoints subdir.</a>
<span class="lineNum">     325 </span>            : ///
<span class="lineNum">     326 </span>            : void AliEMCALQADataMakerRec::InitRecPoints()
<span class="lineNum">     327 </span>            : {
<span class="lineNum">     328 </span>            :   const Bool_t expert   = kTRUE ; 
<span class="lineNum">     329 </span>            :   const Bool_t image    = kTRUE ; 
<span class="lineNum">     330 </span>            :   
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :   TH1F* h0 = new TH1F(&quot;hEMCALRpE&quot;,&quot;EMCAL RecPoint energies;Energy [GeV];Counts&quot;,200, 0.,20.); //GeV</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :   h0-&gt;Sumw2();</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :   Add2RecPointsList(h0,kRecPE, !expert, image);</span>
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :   TH1I* h1 = new TH1I(&quot;hEMCALRpM&quot;,&quot;EMCAL RecPoint multiplicities;# of Clusters;Entries&quot;,100,0,100);</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :   h1-&gt;Sumw2();</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :   Add2RecPointsList(h1,kRecPM, !expert, image);</span>
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :   TH1I* h2 = new TH1I(&quot;hEMCALRpDigM&quot;,&quot;EMCAL RecPoint Digit Multiplicities;# of Digits;Entries&quot;,20,0,20);</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :   h2-&gt;Sumw2();</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :   Add2RecPointsList(h2,kRecPDigM, !expert, image);</span>
<span class="lineNum">     342 </span>            :   //
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :   ClonePerTrigClass(AliQAv1::kRECPOINTS); // this should be the last line</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span>            : //____________________________________________________________________________ 
<span class="lineNum">     347 </span>            : ///
<a name="348"><span class="lineNum">     348 </span>            : ///  Create Raws histograms in Raws subdir.</a>
<span class="lineNum">     349 </span>            : ///
<span class="lineNum">     350 </span>            : void AliEMCALQADataMakerRec::InitRaws()
<span class="lineNum">     351 </span>            : {
<span class="lineNum">     352 </span>            :   const Bool_t expert   = kTRUE ; 
<span class="lineNum">     353 </span>            :   const Bool_t saveCorr = kTRUE ; 
<span class="lineNum">     354 </span>            :   const Bool_t image    = kTRUE ; 
<span class="lineNum">     355 </span>            :   const Option_t *profileOption = &quot;s&quot;;
<span class="lineNum">     356 </span>            :   
<span class="lineNum">     357 </span>            :   Int_t nTowersPerSM = 2*AliEMCALTriggerMappingV2::fNEta*2*AliEMCALTriggerMappingV2::fNPhi; // number of towers in a SuperModule; 24x48
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :   Int_t nTot = fSuperModules * nTowersPerSM; // max number of towers in all SuperModules</span>
<span class="lineNum">     359 </span>            :   
<span class="lineNum">     360 </span>            :   //Defining histograms binning, each 2D histogram covers all SMs
<span class="lineNum">     361 </span>            :   Int_t nTotTRUs = AliEMCALTriggerMappingV2::fNTotalTRU;  
<span class="lineNum">     362 </span>            :   Int_t nSMSectors = fSuperModules / 2; // 2 SMs per sector
<span class="lineNum">     363 </span>            :   Int_t nbinsZ = 2*AliEMCALTriggerMappingV2::fSTURegionNEta;
<span class="lineNum">     364 </span>            :   Int_t nbinsPhi = 2*AliEMCALTriggerMappingV2::fSTURegionNPhi;
<span class="lineNum">     365 </span>            :   
<span class="lineNum">     366 </span>            :   Int_t nTRUCols = nbinsZ/2; // total TRU columns for 2D TRU histos
<span class="lineNum">     367 </span>            :   Int_t nTRURows = nbinsPhi/2; // total TRU rows for 2D TRU histos
<span class="lineNum">     368 </span>            :                                // counter info: number of channels per event (bins are SM index)
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :   TProfile * h0 = new TProfile(&quot;hLowEmcalSupermodules&quot;, &quot;Low Gain EMC: # of towers vs SuperMod;SM Id;# of towers&quot;,</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :                                fSuperModules, -0.5, fSuperModules-0.5, profileOption) ;</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :   Add2RawsList(h0, kNsmodLG, !expert, !image, !saveCorr) ;</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :   TProfile * h1 = new TProfile(&quot;hHighEmcalSupermodules&quot;, &quot;High Gain EMC: # of towers vs SuperMod;SM Id;# of towers&quot;,  </span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :                                fSuperModules, -0.5, fSuperModules-0.5, profileOption) ; </span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :   Add2RawsList(h1, kNsmodHG, !expert, !image, !saveCorr) ;</span>
<span class="lineNum">     375 </span>            :   
<span class="lineNum">     376 </span>            :   // where did max sample occur? (bins are towers)
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :   TProfile * h2 = new TProfile(&quot;hLowEmcalRawtime&quot;, &quot;Low Gain EMC: Time at Max vs towerId;Tower Id;Time [ticks]&quot;, </span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :                                nTot, -0.5, nTot-0.5, profileOption) ;</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :   Add2RawsList(h2, kTimeLG, expert, !image, !saveCorr) ;</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :   TProfile * h3 = new TProfile(&quot;hHighEmcalRawtime&quot;, &quot;High Gain EMC: Time at Max vs towerId;Tower Id;Time [ticks]&quot;, </span>
<span class="lineNum">     381 </span>            :                                nTot, -0.5, nTot-0.5, profileOption) ;
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :   Add2RawsList(h3, kTimeHG, expert, !image, !saveCorr) ;</span>
<span class="lineNum">     383 </span>            :   
<span class="lineNum">     384 </span>            :   // how much above pedestal was the max sample?  (bins are towers)
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :   TProfile * h4 = new TProfile(&quot;hLowEmcalRawMaxMinusMin&quot;, &quot;Low Gain EMC: Max - Min vs towerId;Tower Id;Max-Min [ADC counts]&quot;, </span>
<span class="lineNum">     386 </span>            :                                nTot, -0.5, nTot-0.5, profileOption) ;
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :   Add2RawsList(h4, kSigLG, !expert, !image, !saveCorr) ;</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :   TProfile * h5 = new TProfile(&quot;hHighEmcalRawMaxMinusMin&quot;, &quot;High Gain EMC: Max - Min vs towerId;Tower Id;Max-Min [ADC counts]&quot;,</span>
<span class="lineNum">     389 </span>            :                                nTot, -0.5, nTot-0.5, profileOption) ;
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :   Add2RawsList(h5, kSigHG, !expert, !image, !saveCorr) ;</span>
<span class="lineNum">     391 </span>            :   
<span class="lineNum">     392 </span>            :   // total counter: channels per event
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :   TH1I * h6 = new TH1I(&quot;hLowNtot&quot;, &quot;Low Gain EMC: Total Number of found towers;# of Towers;Counts&quot;, 200, 0, nTot) ;</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :   h6-&gt;Sumw2() ;</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :   Add2RawsList(h6, kNtotLG, !expert, !image, !saveCorr) ;</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :   TH1I * h7 = new TH1I(&quot;hHighNtot&quot;, &quot;High Gain EMC: Total Number of found towers;# of Towers;Counts&quot;, 200,0, nTot) ;</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :   h7-&gt;Sumw2() ;</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :   Add2RawsList(h7, kNtotHG, !expert, !image, !saveCorr) ;</span>
<span class="lineNum">     399 </span>            :   
<span class="lineNum">     400 </span>            :   // pedestal (bins are towers)
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :   TProfile * h8 = new TProfile(&quot;hLowEmcalRawPed&quot;, &quot;Low Gain EMC: Pedestal vs towerId;Tower Id;Pedestal [ADC counts]&quot;, </span>
<span class="lineNum">     402 </span>            :                                nTot, -0.5, nTot-0.5, profileOption) ;
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :   Add2RawsList(h8, kPedLG, expert, !image, !saveCorr) ;</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :   TProfile * h9 = new TProfile(&quot;hHighEmcalRawPed&quot;, &quot;High Gain EMC: Pedestal vs towerId;Tower Id;Pedestal [ADC counts]&quot;,</span>
<span class="lineNum">     405 </span>            :                                nTot, -0.5, nTot-0.5, profileOption) ;
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :   Add2RawsList(h9, kPedHG, expert, !image, !saveCorr) ;</span>
<span class="lineNum">     407 </span>            :   
<span class="lineNum">     408 </span>            :   
<span class="lineNum">     409 </span>            :   // now repeat the same for TRU and LEDMon data
<span class="lineNum">     410 </span>            :   Int_t nTot2x2 = nTotTRUs*AliEMCALTriggerMappingV2::fNModulesInTRU; // max number of TRU channels for all SuperModules
<span class="lineNum">     411 </span>            :   
<span class="lineNum">     412 </span>            :   // counter info: number of channels per event (bins are SM index)
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :   TProfile * hT0 = new TProfile(&quot;hTRUEmcalSupermodules&quot;, &quot;TRU EMC: # of TRU channels vs SuperMod;SM Id;# of TRU channels&quot;,</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :                                 fSuperModules, -0.5, fSuperModules-0.5, profileOption) ;</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :   Add2RawsList(hT0, kNsmodTRU, expert, !image, !saveCorr) ;</span>
<span class="lineNum">     416 </span>            :   
<span class="lineNum">     417 </span>            :   // how much above pedestal was the max sample?  (bins are TRU channels)
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :   TProfile * hT1 = new TProfile(&quot;hTRUEmcalRawMaxMinusMin&quot;, &quot;TRU EMC: Max - Min vs 2x2Id;2x2 Id;Max-Min [ADC counts]&quot;, </span>
<span class="lineNum">     419 </span>            :                                 nTot2x2, -0.5, nTot2x2-0.5, profileOption) ;
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :   Add2RawsList(hT1, kSigTRU, expert, !image, !saveCorr) ;</span>
<span class="lineNum">     421 </span>            :   
<span class="lineNum">     422 </span>            :   // total counter: channels per event
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :   TH1I * hT2 = new TH1I(&quot;hTRUNtot&quot;, &quot;TRU EMC: Total Number of found TRU channels;# of TRU Channels;Counts&quot;, 200, 0, nTot2x2) ;</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :   hT2-&gt;Sumw2() ;</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :   Add2RawsList(hT2, kNtotTRU, expert, !image, !saveCorr) ;</span>
<span class="lineNum">     426 </span>            :   
<span class="lineNum">     427 </span>            :   // L0 trigger hits: # of hits (bins are TRU channels)
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :   TH2I * hT3 = new TH2I(&quot;hTRUEmcalL0hits&quot;, &quot;L0 trigger hits: Total number of 2x2 L0 generated&quot;,  nTRUCols, -0.5, nTRUCols - 0.5, nTRURows, -0.5, nTRURows-0.5);</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :   hT3-&gt;SetOption(&quot;COLZ&quot;);</span>
<span class="lineNum">     430 </span>            :   //hT3-&gt;Sumw2();
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :   Add2RawsList(hT3, kNL0TRU, !expert, image, !saveCorr);</span>
<span class="lineNum">     432 </span>            :   
<span class="lineNum">     433 </span>            :   // L0 trigger hits: average time (bins are TRU channels)
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :   TProfile2D * hT4 = new TProfile2D(&quot;hTRUEmcalL0hitsAvgTime&quot;, &quot;L0 trigger hits: average time bin&quot;, nTRUCols, -0.5, nTRUCols - 0.5, nTRURows, -0.5, nTRURows-0.5, profileOption);</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :   hT4-&gt;SetOption(&quot;COLZ&quot;);</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :   Add2RawsList(hT4, kTimeL0TRU, !expert, image, !saveCorr);</span>
<span class="lineNum">     437 </span>            :   
<span class="lineNum">     438 </span>            :   // L0 trigger hits: first in the event (bins are TRU channels)
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :   TH1I * hT5 = new TH1I(&quot;hTRUEmcalL0hitsFirst&quot;, &quot;L0 trigger hits: First hit in the event&quot;, nTot2x2, -0.5, nTot2x2);</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :   hT5-&gt;Sumw2();</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :   Add2RawsList(hT5, kNL0FirstTRU, expert, !image, !saveCorr);</span>
<span class="lineNum">     442 </span>            :   
<span class="lineNum">     443 </span>            :   // L0 trigger hits: average time of first hit in the event (bins are TRU channels)
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :   TProfile * hT6 = new TProfile(&quot;hTRUEmcalL0hitsFirstAvgTime&quot;, &quot;L0 trigger hits: average time of first hit&quot;, nTot2x2, -0.5, nTot2x2, profileOption); </span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :   Add2RawsList(hT6, kTimeL0FirstTRU, expert, !image, !saveCorr);</span>
<span class="lineNum">     446 </span>            :   
<span class="lineNum">     447 </span>            :   // L0 number of time sample: # of samples over the threshold out of the 13 time sample (bins are TRU channels)
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :   TH2I * hT7 = new TH2I(&quot;hTRUEmcalL0Samples&quot;, &quot;L0 fired trigger within a bunch per Patch&quot;, nTRUCols, -0.5, nTRUCols-0.5, nTRURows, -0.5, nTRURows-0.5);</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :   hT7-&gt;SetOption(&quot;COLZ&quot;);</span>
<span class="lineNum">     450 </span>            :   //hT3-&gt;Sumw2();
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :   Add2RawsList(hT7, kNL0TRUSamples, !expert, image, !saveCorr);</span>
<span class="lineNum">     452 </span>            :   
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :   TH1F * hT8 = new TH1F(&quot;hRMSOfnTimes&quot;, &quot;Dispersion of Time for Fired Triggers per Patch&quot;, nTRUCols*nTRURows, -0.5, nTRUCols*nTRURows-0.5);</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :   hT8-&gt;Sumw2();</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :   Add2RawsList(hT8, kNL0TRURMS, !expert, image, !saveCorr);</span>
<span class="lineNum">     456 </span>            :   
<span class="lineNum">     457 </span>            :   // and also LED Mon..
<span class="lineNum">     458 </span>            :   // LEDMon has both high and low gain channels, just as regular FEE/towers
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :   Int_t nTotLEDMon = fSuperModules * AliEMCALGeoParams::fgkEMCALLEDRefs; // max number of LEDMon channels for all SuperModules </span>
<span class="lineNum">     460 </span>            :   
<span class="lineNum">     461 </span>            :   // counter info: number of channels per event (bins are SM index)
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :   TProfile * hL0 = new TProfile(&quot;hLowLEDMonEmcalSupermodules&quot;, &quot;LowLEDMon Gain EMC: # of strips vs SuperMod;SM Id;# of strips&quot;,</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :                                 fSuperModules, -0.5, fSuperModules-0.5, profileOption) ;</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :   Add2RawsList(hL0, kNsmodLGLEDMon, expert, !image, !saveCorr) ;</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :   TProfile * hL1 = new TProfile(&quot;hHighLEDMonEmcalSupermodules&quot;, &quot;HighLEDMon Gain EMC: # of strips vs SuperMod;SM Id;# of strips&quot;,  </span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :                                 fSuperModules, -0.5, fSuperModules-0.5, profileOption) ; </span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :   Add2RawsList(hL1, kNsmodHGLEDMon, expert, !image, !saveCorr) ;</span>
<span class="lineNum">     468 </span>            :   
<span class="lineNum">     469 </span>            :   // where did max sample occur? (bins are strips)
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :   TProfile * hL2 = new TProfile(&quot;hLowLEDMonEmcalRawtime&quot;, &quot;LowLEDMon Gain EMC: Time at Max vs stripId;Strip Id;Time [ticks]&quot;, </span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :                                 nTotLEDMon, -0.5, nTotLEDMon-0.5, profileOption) ;</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :   Add2RawsList(hL2, kTimeLGLEDMon, expert, !image, !saveCorr) ;</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :   TProfile * hL3 = new TProfile(&quot;hHighLEDMonEmcalRawtime&quot;, &quot;HighLEDMon Gain EMC: Time at Max vs stripId;Strip Id;Time [ticks]&quot;, </span>
<span class="lineNum">     474 </span>            :                                 nTotLEDMon, -0.5, nTotLEDMon-0.5, profileOption) ;
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :   Add2RawsList(hL3, kTimeHGLEDMon, expert, !image, !saveCorr) ;</span>
<span class="lineNum">     476 </span>            :   
<span class="lineNum">     477 </span>            :   // how much above pedestal was the max sample?  (bins are strips)
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :   TProfile * hL4 = new TProfile(&quot;hLowLEDMonEmcalRawMaxMinusMin&quot;, &quot;LowLEDMon Gain EMC: Max - Min vs stripId;Strip Id;Max-Min [ADC counts]&quot;, </span>
<span class="lineNum">     479 </span>            :                                 nTotLEDMon, -0.5, nTotLEDMon-0.5, profileOption) ;
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :   Add2RawsList(hL4, kSigLGLEDMon, expert, !image, !saveCorr) ;</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :   TProfile * hL5 = new TProfile(&quot;hHighLEDMonEmcalRawMaxMinusMin&quot;, &quot;HighLEDMon Gain EMC: Max - Min vs stripId;Strip Id;Max-Min [ADC counts]&quot;,</span>
<span class="lineNum">     482 </span>            :                                 nTotLEDMon, -0.5, nTotLEDMon-0.5, profileOption) ;
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :   Add2RawsList(hL5, kSigHGLEDMon, expert, !image, !saveCorr) ;</span>
<span class="lineNum">     484 </span>            :   
<span class="lineNum">     485 </span>            :   // total counter: channels per event
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :   TH1I * hL6 = new TH1I(&quot;hLowLEDMonNtot&quot;, &quot;LowLEDMon Gain EMC: Total Number of found strips;# of Strips;Counts&quot;, 200, 0, nTotLEDMon) ;</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :   hL6-&gt;Sumw2() ;</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :   Add2RawsList(hL6, kNtotLGLEDMon, expert, !image, !saveCorr) ;</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :   TH1I * hL7 = new TH1I(&quot;hHighLEDMonNtot&quot;, &quot;HighLEDMon Gain EMC: Total Number of found strips;# of Strips;Counts&quot;, 200,0, nTotLEDMon) ;</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :   hL7-&gt;Sumw2() ;</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :   Add2RawsList(hL7, kNtotHGLEDMon, expert, !image, !saveCorr) ;</span>
<span class="lineNum">     492 </span>            :   
<span class="lineNum">     493 </span>            :   // pedestal (bins are strips)
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :   TProfile * hL8 = new TProfile(&quot;hLowLEDMonEmcalRawPed&quot;, &quot;LowLEDMon Gain EMC: Pedestal vs stripId;Strip Id;Pedestal [ADC counts]&quot;, </span>
<span class="lineNum">     495 </span>            :                                 nTotLEDMon, -0.5, nTotLEDMon-0.5, profileOption) ;
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :   Add2RawsList(hL8, kPedLGLEDMon, expert, !image, !saveCorr) ;</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :   TProfile * hL9 = new TProfile(&quot;hHighLEDMonEmcalRawPed&quot;, &quot;HighLEDMon Gain EMC: Pedestal vs stripId;Strip Id;Pedestal [ADC counts]&quot;,</span>
<span class="lineNum">     498 </span>            :                                 nTotLEDMon, -0.5, nTotLEDMon-0.5, profileOption) ;
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :   Add2RawsList(hL9, kPedHGLEDMon, expert, !image, !saveCorr) ;</span>
<span class="lineNum">     500 </span>            :   
<span class="lineNum">     501 </span>            :   // temp 2D amplitude histogram for the current run
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :   fHighEmcHistoH2F = new TH2F(&quot;h2DHighEC2&quot;, &quot;High Gain EMC:Max - Min [ADC counts]&quot;, nbinsZ, -0.5 , nbinsZ-0.5, nbinsPhi, -0.5, nbinsPhi-0.5);</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :   fHighEmcHistoH2F-&gt;SetDirectory(0) ; // this histo must be memory resident</span>
<span class="lineNum">     504 </span>            :                                       // add ratio histograms: to comapre the current run with the reference data 
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :   TH2F * h15 = new TH2F(&quot;h2DRatioAmp&quot;, &quot;High Gain Ratio to Reference:Amplitude_{current run}/Amplitude_{reference run}&quot;, nbinsZ, -0.5 , nbinsZ-0.5, </span>
<span class="lineNum">     506 </span>            :                         nbinsPhi, -0.5, nbinsPhi-0.5);
<span class="lineNum">     507 </span>            :   // settings for display in amore
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :   h15-&gt;SetTitle(&quot;Amplitude_{current run}/Amplitude_{reference run}&quot;); </span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :   h15-&gt;SetMaximum(2.0);</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :   h15-&gt;SetMinimum(0.1);</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :   h15-&gt;SetOption(&quot;COLZ&quot;);</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :   gStyle-&gt;SetOptStat(0);</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :   Int_t color[] = {4,3,2} ;</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :   gStyle-&gt;SetPalette(3,color);</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :   h15-&gt;GetZaxis()-&gt;SetNdivisions(3);</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :   h15-&gt;UseCurrentStyle();</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :   h15-&gt;SetDirectory(0);</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :   Add2RawsList(h15, k2DRatioAmp, !expert, image, !saveCorr) ;</span>
<span class="lineNum">     519 </span>            :   
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :   TH1F * h16 = new TH1F(&quot;hRatioDist&quot;, &quot;Amplitude_{current run}/Amplitude_{reference run} ratio distribution&quot;, nTot, 0., 10000.);</span>
<span class="lineNum">     521 </span>            :   // h16-&gt;SetMinimum(0.1); 
<span class="lineNum">     522 </span>            :   // h16-&gt;SetMaximum(100.);
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :   gStyle-&gt;SetOptStat(0);</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :   h16-&gt;UseCurrentStyle();</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :   h16-&gt;SetDirectory(0);</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :   Add2RawsList(h16, kRatioDist, !expert, image, !saveCorr) ;</span>
<span class="lineNum">     527 </span>            :   
<span class="lineNum">     528 </span>            :   // add two histograms for shifter from the LED monitor system: comapre LED monitor with the reference run
<span class="lineNum">     529 </span>            :   // to be used for decision whether we need to change reference data
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :   TH1F * hL10 = new TH1F(&quot;hMaxMinusMinLEDMonRatio&quot;, &quot;LEDMon amplitude, Ratio to reference run&quot;, nTotLEDMon, -0.5, nTotLEDMon-0.5) ;</span>
<span class="lineNum">     531 </span>            :   // settings for display in amore
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :   hL10-&gt;SetTitle(&quot;Amplitude_{LEDMon current}/Amplitude_{LEDMon reference}&quot;); </span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :   hL10-&gt;SetMaximum(2.0);</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :   hL10-&gt;SetMinimum(0.1); </span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :   gStyle-&gt;SetOptStat(0);</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :   hL10-&gt;UseCurrentStyle();</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :   hL10-&gt;SetDirectory(0);</span>
<span class="lineNum">     538 </span>            :   //  hL10-&gt;SetOption(&quot;E&quot;);
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :   Add2RawsList(hL10, kLEDMonRatio, !expert, image, !saveCorr) ;</span>
<span class="lineNum">     540 </span>            :   
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :   TH1F * hL11 = new TH1F(&quot;hMaxMinusMinLEDMonRatioDist&quot;, &quot;LEDMon amplitude, Ratio distribution&quot;, nTotLEDMon, 0, 2);</span>
<span class="lineNum">     542 </span>            :   // hL11-&gt;SetMinimum(0.1) ;
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :   gStyle-&gt;SetOptStat(0);</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :   hL11-&gt;UseCurrentStyle();</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :   hL11-&gt;SetDirectory(0);</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :   Add2RawsList(hL11, kLEDMonRatioDist, !expert, image, !saveCorr) ;</span>
<span class="lineNum">     547 </span>            :   
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :   GetCalibRefFromOCDB();   </span>
<span class="lineNum">     549 </span>            :   
<span class="lineNum">     550 </span>            :   // STU histgrams
<span class="lineNum">     551 </span>            :   
<span class="lineNum">     552 </span>            :   // histos
<span class="lineNum">     553 </span>            :   Int_t nSTUCols = nbinsZ/2;
<span class="lineNum">     554 </span>            :   Int_t nSTURows = nbinsPhi/2;
<span class="lineNum">     555 </span>            :   //            kAmpL1, kGL1, kJL1,
<span class="lineNum">     556 </span>            :   //            kGL1V0, kJL1V0, kSTUTRU  
<span class="lineNum">     557 </span>            :   
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :   TProfile2D *hS0 = new TProfile2D(&quot;hL1Amp&quot;, &quot;Mean STU signal per Row and Column&quot;, nSTUCols, -0.5, nSTUCols-0.5, nSTURows, -0.5, nSTURows-0.5);</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :   Add2RawsList(hS0, kAmpL1, expert, !image, !saveCorr) ;</span>
<span class="lineNum">     560 </span>            :   //+5 for better visible error box
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :   TH2F *hS1 = new TH2F(&quot;hL1Gamma&quot;, &quot;L1 Gamma patch position (FastOR top-left)&quot;, nSTUCols, -0.50, nSTUCols-0.5, nSTURows + 5, -0.5, nSTURows-0.5 + 5); </span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :   Add2RawsList(hS1, kGL1, !expert, image, !saveCorr) ;</span>
<span class="lineNum">     563 </span>            :   
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :   TH2F *hS2 = new TH2F(&quot;hL1Jet&quot;, &quot;L1 Jet patch position (FastOR top-left)&quot;, 12, -0.5, nSTUCols-0.5, 16, 0, nSTURows-0.5);</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :   Add2RawsList(hS2, kJL1, !expert, image, !saveCorr) ;</span>
<span class="lineNum">     566 </span>            :   
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :   TH2I *hS3 = new TH2I(&quot;hL1GV0&quot;, &quot;L1 Gamma patch amplitude versus V0 signal&quot;, 500, 0, 50000, 1500, 0, 1500);</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :   Add2RawsList(hS3, kGL1V0, expert, image, !saveCorr) ;</span>
<span class="lineNum">     569 </span>            :   
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :   TH2I *hS4 = new TH2I(&quot;hL1JV0&quot;, &quot;L1 Jet patch amplitude versus V0 signal&quot;, 500, 0, 50000, 1000, 0, 1000);</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :   Add2RawsList(hS4, kJL1V0, expert, !image, !saveCorr) ;</span>
<span class="lineNum">     572 </span>            :   
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :   TH1I *hS5 = new TH1I(&quot;hFrameR&quot;,&quot;Link between TRU and STU&quot;, AliEMCALTriggerMappingV2::fNTotalTRU, 0, AliEMCALTriggerMappingV2::fNTotalTRU);</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :   Add2RawsList(hS5, kSTUTRU, !expert, image, !saveCorr) ;</span>
<span class="lineNum">     575 </span>            :   
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :   hS0-&gt;SetOption(&quot;COLZ&quot;);</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :   hS1-&gt;SetOption(&quot;COLZ&quot;);</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :   hS2-&gt;SetOption(&quot;COLZ&quot;);</span>
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :   hS3-&gt;SetOption(&quot;COLZ&quot;);</span>
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :   hS4-&gt;SetOption(&quot;COLZ&quot;);</span>
<span class="lineNum">     581 </span>            :   
<span class="lineNum">     582 </span>            :   // 
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :   ClonePerTrigClass(AliQAv1::kRAWS); // this should be the last line</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span>            : //____________________________________________________________________________
<span class="lineNum">     588 </span>            : ///
<span class="lineNum">     589 </span>            : /// Make QA data from ESDs.
<span class="lineNum">     590 </span>            : ///
<a name="591"><span class="lineNum">     591 </span>            : /// \param esd: AliESDEvent</a>
<span class="lineNum">     592 </span>            : ///
<span class="lineNum">     593 </span>            : void AliEMCALQADataMakerRec::MakeESDs(AliESDEvent * esd)
<span class="lineNum">     594 </span>            : {
<span class="lineNum">     595 </span>            :   Int_t nTot = 0 ; 
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :   for ( Int_t index = 0; index &lt; esd-&gt;GetNumberOfCaloClusters() ; index++ ) {</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :     AliESDCaloCluster * clu = esd-&gt;GetCaloCluster(index) ;</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :     if( clu-&gt;IsEMCAL() ) {</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :       FillESDsData(kESDCaloClusE,clu-&gt;E()) ;</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :       nTot++ ;</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :     } </span>
<span class="lineNum">     602 </span>            :   }
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :   FillESDsData(kESDCaloClusM,nTot) ;</span>
<span class="lineNum">     604 </span>            :   
<span class="lineNum">     605 </span>            :   // fill calo cells
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :   AliESDCaloCells* cells = esd-&gt;GetEMCALCells();</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :   FillESDsData(kESDCaloCellM,cells-&gt;GetNumberOfCells()) ;</span>
<span class="lineNum">     608 </span>            :   
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :   for ( Int_t index = 0; index &lt; cells-&gt;GetNumberOfCells() ; index++ ) {</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :     FillESDsData(kESDCaloCellA,cells-&gt;GetAmplitude(index)) ;</span>
<span class="lineNum">     611 </span>            :   }
<span class="lineNum">     612 </span>            :   
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :   IncEvCountCycleESDs();</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :   IncEvCountTotalESDs();</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span>            : //____________________________________________________________________________
<span class="lineNum">     618 </span>            : ///
<span class="lineNum">     619 </span>            : /// Make the histograms for Raw data.
<span class="lineNum">     620 </span>            : ///
<a name="621"><span class="lineNum">     621 </span>            : /// \param rawReader: AliRawReader</a>
<span class="lineNum">     622 </span>            : ///
<span class="lineNum">     623 </span>            : void AliEMCALQADataMakerRec::MakeRaws(AliRawReader* rawReader)
<span class="lineNum">     624 </span>            : {
<span class="lineNum">     625 </span>            :   // Check that all the reference histograms exist before we try to use them - otherwise call InitRaws
<span class="lineNum">     626 </span>            :   // RS: Attention: the counters are increments after custom modification of eventSpecie
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :   if (!fCalibRefHistoPro || !fCalibRefHistoH2F || !fLEDMonRefHistoPro || !fHighEmcHistoH2F) {</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :     InitRaws();</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     630 </span>            :   
<span class="lineNum">     631 </span>            :   // make sure EMCal was readout during the event
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :   Int_t emcID = AliDAQ::DetectorID(&quot;EMCAL&quot;); // bit 18..</span>
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :   const UInt_t *detPattern = rawReader-&gt;GetDetectorPattern(); </span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :   UInt_t emcInReadout = ( ((1 &lt;&lt; emcID) &amp; detPattern[0]) &gt;&gt; emcID);</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :   if (! emcInReadout) return; // no poInt_t in looking at this event, if no EMCal data</span>
<span class="lineNum">     636 </span>            :   
<span class="lineNum">     637 </span>            :   // setup
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :   rawReader-&gt;Reset() ;</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :   AliCaloRawStreamV3 in(rawReader,&quot;EMCAL&quot;); </span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :   rawReader-&gt;Select(&quot;EMCAL&quot;,0,AliDAQ::GetFirstSTUDDL()-1) ; // select EMCAL DDL's </span>
<span class="lineNum">     641 </span>            :   
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :   AliRecoParam::EventSpecie_t saveSpecie = fEventSpecie ;</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :   if (rawReader-&gt;GetType() == AliRawEventHeaderBase::kCalibrationEvent) { </span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :     SetEventSpecie(AliRecoParam::kCalib) ;      </span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     646 </span>            :   const Int_t nTowColsPerSM= 2 * AliEMCALTriggerMappingV2::fNEta;
<span class="lineNum">     647 </span>            :   const Int_t nTowRowsPerSM= 2 * AliEMCALTriggerMappingV2::fNPhi; // number of rows per SuperModule
<span class="lineNum">     648 </span>            :   
<span class="lineNum">     649 </span>            :   const Int_t nTowersPerSM = 2*AliEMCALTriggerMappingV2::fNEta*2*AliEMCALTriggerMappingV2::fNPhi; // number of towers in a SuperModule; 24x48
<span class="lineNum">     650 </span>            :   const Int_t nRows        = 2*AliEMCALTriggerMappingV2::fNPhi; // number of rows per SuperModule
<span class="lineNum">     651 </span>            :   const Int_t nStripsPerSM = AliEMCALGeoParams::fgkEMCALLEDRefs; // number of strips per SuperModule 
<span class="lineNum">     652 </span>            :   const Int_t n2x2PerSM    = AliEMCALTriggerMappingV2::fNTRU * AliEMCALTriggerMappingV2::fNModulesInTRU; // number of TRU 2x2's per SuperModule
<span class="lineNum">     653 </span>            :   const Int_t n2x2PerTRU   = AliEMCALTriggerMappingV2::fNModulesInTRU;
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :   const Int_t nTot2x2      = fSuperModules * n2x2PerSM; // total TRU channel</span>
<span class="lineNum">     655 </span>            :   
<span class="lineNum">     656 </span>            :   Int_t maxNumL0PatchesPerTRU, nTotTRUs;
<span class="lineNum">     657 </span>            :   
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :   if(fGeom-&gt;GetEMCGeometry()-&gt;GetGeoName().Contains(&quot;DCAL&quot;)){</span>
<span class="lineNum">     659 </span>            :     maxNumL0PatchesPerTRU = (AliEMCALTriggerMappingV2::fNModulesInTRUPhi-1)*(AliEMCALTriggerMappingV2::fNModulesInTRUEta-1); // when 4x4 PatchMode for L0 trigger is ON
<span class="lineNum">     660 </span>            :     nTotTRUs = AliEMCALTriggerMappingV2::fNTotalTRU; // 52 TRUs : 32 EMCAL + 20  ( 14 + 6 unused ) DCAL
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     662 </span>            :   else{
<span class="lineNum">     663 </span>            :     maxNumL0PatchesPerTRU = (AliEMCALGeoParams::fgkEMCALTRURows-1)*(AliEMCALGeoParams::fgkEMCALTRUCols -1);
<span class="lineNum">     664 </span>            :     nTotTRUs = AliEMCALGeoParams::fgkEMCALTRUsPerSM * 10 + 2 ; //32 TRUs ( 3*10 Full_SM + 2 1/3_SM )
<span class="lineNum">     665 </span>            :   }
<span class="lineNum">     666 </span>            :   
<span class="lineNum">     667 </span>            :   //const Int_t nTot2x2 = nTotTRUs* n2x2PerTRU;// total TRU channel
<span class="lineNum">     668 </span>            :   
<span class="lineNum">     669 </span>            :   // Set nTRUs array size to maximum possible 52, later it will be filled up to the real maximum
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :   vector &lt;unsigned int&gt; startBins [AliEMCALTriggerMappingV2::fNTotalTRU][n2x2PerTRU];</span>
<span class="lineNum">     671 </span>            :   
<span class="lineNum">     672 </span>            :   // SM counters; decl. should be safe, assuming we don't get more than expected SuperModules..
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :   Int_t nTotalSMLG[AliEMCALGeoParams::fgkEMCALModules]       = {0};</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :   Int_t nTotalSMHG[AliEMCALGeoParams::fgkEMCALModules]       = {0};</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :   Int_t nTotalSMTRU[AliEMCALGeoParams::fgkEMCALModules]      = {0};</span>
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :   Int_t nTotalSMLGLEDMon[AliEMCALGeoParams::fgkEMCALModules] = {0};</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :   Int_t nTotalSMHGLEDMon[AliEMCALGeoParams::fgkEMCALModules] = {0};</span>
<span class="lineNum">     678 </span>            :   
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :   Int_t rmsForTRUL0[AliEMCALTriggerMappingV2::fSTURegionN]={0};</span>
<span class="lineNum">     680 </span>            :   
<span class="lineNum">     681 </span>            :   const Int_t nTRUL0ChannelBits = 10; // used for L0 trigger bits checks
<span class="lineNum">     682 </span>            :   int firstL0TimeBin = 999;
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :   int triggers[nTot2x2][24]; // auxiliary array for L0 trigger - TODO remove hardcoded 24</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :   memset(triggers, 0, sizeof(int) * 24 * nTot2x2);</span>
<span class="lineNum">     685 </span>            :   
<span class="lineNum">     686 </span>            :   // The next 2 array must be up to 96 (n2x2PerTRU) to account for the possibility
<span class="lineNum">     687 </span>            :   // to have 2x2 (single module) L0 trigger patches instead of 4x4 (2x2 modules)
<span class="lineNum">     688 </span>            :   // Set nTRUs array size to maximum possible 52, later it will be filled up to the real maximum
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :   vector&lt;Int_t&gt; timeOfFiredPatches[AliEMCALTriggerMappingV2::fNTotalTRU][n2x2PerTRU];</span>
<span class="lineNum">     690 </span>            :   
<span class="lineNum">     691 </span>            :   bool is2x2PatchModeActive = false; //default in Run2 is 4x4 Patch for L0 trigger
<span class="lineNum">     692 </span>            :   Int_t iSM = 0; // SuperModule index 
<span class="lineNum">     693 </span>            :                  // start loop over input stream  
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :   while (in.NextDDL()) {</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :     Int_t iRCU = in.GetDDLNumber() % 2; // RCU0 or RCU1, within SuperModule</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :     Int_t iDDL = in.GetDDLNumber();</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :     fRawAnalyzer-&gt;SetIsZeroSuppressed( in.GetZeroSupp() ); </span>
<span class="lineNum">     698 </span>            :     
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :     while (in.NextChannel()) {</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :       Int_t iBranch = in.GetBranch();</span>
<span class="lineNum">     701 </span>            :       
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :       iSM = in.GetModule(); // SuperModule</span>
<span class="lineNum">     703 </span>            :                             //prInt_tf(&quot;iSM %d DDL %d&quot;, iSM, in.GetDDLNumber()); 
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :       if (iSM&gt;=0 &amp;&amp; iSM&lt;fSuperModules) { // valid module reading</span>
<span class="lineNum">     705 </span>            :         
<span class="lineNum">     706 </span>            :         Int_t nsamples = 0;
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :         vector&lt;AliCaloBunchInfo&gt; bunchlist; </span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :         while (in.NextBunch()) {</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :           nsamples += in.GetBunchLength();</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :           bunchlist.push_back( AliCaloBunchInfo(in.GetStartTimeBin(), in.GetBunchLength(), in.GetSignals() ) );</span>
<span class="lineNum">     711 </span>            :         }  //Storing of each bunch per channel
<span class="lineNum">     712 </span>            :         
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :         if (nsamples &gt; 0) { // this check is needed for when we have zero-supp. on, but not sparse readout</span>
<span class="lineNum">     714 </span>            :           Float_t time = 0.; 
<span class="lineNum">     715 </span>            :           Float_t amp  = 0.; 
<span class="lineNum">     716 </span>            :           // indices for pedestal calc.
<span class="lineNum">     717 </span>            :           Int_t firstPedSample = 0;
<span class="lineNum">     718 </span>            :           Int_t lastPedSample  = 0;
<span class="lineNum">     719 </span>            :           bool isTRUL0IdData   = false;
<span class="lineNum">     720 </span>            :           
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :           if (! in.IsTRUData() ) { // high gain, low gain, LED Mon data - all have the same shaper/sampling </span>
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :             AliCaloFitResults fitResults = fRawAnalyzer-&gt;Evaluate( bunchlist, in.GetAltroCFG1(), in.GetAltroCFG2()); </span>
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :             amp  = fitResults.GetAmp();</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :             time = fitResults.GetTof(); </span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :             firstPedSample = fFirstPedestalSample;</span>
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :             lastPedSample  = fLastPedestalSample;</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">     728 </span>            :           else { // TRU data is special, needs its own analyzer
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :             AliCaloFitResults fitResults = fRawAnalyzerTRU-&gt;Evaluate( bunchlist, in.GetAltroCFG1(), in.GetAltroCFG2()); </span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :             amp  = fitResults.GetAmp();</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :             time = fitResults.GetTof(); </span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :             firstPedSample = fFirstPedestalSampleTRU;</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :             lastPedSample  = fLastPedestalSampleTRU;</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :             if (in.GetColumn() &gt;= n2x2PerTRU) {</span>
<span class="lineNum">     735 </span>            :               isTRUL0IdData = true;
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">     738 </span>            :           
<span class="lineNum">     739 </span>            :           // pedestal samples
<span class="lineNum">     740 </span>            :           Int_t nPed = 0;
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :           vector&lt;Int_t&gt; pedSamples; </span>
<span class="lineNum">     742 </span>            :           
<span class="lineNum">     743 </span>            :           // select earliest bunch 
<span class="lineNum">     744 </span>            :           unsigned int bunchIndex = 0;
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :           unsigned int startBin = bunchlist.at(0).GetStartBin();</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :           if (bunchlist.size() &gt; 0) {</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :             for(unsigned int ui=1; ui &lt; bunchlist.size(); ui++ ) {</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :               if (startBin &gt; bunchlist.at(ui).GetStartBin() ) {</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :                 startBin = bunchlist.at(ui).GetStartBin();</span>
<span class="lineNum">     750 </span>            :                 bunchIndex = ui;
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :               }</span>
<span class="lineNum">     752 </span>            :             }
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :           }//bunch size and select earliest bunch</span>
<span class="lineNum">     754 </span>            :           
<span class="lineNum">     755 </span>            :           // check bunch for entries in the pedestal sample range
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :           Int_t bunchLength = bunchlist.at(bunchIndex).GetLength(); </span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :           const UShort_t *sig = bunchlist.at(bunchIndex).GetData();</span>
<span class="lineNum">     758 </span>            :           Int_t timebin = 0;
<span class="lineNum">     759 </span>            :           
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :           if (! isTRUL0IdData) { // regular data, can look at pedestals</span>
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :             for (Int_t i = 0; i&lt;bunchLength; i++) {</span>
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :               timebin = startBin--;</span>
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :               if ( firstPedSample&lt;=timebin &amp;&amp; timebin&lt;=lastPedSample ) {</span>
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :                 pedSamples.push_back( sig[i] );</span>
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :                 nPed++;</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :               }     </span>
<span class="lineNum">     767 </span>            :             } // i
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :           }//PEDESTALS FOR REGULARE DATA!</span>
<span class="lineNum">     769 </span>            :           
<span class="lineNum">     770 </span>            :           /***************/
<span class="lineNum">     771 </span>            :           // Storing TRUL0Id Data
<span class="lineNum">     772 </span>            :           else { // TRU L0 Id Data
<span class="lineNum">     773 </span>            :                  // which TRU the channel belongs to?
<span class="lineNum">     774 </span>            :                  //Int_t iTRUId = in.GetModule()*3 + (iRCU*in.GetBranch() + iRCU);    
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :             Int_t iHWaddress = in.GetHWAddress();</span>
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :             Int_t iTRUId = fGeom-&gt;GetTRUIndexFromOnlineHwAdd(iHWaddress,iRCU,iSM);</span>
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :             for (Int_t i = 0; i&lt; bunchLength; i++) {</span>
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :               for( Int_t j = 0; j &lt; nTRUL0ChannelBits; j++ ){</span>
<span class="lineNum">     779 </span>            :                 // check if the bit j is 1
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :                 if( (sig[i] &amp; ( 1 &lt;&lt; j )) &gt; 0 ){</span>
<span class="lineNum">     781 </span>            :                   
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :                   Int_t iPatchInTRU = (in.GetColumn() - n2x2PerTRU)*nTRUL0ChannelBits+j;</span>
<span class="lineNum">     783 </span>            :                   
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :                   if(iPatchInTRU&lt;n2x2PerTRU){</span>
<span class="lineNum">     785 </span>            :                          //printf(&quot;iTRU %d\tiPatchinTRU %d\tstartBin %d&quot;,iTRUId,iPatchInTRU,startBin) ;
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :                     timeOfFiredPatches[iTRUId][iPatchInTRU].push_back(startBin);</span>
<span class="lineNum">     787 </span>            :                     //printf(&quot;\tnumber of times a patch has fired: %d\n&quot;,timeOfFiredPatches[iTRUId][iPatchInTRU].size());
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :                     startBins[iTRUId][iPatchInTRU].push_back(startBin);</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :                     if((int)startBin &lt; firstL0TimeBin) firstL0TimeBin = startBin;</span>
<span class="lineNum">     790 </span>            :                   }
<span class="lineNum">     791 </span>            :                   else{
<span class="lineNum">     792 </span>            :                     //only possible if in.GetColumn()&gt;nFastORinTRU &amp;&amp; in.GetColumn()==105 and the 8th bit of all sig[i] is 1
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :                     if(iPatchInTRU==97)</span>
<span class="lineNum">     794 </span>            :                       is2x2PatchModeActive=true;
<span class="lineNum">     795 </span>            :                     else
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :                       continue;</span>
<span class="lineNum">     797 </span>            :                   }
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :                 }//check if bit j of sig i is 1</span>
<span class="lineNum">     799 </span>            :               }//loop over the 10 bits of each sig[i]
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :               startBin--;</span>
<span class="lineNum">     801 </span>            :             }//loop over the 13 time samples sig[i]
<span class="lineNum">     802 </span>            :           }//TRU L0idData
<span class="lineNum">     803 </span>            :           /***************/ //Go to line 282 for the rest of the L0 code    
<span class="lineNum">     804 </span>            :           
<span class="lineNum">     805 </span>            :           
<span class="lineNum">     806 </span>            :           // fill histograms
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :           Int_t icol = in.GetColumn();</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :           Int_t irow = in.GetRow();</span>
<span class="lineNum">     809 </span>            :           
<span class="lineNum">     810 </span>            :           Int_t towerId = -1;
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :           if ( in.IsLowGain() || in.IsHighGain() ) { // regular towers</span>
<span class="lineNum">     812 </span>            :             
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :             if (iSM &lt; 10) //FULL EMCAL MODULES</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :               towerId = iSM*nTowersPerSM + icol*nTowRowsPerSM + irow;</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :             else if (iSM &gt; 9 &amp;&amp; iSM &lt; 12) //1/3 EMCAL = OFFSET_FULL_EMCAL + iSM,irow,icol -&gt;tower_number (nrows=1/3nrows EMCAL FULL)</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :               towerId = 10*nTowersPerSM + (iSM-10)*nTowColsPerSM*(nTowRowsPerSM/3) + icol*(nTowRowsPerSM/3) + irow;</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :             else if (iSM &gt; 11 &amp;&amp; iSM &lt; 18)//FULL DCAL = OFFSET_FULL_EMCAL+ OFFSET_1/3_EMCAL + iSM,irow,icol -&gt;tower_number</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :               towerId = (iSM-2)*nTowersPerSM + 2*nTowColsPerSM*(nTowRowsPerSM/3) + icol*nTowRowsPerSM + irow;</span>
<span class="lineNum">     819 </span>            :             else //1/3 DCAL = OFFSET_FULL_EMCAL+ OFFSET_1/3_EMCAL+ OFFSET_FULL_DCAL+ iSM,irow,icol -&gt;tower_number (nrows=1/3nrows EM(D)CAL FULL)
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :               towerId = 16*nTowersPerSM + (iSM-16)*nTowColsPerSM*(nTowRowsPerSM/3) + icol*(nTowRowsPerSM/3) + irow;</span>
<span class="lineNum">     821 </span>            :             
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :             if ( in.IsLowGain() ) { </span>
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :               nTotalSMLG[iSM]++; </span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :               if ( (amp &gt; fMinSignalLG) &amp;&amp; (amp &lt; fMaxSignalLG) ) { </span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :                 FillRawsData(kSigLG,towerId, amp);</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :                 FillRawsData(kTimeLG,towerId, time);</span>
<span class="lineNum">     827 </span>            :               }
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :               if (nPed &gt; 0) {</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :                 for (Int_t i=0; i&lt;nPed; i++) {</span>
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :                   FillRawsData(kPedLG,towerId, pedSamples[i]);</span>
<span class="lineNum">     831 </span>            :                 }
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :               }</span>
<span class="lineNum">     833 </span>            :             } // gain==0
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :             else if ( in.IsHighGain() ) {               </span>
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :               nTotalSMHG[iSM]++; </span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :               if ( (amp &gt; fMinSignalHG) &amp;&amp; (amp &lt; fMaxSignalHG) ) { </span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :                 FillRawsData(kSigHG,towerId, amp);</span>
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :                 FillRawsData(kTimeHG,towerId, time);</span>
<span class="lineNum">     839 </span>            :               } 
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :               if (nPed &gt; 0) {</span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :                 for (Int_t i=0; i&lt;nPed; i++) {</span>
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :                   FillRawsData(kPedHG,towerId, pedSamples[i]);</span>
<span class="lineNum">     843 </span>            :                 }
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :               }</span>
<span class="lineNum">     845 </span>            :             } // gain==1
<span class="lineNum">     846 </span>            :           } // low or high gain
<span class="lineNum">     847 </span>            :             // TRU
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :           else if ( in.IsTRUData() &amp;&amp; in.GetColumn()&lt;AliEMCALGeoParams::fgkEMCAL2x2PerTRU) {</span>
<span class="lineNum">     849 </span>            :             // for TRU data, the mapping class holds the TRU Int_ternal 2x2 number (0..95) in the Column var..
<span class="lineNum">     850 </span>            :             // Int_t iTRU = (iRCU*in.GetBranch() + iRCU); // TRU0 is from RCU0, TRU1 from RCU1, TRU2 is from branch B on RCU1
<span class="lineNum">     851 </span>            :             //Int_t iTRU2x2Id = iSM*n2x2PerSM + iTRU*AliEMCALGeoParams::fgkEMCAL2x2PerTRU + in.GetColumn();
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :             Int_t iHWaddress = in.GetHWAddress();</span>
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :             Int_t iTRU = fGeom-&gt;GetTRUIndexFromOnlineHwAdd(iHWaddress,iRCU,iSM); </span>
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :             nTotalSMTRU[iSM]++; </span>
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :             Int_t iTRU2x2Id; </span>
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :             Bool_t gotAbsFastORId=fGeom-&gt;GetAbsFastORIndexFromTRU(iTRU, in.GetColumn(), iTRU2x2Id);</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :             if(!gotAbsFastORId) </span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :               continue;</span>
<span class="lineNum">     859 </span>            :             else{
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :               nTotalSMTRU[iSM]++; </span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :               if ( (amp &gt; fMinSignalTRU) &amp;&amp; (amp &lt; fMaxSignalTRU) ) { </span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :                 FillRawsData(kSigTRU,iTRU2x2Id, amp);</span>
<span class="lineNum">     863 </span>            :                 // FillRawsData(kTimeTRU,iTRU2x2Id, time);
<span class="lineNum">     864 </span>            :               }
<span class="lineNum">     865 </span>            :             }
<span class="lineNum">     866 </span>            :             // if (nPed &gt; 0) {
<span class="lineNum">     867 </span>            :             // for (Int_t i=0; i&lt;nPed; i++) {
<span class="lineNum">     868 </span>            :             // FillRawsData(kPedTRU,iTRU2x2Id, pedSamples[i]);
<span class="lineNum">     869 </span>            :             // }
<span class="lineNum">     870 </span>            :             // }
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :           }//end TRU</span>
<span class="lineNum">     872 </span>            :            // LED Mon
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :           else if ( in.IsLEDMonData() ) {</span>
<span class="lineNum">     874 </span>            :             // for LED Mon data, the mapping class holds the gain info in the Row variable
<span class="lineNum">     875 </span>            :             // and the Strip number in the Column..
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :             Int_t gain = in.GetRow();</span>
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :             Int_t stripId = iSM*nStripsPerSM + in.GetColumn();</span>
<span class="lineNum">     878 </span>            :             
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :             if ( gain == 0 ) {</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :               nTotalSMLGLEDMon[iSM]++;</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :               if ( (amp &gt; fMinSignalLGLEDMon) &amp;&amp; (amp &lt; fMaxSignalLGLEDMon) ) {</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :                 FillRawsData(kSigLGLEDMon,stripId, amp);</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :                 FillRawsData(kTimeLGLEDMon,stripId, time);</span>
<span class="lineNum">     884 </span>            :               }
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :               if (nPed &gt; 0) {</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :                 for (Int_t i=0; i&lt;nPed; i++) {</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :                   FillRawsData(kPedLGLEDMon,stripId, pedSamples[i]);</span>
<span class="lineNum">     888 </span>            :                 }
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :               }</span>
<span class="lineNum">     890 </span>            :             } // gain==0
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :             else if ( gain == 1 ) {</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :               nTotalSMHGLEDMon[iSM]++;</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :               if ( (amp &gt; fMinSignalHGLEDMon) &amp;&amp; (amp &lt; fMaxSignalHGLEDMon) ) {</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :                 FillRawsData(kSigHGLEDMon,stripId, amp);</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :                 FillRawsData(kTimeHGLEDMon,stripId, time);</span>
<span class="lineNum">     896 </span>            :               }
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :               if (nPed &gt; 0) {</span>
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :                 for (Int_t i=0; i&lt;nPed; i++) {</span>
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :                   FillRawsData(kPedHGLEDMon,stripId, pedSamples[i]);</span>
<span class="lineNum">     900 </span>            :                 }
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :               }//nPed&gt;0</span>
<span class="lineNum">     902 </span>            :             } // low or high gain
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :           } // LEDMon</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :         } // SM index OK</span>
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :       } // nsamples&gt;0 check, some data found for this channel; not only trailer/header</span>
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :     }// end while over channel</span>
<span class="lineNum">     907 </span>            :   }// end while over DDL's, of input stream
<span class="lineNum">     908 </span>            :   
<span class="lineNum">     909 </span>            :   /***************/
<span class="lineNum">     910 </span>            :   //Filling histograms for TRUL0IdData
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :   Int_t AbsFastORId=-1;</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :   Int_t AbsFastORIndexesIn4x4Patch[4]={-1};</span>
<span class="lineNum">     913 </span>            :   Int_t AbsFastORFirstIndexIn4x4Patch;
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :   Int_t globTRUCol, globTRURow;</span>
<span class="lineNum">     915 </span>            :   
<span class="lineNum">     916 </span>            :   bool worry=false;
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :   for(int k=0; k &lt; nTotTRUs; k++){</span>
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :     for(int h=0; h &lt; maxNumL0PatchesPerTRU; h++){</span>
<span class="lineNum">     919 </span>            :       //printf(&quot;ciao: iTRU %d\tiPatchinTRU %d\t number of fired patches: %d\n&quot;,k,h,timeOfFiredPatches[k][h].size());
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :       if(timeOfFiredPatches[k][h].size()==0) continue;</span>
<span class="lineNum">     921 </span>            :       else{ //Run 1 or 2x2PatchModeON L0Channels = modules in TRU
<span class="lineNum">     922 </span>            :         Int_t maxTsample=-1, minTsample=20;
<span class="lineNum">     923 </span>            :         Float_t rms=0.;
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :         if(is2x2PatchModeActive || !(fGeom-&gt;GetEMCGeometry()-&gt;GetGeoName().Contains(&quot;DCAL&quot;))){</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :           if(fGeom-&gt;GetAbsFastORIndexFromTRU(k, h, AbsFastORId)){</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :             fGeom-&gt;GetPositionInEMCALFromAbsFastORIndex(AbsFastORId, globTRUCol, globTRURow);</span>
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :             for(int s=0; s&lt;timeOfFiredPatches[k][h].size(); s++){</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :               FillRawsData(kNL0TRU, globTRUCol, globTRURow);</span>
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :               FillRawsData(kTimeL0TRU, globTRUCol, globTRURow, timeOfFiredPatches[k][h].at(s));</span>
<span class="lineNum">     930 </span>            :               
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :               rms+=timeOfFiredPatches[k][h].at(s)*timeOfFiredPatches[k][h].at(s);</span>
<span class="lineNum">     932 </span>            :               
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :               if(timeOfFiredPatches[k][h].at(s)&gt;maxTsample) maxTsample= timeOfFiredPatches[k][h].at(s);</span>
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :               if(timeOfFiredPatches[k][h].at(s)&lt;minTsample) minTsample= timeOfFiredPatches[k][h].at(s);</span>
<span class="lineNum">     935 </span>            :               
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :               triggers[AbsFastORId][startBins[k][h].at(s)] = 1;</span>
<span class="lineNum">     937 </span>            :             }
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :             FillRawsData(kNL0TRUSamples, globTRUCol, globTRURow,timeOfFiredPatches[k][h].size());</span>
<span class="lineNum">     939 </span>            :             //FillRawsData(kNL0TRURMS,globTRURow*48+globTRUCol,maxTsample-minTsample); 
<span class="lineNum">     940 </span>            :             //printf(&quot;rms calculated with  SQRT(sum of times^2 / Ntimes samples) %f\n&quot;,TMath::Sqrt(rms/timeOfFiredPatches[k][h].size()));
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :             FillRawsData(kNL0TRURMS,globTRURow*48+globTRUCol,TMath::Sqrt(rms/timeOfFiredPatches[k][h].size())); </span>
<span class="lineNum">     942 </span>            :           }
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :           else continue;</span>
<span class="lineNum">     944 </span>            :         }
<span class="lineNum">     945 </span>            :         else{ //Run2 default L0Channels = 4x4 towers patches = 2x2 modules in TRU
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :           if(fGeom-&gt;GetFastORIndexFromL0Index(k, h, AbsFastORIndexesIn4x4Patch, 4)){</span>
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :             for(int i=0;i&lt;4;i++)</span>
<span class="lineNum">     948 </span>            :               //printf(&quot;AbsID = %d of the %d module in the %d Patch of the %d TRU\n&quot;,AbsFastORIndexesIn4x4Patch[i],i,h,k);
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :               AbsFastORFirstIndexIn4x4Patch=AbsFastORIndexesIn4x4Patch[0];</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :             fGeom-&gt;GetPositionInEMCALFromAbsFastORIndex(AbsFastORFirstIndexIn4x4Patch, globTRUCol, globTRURow);</span>
<span class="lineNum">     951 </span>            :             //printf(&quot;TRU: %d \t PatchIndex:%d \t number of times for the fired patch: %d\n&quot;,k,h,timeOfFiredPatches[k][h].size());
<span class="lineNum">     952 </span>            :             //printf(&quot;First Index %d of the 4 modules making the patch\n&quot;, AbsFastORFirstIndexIn4x4Patch);
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :             for(int s=0; s&lt;timeOfFiredPatches[k][h].size(); s++){</span>
<span class="lineNum">     954 </span>            :               //printf(&quot;%d time the patch has been fired and time: %d\n&quot;,s+1,timeOfFiredPatches[k][h].at(s));
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :               rms+=timeOfFiredPatches[k][h].at(s)*timeOfFiredPatches[k][h].at(s);</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :               if(timeOfFiredPatches[k][h].at(s)&gt;maxTsample) maxTsample= timeOfFiredPatches[k][h].at(s);</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :               if(timeOfFiredPatches[k][h].at(s)&lt;minTsample) minTsample= timeOfFiredPatches[k][h].at(s);</span>
<span class="lineNum">     958 </span>            :               
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :               FillRawsData(kNL0TRU, globTRUCol, globTRURow);</span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :               FillRawsData(kTimeL0TRU, globTRUCol, globTRURow, timeOfFiredPatches[k][h].at(s));</span>
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :               triggers[AbsFastORFirstIndexIn4x4Patch][startBins[k][h].at(s)] = 1;</span>
<span class="lineNum">     962 </span>            :             }//number of times each module in a patch has fired the trigger
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :             FillRawsData(kNL0TRUSamples, globTRUCol, globTRURow,timeOfFiredPatches[k][h].size());</span>
<span class="lineNum">     964 </span>            :             //FillRawsData(kNL0TRURMS,globTRURow*48+globTRUCol,maxTsample-minTsample); 
<span class="lineNum">     965 </span>            :             //printf(&quot;rms calculated with  SQRT(sum of times^2 / Ntimes samples) %f\n&quot;,TMath::Sqrt(rms/timeOfFiredPatches[k][h].size()));
<span class="lineNum">     966 </span>            :             // printf(&quot;\tfilling the bin %d with this value \n&quot;,globTRURow*48+globTRUCol);
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :             FillRawsData(kNL0TRURMS,globTRURow*48+globTRUCol,TMath::Sqrt(rms/timeOfFiredPatches[k][h].size())); </span>
<span class="lineNum">     968 </span>            :           }//position of the patch FOUND!
<span class="lineNum">     969 </span>            :           else
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     971 </span>            :         }//check which kind of patch has been SELECTED
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :       }//the patch &quot;h&quot; in TRU &quot;k&quot; has been fired</span>
<span class="lineNum">     973 </span>            :       
<span class="lineNum">     974 </span>            :     }//loop over the max number of AVAILABLE patches per TRU
<span class="lineNum">     975 </span>            :   }//loop on nTotTRUs (Run1 or Run2)
<span class="lineNum">     976 </span>            :   
<span class="lineNum">     977 </span>            :   /***************/
<span class="lineNum">     978 </span>            :   // filling some L0 trigger histos
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :   if( firstL0TimeBin &lt; 999 ){</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :     for(Int_t i = 0; i &lt; nTot2x2; i++) {     </span>
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :       if( triggers[i][firstL0TimeBin] &gt; 0 ) {</span>
<span class="lineNum">     982 </span>            :         // histo-&gt;Fill(i,j);
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :         FillRawsData(kNL0FirstTRU, i);</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :         FillRawsData(kTimeL0FirstTRU, i, firstL0TimeBin);</span>
<span class="lineNum">     985 </span>            :       }
<span class="lineNum">     986 </span>            :     }
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     988 </span>            :   
<span class="lineNum">     989 </span>            :   // calculate the ratio of the amplitude and fill the histograms, only if the events type is Calib
<span class="lineNum">     990 </span>            :   // RS: operation on the group of histos kSigHG,k2DRatioAmp,kRatioDist,kLEDMonRatio,kLEDMonRatio,kSigLGLEDMon
<span class="lineNum">     991 </span>            :   const int hGrp[] = {kSigHG,k2DRatioAmp,kRatioDist,kLEDMonRatio,kLEDMonRatioDist,kSigLGLEDMon};
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :   if ( rawReader-&gt;GetType() == AliRawEventHeaderBase::kCalibrationEvent &amp;&amp;</span>
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :       CheckCloningConsistency(fRawsQAList, hGrp, sizeof(hGrp)/sizeof(int)) ) {  // RS converting original code to loop over all matching triggers</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :     int nTrig =IsClonedPerTrigClass(kSigHG,fRawsQAList) ? GetNEventTrigClasses() : 0; // loop over triggers only if histos were cloned</span>
<span class="lineNum">     995 </span>            :                                                                                       //
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :     for (int itr=-1;itr&lt;nTrig;itr++) { // start from -1 to acknowledge original histos if they were kept</span>
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :       TObjArray* trArr = GetMatchingRawsHistosSet(hGrp, sizeof(hGrp)/sizeof(int) ,itr);</span>
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :       if (!trArr) continue;  // no histos for current trigger</span>
<span class="lineNum">     999 </span>            :                              //
<span class="lineNum">    1000 </span>            :       Double_t binContent = 0.;
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :       TProfile* prSigHG      = (TProfile *)trArr-&gt;At(0); // kSigHG</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :       TH1* th2DRatioAmp      = (TH1*) trArr-&gt;At(1); // k2DRatioAmp</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :       TH1* thRatioDist       = (TH1*) trArr-&gt;At(2); // kRatioDist</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :       TH1* thLEDMonRatio     = (TH1*) trArr-&gt;At(3); // kLEDMonRatio</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :       TH1* thLEDMonRatioDist = (TH1*) trArr-&gt;At(4); // kLEDMonRatio</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :       TH1* hSigLGLEDMon      = (TH1*) trArr-&gt;At(5); // kSigLGLEDMon</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :       th2DRatioAmp-&gt;Reset(&quot;ICE&quot;);</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :       thRatioDist-&gt;Reset(&quot;ICE&quot;);</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :       thLEDMonRatio-&gt;Reset(&quot;ICE&quot;);</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :       thLEDMonRatioDist-&gt;Reset(&quot;ICE&quot;);</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :       th2DRatioAmp-&gt;ResetStats();</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :       thRatioDist-&gt;ResetStats();</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :       thLEDMonRatio-&gt;ResetStats();</span>
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :       thLEDMonRatioDist-&gt;ResetStats();</span>
<span class="lineNum">    1015 </span>            :       
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :       ConvertProfile2H(prSigHG, fHighEmcHistoH2F);  </span>
<span class="lineNum">    1017 </span>            :       // 
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :       for(Int_t ix = 1; ix &lt;= fHighEmcHistoH2F-&gt;GetNbinsX(); ix++) {</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :         for(Int_t iy = 1; iy &lt;= fHighEmcHistoH2F-&gt;GetNbinsY(); iy++) { </span>
<span class="lineNum">    1020 </span>            :           
<span class="lineNum">    1021 </span>            :           // if(fCalibRefHistoH2F-&gt;GetBinContent(ix, iy)){
<span class="lineNum">    1022 </span>            :           
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :           binContent = fHighEmcHistoH2F-&gt;GetBinContent(ix, iy);// /fCalibRefHistoH2F-&gt;GetBinContent(ix, iy);</span>
<span class="lineNum">    1024 </span>            :                                                                // }
<span class="lineNum">    1025 </span>            :           
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :           th2DRatioAmp-&gt;SetBinContent(ix, iy, binContent);</span>
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :           thRatioDist-&gt;Fill(binContent);</span>
<span class="lineNum">    1028 </span>            :         }
<span class="lineNum">    1029 </span>            :       } 
<span class="lineNum">    1030 </span>            :       // 
<span class="lineNum">    1031 </span>            :       // Now for LED monitor system, to calculate the ratio as well
<span class="lineNum">    1032 </span>            :       Double_t binError = 0. ;
<span class="lineNum">    1033 </span>            :       // For the binError, we add the relative errors, squared
<span class="lineNum">    1034 </span>            :       Double_t relativeErrorSqr = 0. ;
<span class="lineNum">    1035 </span>            :       // 
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :       for(int ib = 1; ib &lt;= fLEDMonRefHistoPro-&gt;GetNbinsX(); ib++) {</span>
<span class="lineNum">    1037 </span>            :         // 
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :         if(fLEDMonRefHistoPro-&gt;GetBinContent(ib) != 0) {</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :           binContent = hSigLGLEDMon-&gt;GetBinContent(ib) / fLEDMonRefHistoPro-&gt;GetBinContent(ib);</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :           relativeErrorSqr = TMath::Power( (fLEDMonRefHistoPro-&gt;GetBinError(ib) / fLEDMonRefHistoPro-&gt;GetBinContent(ib)), 2);</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :           if( hSigLGLEDMon-&gt;GetBinContent(ib) != 0) {</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :             relativeErrorSqr += TMath::Power( (hSigLGLEDMon-&gt;GetBinError(ib)/hSigLGLEDMon-&gt;GetBinContent(ib)), 2);</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    1044 </span>            :         }
<span class="lineNum">    1045 </span>            :         else { // ref. run info is zero
<span class="lineNum">    1046 </span>            :           binContent = -1;
<span class="lineNum">    1047 </span>            :           relativeErrorSqr = 1;
<span class="lineNum">    1048 </span>            :         }
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :         thLEDMonRatio-&gt;SetBinContent(ib, binContent);</span>
<span class="lineNum">    1050 </span>            :         
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :         binError = sqrt(relativeErrorSqr) * binContent;</span>
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :         thLEDMonRatio-&gt;SetBinError(ib, binError);</span>
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :         thLEDMonRatioDist-&gt;Fill(thLEDMonRatio-&gt;GetBinContent(ib));</span>
<span class="lineNum">    1054 </span>            :       }
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :     } // loop over eventual trigger clones</span>
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :   } </span>
<span class="lineNum">    1057 </span>            :   // let's also fill the SM and event counter histograms
<span class="lineNum">    1058 </span>            :   Int_t nTotalHG = 0;
<span class="lineNum">    1059 </span>            :   Int_t nTotalLG = 0;
<span class="lineNum">    1060 </span>            :   Int_t nTotalTRU = 0;
<span class="lineNum">    1061 </span>            :   Int_t nTotalHGLEDMon = 0;
<span class="lineNum">    1062 </span>            :   Int_t nTotalLGLEDMon = 0;
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :   for (iSM=0; iSM&lt;fSuperModules; iSM++) {  </span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :     nTotalLG += nTotalSMLG[iSM]; </span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :     nTotalHG += nTotalSMHG[iSM]; </span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :     nTotalTRU += nTotalSMTRU[iSM]; </span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :     nTotalLGLEDMon += nTotalSMLGLEDMon[iSM]; </span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :     nTotalHGLEDMon += nTotalSMHGLEDMon[iSM]; </span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :     FillRawsData(kNsmodLG,iSM, nTotalSMLG[iSM]); </span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :     FillRawsData(kNsmodHG,iSM, nTotalSMHG[iSM]); </span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :     FillRawsData(kNsmodTRU,iSM, nTotalSMTRU[iSM]); </span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :     FillRawsData(kNsmodLGLEDMon,iSM, nTotalSMLGLEDMon[iSM]); </span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :     FillRawsData(kNsmodHGLEDMon,iSM, nTotalSMHGLEDMon[iSM]); </span>
<span class="lineNum">    1074 </span>            :   }
<span class="lineNum">    1075 </span>            :   
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :   FillRawsData(kNtotLG,nTotalLG);</span>
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :   FillRawsData(kNtotHG,nTotalHG);</span>
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :   FillRawsData(kNtotTRU,nTotalTRU);</span>
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :   FillRawsData(kNtotLGLEDMon,nTotalLGLEDMon);</span>
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :   FillRawsData(kNtotHGLEDMon,nTotalHGLEDMon);</span>
<span class="lineNum">    1081 </span>            :   
<span class="lineNum">    1082 </span>            :   //Last TRUL0 histogram to be filled with RMSs per channel, so AFTER all Channels hav been read 
<span class="lineNum">    1083 </span>            :   
<span class="lineNum">    1084 </span>            :   
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :   IncEvCountCycleESDs();</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :   IncEvCountTotalESDs();</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :   SetEventSpecie(saveSpecie) ; </span>
<span class="lineNum">    1088 </span>            :   
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :   MakeRawsSTU(rawReader);</span>
<span class="lineNum">    1090 </span>            :   
<span class="lineNum">    1091 </span>            :   // just in case the next rawreader consumer forgets to reset; let's do it here again..
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :   rawReader-&gt;Reset() ;</span>
<span class="lineNum">    1093 </span>            :   return;
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1095 </span>            : 
<span class="lineNum">    1096 </span>            : //____________________________________________________________________________
<span class="lineNum">    1097 </span>            : ///
<a name="1098"><span class="lineNum">    1098 </span>            : /// Make data from Digits.</a>
<span class="lineNum">    1099 </span>            : ///
<span class="lineNum">    1100 </span>            : void AliEMCALQADataMakerRec::MakeDigits()
<span class="lineNum">    1101 </span>            : {
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :   FillDigitsData(1,fDigitsArray-&gt;GetEntriesFast()) ; </span>
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :   TIter next(fDigitsArray) ; </span>
<span class="lineNum">    1104 </span>            :   AliEMCALDigit * digit ; 
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :   while ( (digit = dynamic_cast&lt;AliEMCALDigit *&gt;(next())) ) {</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :     FillDigitsData(0, digit-&gt;GetAmplitude()) ;</span>
<span class="lineNum">    1107 </span>            :   }  
<span class="lineNum">    1108 </span>            :   //
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1110 </span>            : 
<span class="lineNum">    1111 </span>            : //____________________________________________________________________________
<span class="lineNum">    1112 </span>            : ///
<span class="lineNum">    1113 </span>            : /// Make data from Digit Tree.
<span class="lineNum">    1114 </span>            : ///
<a name="1115"><span class="lineNum">    1115 </span>            : /// \param digitTree: TTree</a>
<span class="lineNum">    1116 </span>            : ///
<span class="lineNum">    1117 </span>            : void AliEMCALQADataMakerRec::MakeDigits(TTree * digitTree)
<span class="lineNum">    1118 </span>            : {
<span class="lineNum">    1119 </span>            :   // makes data from Digit Tree
<span class="lineNum">    1120 </span>            :   // RS: Attention: the counters are increments in the MakeDigits()
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :   if (fDigitsArray) </span>
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :     fDigitsArray-&gt;Clear(&quot;C&quot;) ; </span>
<span class="lineNum">    1123 </span>            :   else
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :     fDigitsArray = new TClonesArray(&quot;AliEMCALDigit&quot;, 1000) ; </span>
<span class="lineNum">    1125 </span>            :   
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :   TBranch * branch = digitTree-&gt;GetBranch(&quot;EMCAL&quot;) ;</span>
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :   if ( ! branch ) { AliWarning(&quot;EMCAL branch in Digit Tree not found&quot;); return; }</span>
<span class="lineNum">    1128 </span>            :   //
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :   branch-&gt;SetAddress(&amp;fDigitsArray) ;</span>
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :   branch-&gt;GetEntry(0) ; </span>
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :   MakeDigits() ; </span>
<span class="lineNum">    1132 </span>            :   //
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :   IncEvCountCycleDigits();</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :   IncEvCountTotalDigits();  </span>
<span class="lineNum">    1135 </span>            :   //  
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1137 </span>            : 
<span class="lineNum">    1138 </span>            : //____________________________________________________________________________
<span class="lineNum">    1139 </span>            : ///
<span class="lineNum">    1140 </span>            : /// Make data from RecPoints.
<span class="lineNum">    1141 </span>            : ///
<a name="1142"><span class="lineNum">    1142 </span>            : /// \param clustersTree: TTree</a>
<span class="lineNum">    1143 </span>            : ///
<span class="lineNum">    1144 </span>            : void AliEMCALQADataMakerRec::MakeRecPoints(TTree * clustersTree)
<span class="lineNum">    1145 </span>            : {
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :   TBranch *emcbranch = clustersTree-&gt;GetBranch(&quot;EMCALECARP&quot;);</span>
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :   if (!emcbranch) { </span>
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :     AliError(&quot;can't get the branch with the EMCAL clusters !&quot;);</span>
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1150 </span>            :   }
<span class="lineNum">    1151 </span>            :   
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :   TObjArray * emcRecPoints = new TObjArray(100) ;</span>
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :   emcbranch-&gt;SetAddress(&amp;emcRecPoints);</span>
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :   emcbranch-&gt;GetEntry(0);</span>
<span class="lineNum">    1155 </span>            :   
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :   FillRecPointsData(kRecPM,emcRecPoints-&gt;GetEntriesFast()) ; </span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :   TIter next(emcRecPoints) ; </span>
<span class="lineNum">    1158 </span>            :   AliEMCALRecPoint * rp ; 
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :   while ( (rp = dynamic_cast&lt;AliEMCALRecPoint *&gt;(next())) ) {</span>
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :     FillRecPointsData(kRecPE,rp-&gt;GetEnergy()) ;</span>
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :     FillRecPointsData(kRecPDigM,rp-&gt;GetMultiplicity());</span>
<span class="lineNum">    1162 </span>            :   }
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :   emcRecPoints-&gt;Delete();</span>
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :   delete emcRecPoints;</span>
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :   IncEvCountCycleRecPoints();</span>
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :   IncEvCountTotalRecPoints();</span>
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1168 </span>            : 
<span class="lineNum">    1169 </span>            : //____________________________________________________________________________ 
<span class="lineNum">    1170 </span>            : ///
<a name="1171"><span class="lineNum">    1171 </span>            : /// Detector specific actions at start of cycle.</a>
<span class="lineNum">    1172 </span>            : /// 
<span class="lineNum">    1173 </span>            : void AliEMCALQADataMakerRec::StartOfDetectorCycle()
<span class="lineNum">    1174 </span>            : {
<span class="lineNum">    1175 </span>            :   
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1177 </span>            : 
<span class="lineNum">    1178 </span>            : //____________________________________________________________________________ 
<span class="lineNum">    1179 </span>            : ///
<span class="lineNum">    1180 </span>            : /// Set fitting algorithm and initialize it if this same algorithm was not set before.
<span class="lineNum">    1181 </span>            : ///
<a name="1182"><span class="lineNum">    1182 </span>            : /// \param fitAlgo: kind of fitting algorithm</a>
<span class="lineNum">    1183 </span>            : ///
<span class="lineNum">    1184 </span>            : void AliEMCALQADataMakerRec::SetFittingAlgorithm(Int_t fitAlgo)              
<span class="lineNum">    1185 </span>            : {
<span class="lineNum">    1186 </span><span class="lineCov">          4 :   fFittingAlgorithm = fitAlgo; // Not sure we need this</span>
<span class="lineNum">    1187 </span>            :   
<span class="lineNum">    1188 </span><span class="lineCov">          2 :   fRawAnalyzer    =  AliCaloRawAnalyzerFactory::CreateAnalyzer(fitAlgo);</span>
<span class="lineNum">    1189 </span>            :   
<span class="lineNum">    1190 </span>            :   //  Init also here the TRU algo, even if it is fixed type.
<span class="lineNum">    1191 </span><span class="lineCov">          2 :   fRawAnalyzerTRU = AliCaloRawAnalyzerFactory::CreateAnalyzer(Algo::kFakeAltro);</span>
<span class="lineNum">    1192 </span><span class="lineCov">          2 :   fRawAnalyzerTRU-&gt;SetFixTau(kTRUE);</span>
<span class="lineNum">    1193 </span><span class="lineCov">          2 :   fRawAnalyzerTRU-&gt;SetTau(2.5); //  default for TRU shaper</span>
<span class="lineNum">    1194 </span><span class="lineCov">          2 : }</span>
<span class="lineNum">    1195 </span>            : 
<span class="lineNum">    1196 </span>            : //_____________________________________________________________________________________
<span class="lineNum">    1197 </span>            : ///
<span class="lineNum">    1198 </span>            : /// Convert TProfile to TH2  
<span class="lineNum">    1199 </span>            : ///
<span class="lineNum">    1200 </span>            : /// \param p: TProfile
<a name="1201"><span class="lineNum">    1201 </span>            : /// \param histo: TH2 histogram</a>
<span class="lineNum">    1202 </span>            : ///
<span class="lineNum">    1203 </span>            : void AliEMCALQADataMakerRec::ConvertProfile2H(TProfile * p, TH2 * histo)
<span class="lineNum">    1204 </span>            : { 
<span class="lineNum">    1205 </span>            :   //  reset histogram
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :   histo-&gt;Reset(&quot;ICE&quot;) ; </span>
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :   histo-&gt;ResetStats(); </span>
<span class="lineNum">    1208 </span>            :   
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :   Int_t nbinsProf = p-&gt;GetNbinsX();</span>
<span class="lineNum">    1210 </span>            :   
<span class="lineNum">    1211 </span>            :   //  loop through the TProfile p and fill the TH2F histo 
<span class="lineNum">    1212 </span>            :   Double_t binContent = 0;
<span class="lineNum">    1213 </span>            :   Int_t towerNum = 0; //  global tower Id
<span class="lineNum">    1214 </span>            :                       //   i = 0; //  tower Id within SuperModule
<span class="lineNum">    1215 </span>            :   Int_t iSM=0; 
<span class="lineNum">    1216 </span>            :   Int_t iSMSide = 0; // 0=A, 1=C side
<span class="lineNum">    1217 </span>            :   Int_t iSMSector = 0; // 2 SM's per sector  
<span class="lineNum">    1218 </span>            :                        //  indices for 2D plots
<span class="lineNum">    1219 </span>            :   Int_t col2d = 0;
<span class="lineNum">    1220 </span>            :   Int_t row2d = 0;
<span class="lineNum">    1221 </span>            :   Int_t kEMCALRows = 24; // TOWERs  nRows
<span class="lineNum">    1222 </span>            :   Int_t kEMCALCols = 48; // TOWERs  nCols
<span class="lineNum">    1223 </span>            :   Int_t kEMCALTowersPerSM = kEMCALRows * kEMCALCols; // nTOWERS in SM
<span class="lineNum">    1224 </span>            :   
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :   for (Int_t ibin = 1; ibin &lt;= nbinsProf; ibin++) </span>
<span class="lineNum">    1226 </span>            :   {
<span class="lineNum">    1227 </span><span class="lineNoCov">          0 :     towerNum = (Int_t) p-&gt;GetBinCenter(ibin);</span>
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :     binContent = p-&gt;GetBinContent(ibin);</span>
<span class="lineNum">    1229 </span>            :     
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :     if(towerNum&lt;11520){</span>
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :       iSM = towerNum/(kEMCALTowersPerSM);</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :       col2d = (towerNum/kEMCALRows) % kEMCALCols;</span>
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :       row2d = towerNum % kEMCALRows;</span>
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :     else if(towerNum&gt;11519 &amp;&amp; towerNum&lt;12288){</span>
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 :       iSM = 10 + (towerNum-11520)/(kEMCALTowersPerSM/3);//for the 10th SM the second part returns 0 (division between integers) </span>
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :       col2d = ((towerNum-11520)/(kEMCALRows/3)) % kEMCALCols;</span>
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :       row2d = (towerNum-11520) % (kEMCALRows/3);</span>
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1240 </span><span class="lineNoCov">          0 :     else if(towerNum&gt;12287 &amp;&amp; towerNum&lt;19200){</span>
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :       iSM = 12 + (towerNum-12288)/(kEMCALTowersPerSM);//for the 12th SM the second part return 0 (division between integers) </span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :       col2d = ((towerNum-12288)/kEMCALRows) % kEMCALCols;</span>
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :       row2d = (towerNum-12288) % kEMCALRows;</span>
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1245 </span>            :     else{ //10 EMCAL_FULL + 2 EMCAL_1/3 + 6 DCAL_FULL 
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 :       iSM = 18 + (towerNum-19200)/(kEMCALTowersPerSM/3); //for the 18th SM the second part return 0 (division between integers)</span>
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :       col2d = ((towerNum-19200)/(kEMCALRows/3)) % kEMCALCols;</span>
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :       row2d = (towerNum-19200) % (kEMCALRows/3); </span>
<span class="lineNum">    1249 </span>            :     }
<span class="lineNum">    1250 </span>            :     
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :     iSMSector = iSM / 2;</span>
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 :     iSMSide = iSM % 2;</span>
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :     if (iSMSide == 1) // C side, shown to the right</span>
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :       col2d += kEMCALCols;</span>
<span class="lineNum">    1255 </span>            :     
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :     if (towerNum&gt;=0 &amp;&amp; towerNum&lt;12288)//EMCAL (FULL and 1/3 SM)</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :              row2d += iSMSector *kEMCALRows;</span>
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :     else if (towerNum&gt;12287 &amp;&amp; towerNum&lt;19968)//DCAL =  EMCAL Offset (120+8) + Offset in DCAL Sectors (here they continue from 6, not 9) </span>
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :              row2d += 5*kEMCALRows + (kEMCALRows/3) + (iSMSector-6)*kEMCALRows;</span>
<span class="lineNum">    1260 </span>            :     
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :     histo-&gt;SetBinContent(col2d+1, row2d+1, binContent);</span>
<span class="lineNum">    1262 </span>            :   }
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 : } </span>
<span class="lineNum">    1264 </span>            : 
<span class="lineNum">    1265 </span>            : /*
<span class="lineNum">    1266 </span>            : //____________________________________________________________________________
<span class="lineNum">    1267 </span>            : ///
<span class="lineNum">    1268 </span>            : /// Transform local to global indices.
<span class="lineNum">    1269 </span>            : ///
<span class="lineNum">    1270 </span>            : /// \param globRow = global row index 
<span class="lineNum">    1271 </span>            : /// \param globColumn = global column index
<span class="lineNum">    1272 </span>            : /// \param module = number of the module
<span class="lineNum">    1273 </span>            : /// \param ddl = number of the ddl
<span class="lineNum">    1274 </span>            : /// \param branch = number of the branch
<span class="lineNum">    1275 </span>            : /// \param column = number of module column inside the TRU
<span class="lineNum">    1276 </span>            : ///
<span class="lineNum">    1277 </span>            : void AliEMCALQADataMakerRec::GetTruChannelPosition( Int_t &amp;globRow, Int_t &amp;globColumn, Int_t module, Int_t ddl, Int_t branch, Int_t column ) const
<span class="lineNum">    1278 </span>            : { // I THINK THIS WHOLE METHOD SHOULD BE CHANGED BUT NEED THE TRU SCHEME! 
<span class="lineNum">    1279 </span>            :   Int_t mrow;
<span class="lineNum">    1280 </span>            :   Int_t mcol;
<span class="lineNum">    1281 </span>            :   Int_t trow;
<span class="lineNum">    1282 </span>            :   Int_t tcol;
<span class="lineNum">    1283 </span>            :   Int_t drow;
<span class="lineNum">    1284 </span>            :   Int_t rcu;
<span class="lineNum">    1285 </span>            :   // RCU 0 or 1
<span class="lineNum">    1286 </span>            :   rcu = ddl % 2;
<span class="lineNum">    1287 </span>            : 
<span class="lineNum">    1288 </span>            :   // 12 rows of 2x2s in a module (3 TRUs by 4 rows)
<span class="lineNum">    1289 </span>            :   mrow = (module/2) * 12;
<span class="lineNum">    1290 </span>            :   // 24 columns per module, odd module numbers increased by 24
<span class="lineNum">    1291 </span>            :   mcol = (module%2) * 24;
<span class="lineNum">    1292 </span>            : 
<span class="lineNum">    1293 </span>            :   // position within TRU coordinates
<span class="lineNum">    1294 </span>            :   tcol = column / 4;
<span class="lineNum">    1295 </span>            :   trow = column % 4;
<span class="lineNum">    1296 </span>            : 
<span class="lineNum">    1297 </span>            :   // .combine
<span class="lineNum">    1298 </span>            :   if( module%2 == 0 ){   // A side
<span class="lineNum">    1299 </span>            :     // mirror rows
<span class="lineNum">    1300 </span>            :     trow = 3 - trow;
<span class="lineNum">    1301 </span>            : 
<span class="lineNum">    1302 </span>            :     // TRU in module row addition
<span class="lineNum">    1303 </span>            :     drow = (rcu*branch+rcu) * 4;
<span class="lineNum">    1304 </span>            : 
<span class="lineNum">    1305 </span>            :   }
<span class="lineNum">    1306 </span>            :   else{   // C side
<span class="lineNum">    1307 </span>            :     // mirror columns
<span class="lineNum">    1308 </span>            :     tcol = 23 - tcol;
<span class="lineNum">    1309 </span>            : 
<span class="lineNum">    1310 </span>            :     // TRU in module row addition
<span class="lineNum">    1311 </span>            :     drow = (2 - (rcu*branch+rcu)) * 4;
<span class="lineNum">    1312 </span>            :   }
<span class="lineNum">    1313 </span>            : 
<span class="lineNum">    1314 </span>            :   // output global row/collumn position (0,0 = SMA0, phi = 0, |eta| = max)
<span class="lineNum">    1315 </span>            :   globRow = mrow + drow + trow;
<span class="lineNum">    1316 </span>            :   globColumn = mcol + tcol;
<span class="lineNum">    1317 </span>            : }
<span class="lineNum">    1318 </span>            :  
<span class="lineNum">    1319 </span>            : // ____________________________________________________________________________ 
<span class="lineNum">    1320 </span>            : /// 
<span class="lineNum">    1321 </span>            : /// Create the Raw STU histograms.
<span class="lineNum">    1322 </span>            : /// 
<span class="lineNum">    1323 </span>            : /// \param  AliRawReader
<span class="lineNum">    1324 </span>            : ///
<span class="lineNum">    1325 </span>            : void AliEMCALQADataMakerRec::MakeRawsSTU(AliRawReader* rawReader)
<span class="lineNum">    1326 </span>            : { //  STU specifics
<span class="lineNum">    1327 </span>            :   AliEMCALTriggerSTURawStream* inSTU = new AliEMCALTriggerSTURawStream(rawReader);
<span class="lineNum">    1328 </span>            :   Int_t iEMCALtrig[AliEMCALTriggerMappingV2::fSTURegionNEta][AliEMCALTriggerMappingV2::fSTURegionNPhi]={{0}};
<span class="lineNum">    1329 </span>            :   
<span class="lineNum">    1330 </span>            :   for(int dete=0; dete&lt;2; dete++){
<span class="lineNum">    1331 </span>            :         if(dete==0){            
<span class="lineNum">    1332 </span>            :           rawReader-&gt;Reset();
<span class="lineNum">    1333 </span>            :           rawReader-&gt;Select(&quot;EMCAL&quot;,AliDAQ::GetFirstSTUDDL(),AliDAQ::GetFirstSTUDDL());
<span class="lineNum">    1334 </span>            :         }
<span class="lineNum">    1335 </span>            :         else{
<span class="lineNum">    1336 </span>            :           rawReader-&gt;Reset();
<span class="lineNum">    1337 </span>            :           rawReader-&gt;Select(&quot;DCAL&quot;,AliDAQ::GetLastSTUDDL(),AliDAQ::GetLastSTUDDL());
<span class="lineNum">    1338 </span>            :         }
<span class="lineNum">    1339 </span>            :         printf(&quot;detector = %d \n&quot;,dete);
<span class="lineNum">    1340 </span>            :         Int_t h=0; //helper for TRU-STU conversion
<span class="lineNum">    1341 </span>            :         // L1 segmentation
<span class="lineNum">    1342 </span>            :         Int_t sizeL1gsubr = 1;
<span class="lineNum">    1343 </span>            :         Int_t sizeL1gpatch = 2; 
<span class="lineNum">    1344 </span>            :         Int_t sizeL1jsubr = 4; 
<span class="lineNum">    1345 </span>            :         
<span class="lineNum">    1346 </span>            :         if (inSTU-&gt;ReadPayLoad()){
<span class="lineNum">    1347 </span>            :           Int_t fw = inSTU-&gt;GetFwVersion();
<span class="lineNum">    1348 </span>            :           Int_t sizeL1jpatch = 2+(fw &gt;&gt; 16);
<span class="lineNum">    1349 </span>            :           printf(&quot;Firmware= 0x%x \t sizeL1jetpatch= %d \n&quot;,fw,sizeL1jpatch);  
<span class="lineNum">    1350 </span>            :       
<span class="lineNum">    1351 </span>            :           Long64_t mask = inSTU-&gt;GetFrameReceived() ^ inSTU-&gt;GetRegionEnable();
<span class="lineNum">    1352 </span>            :         
<span class="lineNum">    1353 </span>            :           //32 STU for EMCAL and 14 for DCAL
<span class="lineNum">    1354 </span>            :           printf(&quot;max number of STu for detector %d = %d\n&quot;,dete,(dete==0) ? 32 : 14);
<span class="lineNum">    1355 </span>            :     
<span class="lineNum">    1356 </span>            :           for (int i = 0; i &lt; (dete==0) ? 32 : 14; i++)
<span class="lineNum">    1357 </span>            :           {
<span class="lineNum">    1358 </span>            :             if (!((mask &gt;&gt; i) &amp;  0x1)) FillRawsData(kSTUTRU, i);
<span class="lineNum">    1359 </span>            :           }
<span class="lineNum">    1360 </span>            :  
<span class="lineNum">    1361 </span>            :           // V0 signal in STU
<span class="lineNum">    1362 </span>            :           Int_t iV0Sig = inSTU-&gt;GetV0A()+inSTU-&gt;GetV0C();
<span class="lineNum">    1363 </span>            :           for (int i = 0; i &lt; (dete==0) ? 32 : 14; i++)
<span class="lineNum">    1364 </span>            :           {
<span class="lineNum">    1365 </span>            :             printf(&quot;current STU : %d\n&quot;,i);
<span class="lineNum">    1366 </span>            :             UInt_t adc[96];
<span class="lineNum">    1367 </span>            :             for (Int_t j = 0; j &lt; AliEMCALTriggerMappingV2::fNModulesInTRU; j++) adc[j] = 0;
<span class="lineNum">    1368 </span>            :      
<span class="lineNum">    1369 </span>            :             inSTU-&gt;GetADC(i, adc);
<span class="lineNum">    1370 </span>            :             Int_t iTRU = fGeom-&gt;GetTRUIndexFromSTUIndex(h,dete);
<span class="lineNum">    1371 </span>            :              
<span class="lineNum">    1372 </span>            :             for (Int_t j = 0; j &lt; AliEMCALTriggerMappingV2::fNModulesInTRU; j++)
<span class="lineNum">    1373 </span>            :             {
<span class="lineNum">    1374 </span>            :               Int_t idx;
<span class="lineNum">    1375 </span>            :               fGeom-&gt;GetAbsFastORIndexFromTRU(iTRU, j, idx);// CHANGE WITH TRIGGERMAPPINGV2 METHOD
<span class="lineNum">    1376 </span>            :                                 
<span class="lineNum">    1377 </span>            :               Int_t px, py;
<span class="lineNum">    1378 </span>            :               fGeom-&gt;GetPositionInEMCALFromAbsFastORIndex(idx, px, py); // CHANGE WITH TRIGGERMAPPINGV2 METHOD
<span class="lineNum">    1379 </span>            :                                         
<span class="lineNum">    1380 </span>            :               iEMCALtrig[px][py] = adc[j];
<span class="lineNum">    1381 </span>            :             }
<span class="lineNum">    1382 </span>            :         }
<span class="lineNum">    1383 </span>            :         
<span class="lineNum">    1384 </span>            :         // L1 Gamma patches
<span class="lineNum">    1385 </span>            :         Int_t iTRUSTU, x, y, etaG, phiG;
<span class="lineNum">    1386 </span>            :         printf(&quot;Number of High Threshold Gamma patches for Detector %d : %d\n&quot;, dete, inSTU-&gt;GetNL1GammaPatch(0));
<span class="lineNum">    1387 </span>            :         for(Int_t i = 0; i &lt; inSTU-&gt;GetNL1GammaPatch(0); i++)
<span class="lineNum">    1388 </span>            :          {
<span class="lineNum">    1389 </span>            :             etaG=0, phiG=0;
<span class="lineNum">    1390 </span>            :             if (inSTU-&gt;GetL1GammaPatch(i, 0, iTRUSTU, x, y)) // col (0..7), row (0..11)
<span class="lineNum">    1391 </span>            :              {
<span class="lineNum">    1392 </span>            :                Int_t iTRU,id;
<span class="lineNum">    1393 </span>            :                 
<span class="lineNum">    1394 </span>            :                iTRU = fGeom-&gt;GetTRUIndexFromSTUIndex(iTRUSTU,dete);
<span class="lineNum">    1395 </span>            :                 
<span class="lineNum">    1396 </span>            :                    if(!fGeom-&gt;GetAbsFastORIndexFromPositionInTRU(iTRU, x, y, id))continue;
<span class="lineNum">    1397 </span>            : 
<span class="lineNum">    1398 </span>            :                if(!(fGeom-&gt;GetPositionInEMCALFromAbsFastORIndex( id, etaG, phiG ))) continue;
<span class="lineNum">    1399 </span>            :                else{
<span class="lineNum">    1400 </span>            :                     // Position of patch L1G (bottom-left FastOR of the patch)
<span class="lineNum">    1401 </span>            :                         //etaG = etaG - sizeL1gsubr * sizeL1gpatch + 1;
<span class="lineNum">    1402 </span>            :                         //phiG = phiG - sizeL1gsubr * sizeL1gpatch + 1;
<span class="lineNum">    1403 </span>            :                         
<span class="lineNum">    1404 </span>            :                         FillRawsData(kGL1, etaG, phiG);
<span class="lineNum">    1405 </span>            :                         Int_t iL1GPatchAmp = 0;
<span class="lineNum">    1406 </span>            :                     for(Int_t L1Gx = 0; L1Gx &lt; sizeL1gpatch; L1Gx ++)
<span class="lineNum">    1407 </span>            :                          {
<span class="lineNum">    1408 </span>            :                            for(Int_t L1Gy = 0; L1Gy &lt; sizeL1gpatch; L1Gy ++)
<span class="lineNum">    1409 </span>            :                              {
<span class="lineNum">    1410 </span>            :                                if (((etaG-L1Gx)&gt; 0 &amp;&amp; (etaG+L1Gx) &lt; AliEMCALTriggerMappingV2::fSTURegionNEta) &amp;&amp; 
<span class="lineNum">    1411 </span>            :                                         ((phiG-L1Gy)&gt;0 &amp;&amp; (phiG+L1Gy) &lt; AliEMCALTriggerMappingV2::fSTURegionNPhi)) 
<span class="lineNum">    1412 </span>            :                                    iL1GPatchAmp += iEMCALtrig[etaG+L1Gx][phiG+L1Gy];
<span class="lineNum">    1413 </span>            :                                  }
<span class="lineNum">    1414 </span>            :                          }
<span class="lineNum">    1415 </span>            :                          FillRawsData(kGL1V0, iV0Sig, iL1GPatchAmp);
<span class="lineNum">    1416 </span>            :                    }
<span class="lineNum">    1417 </span>            :                 }
<span class="lineNum">    1418 </span>            :           }
<span class="lineNum">    1419 </span>            : 
<span class="lineNum">    1420 </span>            :           // L1 Jet patches
<span class="lineNum">    1421 </span>            :           printf(&quot;Number of High Threshold Gamma patches for Detector %d : %d\n&quot;, dete, inSTU-&gt;GetNL1JetPatch(0));  
<span class="lineNum">    1422 </span>            :           
<span class="lineNum">    1423 </span>            :           for (Int_t i = 0; i &lt; inSTU-&gt;GetNL1JetPatch(0); i++)
<span class="lineNum">    1424 </span>            :           {
<span class="lineNum">    1425 </span>            :             if(inSTU-&gt;GetL1JetPatch(i, 0, x, y)) // / col (0,15), row (0,11)
<span class="lineNum">    1426 </span>            :             {
<span class="lineNum">    1427 </span>            :               //GetPositionInEMCALFrom Something that crosses the TRU boundaries.
<span class="lineNum">    1428 </span>            :               //NEED To know how JET PATCHES ARE COMPUTED AND STORED.
<span class="lineNum">    1429 </span>            :               
<span class="lineNum">    1430 </span>            :               Int_t etaJ = x;
<span class="lineNum">    1431 </span>            :               Int_t phiJ = y;
<span class="lineNum">    1432 </span>            :               
<span class="lineNum">    1433 </span>            :               //Int_t etaJ = sizeL1jsubr * (11-y-sizeL1jpatch + 1); // CHECK THIS FOR JETS
<span class="lineNum">    1434 </span>            :               //64 EMCAL rows offset when reading DCAL patches 
<span class="lineNum">    1435 </span>            :               //Int_t phiJ = AliEMCALGeoParams::fgkEMCALSTURows*dete + sizeL1jsubr * (15-x-sizeL1jpatch + 1);
<span class="lineNum">    1436 </span>            :               
<span class="lineNum">    1437 </span>            :                   // position of patch L1J (FOR bottom-left)
<span class="lineNum">    1438 </span>            :               FillRawsData(kJL1, x,y);
<span class="lineNum">    1439 </span>            :                                         
<span class="lineNum">    1440 </span>            :               // loop the sum aplitude of FOR in the jet patch
<span class="lineNum">    1441 </span>            :               Int_t iL1JPatchAmp = 0;
<span class="lineNum">    1442 </span>            :               for (Int_t L1Jx = 0; L1Jx &lt; sizeL1jpatch*4; L1Jx ++)
<span class="lineNum">    1443 </span>            :                   {
<span class="lineNum">    1444 </span>            :                         for (Int_t L1Jy = 0; L1Jy &lt; sizeL1jpatch*4; L1Jy ++)
<span class="lineNum">    1445 </span>            :                           {
<span class="lineNum">    1446 </span>            :                             if (etaJ+L1Jx &lt; AliEMCALTriggerMappingV2::fSTURegionNEta &amp;&amp; phiJ+L1Jy &lt; AliEMCALTriggerMappingV2::fSTURegionNPhi) 
<span class="lineNum">    1447 </span>            :                           iL1JPatchAmp += iEMCALtrig[etaJ+L1Jx][phiJ+L1Jy];
<span class="lineNum">    1448 </span>            :                       }
<span class="lineNum">    1449 </span>            :                   }
<span class="lineNum">    1450 </span>            :                   // cout &lt;&lt; &quot;L1J amp =&quot; &lt;&lt; iL1JPatchAmp &lt;&lt; endl;
<span class="lineNum">    1451 </span>            :                   FillRawsData(kJL1V0, iV0Sig, iL1JPatchAmp);
<span class="lineNum">    1452 </span>            :                 }//end-if
<span class="lineNum">    1453 </span>            :           }//end patches loop           
<span class="lineNum">    1454 </span>            :           delete inSTU;
<span class="lineNum">    1455 </span>            :      }//end inSTU-&gt;ReadPayload()  
<span class="lineNum">    1456 </span>            :   }//end detector loop 
<span class="lineNum">    1457 </span>            :       
<span class="lineNum">    1458 </span>            :   // Fill FOR amplitude histo
<span class="lineNum">    1459 </span>            :   for (Int_t i = 0; i &lt; AliEMCALTriggerMappingV2::fSTURegionNEta; i++)
<span class="lineNum">    1460 </span>            :   {
<span class="lineNum">    1461 </span>            :     for (Int_t j = 0; j &lt; AliEMCALTriggerMappingV2::fSTURegionNPhi; j++)
<span class="lineNum">    1462 </span>            :         {
<span class="lineNum">    1463 </span>            :           if (iEMCALtrig[i][j] != 0) FillRawsData(kAmpL1, i, j, iEMCALtrig[i][j]);
<span class="lineNum">    1464 </span>            :         }
<span class="lineNum">    1465 </span>            :   }
<span class="lineNum">    1466 </span>            : }
<span class="lineNum">    1467 </span>            : */
<span class="lineNum">    1468 </span>            : 
<span class="lineNum">    1469 </span>            : // ____________________________________________________________________________
<span class="lineNum">    1470 </span>            : ///
<span class="lineNum">    1471 </span>            : /// Create the Raw STU histograms.
<span class="lineNum">    1472 </span>            : /// 
<a name="1473"><span class="lineNum">    1473 </span>            : /// \param  rawReader: AliRawReaded</a>
<span class="lineNum">    1474 </span>            : ///
<span class="lineNum">    1475 </span>            : void AliEMCALQADataMakerRec::MakeRawsSTU(AliRawReader* rawReader)
<span class="lineNum">    1476 </span>            : { //  STU specifics
<span class="lineNum">    1477 </span>            :   Int_t h=0; //helper for TRU-STU conversion
<span class="lineNum">    1478 </span>            :              // L1 segmentation 
<span class="lineNum">    1479 </span>            :              // !!!! IMPORTANT THESE ARE in units of MODULES (2*2 towers) !!!!
<span class="lineNum">    1480 </span>            :   Int_t sizeL1gsubr = 1;
<span class="lineNum">    1481 </span>            :   Int_t sizeL1gpatch = 2; 
<span class="lineNum">    1482 </span>            :   Int_t sizeL1jsubr = 2; 
<span class="lineNum">    1483 </span>            :   Int_t sizeL1Jpatch, detPatchOffset, detPhiOffset;
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :   for(int det=0;det&lt;2;det++){</span>
<span class="lineNum">    1485 </span>            :     //printf(&quot;\n\n\n%d times inside the loop for detector&quot;,det);
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :     if(det==0){ </span>
<span class="lineNum">    1487 </span><span class="lineNoCov">          0 :       rawReader-&gt;Reset();</span>
<span class="lineNum">    1488 </span><span class="lineNoCov">          0 :       rawReader-&gt;Select(&quot;EMCAL&quot;,AliDAQ::GetFirstSTUDDL(),AliDAQ::GetFirstSTUDDL());</span>
<span class="lineNum">    1489 </span>            :       sizeL1Jpatch=2; //EMCAL 1 JetPatch = 4*4 subregions of 4x4 towers. = 4*4*2
<span class="lineNum">    1490 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1491 </span>            :     else{
<span class="lineNum">    1492 </span>            :       rawReader-&gt;Reset();
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :       rawReader-&gt;Select(&quot;EMCAL&quot;,AliDAQ::GetLastSTUDDL(),AliDAQ::GetLastSTUDDL());</span>
<span class="lineNum">    1494 </span>            :       sizeL1Jpatch=1; //DCAL 1 JetPatch = 2*2 subregions of 4x4 towers= 2*2*1  * 4x4 towers.
<span class="lineNum">    1495 </span>            :     }
<span class="lineNum">    1496 </span>            :     detPhiOffset = AliEMCALGeoParams::fgkEMCALSTURows*det;
<span class="lineNum">    1497 </span><span class="lineNoCov">          0 :     detPatchOffset = sizeL1jsubr*sizeL1jsubr*sizeL1Jpatch -1 ;</span>
<span class="lineNum">    1498 </span>            :     //Printf(&quot;detector : %c &quot;, (det==0 ? 'E': 'D'));
<span class="lineNum">    1499 </span>            :     //Printf(&quot;subregion %d   patch %d   detPatchOffset %d   detphiOffset %d &quot;, sizeL1jsubr,sizeL1Jpatch,detPatchOffset,detPhiOffset);
<span class="lineNum">    1500 </span><span class="lineNoCov">          0 :     AliEMCALTriggerSTURawStream inSTU(rawReader);</span>
<span class="lineNum">    1501 </span>            :     // FOR DCAL
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 :     Int_t iEMCALtrig[AliEMCALTriggerMappingV2::fSTURegionNEta][AliEMCALTriggerMappingV2::fSTURegionNPhi]={{0}};</span>
<span class="lineNum">    1503 </span>            :     //memset(iEMCALtrig, 0, sizeof(int) * AliEMCALTriggerMappingV2::fSTURegionNEta * AliEMCALTriggerMappingV2::fSTURegionNPhi);
<span class="lineNum">    1504 </span>            :     // Int_t iEMCALtrig[AliEMCALGeoParams::fgkEMCALSTUCols][AliEMCALGeoParams::fgkEMCALSTURows];
<span class="lineNum">    1505 </span>            :     // memset(iEMCALtrig, 0, sizeof(int) * AliEMCALGeoParams::fgkEMCALSTUCols * AliEMCALGeoParams::fgkEMCALSTURows);
<span class="lineNum">    1506 </span>            :     
<span class="lineNum">    1507 </span><span class="lineNoCov">          0 :     if (inSTU.ReadPayLoad()) </span>
<span class="lineNum">    1508 </span>            :     {
<span class="lineNum">    1509 </span>            :       // Fw version (use in case of change in L1 jet 
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 :       Int_t fw = inSTU.GetFwVersion();</span>
<span class="lineNum">    1511 </span>            :       //printf(&quot;\nFirmware value: 0x%x\n&quot;,fw);
<span class="lineNum">    1512 </span>            :       //printf(&quot;Firmware masked 0xf000 = 0x%x\n&quot;,fw &amp; 0xf000);
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :       Int_t sizeL1jpatch = 2+(fw &gt;&gt; 16) ;</span>
<span class="lineNum">    1514 </span>            :       //Printf(&quot;sizeL1jetpatch : %d\n&quot;,sizeL1jpatch);
<span class="lineNum">    1515 </span>            :       //Int_t sizeL1jpatch=sizeL1jpatchEta;
<span class="lineNum">    1516 </span>            :       //Int_t sizeL1jpatchPhi ;
<span class="lineNum">    1517 </span>            :       
<span class="lineNum">    1518 </span>            :       //to be checked !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<span class="lineNum">    1519 </span>            :       //printf(&quot;Firmware masked 0xf000 = 0x%x\n&quot;,fw &amp; 0xf000);
<span class="lineNum">    1520 </span>            :       /*
<span class="lineNum">    1521 </span>            :        if(fw &amp; 0xf000 == 0xb000){//EMCAL,same dimensions
<span class="lineNum">    1522 </span>            :         sizeL1jpatchPhi=sizeL1jpatchEta;
<span class="lineNum">    1523 </span>            :        }
<span class="lineNum">    1524 </span>            :        else if(fw &amp; 0xf000 == 0xd000){//DCAL,should be 16*10 //Let's see
<span class="lineNum">    1525 </span>            :         sizeL1jpatchPhi= 10;
<span class="lineNum">    1526 </span>            :        }
<span class="lineNum">    1527 </span>            :        */
<span class="lineNum">    1528 </span>            :       
<span class="lineNum">    1529 </span>            :       // To check link
<span class="lineNum">    1530 </span><span class="lineNoCov">          0 :       Long64_t mask = inSTU.GetFrameReceived() ^ inSTU.GetRegionEnable();</span>
<span class="lineNum">    1531 </span>            :       
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :       for (int i = 0; i &lt; AliEMCALTriggerMappingV2::fNTotalTRU; i++)</span>
<span class="lineNum">    1533 </span>            :       {
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :         if (!((mask &gt;&gt; i) &amp;  0x1)) FillRawsData(kSTUTRU, i);</span>
<span class="lineNum">    1535 </span>            :       }
<span class="lineNum">    1536 </span>            :       
<span class="lineNum">    1537 </span>            :       // V0 signal in STU
<span class="lineNum">    1538 </span><span class="lineNoCov">          0 :       Int_t iV0Sig = inSTU.GetV0A()+inSTU.GetV0C();</span>
<span class="lineNum">    1539 </span>            :       // FastOR amplitude receive from TRU
<span class="lineNum">    1540 </span>            :       
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 :       for (Int_t i = 0; i &lt; (det==0 ? 32 : 14); i++)</span>
<span class="lineNum">    1542 </span>            :       {
<span class="lineNum">    1543 </span>            :         //        if(i==34 || i==35 || i==40 || i==41 || i==46 || i==47)continue;
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :         UInt_t adc[96];</span>
<span class="lineNum">    1545 </span><span class="lineNoCov">          0 :         for (Int_t j = 0; j &lt; 96; j++) adc[j] = 0;</span>
<span class="lineNum">    1546 </span>            :         
<span class="lineNum">    1547 </span>            :         /*  if(i&gt;31) {
<span class="lineNum">    1548 </span>            :          det=1;  //Detector switch for STU (for TRUs EMCal and DCal are the same Detector 
<span class="lineNum">    1549 </span>            :          h=i-32; //General Offset DCAL STU / EMCAL+DCAL TRU
<span class="lineNum">    1550 </span>            :          } 
<span class="lineNum">    1551 </span>            :          if(i&gt;35) h=i-34; //1st row DCAL offset STU/TRU 
<span class="lineNum">    1552 </span>            :          if(i&gt;41) h=i-36; //2nd row DCAL offset STU/TRU
<span class="lineNum">    1553 </span>            :          if(i&gt;47) h=i-38; //3rd row DCAL offset STU/TRU
<span class="lineNum">    1554 </span>            :          */
<span class="lineNum">    1555 </span>            :         
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 :         inSTU.GetADC(i, adc);           </span>
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :         Int_t iTRU = fGeom-&gt;GetTRUIndexFromSTUIndex(i,det);</span>
<span class="lineNum">    1558 </span>            :         
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :         for (Int_t j = 0; j &lt; 96; j++)</span>
<span class="lineNum">    1560 </span>            :         {
<span class="lineNum">    1561 </span><span class="lineNoCov">          0 :           Int_t idx;</span>
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 :           if(fGeom-&gt;GetTriggerMappingVersion() == 1){</span>
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :             fGeom-&gt;GetAbsFastORIndexFromTRU(iTRU, j, idx);</span>
<span class="lineNum">    1564 </span>            :           } else {
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :             Int_t jTRU = 0, jADC = 0;</span>
<span class="lineNum">    1566 </span><span class="lineNoCov">          0 :             fGeom-&gt;GetTRUFromSTU(i, j, jTRU, jADC, det);</span>
<span class="lineNum">    1567 </span><span class="lineNoCov">          0 :             fGeom-&gt;GetAbsFastORIndexFromTRU(jTRU, jADC, idx);</span>
<span class="lineNum">    1568 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    1569 </span>            :           
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :           Int_t px, py;</span>
<span class="lineNum">    1571 </span><span class="lineNoCov">          0 :           fGeom-&gt;GetPositionInEMCALFromAbsFastORIndex(idx, px, py);</span>
<span class="lineNum">    1572 </span>            :           
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :           iEMCALtrig[px][py] = adc[j];</span>
<span class="lineNum">    1574 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1576 </span>            :       
<span class="lineNum">    1577 </span>            :       // L1 Gamma patches
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 :       Int_t iTRUSTU, x, y,etaG,phiG;</span>
<span class="lineNum">    1579 </span>            :       //Printf(&quot;Gamma patches&quot;);
<span class="lineNum">    1580 </span>            :       //for(detector=0; detector&lt;2;detector++){ // 0 EMCAL , 1 DCAL
<span class="lineNum">    1581 </span>            :       // printf(&quot;Number of L1GammaPatches high threshold: %d\n&quot;,inSTU.GetNL1GammaPatch(0) );
<span class="lineNum">    1582 </span><span class="lineNoCov">          0 :       for(Int_t ithresh = 0; ithresh &lt; 2; ithresh++)</span>
<span class="lineNum">    1583 </span>            :       {
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :         for(Int_t i = 0; i &lt; inSTU.GetNL1GammaPatch(ithresh); i++)</span>
<span class="lineNum">    1585 </span>            :         {
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :           etaG=0,phiG=0;</span>
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :           if (inSTU.GetL1GammaPatch(i, ithresh, iTRUSTU, x, y)) // col (0..7), row (0..11)</span>
<span class="lineNum">    1588 </span>            :           {
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :             Int_t iTRU, jTRU, id;</span>
<span class="lineNum">    1590 </span>            : 
<span class="lineNum">    1591 </span><span class="lineNoCov">          0 :             if(fGeom-&gt;GetTriggerMappingVersion() == 1){</span>
<span class="lineNum">    1592 </span><span class="lineNoCov">          0 :               iTRU = fGeom-&gt;GetTRUIndexFromSTUIndex(iTRUSTU, det);</span>
<span class="lineNum">    1593 </span><span class="lineNoCov">          0 :               etaG = 23 - x;</span>
<span class="lineNum">    1594 </span><span class="lineNoCov">          0 :               phiG = y + 4 * int(iTRU / 2); // Position in EMCal frame</span>
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 :               if (iTRU % 2) etaG += 24; // C side</span>
<span class="lineNum">    1596 </span><span class="lineNoCov">          0 :               etaG = etaG - 2;</span>
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :             } else {</span>
<span class="lineNum">    1598 </span><span class="lineNoCov">          0 :               if(!fGeom-&gt;GetTRUFromSTU(iTRUSTU, x, y, jTRU, etaG, phiG, det)) continue;</span>
<span class="lineNum">    1599 </span>            :             }
<span class="lineNum">    1600 </span>            :           
<span class="lineNum">    1601 </span>            :             // Position of patch L1G (bottom-left FastOR of the patch)
<span class="lineNum">    1602 </span>            :             //Printf(&quot;position of the found patch (eta,phi)=([0,47],[0,63]) for EMCAL ([0,15]&amp;&amp;[32,47],[64,103]) for DCAL\t\t(%d,%d)&quot;,etaG,phiG);
<span class="lineNum">    1603 </span>            :             // etaG = (etaG - sizeL1gsubr) * sizeL1gpatch + 1;
<span class="lineNum">    1604 </span>            :             // phiG = (phiG - sizeL1gsubr) * sizeL1gpatch + 1;
<span class="lineNum">    1605 </span>            :             //Printf(&quot;position of the found patch (eta,phi) AFTER CORRECTION FOR PATCH size\t\t(%d,%d)&quot;,etaG,phiG);
<span class="lineNum">    1606 </span><span class="lineNoCov">          0 :             FillRawsData(kGL1, etaG, phiG);</span>
<span class="lineNum">    1607 </span>            : 
<span class="lineNum">    1608 </span>            :             // New position in CALORIMETER!
<span class="lineNum">    1609 </span>            :             // if (iTRU&lt;30)
<span class="lineNum">    1610 </span>            :             // Int_t phiG = 11 - y, etaG = x + 8 * int(iTRU/2); // position with new EMCAL TRU configuration !!check iTRU/2..
<span class="lineNum">    1611 </span>            :             // else if ((iTRU&gt;29 &amp;&amp; iTRU&lt;32) || (iTRU&gt;43))
<span class="lineNum">    1612 </span>            :             // Int_t etaG = 23 - x, phiG = y + 4 * int(iTRU/2); // position in EMCAL 1/3 SMs !!check iTRU/2
<span class="lineNum">    1613 </span>            :             // else
<span class="lineNum">    1614 </span>            :             // Int_t phiG = 11 - y, etaG = x + 8 * int(iTRU/2); // position in DCAL SMs !!!!Still have to check this!!!
<span class="lineNum">    1615 </span>            :             // Int_t etaG = 23-x, phiG = y + 4 * int(iTRU/2); // position in EMCal
<span class="lineNum">    1616 </span>            :             // if (iTRU%2) etaG += 24; // C-side// / NEED THE NEW TRU NUMBERING SCHEME !!!!!
<span class="lineNum">    1617 </span>            :             // etaG = etaG - sizeL1gsubr * sizeL1gpatch + 1;
<span class="lineNum">    1618 </span>            : 
<span class="lineNum">    1619 </span>            :             // loop to sum amplitude of FOR in the gamma patch
<span class="lineNum">    1620 </span>            :             Int_t iL1GPatchAmp = 0;
<span class="lineNum">    1621 </span><span class="lineNoCov">          0 :             for(Int_t L1Gx = 0; L1Gx &lt; sizeL1gpatch; L1Gx ++)</span>
<span class="lineNum">    1622 </span>            :             {
<span class="lineNum">    1623 </span><span class="lineNoCov">          0 :               for(Int_t L1Gy = 0; L1Gy &lt; sizeL1gpatch; L1Gy ++)</span>
<span class="lineNum">    1624 </span>            :               {
<span class="lineNum">    1625 </span><span class="lineNoCov">          0 :                 if (((etaG+L1Gx) &lt; AliEMCALTriggerMappingV2::fSTURegionNEta) &amp;&amp; ((phiG+L1Gy) &lt; AliEMCALTriggerMappingV2::fSTURegionNPhi))</span>
<span class="lineNum">    1626 </span><span class="lineNoCov">          0 :                   iL1GPatchAmp += iEMCALtrig[etaG+L1Gx][phiG+L1Gy];</span>
<span class="lineNum">    1627 </span>            :                 // cout &lt;&lt; iEMCALtrig[etaG+L1Gx][phiG+L1Gy] &lt;&lt; endl;
<span class="lineNum">    1628 </span>            :               }
<span class="lineNum">    1629 </span>            :             }
<span class="lineNum">    1630 </span>            :             // if (iL1GPatchAmp &gt; 500) cout &lt;&lt; &quot;L1G amp =&quot; &lt;&lt; iL1GPatchAmp &lt;&lt; endl;
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 :             FillRawsData(kGL1V0, iV0Sig, iL1GPatchAmp);</span>
<span class="lineNum">    1632 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    1633 </span>            :         }
<span class="lineNum">    1634 </span>            :       }
<span class="lineNum">    1635 </span>            :       // L1 Jet patches
<span class="lineNum">    1636 </span>            :       //for(detector=0; detector&lt;2;detector++){ // 0 EMCAL , 1 DCAL
<span class="lineNum">    1637 </span>            :       //printf(&quot;Number of L1JetPatches high threshold: %d\n&quot;,inSTU.GetNL1JetPatch(0) );
<span class="lineNum">    1638 </span><span class="lineNoCov">          0 :       for(Int_t ithresh = 0; ithresh &lt; 2; ++ithresh)</span>
<span class="lineNum">    1639 </span>            :       {
<span class="lineNum">    1640 </span><span class="lineNoCov">          0 :         for (Int_t i = 0; i &lt; inSTU.GetNL1JetPatch(ithresh); i++)</span>
<span class="lineNum">    1641 </span>            :         {
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 :           if(inSTU.GetL1JetPatch(i, ithresh, x, y)) // Position in patches units, should be the other way around (row, col)</span>
<span class="lineNum">    1643 </span>            :           {
<span class="lineNum">    1644 </span>            :             //GetPositionInEMCALFrom Something that crosses the TRU boundaries.
<span class="lineNum">    1645 </span>            :             Int_t etaJ, phiJ;
<span class="lineNum">    1646 </span><span class="lineNoCov">          0 :             if (fGeom-&gt;GetTriggerMappingVersion() == 1) {</span>
<span class="lineNum">    1647 </span><span class="lineNoCov">          0 :               etaJ = 11 - y - sizeL1jpatch + 1;</span>
<span class="lineNum">    1648 </span><span class="lineNoCov">          0 :               phiJ = 15 - x - sizeL1jpatch + 1;</span>
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    1650 </span>            :             else {
<span class="lineNum">    1651 </span>            :               etaJ = y;
<span class="lineNum">    1652 </span><span class="lineNoCov">          0 :               phiJ = x;</span>
<span class="lineNum">    1653 </span>            :             }
<span class="lineNum">    1654 </span>            : 
<span class="lineNum">    1655 </span><span class="lineNoCov">          0 :             etaJ *= 4.;</span>
<span class="lineNum">    1656 </span><span class="lineNoCov">          0 :             phiJ *= 4.;</span>
<span class="lineNum">    1657 </span>            :           
<span class="lineNum">    1658 </span>            : 
<span class="lineNum">    1659 </span>            :             //NEED To know how JET PATCHES ARE COMPUTED AND STORED.
<span class="lineNum">    1660 </span>            :             //printf(&quot;sizeL1jsubr %d\n&quot;,sizeL1jsubr);
<span class="lineNum">    1661 </span>            :             //Printf(&quot;%dth patch in eta , %dth patch in phi&quot;,y , x);
<span class="lineNum">    1662 </span>            :             //Int_t etaJ = y*sizeL1jsubr*sizeL1jsubr + detPatchOffset;
<span class="lineNum">    1663 </span>            :             //Int_t etaJ = sizeL1jsubr * (10-y); // CHECK THIS FOR JETS
<span class="lineNum">    1664 </span>            :             //64 EMCAL rows offset when reading DCAL patches
<span class="lineNum">    1665 </span>            :             //Int_t phiJ = detPhiOffset + x*sizeL1jsubr*sizeL1jsubr + detPatchOffset;
<span class="lineNum">    1666 </span>            :             //Printf(&quot;eta and phi EMCAL ([7,39],[7,55]) DCAL ([3,43],[67,99]) \t\t %d,%d\n\n&quot;,etaJ,phiJ);
<span class="lineNum">    1667 </span>            :             //Int_t phiJ = AliEMCALGeoParams::fgkEMCALSTURows*det + sizeL1jsubr * ((det==0 ? 14 : 8) -x) ;
<span class="lineNum">    1668 </span>            :             //printf(&quot;det %d JetPatch %d  x and y for jet patch %d\t%d and etaJ and phiJ  %d \t %d\n&quot;,det, i, x,y,etaJ, phiJ);
<span class="lineNum">    1669 </span>            :             // position of patch L1J (FOR bottom-left)
<span class="lineNum">    1670 </span><span class="lineNoCov">          0 :             FillRawsData(kJL1, etaJ +2, phiJ);</span>
<span class="lineNum">    1671 </span>            :           
<span class="lineNum">    1672 </span>            :             // loop the sum aplitude of FOR in the jet patch
<span class="lineNum">    1673 </span>            :             Int_t iL1JPatchAmp = 0;
<span class="lineNum">    1674 </span><span class="lineNoCov">          0 :             for (Int_t L1Jx = 0; L1Jx &lt; sizeL1jpatch*4; L1Jx ++)</span>
<span class="lineNum">    1675 </span>            :             {
<span class="lineNum">    1676 </span><span class="lineNoCov">          0 :               for (Int_t L1Jy = 0; L1Jy &lt; sizeL1jpatch*4; L1Jy ++)</span>
<span class="lineNum">    1677 </span>            :               {
<span class="lineNum">    1678 </span><span class="lineNoCov">          0 :                 if (etaJ+L1Jx &lt; AliEMCALTriggerMappingV2::fSTURegionNEta &amp;&amp; phiJ+L1Jy &lt; AliEMCALTriggerMappingV2::fSTURegionNPhi)</span>
<span class="lineNum">    1679 </span><span class="lineNoCov">          0 :                   iL1JPatchAmp += iEMCALtrig[etaJ+L1Jx][phiJ+L1Jy];</span>
<span class="lineNum">    1680 </span>            :               }
<span class="lineNum">    1681 </span>            :             }
<span class="lineNum">    1682 </span>            :           
<span class="lineNum">    1683 </span>            :             // cout &lt;&lt; &quot;L1J amp =&quot; &lt;&lt; iL1JPatchAmp &lt;&lt; endl;
<span class="lineNum">    1684 </span><span class="lineNoCov">          0 :             FillRawsData(kJL1V0, iV0Sig, iL1JPatchAmp);</span>
<span class="lineNum">    1685 </span><span class="lineNoCov">          0 :           }//end-if</span>
<span class="lineNum">    1686 </span>            :         }//end patches loop
<span class="lineNum">    1687 </span>            :       }//end detector loop
<span class="lineNum">    1688 </span><span class="lineNoCov">          0 :     }//end inSTU.ReadPayload()</span>
<span class="lineNum">    1689 </span>            :     
<span class="lineNum">    1690 </span>            :     // Fill FOR amplitude histo
<span class="lineNum">    1691 </span><span class="lineNoCov">          0 :     for (Int_t i = 0; i &lt; AliEMCALTriggerMappingV2::fSTURegionNEta; i++)</span>
<span class="lineNum">    1692 </span>            :     {
<span class="lineNum">    1693 </span><span class="lineNoCov">          0 :       for (Int_t j = 0; j &lt; AliEMCALTriggerMappingV2::fSTURegionNPhi; j++)</span>
<span class="lineNum">    1694 </span>            :       {
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :         if (iEMCALtrig[i][j] != 0) FillRawsData(kAmpL1, i, j, iEMCALtrig[i][j]);</span>
<span class="lineNum">    1696 </span>            :       }
<span class="lineNum">    1697 </span>            :     }
<span class="lineNum">    1698 </span>            :     
<span class="lineNum">    1699 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1700 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1701 </span>            : 
<span class="lineNum">    1702 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
