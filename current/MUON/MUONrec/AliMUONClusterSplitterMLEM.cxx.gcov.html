<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - MUON/MUONrec/AliMUONClusterSplitterMLEM.cxx</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">MUON/MUONrec</a> - AliMUONClusterSplitterMLEM.cxx<span style="font-size: 80%;"> (source / <a href="AliMUONClusterSplitterMLEM.cxx.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">482</td>
            <td class="headerCovTableEntry">620</td>
            <td class="headerCovTableEntryMed">77.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">18</td>
            <td class="headerCovTableEntry">18</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**************************************************************************</a>
<span class="lineNum">       2 </span>            : * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
<span class="lineNum">       3 </span>            : *                                                                        *
<span class="lineNum">       4 </span>            : * Author: The ALICE Off-line Project.                                    *
<span class="lineNum">       5 </span>            : * Contributors are mentioned in the code where appropriate.              *
<span class="lineNum">       6 </span>            : *                                                                        *
<span class="lineNum">       7 </span>            : * Permission to use, copy, modify and distribute this software and its   *
<span class="lineNum">       8 </span>            : * documentation strictly for non-commercial purposes is hereby granted   *
<span class="lineNum">       9 </span>            : * without fee, provided that the above copyright notice appears in all   *
<span class="lineNum">      10 </span>            : * copies and that both the copyright notice and this permission notice   *
<span class="lineNum">      11 </span>            : * appear in the supporting documentation. The authors make no claims     *
<span class="lineNum">      12 </span>            : * about the suitability of this software for any purpose. It is          *
<span class="lineNum">      13 </span>            : * provided &quot;as is&quot; without express or implied warranty.                  *
<span class="lineNum">      14 </span>            : **************************************************************************/
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : /* $Id$ */
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : //-----------------------------------------------------------------------------
<span class="lineNum">      19 </span>            : /// \class AliMUONClusterSplitterMLEM
<span class="lineNum">      20 </span>            : /// 
<span class="lineNum">      21 </span>            : /// Splitter class for the MLEM algorithm. Performs fitting procedure
<span class="lineNum">      22 </span>            : /// with up to 3 hit candidates and tries to split clusters if the number
<span class="lineNum">      23 </span>            : /// of candidates exceeds 3.
<span class="lineNum">      24 </span>            : ///
<span class="lineNum">      25 </span>            : /// \author Laurent Aphecetche (for the &quot;new&quot; C++ structure) and 
<span class="lineNum">      26 </span>            : /// Alexander Zinchenko, JINR Dubna, for the hardcore of it ;-)
<span class="lineNum">      27 </span>            : //-----------------------------------------------------------------------------
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : #include &quot;AliMUONClusterSplitterMLEM.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;AliMUONClusterFinderMLEM.h&quot; // for status flag constants
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span>            : #include &quot;AliMUONCluster.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;AliMUONPad.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;AliMUONPad.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;AliMUONConstants.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;AliMpDEManager.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;AliMUONMathieson.h&quot;
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : #include &quot;AliMpEncodePair.h&quot;
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            : #include &quot;AliLog.h&quot;
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : #include &lt;TClonesArray.h&gt;
<span class="lineNum">      44 </span>            : #include &lt;TH2.h&gt;
<span class="lineNum">      45 </span>            : #include &lt;TMath.h&gt;
<span class="lineNum">      46 </span>            : #include &lt;TMatrixD.h&gt;
<span class="lineNum">      47 </span>            : #include &lt;TObjArray.h&gt;
<span class="lineNum">      48 </span>            : #include &lt;TRandom.h&gt;
<span class="lineNum">      49 </span>            : #include &lt;Riostream.h&gt;
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : using std::endl;
<a name="52"><span class="lineNum">      52 </span>            : using std::cout;</a>
<span class="lineNum">      53 </span>            : /// \cond CLASSIMP
<span class="lineNum">      54 </span><span class="lineCov">         18 : ClassImp(AliMUONClusterSplitterMLEM)</span>
<span class="lineNum">      55 </span>            : /// \endcond
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            : //const Double_t AliMUONClusterSplitterMLEM::fgkCouplMin = 1.e-3; // threshold on coupling 
<span class="lineNum">      58 </span>            : const Double_t AliMUONClusterSplitterMLEM::fgkCouplMin = 1.e-2; // threshold on coupling 
<a name="59"><span class="lineNum">      59 </span>            : </a>
<span class="lineNum">      60 </span>            : //_____________________________________________________________________________
<span class="lineNum">      61 </span>            : AliMUONClusterSplitterMLEM::AliMUONClusterSplitterMLEM(Int_t detElemId, 
<span class="lineNum">      62 </span>            :                                                        TObjArray* pixArray,
<span class="lineNum">      63 </span>            :                                                        Double_t lowestPixelCharge,
<span class="lineNum">      64 </span>            :                                                        Double_t lowestPadCharge,
<span class="lineNum">      65 </span>            :                                                        Double_t lowestClusterCharge) 
<span class="lineNum">      66 </span><span class="lineCov">        144 : : TObject(),</span>
<span class="lineNum">      67 </span><span class="lineCov">        144 : fPixArray(pixArray),</span>
<span class="lineNum">      68 </span><span class="lineCov">        144 : fMathieson(0x0),</span>
<span class="lineNum">      69 </span><span class="lineCov">        144 : fDetElemId(detElemId),</span>
<span class="lineNum">      70 </span><span class="lineCov">        144 : fNpar(0),</span>
<span class="lineNum">      71 </span><span class="lineCov">        144 : fQtot(0),</span>
<span class="lineNum">      72 </span><span class="lineCov">        144 : fnCoupled(0),</span>
<span class="lineNum">      73 </span><span class="lineCov">        144 : fDebug(0),</span>
<span class="lineNum">      74 </span><span class="lineCov">        144 : fLowestPixelCharge(lowestPixelCharge),</span>
<span class="lineNum">      75 </span><span class="lineCov">        144 : fLowestPadCharge(lowestPadCharge),</span>
<span class="lineNum">      76 </span><span class="lineCov">        144 : fLowestClusterCharge(lowestClusterCharge)</span>
<span class="lineNum">      77 </span><span class="lineCov">        720 : {</span>
<span class="lineNum">      78 </span>            :   /// Constructor
<span class="lineNum">      79 </span>            :   
<span class="lineNum">      80 </span><span class="lineCov">        144 :   AliMq::Station12Type stationType = AliMpDEManager::GetStation12Type(fDetElemId);</span>
<span class="lineNum">      81 </span>            :   
<span class="lineNum">      82 </span><span class="lineCov">        144 :   Float_t kx3 = AliMUONConstants::SqrtKx3();</span>
<span class="lineNum">      83 </span><span class="lineCov">        144 :   Float_t ky3 = AliMUONConstants::SqrtKy3();</span>
<span class="lineNum">      84 </span><span class="lineCov">        144 :   Float_t pitch = AliMUONConstants::Pitch();</span>
<span class="lineNum">      85 </span>            :   
<span class="lineNum">      86 </span><span class="lineCov">        144 :   if ( stationType == AliMq::kStation1 )</span>
<span class="lineNum">      87 </span>            :   {
<span class="lineNum">      88 </span><span class="lineCov">         28 :     kx3 = AliMUONConstants::SqrtKx3St1();</span>
<span class="lineNum">      89 </span><span class="lineCov">         28 :     ky3 = AliMUONConstants::SqrtKy3St1();</span>
<span class="lineNum">      90 </span><span class="lineCov">         28 :     pitch = AliMUONConstants::PitchSt1();</span>
<span class="lineNum">      91 </span><span class="lineCov">         28 :   }</span>
<span class="lineNum">      92 </span>            :   
<span class="lineNum">      93 </span><span class="lineCov">        432 :   fMathieson = new AliMUONMathieson;</span>
<span class="lineNum">      94 </span>            :   
<span class="lineNum">      95 </span><span class="lineCov">        144 :   fMathieson-&gt;SetPitch(pitch);</span>
<span class="lineNum">      96 </span><span class="lineCov">        144 :   fMathieson-&gt;SetSqrtKx3AndDeriveKx2Kx4(kx3);</span>
<span class="lineNum">      97 </span><span class="lineCov">        144 :   fMathieson-&gt;SetSqrtKy3AndDeriveKy2Ky4(ky3);</span>
<span class="lineNum">      98 </span>            :   
<span class="lineNum">      99 </span><span class="lineCov">        288 : }</span>
<a name="100"><span class="lineNum">     100 </span>            : </a>
<span class="lineNum">     101 </span>            : //_____________________________________________________________________________
<span class="lineNum">     102 </span>            : AliMUONClusterSplitterMLEM::~AliMUONClusterSplitterMLEM()
<span class="lineNum">     103 </span><span class="lineCov">        864 : {</span>
<span class="lineNum">     104 </span>            :   /// Destructor
<span class="lineNum">     105 </span>            :   
<span class="lineNum">     106 </span><span class="lineCov">        288 :   delete fMathieson;</span>
<span class="lineNum">     107 </span><span class="lineCov">        432 : }</span>
<span class="lineNum">     108 </span>            : 
<a name="109"><span class="lineNum">     109 </span>            : //_____________________________________________________________________________</a>
<span class="lineNum">     110 </span>            : void 
<span class="lineNum">     111 </span>            : AliMUONClusterSplitterMLEM::AddBin(TH2 *mlem, 
<span class="lineNum">     112 </span>            :                                    Int_t ic, Int_t jc, Int_t mode, 
<span class="lineNum">     113 </span>            :                                    Bool_t *used, TObjArray *pix)
<span class="lineNum">     114 </span>            : {
<span class="lineNum">     115 </span>            :   /// Add a bin to the cluster
<span class="lineNum">     116 </span>            :   
<span class="lineNum">     117 </span><span class="lineCov">        814 :   Int_t nx = mlem-&gt;GetNbinsX();</span>
<span class="lineNum">     118 </span><span class="lineCov">        407 :   Int_t ny = mlem-&gt;GetNbinsY();</span>
<span class="lineNum">     119 </span><span class="lineCov">        407 :   Double_t cont1, cont = mlem-&gt;GetBinContent(mlem-&gt;GetBin(jc,ic));</span>
<span class="lineNum">     120 </span>            :   AliMUONPad *pixPtr = 0;
<span class="lineNum">     121 </span>            :   
<span class="lineNum">     122 </span><span class="lineCov">        407 :   Int_t ie = TMath::Min(ic+1,ny), je = TMath::Min(jc+1,nx);</span>
<span class="lineNum">     123 </span><span class="lineCov">       3018 :   for (Int_t i = TMath::Max(ic-1,1); i &lt;= ie; ++i) {</span>
<span class="lineNum">     124 </span><span class="lineCov">       7980 :     for (Int_t j = TMath::Max(jc-1,1); j &lt;= je; ++j) {</span>
<span class="lineNum">     125 </span><span class="lineCov">       4709 :       if (i != ic &amp;&amp; j != jc) continue;</span>
<span class="lineNum">     126 </span><span class="lineCov">       1762 :       if (used[(i-1)*nx+j-1]) continue;</span>
<span class="lineNum">     127 </span><span class="lineCov">        706 :       cont1 = mlem-&gt;GetBinContent(mlem-&gt;GetBin(j,i));</span>
<span class="lineNum">     128 </span><span class="lineCov">        706 :       if (mode &amp;&amp; cont1 &gt; cont) continue;</span>
<span class="lineNum">     129 </span><span class="lineCov">        706 :       used[(i-1)*nx+j-1] = kTRUE;</span>
<span class="lineNum">     130 </span><span class="lineCov">        706 :       if (cont1 &lt; fLowestPixelCharge) continue;</span>
<span class="lineNum">     131 </span><span class="lineCov">        688 :       if (pix) pix-&gt;Add(BinToPix(mlem,j,i)); </span>
<span class="lineNum">     132 </span>            :       else {
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :         pixPtr = new AliMUONPad (mlem-&gt;GetXaxis()-&gt;GetBinCenter(j), </span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :                                  mlem-&gt;GetYaxis()-&gt;GetBinCenter(i), 0, 0, cont1);</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :         fPixArray-&gt;Add(pixPtr);</span>
<span class="lineNum">     136 </span>            :       }
<span class="lineNum">     137 </span><span class="lineCov">        344 :       AddBin(mlem, i, j, mode, used, pix); // recursive call</span>
<span class="lineNum">     138 </span><span class="lineCov">        344 :     }</span>
<span class="lineNum">     139 </span>            :   }
<span class="lineNum">     140 </span><span class="lineCov">        407 : }</span>
<span class="lineNum">     141 </span>            : 
<a name="142"><span class="lineNum">     142 </span>            : //_____________________________________________________________________________</a>
<span class="lineNum">     143 </span>            : void 
<span class="lineNum">     144 </span>            : AliMUONClusterSplitterMLEM::AddCluster(Int_t ic, Int_t nclust, 
<span class="lineNum">     145 </span>            :                                        TMatrixD&amp; aijcluclu, 
<span class="lineNum">     146 </span>            :                                        Bool_t *used, Int_t *clustNumb, Int_t &amp;nCoupled)
<span class="lineNum">     147 </span>            : {
<span class="lineNum">     148 </span>            :   /// Add a cluster to the group of coupled clusters
<span class="lineNum">     149 </span>            :   
<span class="lineNum">     150 </span><span class="lineCov">        431 :   for (Int_t i = 0; i &lt; nclust; ++i) {</span>
<span class="lineNum">     151 </span><span class="lineCov">        121 :     if (used[i]) continue;</span>
<span class="lineNum">     152 </span><span class="lineCov">         21 :     if (aijcluclu(i,ic) &lt; fgkCouplMin) continue;</span>
<span class="lineNum">     153 </span><span class="lineCov">         21 :     used[i] = kTRUE;</span>
<span class="lineNum">     154 </span><span class="lineCov">         21 :     clustNumb[nCoupled++] = i;</span>
<span class="lineNum">     155 </span><span class="lineCov">         21 :     AddCluster(i, nclust, aijcluclu, used, clustNumb, nCoupled);</span>
<span class="lineNum">     156 </span><span class="lineCov">         21 :   }</span>
<span class="lineNum">     157 </span><span class="lineCov">         63 : }</span>
<span class="lineNum">     158 </span>            : 
<a name="159"><span class="lineNum">     159 </span>            : //_____________________________________________________________________________</a>
<span class="lineNum">     160 </span>            : TObject* 
<span class="lineNum">     161 </span>            : AliMUONClusterSplitterMLEM::BinToPix(TH2 *mlem,
<span class="lineNum">     162 </span>            :                                      Int_t jc, Int_t ic)
<span class="lineNum">     163 </span>            : {
<span class="lineNum">     164 </span>            :   /// Translate histogram bin to pixel 
<span class="lineNum">     165 </span>            :   
<span class="lineNum">     166 </span><span class="lineCov">        900 :   Double_t yc = mlem-&gt;GetYaxis()-&gt;GetBinCenter(ic);</span>
<span class="lineNum">     167 </span><span class="lineCov">        450 :   Double_t xc = mlem-&gt;GetXaxis()-&gt;GetBinCenter(jc);</span>
<span class="lineNum">     168 </span>            :   
<span class="lineNum">     169 </span><span class="lineCov">        450 :   Int_t nPix = fPixArray-&gt;GetEntriesFast();</span>
<span class="lineNum">     170 </span>            :   AliMUONPad *pixPtr = NULL;
<span class="lineNum">     171 </span>            :   
<span class="lineNum">     172 </span>            :   // Compare pixel and bin positions
<span class="lineNum">     173 </span><span class="lineCov">       5414 :   for (Int_t i = 0; i &lt; nPix; ++i) {</span>
<span class="lineNum">     174 </span><span class="lineCov">       2707 :     pixPtr = (AliMUONPad*) fPixArray-&gt;UncheckedAt(i);</span>
<span class="lineNum">     175 </span><span class="lineCov">       2707 :     if (pixPtr-&gt;Charge() &lt; fLowestPixelCharge) continue; </span>
<span class="lineNum">     176 </span><span class="lineCov">       3401 :     if (TMath::Abs(pixPtr-&gt;Coord(0)-xc)&lt;1.e-4 &amp;&amp; TMath::Abs(pixPtr-&gt;Coord(1)-yc)&lt;1.e-4) </span>
<span class="lineNum">     177 </span>            :     {
<span class="lineNum">     178 </span>            :       //return (TObject*) pixPtr;
<span class="lineNum">     179 </span><span class="lineCov">        450 :       return pixPtr;</span>
<span class="lineNum">     180 </span>            :     }
<span class="lineNum">     181 </span>            :   }
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :   AliError(Form(&quot; Something wrong ??? %f %f &quot;, xc, yc));</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :   return NULL;</span>
<span class="lineNum">     184 </span><span class="lineCov">        450 : }</span>
<span class="lineNum">     185 </span>            : 
<a name="186"><span class="lineNum">     186 </span>            : //_____________________________________________________________________________</a>
<span class="lineNum">     187 </span>            : Float_t
<span class="lineNum">     188 </span>            : AliMUONClusterSplitterMLEM::ChargeIntegration(Double_t x, Double_t y,
<span class="lineNum">     189 </span>            :                                               const AliMUONPad&amp; pad)
<span class="lineNum">     190 </span>            : {
<span class="lineNum">     191 </span>            :   /// Compute the Mathieson integral on pad area, assuming the center
<span class="lineNum">     192 </span>            :   /// of the Mathieson is at (x,y)
<span class="lineNum">     193 </span>            :   
<span class="lineNum">     194 </span><span class="lineCov">     280992 :   TVector2 lowerLeft(TVector2(x,y)-pad.Position()-pad.Dimensions());</span>
<span class="lineNum">     195 </span><span class="lineCov">     187328 :   TVector2 upperRight(lowerLeft + pad.Dimensions()*2.0);</span>
<span class="lineNum">     196 </span>            :   
<span class="lineNum">     197 </span><span class="lineCov">      93664 :         return fMathieson-&gt;IntXY(lowerLeft.X(),lowerLeft.Y(),</span>
<span class="lineNum">     198 </span><span class="lineCov">      46832 :                            upperRight.X(),upperRight.Y());</span>
<span class="lineNum">     199 </span><span class="lineCov">      46832 : }</span>
<span class="lineNum">     200 </span>            : 
<a name="201"><span class="lineNum">     201 </span>            : //_____________________________________________________________________________</a>
<span class="lineNum">     202 </span>            : void 
<span class="lineNum">     203 </span>            : AliMUONClusterSplitterMLEM::Fcn1(const AliMUONCluster&amp; cluster, 
<span class="lineNum">     204 </span>            :                                     Int_t &amp; /*fNpar*/, Double_t * /*gin*/, 
<span class="lineNum">     205 </span>            :                                     Double_t &amp;f, Double_t *par, Int_t iflag)
<span class="lineNum">     206 </span>            : {
<span class="lineNum">     207 </span>            :   /// Computes the functional to be minimized
<span class="lineNum">     208 </span>            :   
<span class="lineNum">     209 </span>            :   Int_t indx, npads=0;
<span class="lineNum">     210 </span>            :   Double_t charge, delta, coef=0, chi2=0, qTot = 0;
<span class="lineNum">     211 </span>            :   static Double_t qAver = 0;
<span class="lineNum">     212 </span>            :   
<span class="lineNum">     213 </span><span class="lineCov">       4710 :   Int_t mult = cluster.Multiplicity(), iend = fNpar / 3;</span>
<span class="lineNum">     214 </span><span class="lineCov">      44316 :   for (Int_t j = 0; j &lt; mult; ++j) </span>
<span class="lineNum">     215 </span>            :   {
<span class="lineNum">     216 </span><span class="lineCov">      19803 :     AliMUONPad* pad = cluster.Pad(j);</span>
<span class="lineNum">     217 </span>            :     //if ( pad-&gt;Status() !=1 || pad-&gt;IsSaturated() ) continue;
<span class="lineNum">     218 </span><span class="lineCov">      39450 :     if ( pad-&gt;Status() != AliMUONClusterFinderMLEM::GetUseForFitFlag() ||</span>
<span class="lineNum">     219 </span><span class="lineCov">      19803 :          pad-&gt;Charge() == 0 ) continue;</span>
<span class="lineNum">     220 </span><span class="lineCov">      19647 :     if (iflag == 0) {</span>
<span class="lineNum">     221 </span><span class="lineCov">       2738 :       if ( pad-&gt;IsReal() ) npads++; // exclude virtual pads</span>
<span class="lineNum">     222 </span><span class="lineCov">       1422 :       qTot += pad-&gt;Charge(); </span>
<span class="lineNum">     223 </span><span class="lineCov">       1422 :     }</span>
<span class="lineNum">     224 </span>            :     charge = 0;
<span class="lineNum">     225 </span><span class="lineCov">      78588 :     for (Int_t i = 0; i &lt;= iend; ++i)</span>
<span class="lineNum">     226 </span>            :     { 
<span class="lineNum">     227 </span>            :       // sum over hits
<span class="lineNum">     228 </span><span class="lineCov">      19647 :       indx = 3 * i;</span>
<span class="lineNum">     229 </span><span class="lineCov">      19647 :       coef = Param2Coef(i, coef, par);</span>
<span class="lineNum">     230 </span><span class="lineCov">      19647 :       charge += ChargeIntegration(par[indx],par[indx+1],*pad) * coef;</span>
<span class="lineNum">     231 </span>            :     }
<span class="lineNum">     232 </span><span class="lineCov">      19647 :     charge *= fQtot;</span>
<span class="lineNum">     233 </span><span class="lineCov">      19647 :     delta = charge - pad-&gt;Charge(); </span>
<span class="lineNum">     234 </span><span class="lineCov">      19647 :     delta *= delta;</span>
<span class="lineNum">     235 </span><span class="lineCov">      19647 :     delta /= pad-&gt;Charge(); </span>
<span class="lineNum">     236 </span><span class="lineCov">      19647 :     chi2 += delta;</span>
<span class="lineNum">     237 </span><span class="lineCov">      19647 :   } // for (Int_t j=0;</span>
<span class="lineNum">     238 </span><span class="lineCov">       2519 :   if (iflag == 0 &amp;&amp; npads) qAver = qTot / npads;</span>
<span class="lineNum">     239 </span><span class="lineCov">       2355 :   if (!npads &amp;&amp; iflag==0)</span>
<span class="lineNum">     240 </span>            :   {
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :     AliError(Form(&quot;Got npads=0. Please check&quot;));</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     243 </span><span class="lineCov">       2355 :   f = chi2 / qAver;</span>
<span class="lineNum">     244 </span><span class="lineCov">       2355 : }</span>
<a name="245"><span class="lineNum">     245 </span>            : </a>
<span class="lineNum">     246 </span>            : //_____________________________________________________________________________
<span class="lineNum">     247 </span>            : Double_t AliMUONClusterSplitterMLEM::Param2Coef(Int_t icand, Double_t coef, Double_t *par) const
<span class="lineNum">     248 </span>            : {
<span class="lineNum">     249 </span>            :   /// Extract hit contribution scale factor from fit parameters
<span class="lineNum">     250 </span>            :   
<span class="lineNum">     251 </span><span class="lineCov">      59433 :   if (fNpar == 2) return 1.;</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :   if (fNpar == 5) return icand==0 ? par[2] : TMath::Max(1.-par[2],0.);</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :   if (icand == 0) return par[2];</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :   if (icand == 1) return TMath::Max((1.-par[2])*par[5], 0.);</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :   return TMath::Max(1.-par[2]-coef,0.);</span>
<span class="lineNum">     256 </span><span class="lineCov">      19811 : }</span>
<span class="lineNum">     257 </span>            : 
<a name="258"><span class="lineNum">     258 </span>            : //_____________________________________________________________________________</a>
<span class="lineNum">     259 </span>            : Int_t 
<span class="lineNum">     260 </span>            : AliMUONClusterSplitterMLEM::Fit(const AliMUONCluster&amp; cluster,
<span class="lineNum">     261 </span>            :                                 Int_t iSimple, Int_t nfit, 
<span class="lineNum">     262 </span>            :                                 const Int_t *clustFit, TObjArray **clusters, 
<span class="lineNum">     263 </span>            :                                 Double_t *parOk,
<span class="lineNum">     264 </span>            :                                 TObjArray&amp; clusterList, TH2 *mlem)
<span class="lineNum">     265 </span>            : {
<span class="lineNum">     266 </span>            :   /// Steering function and fitting procedure for the fit of pad charge distribution
<span class="lineNum">     267 </span>            :   
<span class="lineNum">     268 </span>            :   //  AliDebug(2,Form(&quot;iSimple=%d nfit=%d&quot;,iSimple,nfit));
<span class="lineNum">     269 </span>            :   
<span class="lineNum">     270 </span><span class="lineCov">        328 :   Double_t xmin = mlem-&gt;GetXaxis()-&gt;GetXmin() - mlem-&gt;GetXaxis()-&gt;GetBinWidth(1);</span>
<span class="lineNum">     271 </span><span class="lineCov">        164 :   Double_t xmax = mlem-&gt;GetXaxis()-&gt;GetXmax() + mlem-&gt;GetXaxis()-&gt;GetBinWidth(1);</span>
<span class="lineNum">     272 </span><span class="lineCov">        164 :   Double_t ymin = mlem-&gt;GetYaxis()-&gt;GetXmin() - mlem-&gt;GetYaxis()-&gt;GetBinWidth(1);</span>
<span class="lineNum">     273 </span><span class="lineCov">        164 :   Double_t ymax = mlem-&gt;GetYaxis()-&gt;GetXmax() + mlem-&gt;GetYaxis()-&gt;GetBinWidth(1);</span>
<span class="lineNum">     274 </span>            :   
<span class="lineNum">     275 </span>            :   // Number of pads to use and number of virtual pads
<span class="lineNum">     276 </span>            :   Int_t npads = 0, nVirtual = 0, nfit0 = nfit;
<span class="lineNum">     277 </span>            :   //cluster.Print(&quot;full&quot;);
<span class="lineNum">     278 </span><span class="lineCov">        164 :   Int_t mult = cluster.Multiplicity();</span>
<span class="lineNum">     279 </span><span class="lineCov">       3188 :   for (Int_t i = 0; i &lt; mult; ++i ) </span>
<span class="lineNum">     280 </span>            :   {
<span class="lineNum">     281 </span><span class="lineCov">       1430 :     AliMUONPad* pad = cluster.Pad(i);</span>
<span class="lineNum">     282 </span><span class="lineCov">       1536 :     if ( !pad-&gt;IsReal() ) ++nVirtual;</span>
<span class="lineNum">     283 </span>            :     //if ( pad-&gt;Status() !=1 || pad-&gt;IsSaturated() ) continue;
<span class="lineNum">     284 </span><span class="lineCov">       1438 :     if ( pad-&gt;Status() != AliMUONClusterFinderMLEM::GetUseForFitFlag() ) continue;</span>
<span class="lineNum">     285 </span><span class="lineCov">       1422 :     if ( pad-&gt;IsReal() )</span>
<span class="lineNum">     286 </span>            :     {
<span class="lineNum">     287 </span><span class="lineCov">       1316 :       ++npads;</span>
<span class="lineNum">     288 </span><span class="lineCov">       1316 :     }</span>
<span class="lineNum">     289 </span><span class="lineCov">       1422 :   }</span>
<span class="lineNum">     290 </span>            :   
<span class="lineNum">     291 </span><span class="lineCov">        164 :   fNpar = 0;</span>
<span class="lineNum">     292 </span><span class="lineCov">        164 :   fQtot = 0;</span>
<span class="lineNum">     293 </span>            :   
<span class="lineNum">     294 </span><span class="lineCov">        164 :   if (npads &lt; 2) return 0; </span>
<span class="lineNum">     295 </span>            :   
<span class="lineNum">     296 </span>            :   // FIXME : AliWarning(&quot;Reconnect the following code for hit/track passing ?&quot;);
<span class="lineNum">     297 </span>            :   
<span class="lineNum">     298 </span>            :   //  Int_t tracks[3] = {-1, -1, -1};
<span class="lineNum">     299 </span>            :   
<span class="lineNum">     300 </span>            :   /*
<span class="lineNum">     301 </span>            :    Int_t digit = 0;
<span class="lineNum">     302 </span>            :    AliMUONDigit *mdig = 0;
<span class="lineNum">     303 </span>            :    for (Int_t cath=0; cath&lt;2; cath++) {  
<span class="lineNum">     304 </span>            :      for (Int_t i=0; i&lt;fnPads[0]+fnPads[1]; i++) {
<span class="lineNum">     305 </span>            :        if (fPadIJ[0][i] != cath) continue;
<span class="lineNum">     306 </span>            :        if (fPadIJ[1][i] != 1) continue;
<span class="lineNum">     307 </span>            :        if (fXyq[3][i] &lt; 0) continue; // exclude virtual pads
<span class="lineNum">     308 </span>            :        digit = TMath::Nint (fXyq[5][i]);
<span class="lineNum">     309 </span>            :        if (digit &gt;= 0) mdig = fInput-&gt;Digit(cath,digit);
<span class="lineNum">     310 </span>            :        else mdig = fInput-&gt;Digit(TMath::Even(cath),-digit-1);
<span class="lineNum">     311 </span>            :        //if (!mdig) mdig = fInput-&gt;Digit(TMath::Even(cath),digit);
<span class="lineNum">     312 </span>            :        if (!mdig) continue; // protection for cluster display
<span class="lineNum">     313 </span>            :        if (mdig-&gt;Hit() &gt;= 0) {
<span class="lineNum">     314 </span>            :          if (tracks[0] &lt; 0) {
<span class="lineNum">     315 </span>            :            tracks[0] = mdig-&gt;Hit();
<span class="lineNum">     316 </span>            :            tracks[1] = mdig-&gt;Track(0);
<span class="lineNum">     317 </span>            :          } else if (mdig-&gt;Track(0) &lt; tracks[1]) {
<span class="lineNum">     318 </span>            :            tracks[0] = mdig-&gt;Hit();
<span class="lineNum">     319 </span>            :            tracks[1] = mdig-&gt;Track(0);
<span class="lineNum">     320 </span>            :          }
<span class="lineNum">     321 </span>            :        }
<span class="lineNum">     322 </span>            :        if (mdig-&gt;Track(1) &gt;= 0 &amp;&amp; mdig-&gt;Track(1) != tracks[1]) {
<span class="lineNum">     323 </span>            :          if (tracks[2] &lt; 0) tracks[2] = mdig-&gt;Track(1);
<span class="lineNum">     324 </span>            :          else tracks[2] = TMath::Min (tracks[2], mdig-&gt;Track(1));
<span class="lineNum">     325 </span>            :        }
<span class="lineNum">     326 </span>            :      } // for (Int_t i=0;
<span class="lineNum">     327 </span>            :   } // for (Int_t cath=0;
<span class="lineNum">     328 </span>            :    */
<span class="lineNum">     329 </span>            :   
<span class="lineNum">     330 </span>            :   // Get number of pads in X and Y 
<span class="lineNum">     331 </span>            :   //const Int_t kStatusToTest(1);
<span class="lineNum">     332 </span><span class="lineCov">        164 :   const Int_t kStatusToTest(AliMUONClusterFinderMLEM::GetUseForFitFlag());</span>
<span class="lineNum">     333 </span>            :   
<span class="lineNum">     334 </span><span class="lineCov">        164 :   Long_t nofPads = cluster.NofPads(kStatusToTest);</span>
<span class="lineNum">     335 </span><span class="lineCov">        164 :   Int_t nInX = AliMp::PairFirst(nofPads);</span>
<span class="lineNum">     336 </span><span class="lineCov">        164 :   Int_t nInY = AliMp::PairSecond(nofPads);</span>
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span><span class="lineCov">        164 :   if (fDebug) {</span>
<span class="lineNum">     339 </span>            :     Int_t npadOK = 0;
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :     for (Int_t j = 0; j &lt; cluster.Multiplicity(); ++j) {</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :       AliMUONPad *pad = cluster.Pad(j);</span>
<span class="lineNum">     342 </span>            :       //if (pad-&gt;Status() == 1 &amp;&amp; !pad-&gt;IsSaturated()) npadOK++;
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :       if (pad-&gt;Status() == AliMUONClusterFinderMLEM::GetUseForFitFlag() &amp;&amp; !pad-&gt;IsSaturated()) npadOK++;</span>
<span class="lineNum">     344 </span>            :     }
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :     cout &lt;&lt; &quot; Number of pads to fit: &quot; &lt;&lt; npadOK &lt;&lt; endl;</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :     cout &lt;&lt; &quot; nInX and Y: &quot; &lt;&lt; nInX &lt;&lt; &quot; &quot; &lt;&lt; nInY &lt;&lt; endl;</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     348 </span>            :   
<span class="lineNum">     349 </span>            :   Int_t nfitMax = 3; 
<span class="lineNum">     350 </span><span class="lineCov">        164 :   nfitMax = TMath::Min (nfitMax, (npads + 1) / 3);</span>
<span class="lineNum">     351 </span><span class="lineCov">        164 :   if (nfitMax &gt; 1) {</span>
<span class="lineNum">     352 </span><span class="lineCov">        552 :     if (((nInX &lt; 3) &amp;&amp; (nInY &lt; 3)) || ((nInX == 3) &amp;&amp; (nInY &lt; 3)) || ((nInX &lt; 3) &amp;&amp; (nInY == 3))) nfitMax = 1; // not enough pads in each direction</span>
<span class="lineNum">     353 </span>            :   }
<span class="lineNum">     354 </span><span class="lineCov">        164 :   if (nfit &gt; nfitMax) nfit = nfitMax;</span>
<span class="lineNum">     355 </span>            :   
<span class="lineNum">     356 </span>            :   // Take cluster maxima as fitting seeds
<span class="lineNum">     357 </span>            :   TObjArray *pix;
<span class="lineNum">     358 </span>            :   AliMUONPad *pixPtr;
<span class="lineNum">     359 </span>            :   Int_t npxclu;
<span class="lineNum">     360 </span><span class="lineCov">        164 :   Double_t cont, cmax = 0, xseed = 0, yseed = 0, errOk[8], qq = 0;</span>
<span class="lineNum">     361 </span>            :   
<span class="lineNum">     362 </span><span class="lineCov">       2952 :   for ( int i = 0; i &lt; 8; ++i ) errOk[i]=0.0;</span>
<span class="lineNum">     363 </span>            :   
<span class="lineNum">     364 </span><span class="lineCov">        164 :   Double_t xyseed[3][2], qseed[3], xyCand[3][2] = {{0},{0}}, sigCand[3][2] = {{0},{0}};</span>
<span class="lineNum">     365 </span>            :   
<span class="lineNum">     366 </span><span class="lineCov">        694 :   for (Int_t ifit = 1; ifit &lt;= nfit0; ++ifit) </span>
<span class="lineNum">     367 </span>            :   {
<span class="lineNum">     368 </span>            :     cmax = 0;
<span class="lineNum">     369 </span><span class="lineCov">        183 :     pix = clusters[clustFit[ifit-1]];</span>
<span class="lineNum">     370 </span><span class="lineCov">        183 :     npxclu = pix-&gt;GetEntriesFast();</span>
<span class="lineNum">     371 </span>            :     //qq = 0;
<span class="lineNum">     372 </span><span class="lineCov">       2616 :     for (Int_t clu = 0; clu &lt; npxclu; ++clu) </span>
<span class="lineNum">     373 </span>            :     {
<span class="lineNum">     374 </span><span class="lineCov">       1125 :       pixPtr = (AliMUONPad*) pix-&gt;UncheckedAt(clu);</span>
<span class="lineNum">     375 </span><span class="lineCov">       1125 :       cont = pixPtr-&gt;Charge();</span>
<span class="lineNum">     376 </span><span class="lineCov">       1125 :       fQtot += cont;</span>
<span class="lineNum">     377 </span><span class="lineCov">       1125 :       if (cont &gt; cmax) </span>
<span class="lineNum">     378 </span>            :       { 
<span class="lineNum">     379 </span>            :         cmax = cont; 
<span class="lineNum">     380 </span><span class="lineCov">        439 :         xseed = pixPtr-&gt;Coord(0);</span>
<span class="lineNum">     381 </span><span class="lineCov">        439 :         yseed = pixPtr-&gt;Coord(1);</span>
<span class="lineNum">     382 </span><span class="lineCov">        439 :       }</span>
<span class="lineNum">     383 </span><span class="lineCov">       1125 :       qq += cont;</span>
<span class="lineNum">     384 </span><span class="lineCov">       1125 :       xyCand[0][0] += pixPtr-&gt;Coord(0) * cont;</span>
<span class="lineNum">     385 </span><span class="lineCov">       1125 :       xyCand[0][1] += pixPtr-&gt;Coord(1) * cont;</span>
<span class="lineNum">     386 </span><span class="lineCov">       1125 :       sigCand[0][0] += pixPtr-&gt;Coord(0) * pixPtr-&gt;Coord(0) * cont;</span>
<span class="lineNum">     387 </span><span class="lineCov">       1125 :       sigCand[0][1] += pixPtr-&gt;Coord(1) * pixPtr-&gt;Coord(1) * cont;</span>
<span class="lineNum">     388 </span>            :     }
<span class="lineNum">     389 </span><span class="lineCov">        183 :     xyseed[ifit-1][0] = xseed;</span>
<span class="lineNum">     390 </span><span class="lineCov">        183 :     xyseed[ifit-1][1] = yseed;</span>
<span class="lineNum">     391 </span><span class="lineCov">        183 :     qseed[ifit-1] = cmax;</span>
<span class="lineNum">     392 </span>            :   } // for (Int_t ifit=1;
<span class="lineNum">     393 </span>            :   
<span class="lineNum">     394 </span><span class="lineCov">        164 :   xyCand[0][0] /= qq; // &lt;x&gt;</span>
<span class="lineNum">     395 </span><span class="lineCov">        164 :   xyCand[0][1] /= qq; // &lt;y&gt;</span>
<span class="lineNum">     396 </span><span class="lineCov">        164 :   sigCand[0][0] = sigCand[0][0]/qq - xyCand[0][0]*xyCand[0][0]; // &lt;x^2&gt; - &lt;x&gt;^2</span>
<span class="lineNum">     397 </span><span class="lineCov">        492 :   sigCand[0][0] = sigCand[0][0] &gt; 0 ? TMath::Sqrt (sigCand[0][0]) : 0;</span>
<span class="lineNum">     398 </span><span class="lineCov">        164 :   sigCand[0][1] = sigCand[0][1]/qq - xyCand[0][1]*xyCand[0][1]; // &lt;y^2&gt; - &lt;y&gt;^2</span>
<span class="lineNum">     399 </span><span class="lineCov">        492 :   sigCand[0][1] = sigCand[0][1] &gt; 0 ? TMath::Sqrt (sigCand[0][1]) : 0;</span>
<span class="lineNum">     400 </span><span class="lineCov">        164 :   if (fDebug) cout &lt;&lt; xyCand[0][0] &lt;&lt; &quot; &quot; &lt;&lt; xyCand[0][1] &lt;&lt; &quot; &quot; &lt;&lt; sigCand[0][0] &lt;&lt; &quot; &quot; &lt;&lt; sigCand[0][1] &lt;&lt; endl;</span>
<span class="lineNum">     401 </span>            :   
<span class="lineNum">     402 </span><span class="lineCov">        164 :   Int_t nDof, maxSeed[3];//, nMax = 0;</span>
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span><span class="lineCov">        164 :   if ( nfit0 &lt; 0 || nfit0 &gt; 3 ) {</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :      AliErrorStream() &lt;&lt; &quot;Wrong nfit0 value: &quot; &lt;&lt; nfit0 &lt;&lt; endl;</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :      return nfit;</span>
<span class="lineNum">     407 </span>            :   }   
<span class="lineNum">     408 </span><span class="lineCov">        164 :   TMath::Sort(nfit0, qseed, maxSeed, kTRUE); // in decreasing order</span>
<span class="lineNum">     409 </span>            :     
<span class="lineNum">     410 </span><span class="lineCov">        164 :   Double_t step[3]={0.01,0.002,0.02}, fmin, chi2o = 9999, chi2n;</span>
<span class="lineNum">     411 </span><span class="lineCov">        164 :   Double_t *gin = 0, func0, func1, param[8]={0}, step0[8]={0};</span>
<span class="lineNum">     412 </span><span class="lineCov">        164 :   Double_t param0[2][8]={{0},{0}}, deriv[2][8]={{0},{0}}; </span>
<span class="lineNum">     413 </span><span class="lineCov">        164 :   Double_t shift[8]={0}, stepMax, derMax, parmin[8]={0}, parmax[8]={0}, func2[2]={0}, shift0;</span>
<span class="lineNum">     414 </span><span class="lineCov">        164 :   Double_t delta[8]={0}, scMax, dder[8], estim, shiftSave = 0;</span>
<span class="lineNum">     415 </span>            :   Int_t min, max, nCall = 0, nLoop, idMax = 0, nFail;
<span class="lineNum">     416 </span><span class="lineCov">        164 :   Double_t rad, dist[3] = {0};</span>
<span class="lineNum">     417 </span>            :     
<span class="lineNum">     418 </span>            :   // Try to fit with one-track hypothesis, then 2-track. If chi2/dof is 
<span class="lineNum">     419 </span>            :   // lower, try 3-track (if number of pads is sufficient).
<span class="lineNum">     420 </span>            :   Int_t iflag = 0; // for the first call of fcn1
<span class="lineNum">     421 </span><span class="lineCov">        358 :   for (Int_t iseed = 0; iseed &lt; nfit; ++iseed) </span>
<span class="lineNum">     422 </span>            :   {
<span class="lineNum">     423 </span>            :       
<span class="lineNum">     424 </span><span class="lineCov">        164 :     Int_t memory[8] = {0};</span>
<span class="lineNum">     425 </span><span class="lineCov">        164 :     if (iseed) </span>
<span class="lineNum">     426 </span>            :     { 
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :       for (Int_t j = 0; j &lt; fNpar; ++j) </span>
<span class="lineNum">     428 </span>            :       {
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :         param[j] = parOk[j]; </span>
<span class="lineNum">     430 </span>            :       }
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :       param[fNpar] = 0.6;</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :       parmin[fNpar] = 1E-9; </span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :       parmax[fNpar++] = 1; </span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     435 </span>            :       
<span class="lineNum">     436 </span><span class="lineCov">        164 :     if (nfit == 1) </span>
<span class="lineNum">     437 </span>            :     {
<span class="lineNum">     438 </span><span class="lineCov">        149 :       param[fNpar] = xyCand[0][0]; // take COG</span>
<span class="lineNum">     439 </span><span class="lineCov">        149 :     }</span>
<span class="lineNum">     440 </span>            :     else 
<span class="lineNum">     441 </span>            :     {
<span class="lineNum">     442 </span><span class="lineCov">         15 :       param[fNpar] = xyseed[maxSeed[iseed]][0];</span>
<span class="lineNum">     443 </span>            :       //param[fNpar] = fNpar==0 ? -16.1651 : -15.2761; 
<span class="lineNum">     444 </span>            :     }
<span class="lineNum">     445 </span><span class="lineCov">        164 :     parmin[fNpar] = xmin; </span>
<span class="lineNum">     446 </span><span class="lineCov">        164 :     parmax[fNpar++] = xmax; </span>
<span class="lineNum">     447 </span><span class="lineCov">        164 :     if (nfit == 1) </span>
<span class="lineNum">     448 </span>            :     {
<span class="lineNum">     449 </span><span class="lineCov">        149 :       param[fNpar] = xyCand[0][1]; // take COG</span>
<span class="lineNum">     450 </span><span class="lineCov">        149 :     }</span>
<span class="lineNum">     451 </span>            :     else 
<span class="lineNum">     452 </span>            :     {
<span class="lineNum">     453 </span><span class="lineCov">         15 :       param[fNpar] = xyseed[maxSeed[iseed]][1];</span>
<span class="lineNum">     454 </span>            :       //param[fNpar] = fNpar==1 ? -15.1737 : -15.8487;
<span class="lineNum">     455 </span>            :     }
<span class="lineNum">     456 </span><span class="lineCov">        164 :     parmin[fNpar] = ymin; </span>
<span class="lineNum">     457 </span><span class="lineCov">        164 :     parmax[fNpar++] = ymax; </span>
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span><span class="lineCov">        984 :     for (Int_t j = 0; j &lt; fNpar; ++j) </span>
<span class="lineNum">     460 </span>            :     {
<span class="lineNum">     461 </span><span class="lineCov">        328 :       step0[j] = shift[j] = step[j%3];</span>
<span class="lineNum">     462 </span>            :     }
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span><span class="lineCov">        164 :     if (iseed) </span>
<span class="lineNum">     465 </span>            :     { 
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :       for (Int_t j = 0; j &lt; fNpar; ++j) </span>
<span class="lineNum">     467 </span>            :       {
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :         param0[1][j] = 0; </span>
<span class="lineNum">     469 </span>            :       }
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     471 </span><span class="lineCov">        164 :     if (fDebug) {</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :       for (Int_t j = 0; j &lt; fNpar; ++j) cout &lt;&lt; param[j] &lt;&lt; &quot; &quot;; </span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :       cout &lt;&lt; endl;</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     475 </span>            :       
<span class="lineNum">     476 </span>            :     // Try new algorithm
<span class="lineNum">     477 </span><span class="lineCov">        164 :     min = nLoop = 1; stepMax = func2[1] = derMax = 999999; nFail = 0;</span>
<span class="lineNum">     478 </span>            :       
<span class="lineNum">     479 </span><span class="lineCov">        164 :     while (1) </span>
<span class="lineNum">     480 </span>            :     {
<span class="lineNum">     481 </span><span class="lineCov">        785 :       max = !min;</span>
<span class="lineNum">     482 </span><span class="lineCov">        785 :       Fcn1(cluster,fNpar, gin, func0, param, iflag); nCall++;</span>
<span class="lineNum">     483 </span>            :       iflag = 1;
<span class="lineNum">     484 </span>            :       //cout &lt;&lt; &quot; Func: &quot; &lt;&lt; func0 &lt;&lt; endl;
<span class="lineNum">     485 </span>            :       
<span class="lineNum">     486 </span><span class="lineCov">        785 :       func2[max] = func0;</span>
<span class="lineNum">     487 </span><span class="lineCov">       4710 :       for (Int_t j = 0; j &lt; fNpar; ++j) </span>
<span class="lineNum">     488 </span>            :       {
<span class="lineNum">     489 </span><span class="lineCov">       1570 :         param0[max][j] = param[j];</span>
<span class="lineNum">     490 </span><span class="lineCov">       1570 :         delta[j] = step0[j];</span>
<span class="lineNum">     491 </span><span class="lineCov">       1570 :         param[j] += delta[j] / 10;</span>
<span class="lineNum">     492 </span><span class="lineCov">       2355 :         if (j &gt; 0) param[j-1] -= delta[j-1] / 10;</span>
<span class="lineNum">     493 </span><span class="lineCov">       1570 :         Fcn1(cluster,fNpar, gin, func1, param, iflag); nCall++;</span>
<span class="lineNum">     494 </span><span class="lineCov">       1570 :         deriv[max][j] = (func1 - func0) / delta[j] * 10; // first derivative</span>
<span class="lineNum">     495 </span>            :         //cout &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; deriv[max][j] &lt;&lt; endl;
<span class="lineNum">     496 </span><span class="lineCov">       6248 :         dder[j] = param0[0][j] != param0[1][j] ? (deriv[0][j] - deriv[1][j]) / </span>
<span class="lineNum">     497 </span><span class="lineCov">       1554 :           (param0[0][j] - param0[1][j]) : 0; // second derivative</span>
<span class="lineNum">     498 </span>            :       }
<span class="lineNum">     499 </span><span class="lineCov">        785 :       param[fNpar-1] -= delta[fNpar-1] / 10;</span>
<span class="lineNum">     500 </span><span class="lineCov">        785 :       if (nCall &gt; 2000) break;</span>
<span class="lineNum">     501 </span>            :         
<span class="lineNum">     502 </span><span class="lineCov">        785 :       min = func2[0] &lt; func2[1] ? 0 : 1;</span>
<span class="lineNum">     503 </span><span class="lineCov">        785 :       nFail = min == max ? 0 : nFail + 1;</span>
<span class="lineNum">     504 </span>            :         
<span class="lineNum">     505 </span>            :       stepMax = derMax = estim = 0;
<span class="lineNum">     506 </span><span class="lineCov">       4710 :       for (Int_t j = 0; j &lt; fNpar; ++j) </span>
<span class="lineNum">     507 </span>            :       { 
<span class="lineNum">     508 </span>            :         // Estimated distance to minimum
<span class="lineNum">     509 </span><span class="lineCov">       1570 :         shift0 = shift[j];</span>
<span class="lineNum">     510 </span><span class="lineCov">       1570 :         if (nLoop == 1) </span>
<span class="lineNum">     511 </span>            :         {
<span class="lineNum">     512 </span><span class="lineCov">        328 :           shift[j] = TMath::Sign (step0[j], -deriv[max][j]); // first step</span>
<span class="lineNum">     513 </span><span class="lineCov">        328 :         }</span>
<span class="lineNum">     514 </span><span class="lineCov">       1274 :         else if (TMath::Abs(deriv[0][j]) &lt; 1.e-3 &amp;&amp; TMath::Abs(deriv[1][j]) &lt; 1.e-3) </span>
<span class="lineNum">     515 </span>            :         {
<span class="lineNum">     516 </span><span class="lineCov">         22 :           shift[j] = 0;</span>
<span class="lineNum">     517 </span><span class="lineCov">         22 :         }</span>
<span class="lineNum">     518 </span><span class="lineCov">       3234 :         else if (((deriv[min][j]*deriv[!min][j] &gt; 0) &amp;&amp; (TMath::Abs(deriv[min][j]) &gt; TMath::Abs(deriv[!min][j])))</span>
<span class="lineNum">     519 </span><span class="lineCov">       3158 :                  || (TMath::Abs(deriv[0][j]-deriv[1][j]) &lt; 1.e-3) || (TMath::Abs(dder[j]) &lt; 1.e-6)) </span>
<span class="lineNum">     520 </span>            :         {
<span class="lineNum">     521 </span><span class="lineCov">         80 :           shift[j] = -TMath::Sign (shift[j], (func2[0]-func2[1]) * (param0[0][j]-param0[1][j]));</span>
<span class="lineNum">     522 </span><span class="lineCov">         80 :           if (min == max) </span>
<span class="lineNum">     523 </span>            :           { 
<span class="lineNum">     524 </span><span class="lineCov">         66 :             if (memory[j] &gt; 1) </span>
<span class="lineNum">     525 </span>            :             { 
<span class="lineNum">     526 </span><span class="lineCov">         14 :               shift[j] *= 2; </span>
<span class="lineNum">     527 </span><span class="lineCov">         14 :             } </span>
<span class="lineNum">     528 </span><span class="lineCov">         66 :             memory[j]++;</span>
<span class="lineNum">     529 </span><span class="lineCov">         66 :           }</span>
<span class="lineNum">     530 </span>            :         }
<span class="lineNum">     531 </span>            :         else 
<span class="lineNum">     532 </span>            :         {
<span class="lineNum">     533 </span><span class="lineCov">       3420 :           shift[j] = dder[j] != 0 ? -deriv[min][j] / dder[j] : 0;</span>
<span class="lineNum">     534 </span><span class="lineCov">       1140 :           memory[j] = 0;</span>
<span class="lineNum">     535 </span>            :         }
<span class="lineNum">     536 </span>            :           
<span class="lineNum">     537 </span><span class="lineCov">       1570 :         Double_t es = TMath::Abs(shift[j]) / step0[j];</span>
<span class="lineNum">     538 </span><span class="lineCov">       1570 :         if (es &gt; estim) </span>
<span class="lineNum">     539 </span>            :         { 
<span class="lineNum">     540 </span>            :           estim = es;
<span class="lineNum">     541 </span><span class="lineCov">       1208 :         }</span>
<span class="lineNum">     542 </span>            :           
<span class="lineNum">     543 </span>            :         // Too big step
<span class="lineNum">     544 </span><span class="lineCov">       1842 :         if (TMath::Abs(shift[j])/step0[j] &gt; 10) shift[j] = TMath::Sign(10.,shift[j]) * step0[j]; // </span>
<span class="lineNum">     545 </span>            :         
<span class="lineNum">     546 </span>            :         // Failed to improve minimum
<span class="lineNum">     547 </span><span class="lineCov">       1570 :         if (min != max) </span>
<span class="lineNum">     548 </span>            :         {
<span class="lineNum">     549 </span><span class="lineCov">         42 :           memory[j] = 0;</span>
<span class="lineNum">     550 </span><span class="lineCov">         42 :           param[j] = param0[min][j];</span>
<span class="lineNum">     551 </span><span class="lineCov">         84 :           if (TMath::Abs(shift[j]+shift0) &gt; 0.1*step0[j]) </span>
<span class="lineNum">     552 </span>            :           {
<span class="lineNum">     553 </span><span class="lineCov">         70 :             shift[j] = (shift[j] + shift0) / 2;</span>
<span class="lineNum">     554 </span><span class="lineCov">         28 :           }</span>
<span class="lineNum">     555 </span>            :           else 
<span class="lineNum">     556 </span>            :           {
<span class="lineNum">     557 </span><span class="lineCov">         14 :             shift[j] /= -2;</span>
<span class="lineNum">     558 </span>            :           }
<span class="lineNum">     559 </span>            :         } 
<span class="lineNum">     560 </span>            :           
<span class="lineNum">     561 </span>            :         // Too big step
<span class="lineNum">     562 </span><span class="lineCov">       1570 :         if (TMath::Abs(shift[j]*deriv[min][j]) &gt; func2[min]) </span>
<span class="lineNum">     563 </span>            :         {
<span class="lineNum">     564 </span><span class="lineCov">        211 :           shift[j] = TMath::Sign (func2[min]/deriv[min][j], shift[j]);</span>
<span class="lineNum">     565 </span><span class="lineCov">        211 :         }</span>
<span class="lineNum">     566 </span>            :           
<span class="lineNum">     567 </span>            :         // Introduce step relaxation factor
<span class="lineNum">     568 </span><span class="lineCov">       1570 :         if (memory[j] &lt; 3) </span>
<span class="lineNum">     569 </span>            :         {
<span class="lineNum">     570 </span><span class="lineCov">       1556 :           scMax = 1 + 4 / TMath::Max(nLoop/2.,1.);</span>
<span class="lineNum">     571 </span><span class="lineCov">       3100 :           if (TMath::Abs(shift0) &gt; 0 &amp;&amp; TMath::Abs(shift[j]/shift0) &gt; scMax) </span>
<span class="lineNum">     572 </span>            :           {
<span class="lineNum">     573 </span><span class="lineCov">        199 :             shift[j] = TMath::Sign (shift0*scMax, shift[j]);</span>
<span class="lineNum">     574 </span><span class="lineCov">        199 :           }</span>
<span class="lineNum">     575 </span>            :         }
<span class="lineNum">     576 </span><span class="lineCov">       1570 :         param[j] += shift[j]; </span>
<span class="lineNum">     577 </span>            :         // Check parameter limits
<span class="lineNum">     578 </span><span class="lineCov">       1570 :         if (param[j] &lt; parmin[j]) </span>
<span class="lineNum">     579 </span>            :         { 
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :           shift[j] = parmin[j] - param[j]; </span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :           param[j] = parmin[j]; </span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :         } </span>
<span class="lineNum">     583 </span><span class="lineCov">       1570 :         else if (param[j] &gt; parmax[j]) </span>
<span class="lineNum">     584 </span>            :         {
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :           shift[j] = parmax[j] - param[j];</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :           param[j] = parmax[j];</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     588 </span>            :         //cout &lt;&lt; &quot; xxx &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; shift[j] &lt;&lt; &quot; &quot; &lt;&lt; param[j] &lt;&lt; endl;
<span class="lineNum">     589 </span><span class="lineCov">       1570 :         stepMax = TMath::Max (stepMax, TMath::Abs(shift[j]/step0[j]));</span>
<span class="lineNum">     590 </span><span class="lineCov">       1570 :         if (TMath::Abs(deriv[min][j]) &gt; derMax) </span>
<span class="lineNum">     591 </span>            :         {
<span class="lineNum">     592 </span>            :           idMax = j;
<span class="lineNum">     593 </span><span class="lineCov">       1198 :           derMax = TMath::Abs (deriv[min][j]);</span>
<span class="lineNum">     594 </span><span class="lineCov">       1198 :         }</span>
<span class="lineNum">     595 </span>            :       } // for (Int_t j=0; j&lt;fNpar;
<span class="lineNum">     596 </span>            :         
<span class="lineNum">     597 </span><span class="lineCov">        785 :       if (((estim &lt; 1) &amp;&amp; (derMax &lt; 2)) || nLoop &gt; 150) break; // minimum was found</span>
<span class="lineNum">     598 </span>            :         
<span class="lineNum">     599 </span><span class="lineCov">        621 :       nLoop++;</span>
<span class="lineNum">     600 </span>            :         
<span class="lineNum">     601 </span>            :       // Check for small step
<span class="lineNum">     602 </span><span class="lineCov">        621 :       if (shift[idMax] == 0) </span>
<span class="lineNum">     603 </span>            :       { 
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :         shift[idMax] = step0[idMax]/10; </span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :         param[idMax] += shift[idMax]; </span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :         continue; </span>
<span class="lineNum">     607 </span>            :       }
<span class="lineNum">     608 </span>            :         
<span class="lineNum">     609 </span><span class="lineCov">        621 :       if (!memory[idMax] &amp;&amp; derMax &gt; 0.5 &amp;&amp; nLoop &gt; 10) </span>
<span class="lineNum">     610 </span>            :       {
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :         if (dder[idMax] != 0 &amp;&amp; TMath::Abs(deriv[min][idMax]/dder[idMax]/shift[idMax]) &gt; 10) </span>
<span class="lineNum">     612 </span>            :         {
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :           if (min == max) dder[idMax] = -dder[idMax];</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :           shift[idMax] = -deriv[min][idMax] / dder[idMax] / 10; </span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :           param[idMax] += shift[idMax];</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :           stepMax = TMath::Max (stepMax, TMath::Abs(shift[idMax])/step0[idMax]);</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :           if (min == max) shiftSave = shift[idMax];</span>
<span class="lineNum">     618 </span>            :         }
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :         if (nFail &gt; 10) </span>
<span class="lineNum">     620 </span>            :         {
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :           param[idMax] -= shift[idMax];</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :           shift[idMax] = 4 * shiftSave * (gRandom-&gt;Rndm(0) - 0.5);</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :           param[idMax] += shift[idMax];</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     625 </span>            :       }      
<span class="lineNum">     626 </span>            :     } // while (1)
<span class="lineNum">     627 </span>            :       
<span class="lineNum">     628 </span><span class="lineCov">        164 :     fmin = func2[min];</span>
<span class="lineNum">     629 </span>            :     
<span class="lineNum">     630 </span><span class="lineCov">        164 :     nDof = npads - fNpar + nVirtual;</span>
<span class="lineNum">     631 </span><span class="lineCov">        164 :     if (!nDof) nDof++;</span>
<span class="lineNum">     632 </span><span class="lineCov">        164 :     chi2n = fmin / nDof;</span>
<span class="lineNum">     633 </span><span class="lineCov">        164 :     if (fDebug) cout &lt;&lt; &quot; Chi2 &quot; &lt;&lt; chi2n &lt;&lt; &quot; &quot; &lt;&lt; fNpar &lt;&lt; endl;</span>
<span class="lineNum">     634 </span>            :       
<span class="lineNum">     635 </span>            :     //if (fNpar &gt; 2) cout &lt;&lt; param0[min][fNpar-3] &lt;&lt; &quot; &quot; &lt;&lt; chi2n * (1+TMath::Min(1-param0[min][fNpar-3],0.25)) &lt;&lt; endl;
<span class="lineNum">     636 </span>            :     //if (chi2n*1.2+1.e-6 &gt; chi2o ) 
<span class="lineNum">     637 </span><span class="lineCov">        164 :     if (fNpar &gt; 2 &amp;&amp; (chi2n &gt; chi2o || ((iseed == nfit-1) </span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :                                         &amp;&amp; (chi2n * (1+TMath::Min(1-param0[min][fNpar-3],0.25)) &gt; chi2o)))) </span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :       { fNpar -= 3; break; }</span>
<span class="lineNum">     640 </span>            :       
<span class="lineNum">     641 </span>            :     // Save parameters and errors
<span class="lineNum">     642 </span>            :       
<span class="lineNum">     643 </span><span class="lineCov">        164 :     if (nInX == 1) {</span>
<span class="lineNum">     644 </span>            :       // One pad per direction 
<span class="lineNum">     645 </span>            :       //for (Int_t i=0; i&lt;fNpar; ++i) if (i == 0 || i == 2 || i == 5) param0[min][i] = xPad;
<span class="lineNum">     646 </span><span class="lineCov">         16 :       for (Int_t i=0; i&lt;fNpar; ++i) if (i == 0 || i == 2 || i == 5) </span>
<span class="lineNum">     647 </span><span class="lineCov">          2 :         param0[min][i] = xyCand[0][0];</span>
<span class="lineNum">     648 </span><span class="lineCov">          2 :     }</span>
<span class="lineNum">     649 </span><span class="lineCov">        164 :     if (nInY == 1) {</span>
<span class="lineNum">     650 </span>            :       // One pad per direction 
<span class="lineNum">     651 </span>            :       //for (Int_t i=0; i&lt;fNpar; ++i) if (i == 1 || i == 3 || i == 6) param0[min][i] = yPad;
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :       for (Int_t i=0; i&lt;fNpar; ++i) if (i == 1 || i == 3 || i == 6) </span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :         param0[min][i] = xyCand[0][1];</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     655 </span>            :       
<span class="lineNum">     656 </span>            :     /*
<span class="lineNum">     657 </span>            :       if (iseed &gt; 0) {
<span class="lineNum">     658 </span>            :       // Find distance to the nearest neighbour
<span class="lineNum">     659 </span>            :       dist[0] = dist[1] = TMath::Sqrt ((param0[min][0]-param0[min][2])*
<span class="lineNum">     660 </span>            :       (param0[min][0]-param0[min][2])
<span class="lineNum">     661 </span>            :       +(param0[min][1]-param0[min][3])*
<span class="lineNum">     662 </span>            :       (param0[min][1]-param0[min][3]));
<span class="lineNum">     663 </span>            :       if (iseed &gt; 1) {
<span class="lineNum">     664 </span>            :       dist[2] = TMath::Sqrt ((param0[min][0]-param0[min][5])*
<span class="lineNum">     665 </span>            :       (param0[min][0]-param0[min][5])
<span class="lineNum">     666 </span>            :       +(param0[min][1]-param0[min][6])*
<span class="lineNum">     667 </span>            :       (param0[min][1]-param0[min][6]));
<span class="lineNum">     668 </span>            :       rad = TMath::Sqrt ((param0[min][2]-param0[min][5])*
<span class="lineNum">     669 </span>            :       (param0[min][2]-param0[min][5])
<span class="lineNum">     670 </span>            :       +(param0[min][3]-param0[min][6])*
<span class="lineNum">     671 </span>            :       (param0[min][3]-param0[min][6]));
<span class="lineNum">     672 </span>            :       if (dist[2] &lt; dist[0]) dist[0] = dist[2];
<span class="lineNum">     673 </span>            :       if (rad &lt; dist[1]) dist[1] = rad;
<span class="lineNum">     674 </span>            :       if (rad &lt; dist[2]) dist[2] = rad;
<span class="lineNum">     675 </span>            :       }
<span class="lineNum">     676 </span>            :       cout &lt;&lt; dist[0] &lt;&lt; &quot; &quot; &lt;&lt; dist[1] &lt;&lt; &quot; &quot; &lt;&lt; dist[2] &lt;&lt; endl;
<span class="lineNum">     677 </span>            :       if (dist[TMath::LocMin(iseed+1,dist)] &lt; 1.) { fNpar -= 3; break; }
<span class="lineNum">     678 </span>            :       }
<span class="lineNum">     679 </span>            :     */
<span class="lineNum">     680 </span>            :       
<span class="lineNum">     681 </span><span class="lineCov">        984 :     for (Int_t i = 0; i &lt; fNpar; ++i) {</span>
<span class="lineNum">     682 </span><span class="lineCov">        328 :       parOk[i] = param0[min][i];</span>
<span class="lineNum">     683 </span>            :       //errOk[i] = fmin;
<span class="lineNum">     684 </span><span class="lineCov">        328 :       errOk[i] = chi2n;</span>
<span class="lineNum">     685 </span>            :       // Bounded params
<span class="lineNum">     686 </span><span class="lineCov">        328 :       parOk[i] = TMath::Max (parOk[i], parmin[i]);</span>
<span class="lineNum">     687 </span><span class="lineCov">        328 :       parOk[i] = TMath::Min (parOk[i], parmax[i]);</span>
<span class="lineNum">     688 </span>            :     }
<span class="lineNum">     689 </span>            :       
<span class="lineNum">     690 </span>            :     chi2o = chi2n;
<span class="lineNum">     691 </span><span class="lineCov">        318 :     if (fmin &lt; 0.1) break; // !!!???</span>
<span class="lineNum">     692 </span><span class="lineCov">        174 :   } // for (Int_t iseed=0; </span>
<span class="lineNum">     693 </span>            :    
<span class="lineNum">     694 </span><span class="lineCov">        164 :   if (fDebug) {</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :     for (Int_t i=0; i&lt;fNpar; ++i) {</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :       if (i == 4 || i == 7) {</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :         if ((i == 7) || ((i == 4) &amp;&amp; (fNpar &lt; 7))) cout &lt;&lt; parOk[i] &lt;&lt; endl;</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :         else cout &lt;&lt; parOk[i] * (1-parOk[7]) &lt;&lt; endl;</span>
<span class="lineNum">     699 </span>            :         continue;
<span class="lineNum">     700 </span>            :       }
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :       cout &lt;&lt; parOk[i] &lt;&lt; &quot; &quot; &lt;&lt; errOk[i] &lt;&lt; endl;</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     704 </span><span class="lineCov">        164 :   nfit = (fNpar + 1) / 3;</span>
<span class="lineNum">     705 </span><span class="lineCov">        164 :   dist[0] = dist[1] = dist[2] = 0;</span>
<span class="lineNum">     706 </span>            :   
<span class="lineNum">     707 </span><span class="lineCov">        164 :   if (nfit &gt; 1) {</span>
<span class="lineNum">     708 </span>            :     // Find distance to the nearest neighbour
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :     dist[0] = dist[1] = TMath::Sqrt ((parOk[0]-parOk[2])*</span>
<span class="lineNum">     710 </span>            :                                      (parOk[0]-parOk[2])
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :                                      +(parOk[1]-parOk[3])*</span>
<span class="lineNum">     712 </span>            :                                      (parOk[1]-parOk[3]));
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :     if (nfit &gt; 2) {</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :       dist[2] = TMath::Sqrt ((parOk[0]-parOk[5])*</span>
<span class="lineNum">     715 </span>            :                              (parOk[0]-parOk[5])
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :                              +(parOk[1]-parOk[6])*</span>
<span class="lineNum">     717 </span>            :                              (parOk[1]-parOk[6]));
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :       rad = TMath::Sqrt ((parOk[2]-parOk[5])*</span>
<span class="lineNum">     719 </span>            :                          (parOk[2]-parOk[5])
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :                          +(parOk[3]-parOk[6])*</span>
<span class="lineNum">     721 </span>            :                          (parOk[3]-parOk[6]));
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :       if (dist[2] &lt; dist[0]) dist[0] = dist[2];</span>
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :       if (rad &lt; dist[1]) dist[1] = rad;</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :       if (rad &lt; dist[2]) dist[2] = rad;</span>
<span class="lineNum">     725 </span>            :     }
<span class="lineNum">     726 </span>            :   }
<span class="lineNum">     727 </span>            :     
<span class="lineNum">     728 </span>            :   Int_t indx;
<span class="lineNum">     729 </span>            :   
<span class="lineNum">     730 </span>            :   Double_t coef = 0;
<span class="lineNum">     731 </span><span class="lineCov">        286 :   if (iSimple) fnCoupled = 0;</span>
<span class="lineNum">     732 </span><span class="lineCov">        820 :   for (Int_t j = 0; j &lt; nfit; ++j) {</span>
<span class="lineNum">     733 </span><span class="lineCov">        164 :     indx = 3 * j;</span>
<span class="lineNum">     734 </span><span class="lineCov">        164 :     coef = Param2Coef(j, coef, parOk);</span>
<span class="lineNum">     735 </span>            :       
<span class="lineNum">     736 </span>            :     //void AliMUONClusterFinderMLEM::AddRawCluster(Double_t x, Double_t y, 
<span class="lineNum">     737 </span>            :     //                                             Double_t qTot, Double_t fmin,
<span class="lineNum">     738 </span>            :     //                                             Int_t nfit, Int_t *tracks, 
<span class="lineNum">     739 </span>            :     //                                             Double_t /*sigx*/, 
<span class="lineNum">     740 </span>            :     //                                             Double_t /*sigy*/, 
<span class="lineNum">     741 </span>            :     //                                             Double_t /*dist*/)
<span class="lineNum">     742 </span>            :     
<span class="lineNum">     743 </span><span class="lineCov">        164 :     if ( coef*fQtot &gt;= fLowestClusterCharge ) </span>
<span class="lineNum">     744 </span>            :     {
<span class="lineNum">     745 </span>            :       //AZ AliMUONCluster* cluster1 = new AliMUONCluster();
<span class="lineNum">     746 </span><span class="lineCov">        164 :       AliMUONCluster* cluster1 = new AliMUONCluster(cluster);</span>
<span class="lineNum">     747 </span>            :       
<span class="lineNum">     748 </span><span class="lineCov">        164 :       cluster1-&gt;SetCharge(coef*fQtot,coef*fQtot);</span>
<span class="lineNum">     749 </span><span class="lineCov">        492 :       cluster1-&gt;SetPosition(TVector2(parOk[indx],parOk[indx+1]),TVector2(sigCand[0][0],sigCand[0][1]));</span>
<span class="lineNum">     750 </span>            :       //cluster1-&gt;SetChi2(dist[TMath::LocMin(nfit,dist)]);
<span class="lineNum">     751 </span><span class="lineCov">        164 :       Int_t idx = TMath::LocMin(nfit,dist);</span>
<span class="lineNum">     752 </span><span class="lineCov">        164 :       if ( idx &lt; 0 || idx &gt; 2 ) {</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :         AliErrorStream() &lt;&lt; &quot;Wrong index value: &quot; &lt;&lt; idx &lt;&lt; endl;</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :         return nfit;</span>
<span class="lineNum">     755 </span>            :       }  
<span class="lineNum">     756 </span><span class="lineCov">        164 :       cluster1-&gt;SetChi2(dist[idx]);</span>
<span class="lineNum">     757 </span>            :       
<span class="lineNum">     758 </span>            :       // FIXME: we miss some information in this cluster, as compared to 
<span class="lineNum">     759 </span>            :       // the original AddRawCluster code.
<span class="lineNum">     760 </span>            :       
<span class="lineNum">     761 </span><span class="lineCov">        492 :       AliDebug(2,Form(&quot;Adding RawCluster detElemId %4d mult %2d charge %5d (xl,yl)=(%9.6g,%9.6g)&quot;,</span>
<span class="lineNum">     762 </span>            :                       fDetElemId,cluster1-&gt;Multiplicity(),(Int_t)cluster1-&gt;Charge(),
<span class="lineNum">     763 </span>            :                       cluster1-&gt;Position().X(),cluster1-&gt;Position().Y()));
<span class="lineNum">     764 </span>            :         
<span class="lineNum">     765 </span><span class="lineCov">        164 :       clusterList.Add(cluster1);</span>
<span class="lineNum">     766 </span><span class="lineCov">        164 :     }</span>
<span class="lineNum">     767 </span>            :     //      AddRawCluster (parOk[indx], // double x
<span class="lineNum">     768 </span>            :     //                     parOk[indx+1], // double y
<span class="lineNum">     769 </span>            :     //                     coef*qTot, // double charge
<span class="lineNum">     770 </span>            :     //                     errOk[indx], // double fmin
<span class="lineNum">     771 </span>            :     //                     nfit0+10*nfit+100*nMax+10000*fnCoupled, // int nfit
<span class="lineNum">     772 </span>            :     //                     tracks, // int* tracks
<span class="lineNum">     773 </span>            :     //                     sigCand[0][0], // double sigx
<span class="lineNum">     774 </span>            :     //                     sigCand[0][1], // double sigy
<span class="lineNum">     775 </span>            :     //                     dist[TMath::LocMin(nfit,dist)] // double dist
<span class="lineNum">     776 </span>            :     //                     );
<span class="lineNum">     777 </span>            :   }
<span class="lineNum">     778 </span><span class="lineCov">        164 :   return nfit;</span>
<span class="lineNum">     779 </span><span class="lineCov">        492 : }  </span>
<span class="lineNum">     780 </span>            : 
<span class="lineNum">     781 </span>            : 
<a name="782"><span class="lineNum">     782 </span>            : //_____________________________________________________________________________</a>
<span class="lineNum">     783 </span>            : void
<span class="lineNum">     784 </span>            : AliMUONClusterSplitterMLEM::Split(const AliMUONCluster&amp; cluster,
<span class="lineNum">     785 </span>            :                                   TH2 *mlem, Double_t *coef,
<span class="lineNum">     786 </span>            :                                   TObjArray&amp; clusterList)
<span class="lineNum">     787 </span>            : {
<span class="lineNum">     788 </span>            :   /// The main steering function to work with clusters of pixels in anode
<span class="lineNum">     789 </span>            :   /// plane (find clusters, decouple them from each other, merge them (if
<span class="lineNum">     790 </span>            :   /// necessary), pick up coupled pads, call the fitting function)
<span class="lineNum">     791 </span>            :   
<span class="lineNum">     792 </span><span class="lineCov">         84 :   Int_t nx = mlem-&gt;GetNbinsX();</span>
<span class="lineNum">     793 </span><span class="lineCov">         42 :   Int_t ny = mlem-&gt;GetNbinsY();</span>
<span class="lineNum">     794 </span><span class="lineCov">         42 :   Int_t nPix = fPixArray-&gt;GetEntriesFast();</span>
<span class="lineNum">     795 </span>            :   
<span class="lineNum">     796 </span>            :   Double_t cont;
<span class="lineNum">     797 </span><span class="lineCov">         42 :   Int_t nclust = 0, indx, indx1, nxy = ny * nx; </span>
<span class="lineNum">     798 </span><span class="lineCov">         42 :   Bool_t *used = new Bool_t[nxy];</span>
<span class="lineNum">     799 </span>            :   
<span class="lineNum">     800 </span><span class="lineCov">       2266 :   for (Int_t j = 0; j &lt; nxy; ++j) used[j] = kFALSE; </span>
<span class="lineNum">     801 </span>            :   
<span class="lineNum">     802 </span><span class="lineCov">         42 :   TObjArray *clusters[200]={0};</span>
<span class="lineNum">     803 </span>            :   TObjArray *pix;
<span class="lineNum">     804 </span>            :   
<span class="lineNum">     805 </span>            :   // Find clusters of histogram bins (easier to work in 2-D space)
<span class="lineNum">     806 </span><span class="lineCov">        598 :   for (Int_t i = 1; i &lt;= ny; ++i) </span>
<span class="lineNum">     807 </span>            :   {
<span class="lineNum">     808 </span><span class="lineCov">       2696 :     for (Int_t j = 1; j &lt;= nx; ++j) </span>
<span class="lineNum">     809 </span>            :     {
<span class="lineNum">     810 </span><span class="lineCov">       1091 :       indx = (i-1)*nx + j - 1;</span>
<span class="lineNum">     811 </span><span class="lineCov">       1091 :       if (used[indx]) continue;</span>
<span class="lineNum">     812 </span><span class="lineCov">        477 :       cont = mlem-&gt;GetBinContent(mlem-&gt;GetBin(j,i));</span>
<span class="lineNum">     813 </span><span class="lineCov">        477 :       if (cont &lt; fLowestPixelCharge) continue;</span>
<span class="lineNum">     814 </span><span class="lineCov">         63 :       pix = new TObjArray(20);</span>
<span class="lineNum">     815 </span><span class="lineCov">         63 :       used[indx] = 1;</span>
<span class="lineNum">     816 </span><span class="lineCov">         63 :       pix-&gt;Add(BinToPix(mlem,j,i));</span>
<span class="lineNum">     817 </span><span class="lineCov">         63 :       AddBin(mlem, i, j, 0, used, pix); // recursive call</span>
<span class="lineNum">     818 </span><span class="lineCov">         63 :       if (nclust &gt;= 200) AliFatal(&quot; Too many clusters !!!&quot;);</span>
<span class="lineNum">     819 </span><span class="lineCov">         63 :       clusters[nclust++] = pix;</span>
<span class="lineNum">     820 </span><span class="lineCov">         63 :     } // for (Int_t j=1; j&lt;=nx; j++) {</span>
<span class="lineNum">     821 </span>            :   } // for (Int_t i=1; i&lt;=ny;
<span class="lineNum">     822 </span><span class="lineCov">         42 :   if (fDebug) cout &lt;&lt; nclust &lt;&lt; endl;</span>
<span class="lineNum">     823 </span><span class="lineCov">         84 :   delete [] used;</span>
<span class="lineNum">     824 </span>            :   
<span class="lineNum">     825 </span>            :   // Compute couplings between clusters and clusters to pads
<span class="lineNum">     826 </span><span class="lineCov">         42 :   Int_t npad = cluster.Multiplicity();</span>
<span class="lineNum">     827 </span>            :   
<span class="lineNum">     828 </span>            :   // Exclude pads with overflows
<span class="lineNum">     829 </span>            :   /*
<span class="lineNum">     830 </span>            :   for (Int_t j = 0; j &lt; npad; ++j) 
<span class="lineNum">     831 </span>            :   {
<span class="lineNum">     832 </span>            :     AliMUONPad* pad = cluster.Pad(j);
<span class="lineNum">     833 </span>            :     if ( pad-&gt;IsSaturated() )
<span class="lineNum">     834 </span>            :     {
<span class="lineNum">     835 </span>            :       pad-&gt;SetStatus(-5); 
<span class="lineNum">     836 </span>            :     }
<span class="lineNum">     837 </span>            :     else 
<span class="lineNum">     838 </span>            :     {
<span class="lineNum">     839 </span>            :       pad-&gt;SetStatus(0);
<span class="lineNum">     840 </span>            :     }
<span class="lineNum">     841 </span>            :   }
<span class="lineNum">     842 </span>            :   */
<span class="lineNum">     843 </span>            :   
<span class="lineNum">     844 </span>            :   // Compute couplings of clusters to pads (including overflows)
<span class="lineNum">     845 </span><span class="lineCov">         42 :   TMatrixD aijclupad(nclust,npad);</span>
<span class="lineNum">     846 </span><span class="lineCov">         42 :   aijclupad = 0;</span>
<span class="lineNum">     847 </span>            :   Int_t npxclu;
<span class="lineNum">     848 </span><span class="lineCov">        210 :   for (Int_t iclust = 0; iclust &lt; nclust; ++iclust) </span>
<span class="lineNum">     849 </span>            :   {
<span class="lineNum">     850 </span><span class="lineCov">         63 :     pix = clusters[iclust];</span>
<span class="lineNum">     851 </span><span class="lineCov">         63 :     npxclu = pix-&gt;GetEntriesFast();</span>
<span class="lineNum">     852 </span><span class="lineCov">        940 :     for (Int_t i = 0; i &lt; npxclu; ++i) </span>
<span class="lineNum">     853 </span>            :     {
<span class="lineNum">     854 </span><span class="lineCov">        407 :       indx = fPixArray-&gt;IndexOf(pix-&gt;UncheckedAt(i));</span>
<span class="lineNum">     855 </span><span class="lineCov">      10168 :       for (Int_t j = 0; j &lt; npad; ++j) </span>
<span class="lineNum">     856 </span>            :       {
<span class="lineNum">     857 </span>            :         //AliMUONPad* pad = cluster.Pad(j);
<span class="lineNum">     858 </span>            :         //if ( pad-&gt;Status() &lt; 0 &amp;&amp; pad-&gt;Status() != -5) continue;
<span class="lineNum">     859 </span><span class="lineCov">       4677 :         if (coef[j*nPix+indx] &lt; fgkCouplMin) continue;</span>
<span class="lineNum">     860 </span><span class="lineCov">       6854 :         aijclupad(iclust,j) += coef[j*nPix+indx];</span>
<span class="lineNum">     861 </span><span class="lineCov">       3427 :       }</span>
<span class="lineNum">     862 </span>            :     }
<span class="lineNum">     863 </span>            :   }
<span class="lineNum">     864 </span>            :   
<span class="lineNum">     865 </span>            :   // Compute couplings between clusters (exclude overflows)
<span class="lineNum">     866 </span><span class="lineCov">         42 :   TMatrixD aijcluclu(nclust,nclust);</span>
<span class="lineNum">     867 </span><span class="lineCov">         42 :   aijcluclu = 0;</span>
<span class="lineNum">     868 </span><span class="lineCov">        210 :   for (Int_t iclust = 0; iclust &lt; nclust; ++iclust) </span>
<span class="lineNum">     869 </span>            :   {
<span class="lineNum">     870 </span><span class="lineCov">       1444 :     for (Int_t j = 0; j &lt; npad; ++j) </span>
<span class="lineNum">     871 </span>            :     {
<span class="lineNum">     872 </span>            :       // Exclude overflows
<span class="lineNum">     873 </span>            :       //if ( cluster.Pad(j)-&gt;Status() &lt; 0) continue;
<span class="lineNum">     874 </span><span class="lineCov">       1318 :       if ( cluster.Pad(j)-&gt;IsSaturated()) continue;</span>
<span class="lineNum">     875 </span><span class="lineCov">       1318 :       if (aijclupad(iclust,j) &lt; fgkCouplMin) continue;</span>
<span class="lineNum">     876 </span><span class="lineCov">       1600 :       for (Int_t iclust1=iclust+1; iclust1&lt;nclust; iclust1++) </span>
<span class="lineNum">     877 </span>            :       {
<span class="lineNum">     878 </span><span class="lineCov">        420 :         if (aijclupad(iclust1,j) &lt; fgkCouplMin) continue;</span>
<span class="lineNum">     879 </span><span class="lineCov">        356 :         aijcluclu(iclust,iclust1) += </span>
<span class="lineNum">     880 </span><span class="lineCov">        534 :           TMath::Sqrt (aijclupad(iclust,j)*aijclupad(iclust1,j));</span>
<span class="lineNum">     881 </span><span class="lineCov">        178 :       }</span>
<span class="lineNum">     882 </span><span class="lineCov">        590 :     }</span>
<span class="lineNum">     883 </span>            :   }
<span class="lineNum">     884 </span><span class="lineCov">        210 :   for (Int_t iclust = 0; iclust &lt; nclust; ++iclust) </span>
<span class="lineNum">     885 </span>            :   {
<span class="lineNum">     886 </span><span class="lineCov">        184 :     for (Int_t iclust1 = iclust+1; iclust1 &lt; nclust; ++iclust1) </span>
<span class="lineNum">     887 </span>            :     {
<span class="lineNum">     888 </span><span class="lineCov">         87 :       aijcluclu(iclust1,iclust) = aijcluclu(iclust,iclust1);</span>
<span class="lineNum">     889 </span>            :     }
<span class="lineNum">     890 </span>            :   }
<span class="lineNum">     891 </span>            :   
<span class="lineNum">     892 </span><span class="lineCov">         42 :   if (fDebug &amp;&amp; nclust &gt; 1) aijcluclu.Print();</span>
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span>            :   // Find groups of coupled clusters
<span class="lineNum">     895 </span><span class="lineCov">         42 :   used = new Bool_t[nclust];</span>
<span class="lineNum">     896 </span><span class="lineCov">        210 :   for (Int_t j = 0; j &lt; nclust; ++j) used[j] = kFALSE;</span>
<span class="lineNum">     897 </span>            : 
<span class="lineNum">     898 </span><span class="lineCov">         84 :   Int_t *clustNumb = new Int_t[nclust];</span>
<span class="lineNum">     899 </span><span class="lineCov">         42 :   Int_t nCoupled, nForFit, minGroup[3], clustFit[3], nfit = 0;</span>
<span class="lineNum">     900 </span>            :   //Double_t parOk[8];
<span class="lineNum">     901 </span><span class="lineCov">         42 :   Double_t parOk[8] = {0}; //AZ</span>
<span class="lineNum">     902 </span>            :   
<span class="lineNum">     903 </span><span class="lineCov">        210 :   for (Int_t igroup = 0; igroup &lt; nclust; ++igroup) </span>
<span class="lineNum">     904 </span>            :   {
<span class="lineNum">     905 </span><span class="lineCov">         63 :     if (used[igroup]) continue;</span>
<span class="lineNum">     906 </span><span class="lineCov">         42 :     used[igroup] = kTRUE;</span>
<span class="lineNum">     907 </span><span class="lineCov">         42 :     clustNumb[0] = igroup;</span>
<span class="lineNum">     908 </span><span class="lineCov">         42 :     nCoupled = 1;</span>
<span class="lineNum">     909 </span>            :     // Find group of coupled clusters
<span class="lineNum">     910 </span><span class="lineCov">         42 :     AddCluster(igroup, nclust, aijcluclu, used, clustNumb, nCoupled); // recursive</span>
<span class="lineNum">     911 </span>            :     
<span class="lineNum">     912 </span><span class="lineCov">         42 :     if (fDebug) {                                                                      </span>
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :       cout &lt;&lt; &quot; nCoupled: &quot; &lt;&lt; nCoupled &lt;&lt; endl;</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :       for (Int_t i=0; i&lt;nCoupled; ++i) cout &lt;&lt; clustNumb[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;</span>
<span class="lineNum">     915 </span>            :     }
<span class="lineNum">     916 </span>            :     
<span class="lineNum">     917 </span><span class="lineCov">         42 :     fnCoupled = nCoupled;</span>
<span class="lineNum">     918 </span>            :     
<span class="lineNum">     919 </span><span class="lineCov">        172 :     while (nCoupled &gt; 0) </span>
<span class="lineNum">     920 </span>            :     {
<span class="lineNum">     921 </span><span class="lineCov">         44 :       if (nCoupled &lt; 4) </span>
<span class="lineNum">     922 </span>            :       {
<span class="lineNum">     923 </span>            :         nForFit = nCoupled;
<span class="lineNum">     924 </span><span class="lineCov">        206 :         for (Int_t i = 0; i &lt; nCoupled; ++i) clustFit[i] = clustNumb[i];</span>
<span class="lineNum">     925 </span><span class="lineCov">         42 :       } </span>
<span class="lineNum">     926 </span>            :       else 
<span class="lineNum">     927 </span>            :       {
<span class="lineNum">     928 </span>            :         // Too many coupled clusters to fit - try to decouple them
<span class="lineNum">     929 </span>            :         // Find the lowest coupling of 1, 2, min(3,nLinks/2) pixels with 
<span class="lineNum">     930 </span>            :         // all the others in the group 
<span class="lineNum">     931 </span><span class="lineCov">         16 :         for (Int_t j = 0; j &lt; 3; ++j) minGroup[j] = -1;</span>
<span class="lineNum">     932 </span><span class="lineCov">          2 :         Double_t coupl = MinGroupCoupl(nCoupled, clustNumb, aijcluclu, minGroup);</span>
<span class="lineNum">     933 </span>            :         
<span class="lineNum">     934 </span>            :         // Flag clusters for fit
<span class="lineNum">     935 </span>            :         nForFit = 0;
<span class="lineNum">     936 </span><span class="lineCov">         16 :         while (nForFit &lt; 3 &amp;&amp; minGroup[nForFit] &gt;= 0)</span>
<span class="lineNum">     937 </span>            :         {
<span class="lineNum">     938 </span><span class="lineCov">          6 :           if (fDebug) cout &lt;&lt; clustNumb[minGroup[nForFit]] &lt;&lt; &quot; &quot;;</span>
<span class="lineNum">     939 </span><span class="lineCov">          2 :           clustFit[nForFit] = clustNumb[minGroup[nForFit]];</span>
<span class="lineNum">     940 </span><span class="lineCov">          2 :           clustNumb[minGroup[nForFit]] -= 999;</span>
<span class="lineNum">     941 </span><span class="lineCov">          2 :           nForFit++;</span>
<span class="lineNum">     942 </span>            :         }
<span class="lineNum">     943 </span><span class="lineCov">          2 :         if (fDebug) cout &lt;&lt; &quot; nForFit &quot; &lt;&lt; nForFit &lt;&lt; &quot; &quot; &lt;&lt; coupl &lt;&lt; endl;</span>
<span class="lineNum">     944 </span>            :       } // else
<span class="lineNum">     945 </span>            :       
<span class="lineNum">     946 </span>            :       // Select pads for fit. 
<span class="lineNum">     947 </span><span class="lineCov">         88 :       if (SelectPad(cluster,nCoupled, nForFit, clustNumb, clustFit, aijclupad) &lt; 3 &amp;&amp; nCoupled &gt; 1) </span>
<span class="lineNum">     948 </span>            :       {
<span class="lineNum">     949 </span>            :         // Deselect pads
<span class="lineNum">     950 </span><span class="lineCov">         40 :         for (Int_t j = 0; j &lt; npad; ++j)</span>
<span class="lineNum">     951 </span>            :         {
<span class="lineNum">     952 </span><span class="lineCov">         18 :           AliMUONPad* pad = cluster.Pad(j);</span>
<span class="lineNum">     953 </span>            :           //if ( pad-&gt;Status()==1 ) pad-&gt;SetStatus(0);
<span class="lineNum">     954 </span>            :           //if ( pad-&gt;Status()==-9) pad-&gt;SetStatus(-5);
<span class="lineNum">     955 </span><span class="lineCov">         36 :           if ( pad-&gt;Status() == AliMUONClusterFinderMLEM::GetUseForFitFlag() ||</span>
<span class="lineNum">     956 </span><span class="lineCov">         18 :                pad-&gt;Status() == AliMUONClusterFinderMLEM::GetCoupledFlag()) </span>
<span class="lineNum">     957 </span><span class="lineCov">         10 :             pad-&gt;SetStatus(AliMUONClusterFinderMLEM::GetZeroFlag());</span>
<span class="lineNum">     958 </span>            :         }
<span class="lineNum">     959 </span>            :         // Merge the failed cluster candidates (with too few pads to fit) with 
<span class="lineNum">     960 </span>            :         // the one with the strongest coupling
<span class="lineNum">     961 </span><span class="lineCov">          2 :         Merge(cluster,nForFit, nCoupled, clustNumb, clustFit, clusters, aijcluclu, aijclupad);</span>
<span class="lineNum">     962 </span>            :       } 
<span class="lineNum">     963 </span>            :       else 
<span class="lineNum">     964 </span>            :       {
<span class="lineNum">     965 </span>            :         // Do the fit
<span class="lineNum">     966 </span><span class="lineCov">         42 :         nfit = Fit(cluster,0, nForFit, clustFit, clusters, parOk, clusterList, mlem);</span>
<span class="lineNum">     967 </span><span class="lineCov">         42 :         if (nfit == 0) { </span>
<span class="lineNum">     968 </span>            :           //cout &lt;&lt; &quot; (nfit == 0) &quot; &lt;&lt; fNpar &lt;&lt; &quot; &quot; &lt;&lt; cluster.Multiplicity() &lt;&lt; endl; 
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :           fNpar = 0; // should be 0 by itself but just in case ...</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     971 </span>            :       }
<span class="lineNum">     972 </span>            :       
<span class="lineNum">     973 </span>            :       // Subtract the fitted charges from pads with strong coupling and/or
<span class="lineNum">     974 </span>            :       // return pads for further use
<span class="lineNum">     975 </span><span class="lineCov">         44 :       UpdatePads(cluster,nfit, parOk);</span>
<span class="lineNum">     976 </span>            :       
<span class="lineNum">     977 </span>            :       // Mark used pads
<span class="lineNum">     978 </span><span class="lineCov">       1028 :       for (Int_t j = 0; j &lt; npad; ++j) </span>
<span class="lineNum">     979 </span>            :       {
<span class="lineNum">     980 </span><span class="lineCov">        470 :         AliMUONPad* pad = cluster.Pad(j);</span>
<span class="lineNum">     981 </span>            :         //if ( pad-&gt;Status()==1 ) pad-&gt;SetStatus(-2);
<span class="lineNum">     982 </span>            :         //if ( pad-&gt;Status()==-9) pad-&gt;SetStatus(-5);
<span class="lineNum">     983 </span><span class="lineCov">        470 :         if ( pad-&gt;Status() == AliMUONClusterFinderMLEM::GetUseForFitFlag() ) </span>
<span class="lineNum">     984 </span><span class="lineCov">        444 :           pad-&gt;SetStatus(AliMUONClusterFinderMLEM::GetModifiedFlag());</span>
<span class="lineNum">     985 </span>            :       }
<span class="lineNum">     986 </span>            :       
<span class="lineNum">     987 </span>            :       // Sort the clusters (move to the right the used ones)
<span class="lineNum">     988 </span><span class="lineCov">         44 :       Int_t beg = 0, end = nCoupled - 1;</span>
<span class="lineNum">     989 </span><span class="lineCov">        113 :       while (beg &lt; end) </span>
<span class="lineNum">     990 </span>            :       {
<span class="lineNum">     991 </span><span class="lineCov">         50 :         if (clustNumb[beg] &gt;= 0) { ++beg; continue; }</span>
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :         for (Int_t j = end; j &gt; beg; --j) </span>
<span class="lineNum">     993 </span>            :         {
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :           if (clustNumb[j] &lt; 0) continue;</span>
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :           end = j - 1;</span>
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :           indx = clustNumb[beg];</span>
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :           clustNumb[beg] = clustNumb[j];</span>
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :           clustNumb[j] = indx;</span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1000 </span>            :         }
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :         ++beg;</span>
<span class="lineNum">    1002 </span>            :       }
<span class="lineNum">    1003 </span>            :       
<span class="lineNum">    1004 </span><span class="lineCov">         44 :       nCoupled -= nForFit;</span>
<span class="lineNum">    1005 </span><span class="lineCov">         44 :       if (nCoupled &gt; 3) </span>
<span class="lineNum">    1006 </span>            :       {
<span class="lineNum">    1007 </span>            :         // Remove couplings of used clusters
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :         for (Int_t iclust = nCoupled; iclust &lt; nCoupled+nForFit; ++iclust) </span>
<span class="lineNum">    1009 </span>            :         {
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :           indx = clustNumb[iclust] + 999;</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :           for (Int_t iclust1 = 0; iclust1 &lt; nCoupled; ++iclust1) </span>
<span class="lineNum">    1012 </span>            :           {
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :             indx1 = clustNumb[iclust1];</span>
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :             aijcluclu(indx,indx1) = aijcluclu(indx1,indx) = 0;</span>
<span class="lineNum">    1015 </span>            :           }
<span class="lineNum">    1016 </span>            :         }
<span class="lineNum">    1017 </span>            :         
<span class="lineNum">    1018 </span>            :         // Update the remaining clusters couplings (subtract couplings from 
<span class="lineNum">    1019 </span>            :         // the used pads) - overflows excluded
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :         for (Int_t j = 0; j &lt; npad; ++j) </span>
<span class="lineNum">    1021 </span>            :         {
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :           AliMUONPad* pad = cluster.Pad(j);</span>
<span class="lineNum">    1023 </span>            :           //if ( pad-&gt;Status() != -2) continue;
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :           if ( pad-&gt;Status() != AliMUONClusterFinderMLEM::GetModifiedFlag()) continue;</span>
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :           for (Int_t iclust=0; iclust&lt;nCoupled; ++iclust) </span>
<span class="lineNum">    1026 </span>            :           {
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :             indx = clustNumb[iclust];</span>
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :             if (aijclupad(indx,j) &lt; fgkCouplMin) continue;</span>
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :             for (Int_t iclust1 = iclust+1; iclust1 &lt; nCoupled; ++iclust1) </span>
<span class="lineNum">    1030 </span>            :             {
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :               indx1 = clustNumb[iclust1];</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :               if (aijclupad(indx1,j) &lt; fgkCouplMin) continue;</span>
<span class="lineNum">    1033 </span>            :               // Check this
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :               aijcluclu(indx,indx1) -= </span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :                 TMath::Sqrt (aijclupad(indx,j)*aijclupad(indx1,j));</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :               aijcluclu(indx1,indx) = aijcluclu(indx,indx1);</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    1039 </span>            :           //pad-&gt;SetStatus(-8);
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :           pad-&gt;SetStatus(AliMUONClusterFinderMLEM::GetOverFlag());</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :         } // for (Int_t j=0; j&lt;npad;</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :       } // if (nCoupled &gt; 3)</span>
<span class="lineNum">    1043 </span>            :     } // while (nCoupled &gt; 0)
<span class="lineNum">    1044 </span>            :   } // for (Int_t igroup=0; igroup&lt;nclust;
<span class="lineNum">    1045 </span>            :   
<span class="lineNum">    1046 </span><span class="lineCov">        210 :   for (Int_t iclust = 0; iclust &lt; nclust; ++iclust)</span>
<span class="lineNum">    1047 </span>            :   {
<span class="lineNum">    1048 </span><span class="lineCov">         63 :     pix = clusters[iclust]; </span>
<span class="lineNum">    1049 </span><span class="lineCov">         63 :     pix-&gt;Clear();</span>
<span class="lineNum">    1050 </span><span class="lineCov">        126 :     delete pix; </span>
<span class="lineNum">    1051 </span>            :   }
<span class="lineNum">    1052 </span><span class="lineCov">         84 :   delete [] clustNumb; </span>
<span class="lineNum">    1053 </span><span class="lineCov">         84 :   delete [] used; </span>
<span class="lineNum">    1054 </span>            : 
<span class="lineNum">    1055 </span><span class="lineCov">         42 : }</span>
<span class="lineNum">    1056 </span>            : 
<a name="1057"><span class="lineNum">    1057 </span>            : //_____________________________________________________________________________</a>
<span class="lineNum">    1058 </span>            : void 
<span class="lineNum">    1059 </span>            : AliMUONClusterSplitterMLEM::Merge(const AliMUONCluster&amp; cluster,
<span class="lineNum">    1060 </span>            :                                      Int_t nForFit, Int_t nCoupled, 
<span class="lineNum">    1061 </span>            :                                      const Int_t *clustNumb, const Int_t *clustFit, 
<span class="lineNum">    1062 </span>            :                                      TObjArray **clusters, 
<span class="lineNum">    1063 </span>            :                                      TMatrixD&amp; aijcluclu, TMatrixD&amp; aijclupad)
<span class="lineNum">    1064 </span>            : {
<span class="lineNum">    1065 </span>            :   /// Merge the group of clusters with the one having the strongest coupling with them
<span class="lineNum">    1066 </span>            :   
<span class="lineNum">    1067 </span>            :   Int_t indx, indx1, npxclu, imax=0;
<span class="lineNum">    1068 </span>            :   TObjArray *pix, *pix1;
<span class="lineNum">    1069 </span>            :   Double_t couplMax;
<span class="lineNum">    1070 </span>            :   
<span class="lineNum">    1071 </span><span class="lineCov">         10 :   for (Int_t icl = 0; icl &lt; nForFit; ++icl) </span>
<span class="lineNum">    1072 </span>            :   {
<span class="lineNum">    1073 </span><span class="lineCov">          2 :     indx = clustFit[icl];</span>
<span class="lineNum">    1074 </span><span class="lineCov">          2 :     pix = clusters[indx];</span>
<span class="lineNum">    1075 </span><span class="lineCov">          2 :     npxclu = pix-&gt;GetEntriesFast();</span>
<span class="lineNum">    1076 </span>            :     couplMax = -1;
<span class="lineNum">    1077 </span><span class="lineCov">         20 :     for (Int_t icl1 = 0; icl1 &lt; nCoupled; ++icl1) </span>
<span class="lineNum">    1078 </span>            :     {
<span class="lineNum">    1079 </span><span class="lineCov">          8 :       indx1 = clustNumb[icl1];</span>
<span class="lineNum">    1080 </span><span class="lineCov">          8 :       if (indx1 &lt; 0) continue;</span>
<span class="lineNum">    1081 </span><span class="lineCov">          6 :       if ( aijcluclu(indx,indx1) &gt; couplMax) </span>
<span class="lineNum">    1082 </span>            :       {
<span class="lineNum">    1083 </span><span class="lineCov">          6 :         couplMax = aijcluclu(indx,indx1);</span>
<span class="lineNum">    1084 </span>            :         imax = indx1;
<span class="lineNum">    1085 </span><span class="lineCov">          6 :       }</span>
<span class="lineNum">    1086 </span>            :     } // for (Int_t icl1=0;
<span class="lineNum">    1087 </span>            :       // Add to it
<span class="lineNum">    1088 </span><span class="lineCov">          2 :     pix1 = clusters[imax];</span>
<span class="lineNum">    1089 </span>            :     // Add pixels
<span class="lineNum">    1090 </span><span class="lineCov">          8 :     for (Int_t i = 0; i &lt; npxclu; ++i) </span>
<span class="lineNum">    1091 </span>            :     { 
<span class="lineNum">    1092 </span><span class="lineCov">          2 :       pix1-&gt;Add(pix-&gt;UncheckedAt(i)); </span>
<span class="lineNum">    1093 </span><span class="lineCov">          2 :       pix-&gt;RemoveAt(i); </span>
<span class="lineNum">    1094 </span>            :     }
<span class="lineNum">    1095 </span>            :     
<span class="lineNum">    1096 </span>            :     //Add cluster-to-cluster couplings
<span class="lineNum">    1097 </span><span class="lineCov">         20 :     for (Int_t icl1 = 0; icl1 &lt; nCoupled; ++icl1) </span>
<span class="lineNum">    1098 </span>            :     {
<span class="lineNum">    1099 </span><span class="lineCov">          8 :       indx1 = clustNumb[icl1];</span>
<span class="lineNum">    1100 </span><span class="lineCov">         14 :       if (indx1 &lt; 0 || indx1 == imax) continue;</span>
<span class="lineNum">    1101 </span><span class="lineCov">          4 :       aijcluclu(indx1,imax) += aijcluclu(indx,indx1);</span>
<span class="lineNum">    1102 </span><span class="lineCov">          4 :       aijcluclu(imax,indx1) = aijcluclu(indx1,imax);</span>
<span class="lineNum">    1103 </span><span class="lineCov">          4 :     }</span>
<span class="lineNum">    1104 </span><span class="lineCov">          2 :     aijcluclu(indx,imax) = aijcluclu(imax,indx) = 0;</span>
<span class="lineNum">    1105 </span>            :     
<span class="lineNum">    1106 </span>            :     //Add cluster-to-pad couplings
<span class="lineNum">    1107 </span><span class="lineCov">          2 :     Int_t mult = cluster.Multiplicity();</span>
<span class="lineNum">    1108 </span><span class="lineCov">         40 :     for (Int_t j = 0; j &lt; mult; ++j) </span>
<span class="lineNum">    1109 </span>            :     {
<span class="lineNum">    1110 </span><span class="lineCov">         18 :       AliMUONPad* pad = cluster.Pad(j);</span>
<span class="lineNum">    1111 </span>            :       //if ( pad-&gt;Status() &lt; 0 &amp;&amp; pad-&gt;Status() != -5 ) continue;// exclude used pads
<span class="lineNum">    1112 </span><span class="lineCov">         18 :       if ( pad-&gt;Status() != AliMUONClusterFinderMLEM::GetZeroFlag()) continue;// exclude used pads</span>
<span class="lineNum">    1113 </span><span class="lineCov">         18 :         aijclupad(imax,j) += aijclupad(indx,j);</span>
<span class="lineNum">    1114 </span><span class="lineCov">         18 :         aijclupad(indx,j) = 0;</span>
<span class="lineNum">    1115 </span><span class="lineCov">         18 :     }</span>
<span class="lineNum">    1116 </span>            :   } // for (Int_t icl=0; icl&lt;nForFit;
<span class="lineNum">    1117 </span><span class="lineCov">          2 : }</span>
<span class="lineNum">    1118 </span>            : 
<span class="lineNum">    1119 </span>            : 
<a name="1120"><span class="lineNum">    1120 </span>            : //_____________________________________________________________________________</a>
<span class="lineNum">    1121 </span>            : Double_t 
<span class="lineNum">    1122 </span>            : AliMUONClusterSplitterMLEM::MinGroupCoupl(Int_t nCoupled, const Int_t *clustNumb, 
<span class="lineNum">    1123 </span>            :                                           const TMatrixD&amp; aijcluclu, Int_t *minGroup)
<span class="lineNum">    1124 </span>            : {
<span class="lineNum">    1125 </span>            :   /// Find group of clusters with minimum coupling to all the others
<span class="lineNum">    1126 </span>            :   
<span class="lineNum">    1127 </span><span class="lineCov">          4 :   Int_t i123max = TMath::Min(3,nCoupled/2); </span>
<span class="lineNum">    1128 </span>            :   Int_t indx, indx1, indx2, indx3, nTot = 0;
<span class="lineNum">    1129 </span>            :   Double_t *coupl1 = 0, *coupl2 = 0, *coupl3 = 0;
<span class="lineNum">    1130 </span>            :   
<span class="lineNum">    1131 </span><span class="lineCov">         12 :   for (Int_t i123 = 1; i123 &lt;= i123max; ++i123) {</span>
<span class="lineNum">    1132 </span>            :     
<span class="lineNum">    1133 </span><span class="lineCov">          4 :     if (i123 == 1) {</span>
<span class="lineNum">    1134 </span><span class="lineCov">          2 :       coupl1 = new Double_t [nCoupled];</span>
<span class="lineNum">    1135 </span><span class="lineCov">         20 :       for (Int_t i = 0; i &lt; nCoupled; ++i) coupl1[i] = 0;</span>
<span class="lineNum">    1136 </span><span class="lineCov">          2 :     }</span>
<span class="lineNum">    1137 </span><span class="lineCov">          2 :     else if (i123 == 2) {</span>
<span class="lineNum">    1138 </span><span class="lineCov">          2 :       nTot = nCoupled*nCoupled;</span>
<span class="lineNum">    1139 </span><span class="lineCov">          2 :       coupl2 = new Double_t [nTot];</span>
<span class="lineNum">    1140 </span><span class="lineCov">         68 :       for (Int_t i = 0; i &lt; nTot; ++i) coupl2[i] = 9999;</span>
<span class="lineNum">    1141 </span><span class="lineCov">          2 :     } else {</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :       nTot = nTot*nCoupled;</span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :       coupl3 = new Double_t [nTot];</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :       for (Int_t i = 0; i &lt; nTot; ++i) coupl3[i] = 9999;</span>
<span class="lineNum">    1145 </span>            :     } // else
<span class="lineNum">    1146 </span>            :     
<span class="lineNum">    1147 </span><span class="lineCov">         40 :     for (Int_t i = 0; i &lt; nCoupled; ++i) {</span>
<span class="lineNum">    1148 </span><span class="lineCov">         16 :       indx1 = clustNumb[i];</span>
<span class="lineNum">    1149 </span><span class="lineCov">         80 :       for (Int_t j = i+1; j &lt; nCoupled; ++j) {</span>
<span class="lineNum">    1150 </span><span class="lineCov">         24 :         indx2 = clustNumb[j];</span>
<span class="lineNum">    1151 </span><span class="lineCov">         24 :         if (i123 == 1) {</span>
<span class="lineNum">    1152 </span><span class="lineCov">         12 :           coupl1[i] += aijcluclu(indx1,indx2);</span>
<span class="lineNum">    1153 </span><span class="lineCov">         12 :           coupl1[j] += aijcluclu(indx1,indx2);</span>
<span class="lineNum">    1154 </span><span class="lineCov">         12 :         } </span>
<span class="lineNum">    1155 </span><span class="lineCov">         12 :         else if (i123 == 2) {</span>
<span class="lineNum">    1156 </span><span class="lineCov">         12 :           indx = i*nCoupled + j;</span>
<span class="lineNum">    1157 </span><span class="lineCov">         12 :           coupl2[indx] = coupl1[i] + coupl1[j];</span>
<span class="lineNum">    1158 </span><span class="lineCov">         12 :           coupl2[indx] -= 2 * (aijcluclu(indx1,indx2));</span>
<span class="lineNum">    1159 </span><span class="lineCov">         12 :         } else {</span>
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :           for (Int_t k = j+1; k &lt; nCoupled; ++k) {</span>
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :             indx3 = clustNumb[k];</span>
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :             indx = i*nCoupled*nCoupled + j*nCoupled + k;</span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :             coupl3[indx] = coupl2[i*nCoupled+j] + coupl1[k];</span>
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :             coupl3[indx] -= 2 * (aijcluclu(indx1,indx3)+aijcluclu(indx2,indx3));</span>
<span class="lineNum">    1165 </span>            :           }
<span class="lineNum">    1166 </span>            :         } // else
<span class="lineNum">    1167 </span>            :       } // for (Int_t j=i+1;
<span class="lineNum">    1168 </span>            :     } // for (Int_t i=0;
<span class="lineNum">    1169 </span>            :   } // for (Int_t i123=1;
<span class="lineNum">    1170 </span>            :   
<span class="lineNum">    1171 </span>            :   // Find minimum coupling
<span class="lineNum">    1172 </span>            :   Double_t couplMin = 9999;
<span class="lineNum">    1173 </span>            :   Int_t locMin = 0;
<span class="lineNum">    1174 </span>            :   
<span class="lineNum">    1175 </span><span class="lineCov">         12 :   for (Int_t i123 = 1; i123 &lt;= i123max; ++i123) {</span>
<span class="lineNum">    1176 </span><span class="lineCov">          4 :     if (i123 == 1) {</span>
<span class="lineNum">    1177 </span><span class="lineCov">          2 :       locMin = TMath::LocMin(nCoupled, coupl1);</span>
<span class="lineNum">    1178 </span><span class="lineCov">          2 :       couplMin = coupl1[locMin];</span>
<span class="lineNum">    1179 </span><span class="lineCov">          2 :       minGroup[0] = locMin;</span>
<span class="lineNum">    1180 </span><span class="lineCov">          4 :       delete [] coupl1;</span>
<span class="lineNum">    1181 </span>            :     } 
<span class="lineNum">    1182 </span><span class="lineCov">          2 :     else if (i123 == 2) {</span>
<span class="lineNum">    1183 </span><span class="lineCov">          2 :       locMin = TMath::LocMin(nCoupled*nCoupled, coupl2);</span>
<span class="lineNum">    1184 </span><span class="lineCov">          2 :       if (coupl2[locMin] &lt; couplMin) {</span>
<span class="lineNum">    1185 </span>            :         couplMin = coupl2[locMin];
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :         minGroup[0] = locMin/nCoupled;</span>
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :         minGroup[1] = locMin%nCoupled;</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1189 </span><span class="lineCov">          4 :       delete [] coupl2;</span>
<span class="lineNum">    1190 </span>            :     } else {
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :       locMin = TMath::LocMin(nTot, coupl3);</span>
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :       if (coupl3[locMin] &lt; couplMin) {</span>
<span class="lineNum">    1193 </span>            :         couplMin = coupl3[locMin];
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :         minGroup[0] = locMin/nCoupled/nCoupled;</span>
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :         minGroup[1] = locMin%(nCoupled*nCoupled)/nCoupled;</span>
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :         minGroup[2] = locMin%nCoupled;</span>
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :       delete [] coupl3; </span>
<span class="lineNum">    1199 </span>            :     } // else
<span class="lineNum">    1200 </span>            :   } // for (Int_t i123=1;
<span class="lineNum">    1201 </span><span class="lineCov">          2 :   return couplMin;</span>
<span class="lineNum">    1202 </span>            : }
<span class="lineNum">    1203 </span>            : 
<a name="1204"><span class="lineNum">    1204 </span>            : //_____________________________________________________________________________</a>
<span class="lineNum">    1205 </span>            : Int_t 
<span class="lineNum">    1206 </span>            : AliMUONClusterSplitterMLEM::SelectPad(const AliMUONCluster&amp; cluster,
<span class="lineNum">    1207 </span>            :                                           Int_t nCoupled, Int_t nForFit, 
<span class="lineNum">    1208 </span>            :                                           const Int_t *clustNumb, const Int_t *clustFit, 
<span class="lineNum">    1209 </span>            :                                           const TMatrixD&amp; aijclupad)
<span class="lineNum">    1210 </span>            : {
<span class="lineNum">    1211 </span>            :   /// Select pads for fit. If too many coupled clusters, find pads giving 
<span class="lineNum">    1212 </span>            :   /// the strongest coupling with the rest of clusters and exclude them from the fit.
<span class="lineNum">    1213 </span>            :   
<span class="lineNum">    1214 </span><span class="lineCov">         88 :   Int_t npad = cluster.Multiplicity();</span>
<span class="lineNum">    1215 </span>            :   Double_t *padpix = 0;
<span class="lineNum">    1216 </span>            :   
<span class="lineNum">    1217 </span><span class="lineCov">         44 :   if (nCoupled &gt; 3) </span>
<span class="lineNum">    1218 </span>            :   {
<span class="lineNum">    1219 </span><span class="lineCov">          2 :     padpix = new Double_t[npad];</span>
<span class="lineNum">    1220 </span><span class="lineCov">         40 :     for (Int_t i = 0; i &lt; npad; ++i) padpix[i] = 0.;</span>
<span class="lineNum">    1221 </span><span class="lineCov">          2 :   }</span>
<span class="lineNum">    1222 </span>            :   
<span class="lineNum">    1223 </span>            :   Int_t nOK = 0, indx, indx1;
<span class="lineNum">    1224 </span><span class="lineCov">        214 :   for (Int_t iclust = 0; iclust &lt; nForFit; ++iclust)</span>
<span class="lineNum">    1225 </span>            :   {
<span class="lineNum">    1226 </span><span class="lineCov">         63 :     indx = clustFit[iclust];</span>
<span class="lineNum">    1227 </span><span class="lineCov">       1444 :     for (Int_t j = 0; j &lt; npad; ++j) </span>
<span class="lineNum">    1228 </span>            :     {
<span class="lineNum">    1229 </span><span class="lineCov">        659 :       if ( aijclupad(indx,j) &lt; fgkCouplMin) continue;</span>
<span class="lineNum">    1230 </span><span class="lineCov">        590 :       AliMUONPad* pad = cluster.Pad(j);</span>
<span class="lineNum">    1231 </span>            :       /*
<span class="lineNum">    1232 </span>            :       if ( pad-&gt;Status() == -5 ) pad-&gt;SetStatus(-9); // flag overflow
<span class="lineNum">    1233 </span>            :       if ( pad-&gt;Status() &lt; 0 ) continue; // exclude overflows and used pads
<span class="lineNum">    1234 </span>            :       if ( !pad-&gt;Status() ) 
<span class="lineNum">    1235 </span>            :       {
<span class="lineNum">    1236 </span>            :         pad-&gt;SetStatus(1);
<span class="lineNum">    1237 </span>            :         ++nOK; // pad to be used in fit
<span class="lineNum">    1238 </span>            :       }      
<span class="lineNum">    1239 </span>            :       */
<span class="lineNum">    1240 </span><span class="lineCov">       1044 :       if ( pad-&gt;Status() != AliMUONClusterFinderMLEM::GetZeroFlag() </span>
<span class="lineNum">    1241 </span><span class="lineCov">       1180 :            || pad-&gt;IsSaturated() ) continue; // used pads and overflows</span>
<span class="lineNum">    1242 </span><span class="lineCov">        454 :       pad-&gt;SetStatus(AliMUONClusterFinderMLEM::GetUseForFitFlag());</span>
<span class="lineNum">    1243 </span><span class="lineCov">        454 :       ++nOK; // pad to be used in fit</span>
<span class="lineNum">    1244 </span>            : 
<span class="lineNum">    1245 </span><span class="lineCov">        454 :       if (nCoupled &gt; 3) </span>
<span class="lineNum">    1246 </span>            :       {
<span class="lineNum">    1247 </span>            :         // Check other clusters
<span class="lineNum">    1248 </span><span class="lineCov">        100 :         for (Int_t iclust1 = 0; iclust1 &lt; nCoupled; ++iclust1) </span>
<span class="lineNum">    1249 </span>            :         {
<span class="lineNum">    1250 </span><span class="lineCov">         40 :           indx1 = clustNumb[iclust1];</span>
<span class="lineNum">    1251 </span><span class="lineCov">         40 :           if (indx1 &lt; 0) continue;</span>
<span class="lineNum">    1252 </span><span class="lineCov">         30 :           if ( aijclupad(indx1,j) &lt; fgkCouplMin ) continue;</span>
<span class="lineNum">    1253 </span><span class="lineCov">         22 :           padpix[j] += aijclupad(indx1,j);</span>
<span class="lineNum">    1254 </span><span class="lineCov">         22 :         }</span>
<span class="lineNum">    1255 </span><span class="lineCov">         10 :       } // if (nCoupled &gt; 3)</span>
<span class="lineNum">    1256 </span><span class="lineCov">        454 :     } // for (Int_t j=0; j&lt;npad;</span>
<span class="lineNum">    1257 </span>            :   } // for (Int_t iclust=0; iclust&lt;nForFit
<span class="lineNum">    1258 </span><span class="lineCov">         86 :   if (nCoupled &lt; 4) return nOK;</span>
<span class="lineNum">    1259 </span>            :   
<span class="lineNum">    1260 </span>            :   Double_t aaa = 0;
<span class="lineNum">    1261 </span><span class="lineCov">         40 :   for (Int_t j = 0; j &lt; npad; ++j) </span>
<span class="lineNum">    1262 </span>            :   {
<span class="lineNum">    1263 </span><span class="lineCov">         18 :     if (padpix[j] &lt; fgkCouplMin) continue;</span>
<span class="lineNum">    1264 </span><span class="lineCov">         10 :     aaa += padpix[j];</span>
<span class="lineNum">    1265 </span>            :     //cluster.Pad(j)-&gt;SetStatus(-1); // exclude pads with strong coupling to the other clusters
<span class="lineNum">    1266 </span><span class="lineCov">         10 :     cluster.Pad(j)-&gt;SetStatus(AliMUONClusterFinderMLEM::GetCoupledFlag()); // exclude pads with strong coupling to the other clusters</span>
<span class="lineNum">    1267 </span><span class="lineCov">         10 :     nOK--;</span>
<span class="lineNum">    1268 </span><span class="lineCov">         10 :   }</span>
<span class="lineNum">    1269 </span><span class="lineCov">          4 :   delete [] padpix; </span>
<span class="lineNum">    1270 </span>            :   return nOK;
<span class="lineNum">    1271 </span><span class="lineCov">         44 : }</span>
<span class="lineNum">    1272 </span>            : 
<a name="1273"><span class="lineNum">    1273 </span>            : //_____________________________________________________________________________</a>
<span class="lineNum">    1274 </span>            : void 
<span class="lineNum">    1275 </span>            : AliMUONClusterSplitterMLEM::UpdatePads(const AliMUONCluster&amp; cluster,
<span class="lineNum">    1276 </span>            :                                           Int_t /*nfit*/, Double_t *par)
<span class="lineNum">    1277 </span>            : {
<span class="lineNum">    1278 </span>            :   /// Subtract the fitted charges from pads with strong coupling
<span class="lineNum">    1279 </span>            :   
<span class="lineNum">    1280 </span><span class="lineCov">         88 :   Int_t indx, mult = cluster.Multiplicity(), iend = fNpar/3;</span>
<span class="lineNum">    1281 </span>            :   Double_t charge, coef=0;
<span class="lineNum">    1282 </span>            :   
<span class="lineNum">    1283 </span><span class="lineCov">       1028 :   for (Int_t j = 0; j &lt; mult; ++j) </span>
<span class="lineNum">    1284 </span>            :   {
<span class="lineNum">    1285 </span><span class="lineCov">        470 :     AliMUONPad* pad = cluster.Pad(j);</span>
<span class="lineNum">    1286 </span>            :     //if ( pad-&gt;Status() != -1 ) continue;
<span class="lineNum">    1287 </span><span class="lineCov">        940 :     if ( pad-&gt;Status() != AliMUONClusterFinderMLEM::GetCoupledFlag() ) continue;</span>
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :     if (fNpar != 0) </span>
<span class="lineNum">    1289 </span>            :     {
<span class="lineNum">    1290 </span>            :       charge = 0;
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :       for (Int_t i = 0; i &lt;= iend; ++i) </span>
<span class="lineNum">    1292 </span>            :       { 
<span class="lineNum">    1293 </span>            :         // sum over hits
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 :         indx = 3 * i;</span>
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 :         coef = Param2Coef(i, coef, par);</span>
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :         charge += ChargeIntegration(par[indx],par[indx+1],*pad) * coef;</span>
<span class="lineNum">    1297 </span>            :       }
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :       charge *= fQtot;</span>
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 :       pad-&gt;SetCharge(pad-&gt;Charge()-charge);</span>
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :     } // if (fNpar != 0)</span>
<span class="lineNum">    1301 </span>            :     
<span class="lineNum">    1302 </span>            :     //if (pad-&gt;Charge() &gt; 6 /*fgkZeroSuppression*/) pad-&gt;SetStatus(0); 
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :     if (pad-&gt;Charge() &gt; fLowestPadCharge) pad-&gt;SetStatus(AliMUONClusterFinderMLEM::GetZeroFlag());</span>
<span class="lineNum">    1304 </span>            :     // return pad for further using // FIXME: remove usage of zerosuppression here
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 :     else pad-&gt;SetStatus(AliMUONClusterFinderMLEM::GetOverFlag()); // do not use anymore</span>
<span class="lineNum">    1306 </span>            :     
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :   } // for (Int_t j=0;</span>
<span class="lineNum">    1308 </span><span class="lineCov">         44 : }  </span>
<span class="lineNum">    1309 </span>            : 
<span class="lineNum">    1310 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
