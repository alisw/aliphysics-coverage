<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - MUON/MUONraw/AliMUONTrackerDDLDecoderEventHandler.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">MUON/MUONraw</a> - AliMUONTrackerDDLDecoderEventHandler.h<span style="font-size: 80%;"> (source / <a href="AliMUONTrackerDDLDecoderEventHandler.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">9</td>
            <td class="headerCovTableEntry">74</td>
            <td class="headerCovTableEntryLo">12.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">6</td>
            <td class="headerCovTableEntry">15</td>
            <td class="headerCovTableEntryLo">40.0 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : #ifndef ALIMUONTRACKERDDLDECODEREVENTHANDLER_H</a>
<span class="lineNum">       2 </span>            : #define ALIMUONTRACKERDDLDECODEREVENTHANDLER_H
<span class="lineNum">       3 </span>            : /**************************************************************************
<span class="lineNum">       4 </span>            :  * This file is property of and copyright by the ALICE HLT Project        *
<span class="lineNum">       5 </span>            :  * All rights reserved.                                                   *
<span class="lineNum">       6 </span>            :  *                                                                        *
<span class="lineNum">       7 </span>            :  * Primary Authors:                                                       *
<span class="lineNum">       8 </span>            :  *   Artur Szostak &lt;artursz@iafrica.com&gt;                                  *
<span class="lineNum">       9 </span>            :  *                                                                        *
<span class="lineNum">      10 </span>            :  * Permission to use, copy, modify and distribute this software and its   *
<span class="lineNum">      11 </span>            :  * documentation strictly for non-commercial purposes is hereby granted   *
<span class="lineNum">      12 </span>            :  * without fee, provided that the above copyright notice appears in all   *
<span class="lineNum">      13 </span>            :  * copies and that both the copyright notice and this permission notice   *
<span class="lineNum">      14 </span>            :  * appear in the supporting documentation. The authors make no claims     *
<span class="lineNum">      15 </span>            :  * about the suitability of this software for any purpose. It is          *
<span class="lineNum">      16 </span>            :  * provided &quot;as is&quot; without express or implied warranty.                  *
<span class="lineNum">      17 </span>            :  **************************************************************************/
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : /* $Id$ */
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : ///
<span class="lineNum">      22 </span>            : /// \file   AliMUONTrackerDDLDecoderEventHandler.h
<span class="lineNum">      23 </span>            : /// \author Artur Szostak &lt;artursz@iafrica.com&gt;
<span class="lineNum">      24 </span>            : /// \date   28-11-2007
<span class="lineNum">      25 </span>            : /// \brief  Implementation of a high performance DDL decoder event handler 
<span class="lineNum">      26 </span>            : /// for the muon tracking stations.
<span class="lineNum">      27 </span>            : ///
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : #include &lt;cassert&gt;
<span class="lineNum">      30 </span>            : #include &lt;ostream&gt;
<span class="lineNum">      31 </span>            : #include &lt;Rtypes.h&gt;
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : // We use C binding for the structures because C is more uniform with its application
<span class="lineNum">      35 </span>            : // binary interface (ABI) between compilers.
<span class="lineNum">      36 </span>            : extern &quot;C&quot;
<span class="lineNum">      37 </span>            : {
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : // The following structures are the headers found in the DDL payload from the
<span class="lineNum">      40 </span>            : // muon tracking chambers. The specification is defined in ALICE-INT-2005-012
<span class="lineNum">      41 </span>            : // (https://edms.cern.ch/file/591904/1/ALICE-INT-2005-012.pdf)
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : /// The block header structure of the Tracker DDL payload.
<span class="lineNum">      44 </span>            : struct AliMUONBlockHeaderStruct
<span class="lineNum">      45 </span>            : {
<span class="lineNum">      46 </span>            :         UInt_t     fDataKey;        ///&lt; Data key word for CRT header 
<span class="lineNum">      47 </span>            :         UInt_t     fTotalLength;    ///&lt; total length of block structure (w/o padding word)
<span class="lineNum">      48 </span>            :         UInt_t     fLength;         ///&lt; length of raw data
<span class="lineNum">      49 </span>            :         UInt_t     fDSPId;          ///&lt; DSP id
<span class="lineNum">      50 </span>            :         UInt_t     fL0Trigger;      ///&lt; L0 trigger word
<span class="lineNum">      51 </span>            :         UInt_t     fMiniEventId;    ///&lt; Bunch Crossing for mini-event id (see TDR chapter 8)
<span class="lineNum">      52 </span>            :         UInt_t     fEventId1;       ///&lt; Event Id in bunch crossing
<span class="lineNum">      53 </span>            :         UInt_t     fEventId2;       ///&lt; Event Id in orbit number
<span class="lineNum">      54 </span>            : };
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : /// The DSP header structure of the Tracker DDL payload.
<span class="lineNum">      57 </span>            : struct AliMUONDSPHeaderStruct
<span class="lineNum">      58 </span>            : {
<span class="lineNum">      59 </span>            :         UInt_t     fDataKey;          ///&lt; Data key word for FRT header 
<span class="lineNum">      60 </span>            :         UInt_t     fTotalLength;      ///&lt; total length of block structure
<span class="lineNum">      61 </span>            :         UInt_t     fLength;           ///&lt; length of raw data
<span class="lineNum">      62 </span>            :         UInt_t     fDSPId;            ///&lt; DSP id
<span class="lineNum">      63 </span>            :         UInt_t     fBlkL1ATrigger;    ///&lt; L1 accept in Block Structure (CRT)
<span class="lineNum">      64 </span>            :         UInt_t     fMiniEventId;      ///&lt; Mini Event Id in bunch crossing 
<span class="lineNum">      65 </span>            :         UInt_t     fL1ATrigger;       ///&lt; Number of L1 accept in DSP Structure (FRT)
<span class="lineNum">      66 </span>            :         UInt_t     fL1RTrigger;       ///&lt; Number of L1 reject in DSP Structure (FRT)
<span class="lineNum">      67 </span>            :         UInt_t     fPaddingWord;      ///&lt; padding dummy word for 64 bits transfer
<span class="lineNum">      68 </span>            :         UInt_t     fErrorWord;        ///&lt; Error word
<span class="lineNum">      69 </span>            : };
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span>            : /// The bus patch header structure of the Tracker DDL payload.
<span class="lineNum">      72 </span>            : struct AliMUONBusPatchHeaderStruct
<span class="lineNum">      73 </span>            : {
<span class="lineNum">      74 </span>            :         UInt_t     fDataKey;       ///&lt; Data key word for bus patch header 
<span class="lineNum">      75 </span>            :         UInt_t     fTotalLength;   ///&lt; total length of bus patch structure
<span class="lineNum">      76 </span>            :         UInt_t     fLength;        ///&lt; length of raw data
<span class="lineNum">      77 </span>            :         UInt_t     fBusPatchId;    ///&lt; bus patch id
<span class="lineNum">      78 </span>            : };
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            : } // extern &quot;C&quot;
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span>            : /// \ingroup raw
<span class="lineNum">      84 </span>            : /// \class AliMUONTrackerDDLDecoderEventHandler
<span class="lineNum">      85 </span>            : /// \brief Callback event handler class for the AliMUONTrackerDDLDecoder.
<span class="lineNum">      86 </span>            : ///
<span class="lineNum">      87 </span>            : /// This class is the base class defining what methods the event handler for the
<span class="lineNum">      88 </span>            : /// high performance decoder should have. This handler actually does nothing.
<span class="lineNum">      89 </span>            : /// The user of this decoder will have to derive from this class a custom event
<span class="lineNum">      90 </span>            : /// handler that actually does something within the callback methods OnNewBusPatch,
<span class="lineNum">      91 </span>            : /// OnData, OnError etc...
<span class="lineNum">      92 </span>            : ///
<a name="93"><span class="lineNum">      93 </span>            : /// \author Artur Szostak &lt;artursz@iafrica.com&gt;</a>
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span><span class="lineCov">         24 : class AliMUONTrackerDDLDecoderEventHandler</span>
<span class="lineNum">      96 </span>            : {
<span class="lineNum">      97 </span>            : public:
<span class="lineNum">      98 </span>            : 
<a name="99"><span class="lineNum">      99 </span>            :         /// The only reason for a virtual destructor is to make -Weffc++ shutup.</a>
<span class="lineNum">     100 </span>            :         /// This should not really be here since we do not need or use virtual methods.
<span class="lineNum">     101 </span><span class="lineCov">         16 :         virtual ~AliMUONTrackerDDLDecoderEventHandler() {}</span>
<span class="lineNum">     102 </span>            : 
<span class="lineNum">     103 </span>            :         /// All the possible error codes for the parsing.
<span class="lineNum">     104 </span>            :         enum ErrorCode
<span class="lineNum">     105 </span>            :         {
<span class="lineNum">     106 </span>            :                 kNoError = 0,                  /// Decoding was successful.
<span class="lineNum">     107 </span>            :                 // Offset our error codes to stay clear of any common codes in AliMUONRawStreamTracker:
<span class="lineNum">     108 </span>            :                 kBufferTooBig = 10,            /// The DDL raw data is larger than indicated by the headers; extra bytes are probably just garbage.
<span class="lineNum">     109 </span>            :                 kTooManyBlocks = 11,           /// Too many block structures found.
<span class="lineNum">     110 </span>            :                 kTooManyDSPs = 12,             /// Too many DSP structures found in the block.
<span class="lineNum">     111 </span>            :                 kTooManyBusPatches = 13,       /// Too many bus patch structures found in the DSP structure.
<span class="lineNum">     112 </span>            :                 kNoBlockHeader = 14,           /// Missing a block header.
<span class="lineNum">     113 </span>            :                 kBadBlockKey = 15,             /// The block header key word does not contain the correct value.
<span class="lineNum">     114 </span>            :                 kBadBlockLength = 16,          /// The block length field points past the end of the raw data size.
<span class="lineNum">     115 </span>            :                 kBadBlockTotalLength = 17,     /// The total block length field points past the end of the raw data size.
<span class="lineNum">     116 </span>            :                 kBlockLengthMismatch = 18,     /// The block length and total length fields do not correspond. One or both of these values is incorrect.
<span class="lineNum">     117 </span>            :                 kNoDSPHeader = 19,             /// Missing a DSP header.
<span class="lineNum">     118 </span>            :                 kBadDSPKey = 20,               /// The DSP header key word does not contain the correct value.
<span class="lineNum">     119 </span>            :                 kBadDSPLength = 21,            /// The DSP structure length field points past the end of the block structure.
<span class="lineNum">     120 </span>            :                 kBadDSPTotalLength = 22,       /// The total DSP structure length field points past the end of the block structure.
<span class="lineNum">     121 </span>            :                 kDSPLengthMismatch = 23,       /// The DSP structure length and total length fields do not correspond. One or both of these values is incorrect.
<span class="lineNum">     122 </span>            :                 kNoBusPatchHeader = 24,        /// Missing a bus patch header.
<span class="lineNum">     123 </span>            :                 kBadBusPatchKey = 25,          /// The bus patch header key word does not contain the correct value.
<span class="lineNum">     124 </span>            :                 kBadBusPatchLength = 26,       /// The bus patch length field points past the end of the DSP structure.
<span class="lineNum">     125 </span>            :                 kBadBusPatchTotalLength = 27,  /// The total bus patch length field points past the end of the DSP structure.
<span class="lineNum">     126 </span>            :                 kBusPatchLengthMismatch = 28,  /// The bus patch length and total length fields do not correspond. One or both of these values is incorrect.
<span class="lineNum">     127 </span>            :                 kNoDDLTrailerWords = 29,       /// No end of DDL markers found in the trailer words.
<span class="lineNum">     128 </span>            :                 kTooFewDDLTrailerWords = 30,   /// Only one end of DDL marker trailer word found but expected two.
<span class="lineNum">     129 </span>            :                 kUnknownDspError = 31,         /// The DSP error code is non-zero but of an unrecognised format.
<span class="lineNum">     130 </span>            :                 kTokenLost = 32,               /// The DSP contains a token lost error code that can affect the deadtime.
<span class="lineNum">     131 </span>            :                 // match up error codes with AliMUONRawStreamTracker:
<span class="lineNum">     132 </span>            :                 kGlitchFound = 1,              /// Found a glitch. This means a 1 byte word has been randomly inserted into the raw data by mistake.
<span class="lineNum">     133 </span>            :                 kBadPaddingWord = 2,           /// The padding word does not contain the correct value.
<span class="lineNum">     134 </span>            :                 kParityError = 3               /// Found a parity error in the data word.
<span class="lineNum">     135 </span>            :         };
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            :         // The following methods should be overridden for specific processing to
<span class="lineNum">     138 </span>            :         // take place in your event handler.
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            :         /// The OnNewBuffer method will be called whenever a new buffer containing
<span class="lineNum">     141 </span>            :         /// a DDL payload is about to be processed.
<span class="lineNum">     142 </span>            :         /// The default behaviour of this method is to do nothing.
<span class="lineNum">     143 </span>            :         /// - param const void*  The pointer to the start of the memory buffer storing
<a name="144"><span class="lineNum">     144 </span>            :         ///                the DDL payload.</a>
<span class="lineNum">     145 </span>            :         /// - param UInt_t The size in bytes of the memory buffer.
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :         void OnNewBuffer(const void* /*buffer*/, UInt_t /*bufferSize*/) {}</span>
<span class="lineNum">     147 </span>            :         
<span class="lineNum">     148 </span>            :         /// The OnEndOfBuffer method will be called whenever the buffer containing
<span class="lineNum">     149 </span>            :         /// a DDL payload has been processed. For each OnNewBuffer method call a
<span class="lineNum">     150 </span>            :         /// symmetric call to OnEndOfBuffer is made at the end of processing (after
<span class="lineNum">     151 </span>            :         /// the last call to OnData)
<span class="lineNum">     152 </span>            :         /// The default behaviour of this method is to do nothing.
<span class="lineNum">     153 </span>            :         /// - param const void*  The pointer to the start of the memory buffer storing
<a name="154"><span class="lineNum">     154 </span>            :         ///                the DDL payload.</a>
<span class="lineNum">     155 </span>            :         /// - param UInt_t The size in bytes of the memory buffer.
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :         void OnEndOfBuffer(const void* /*buffer*/, UInt_t /*bufferSize*/) {}</span>
<span class="lineNum">     157 </span>            :         
<span class="lineNum">     158 </span>            :         /// OnNewBlock is called whenever a new block header is found in the payload.
<span class="lineNum">     159 </span>            :         /// The default behaviour of this method is to do nothing.
<span class="lineNum">     160 </span>            :         /// - param const AliMUONBlockHeaderStruct* This is a pointer to the block header
<span class="lineNum">     161 </span>            :         ///                as found in the DDL payload.
<span class="lineNum">     162 </span>            :         /// - param const void* This is a pointer to the start of the block's contents.
<span class="lineNum">     163 </span>            :         /// Note: both pointers point into the memory buffer being parsed, so the
<a name="164"><span class="lineNum">     164 </span>            :         /// contents must not be modified. On the other hand this is very efficient</a>
<span class="lineNum">     165 </span>            :         /// because no memory copying is required.
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :         void OnNewBlock(const AliMUONBlockHeaderStruct* /*header*/, const void* /*data*/) {}</span>
<span class="lineNum">     167 </span>            :         
<span class="lineNum">     168 </span>            :         /// OnEndOfBlock is called whenever a block has been processed. Symmetric
<span class="lineNum">     169 </span>            :         /// calls are made to OnEndOfBlock after each call to OnNewBlock. This happens
<span class="lineNum">     170 </span>            :         /// once all DSP structures contained inside the current block have been
<span class="lineNum">     171 </span>            :         /// processed.
<span class="lineNum">     172 </span>            :         /// The default behaviour of this method is to do nothing.
<span class="lineNum">     173 </span>            :         /// - param const AliMUONBlockHeaderStruct* This is a pointer to the processed
<span class="lineNum">     174 </span>            :         ///                block header as found in the DDL payload.
<span class="lineNum">     175 </span>            :         /// - param const void* This is a pointer to the start of the block's contents.
<span class="lineNum">     176 </span>            :         /// Note: both pointers point into the memory buffer being parsed, so the
<a name="177"><span class="lineNum">     177 </span>            :         /// contents must not be modified. On the other hand this is very efficient</a>
<span class="lineNum">     178 </span>            :         /// because no memory copying is required.
<span class="lineNum">     179 </span><span class="lineCov">        320 :         void OnEndOfBlock(const AliMUONBlockHeaderStruct* /*header*/, const void* /*data*/) {}</span>
<span class="lineNum">     180 </span>            :         
<span class="lineNum">     181 </span>            :         /// OnNewDSP is called whenever a new DSP header is found in the payload.
<span class="lineNum">     182 </span>            :         /// Every DSP header received by a call to OnNewDSP is associated to the
<span class="lineNum">     183 </span>            :         /// block header received in the most recent call to OnNewBlock.
<span class="lineNum">     184 </span>            :         /// The default behaviour of this method is to do nothing.
<span class="lineNum">     185 </span>            :         /// - param const AliMUONDSPHeaderStruct*  This is a pointer to the DSP header
<span class="lineNum">     186 </span>            :         ///                as found in the DDL payload.
<span class="lineNum">     187 </span>            :         /// - param const void*  This is a pointer to the start of the DSP's contents.
<span class="lineNum">     188 </span>            :         /// Note: both pointers point into the memory buffer being parsed, so the
<a name="189"><span class="lineNum">     189 </span>            :         /// contents must not be modified. On the other hand this is very efficient</a>
<span class="lineNum">     190 </span>            :         /// because no memory copying is required.
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :         void OnNewDSP(const AliMUONDSPHeaderStruct* /*header*/, const void* /*data*/) {}</span>
<span class="lineNum">     192 </span>            :         
<span class="lineNum">     193 </span>            :         /// OnEndOfDSP is called whenever a DSP header has already been processed.
<span class="lineNum">     194 </span>            :         /// For every call to OnNewDSP a symmetric call to OnEndOfDSP is made once
<span class="lineNum">     195 </span>            :         /// all the bus patch structured contained in the DSP are processed.
<span class="lineNum">     196 </span>            :         /// The default behaviour of this method is to do nothing.
<span class="lineNum">     197 </span>            :         /// - param const AliMUONDSPHeaderStruct*  This is a pointer to the already
<span class="lineNum">     198 </span>            :         ///                processed DSP header as found in the DDL payload.
<span class="lineNum">     199 </span>            :         /// - param const void*  This is a pointer to the start of the DSP's contents.
<span class="lineNum">     200 </span>            :         /// Note: both pointers point into the memory buffer being parsed, so the
<a name="201"><span class="lineNum">     201 </span>            :         /// contents must not be modified. On the other hand this is very efficient</a>
<span class="lineNum">     202 </span>            :         /// because no memory copying is required.
<span class="lineNum">     203 </span><span class="lineCov">       1472 :         void OnEndOfDSP(const AliMUONDSPHeaderStruct* /*header*/, const void* /*data*/) {}</span>
<span class="lineNum">     204 </span>            :         
<span class="lineNum">     205 </span>            :         /// OnNewBusPatch is called whenever a new bus patch header is found in
<span class="lineNum">     206 </span>            :         /// the payload. Every bus patch received by a call to OnNewBusPatch is
<span class="lineNum">     207 </span>            :         /// associated to the DSP header received in the most recent call to OnNewDSP.
<span class="lineNum">     208 </span>            :         /// The default behaviour of this method is to do nothing.
<span class="lineNum">     209 </span>            :         /// - param const AliMUONBusPatchHeaderStruct*  This is a pointer to the bus patch
<span class="lineNum">     210 </span>            :         ///                header as found in the DDL payload.
<span class="lineNum">     211 </span>            :         /// - param const void*  This is a pointer to the start of the bus patch's contents,
<span class="lineNum">     212 </span>            :         ///              specifically the raw data words.
<span class="lineNum">     213 </span>            :         /// Note: both pointers point into the memory buffer being parsed, so the
<a name="214"><span class="lineNum">     214 </span>            :         /// contents must not be modified. On the other hand this is very efficient</a>
<span class="lineNum">     215 </span>            :         /// because no memory copying is required.
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :         void OnNewBusPatch(const AliMUONBusPatchHeaderStruct* /*header*/, const void* /*data*/) {}</span>
<span class="lineNum">     217 </span>            :         
<span class="lineNum">     218 </span>            :         /// OnEndOfBusPatch is called whenever a bus patch has been processed.
<span class="lineNum">     219 </span>            :         /// For every call to OnNewBusPatch a symmetric call to OnEndOfBusPatch is
<span class="lineNum">     220 </span>            :         /// made once the bus patch is completely processed (no more OnData calls).
<span class="lineNum">     221 </span>            :         /// The default behaviour of this method is to do nothing.
<span class="lineNum">     222 </span>            :         /// - param const AliMUONBusPatchHeaderStruct*  This is a pointer to the already
<span class="lineNum">     223 </span>            :         ///                processed bus patch header, as found in the DDL payload.
<span class="lineNum">     224 </span>            :         /// - param const void*  This is a pointer to the start of the bus patch's contents,
<span class="lineNum">     225 </span>            :         ///              specifically the raw data words.
<span class="lineNum">     226 </span>            :         /// Note: both pointers point into the memory buffer being parsed so the
<a name="227"><span class="lineNum">     227 </span>            :         /// contents must not be modified. On the other hand this is very efficient</a>
<span class="lineNum">     228 </span>            :         /// because no memory copying is required.
<span class="lineNum">     229 </span><span class="lineCov">       7104 :         void OnEndOfBusPatch(const AliMUONBusPatchHeaderStruct* /*header*/, const void* /*data*/) {}</span>
<span class="lineNum">     230 </span>            :         
<span class="lineNum">     231 </span>            :         /// OnData is called for every raw data word found within a bus patch.
<span class="lineNum">     232 </span>            :         /// Every data ward received by a call to OnData is associated to the bus patch
<span class="lineNum">     233 </span>            :         /// header received in the most recent call to OnNewBusPatch.
<span class="lineNum">     234 </span>            :         /// The default behaviour of this method is to do nothing.
<span class="lineNum">     235 </span>            :         /// - param UInt_t  This is the raw data word as found within the bus patch payload.
<span class="lineNum">     236 </span>            :         /// - param bool  Flag indicating if the raw data word had a parity error.
<span class="lineNum">     237 </span>            :         ///       This will always be set to false if fSendDataOnParityError in the
<span class="lineNum">     238 </span>            :         ///       AliMUONTrackerDDLDecoder class was set to false.
<span class="lineNum">     239 </span>            :         void OnData(UInt_t /*data*/, bool /*parityError*/) {}
<span class="lineNum">     240 </span>            :         
<span class="lineNum">     241 </span>            :         /// Whenever a parsing error of the DDL payload is encountered because of
<span class="lineNum">     242 </span>            :         /// corruption of the raw data (eg. bit flips) the OnError method is called
<span class="lineNum">     243 </span>            :         /// immediately at the point this error is discovered.
<span class="lineNum">     244 </span>            :         /// The default behaviour of this method is to do nothing.
<span class="lineNum">     245 </span>            :         /// - param ErrorCode  This is an error code indicating the kind of problem
<span class="lineNum">     246 </span>            :         ///               encountered with the DDL payload.
<span class="lineNum">     247 </span>            :         /// - param const void*  This is a pointer into the DDL payload memory buffer
<span class="lineNum">     248 </span>            :         ///         indicating the exact location where the parsing error happened
<span class="lineNum">     249 </span>            :         ///         or i.e. the location of the corruption.
<span class="lineNum">     250 </span>            :         /// Note that a relative offset in bytes from the start of the memory buffer
<span class="lineNum">     251 </span>            :         /// can be calculated by: storing the buffer pointer received in OnNewBuffer
<span class="lineNum">     252 </span>            :         /// earlier in fBufferStart for example, and then the offset is given by:
<span class="lineNum">     253 </span>            :         ///   offset = (unsigned long)location - (unsigned long)fBufferStart;
<span class="lineNum">     254 </span>            :         void OnError(ErrorCode /*error*/, const void* /*location*/) {}
<span class="lineNum">     255 </span>            :         
<span class="lineNum">     256 </span>            :         /// This is a utility method which will unpack the MANU ID, channel ID and
<span class="lineNum">     257 </span>            :         /// ADC signal value from a raw data word. It should normally be used in
<span class="lineNum">     258 </span>            :         /// OnData() to unpack these fields.
<span class="lineNum">     259 </span>            :         /// [in]  \param data  This is the raw data word found in the DDL payload.
<span class="lineNum">     260 </span>            :         /// [out] \param manuId    This is filled with the unpacked MANU ID.
<a name="261"><span class="lineNum">     261 </span>            :         /// [out] \param channelId This is filled with the unpacked MANU channel ID.</a>
<span class="lineNum">     262 </span>            :         /// [out] \param adc       This is filled with the unpacked ADC signal.
<span class="lineNum">     263 </span>            :         static void UnpackADC(
<span class="lineNum">     264 </span>            :                         UInt_t data,
<span class="lineNum">     265 </span>            :                         UShort_t&amp; manuId, UChar_t&amp; channelId, UShort_t&amp; adc
<span class="lineNum">     266 </span>            :                 )
<span class="lineNum">     267 </span>            :         {
<span class="lineNum">     268 </span><span class="lineCov">       1416 :                 manuId = (UShort_t)(data &gt;&gt; 18) &amp; 0x7FF;</span>
<span class="lineNum">     269 </span><span class="lineCov">        708 :                 channelId = (Char_t)(data &gt;&gt; 12) &amp; 0x3F;</span>
<span class="lineNum">     270 </span><span class="lineCov">        708 :                 adc = (UShort_t)(data &amp; 0xFFF);</span>
<span class="lineNum">     271 </span><span class="lineCov">        708 :         }</span>
<span class="lineNum">     272 </span>            :         
<span class="lineNum">     273 </span>            :         /// This is a utility method which converts an error code to a string
<span class="lineNum">     274 </span>            :         /// representation for printing purposes.
<span class="lineNum">     275 </span>            :         /// \param code  The error code as received in OnError for example.
<span class="lineNum">     276 </span>            :         /// \return  An ANSI string containing the name of the error code symbol.
<span class="lineNum">     277 </span>            :         static const char* ErrorCodeToString(ErrorCode code);
<span class="lineNum">     278 </span>            :         
<span class="lineNum">     279 </span>            :         /// This is a utility method which converts an error code to user friendly
<span class="lineNum">     280 </span>            :         /// descriptive message useful for printing to the screen.
<span class="lineNum">     281 </span>            :         /// \param code  The error code as received in OnError for example.
<span class="lineNum">     282 </span>            :         /// \return  An ANSI string containing a descriptive message of the error.
<span class="lineNum">     283 </span>            :         static const char* ErrorCodeToMessage(ErrorCode code);
<span class="lineNum">     284 </span>            : };
<span class="lineNum">     285 </span>            : 
<a name="286"><span class="lineNum">     286 </span>            : //_____________________________________________________________________________</a>
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            : inline const char* AliMUONTrackerDDLDecoderEventHandler::ErrorCodeToString(ErrorCode code)
<span class="lineNum">     289 </span>            : {
<span class="lineNum">     290 </span>            :         /// This is a utility method which converts an error code to a string
<span class="lineNum">     291 </span>            :         /// representation for printing purposes.
<span class="lineNum">     292 </span>            :         /// \param code  The error code as received in OnError for example.
<span class="lineNum">     293 </span>            :         /// \return  An ANSI string containing the name of the error code symbol.
<span class="lineNum">     294 </span>            :         
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :         switch (code)</span>
<span class="lineNum">     296 </span>            :         {
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :         case kNoError: return &quot;kNoError&quot;;</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :         case kBufferTooBig: return &quot;kBufferTooBig&quot;;</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :         case kTooManyBlocks: return &quot;kTooManyBlocks&quot;;</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :         case kTooManyDSPs: return &quot;kTooManyDSPs&quot;;</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :         case kTooManyBusPatches: return &quot;kTooManyBusPatches&quot;;</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :         case kNoBlockHeader: return &quot;kNoBlockHeader&quot;;</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :         case kBadBlockKey: return &quot;kBadBlockKey&quot;;</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :         case kBadBlockLength: return &quot;kBadBlockLength&quot;;</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :         case kBadBlockTotalLength: return &quot;kBadBlockTotalLength&quot;;</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :         case kBlockLengthMismatch: return &quot;kBlockLengthMismatch&quot;;</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :         case kNoDSPHeader: return &quot;kNoDSPHeader&quot;;</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :         case kBadDSPKey: return &quot;kBadDSPKey&quot;;</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :         case kBadDSPLength: return &quot;kBadDSPLength&quot;;</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :         case kBadDSPTotalLength: return &quot;kBadDSPTotalLength&quot;;</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :         case kDSPLengthMismatch: return &quot;kDSPLengthMismatch&quot;;</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :         case kNoBusPatchHeader: return &quot;kNoBusPatchHeader&quot;;</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :         case kBadBusPatchKey: return &quot;kBadBusPatchKey&quot;;</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :         case kBadBusPatchLength: return &quot;kBadBusPatchLength&quot;;</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :         case kBadBusPatchTotalLength: return &quot;kBadBusPatchTotalLength&quot;;</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :         case kBusPatchLengthMismatch: return &quot;kBusPatchLengthMismatch&quot;;</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :         case kNoDDLTrailerWords: return &quot;kNoDDLTrailerWords&quot;;</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :         case kTooFewDDLTrailerWords: return &quot;kTooFewDDLTrailerWords&quot;;</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :         case kUnknownDspError: return &quot;kUnknownDspError&quot;;</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :         case kTokenLost: return &quot;kTokenLost&quot;;</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :         case kGlitchFound: return &quot;kGlitchFound&quot;;</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :         case kBadPaddingWord: return &quot;kBadPaddingWord&quot;;</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :         case kParityError: return &quot;kParityError&quot;;</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :         default: return &quot;INVALID&quot;;</span>
<span class="lineNum">     325 </span>            :         }
<span class="lineNum">     326 </span><span class="lineNoCov">          0 : }</span>
<a name="327"><span class="lineNum">     327 </span>            : </a>
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            : inline const char* AliMUONTrackerDDLDecoderEventHandler::ErrorCodeToMessage(ErrorCode code)
<span class="lineNum">     330 </span>            : {
<span class="lineNum">     331 </span>            :         /// This is a utility method which converts an error code to user friendly
<span class="lineNum">     332 </span>            :         /// descriptive message useful for printing to the screen.
<span class="lineNum">     333 </span>            :         /// \param code  The error code as received in OnError for example.
<span class="lineNum">     334 </span>            :         /// \return  An ANSI string containing a descriptive message of the error.
<span class="lineNum">     335 </span>            :         
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :         switch (code)</span>
<span class="lineNum">     337 </span>            :         {
<span class="lineNum">     338 </span>            :         case kNoError:
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :                 return &quot;Decoding was successful.&quot;;</span>
<span class="lineNum">     340 </span>            :         case kBufferTooBig:
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :                 return &quot;The DDL raw data is larger than indicated by the headers;&quot;</span>
<span class="lineNum">     342 </span>            :                        &quot; extra bytes are probably just garbage.&quot;;
<span class="lineNum">     343 </span>            :         case kTooManyBlocks:
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :                 return &quot;Too many block structures found.&quot;;</span>
<span class="lineNum">     345 </span>            :         case kTooManyDSPs:
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :                 return &quot;Too many DSP structures found in the block.&quot;;</span>
<span class="lineNum">     347 </span>            :         case kTooManyBusPatches:
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :                 return &quot;Too many bus patch structures found in the DSP structure.&quot;;</span>
<span class="lineNum">     349 </span>            :         case kNoBlockHeader:
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :                 return &quot;Missing a block header.&quot;;</span>
<span class="lineNum">     351 </span>            :         case kBadBlockKey:
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :                 return &quot;The block header key word does not contain the correct value.&quot;;</span>
<span class="lineNum">     353 </span>            :         case kBadBlockLength:
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :                 return &quot;The block length field points past the end of the raw data size.&quot;;</span>
<span class="lineNum">     355 </span>            :         case kBadBlockTotalLength:
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :                 return &quot;The total block length field points past the end of the&quot;</span>
<span class="lineNum">     357 </span>            :                        &quot; raw data size.&quot;;
<span class="lineNum">     358 </span>            :         case kBlockLengthMismatch:
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :                 return &quot;The block length and total length fields do not correspond.&quot;</span>
<span class="lineNum">     360 </span>            :                        &quot; One or both of these values is incorrect.&quot;;
<span class="lineNum">     361 </span>            :         case kNoDSPHeader:
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :                 return &quot;Missing a DSP header.&quot;;</span>
<span class="lineNum">     363 </span>            :         case kBadDSPKey:
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :                 return &quot;The DSP header key word does not contain the correct value.&quot;;</span>
<span class="lineNum">     365 </span>            :         case kBadDSPLength:
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :                 return &quot;The DSP structure length field points past the end of the&quot;</span>
<span class="lineNum">     367 </span>            :                        &quot; block structure.&quot;;
<span class="lineNum">     368 </span>            :         case kBadDSPTotalLength:
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :                 return &quot;The total DSP structure length field points past the end of&quot;</span>
<span class="lineNum">     370 </span>            :                        &quot; the block structure.&quot;;
<span class="lineNum">     371 </span>            :         case kDSPLengthMismatch:
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :                 return &quot;The DSP structure length and total length fields do not&quot;</span>
<span class="lineNum">     373 </span>            :                        &quot; correspond. One or both of these values is incorrect.&quot;;
<span class="lineNum">     374 </span>            :         case kNoBusPatchHeader:
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :                 return &quot;Missing a bus patch header.&quot;;</span>
<span class="lineNum">     376 </span>            :         case kBadBusPatchKey:
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :                 return &quot;The bus patch header key word does not contain the correct value.&quot;;</span>
<span class="lineNum">     378 </span>            :         case kBadBusPatchLength:
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :                 return &quot;The bus patch length field points past the end of the&quot;</span>
<span class="lineNum">     380 </span>            :                        &quot; DSP structure.&quot;;
<span class="lineNum">     381 </span>            :         case kBadBusPatchTotalLength:
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :                 return &quot;The total bus patch length field points past the end of&quot;</span>
<span class="lineNum">     383 </span>            :                        &quot; the DSP structure.&quot;;
<span class="lineNum">     384 </span>            :         case kBusPatchLengthMismatch:
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :                 return &quot;The bus patch length and total length fields do not correspond.&quot;</span>
<span class="lineNum">     386 </span>            :                        &quot; One or both of these values is incorrect.&quot;;
<span class="lineNum">     387 </span>            :         case kNoDDLTrailerWords:
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :                 return &quot;No end of DDL data key found in the trailer words.&quot;;</span>
<span class="lineNum">     389 </span>            :         case kTooFewDDLTrailerWords:
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :                 return &quot;Only one end of DDL data key word found in the trailer but expected two.&quot;;</span>
<span class="lineNum">     391 </span>            :         case kUnknownDspError:
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :                 return &quot;The DSP error code is non-zero but of an unrecognised format.&quot;;</span>
<span class="lineNum">     393 </span>            :         case kTokenLost:
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :                 return &quot;The DSP contains a token lost error code that can affect the deadtime.&quot;;</span>
<span class="lineNum">     395 </span>            :         case kGlitchFound:
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :                 return &quot;Found a glitch. This means a 1 byte word has been randomly&quot;</span>
<span class="lineNum">     397 </span>            :                        &quot; inserted into the raw data by mistake.&quot;;
<span class="lineNum">     398 </span>            :         case kBadPaddingWord:
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :                 return &quot;The padding word does not contain the correct value.&quot;;</span>
<span class="lineNum">     400 </span>            :         case kParityError:
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :                 return &quot;Found a parity error in the data word.&quot;;</span>
<span class="lineNum">     402 </span>            :         default:
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :                 return &quot;Unknown error code!&quot;;</span>
<span class="lineNum">     404 </span>            :         }
<span class="lineNum">     405 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            : inline std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, AliMUONTrackerDDLDecoderEventHandler::ErrorCode code)
<span class="lineNum">     409 </span>            : {
<span class="lineNum">     410 </span>            :         /// This is the stream operator for std::ostream classes to be able to
<span class="lineNum">     411 </span>            :         /// easily write the error messages associated with the error codes generated
<span class="lineNum">     412 </span>            :         /// by the decoder to 'cout' or 'cerr' for example.
<span class="lineNum">     413 </span>            :         
<span class="lineNum">     414 </span>            :         os &lt;&lt; AliMUONTrackerDDLDecoderEventHandler::ErrorCodeToMessage(code);
<span class="lineNum">     415 </span>            :         return os;
<span class="lineNum">     416 </span>            : }
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            : #endif // ALIMUONTRACKERDDLDECODEREVENTHANDLER_H
<span class="lineNum">     419 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
