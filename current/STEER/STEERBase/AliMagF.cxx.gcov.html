<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - STEER/STEERBase/AliMagF.cxx</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">STEER/STEERBase</a> - AliMagF.cxx<span style="font-size: 80%;"> (source / <a href="AliMagF.cxx.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">159</td>
            <td class="headerCovTableEntry">294</td>
            <td class="headerCovTableEntryLo">54.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">20</td>
            <td class="headerCovTableEntry">27</td>
            <td class="headerCovTableEntryLo">74.1 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**************************************************************************</a>
<span class="lineNum">       2 </span>            :  * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
<span class="lineNum">       3 </span>            :  *                                                                        *
<span class="lineNum">       4 </span>            :  * Author: The ALICE Off-line Project.                                    *
<span class="lineNum">       5 </span>            :  * Contributors are mentioned in the code where appropriate.              *
<span class="lineNum">       6 </span>            :  *                                                                        *
<span class="lineNum">       7 </span>            :  * Permission to use, copy, modify and distribute this software and its   *
<span class="lineNum">       8 </span>            :  * documentation strictly for non-commercial purposes is hereby granted   *
<span class="lineNum">       9 </span>            :  * without fee, provided that the above copyright notice appears in all   *
<span class="lineNum">      10 </span>            :  * copies and that both the copyright notice and this permission notice   *
<span class="lineNum">      11 </span>            :  * appear in the supporting documentation. The authors make no claims     *
<span class="lineNum">      12 </span>            :  * about the suitability of this software for any purpose. It is          *
<span class="lineNum">      13 </span>            :  * provided &quot;as is&quot; without express or implied warranty.                  *
<span class="lineNum">      14 </span>            :  **************************************************************************/
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : #include &lt;TClass.h&gt;
<span class="lineNum">      18 </span>            : #include &lt;TFile.h&gt;
<span class="lineNum">      19 </span>            : #include &lt;TSystem.h&gt;
<span class="lineNum">      20 </span>            : #include &lt;TPRegexp.h&gt;
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : #include &quot;AliMagF.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;AliMagWrapCheb.h&quot;
<a name="24"><span class="lineNum">      24 </span>            : #include &quot;AliLog.h&quot;</a>
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span><span class="lineCov">        176 : ClassImp(AliMagF)</span>
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : const Double_t AliMagF::fgkSol2DipZ    =  -700.;  
<span class="lineNum">      29 </span>            : const UShort_t AliMagF::fgkPolarityConvention = AliMagF::kConvLHC;
<span class="lineNum">      30 </span>            : /*
<span class="lineNum">      31 </span>            :  Explanation for polarity conventions: these are the mapping between the
<span class="lineNum">      32 </span>            :  current signs and main field components in L3 (Bz) and Dipole (Bx) (in Alice frame)
<span class="lineNum">      33 </span>            :  1) kConvMap2005: used for the field mapping in 2005
<span class="lineNum">      34 </span>            :  positive L3  current -&gt; negative Bz
<span class="lineNum">      35 </span>            :  positive Dip current -&gt; positive Bx 
<span class="lineNum">      36 </span>            :  2) kConvMapDCS2008: defined by the microswitches/cabling of power converters as of 2008 - 1st half 2009
<span class="lineNum">      37 </span>            :  positive L3  current -&gt; positive Bz
<span class="lineNum">      38 </span>            :  positive Dip current -&gt; positive Bx
<span class="lineNum">      39 </span>            :  3) kConvLHC : defined by LHC
<span class="lineNum">      40 </span>            :  positive L3  current -&gt; positive Bz
<span class="lineNum">      41 </span>            :  positive Dip current -&gt; negative Bx
<span class="lineNum">      42 </span>            :  
<span class="lineNum">      43 </span>            :  Note: only &quot;negative Bz(L3) with postive Bx(Dipole)&quot; and its inverse was mapped in 2005. Hence 
<span class="lineNum">      44 </span>            :  the GRP Manager will reject the runs with the current combinations (in the convention defined by the
<span class="lineNum">      45 </span>            :  static Int_t AliMagF::GetPolarityConvention()) which do not lead to such field polarities.
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            :  ----------------------------------------------- 
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            :  Explanation on integrals in the TPC region
<span class="lineNum">      50 </span>            :  GetTPCInt(xyz,b) and GetTPCRatInt(xyz,b) give integrals from point (x,y,z) to point (x,y,0) 
<span class="lineNum">      51 </span>            :  (irrespectively of the z sign) of the following:
<span class="lineNum">      52 </span>            :  TPCInt:    b contains int{bx}, int{by}, int{bz}
<span class="lineNum">      53 </span>            :  TPCRatInt: b contains int{bx/bz}, int{by/bz}, int{(bx/bz)^2+(by/bz)^2}
<span class="lineNum">      54 </span>            :   
<span class="lineNum">      55 </span>            :  The same applies to integral in cylindrical coordinates:
<span class="lineNum">      56 </span>            :  GetTPCIntCyl(rphiz,b)
<span class="lineNum">      57 </span>            :  GetTPCIntRatCyl(rphiz,b)
<span class="lineNum">      58 </span>            :  They accept the R,Phi,Z coordinate (-pi&lt;phi&lt;pi) and return the field 
<span class="lineNum">      59 </span>            :  integrals in cyl. coordinates.
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            :  Thus, to compute the integral from arbitrary xy_z1 to xy_z2, one should take
<span class="lineNum">      62 </span>            :  b = b1-b2 with b1 and b2 coming from GetTPCInt(xy_z1,b1) and GetTPCInt(xy_z2,b2)
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            :  Note: the integrals are defined for the range -300&lt;Z&lt;300 and 0&lt;R&lt;300
<a name="65"><span class="lineNum">      65 </span>            : */</a>
<span class="lineNum">      66 </span>            : //_______________________________________________________________________
<span class="lineNum">      67 </span>            : AliMagF::AliMagF():
<span class="lineNum">      68 </span><span class="lineCov">          3 :   TVirtualMagField(),</span>
<span class="lineNum">      69 </span><span class="lineCov">          3 :   fMeasuredMap(0),</span>
<span class="lineNum">      70 </span><span class="lineCov">          3 :   fMapType(k5kG),</span>
<span class="lineNum">      71 </span><span class="lineCov">          3 :   fSolenoid(0),</span>
<span class="lineNum">      72 </span><span class="lineCov">          3 :   fBeamType(kNoBeamField),</span>
<span class="lineNum">      73 </span><span class="lineCov">          3 :   fBeamEnergy(0),</span>
<span class="lineNum">      74 </span>            :   //
<span class="lineNum">      75 </span><span class="lineCov">          3 :   fInteg(0),</span>
<span class="lineNum">      76 </span><span class="lineCov">          3 :   fPrecInteg(0),</span>
<span class="lineNum">      77 </span><span class="lineCov">          3 :   fFactorSol(1.),</span>
<span class="lineNum">      78 </span><span class="lineCov">          3 :   fFactorDip(1.),</span>
<span class="lineNum">      79 </span><span class="lineCov">          3 :   fMax(15),</span>
<span class="lineNum">      80 </span><span class="lineCov">          3 :   fDipoleOFF(kFALSE),</span>
<span class="lineNum">      81 </span>            :   //
<span class="lineNum">      82 </span><span class="lineCov">          3 :   fQuadGradient(0),</span>
<span class="lineNum">      83 </span><span class="lineCov">          3 :   fDipoleField(0),</span>
<span class="lineNum">      84 </span><span class="lineCov">          3 :   fCCorrField(0), </span>
<span class="lineNum">      85 </span><span class="lineCov">          3 :   fACorr1Field(0),</span>
<span class="lineNum">      86 </span><span class="lineCov">          3 :   fACorr2Field(0),</span>
<span class="lineNum">      87 </span><span class="lineCov">          3 :   fParNames(&quot;&quot;,&quot;&quot;)</span>
<span class="lineNum">      88 </span><span class="lineCov">         15 : {</span>
<span class="lineNum">      89 </span>            :   // Default constructor
<span class="lineNum">      90 </span>            :   //
<span class="lineNum">      91 </span><span class="lineCov">          6 : }</span>
<a name="92"><span class="lineNum">      92 </span>            : </a>
<span class="lineNum">      93 </span>            : //_______________________________________________________________________
<span class="lineNum">      94 </span>            : AliMagF::AliMagF(const char *name, const char* title, Double_t factorSol, Double_t factorDip, 
<span class="lineNum">      95 </span>            :                  BMap_t maptype, BeamType_t bt, Double_t be,Int_t integ, Double_t fmax, const char* path):
<span class="lineNum">      96 </span><span class="lineCov">          5 :   TVirtualMagField(name),</span>
<span class="lineNum">      97 </span><span class="lineCov">          5 :   fMeasuredMap(0),</span>
<span class="lineNum">      98 </span><span class="lineCov">          5 :   fMapType(maptype),</span>
<span class="lineNum">      99 </span><span class="lineCov">          5 :   fSolenoid(0),</span>
<span class="lineNum">     100 </span><span class="lineCov">          5 :   fBeamType(bt),</span>
<span class="lineNum">     101 </span><span class="lineCov">          5 :   fBeamEnergy(be),</span>
<span class="lineNum">     102 </span>            :   //
<span class="lineNum">     103 </span><span class="lineCov">          5 :   fInteg(integ),</span>
<span class="lineNum">     104 </span><span class="lineCov">          5 :   fPrecInteg(1),</span>
<span class="lineNum">     105 </span><span class="lineCov">          5 :   fFactorSol(1.),</span>
<span class="lineNum">     106 </span><span class="lineCov">          5 :   fFactorDip(1.),</span>
<span class="lineNum">     107 </span><span class="lineCov">          5 :   fMax(fmax),</span>
<span class="lineNum">     108 </span><span class="lineCov">          5 :   fDipoleOFF(factorDip==0.),</span>
<span class="lineNum">     109 </span>            :   //
<span class="lineNum">     110 </span><span class="lineCov">          5 :   fQuadGradient(0),</span>
<span class="lineNum">     111 </span><span class="lineCov">          5 :   fDipoleField(0),</span>
<span class="lineNum">     112 </span><span class="lineCov">          5 :   fCCorrField(0), </span>
<span class="lineNum">     113 </span><span class="lineCov">          5 :   fACorr1Field(0),</span>
<span class="lineNum">     114 </span><span class="lineCov">          5 :   fACorr2Field(0),</span>
<span class="lineNum">     115 </span><span class="lineCov">          5 :   fParNames(&quot;&quot;,&quot;&quot;)</span>
<span class="lineNum">     116 </span><span class="lineCov">         25 : {</span>
<span class="lineNum">     117 </span>            :   // Initialize the field with Geant integration option &quot;integ&quot; and max field &quot;fmax,
<span class="lineNum">     118 </span>            :   // Impose scaling of parameterized L3 field by factorSol and of dipole by factorDip.
<span class="lineNum">     119 </span>            :   // The &quot;be&quot; is the energy of the beam in GeV/nucleon
<span class="lineNum">     120 </span>            :   //
<span class="lineNum">     121 </span><span class="lineCov">          5 :   SetTitle(title);</span>
<span class="lineNum">     122 </span><span class="lineCov">          5 :   if(integ&lt;0 || integ &gt; 2) {</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :     AliWarning(Form(&quot;Invalid magnetic field flag: %5d; Helix tracking chosen instead&quot;,integ));</span>
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :     fInteg = 2;</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     126 </span><span class="lineCov">          5 :   if (fInteg == 0) fPrecInteg = 0;</span>
<span class="lineNum">     127 </span>            :   //
<span class="lineNum">     128 </span><span class="lineCov">          5 :   if (fBeamEnergy&lt;=0 &amp;&amp; fBeamType!=kNoBeamField) {</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :     if      (fBeamType == kBeamTypepp) fBeamEnergy = 7000.; // max proton energy</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :     else if (fBeamType == kBeamTypeAA) fBeamEnergy = 2760;  // max PbPb energy</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :     else if (fBeamType == kBeamTypepA || fBeamType == kBeamTypeAp) fBeamEnergy = 2760;  // same rigitiy max PbPb energy</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :     AliInfo(&quot;Maximim possible beam energy for requested beam is assumed&quot;);</span>
<span class="lineNum">     133 </span>            :   } 
<span class="lineNum">     134 </span>            :   const char* parname = 0;
<span class="lineNum">     135 </span>            :   //  
<span class="lineNum">     136 </span><span class="lineCov">          5 :   if      (fMapType == k2kG) parname = fDipoleOFF ? &quot;Sol12_Dip0_Hole&quot;:&quot;Sol12_Dip6_Hole&quot;;</span>
<span class="lineNum">     137 </span><span class="lineCov">         10 :   else if (fMapType == k5kG) parname = fDipoleOFF ? &quot;Sol30_Dip0_Hole&quot;:&quot;Sol30_Dip6_Hole&quot;;</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :   else if (fMapType == k5kGUniform) parname = &quot;Sol30_Dip6_Uniform&quot;;</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :   else AliFatal(Form(&quot;Unknown field identifier %d is requested\n&quot;,fMapType));</span>
<span class="lineNum">     140 </span>            :   //
<span class="lineNum">     141 </span><span class="lineCov">          5 :   SetDataFileName(path);</span>
<span class="lineNum">     142 </span><span class="lineCov">          5 :   SetParamName(parname);</span>
<span class="lineNum">     143 </span>            :   //
<span class="lineNum">     144 </span><span class="lineCov">          5 :   LoadParameterization();</span>
<span class="lineNum">     145 </span><span class="lineCov">          5 :   InitMachineField(fBeamType,fBeamEnergy);</span>
<span class="lineNum">     146 </span><span class="lineCov">          5 :   double xyz[3]={0.,0.,0.};</span>
<span class="lineNum">     147 </span><span class="lineCov">         10 :   fSolenoid = GetBz(xyz);</span>
<span class="lineNum">     148 </span><span class="lineCov">          5 :   SetFactorSol(factorSol);</span>
<span class="lineNum">     149 </span><span class="lineCov">          5 :   SetFactorDip(factorDip);</span>
<span class="lineNum">     150 </span><span class="lineCov">          5 :   Print(&quot;a&quot;);</span>
<span class="lineNum">     151 </span><span class="lineCov">         10 : }</span>
<a name="152"><span class="lineNum">     152 </span>            : </a>
<span class="lineNum">     153 </span>            : //_______________________________________________________________________
<span class="lineNum">     154 </span>            : AliMagF::AliMagF(const AliMagF &amp;src):
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :   TVirtualMagField(src),</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :   fMeasuredMap(0),</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :   fMapType(src.fMapType),</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :   fSolenoid(src.fSolenoid),</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :   fBeamType(src.fBeamType),</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :   fBeamEnergy(src.fBeamEnergy),</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :   fInteg(src.fInteg),</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :   fPrecInteg(src.fPrecInteg),</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :   fFactorSol(src.fFactorSol),</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :   fFactorDip(src.fFactorDip),</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :   fMax(src.fMax),</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :   fDipoleOFF(src.fDipoleOFF),</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :   fQuadGradient(src.fQuadGradient),</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :   fDipoleField(src.fDipoleField),</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :   fCCorrField(src.fCCorrField), </span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :   fACorr1Field(src.fACorr1Field),</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :   fACorr2Field(src.fACorr2Field),</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :   fParNames(src.fParNames)</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :   if (src.fMeasuredMap) fMeasuredMap = new AliMagWrapCheb(*src.fMeasuredMap);</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 : }</span>
<a name="176"><span class="lineNum">     176 </span>            : </a>
<span class="lineNum">     177 </span>            : //_______________________________________________________________________
<span class="lineNum">     178 </span>            : AliMagF::~AliMagF()
<span class="lineNum">     179 </span><span class="lineCov">         30 : {</span>
<span class="lineNum">     180 </span><span class="lineCov">         10 :   delete fMeasuredMap;</span>
<span class="lineNum">     181 </span><span class="lineCov">         15 : }</span>
<a name="182"><span class="lineNum">     182 </span>            : </a>
<span class="lineNum">     183 </span>            : //_______________________________________________________________________
<span class="lineNum">     184 </span>            : Bool_t AliMagF::LoadParameterization()
<span class="lineNum">     185 </span>            : {
<span class="lineNum">     186 </span><span class="lineCov">         10 :   if (fMeasuredMap) {</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :     AliFatal(Form(&quot;Field data %s are already loaded from %s\n&quot;,GetParamName(),GetDataFileName()));</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     189 </span>            :   //
<span class="lineNum">     190 </span><span class="lineCov">          5 :   char* fname = gSystem-&gt;ExpandPathName(GetDataFileName());</span>
<span class="lineNum">     191 </span><span class="lineCov">          5 :   TFile* file = TFile::Open(fname);</span>
<span class="lineNum">     192 </span><span class="lineCov">          5 :   if (!file) {</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :     AliFatal(Form(&quot;Failed to open magnetic field data file %s\n&quot;,fname)); </span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     195 </span>            :   //
<span class="lineNum">     196 </span><span class="lineCov">         15 :   fMeasuredMap = dynamic_cast&lt;AliMagWrapCheb*&gt;(file-&gt;Get(GetParamName()));</span>
<span class="lineNum">     197 </span><span class="lineCov">          5 :   if (!fMeasuredMap) {</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :     AliFatal(Form(&quot;Did not find field %s in %s\n&quot;,GetParamName(),fname)); </span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     200 </span><span class="lineCov">          5 :   file-&gt;Close();</span>
<span class="lineNum">     201 </span><span class="lineCov">         10 :   delete file;</span>
<span class="lineNum">     202 </span><span class="lineCov">          5 :   return kTRUE;</span>
<span class="lineNum">     203 </span>            : }
<span class="lineNum">     204 </span>            : 
<a name="205"><span class="lineNum">     205 </span>            : </a>
<span class="lineNum">     206 </span>            : //_______________________________________________________________________
<span class="lineNum">     207 </span>            : void AliMagF::Field(const Double_t *xyz, Double_t *b)
<span class="lineNum">     208 </span>            : {
<span class="lineNum">     209 </span>            :   // Method to calculate the field at point  xyz
<span class="lineNum">     210 </span>            :   //
<span class="lineNum">     211 </span>            :   //  b[0]=b[1]=b[2]=0.0;
<span class="lineNum">     212 </span><span class="lineCov">   15867394 :   if (fMeasuredMap &amp;&amp; xyz[2]&gt;fMeasuredMap-&gt;GetMinZ() &amp;&amp; xyz[2]&lt;fMeasuredMap-&gt;GetMaxZ()) {</span>
<span class="lineNum">     213 </span><span class="lineCov">    2876176 :     fMeasuredMap-&gt;Field(xyz,b);</span>
<span class="lineNum">     214 </span><span class="lineCov">   28090408 :     if (xyz[2]&gt;fgkSol2DipZ || fDipoleOFF) for (int i=3;i--;) b[i] *= fFactorSol;</span>
<span class="lineNum">     215 </span><span class="lineCov">     671352 :     else                                  for (int i=3;i--;) b[i] *= fFactorDip;    </span>
<span class="lineNum">     216 </span>            :   }
<span class="lineNum">     217 </span><span class="lineCov">    1090874 :   else MachineField(xyz, b);</span>
<span class="lineNum">     218 </span>            :   //
<span class="lineNum">     219 </span><span class="lineCov">    3967050 : }</span>
<a name="220"><span class="lineNum">     220 </span>            : </a>
<span class="lineNum">     221 </span>            : //_______________________________________________________________________
<span class="lineNum">     222 </span>            : Double_t AliMagF::GetBz(const Double_t *xyz) const
<span class="lineNum">     223 </span>            : {
<span class="lineNum">     224 </span>            :   // Method to calculate the field at point  xyz
<span class="lineNum">     225 </span>            :   //
<span class="lineNum">     226 </span><span class="lineCov">    1189696 :   if (fMeasuredMap &amp;&amp; xyz[2]&gt;fMeasuredMap-&gt;GetMinZ() &amp;&amp; xyz[2]&lt;fMeasuredMap-&gt;GetMaxZ()) {</span>
<span class="lineNum">     227 </span><span class="lineCov">     297424 :     double bz = fMeasuredMap-&gt;GetBz(xyz);</span>
<span class="lineNum">     228 </span><span class="lineCov">     892272 :     return (xyz[2]&gt;fgkSol2DipZ || fDipoleOFF) ? bz*fFactorSol : bz*fFactorDip;    </span>
<span class="lineNum">     229 </span>            :   }
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :   else return 0.;</span>
<span class="lineNum">     231 </span><span class="lineCov">     297424 : }</span>
<a name="232"><span class="lineNum">     232 </span>            : </a>
<span class="lineNum">     233 </span>            : //_______________________________________________________________________
<span class="lineNum">     234 </span>            : AliMagF&amp; AliMagF::operator=(const AliMagF&amp; src)
<span class="lineNum">     235 </span>            : {
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :   if (this != &amp;src) {</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :     if (src.fMeasuredMap) { </span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :       if (fMeasuredMap) delete fMeasuredMap;</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :       fMeasuredMap = new AliMagWrapCheb(*src.fMeasuredMap);</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :     SetName(src.GetName());</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :     fSolenoid    = src.fSolenoid;</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :     fBeamType    = src.fBeamType;</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :     fBeamEnergy  = src.fBeamEnergy;</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :     fInteg       = src.fInteg;</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :     fPrecInteg   = src.fPrecInteg;</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :     fFactorSol   = src.fFactorSol;</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :     fFactorDip   = src.fFactorDip;</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :     fMax         = src.fMax;</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :     fDipoleOFF   = src.fDipoleOFF;</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :     fParNames    = src.fParNames;</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :   return *this;</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 : }</span>
<a name="255"><span class="lineNum">     255 </span>            : </a>
<span class="lineNum">     256 </span>            : //_______________________________________________________________________
<span class="lineNum">     257 </span>            : void AliMagF::InitMachineField(BeamType_t btype, Double_t benergy)
<span class="lineNum">     258 </span>            : {
<span class="lineNum">     259 </span><span class="lineCov">         10 :   if (btype==kNoBeamField) {</span>
<span class="lineNum">     260 </span><span class="lineCov">          4 :     fQuadGradient = fDipoleField = fCCorrField = fACorr1Field = fACorr2Field = 0.;</span>
<span class="lineNum">     261 </span><span class="lineCov">          4 :     return;</span>
<span class="lineNum">     262 </span>            :   }
<span class="lineNum">     263 </span>            :   //
<span class="lineNum">     264 </span><span class="lineCov">          1 :   double rigScale = benergy/7000.;   // scale according to ratio of E/Enominal</span>
<span class="lineNum">     265 </span>            :   // for ions assume PbPb (with energy provided per nucleon) and account for A/Z
<span class="lineNum">     266 </span><span class="lineCov">          2 :   if (btype==kBeamTypeAA/* || btype==kBeamTypepA || btype==kBeamTypeAp */) rigScale *= 208./82.;</span>
<span class="lineNum">     267 </span>            :   // Attention: in p-Pb the energy recorded in the GRP is the PROTON energy, no rigidity
<span class="lineNum">     268 </span>            :   // rescaling is needed
<span class="lineNum">     269 </span>            :   //
<span class="lineNum">     270 </span><span class="lineCov">          1 :   fQuadGradient = 22.0002*rigScale;</span>
<span class="lineNum">     271 </span><span class="lineCov">          1 :   fDipoleField  = 37.8781*rigScale;</span>
<span class="lineNum">     272 </span>            :   //
<span class="lineNum">     273 </span>            :   // SIDE C
<span class="lineNum">     274 </span><span class="lineCov">          1 :   fCCorrField   = -9.6980;</span>
<span class="lineNum">     275 </span>            :   // SIDE A
<span class="lineNum">     276 </span><span class="lineCov">          1 :   fACorr1Field  = -13.2247;</span>
<span class="lineNum">     277 </span><span class="lineCov">          1 :   fACorr2Field  =  11.7905;</span>
<span class="lineNum">     278 </span>            :   //
<span class="lineNum">     279 </span><span class="lineCov">          6 : }</span>
<a name="280"><span class="lineNum">     280 </span>            : </a>
<span class="lineNum">     281 </span>            : //_______________________________________________________________________
<span class="lineNum">     282 </span>            : void AliMagF::MachineField(const Double_t *x, Double_t *b) const
<span class="lineNum">     283 </span>            : {
<span class="lineNum">     284 </span>            :   // ---- This is the ZDC part
<span class="lineNum">     285 </span>            :   // Compansators for Alice Muon Arm Dipole
<span class="lineNum">     286 </span>            :   const Double_t kBComp1CZ = 1075., kBComp1hDZ = 260./2., kBComp1SqR = 4.0*4.0; 
<span class="lineNum">     287 </span>            :   const Double_t kBComp2CZ = 2049., kBComp2hDZ = 153./2., kBComp2SqR = 4.5*4.5; 
<span class="lineNum">     288 </span>            :   //  
<span class="lineNum">     289 </span>            :   const Double_t kTripQ1CZ = 2615., kTripQ1hDZ = 637./2., kTripQ1SqR = 3.5*3.5;
<span class="lineNum">     290 </span>            :   const Double_t kTripQ2CZ = 3480., kTripQ2hDZ = 550./2., kTripQ2SqR = 3.5*3.5;
<span class="lineNum">     291 </span>            :   const Double_t kTripQ3CZ = 4130., kTripQ3hDZ = 550./2., kTripQ3SqR = 3.5*3.5;
<span class="lineNum">     292 </span>            :   const Double_t kTripQ4CZ = 5015., kTripQ4hDZ = 637./2., kTripQ4SqR = 3.5*3.5;
<span class="lineNum">     293 </span>            :   //
<span class="lineNum">     294 </span>            :   const Double_t kDip1CZ = 6310.8,  kDip1hDZ = 945./2., kDip1SqRC = 4.5*4.5, kDip1SqRA = 3.375*3.375;
<span class="lineNum">     295 </span>            :   const Double_t kDip2CZ = 12640.3, kDip2hDZ = 945./2., kDip2SqRC = 4.5*4.5, kDip2SqRA = 3.75*3.75;
<span class="lineNum">     296 </span>            :   const Double_t kDip2DXC = 9.7, kDip2DXA = 9.4;
<span class="lineNum">     297 </span>            :   //
<span class="lineNum">     298 </span><span class="lineCov">    2181748 :   double rad2 = x[0] * x[0] + x[1] * x[1];</span>
<span class="lineNum">     299 </span>            :   //
<span class="lineNum">     300 </span><span class="lineCov">    1090874 :   b[0] = b[1] = b[2] = 0;</span>
<span class="lineNum">     301 </span>            :   //
<span class="lineNum">     302 </span>            :   // SIDE C **************************************************
<span class="lineNum">     303 </span><span class="lineCov">    1090874 :   if(x[2]&lt;0.){  </span>
<span class="lineNum">     304 </span><span class="lineCov">        806 :     if(TMath::Abs(x[2]+kBComp2CZ)&lt;kBComp2hDZ &amp;&amp; rad2 &lt; kBComp2SqR){</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :       b[0] = fCCorrField*fFactorDip;</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :     } </span>
<span class="lineNum">     307 </span><span class="lineCov">        806 :     else if(TMath::Abs(x[2]+kTripQ1CZ)&lt;kTripQ1hDZ &amp;&amp; rad2 &lt; kTripQ1SqR){</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :       b[0] = fQuadGradient*x[1];</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :       b[1] = fQuadGradient*x[0];</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     311 </span><span class="lineCov">        806 :     else if(TMath::Abs(x[2]+kTripQ2CZ)&lt;kTripQ2hDZ &amp;&amp; rad2 &lt; kTripQ2SqR){</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :       b[0] = -fQuadGradient*x[1];</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :       b[1] = -fQuadGradient*x[0];</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     315 </span><span class="lineCov">        806 :     else if(TMath::Abs(x[2]+kTripQ3CZ)&lt;kTripQ3hDZ &amp;&amp; rad2 &lt; kTripQ3SqR){</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :       b[0] = -fQuadGradient*x[1];</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :       b[1] = -fQuadGradient*x[0];</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     319 </span><span class="lineCov">        806 :     else if(TMath::Abs(x[2]+kTripQ4CZ)&lt;kTripQ4hDZ &amp;&amp; rad2 &lt; kTripQ4SqR){</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :       b[0] = fQuadGradient*x[1];</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :       b[1] = fQuadGradient*x[0];</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     323 </span><span class="lineCov">        806 :     else if(TMath::Abs(x[2]+kDip1CZ)&lt;kDip1hDZ &amp;&amp; rad2 &lt; kDip1SqRC){</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :       b[1] = fDipoleField;</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     326 </span><span class="lineCov">        806 :     else if(TMath::Abs(x[2]+kDip2CZ)&lt;kDip2hDZ &amp;&amp; rad2 &lt; kDip2SqRC) {</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :       double dxabs = TMath::Abs(x[0])-kDip2DXC;</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :       if ( (dxabs*dxabs + x[1]*x[1])&lt;kDip2SqRC) {</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :         b[1] = -fDipoleField;</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     332 </span>            :   }
<span class="lineNum">     333 </span>            :   //
<span class="lineNum">     334 </span>            :   // SIDE A **************************************************
<span class="lineNum">     335 </span>            :   else{        
<span class="lineNum">     336 </span><span class="lineCov">    1090068 :     if(TMath::Abs(x[2]-kBComp1CZ)&lt;kBComp1hDZ &amp;&amp; rad2 &lt; kBComp1SqR) {</span>
<span class="lineNum">     337 </span>            :       // Compensator magnet at z = 1075 m 
<span class="lineNum">     338 </span><span class="lineCov">       7228 :       b[0] = fACorr1Field*fFactorDip;</span>
<span class="lineNum">     339 </span><span class="lineCov">       7228 :     }</span>
<span class="lineNum">     340 </span>            :     //
<span class="lineNum">     341 </span><span class="lineCov">    1090068 :     if(TMath::Abs(x[2]-kBComp2CZ)&lt;kBComp2hDZ &amp;&amp; rad2 &lt; kBComp2SqR){</span>
<span class="lineNum">     342 </span><span class="lineCov">         61 :       b[0] = fACorr2Field*fFactorDip;</span>
<span class="lineNum">     343 </span><span class="lineCov">         61 :     }</span>
<span class="lineNum">     344 </span><span class="lineCov">    1090007 :     else if(TMath::Abs(x[2]-kTripQ1CZ)&lt;kTripQ1hDZ &amp;&amp; rad2 &lt; kTripQ1SqR){</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :       b[0] = -fQuadGradient*x[1];</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :       b[1] = -fQuadGradient*x[0];</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     348 </span><span class="lineCov">    1090007 :     else if(TMath::Abs(x[2]-kTripQ2CZ)&lt;kTripQ2hDZ &amp;&amp; rad2 &lt; kTripQ2SqR){</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :       b[0] =  fQuadGradient*x[1];</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :       b[1] =  fQuadGradient*x[0];</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     352 </span><span class="lineCov">    1090007 :     else if(TMath::Abs(x[2]-kTripQ3CZ)&lt;kTripQ3hDZ &amp;&amp; rad2 &lt; kTripQ3SqR){</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :       b[0] =  fQuadGradient*x[1];</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :       b[1] =  fQuadGradient*x[0];</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     356 </span><span class="lineCov">    1090007 :     else if(TMath::Abs(x[2]-kTripQ4CZ)&lt;kTripQ4hDZ &amp;&amp; rad2 &lt; kTripQ4SqR){</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :       b[0] = -fQuadGradient*x[1];</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :       b[1] = -fQuadGradient*x[0];</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     360 </span><span class="lineCov">    1090007 :     else if(TMath::Abs(x[2]-kDip1CZ)&lt;kDip1hDZ &amp;&amp; rad2 &lt; kDip1SqRA){</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :       b[1] = -fDipoleField;</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     363 </span><span class="lineCov">    1090007 :     else if(TMath::Abs(x[2]-kDip2CZ)&lt;kDip2hDZ &amp;&amp; rad2 &lt; kDip2SqRA) {</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :       double dxabs = TMath::Abs(x[0])-kDip2DXA;</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :       if ( (dxabs*dxabs + x[1]*x[1])&lt;kDip2SqRA) {</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :         b[1] = fDipoleField;</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     369 </span>            :   }
<span class="lineNum">     370 </span>            :   //
<span class="lineNum">     371 </span><span class="lineCov">    1090874 : }</span>
<a name="372"><span class="lineNum">     372 </span>            : </a>
<span class="lineNum">     373 </span>            : //_______________________________________________________________________
<span class="lineNum">     374 </span>            : void AliMagF::GetTPCInt(const Double_t *xyz, Double_t *b) const
<span class="lineNum">     375 </span>            : {
<span class="lineNum">     376 </span>            :   // Method to calculate the integral_0^z of br,bt,bz 
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :   b[0]=b[1]=b[2]=0.0;</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :   if (fMeasuredMap) {</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :     fMeasuredMap-&gt;GetTPCInt(xyz,b);</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :     for (int i=3;i--;) b[i] *= fFactorSol;</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 : }</span>
<a name="383"><span class="lineNum">     383 </span>            : </a>
<span class="lineNum">     384 </span>            : //_______________________________________________________________________
<span class="lineNum">     385 </span>            : void AliMagF::GetTPCRatInt(const Double_t *xyz, Double_t *b) const
<span class="lineNum">     386 </span>            : {
<span class="lineNum">     387 </span>            :   // Method to calculate the integral_0^z of bx/bz,by/bz and (bx/bz)^2+(by/bz)^2
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :   b[0]=b[1]=b[2]=0.0;</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :   if (fMeasuredMap) {</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :     fMeasuredMap-&gt;GetTPCRatInt(xyz,b);</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :     b[2] /= 100;</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 : }</span>
<a name="394"><span class="lineNum">     394 </span>            : </a>
<span class="lineNum">     395 </span>            : //_______________________________________________________________________
<span class="lineNum">     396 </span>            : void AliMagF::GetTPCIntCyl(const Double_t *rphiz, Double_t *b) const
<span class="lineNum">     397 </span>            : {
<span class="lineNum">     398 </span>            :   // Method to calculate the integral_0^z of br,bt,bz 
<span class="lineNum">     399 </span>            :   // in cylindrical coordiates ( -pi&lt;phi&lt;pi convention )
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :   b[0]=b[1]=b[2]=0.0;</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :   if (fMeasuredMap) {</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :     fMeasuredMap-&gt;GetTPCIntCyl(rphiz,b);</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :     for (int i=3;i--;) b[i] *= fFactorSol;</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 : }</span>
<a name="406"><span class="lineNum">     406 </span>            : </a>
<span class="lineNum">     407 </span>            : //_______________________________________________________________________
<span class="lineNum">     408 </span>            : void AliMagF::GetTPCRatIntCyl(const Double_t *rphiz, Double_t *b) const
<span class="lineNum">     409 </span>            : {
<span class="lineNum">     410 </span>            :   // Method to calculate the integral_0^z of bx/bz,by/bz and (bx/bz)^2+(by/bz)^2
<span class="lineNum">     411 </span>            :   // in cylindrical coordiates ( -pi&lt;phi&lt;pi convention )
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :   b[0]=b[1]=b[2]=0.0;</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :   if (fMeasuredMap) {</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :     fMeasuredMap-&gt;GetTPCRatIntCyl(rphiz,b);</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :     b[2] /= 100;</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 : }</span>
<a name="418"><span class="lineNum">     418 </span>            : </a>
<span class="lineNum">     419 </span>            : //_______________________________________________________________________
<span class="lineNum">     420 </span>            : void AliMagF::SetFactorSol(Float_t fc)
<span class="lineNum">     421 </span>            : {
<span class="lineNum">     422 </span>            :   // set the sign/scale of the current in the L3 according to fgkPolarityConvention
<span class="lineNum">     423 </span>            :   switch (fgkPolarityConvention) {
<span class="lineNum">     424 </span>            :   case kConvDCS2008: fFactorSol = -fc; break;
<span class="lineNum">     425 </span><span class="lineCov">         10 :   case kConvLHC    : fFactorSol = -fc; break;</span>
<span class="lineNum">     426 </span>            :   default          : fFactorSol =  fc; break;  // case kConvMap2005: fFactorSol =  fc; break;
<span class="lineNum">     427 </span>            :   }
<span class="lineNum">     428 </span><span class="lineCov">          5 : }</span>
<a name="429"><span class="lineNum">     429 </span>            : </a>
<span class="lineNum">     430 </span>            : //_______________________________________________________________________
<span class="lineNum">     431 </span>            : void AliMagF::SetFactorDip(Float_t fc)
<span class="lineNum">     432 </span>            : {
<span class="lineNum">     433 </span>            :   // set the sign*scale of the current in the Dipole according to fgkPolarityConvention
<span class="lineNum">     434 </span>            :   switch (fgkPolarityConvention) {
<span class="lineNum">     435 </span>            :   case kConvDCS2008: fFactorDip =  fc; break;
<span class="lineNum">     436 </span><span class="lineCov">         10 :   case kConvLHC    : fFactorDip = -fc; break;</span>
<span class="lineNum">     437 </span>            :   default          : fFactorDip =  fc; break;  // case kConvMap2005: fFactorDip =  fc; break;
<span class="lineNum">     438 </span>            :   }
<span class="lineNum">     439 </span><span class="lineCov">          5 : }</span>
<a name="440"><span class="lineNum">     440 </span>            : </a>
<span class="lineNum">     441 </span>            : //_______________________________________________________________________
<span class="lineNum">     442 </span>            : Double_t AliMagF::GetFactorSol() const
<span class="lineNum">     443 </span>            : {
<span class="lineNum">     444 </span>            :   // return the sign*scale of the current in the Dipole according to fgkPolarityConventionthe 
<span class="lineNum">     445 </span>            :   switch (fgkPolarityConvention) {
<span class="lineNum">     446 </span>            :   case kConvDCS2008: return -fFactorSol;
<span class="lineNum">     447 </span><span class="lineCov">         44 :   case kConvLHC    : return -fFactorSol;</span>
<span class="lineNum">     448 </span>            :   default          : return  fFactorSol;       //  case kConvMap2005: return  fFactorSol;
<span class="lineNum">     449 </span>            :   }
<span class="lineNum">     450 </span>            : }
<a name="451"><span class="lineNum">     451 </span>            : </a>
<span class="lineNum">     452 </span>            : //_______________________________________________________________________
<span class="lineNum">     453 </span>            : Double_t AliMagF::GetFactorDip() const
<span class="lineNum">     454 </span>            : {
<span class="lineNum">     455 </span>            :   // return the sign*scale of the current in the Dipole according to fgkPolarityConventionthe 
<span class="lineNum">     456 </span>            :   switch (fgkPolarityConvention) {
<span class="lineNum">     457 </span>            :   case kConvDCS2008: return  fFactorDip;
<span class="lineNum">     458 </span><span class="lineCov">         44 :   case kConvLHC    : return -fFactorDip;</span>
<span class="lineNum">     459 </span>            :   default          : return  fFactorDip;       //  case kConvMap2005: return  fFactorDip;
<span class="lineNum">     460 </span>            :   }
<span class="lineNum">     461 </span>            : }
<a name="462"><span class="lineNum">     462 </span>            : </a>
<span class="lineNum">     463 </span>            : //_____________________________________________________________________________
<span class="lineNum">     464 </span>            : AliMagF* AliMagF::CreateFieldMap(Float_t l3Cur, Float_t diCur, Int_t convention, Bool_t uniform,
<span class="lineNum">     465 </span>            :                                  Float_t beamenergy, const Char_t *beamtype, const Char_t *path,
<span class="lineNum">     466 </span>            :                                  Bool_t returnNULLOnInvalidCurrent) 
<span class="lineNum">     467 </span>            : {
<span class="lineNum">     468 </span>            :   //------------------------------------------------
<span class="lineNum">     469 </span>            :   // The magnetic field map, defined externally...
<span class="lineNum">     470 </span>            :   // L3 current 30000 A  -&gt; 0.5 T
<span class="lineNum">     471 </span>            :   // L3 current 12000 A  -&gt; 0.2 T
<span class="lineNum">     472 </span>            :   // dipole current 6000 A
<span class="lineNum">     473 </span>            :   // The polarities must match the convention (LHC or DCS2008) 
<span class="lineNum">     474 </span>            :   // unless the special uniform map was used for MC
<span class="lineNum">     475 </span>            :   //------------------------------------------------
<span class="lineNum">     476 </span><span class="lineCov">          4 :   AliLog::EType_t error_type = returnNULLOnInvalidCurrent ? AliLog::kError : AliLog::kFatal;</span>
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            :   const Float_t l3NominalCurrent1=30000.; // (A)
<span class="lineNum">     479 </span>            :   const Float_t l3NominalCurrent2=12000.; // (A)
<span class="lineNum">     480 </span>            :   const Float_t diNominalCurrent =6000. ; // (A)
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span>            :   const Float_t tolerance=0.03; // relative current tolerance
<span class="lineNum">     483 </span>            :   const Float_t zero=77.;       // &quot;zero&quot; current (A)
<span class="lineNum">     484 </span>            :   //
<span class="lineNum">     485 </span>            :   BMap_t map = k5kG;
<span class="lineNum">     486 </span>            :   double sclL3,sclDip;
<span class="lineNum">     487 </span>            :   //
<span class="lineNum">     488 </span><span class="lineCov">          4 :   Float_t l3Pol = l3Cur &gt; 0 ? 1:-1;</span>
<span class="lineNum">     489 </span><span class="lineCov">          4 :   Float_t diPol = diCur &gt; 0 ? 1:-1;</span>
<span class="lineNum">     490 </span>            :  
<span class="lineNum">     491 </span><span class="lineCov">          4 :   l3Cur = TMath::Abs(l3Cur);</span>
<span class="lineNum">     492 </span><span class="lineCov">          4 :   diCur = TMath::Abs(diCur);</span>
<span class="lineNum">     493 </span>            :   //
<span class="lineNum">     494 </span><span class="lineCov">          4 :   if (TMath::Abs((sclDip=diCur/diNominalCurrent)-1.) &gt; tolerance &amp;&amp; !uniform) {</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :     if (diCur &lt;= zero) sclDip = 0.; // some small current.. -&gt; Dipole OFF</span>
<span class="lineNum">     496 </span>            :     else {
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :       AliMessageGeneral(&quot;AliMagF&quot;,error_type,Form(&quot;Wrong dipole current (%f A)!&quot;,diCur));</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">     499 </span>            :     }
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     501 </span>            :   //
<span class="lineNum">     502 </span><span class="lineCov">          4 :   if (uniform) { </span>
<span class="lineNum">     503 </span>            :     // special treatment of special MC with uniform mag field (normalized to 0.5 T)
<span class="lineNum">     504 </span>            :     // no check for scaling/polarities are done
<span class="lineNum">     505 </span>            :     map   = k5kGUniform;
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :     sclL3 = l3Cur/l3NominalCurrent1; </span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     508 </span>            :   else {
<span class="lineNum">     509 </span><span class="lineCov">          8 :     if      (TMath::Abs((sclL3=l3Cur/l3NominalCurrent1)-1.) &lt; tolerance) map  = k5kG;</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :     else if (TMath::Abs((sclL3=l3Cur/l3NominalCurrent2)-1.) &lt; tolerance) map  = k2kG;</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :     else if (l3Cur &lt;= zero &amp;&amp; diCur&lt;=zero)   { sclL3=0; sclDip=0; map  = k5kGUniform;}</span>
<span class="lineNum">     512 </span>            :     else {
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :       AliMessageGeneral(&quot;AliMagF&quot;,error_type,Form(&quot;Wrong L3 current (%f A)!&quot;,l3Cur));</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">     515 </span>            :     }
<span class="lineNum">     516 </span>            :   }
<span class="lineNum">     517 </span>            :   //
<span class="lineNum">     518 </span><span class="lineCov">          4 :   if (sclDip!=0 &amp;&amp; map!=k5kGUniform) {</span>
<span class="lineNum">     519 </span><span class="lineCov">         16 :     if ( (l3Cur&lt;=zero) || ((convention==kConvLHC &amp;&amp; l3Pol!=diPol) || (convention==kConvDCS2008 &amp;&amp; l3Pol==diPol)) ) { </span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :       AliMessageGeneral(&quot;AliMagF&quot;,error_type,Form(&quot;Wrong combination for L3/Dipole polarities (%c/%c) for convention %d&quot;,</span>
<span class="lineNum">     521 </span>            :                                      l3Pol&gt;0?'+':'-',diPol&gt;0?'+':'-',GetPolarityConvention()));
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">     523 </span>            :     }
<span class="lineNum">     524 </span>            :   }
<span class="lineNum">     525 </span>            :   //
<span class="lineNum">     526 </span><span class="lineCov">          8 :   if (l3Pol&lt;0) sclL3  = -sclL3;</span>
<span class="lineNum">     527 </span><span class="lineCov">          8 :   if (diPol&lt;0) sclDip = -sclDip;</span>
<span class="lineNum">     528 </span>            :   //
<span class="lineNum">     529 </span>            :   BeamType_t btype = kNoBeamField;
<span class="lineNum">     530 </span><span class="lineCov">          4 :   TString btypestr = beamtype;</span>
<span class="lineNum">     531 </span><span class="lineCov">          4 :   btypestr.ToLower();</span>
<span class="lineNum">     532 </span><span class="lineCov">         12 :   TPRegexp protonBeam(&quot;(proton|p)\\s*-?\\s*\\1&quot;);</span>
<span class="lineNum">     533 </span><span class="lineCov">         12 :   TPRegexp ionBeam(&quot;(lead|pb|ion|a|A)\\s*-?\\s*\\1&quot;);</span>
<span class="lineNum">     534 </span><span class="lineCov">         12 :   TPRegexp protonionBeam(&quot;(proton|p)\\s*-?\\s*(lead|pb|ion|a|A)&quot;);</span>
<span class="lineNum">     535 </span><span class="lineCov">         12 :   TPRegexp ionprotonBeam(&quot;(lead|pb|ion|a|A)\\s*-?\\s*(proton|p)&quot;);</span>
<span class="lineNum">     536 </span><span class="lineCov">          8 :   if (btypestr.Contains(ionBeam)) btype = kBeamTypeAA;</span>
<span class="lineNum">     537 </span><span class="lineCov">          8 :   else if (btypestr.Contains(protonBeam)) btype = kBeamTypepp;</span>
<span class="lineNum">     538 </span><span class="lineCov">          8 :   else if (btypestr.Contains(protonionBeam)) btype = kBeamTypepA;</span>
<span class="lineNum">     539 </span><span class="lineCov">          8 :   else if (btypestr.Contains(ionprotonBeam)) btype = kBeamTypeAp;</span>
<span class="lineNum">     540 </span><span class="lineCov">          8 :   else AliInfoGeneral(&quot;AliMagF&quot;,Form(&quot;Assume no LHC magnet field for the beam type %s, &quot;,beamtype));</span>
<span class="lineNum">     541 </span><span class="lineCov">          4 :   char ttl[80];</span>
<span class="lineNum">     542 </span><span class="lineCov">          8 :   snprintf(ttl,79,&quot;L3: %+5d Dip: %+4d kA; %s | Polarities in %s convention&quot;,(int)TMath::Sign(l3Cur,float(sclL3)),</span>
<span class="lineNum">     543 </span><span class="lineCov">          4 :           (int)TMath::Sign(diCur,float(sclDip)),uniform ? &quot; Constant&quot;:&quot;&quot;,</span>
<span class="lineNum">     544 </span><span class="lineCov">          4 :           convention==kConvLHC ? &quot;LHC&quot;:&quot;DCS2008&quot;);</span>
<span class="lineNum">     545 </span>            :   // LHC and DCS08 conventions have opposite dipole polarities
<span class="lineNum">     546 </span><span class="lineCov">          4 :   if ( GetPolarityConvention() != convention) sclDip = -sclDip;</span>
<span class="lineNum">     547 </span>            :   //
<span class="lineNum">     548 </span><span class="lineCov">          8 :   return new AliMagF(&quot;MagneticFieldMap&quot;, ttl,sclL3,sclDip,map,btype,beamenergy,2,10.,path);</span>
<span class="lineNum">     549 </span>            :   //
<span class="lineNum">     550 </span><span class="lineCov">          8 : }</span>
<a name="551"><span class="lineNum">     551 </span>            : </a>
<span class="lineNum">     552 </span>            : //_____________________________________________________________________________
<span class="lineNum">     553 </span>            : const char*  AliMagF::GetBeamTypeText() const
<span class="lineNum">     554 </span>            : {
<span class="lineNum">     555 </span>            :   // beam type in text form
<span class="lineNum">     556 </span>            :   const char *beamNA  = &quot;No Beam&quot;;
<span class="lineNum">     557 </span>            :   const char *beamPP  = &quot;p-p&quot;;
<span class="lineNum">     558 </span>            :   const char *beamPbPb= &quot;A-A&quot;;
<span class="lineNum">     559 </span>            :   const char *beamPPb = &quot;p-A&quot;;
<span class="lineNum">     560 </span>            :   const char *beamPbP = &quot;A-p&quot;;
<span class="lineNum">     561 </span><span class="lineCov">         10 :   switch ( fBeamType ) {</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :   case kBeamTypepp : return beamPP;</span>
<span class="lineNum">     563 </span><span class="lineCov">          1 :   case kBeamTypeAA : return beamPbPb;</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :   case kBeamTypepA : return beamPPb;</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :   case kBeamTypeAp : return beamPbP;</span>
<span class="lineNum">     566 </span>            :   case kNoBeamField: 
<span class="lineNum">     567 </span><span class="lineCov">          4 :   default:           return beamNA;</span>
<span class="lineNum">     568 </span>            :   }
<span class="lineNum">     569 </span><span class="lineCov">          5 : }</span>
<a name="570"><span class="lineNum">     570 </span>            : </a>
<span class="lineNum">     571 </span>            : //_____________________________________________________________________________
<span class="lineNum">     572 </span>            : void AliMagF::Print(Option_t *opt) const
<span class="lineNum">     573 </span>            : {
<span class="lineNum">     574 </span>            :   // print short or long info
<span class="lineNum">     575 </span><span class="lineCov">         10 :   TString opts = opt; opts.ToLower();</span>
<span class="lineNum">     576 </span><span class="lineCov">         25 :   AliInfo(Form(&quot;%s:%s&quot;,GetName(),GetTitle()));</span>
<span class="lineNum">     577 </span><span class="lineCov">         20 :   AliInfo(Form(&quot;Solenoid (%+.2f*)%.0f kG, Dipole %s (%+.2f) %s&quot;,</span>
<span class="lineNum">     578 </span>            :                GetFactorSol(),(fMapType==k5kG||fMapType==k5kGUniform)?5.:2.,
<span class="lineNum">     579 </span>            :                fDipoleOFF ? &quot;OFF&quot;:&quot;ON&quot;,GetFactorDip(),fMapType==k5kGUniform?&quot; |Constant Field!&quot;:&quot;&quot;));
<span class="lineNum">     580 </span><span class="lineCov">         10 :   if (opts.Contains(&quot;a&quot;)) {</span>
<span class="lineNum">     581 </span><span class="lineCov">         15 :     AliInfo(Form(&quot;Machine B fields for %s beam (%.0f GeV): QGrad: %.4f Dipole: %.4f&quot;,</span>
<span class="lineNum">     582 </span>            :                  GetBeamTypeText(),
<span class="lineNum">     583 </span>            :                  fBeamEnergy,fQuadGradient,fDipoleField));
<span class="lineNum">     584 </span><span class="lineCov">         25 :     AliInfo(Form(&quot;Uses %s of %s&quot;,GetParamName(),GetDataFileName()));</span>
<span class="lineNum">     585 </span>            :   }
<span class="lineNum">     586 </span><span class="lineCov">          5 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
