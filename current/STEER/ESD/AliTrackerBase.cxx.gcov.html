<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - STEER/ESD/AliTrackerBase.cxx</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">STEER/ESD</a> - AliTrackerBase.cxx<span style="font-size: 80%;"> (source / <a href="AliTrackerBase.cxx.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">247</td>
            <td class="headerCovTableEntry">464</td>
            <td class="headerCovTableEntryLo">53.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">12</td>
            <td class="headerCovTableEntry">22</td>
            <td class="headerCovTableEntryLo">54.5 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**************************************************************************</a>
<span class="lineNum">       2 </span>            :  * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
<span class="lineNum">       3 </span>            :  *                                                                        *
<span class="lineNum">       4 </span>            :  * Author: The ALICE Off-line Project.                                    *
<span class="lineNum">       5 </span>            :  * Contributors are mentioned in the code where appropriate.              *
<span class="lineNum">       6 </span>            :  *                                                                        *
<span class="lineNum">       7 </span>            :  * Permission to use, copy, modify and distribute this software and its   *
<span class="lineNum">       8 </span>            :  * documentation strictly for non-commercial purposes is hereby granted   *
<span class="lineNum">       9 </span>            :  * without fee, provided that the above copyright notice appears in all   *
<span class="lineNum">      10 </span>            :  * copies and that both the copyright notice and this permission notice   *
<span class="lineNum">      11 </span>            :  * appear in the supporting documentation. The authors make no claims     *
<span class="lineNum">      12 </span>            :  * about the suitability of this software for any purpose. It is          *
<span class="lineNum">      13 </span>            :  * provided &quot;as is&quot; without express or implied warranty.                  *
<span class="lineNum">      14 </span>            :  **************************************************************************/
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : /* $Id: AliTrackerBase.cxx 38069 2009-12-24 16:56:18Z belikov $ */
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : //-------------------------------------------------------------------------
<span class="lineNum">      19 </span>            : //               Implementation of the AliTrackerBase class
<span class="lineNum">      20 </span>            : //                that is the base for the AliTracker class    
<span class="lineNum">      21 </span>            : //                     Origin: Marian.Ivanov@cern.ch
<span class="lineNum">      22 </span>            : //-------------------------------------------------------------------------
<span class="lineNum">      23 </span>            : #include &lt;TClass.h&gt;
<span class="lineNum">      24 </span>            : #include &lt;TMath.h&gt;
<span class="lineNum">      25 </span>            : #include &lt;TGeoManager.h&gt;
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : #include &quot;AliLog.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;AliTrackerBase.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;AliExternalTrackParam.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;AliTrackPointArray.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;TVectorD.h&quot;
<span class="lineNum">      32 </span>            : 
<a name="33"><span class="lineNum">      33 </span>            : extern TGeoManager *gGeoManager;</a>
<span class="lineNum">      34 </span>            : 
<a name="35"><span class="lineNum">      35 </span><span class="lineCov">        172 : ClassImp(AliTrackerBase)</span></a>
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : AliTrackerBase::AliTrackerBase():
<span class="lineNum">      38 </span><span class="lineCov">         16 :   TObject(),</span>
<span class="lineNum">      39 </span><span class="lineCov">         16 :   fX(0),</span>
<span class="lineNum">      40 </span><span class="lineCov">         16 :   fY(0),</span>
<span class="lineNum">      41 </span><span class="lineCov">         16 :   fZ(0),</span>
<span class="lineNum">      42 </span><span class="lineCov">         16 :   fSigmaX(0.005),</span>
<span class="lineNum">      43 </span><span class="lineCov">         16 :   fSigmaY(0.005),</span>
<span class="lineNum">      44 </span><span class="lineCov">         16 :   fSigmaZ(0.010)</span>
<span class="lineNum">      45 </span><span class="lineCov">         48 : {</span>
<span class="lineNum">      46 </span>            :   //--------------------------------------------------------------------
<span class="lineNum">      47 </span>            :   // The default constructor.
<span class="lineNum">      48 </span>            :   //--------------------------------------------------------------------
<span class="lineNum">      49 </span><span class="lineCov">         32 :   if (!TGeoGlobalMagField::Instance()-&gt;GetField())</span>
<span class="lineNum">      50 </span><span class="lineNoCov">          0 :     AliWarning(&quot;Field map is not set.&quot;);</span>
<span class="lineNum">      51 </span><span class="lineCov">         16 : }</span>
<a name="52"><span class="lineNum">      52 </span>            : </a>
<span class="lineNum">      53 </span>            : //__________________________________________________________________________
<span class="lineNum">      54 </span>            : AliTrackerBase::AliTrackerBase(const AliTrackerBase &amp;atr):
<span class="lineNum">      55 </span><span class="lineNoCov">          0 :   TObject(atr),</span>
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :   fX(atr.fX),</span>
<span class="lineNum">      57 </span><span class="lineNoCov">          0 :   fY(atr.fY),</span>
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :   fZ(atr.fZ),</span>
<span class="lineNum">      59 </span><span class="lineNoCov">          0 :   fSigmaX(atr.fSigmaX),</span>
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :   fSigmaY(atr.fSigmaY),</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :   fSigmaZ(atr.fSigmaZ)</span>
<span class="lineNum">      62 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">      63 </span>            :   //--------------------------------------------------------------------
<span class="lineNum">      64 </span>            :   // The default constructor.
<span class="lineNum">      65 </span>            :   //--------------------------------------------------------------------
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :   if (!TGeoGlobalMagField::Instance()-&gt;GetField())</span>
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :     AliWarning(&quot;Field map is not set.&quot;);</span>
<span class="lineNum">      68 </span><span class="lineNoCov">          0 : }</span>
<a name="69"><span class="lineNum">      69 </span>            : </a>
<span class="lineNum">      70 </span>            : //__________________________________________________________________________
<span class="lineNum">      71 </span>            : Double_t AliTrackerBase::GetBz()
<span class="lineNum">      72 </span>            : {
<span class="lineNum">      73 </span><span class="lineCov">     443666 :   AliMagF* fld = (AliMagF*)TGeoGlobalMagField::Instance()-&gt;GetField();</span>
<span class="lineNum">      74 </span><span class="lineCov">     221833 :   if (!fld) {</span>
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :     AliFatalClass(&quot;Field is not loaded&quot;);</span>
<span class="lineNum">      76 </span>            :     //if (!fld) 
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :     return  0.5*kAlmost0Field;</span>
<span class="lineNum">      78 </span>            :   }
<span class="lineNum">      79 </span><span class="lineCov">     221833 :   Double_t bz = fld-&gt;SolenoidField();</span>
<span class="lineNum">      80 </span><span class="lineCov">     221833 :   return TMath::Sign(0.5*kAlmost0Field,bz) + bz;</span>
<span class="lineNum">      81 </span><span class="lineCov">     221833 : }</span>
<a name="82"><span class="lineNum">      82 </span>            : </a>
<span class="lineNum">      83 </span>            : //__________________________________________________________________________
<span class="lineNum">      84 </span>            : Double_t AliTrackerBase::GetBz(const Double_t *r) {
<span class="lineNum">      85 </span>            :   //------------------------------------------------------------------
<span class="lineNum">      86 </span>            :   // Returns Bz (kG) at the point &quot;r&quot; .
<span class="lineNum">      87 </span>            :   //------------------------------------------------------------------
<span class="lineNum">      88 </span><span class="lineCov">        184 :   AliMagF* fld = (AliMagF*)TGeoGlobalMagField::Instance()-&gt;GetField();</span>
<span class="lineNum">      89 </span><span class="lineCov">         92 :   if (!fld) {</span>
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :     AliFatalClass(&quot;Field is not loaded&quot;);</span>
<span class="lineNum">      91 </span>            :     //  if (!fld) 
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :     return  0.5*kAlmost0Field;</span>
<span class="lineNum">      93 </span>            :   }
<span class="lineNum">      94 </span><span class="lineCov">         92 :   Double_t bz = fld-&gt;GetBz(r);</span>
<span class="lineNum">      95 </span><span class="lineCov">         92 :   return  TMath::Sign(0.5*kAlmost0Field,bz) + bz;</span>
<span class="lineNum">      96 </span><span class="lineCov">         92 : }</span>
<a name="97"><span class="lineNum">      97 </span>            : </a>
<span class="lineNum">      98 </span>            : //__________________________________________________________________________
<span class="lineNum">      99 </span>            : void AliTrackerBase::GetBxByBz(const Double_t r[3], Double_t b[3]) {
<span class="lineNum">     100 </span>            :   //------------------------------------------------------------------
<span class="lineNum">     101 </span>            :   // Returns Bx, By and Bz (kG) at the point &quot;r&quot; .
<span class="lineNum">     102 </span>            :   //------------------------------------------------------------------
<span class="lineNum">     103 </span><span class="lineCov">      42150 :   AliMagF* fld = (AliMagF*)TGeoGlobalMagField::Instance()-&gt;GetField();</span>
<span class="lineNum">     104 </span><span class="lineCov">      21075 :   if (!fld) {</span>
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :     AliFatalClass(&quot;Field is not loaded&quot;);</span>
<span class="lineNum">     106 </span>            :     // b[0] = b[1] = 0.;
<span class="lineNum">     107 </span>            :     // b[2] = 0.5*kAlmost0Field;
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     109 </span>            :   }
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span><span class="lineCov">      21075 :   if (fld-&gt;IsUniform()) {</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :      b[0] = b[1] = 0.;</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :      b[2] = fld-&gt;SolenoidField();</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :   }  else {</span>
<span class="lineNum">     115 </span><span class="lineCov">      21075 :      fld-&gt;Field(r,b);</span>
<span class="lineNum">     116 </span>            :   }
<span class="lineNum">     117 </span><span class="lineCov">      21075 :   b[2] = (TMath::Sign(0.5*kAlmost0Field,b[2]) + b[2]);</span>
<span class="lineNum">     118 </span><span class="lineCov">      21075 :   return;</span>
<a name="119"><span class="lineNum">     119 </span><span class="lineCov">      21075 : }</span></a>
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            : Double_t AliTrackerBase::MeanMaterialBudget(const Double_t *start, const Double_t *end, Double_t *mparam)
<span class="lineNum">     122 </span>            : {
<span class="lineNum">     123 </span>            :   // 
<span class="lineNum">     124 </span>            :   // Calculate mean material budget and material properties between 
<span class="lineNum">     125 </span>            :   //    the points &quot;start&quot; and &quot;end&quot;.
<span class="lineNum">     126 </span>            :   //
<span class="lineNum">     127 </span>            :   // &quot;mparam&quot; - parameters used for the energy and multiple scattering
<span class="lineNum">     128 </span>            :   //  corrections: 
<span class="lineNum">     129 </span>            :   //
<span class="lineNum">     130 </span>            :   // mparam[0] - mean density: sum(x_i*rho_i)/sum(x_i) [g/cm3]
<span class="lineNum">     131 </span>            :   // mparam[1] - equivalent rad length fraction: sum(x_i/X0_i) [adimensional]
<span class="lineNum">     132 </span>            :   // mparam[2] - mean A: sum(x_i*A_i)/sum(x_i) [adimensional]
<span class="lineNum">     133 </span>            :   // mparam[3] - mean Z: sum(x_i*Z_i)/sum(x_i) [adimensional]
<span class="lineNum">     134 </span>            :   // mparam[4] - length: sum(x_i) [cm]
<span class="lineNum">     135 </span>            :   // mparam[5] - Z/A mean: sum(x_i*Z_i/A_i)/sum(x_i) [adimensional]
<span class="lineNum">     136 </span>            :   // mparam[6] - number of boundary crosses
<span class="lineNum">     137 </span>            :   //
<span class="lineNum">     138 </span>            :   //  Origin:  Marian Ivanov, Marian.Ivanov@cern.ch
<span class="lineNum">     139 </span>            :   //
<span class="lineNum">     140 </span>            :   //  Corrections and improvements by
<span class="lineNum">     141 </span>            :   //        Andrea Dainese, Andrea.Dainese@lnl.infn.it,
<span class="lineNum">     142 </span>            :   //        Andrei Gheata,  Andrei.Gheata@cern.ch
<span class="lineNum">     143 </span>            :   //
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span><span class="lineCov">     168648 :   mparam[0]=0; mparam[1]=1; mparam[2] =0; mparam[3] =0;</span>
<span class="lineNum">     146 </span><span class="lineCov">      84324 :   mparam[4]=0; mparam[5]=0; mparam[6]=0;</span>
<span class="lineNum">     147 </span>            :   //
<span class="lineNum">     148 </span><span class="lineCov">      84324 :   Double_t bparam[6]; // total parameters</span>
<span class="lineNum">     149 </span>            :   Double_t lparam[6]; // local parameters
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span><span class="lineCov">    1180536 :   for (Int_t i=0;i&lt;6;i++) bparam[i]=0;</span>
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span><span class="lineCov">      84324 :   if (!gGeoManager) {</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :     AliFatalClass(&quot;No TGeo\n&quot;);</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :     return 0.;</span>
<span class="lineNum">     156 </span>            :   }
<span class="lineNum">     157 </span>            :   //
<span class="lineNum">     158 </span>            :   Double_t length;
<span class="lineNum">     159 </span><span class="lineCov">      84324 :   Double_t dir[3];</span>
<span class="lineNum">     160 </span><span class="lineCov">     252972 :   length = TMath::Sqrt((end[0]-start[0])*(end[0]-start[0])+</span>
<span class="lineNum">     161 </span><span class="lineCov">     168648 :                        (end[1]-start[1])*(end[1]-start[1])+</span>
<span class="lineNum">     162 </span><span class="lineCov">      84324 :                        (end[2]-start[2])*(end[2]-start[2]));</span>
<span class="lineNum">     163 </span><span class="lineCov">      84324 :   mparam[4]=length;</span>
<span class="lineNum">     164 </span><span class="lineCov">      84324 :   if (length&lt;TGeoShape::Tolerance()) return 0.0;</span>
<span class="lineNum">     165 </span><span class="lineCov">      84324 :   Double_t invlen = 1./length;</span>
<span class="lineNum">     166 </span><span class="lineCov">      84324 :   dir[0] = (end[0]-start[0])*invlen;</span>
<span class="lineNum">     167 </span><span class="lineCov">      84324 :   dir[1] = (end[1]-start[1])*invlen;</span>
<span class="lineNum">     168 </span><span class="lineCov">      84324 :   dir[2] = (end[2]-start[2])*invlen;</span>
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span>            :   // Initialize start point and direction
<span class="lineNum">     171 </span>            :   TGeoNode *currentnode = 0;
<span class="lineNum">     172 </span><span class="lineCov">      84324 :   TGeoNode *startnode = gGeoManager-&gt;InitTrack(start, dir);</span>
<span class="lineNum">     173 </span><span class="lineCov">      84324 :   if (!startnode) {</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :     AliDebugClass(1,Form(&quot;start point out of geometry: x %f, y %f, z %f&quot;,</span>
<span class="lineNum">     175 </span>            :                          start[0],start[1],start[2]));
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :     return 0.0;</span>
<span class="lineNum">     177 </span>            :   }
<span class="lineNum">     178 </span><span class="lineCov">      84324 :   TGeoMaterial *material = startnode-&gt;GetVolume()-&gt;GetMedium()-&gt;GetMaterial();</span>
<span class="lineNum">     179 </span><span class="lineCov">      84324 :   lparam[0]   = material-&gt;GetDensity();</span>
<span class="lineNum">     180 </span><span class="lineCov">      84324 :   lparam[1]   = material-&gt;GetRadLen();</span>
<span class="lineNum">     181 </span><span class="lineCov">      84324 :   lparam[2]   = material-&gt;GetA();</span>
<span class="lineNum">     182 </span><span class="lineCov">      84324 :   lparam[3]   = material-&gt;GetZ();</span>
<span class="lineNum">     183 </span>            :   lparam[4]   = length;
<span class="lineNum">     184 </span><span class="lineCov">      84324 :   lparam[5]   = lparam[3]/lparam[2];</span>
<span class="lineNum">     185 </span><span class="lineCov">      84324 :   if (material-&gt;IsMixture()) {</span>
<span class="lineNum">     186 </span><span class="lineCov">      79878 :     TGeoMixture * mixture = (TGeoMixture*)material;</span>
<span class="lineNum">     187 </span>            :     lparam[5] =0;
<span class="lineNum">     188 </span>            :     Double_t sum =0;
<span class="lineNum">     189 </span><span class="lineCov">     752396 :     for (Int_t iel=0;iel&lt;mixture-&gt;GetNelements();iel++){</span>
<span class="lineNum">     190 </span><span class="lineCov">     296320 :       sum  += mixture-&gt;GetWmixt()[iel];</span>
<span class="lineNum">     191 </span><span class="lineCov">     296320 :       lparam[5]+= mixture-&gt;GetZmixt()[iel]*mixture-&gt;GetWmixt()[iel]/mixture-&gt;GetAmixt()[iel];</span>
<span class="lineNum">     192 </span>            :     }
<span class="lineNum">     193 </span><span class="lineCov">      79878 :     lparam[5]/=sum;</span>
<span class="lineNum">     194 </span><span class="lineCov">      79878 :   }</span>
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span>            :   // Locate next boundary within length without computing safety.
<span class="lineNum">     197 </span>            :   // Propagate either with length (if no boundary found) or just cross boundary
<span class="lineNum">     198 </span><span class="lineCov">      84324 :   gGeoManager-&gt;FindNextBoundaryAndStep(length, kFALSE);</span>
<span class="lineNum">     199 </span>            :   Double_t step = 0.0; // Step made
<span class="lineNum">     200 </span><span class="lineCov">      84324 :   Double_t snext = gGeoManager-&gt;GetStep();</span>
<span class="lineNum">     201 </span>            :   // If no boundary within proposed length, return current density
<span class="lineNum">     202 </span><span class="lineCov">      84324 :   if (!gGeoManager-&gt;IsOnBoundary()) {</span>
<span class="lineNum">     203 </span><span class="lineCov">      44934 :     mparam[0] = lparam[0];</span>
<span class="lineNum">     204 </span><span class="lineCov">      44934 :     mparam[1] = lparam[4]/lparam[1];</span>
<span class="lineNum">     205 </span><span class="lineCov">      44934 :     mparam[2] = lparam[2];</span>
<span class="lineNum">     206 </span><span class="lineCov">      44934 :     mparam[3] = lparam[3];</span>
<span class="lineNum">     207 </span><span class="lineCov">      44934 :     mparam[4] = lparam[4];</span>
<span class="lineNum">     208 </span><span class="lineCov">      44934 :     return lparam[0];</span>
<span class="lineNum">     209 </span>            :   }
<span class="lineNum">     210 </span>            :   // Try to cross the boundary and see what is next
<span class="lineNum">     211 </span>            :   Int_t nzero = 0;
<span class="lineNum">     212 </span><span class="lineCov">     819686 :   while (length&gt;TGeoShape::Tolerance()) {</span>
<span class="lineNum">     213 </span><span class="lineCov">     409843 :     currentnode = gGeoManager-&gt;GetCurrentNode();</span>
<span class="lineNum">     214 </span><span class="lineCov">     409878 :     if (snext&lt;2.*TGeoShape::Tolerance()) nzero++;</span>
<span class="lineNum">     215 </span>            :     else nzero = 0;
<span class="lineNum">     216 </span><span class="lineCov">     409843 :     if (nzero&gt;3) {</span>
<span class="lineNum">     217 </span>            :       // This means navigation has problems on one boundary
<span class="lineNum">     218 </span>            :       // Try to cross by making a small step
<span class="lineNum">     219 </span><span class="lineCov">          5 :       static int show_error = !(getenv(&quot;HLT_ONLINE_MODE&quot;) &amp;&amp; strcmp(getenv(&quot;HLT_ONLINE_MODE&quot;), &quot;on&quot;) == 0);</span>
<span class="lineNum">     220 </span><span class="lineCov">          2 :       if (show_error) AliErrorClass(&quot;Cannot cross boundary\n&quot;);</span>
<span class="lineNum">     221 </span><span class="lineCov">          1 :       mparam[0] = bparam[0]/step;</span>
<span class="lineNum">     222 </span><span class="lineCov">          1 :       mparam[1] = bparam[1];</span>
<span class="lineNum">     223 </span><span class="lineCov">          1 :       mparam[2] = bparam[2]/step;</span>
<span class="lineNum">     224 </span><span class="lineCov">          1 :       mparam[3] = bparam[3]/step;</span>
<span class="lineNum">     225 </span><span class="lineCov">          1 :       mparam[5] = bparam[5]/step;</span>
<span class="lineNum">     226 </span><span class="lineCov">          1 :       mparam[4] = step;</span>
<span class="lineNum">     227 </span><span class="lineCov">          1 :       mparam[0] = 0.;             // if crash of navigation take mean density 0</span>
<span class="lineNum">     228 </span><span class="lineCov">          1 :       mparam[1] = 1000000;        // and infinite rad length</span>
<span class="lineNum">     229 </span><span class="lineCov">          1 :       return bparam[0]/step;</span>
<span class="lineNum">     230 </span>            :     }
<span class="lineNum">     231 </span><span class="lineCov">     409842 :     mparam[6]+=1.;</span>
<span class="lineNum">     232 </span><span class="lineCov">     409842 :     step += snext;</span>
<span class="lineNum">     233 </span><span class="lineCov">     409842 :     bparam[1]    += snext/lparam[1];</span>
<span class="lineNum">     234 </span><span class="lineCov">     409842 :     bparam[2]    += snext*lparam[2];</span>
<span class="lineNum">     235 </span><span class="lineCov">     409842 :     bparam[3]    += snext*lparam[3];</span>
<span class="lineNum">     236 </span><span class="lineCov">     409842 :     bparam[5]    += snext*lparam[5];</span>
<span class="lineNum">     237 </span><span class="lineCov">     409842 :     bparam[0]    += snext*lparam[0];</span>
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span><span class="lineCov">     819684 :     if (snext&gt;=length) break;</span>
<span class="lineNum">     240 </span><span class="lineCov">     409842 :     if (!currentnode) break;</span>
<span class="lineNum">     241 </span><span class="lineCov">     370453 :     length -= snext;</span>
<span class="lineNum">     242 </span><span class="lineCov">     370453 :     material = currentnode-&gt;GetVolume()-&gt;GetMedium()-&gt;GetMaterial();</span>
<span class="lineNum">     243 </span><span class="lineCov">     370453 :     lparam[0] = material-&gt;GetDensity();</span>
<span class="lineNum">     244 </span><span class="lineCov">     370453 :     lparam[1]  = material-&gt;GetRadLen();</span>
<span class="lineNum">     245 </span><span class="lineCov">     370453 :     lparam[2]  = material-&gt;GetA();</span>
<span class="lineNum">     246 </span><span class="lineCov">     370453 :     lparam[3]  = material-&gt;GetZ();</span>
<span class="lineNum">     247 </span><span class="lineCov">     370453 :     lparam[5]   = lparam[3]/lparam[2];</span>
<span class="lineNum">     248 </span><span class="lineCov">     370453 :     if (material-&gt;IsMixture()) {</span>
<span class="lineNum">     249 </span><span class="lineCov">     276793 :       TGeoMixture * mixture = (TGeoMixture*)material;</span>
<span class="lineNum">     250 </span>            :       lparam[5]=0;
<span class="lineNum">     251 </span>            :       Double_t sum =0;
<span class="lineNum">     252 </span><span class="lineCov">    2705222 :       for (Int_t iel=0;iel&lt;mixture-&gt;GetNelements();iel++){</span>
<span class="lineNum">     253 </span><span class="lineCov">    1075818 :         sum+= mixture-&gt;GetWmixt()[iel];</span>
<span class="lineNum">     254 </span><span class="lineCov">    1075818 :         lparam[5]+= mixture-&gt;GetZmixt()[iel]*mixture-&gt;GetWmixt()[iel]/mixture-&gt;GetAmixt()[iel];</span>
<span class="lineNum">     255 </span>            :       }
<span class="lineNum">     256 </span><span class="lineCov">     276793 :       lparam[5]/=sum;</span>
<span class="lineNum">     257 </span><span class="lineCov">     276793 :     }</span>
<span class="lineNum">     258 </span><span class="lineCov">     370453 :     gGeoManager-&gt;FindNextBoundaryAndStep(length, kFALSE);</span>
<span class="lineNum">     259 </span><span class="lineCov">     370453 :     snext = gGeoManager-&gt;GetStep();</span>
<span class="lineNum">     260 </span>            :   }
<span class="lineNum">     261 </span><span class="lineCov">      39389 :   mparam[0] = bparam[0]/step;</span>
<span class="lineNum">     262 </span><span class="lineCov">      39389 :   mparam[1] = bparam[1];</span>
<span class="lineNum">     263 </span><span class="lineCov">      39389 :   mparam[2] = bparam[2]/step;</span>
<span class="lineNum">     264 </span><span class="lineCov">      39389 :   mparam[3] = bparam[3]/step;</span>
<span class="lineNum">     265 </span><span class="lineCov">      39389 :   mparam[5] = bparam[5]/step;</span>
<span class="lineNum">     266 </span><span class="lineCov">      39389 :   return bparam[0]/step;</span>
<span class="lineNum">     267 </span><span class="lineCov">     168648 : }</span>
<span class="lineNum">     268 </span>            : 
<a name="269"><span class="lineNum">     269 </span>            : </a>
<span class="lineNum">     270 </span>            : Bool_t 
<span class="lineNum">     271 </span>            : AliTrackerBase::PropagateTrackTo(AliExternalTrackParam *track, Double_t xToGo, 
<span class="lineNum">     272 </span>            :                                  Double_t mass, Double_t maxStep, Bool_t rotateTo, Double_t maxSnp, Int_t sign, Bool_t addTimeStep, Bool_t correctMaterialBudget){
<span class="lineNum">     273 </span>            :   //----------------------------------------------------------------
<span class="lineNum">     274 </span>            :   //
<span class="lineNum">     275 </span>            :   // Propagates the track to the plane X=xk (cm) using the magnetic field map 
<span class="lineNum">     276 </span>            :   // and correcting for the crossed material.
<span class="lineNum">     277 </span>            :   //
<span class="lineNum">     278 </span>            :   // mass     - mass used in propagation - used for energy loss correction (if &lt;0 then q = 2)
<span class="lineNum">     279 </span>            :   // maxStep  - maximal step for propagation
<span class="lineNum">     280 </span>            :   //
<span class="lineNum">     281 </span>            :   //  Origin: Marian Ivanov,  Marian.Ivanov@cern.ch
<span class="lineNum">     282 </span>            :   //
<span class="lineNum">     283 </span>            :   //----------------------------------------------------------------
<span class="lineNum">     284 </span>            :   const Double_t kEpsilon = 0.00001;
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :   Double_t xpos     = track-&gt;GetX();</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :   Int_t dir         = (xpos&lt;xToGo) ? 1:-1;</span>
<span class="lineNum">     287 </span>            :   //
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :   while ( (xToGo-xpos)*dir &gt; kEpsilon){</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :     Double_t step = dir*TMath::Min(TMath::Abs(xToGo-xpos), maxStep);</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :     Double_t x    = xpos+step;</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :     Double_t xyz0[3],xyz1[3],param[7];</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :     track-&gt;GetXYZ(xyz0);   //starting global position</span>
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :     Double_t bz=GetBz(xyz0); // getting the local Bz</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :     if (!track-&gt;GetXYZAt(x,bz,xyz1)) return kFALSE;   // no prolongation</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :     xyz1[2]+=kEpsilon; // waiting for bug correction in geo</span>
<span class="lineNum">     297 </span>            :     
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :     if (maxSnp&gt;0 &amp;&amp; TMath::Abs(track-&gt;GetSnpAt(x,bz)) &gt;= maxSnp) return kFALSE;</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :     if (!track-&gt;PropagateTo(x,bz))  return kFALSE;</span>
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :     if (correctMaterialBudget){</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :       MeanMaterialBudget(xyz0,xyz1,param);</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :       Double_t xrho=param[0]*param[4], xx0=param[1];</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :       if (sign) {if (sign&lt;0) xrho = -xrho;}  // sign is imposed</span>
<span class="lineNum">     305 </span>            :       else { // determine automatically the sign from direction
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :         if (dir&gt;0) xrho = -xrho; // outward should be negative</span>
<span class="lineNum">     307 </span>            :       }
<span class="lineNum">     308 </span>            :       //
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :       if (!track-&gt;CorrectForMeanMaterial(xx0,xrho,mass)) return kFALSE;</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     311 </span>            :     
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :     if (rotateTo){</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :       track-&gt;GetXYZ(xyz1);   // global position</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :       Double_t alphan = TMath::ATan2(xyz1[1], xyz1[0]); </span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :       if (maxSnp&gt;0) {</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :         if (TMath::Abs(track-&gt;GetSnp()) &gt;= maxSnp) return kFALSE;</span>
<span class="lineNum">     317 </span>            :         
<span class="lineNum">     318 </span>            :         //
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :         Double_t ca=TMath::Cos(alphan-track-&gt;GetAlpha()), sa=TMath::Sin(alphan-track-&gt;GetAlpha());</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :         Double_t sf=track-&gt;GetSnp(), cf=TMath::Sqrt((1.-sf)*(1.+sf));</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :         Double_t sinNew =  sf*ca - cf*sa;</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :         if (TMath::Abs(sinNew) &gt;= maxSnp) return kFALSE;</span>
<span class="lineNum">     323 </span>            :         
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :       if (!track-&gt;AliExternalTrackParam::Rotate(alphan)) return kFALSE;</span>
<span class="lineNum">     326 </span>            :       
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :     xpos = track-&gt;GetX();</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :     if (addTimeStep &amp;&amp; track-&gt;IsStartedTimeIntegral()) {</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :       if (!rotateTo) track-&gt;GetXYZ(xyz1); // if rotateTo==kTRUE, then xyz1 is already extracted</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :       Double_t dX=xyz0[0]-xyz1[0],dY=xyz0[1]-xyz1[1],dZ=xyz0[2]-xyz1[2]; </span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :       Double_t d=TMath::Sqrt(dX*dX + dY*dY + dZ*dZ);</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :       if (sign) {if (sign&gt;0) d = -d;}  // step sign is imposed, positive means inward direction</span>
<span class="lineNum">     334 </span>            :       else { // determine automatically the sign from direction
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :         if (dir&lt;0) d = -d;</span>
<span class="lineNum">     336 </span>            :       }
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :       track-&gt;AddTimeStep(d);</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :   return kTRUE;</span>
<a name="341"><span class="lineNum">     341 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span>            : Bool_t AliTrackerBase::PropagateTrackParamOnlyTo(AliExternalTrackParam *track, Double_t xToGo,Double_t maxStep, Bool_t rotateTo, Double_t maxSnp)
<span class="lineNum">     344 </span>            : {
<span class="lineNum">     345 </span>            :   //----------------------------------------------------------------
<span class="lineNum">     346 </span>            :   //
<span class="lineNum">     347 </span>            :   // Propagates in fixed step size the track params ONLY to the plane X=xk (cm) using the magnetic field map 
<span class="lineNum">     348 </span>            :   // W/O correcting for the crossed material.
<span class="lineNum">     349 </span>            :   // maxStep  - maximal step for propagation
<span class="lineNum">     350 </span>            :   //
<span class="lineNum">     351 </span>            :   //----------------------------------------------------------------
<span class="lineNum">     352 </span>            :   const Double_t kEpsilon = 0.00001;
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :   double xpos = track-&gt;GetX();</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :   Int_t dir   = (xpos&lt;xToGo) ? 1:-1;</span>
<span class="lineNum">     355 </span>            :   //
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :   double xyz[3];</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :   track-&gt;GetXYZ(xyz);</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :   while ( (xToGo-xpos)*dir &gt; kEpsilon){</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :     Double_t step = dir*TMath::Min(TMath::Abs(xToGo-xpos), maxStep);</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :     Double_t x    = track-&gt;GetX()+step;</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :     Double_t bz=GetBz(xyz); // getting the local Bz</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :     if (!track-&gt;PropagateParamOnlyTo(x,bz))  return kFALSE;</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :     track-&gt;GetXYZ(xyz);   // global position</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :     if (rotateTo){</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :       Double_t alphan = TMath::ATan2(xyz[1], xyz[0]); </span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :       if (maxSnp&gt;0 &amp;&amp; TMath::Abs(track-&gt;GetSnp()) &gt;= maxSnp) return kFALSE;</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :       if (!track-&gt;AliExternalTrackParam::RotateParamOnly(alphan)) return kFALSE;      </span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :     xpos = track-&gt;GetX();</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :   return kTRUE;</span>
<a name="372"><span class="lineNum">     372 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            : Int_t AliTrackerBase::PropagateTrackTo2(AliExternalTrackParam *track, Double_t xToGo,
<span class="lineNum">     375 </span>            :                                         Double_t mass, Double_t maxStep, Bool_t rotateTo, Double_t maxSnp, Int_t sign, Bool_t addTimeStep, Bool_t correctMaterialBudget){
<span class="lineNum">     376 </span>            :   //----------------------------------------------------------------
<span class="lineNum">     377 </span>            :   //
<span class="lineNum">     378 </span>            :   // Propagates the track to the plane X=xk (cm) using the magnetic field map
<span class="lineNum">     379 </span>            :   // and correcting for the crossed material.
<span class="lineNum">     380 </span>            :   //
<span class="lineNum">     381 </span>            :   // mass     - mass used in propagation - used for energy loss correction
<span class="lineNum">     382 </span>            :   // maxStep  - maximal step for propagation
<span class="lineNum">     383 </span>            :   //
<span class="lineNum">     384 </span>            :   //  Origin: Marian Ivanov,  Marian.Ivanov@cern.ch
<span class="lineNum">     385 </span>            :   //
<span class="lineNum">     386 </span>            :   //----------------------------------------------------------------
<span class="lineNum">     387 </span>            :   const Double_t kEpsilon = 0.00001;
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :   Double_t xpos     = track-&gt;GetX();</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :   Int_t dir         = (xpos&lt;xToGo) ? 1:-1;</span>
<span class="lineNum">     390 </span>            :   //
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :   while ( (xToGo-xpos)*dir &gt; kEpsilon){</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :     Double_t step = dir*TMath::Min(TMath::Abs(xToGo-xpos), maxStep);</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :     Double_t x    = xpos+step;</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :     Double_t xyz0[3],xyz1[3],param[7];</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :     track-&gt;GetXYZ(xyz0);   //starting global position</span>
<span class="lineNum">     396 </span>            :     
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :     Double_t bz=GetBz(xyz0); // getting the local Bz</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :     if (!track-&gt;GetXYZAt(x,bz,xyz1)) return -1;   // no prolongation</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :     xyz1[2]+=kEpsilon; // waiting for bug correction in geo</span>
<span class="lineNum">     400 </span>            :     
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :     if (maxSnp&gt;0 &amp;&amp; TMath::Abs(track-&gt;GetSnpAt(x,bz)) &gt;= maxSnp) return -2;</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :     if (!track-&gt;PropagateTo(x,bz))  return -3;</span>
<span class="lineNum">     403 </span>            :     
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :     if (correctMaterialBudget){</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :       MeanMaterialBudget(xyz0,xyz1,param);</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :       Double_t xrho=param[0]*param[4], xx0=param[1];</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :       if (sign) {if (sign&lt;0) xrho = -xrho;}  // sign is imposed</span>
<span class="lineNum">     408 </span>            :       else { // determine automatically the sign from direction
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :         if (dir&gt;0) xrho = -xrho; // outward should be negative</span>
<span class="lineNum">     410 </span>            :       }
<span class="lineNum">     411 </span>            :       //
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :       if (!track-&gt;CorrectForMeanMaterial(xx0,xrho,mass)) return -4;</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     414 </span>            :     
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :     if (rotateTo){</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :       track-&gt;GetXYZ(xyz1);   // global position</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :       Double_t alphan = TMath::ATan2(xyz1[1], xyz1[0]);</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :       if (maxSnp&gt;0) {</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :         if (TMath::Abs(track-&gt;GetSnp()) &gt;= maxSnp) return -5;</span>
<span class="lineNum">     420 </span>            :         
<span class="lineNum">     421 </span>            :         //
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :         Double_t ca=TMath::Cos(alphan-track-&gt;GetAlpha()), sa=TMath::Sin(alphan-track-&gt;GetAlpha());</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :         Double_t sf=track-&gt;GetSnp(), cf=TMath::Sqrt((1.-sf)*(1.+sf));</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :         Double_t sinNew =  sf*ca - cf*sa;</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :         if (TMath::Abs(sinNew) &gt;= maxSnp) return -6;</span>
<span class="lineNum">     426 </span>            :         
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :       if (!track-&gt;AliExternalTrackParam::Rotate(alphan)) return -7;</span>
<span class="lineNum">     429 </span>            :       
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :     xpos = track-&gt;GetX();</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :     if (addTimeStep &amp;&amp; track-&gt;IsStartedTimeIntegral()) {</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :       if (!rotateTo) track-&gt;GetXYZ(xyz1); // if rotateTo==kTRUE, then xyz1 is already extracted</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :       Double_t dX=xyz0[0]-xyz1[0],dY=xyz0[1]-xyz1[1],dZ=xyz0[2]-xyz1[2];</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :       Double_t d=TMath::Sqrt(dX*dX + dY*dY + dZ*dZ);</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :       if (sign) {if (sign&gt;0) d = -d;}  // step sign is imposed, positive means inward direction</span>
<span class="lineNum">     437 </span>            :       else { // determine automatically the sign from direction
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :         if (dir&lt;0) d = -d;</span>
<span class="lineNum">     439 </span>            :       }
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :       track-&gt;AddTimeStep(d);</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :   return 1;</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 : }</span>
<a name="445"><span class="lineNum">     445 </span>            : </a>
<span class="lineNum">     446 </span>            : Bool_t 
<span class="lineNum">     447 </span>            : AliTrackerBase::PropagateTrackToBxByBz(AliExternalTrackParam *track,
<span class="lineNum">     448 </span>            :                                        Double_t xToGo,Double_t mass, Double_t maxStep, Bool_t rotateTo, Double_t maxSnp,Int_t sign, Bool_t addTimeStep,
<span class="lineNum">     449 </span>            :                                        Bool_t correctMaterialBudget){
<span class="lineNum">     450 </span>            :   //----------------------------------------------------------------
<span class="lineNum">     451 </span>            :   //
<span class="lineNum">     452 </span>            :   // Propagates the track to the plane X=xk (cm)
<span class="lineNum">     453 </span>            :   // taking into account all the three components of the magnetic field 
<span class="lineNum">     454 </span>            :   // and correcting for the crossed material.
<span class="lineNum">     455 </span>            :   //
<span class="lineNum">     456 </span>            :   // mass     - mass used in propagation - used for energy loss correction (if &lt;0 then q=2)
<span class="lineNum">     457 </span>            :   // maxStep  - maximal step for propagation
<span class="lineNum">     458 </span>            :   //
<span class="lineNum">     459 </span>            :   //  Origin: Marian Ivanov,  Marian.Ivanov@cern.ch
<span class="lineNum">     460 </span>            :   //
<span class="lineNum">     461 </span>            :   //----------------------------------------------------------------
<span class="lineNum">     462 </span>            :   const Double_t kEpsilon = 0.00001;
<span class="lineNum">     463 </span><span class="lineCov">       2964 :   Double_t xpos     = track-&gt;GetX();</span>
<span class="lineNum">     464 </span><span class="lineCov">       2964 :   Int_t dir         = (xpos&lt;xToGo) ? 1:-1;</span>
<span class="lineNum">     465 </span>            :   //
<span class="lineNum">     466 </span><span class="lineCov">      21394 :   while ( (xToGo-xpos)*dir &gt; kEpsilon){</span>
<span class="lineNum">     467 </span><span class="lineCov">      15511 :     Double_t step = dir*TMath::Min(TMath::Abs(xToGo-xpos), maxStep);</span>
<span class="lineNum">     468 </span><span class="lineCov">      15511 :     Double_t x    = xpos+step;</span>
<span class="lineNum">     469 </span><span class="lineCov">      15511 :     Double_t xyz0[3],xyz1[3],param[7];</span>
<span class="lineNum">     470 </span><span class="lineCov">      15511 :     track-&gt;GetXYZ(xyz0);   //starting global position</span>
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span><span class="lineCov">      15511 :     Double_t b[3]; GetBxByBz(xyz0,b); // getting the local Bx, By and Bz</span>
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span><span class="lineCov">      15535 :     if (!track-&gt;GetXYZAt(x,b[2],xyz1)) return kFALSE;   // no prolongation</span>
<span class="lineNum">     475 </span><span class="lineCov">      15487 :     xyz1[2]+=kEpsilon; // waiting for bug correction in geo</span>
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span>            :     //    if (maxSnp&gt;0 &amp;&amp; TMath::Abs(track-&gt;GetSnpAt(x,b[2])) &gt;= maxSnp) return kFALSE;
<span class="lineNum">     478 </span><span class="lineCov">      15487 :     if (!track-&gt;PropagateToBxByBz(x,b))  return kFALSE;</span>
<span class="lineNum">     479 </span><span class="lineCov">      30992 :     if (maxSnp&gt;0 &amp;&amp; TMath::Abs(track-&gt;GetSnp())&gt;=maxSnp) return kFALSE;</span>
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span><span class="lineCov">      15469 :     if (correctMaterialBudget) {</span>
<span class="lineNum">     482 </span><span class="lineCov">      15469 :       MeanMaterialBudget(xyz0,xyz1,param);    </span>
<span class="lineNum">     483 </span><span class="lineCov">      15469 :       Double_t xrho=param[0]*param[4], xx0=param[1];</span>
<span class="lineNum">     484 </span><span class="lineCov">      36473 :       if (sign) {if (sign&lt;0) xrho = -xrho;}  // sign is imposed</span>
<span class="lineNum">     485 </span>            :       else { // determine automatically the sign from direction
<span class="lineNum">     486 </span><span class="lineCov">       3664 :         if (dir&gt;0) xrho = -xrho; // outward should be negative</span>
<span class="lineNum">     487 </span>            :       }    
<span class="lineNum">     488 </span>            :       //
<span class="lineNum">     489 </span><span class="lineCov">      15472 :       if (!track-&gt;CorrectForMeanMaterial(xx0,xrho,mass)) return kFALSE;</span>
<span class="lineNum">     490 </span><span class="lineCov">      15466 :     }</span>
<span class="lineNum">     491 </span><span class="lineCov">      15466 :     if (rotateTo){</span>
<span class="lineNum">     492 </span><span class="lineCov">       2585 :       track-&gt;GetXYZ(xyz1);   // global position</span>
<span class="lineNum">     493 </span><span class="lineCov">       2585 :       Double_t alphan = TMath::ATan2(xyz1[1], xyz1[0]); </span>
<span class="lineNum">     494 </span>            :       /*
<span class="lineNum">     495 </span>            :         if (maxSnp&gt;0) {
<span class="lineNum">     496 </span>            :         if (TMath::Abs(track-&gt;GetSnp()) &gt;= maxSnp) return kFALSE;
<span class="lineNum">     497 </span>            :         Double_t ca=TMath::Cos(alphan-track-&gt;GetAlpha()), sa=TMath::Sin(alphan-track-&gt;GetAlpha());
<span class="lineNum">     498 </span>            :         Double_t sf=track-&gt;GetSnp(), cf=TMath::Sqrt((1.-sf)*(1.+sf));
<span class="lineNum">     499 </span>            :         Double_t sinNew =  sf*ca - cf*sa;
<span class="lineNum">     500 </span>            :         if (TMath::Abs(sinNew) &gt;= maxSnp) return kFALSE;
<span class="lineNum">     501 </span>            :         }
<span class="lineNum">     502 </span>            :       */
<span class="lineNum">     503 </span><span class="lineCov">       2585 :       if (!track-&gt;AliExternalTrackParam::Rotate(alphan)) return kFALSE;</span>
<span class="lineNum">     504 </span><span class="lineCov">       5170 :       if (maxSnp&gt;0 &amp;&amp; TMath::Abs(track-&gt;GetSnp())&gt;=maxSnp) return kFALSE;</span>
<span class="lineNum">     505 </span><span class="lineCov">       2585 :     }</span>
<span class="lineNum">     506 </span><span class="lineCov">      15466 :     xpos = track-&gt;GetX();    </span>
<span class="lineNum">     507 </span><span class="lineCov">      15466 :     if (addTimeStep &amp;&amp; track-&gt;IsStartedTimeIntegral()) {</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :       if (!rotateTo) track-&gt;GetXYZ(xyz1); // if rotateTo==kTRUE, then xyz1 is already extracted</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :       Double_t dX=xyz0[0]-xyz1[0],dY=xyz0[1]-xyz1[1],dZ=xyz0[2]-xyz1[2]; </span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :       Double_t d=TMath::Sqrt(dX*dX + dY*dY + dZ*dZ);</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :       if (sign) {if (sign&gt;0) d = -d;}  // step sign is imposed, positive means inward direction</span>
<span class="lineNum">     512 </span>            :       else { // determine automatically the sign from direction
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :         if (dir&lt;0) d = -d;</span>
<span class="lineNum">     514 </span>            :       }
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :       track-&gt;AddTimeStep(d);</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     517 </span><span class="lineCov">      30977 :   }</span>
<span class="lineNum">     518 </span><span class="lineCov">       2919 :   return kTRUE;</span>
<a name="519"><span class="lineNum">     519 </span><span class="lineCov">       2964 : }</span></a>
<span class="lineNum">     520 </span>            : 
<span class="lineNum">     521 </span>            : Bool_t AliTrackerBase::PropagateTrackParamOnlyToBxByBz(AliExternalTrackParam *track,
<span class="lineNum">     522 </span>            :                                                        Double_t xToGo,Double_t maxStep, Bool_t rotateTo, Double_t maxSnp)
<span class="lineNum">     523 </span>            : {
<span class="lineNum">     524 </span>            :   //----------------------------------------------------------------
<span class="lineNum">     525 </span>            :   //
<span class="lineNum">     526 </span>            :   // Propagates in fixed step size the track params ONLY to the plane X=xk (cm) using the magnetic field map 
<span class="lineNum">     527 </span>            :   // W/O correcting for the crossed material.
<span class="lineNum">     528 </span>            :   // maxStep  - maximal step for propagation
<span class="lineNum">     529 </span>            :   //
<span class="lineNum">     530 </span>            :   //----------------------------------------------------------------
<span class="lineNum">     531 </span>            :   const Double_t kEpsilon = 0.00001;
<span class="lineNum">     532 </span><span class="lineCov">        406 :   Double_t xpos     = track-&gt;GetX();</span>
<span class="lineNum">     533 </span><span class="lineCov">        406 :   Int_t dir         = (xpos&lt;xToGo) ? 1:-1;</span>
<span class="lineNum">     534 </span><span class="lineCov">        406 :   Double_t xyz[3];</span>
<span class="lineNum">     535 </span><span class="lineCov">        406 :   track-&gt;GetXYZ(xyz);</span>
<span class="lineNum">     536 </span>            :   //
<span class="lineNum">     537 </span><span class="lineCov">       5952 :   while ( (xToGo-xpos)*dir &gt; kEpsilon){</span>
<span class="lineNum">     538 </span><span class="lineCov">       5196 :     Double_t step = dir*TMath::Min(TMath::Abs(xToGo-xpos), maxStep);</span>
<span class="lineNum">     539 </span><span class="lineCov">       5196 :     Double_t x    = xpos+step;</span>
<span class="lineNum">     540 </span><span class="lineCov">       5196 :     Double_t b[3]; GetBxByBz(xyz,b); // getting the local Bx, By and Bz</span>
<span class="lineNum">     541 </span><span class="lineCov">       5196 :     if (!track-&gt;PropagateParamOnlyBxByBzTo(x,b))  return kFALSE;</span>
<span class="lineNum">     542 </span><span class="lineCov">      10448 :     if (maxSnp&gt;0 &amp;&amp; TMath::Abs(track-&gt;GetSnp()) &gt;= maxSnp) return kFALSE;</span>
<span class="lineNum">     543 </span><span class="lineCov">       5140 :     track-&gt;GetXYZ(xyz);</span>
<span class="lineNum">     544 </span><span class="lineCov">       5140 :     if (rotateTo){</span>
<span class="lineNum">     545 </span><span class="lineCov">       5140 :       Double_t alphan = TMath::ATan2(xyz[1], xyz[0]); </span>
<span class="lineNum">     546 </span><span class="lineCov">       5140 :       if (!track-&gt;AliExternalTrackParam::Rotate(alphan)) return kFALSE;</span>
<span class="lineNum">     547 </span><span class="lineCov">       5140 :     }</span>
<span class="lineNum">     548 </span><span class="lineCov">       5140 :     xpos = track-&gt;GetX();    </span>
<span class="lineNum">     549 </span><span class="lineCov">      10336 :   }</span>
<span class="lineNum">     550 </span><span class="lineCov">        350 :   return kTRUE;</span>
<a name="551"><span class="lineNum">     551 </span><span class="lineCov">        406 : }</span></a>
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span>            : Double_t AliTrackerBase::GetTrackPredictedChi2(AliExternalTrackParam *track,
<span class="lineNum">     554 </span>            :                                            Double_t mass, Double_t step,
<span class="lineNum">     555 </span>            :                                      const AliExternalTrackParam *backup) {
<span class="lineNum">     556 </span>            :   //
<span class="lineNum">     557 </span>            :   // This function brings the &quot;track&quot; with particle &quot;mass&quot; [GeV] 
<span class="lineNum">     558 </span>            :   // to the same local coord. system and the same reference plane as 
<span class="lineNum">     559 </span>            :   // of the &quot;backup&quot;, doing it in &quot;steps&quot; [cm].
<span class="lineNum">     560 </span>            :   // Then, it calculates the 5D predicted Chi2 for these two tracks
<span class="lineNum">     561 </span>            :   //
<span class="lineNum">     562 </span>            :   Double_t chi2=kVeryBig;
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :   Double_t alpha=backup-&gt;GetAlpha();</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :   if (!track-&gt;Rotate(alpha)) return chi2;</span>
<span class="lineNum">     565 </span>            : 
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :   Double_t xb=backup-&gt;GetX();</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :   Double_t sign=(xb &lt; track-&gt;GetX()) ? 1. : -1.;</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :   if (!PropagateTrackTo(track,xb,mass,step,kFALSE,kAlmost1,sign)) return chi2;</span>
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :   chi2=track-&gt;GetPredictedChi2(backup);</span>
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :   return chi2;</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     574 </span>            : 
<span class="lineNum">     575 </span>            : 
<a name="576"><span class="lineNum">     576 </span>            : </a>
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span>            : Double_t AliTrackerBase::MakeC(Double_t x1,Double_t y1,
<span class="lineNum">     579 </span>            :                    Double_t x2,Double_t y2,
<span class="lineNum">     580 </span>            :                    Double_t x3,Double_t y3)
<span class="lineNum">     581 </span>            : {
<span class="lineNum">     582 </span>            :   //-----------------------------------------------------------------
<span class="lineNum">     583 </span>            :   // Initial approximation of the track curvature
<span class="lineNum">     584 </span>            :   //-----------------------------------------------------------------
<span class="lineNum">     585 </span><span class="lineCov">         32 :   x3 -=x1;</span>
<span class="lineNum">     586 </span><span class="lineCov">         16 :   x2 -=x1;</span>
<span class="lineNum">     587 </span><span class="lineCov">         16 :   y3 -=y1;</span>
<span class="lineNum">     588 </span><span class="lineCov">         16 :   y2 -=y1;</span>
<span class="lineNum">     589 </span>            :   //  
<span class="lineNum">     590 </span><span class="lineCov">         16 :   Double_t det = x3*y2-x2*y3;</span>
<span class="lineNum">     591 </span><span class="lineCov">         16 :   if (TMath::Abs(det)&lt;1e-10) {</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     593 </span>            :   }
<span class="lineNum">     594 </span>            :   //
<span class="lineNum">     595 </span><span class="lineCov">         16 :   Double_t u = 0.5* (x2*(x2-x3)+y2*(y2-y3))/det;</span>
<span class="lineNum">     596 </span><span class="lineCov">         16 :   Double_t x0 = x3*0.5-y3*u;</span>
<span class="lineNum">     597 </span><span class="lineCov">         16 :   Double_t y0 = y3*0.5+x3*u;</span>
<span class="lineNum">     598 </span><span class="lineCov">         16 :   Double_t c2 = 1/TMath::Sqrt(x0*x0+y0*y0);</span>
<span class="lineNum">     599 </span><span class="lineCov">         24 :   if (det&gt;0) c2*=-1;</span>
<span class="lineNum">     600 </span>            :   return c2;
<a name="601"><span class="lineNum">     601 </span><span class="lineCov">         16 : }</span></a>
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span>            : Double_t AliTrackerBase::MakeSnp(Double_t x1,Double_t y1,
<span class="lineNum">     604 </span>            :                    Double_t x2,Double_t y2,
<span class="lineNum">     605 </span>            :                    Double_t x3,Double_t y3)
<span class="lineNum">     606 </span>            : {
<span class="lineNum">     607 </span>            :   //-----------------------------------------------------------------
<span class="lineNum">     608 </span>            :   // Initial approximation of the track snp
<span class="lineNum">     609 </span>            :   //-----------------------------------------------------------------
<span class="lineNum">     610 </span><span class="lineCov">         32 :   x3 -=x1;</span>
<span class="lineNum">     611 </span><span class="lineCov">         16 :   x2 -=x1;</span>
<span class="lineNum">     612 </span><span class="lineCov">         16 :   y3 -=y1;</span>
<span class="lineNum">     613 </span><span class="lineCov">         16 :   y2 -=y1;</span>
<span class="lineNum">     614 </span>            :   //  
<span class="lineNum">     615 </span><span class="lineCov">         16 :   Double_t det = x3*y2-x2*y3;</span>
<span class="lineNum">     616 </span><span class="lineCov">         16 :   if (TMath::Abs(det)&lt;1e-10) {</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     618 </span>            :   }
<span class="lineNum">     619 </span>            :   //
<span class="lineNum">     620 </span><span class="lineCov">         16 :   Double_t u = 0.5* (x2*(x2-x3)+y2*(y2-y3))/det;</span>
<span class="lineNum">     621 </span><span class="lineCov">         16 :   Double_t x0 = x3*0.5-y3*u; </span>
<span class="lineNum">     622 </span><span class="lineCov">         16 :   Double_t y0 = y3*0.5+x3*u;</span>
<span class="lineNum">     623 </span><span class="lineCov">         16 :   Double_t c2 = 1./TMath::Sqrt(x0*x0+y0*y0);</span>
<span class="lineNum">     624 </span><span class="lineCov">         16 :   x0*=c2;</span>
<span class="lineNum">     625 </span><span class="lineCov">         16 :   x0=TMath::Abs(x0);</span>
<span class="lineNum">     626 </span><span class="lineCov">         28 :   if (y2*x2&lt;0.) x0*=-1;</span>
<span class="lineNum">     627 </span>            :   return x0;
<a name="628"><span class="lineNum">     628 </span><span class="lineCov">         16 : }</span></a>
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span>            : Double_t AliTrackerBase::MakeTgl(Double_t x1,Double_t y1,
<span class="lineNum">     631 </span>            :                    Double_t x2,Double_t y2,
<span class="lineNum">     632 </span>            :                    Double_t z1,Double_t z2, Double_t c)
<span class="lineNum">     633 </span>            : {
<span class="lineNum">     634 </span>            :   //-----------------------------------------------------------------
<span class="lineNum">     635 </span>            :   // Initial approximation of the tangent of the track dip angle
<span class="lineNum">     636 </span>            :   //-----------------------------------------------------------------
<span class="lineNum">     637 </span>            :   //
<span class="lineNum">     638 </span>            :   const Double_t kEpsilon =0.00001;
<span class="lineNum">     639 </span><span class="lineCov">         24 :   x2-=x1;</span>
<span class="lineNum">     640 </span><span class="lineCov">         12 :   y2-=y1;</span>
<span class="lineNum">     641 </span><span class="lineCov">         12 :   z2-=z1;</span>
<span class="lineNum">     642 </span><span class="lineCov">         12 :   Double_t d  =  TMath::Sqrt(x2*x2+y2*y2);  // distance  straight line</span>
<span class="lineNum">     643 </span><span class="lineCov">         12 :   if (TMath::Abs(d*c*0.5)&gt;1) return 0;</span>
<span class="lineNum">     644 </span><span class="lineCov">         12 :   Double_t   angle2    = TMath::ASin(d*c*0.5); </span>
<span class="lineNum">     645 </span><span class="lineCov">         12 :   if (TMath::Abs(angle2)&gt;kEpsilon)  {</span>
<span class="lineNum">     646 </span><span class="lineCov">         12 :     angle2  = z2*TMath::Abs(c/(angle2*2.));</span>
<span class="lineNum">     647 </span><span class="lineCov">         12 :   }else{</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :     angle2=z2/d;</span>
<span class="lineNum">     649 </span>            :   }
<span class="lineNum">     650 </span>            :   return angle2;
<span class="lineNum">     651 </span><span class="lineCov">         12 : }</span>
<a name="652"><span class="lineNum">     652 </span>            : </a>
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span>            : Double_t AliTrackerBase::MakeTgl(Double_t x1,Double_t y1, 
<span class="lineNum">     655 </span>            :                    Double_t x2,Double_t y2,
<span class="lineNum">     656 </span>            :                    Double_t z1,Double_t z2) 
<span class="lineNum">     657 </span>            : {
<span class="lineNum">     658 </span>            :   //-----------------------------------------------------------------
<span class="lineNum">     659 </span>            :   // Initial approximation of the tangent of the track dip angle
<span class="lineNum">     660 </span>            :   //-----------------------------------------------------------------
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :   return (z1 - z2)/sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));</span>
<span class="lineNum">     662 </span>            : }
<a name="663"><span class="lineNum">     663 </span>            : </a>
<span class="lineNum">     664 </span>            : 
<span class="lineNum">     665 </span>            : AliExternalTrackParam * AliTrackerBase::MakeSeed( AliTrackPoint &amp;point0, AliTrackPoint &amp;point1, AliTrackPoint &amp;point2){
<span class="lineNum">     666 </span>            :   //
<span class="lineNum">     667 </span>            :   // Make Seed  - AliExternalTrackParam from input 3 points   
<span class="lineNum">     668 </span>            :   // returning seed in local frame of point0
<span class="lineNum">     669 </span>            :   //
<span class="lineNum">     670 </span>            :   Double_t xyz0[3]={0,0,0};
<span class="lineNum">     671 </span>            :   Double_t xyz1[3]={0,0,0};
<span class="lineNum">     672 </span>            :   Double_t xyz2[3]={0,0,0};
<span class="lineNum">     673 </span><span class="lineCov">          8 :   Double_t alpha=point0.GetAngle();</span>
<span class="lineNum">     674 </span><span class="lineCov">          4 :   Double_t xyz[3]={point0.GetX(),point0.GetY(),point0.GetZ()};</span>
<span class="lineNum">     675 </span><span class="lineCov">          4 :   Double_t bxyz[3]; GetBxByBz(xyz,bxyz); </span>
<span class="lineNum">     676 </span><span class="lineCov">          4 :   Double_t bz = bxyz[2];</span>
<span class="lineNum">     677 </span>            :   //
<span class="lineNum">     678 </span>            :   // get points in frame of point 0
<span class="lineNum">     679 </span>            :   //
<span class="lineNum">     680 </span><span class="lineCov">          4 :   AliTrackPoint p0r = point0.Rotate(alpha);</span>
<span class="lineNum">     681 </span><span class="lineCov">          8 :   AliTrackPoint p1r = point1.Rotate(alpha);</span>
<span class="lineNum">     682 </span><span class="lineCov">          8 :   AliTrackPoint p2r = point2.Rotate(alpha);</span>
<span class="lineNum">     683 </span><span class="lineCov">          4 :   xyz0[0]=p0r.GetX();</span>
<span class="lineNum">     684 </span><span class="lineCov">          4 :   xyz0[1]=p0r.GetY();</span>
<span class="lineNum">     685 </span><span class="lineCov">          4 :   xyz0[2]=p0r.GetZ();</span>
<span class="lineNum">     686 </span><span class="lineCov">          4 :   xyz1[0]=p1r.GetX();</span>
<span class="lineNum">     687 </span><span class="lineCov">          4 :   xyz1[1]=p1r.GetY();</span>
<span class="lineNum">     688 </span><span class="lineCov">          4 :   xyz1[2]=p1r.GetZ();</span>
<span class="lineNum">     689 </span><span class="lineCov">          4 :   xyz2[0]=p2r.GetX();</span>
<span class="lineNum">     690 </span><span class="lineCov">          4 :   xyz2[1]=p2r.GetY();</span>
<span class="lineNum">     691 </span><span class="lineCov">          4 :   xyz2[2]=p2r.GetZ();</span>
<span class="lineNum">     692 </span>            :   //
<span class="lineNum">     693 </span>            :   // make covariance estimate
<span class="lineNum">     694 </span>            :   //  
<span class="lineNum">     695 </span><span class="lineCov">          4 :   Double_t covar[15];</span>
<span class="lineNum">     696 </span><span class="lineCov">          4 :   Double_t param[5]={0,0,0,0,0};</span>
<span class="lineNum">     697 </span><span class="lineCov">        128 :   for (Int_t m=0; m&lt;15; m++) covar[m]=0;</span>
<span class="lineNum">     698 </span>            :   //
<span class="lineNum">     699 </span>            :   // calculate intitial param
<span class="lineNum">     700 </span><span class="lineCov">          4 :   param[0]=xyz0[1];              </span>
<span class="lineNum">     701 </span><span class="lineCov">          4 :   param[1]=xyz0[2];</span>
<span class="lineNum">     702 </span><span class="lineCov">          8 :   param[2]=MakeSnp(xyz0[0],xyz0[1],xyz1[0],xyz1[1],xyz2[0],xyz2[1]);</span>
<span class="lineNum">     703 </span><span class="lineCov">          8 :   param[4]=MakeC(xyz0[0],xyz0[1],xyz1[0],xyz1[1],xyz2[0],xyz2[1]);</span>
<span class="lineNum">     704 </span><span class="lineCov">          8 :   param[3]=MakeTgl(xyz0[0],xyz0[1],xyz1[0],xyz1[1],xyz0[2],xyz1[2],param[4]);</span>
<span class="lineNum">     705 </span>            : 
<span class="lineNum">     706 </span>            :   //covariance matrix - only diagonal elements
<span class="lineNum">     707 </span>            :   //Double_t dist=p0r.GetX()-p2r.GetX();
<span class="lineNum">     708 </span>            :   Double_t deltaP=0;
<span class="lineNum">     709 </span><span class="lineCov">          4 :   covar[0]= p0r.GetCov()[3];</span>
<span class="lineNum">     710 </span><span class="lineCov">          4 :   covar[2]= p0r.GetCov()[5];</span>
<span class="lineNum">     711 </span>            :   //sigma snp
<span class="lineNum">     712 </span><span class="lineCov">          8 :   deltaP= (MakeSnp(xyz0[0],xyz0[1]+TMath::Sqrt(p0r.GetCov()[3]),xyz1[0],xyz1[1],xyz2[0],xyz2[1])-param[2]);</span>
<span class="lineNum">     713 </span><span class="lineCov">          4 :   covar[5]+= deltaP*deltaP;</span>
<span class="lineNum">     714 </span><span class="lineCov">          8 :   deltaP= (MakeSnp(xyz0[0],xyz0[1],xyz1[0],xyz1[1]+TMath::Sqrt(p1r.GetCov()[3]),xyz2[0],xyz2[1])-param[2]);</span>
<span class="lineNum">     715 </span><span class="lineCov">          4 :   covar[5]+= deltaP*deltaP;</span>
<span class="lineNum">     716 </span><span class="lineCov">          8 :   deltaP= (MakeSnp(xyz0[0],xyz0[1],xyz1[0],xyz1[1],xyz2[0],xyz2[1]+TMath::Sqrt(p1r.GetCov()[3]))-param[2]);</span>
<span class="lineNum">     717 </span><span class="lineCov">          4 :   covar[5]+= deltaP*deltaP;</span>
<span class="lineNum">     718 </span>            :   //sigma tgl
<span class="lineNum">     719 </span>            :   //
<span class="lineNum">     720 </span><span class="lineCov">          8 :   deltaP=MakeTgl(xyz0[0],xyz0[1],xyz1[0],xyz1[1],xyz0[2]+TMath::Sqrt(p1r.GetCov()[5]),xyz1[2],param[4])-param[3];</span>
<span class="lineNum">     721 </span><span class="lineCov">          4 :   covar[9]+= deltaP*deltaP;</span>
<span class="lineNum">     722 </span><span class="lineCov">          8 :   deltaP=MakeTgl(xyz0[0],xyz0[1],xyz1[0],xyz1[1],xyz0[2],xyz1[2]+TMath::Sqrt(p1r.GetCov()[5]),param[4])-param[3];</span>
<span class="lineNum">     723 </span><span class="lineCov">          4 :   covar[9]+= deltaP*deltaP;</span>
<span class="lineNum">     724 </span>            :   //
<span class="lineNum">     725 </span>            :   
<span class="lineNum">     726 </span><span class="lineCov">          8 :   deltaP=MakeC(xyz0[0],xyz0[1]+TMath::Sqrt(p0r.GetCov()[3]),xyz1[0],xyz1[1],xyz2[0],xyz2[1])-param[4];</span>
<span class="lineNum">     727 </span><span class="lineCov">          4 :   covar[14]+= deltaP*deltaP;</span>
<span class="lineNum">     728 </span><span class="lineCov">          8 :   deltaP=MakeC(xyz0[0],xyz0[1],xyz1[0],xyz1[1]+TMath::Sqrt(p1r.GetCov()[3]),xyz2[0],xyz2[1])-param[4];</span>
<span class="lineNum">     729 </span><span class="lineCov">          4 :   covar[14]+= deltaP*deltaP;</span>
<span class="lineNum">     730 </span><span class="lineCov">          8 :   deltaP=MakeC(xyz0[0],xyz0[1],xyz1[0],xyz1[1],xyz2[0],xyz2[1]+TMath::Sqrt(p2r.GetCov()[3]))-param[4];</span>
<span class="lineNum">     731 </span><span class="lineCov">          4 :   covar[14]+= deltaP*deltaP;</span>
<span class="lineNum">     732 </span>            :   
<span class="lineNum">     733 </span><span class="lineCov">          4 :   if (TMath::Abs(bz)&gt;kAlmost0Field) {</span>
<span class="lineNum">     734 </span><span class="lineCov">          4 :     covar[14]/=(bz*kB2C)*(bz*kB2C);</span>
<span class="lineNum">     735 </span><span class="lineCov">          4 :     param[4]/=(bz*kB2C); // transform to 1/pt</span>
<span class="lineNum">     736 </span><span class="lineCov">          4 :   }</span>
<span class="lineNum">     737 </span>            :   else { // assign 0.6 GeV pT
<span class="lineNum">     738 </span>            :     const double kq2pt = 1./0.6;
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :     param[4] = kq2pt;</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :     covar[14] = (0.5*0.5)*kq2pt;</span>
<span class="lineNum">     741 </span>            :   }
<span class="lineNum">     742 </span><span class="lineCov">          8 :   AliExternalTrackParam * trackParam = new AliExternalTrackParam(xyz0[0],alpha,param, covar);</span>
<span class="lineNum">     743 </span>            :   if (0) {
<span class="lineNum">     744 </span>            :     // consistency check  -to put warnings here 
<span class="lineNum">     745 </span>            :     // small disagrement once Track extrapolation used 
<span class="lineNum">     746 </span>            :     // nice agreement in seeds with MC track parameters - problem in extrapoloation - to be fixed
<span class="lineNum">     747 </span>            :     // to check later
<span class="lineNum">     748 </span>            :     Double_t y1,y2,z1,z2;
<span class="lineNum">     749 </span>            :     trackParam-&gt;GetYAt(xyz1[0],bz,y1);
<span class="lineNum">     750 </span>            :     trackParam-&gt;GetZAt(xyz1[0],bz,z1);
<span class="lineNum">     751 </span>            :     trackParam-&gt;GetYAt(xyz2[0],bz,y2);
<span class="lineNum">     752 </span>            :     trackParam-&gt;GetZAt(xyz2[0],bz,z2);
<span class="lineNum">     753 </span>            :     if (TMath::Abs(y1-xyz1[1])&gt; TMath::Sqrt(p1r.GetCov()[3]*5)){
<span class="lineNum">     754 </span>            :       AliWarningClass(&quot;Seeding problem y1\n&quot;);
<span class="lineNum">     755 </span>            :     }
<span class="lineNum">     756 </span>            :     if (TMath::Abs(y2-xyz2[1])&gt; TMath::Sqrt(p2r.GetCov()[3]*5)){
<span class="lineNum">     757 </span>            :       AliWarningClass(&quot;Seeding problem y2\n&quot;);
<span class="lineNum">     758 </span>            :     }
<span class="lineNum">     759 </span>            :     if (TMath::Abs(z1-xyz1[2])&gt; TMath::Sqrt(p1r.GetCov()[5]*5)){
<span class="lineNum">     760 </span>            :       AliWarningClass(&quot;Seeding problem z1\n&quot;);
<span class="lineNum">     761 </span>            :     }
<span class="lineNum">     762 </span>            :   }
<span class="lineNum">     763 </span>            :   return trackParam;  
<a name="764"><span class="lineNum">     764 </span><span class="lineCov">          4 : } </span></a>
<span class="lineNum">     765 </span>            : 
<span class="lineNum">     766 </span>            : Double_t  AliTrackerBase::FitTrack(AliExternalTrackParam * trackParam, AliTrackPointArray *pointArray, Double_t mass, Double_t maxStep){
<span class="lineNum">     767 </span>            :   //
<span class="lineNum">     768 </span>            :   // refit the track  - trackParam using the points in point array  
<span class="lineNum">     769 </span>            :   //
<span class="lineNum">     770 </span>            :   const Double_t kMaxSnp=0.99;
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :   if (!trackParam) return 0;</span>
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :   Int_t  npoints=pointArray-&gt;GetNPoints();</span>
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :   AliTrackPoint point,point2;</span>
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :   Double_t pointPos[2]={0,0};</span>
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :   Double_t pointCov[3]={0,0,0};</span>
<span class="lineNum">     776 </span>            :   // choose coordinate frame
<span class="lineNum">     777 </span>            :   // in standard way the coordinate frame should be changed point by point
<span class="lineNum">     778 </span>            :   // Some problems with rotation observed
<span class="lineNum">     779 </span>            :   // rotate method of AliExternalTrackParam should be revisited
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :   pointArray-&gt;GetPoint(point,0);</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :   pointArray-&gt;GetPoint(point2,npoints-1);</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :   Double_t alpha=TMath::ATan2(point.GetY()-point2.GetY(), point.GetX()-point2.GetX());</span>
<span class="lineNum">     783 </span>            :   
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :   for (Int_t ipoint=npoints-1; ipoint&gt;0; ipoint-=1){</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :     pointArray-&gt;GetPoint(point,ipoint);</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :     AliTrackPoint pr = point.Rotate(alpha);</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :     trackParam-&gt;Rotate(alpha);</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :     Bool_t status = PropagateTrackTo(trackParam,pr.GetX(),mass,maxStep,kFALSE,kMaxSnp);</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :     if(!status){</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :       AliWarningClass(&quot;Problem to propagate\n&quot;);    </span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     792 </span>            :     }
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :     if (TMath::Abs(trackParam-&gt;GetSnp())&gt;kMaxSnp){ </span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :       AliWarningClass(&quot;sin(phi) &gt; kMaxSnp \n&quot;);</span>
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     796 </span>            :     }
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :     pointPos[0]=pr.GetY();//local y</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :     pointPos[1]=pr.GetZ();//local z</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :     pointCov[0]=pr.GetCov()[3];//simay^2</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :     pointCov[1]=pr.GetCov()[4];//sigmayz</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :     pointCov[2]=pr.GetCov()[5];//sigmaz^2</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :     trackParam-&gt;Update(pointPos,pointCov); </span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     804 </span>            :   return 0;
<span class="lineNum">     805 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     806 </span>            : 
<a name="807"><span class="lineNum">     807 </span>            : </a>
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span>            : void AliTrackerBase::UpdateTrack(AliExternalTrackParam &amp;track1, const AliExternalTrackParam &amp;track2){
<span class="lineNum">     810 </span>            :   //
<span class="lineNum">     811 </span>            :   // Update track 1 with track 2
<span class="lineNum">     812 </span>            :   //
<span class="lineNum">     813 </span>            :   //
<span class="lineNum">     814 </span>            :   //
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :   TMatrixD vecXk(5,1);    // X vector</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :   TMatrixD covXk(5,5);    // X covariance </span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :   TMatrixD matHk(5,5);    // vector to mesurement</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :   TMatrixD measR(5,5);    // measurement error </span>
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :   TMatrixD vecZk(5,1);    // measurement</span>
<span class="lineNum">     820 </span>            :   //
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :   TMatrixD vecYk(5,1);    // Innovation or measurement residual</span>
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :   TMatrixD matHkT(5,5);</span>
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :   TMatrixD matSk(5,5);    // Innovation (or residual) covariance</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :   TMatrixD matKk(5,5);    // Optimal Kalman gain</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :   TMatrixD mat1(5,5);     // update covariance matrix</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :   TMatrixD covXk2(5,5);   // </span>
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :   TMatrixD covOut(5,5);</span>
<span class="lineNum">     828 </span>            :   //
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :   Double_t *param1=(Double_t*) track1.GetParameter();</span>
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :   Double_t *covar1=(Double_t*) track1.GetCovariance();</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :   Double_t *param2=(Double_t*) track2.GetParameter();</span>
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :   Double_t *covar2=(Double_t*) track2.GetCovariance();</span>
<span class="lineNum">     833 </span>            :   //
<span class="lineNum">     834 </span>            :   // copy data to the matrix
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :   for (Int_t ipar=0; ipar&lt;5; ipar++){</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :     for (Int_t jpar=0; jpar&lt;5; jpar++){</span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :       covXk(ipar,jpar) = covar1[track1.GetIndex(ipar, jpar)];</span>
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :       measR(ipar,jpar) = covar2[track2.GetIndex(ipar, jpar)];</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :       matHk(ipar,jpar)=0;</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :       mat1(ipar,jpar)=0;</span>
<span class="lineNum">     841 </span>            :     }
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :     vecXk(ipar,0) = param1[ipar];</span>
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :     vecZk(ipar,0) = param2[ipar];</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :     matHk(ipar,ipar)=1;</span>
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :     mat1(ipar,ipar)=1;</span>
<span class="lineNum">     846 </span>            :   }
<span class="lineNum">     847 </span>            :   //
<span class="lineNum">     848 </span>            :   //
<span class="lineNum">     849 </span>            :   //
<span class="lineNum">     850 </span>            :   //
<span class="lineNum">     851 </span>            :   //
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :   vecYk = vecZk-matHk*vecXk;                 // Innovation or measurement residual</span>
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :   matHkT=matHk.T(); matHk.T();</span>
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :   matSk = (matHk*(covXk*matHkT))+measR;      // Innovation (or residual) covariance</span>
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :   matSk.Invert();</span>
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :   matKk = (covXk*matHkT)*matSk;              //  Optimal Kalman gain</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :   vecXk += matKk*vecYk;                      //  updated vector </span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :   covXk2 = (mat1-(matKk*matHk));</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :   covOut =  covXk2*covXk; </span>
<span class="lineNum">     860 </span>            :   //
<span class="lineNum">     861 </span>            :   //
<span class="lineNum">     862 </span>            :   //
<span class="lineNum">     863 </span>            :   // copy from matrix to parameters
<span class="lineNum">     864 </span>            :   if (0) {
<span class="lineNum">     865 </span>            :     vecXk.Print();
<span class="lineNum">     866 </span>            :     vecZk.Print();
<span class="lineNum">     867 </span>            :     //
<span class="lineNum">     868 </span>            :     measR.Print();
<span class="lineNum">     869 </span>            :     covXk.Print();
<span class="lineNum">     870 </span>            :     covOut.Print();
<span class="lineNum">     871 </span>            :     //
<span class="lineNum">     872 </span>            :     track1.Print();
<span class="lineNum">     873 </span>            :     track2.Print();
<span class="lineNum">     874 </span>            :   }
<span class="lineNum">     875 </span>            : 
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :   for (Int_t ipar=0; ipar&lt;5; ipar++){</span>
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :     param1[ipar]= vecXk(ipar,0) ;</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :     for (Int_t jpar=0; jpar&lt;5; jpar++){</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :       covar1[track1.GetIndex(ipar, jpar)]=covOut(ipar,jpar);</span>
<span class="lineNum">     880 </span>            :     }
<span class="lineNum">     881 </span>            :   }
<span class="lineNum">     882 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     883 </span>            : 
<span class="lineNum">     884 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
