<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - STEER/STEER/AliMillePede2.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">STEER/STEER</a> - AliMillePede2.h<span style="font-size: 80%;"> (source / <a href="AliMillePede2.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">94</td>
            <td class="headerCovTableEntryLo">1.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">98</td>
            <td class="headerCovTableEntryLo">1.0 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : #ifndef ALIMILLEPEDE2_H</a>
<span class="lineNum">       2 </span>            : #define ALIMILLEPEDE2_H
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : /**********************************************************************************************/
<span class="lineNum">       5 </span>            : /* General class for alignment with large number of degrees of freedom                        */
<span class="lineNum">       6 </span>            : /* Based on the original milliped2 by Volker Blobel                                           */
<span class="lineNum">       7 </span>            : /* http://www.desy.de/~blobel/mptalks.html                                                    */
<span class="lineNum">       8 </span>            : /*                                                                                            */ 
<span class="lineNum">       9 </span>            : /* Author: ruben.shahoyan@cern.ch                                                             */
<span class="lineNum">      10 </span>            : /*                                                                                            */ 
<span class="lineNum">      11 </span>            : /**********************************************************************************************/
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : #include &lt;TObject.h&gt;
<span class="lineNum">      14 </span>            : #include &lt;TString.h&gt;
<span class="lineNum">      15 </span>            : #include &lt;TTree.h&gt;
<span class="lineNum">      16 </span>            : #include &quot;AliMinResSolve.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;AliMillePedeRecord.h&quot;
<span class="lineNum">      18 </span>            : class TFile;
<span class="lineNum">      19 </span>            : class AliMatrixSq;
<span class="lineNum">      20 </span>            : class AliSymMatrix;
<span class="lineNum">      21 </span>            : class AliRectMatrix;
<span class="lineNum">      22 </span>            : class AliMatrixSparse;
<span class="lineNum">      23 </span>            : class AliLog;
<span class="lineNum">      24 </span>            : class TStopwatch;
<span class="lineNum">      25 </span>            : class TArrayL;
<span class="lineNum">      26 </span>            : class TArrayF;
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : class AliMillePede2: public TObject
<span class="lineNum">      30 </span>            : {
<span class="lineNum">      31 </span>            :  public:
<span class="lineNum">      32 </span>            :   //
<span class="lineNum">      33 </span>            :   enum {kFailed,kInvert,kNoInversion};    // used global matrix solution methods
<span class="lineNum">      34 </span>            :   enum {kFixParID=-1};                    // dummy id for fixed param
<span class="lineNum">      35 </span>            :   //
<span class="lineNum">      36 </span>            :   AliMillePede2();
<a name="37"><span class="lineNum">      37 </span>            :   AliMillePede2(const AliMillePede2&amp; src);</a>
<span class="lineNum">      38 </span>            :   virtual ~AliMillePede2();
<span class="lineNum">      39 </span><span class="lineNoCov">          0 :   AliMillePede2&amp; operator=(const AliMillePede2&amp; )             {printf(&quot;Dummy\n&quot;); return *this;}</span>
<span class="lineNum">      40 </span>            :   //
<a name="41"><span class="lineNum">      41 </span>            :   Int_t                InitMille(int nGlo, int nLoc, Int_t lNStdDev=-1,double lResCut=-1., double lResCutInit=-1., const Int_t* regroup=0);</a>
<a name="42"><span class="lineNum">      42 </span>            :   //</a>
<a name="43"><span class="lineNum">      43 </span><span class="lineNoCov">          0 :   Int_t                GetNGloPar()                     const {return fNGloPar;}</span></a>
<a name="44"><span class="lineNum">      44 </span><span class="lineNoCov">          0 :   Int_t                GetNGloParIni()                  const {return fNGloParIni;}</span></a>
<a name="45"><span class="lineNum">      45 </span><span class="lineNoCov">          0 :   const Int_t*         GetRegrouping()                  const {return fkReGroup;}</span></a>
<a name="46"><span class="lineNum">      46 </span><span class="lineNoCov">          0 :   Int_t                GetNLocPar()                     const {return fNLocPar;}</span></a>
<a name="47"><span class="lineNum">      47 </span><span class="lineNoCov">          0 :   Long_t               GetNLocalEquations()             const {return fNLocEquations;}</span></a>
<a name="48"><span class="lineNum">      48 </span><span class="lineNoCov">          0 :   Int_t                GetCurrentIteration()            const {return fIter;}</span></a>
<a name="49"><span class="lineNum">      49 </span><span class="lineNoCov">          0 :   Int_t                GetNMaxIterations()              const {return fMaxIter;}</span></a>
<a name="50"><span class="lineNum">      50 </span><span class="lineNoCov">          0 :   Int_t                GetNStdDev()                     const {return fNStdDev;} </span></a>
<a name="51"><span class="lineNum">      51 </span><span class="lineNoCov">          0 :   Int_t                GetNGlobalConstraints()          const {return fNGloConstraints;}</span></a>
<a name="52"><span class="lineNum">      52 </span><span class="lineNoCov">          0 :   Int_t                GetNLagrangeConstraints()        const {return fNLagrangeConstraints;}</span></a>
<a name="53"><span class="lineNum">      53 </span><span class="lineNoCov">          0 :   Long_t               GetNLocalFits()                  const {return fNLocFits;}</span></a>
<a name="54"><span class="lineNum">      54 </span><span class="lineNoCov">          0 :   Long_t               GetNLocalFitsRejected()          const {return fNLocFitsRejected;}</span></a>
<a name="55"><span class="lineNum">      55 </span><span class="lineNoCov">          0 :   Int_t                GetNGlobalsFixed()               const {return fNGloFix;}</span></a>
<a name="56"><span class="lineNum">      56 </span><span class="lineNoCov">          0 :   Int_t                GetGlobalSolveStatus()           const {return fGloSolveStatus;}</span></a>
<a name="57"><span class="lineNum">      57 </span><span class="lineNoCov">          0 :   Float_t              GetChi2CutFactor()               const {return fChi2CutFactor;}</span></a>
<a name="58"><span class="lineNum">      58 </span><span class="lineNoCov">          0 :   Float_t              GetChi2CutRef()                  const {return fChi2CutRef;}</span></a>
<a name="59"><span class="lineNum">      59 </span><span class="lineNoCov">          0 :   Float_t              GetResCurInit()                  const {return fResCutInit;}</span></a>
<a name="60"><span class="lineNum">      60 </span><span class="lineNoCov">          0 :   Float_t              GetResCut()                      const {return fResCut;}</span></a>
<a name="61"><span class="lineNum">      61 </span><span class="lineNoCov">          0 :   Int_t                GetMinPntValid()                 const {return fMinPntValid;}</span></a>
<a name="62"><span class="lineNum">      62 </span><span class="lineNoCov">          0 :   Int_t                GetRGId(Int_t i)                 const {return fkReGroup ? (fkReGroup[i]&lt;0 ? -1:fkReGroup[i]) : i;}       </span></a>
<a name="63"><span class="lineNum">      63 </span><span class="lineNoCov">          0 :   Int_t                GetProcessedPoints(Int_t i)      const {int ir=GetRGId(i); return ir&lt;=0 ? 0:fProcPnt[ir];}</span></a>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :   Int_t*               GetProcessedPoints()             const {return fProcPnt;}</span>
<a name="65"><span class="lineNum">      65 </span><span class="lineNoCov">          0 :   Int_t                GetParamGrID(Int_t i)            const {int ir=GetRGId(i); return ir&lt;=0 ? 0:fParamGrID[ir];}</span></a>
<a name="66"><span class="lineNum">      66 </span>            :   //</a>
<a name="67"><span class="lineNum">      67 </span><span class="lineNoCov">          0 :   AliMatrixSq*         GetGlobalMatrix()                const {return fMatCGlo;}</span></a>
<a name="68"><span class="lineNum">      68 </span><span class="lineNoCov">          0 :   AliSymMatrix*        GetLocalMatrix()                 const {return fMatCLoc;}</span></a>
<a name="69"><span class="lineNum">      69 </span><span class="lineNoCov">          0 :   Double_t*            GetGlobals()                     const {return fVecBGlo;}</span></a>
<a name="70"><span class="lineNum">      70 </span><span class="lineNoCov">          0 :   Double_t*            GetDeltaPars()                   const {return fDeltaPar;}</span></a>
<a name="71"><span class="lineNum">      71 </span><span class="lineNoCov">          0 :   Double_t*            GetInitPars()                    const {return fInitPar;}</span></a>
<a name="72"><span class="lineNum">      72 </span><span class="lineNoCov">          0 :   Double_t*            GetSigmaPars()                   const {return fSigmaPar;}</span></a>
<a name="73"><span class="lineNum">      73 </span><span class="lineNoCov">          0 :   Bool_t*              GetIsLinear()                    const {return fIsLinear;}</span></a>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :   Double_t             GetFinalParam(int i)             const {int ir=GetRGId(i); return ir&lt;0 ? 0:fDeltaPar[ir]+fInitPar[ir];}</span>
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :   Double_t             GetFinalError(int i)             const {return GetParError(i);}</span>
<a name="76"><span class="lineNum">      76 </span>            :   Double_t             GetPull(int i)                   const;</a>
<a name="77"><span class="lineNum">      77 </span>            :   //</a>
<a name="78"><span class="lineNum">      78 </span><span class="lineNoCov">          0 :   Double_t             GetGlobal(Int_t i)               const {int ir=GetRGId(i); return ir&lt;0 ? 0:fVecBGlo[ir];}</span></a>
<a name="79"><span class="lineNum">      79 </span><span class="lineNoCov">          0 :   Double_t             GetInitPar(Int_t i)              const {int ir=GetRGId(i); return ir&lt;0 ? 0:fInitPar[ir];}</span></a>
<a name="80"><span class="lineNum">      80 </span><span class="lineNoCov">          0 :   Double_t             GetSigmaPar(Int_t i)             const {int ir=GetRGId(i); return ir&lt;0 ? 0:fSigmaPar[ir];}</span></a>
<a name="81"><span class="lineNum">      81 </span><span class="lineNoCov">          0 :   Bool_t               GetIsLinear(Int_t i)             const {int ir=GetRGId(i); return ir&lt;0 ? 0:fIsLinear[ir];}</span></a>
<a name="82"><span class="lineNum">      82 </span><span class="lineNoCov">          0 :   static Bool_t        IsGlobalMatSparse()                    {return fgIsMatGloSparse;}</span></a>
<a name="83"><span class="lineNum">      83 </span><span class="lineNoCov">          0 :   static Bool_t        IsWeightSigma()                        {return fgWeightSigma;}</span></a>
<a name="84"><span class="lineNum">      84 </span><span class="lineNoCov">          0 :   void                 SetWghScale(Double_t wOdd=1,Double_t wEven=1)    {fWghScl[0] = wOdd; fWghScl[1] = wEven;}</span></a>
<a name="85"><span class="lineNum">      85 </span><span class="lineNoCov">          0 :   void                 SetUseRecordWeight(Bool_t v=kTRUE)     {fUseRecordWeight=v;}</span></a>
<a name="86"><span class="lineNum">      86 </span><span class="lineNoCov">          0 :   Bool_t               GetUseRecordWeight()             const {return fUseRecordWeight;}</span></a>
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :   void                 SetMinRecordLength(Int_t v=1)          {fMinRecordLength = v;}</span>
<a name="88"><span class="lineNum">      88 </span><span class="lineNoCov">          0 :   Int_t                GetMinRecordLength()             const {return fMinRecordLength;}</span></a>
<a name="89"><span class="lineNum">      89 </span>            :   //</a>
<a name="90"><span class="lineNum">      90 </span><span class="lineNoCov">          0 :   void                 SetParamGrID(Int_t grID,Int_t i)       {int ir=GetRGId(i); if(ir&lt;0) return; fParamGrID[ir] = grID; if(fNGroupsSet&lt;grID)fNGroupsSet=grID;}</span></a>
<a name="91"><span class="lineNum">      91 </span><span class="lineNoCov">          0 :   void                 SetNGloPar(Int_t n)                    {fNGloPar = n;}</span></a>
<a name="92"><span class="lineNum">      92 </span><span class="lineNoCov">          0 :   void                 SetNLocPar(Int_t n)                    {fNLocPar = n;}</span></a>
<a name="93"><span class="lineNum">      93 </span><span class="lineNoCov">          0 :   void                 SetNMaxIterations(Int_t n=10)          {fMaxIter = n;}</span></a>
<a name="94"><span class="lineNum">      94 </span><span class="lineNoCov">          0 :   void                 SetNStdDev(Int_t n)                    {fNStdDev = n;}</span></a>
<a name="95"><span class="lineNum">      95 </span><span class="lineNoCov">          0 :   void                 SetChi2CutFactor(Float_t v)            {fChi2CutFactor = v;}</span></a>
<a name="96"><span class="lineNum">      96 </span><span class="lineNoCov">          0 :   void                 SetChi2CutRef(Float_t v)               {fChi2CutRef = v;}</span></a>
<a name="97"><span class="lineNum">      97 </span><span class="lineNoCov">          0 :   void                 SetResCurInit(Float_t v)               {fResCutInit = v;}</span></a>
<a name="98"><span class="lineNum">      98 </span><span class="lineNoCov">          0 :   void                 SetResCut(Float_t v)                   {fResCut = v;}</span></a>
<a name="99"><span class="lineNum">      99 </span><span class="lineNoCov">          0 :   void                 SetMinPntValid(Int_t n)                {fMinPntValid = n&gt;0 ? n:1;}</span></a>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :   static void          SetGlobalMatSparse(Bool_t v=kTRUE)     {fgIsMatGloSparse = v;}</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :   static void          SetWeightSigma(Bool_t v=kTRUE)         {fgWeightSigma = v;}</span>
<span class="lineNum">     102 </span>            :   //
<span class="lineNum">     103 </span>            :   void                 SetInitPars(const Double_t* par);
<span class="lineNum">     104 </span>            :   void                 SetSigmaPars(const Double_t* par);
<span class="lineNum">     105 </span>            :   void                 SetInitPar(Int_t i,Double_t par);
<span class="lineNum">     106 </span>            :   void                 SetSigmaPar(Int_t i,Double_t par);
<span class="lineNum">     107 </span>            :   //
<span class="lineNum">     108 </span>            :   Int_t                GlobalFit(Double_t *par=0, Double_t *error=0, Double_t *pull=0);
<a name="109"><span class="lineNum">     109 </span>            :   Int_t                GlobalFitIteration();</a>
<a name="110"><span class="lineNum">     110 </span>            :   Int_t                SolveGlobalMatEq();</a>
<a name="111"><span class="lineNum">     111 </span><span class="lineNoCov">          0 :   static void          SetInvChol(Bool_t v=kTRUE)             {fgInvChol = v;}</span></a>
<a name="112"><span class="lineNum">     112 </span><span class="lineNoCov">          0 :   static void          SetMinResPrecondType(Int_t tp=0)       {fgMinResCondType = tp;}</span></a>
<a name="113"><span class="lineNum">     113 </span><span class="lineNoCov">          0 :   static void          SetMinResTol(Double_t val=1e-12)       {fgMinResTol = val;}</span></a>
<a name="114"><span class="lineNum">     114 </span><span class="lineNoCov">          0 :   static void          SetMinResMaxIter(Int_t val=2000)       {fgMinResMaxIter = val;}</span></a>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :   static void          SetIterSolverType(Int_t val=AliMinResSolve::kSolMinRes) {fgIterSol = val;}</span>
<a name="116"><span class="lineNum">     116 </span><span class="lineNoCov">          0 :   static void          SetNKrylovV(Int_t val=60)              {fgNKrylovV = val;}</span></a>
<a name="117"><span class="lineNum">     117 </span>            :   //</a>
<a name="118"><span class="lineNum">     118 </span><span class="lineNoCov">          0 :   static Bool_t        GetInvChol()                           {return fgInvChol;}</span></a>
<a name="119"><span class="lineNum">     119 </span><span class="lineNoCov">          0 :   static Int_t         GetMinResPrecondType()                 {return fgMinResCondType;}</span></a>
<a name="120"><span class="lineNum">     120 </span><span class="lineNoCov">          0 :   static Double_t      GetMinResTol()                         {return fgMinResTol;}</span></a>
<a name="121"><span class="lineNum">     121 </span><span class="lineNoCov">          0 :   static Int_t         GetMinResMaxIter()                     {return fgMinResMaxIter;}</span></a>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :   static Int_t         GetIterSolverType()                    {return fgIterSol;}</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :   static Int_t         GetNKrylovV()                          {return fgNKrylovV;}</span>
<span class="lineNum">     124 </span>            :   //
<span class="lineNum">     125 </span>            :   Double_t             GetParError(int iPar)           const;
<span class="lineNum">     126 </span>            :   Int_t                PrintGlobalParameters()         const;
<span class="lineNum">     127 </span>            :   void                 SetRejRunList(const UInt_t *runs, Int_t nruns);
<span class="lineNum">     128 </span>            :   void                 SetAccRunList(const UInt_t *runs, Int_t nruns, const Float_t* wghList=0);
<span class="lineNum">     129 </span>            :   Bool_t               IsRecordAcceptable();
<span class="lineNum">     130 </span>            :   //
<span class="lineNum">     131 </span>            :   //
<span class="lineNum">     132 </span>            :   Int_t                SetIterations(double lChi2CutFac);
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            :   //
<span class="lineNum">     135 </span>            :   // constraints
<span class="lineNum">     136 </span>            :   void                 SetGlobalConstraint(const double *dergb, double val, double sigma=0);
<span class="lineNum">     137 </span>            :   void                 SetGlobalConstraint(const int *indgb, const double *dergb, int ngb, double val, double sigma=0);
<span class="lineNum">     138 </span>            :   //
<span class="lineNum">     139 </span>            :   // processing of the local measurement
<span class="lineNum">     140 </span>            :   void                 SetRecordRun(Int_t run);
<span class="lineNum">     141 </span>            :   void                 SetRecordWeight(double wgh);
<span class="lineNum">     142 </span>            :   void                 SetLocalEquation(double *dergb, double *derlc, double lMeas, double lSigma);
<span class="lineNum">     143 </span>            :   void                 SetLocalEquation(int *indgb, double *dergb, int ngb, int *indlc, 
<span class="lineNum">     144 </span>            :                                         double *derlc,int nlc,double lMeas,double lSigma);
<a name="145"><span class="lineNum">     145 </span>            :   //</a>
<a name="146"><span class="lineNum">     146 </span>            :   // manipilation with processed data and costraints records and its buffer</a>
<a name="147"><span class="lineNum">     147 </span><span class="lineNoCov">          0 :   void                 SetDataRecFName(const char* flname)   {fDataRecFName = flname;}</span></a>
<a name="148"><span class="lineNum">     148 </span><span class="lineNoCov">          0 :   const Char_t*        GetDataRecFName()               const {return fDataRecFName.Data();}</span></a>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :   void                 SetConsRecFName(const char* flname)   {fConstrRecFName = flname;}</span>
<a name="150"><span class="lineNum">     150 </span><span class="lineNoCov">          0 :   const Char_t*        GetConsRecFName()               const {return fConstrRecFName.Data();}</span></a>
<a name="151"><span class="lineNum">     151 </span>            :   //</a>
<a name="152"><span class="lineNum">     152 </span><span class="lineNoCov">          0 :   void   SetRecDataTreeName(const char* name=0)     {fRecDataTreeName = name;   if (fRecDataTreeName.IsNull()) fRecDataTreeName = &quot;AliMillePedeRecords_Data&quot;;}</span></a>
<a name="153"><span class="lineNum">     153 </span><span class="lineNoCov">          0 :   void   SetRecConsTreeName(const char* name=0)     {fRecConsTreeName = name;   if (fRecConsTreeName.IsNull()) fRecConsTreeName = &quot;AliMillePedeRecords_Consaints&quot;;}</span></a>
<a name="154"><span class="lineNum">     154 </span><span class="lineNoCov">          0 :   void   SetRecDataBranchName(const char* name=0)   {fRecDataBranchName = name; if (fRecDataBranchName.IsNull()) fRecDataBranchName = &quot;Record_Data&quot;;}</span></a>
<a name="155"><span class="lineNum">     155 </span><span class="lineNoCov">          0 :   void   SetRecConsBranchName(const char* name=0)   {fRecConsBranchName = name; if (fRecConsBranchName.IsNull()) fRecConsBranchName = &quot;Record_Consaints&quot;;}</span></a>
<a name="156"><span class="lineNum">     156 </span><span class="lineNoCov">          0 :   const char* GetRecDataTreeName()     const {return fRecDataTreeName.Data();}</span></a>
<a name="157"><span class="lineNum">     157 </span><span class="lineNoCov">          0 :   const char* GetRecConsTreeName()     const {return fRecConsTreeName.Data();}</span></a>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :   const char* GetRecDataBranchName()   const {return fRecDataBranchName.Data();}</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :   const char* GetRecConsBranchName()   const {return fRecConsBranchName.Data();}</span>
<span class="lineNum">     160 </span>            :   //
<span class="lineNum">     161 </span>            :   Bool_t               InitDataRecStorage(Bool_t read=kFALSE);
<span class="lineNum">     162 </span>            :   Bool_t               InitConsRecStorage(Bool_t read=kFALSE);
<span class="lineNum">     163 </span>            :   Bool_t               ImposeDataRecFile(const char* fname);
<span class="lineNum">     164 </span>            :   Bool_t               ImposeConsRecFile(const char* fname);
<span class="lineNum">     165 </span>            :   void                 CloseDataRecStorage();
<span class="lineNum">     166 </span>            :   void                 CloseConsRecStorage();
<span class="lineNum">     167 </span>            :   void                 ReadRecordData(Long_t recID);
<span class="lineNum">     168 </span>            :   void                 ReadRecordConstraint(Long_t recID);
<span class="lineNum">     169 </span>            :   Bool_t               ReadNextRecordData();
<span class="lineNum">     170 </span>            :   Bool_t               ReadNextRecordConstraint();
<a name="171"><span class="lineNum">     171 </span>            :   void                 SaveRecordData();</a>
<a name="172"><span class="lineNum">     172 </span>            :   void                 SaveRecordConstraint();</a>
<a name="173"><span class="lineNum">     173 </span><span class="lineNoCov">          0 :   AliMillePedeRecord*  GetRecord()                      const {return fRecord;}</span></a>
<a name="174"><span class="lineNum">     174 </span><span class="lineNoCov">          0 :   Long_t               GetSelFirst()                    const {return fSelFirst;}</span></a>
<a name="175"><span class="lineNum">     175 </span><span class="lineNoCov">          0 :   Long_t               GetSelLast()                     const {return fSelLast;}</span></a>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :   void                 SetSelFirst(Long_t v)                  {fSelFirst = v;}</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :   void                 SetSelLast(Long_t v)                   {fSelLast = v;}</span>
<span class="lineNum">     178 </span>            :   //
<span class="lineNum">     179 </span>            :   Float_t              Chi2DoFLim(int nSig, int nDoF)   const;
<a name="180"><span class="lineNum">     180 </span>            :   //</a>
<a name="181"><span class="lineNum">     181 </span>            :   // aliases for compatibility with millipede1</a>
<a name="182"><span class="lineNum">     182 </span><span class="lineNoCov">          0 :   void                 SetParSigma(Int_t i,Double_t par)      {SetSigmaPar(i,par);}</span></a>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :   void                 SetGlobalParameters(Double_t *par)     {SetInitPars(par);}</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :   void                 SetNonLinear(int index, Bool_t v=kTRUE) {int id = GetRGId(index); if (id&lt;0) return; fIsLinear[id] = !v;}</span>
<span class="lineNum">     185 </span>            :   //
<span class="lineNum">     186 </span>            :  protected:
<a name="187"><span class="lineNum">     187 </span>            :   //</a>
<span class="lineNum">     188 </span>            :   Int_t                LocalFit(double *localParams=0);
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :   Bool_t               IsZero(Double_t v,Double_t eps=1e-16)   const {return TMath::Abs(v)&lt;eps;}                  </span>
<span class="lineNum">     190 </span>            :   //
<span class="lineNum">     191 </span>            :  protected:
<span class="lineNum">     192 </span>            :   //
<span class="lineNum">     193 </span>            :   Int_t                 fNLocPar;                        // number of local parameters
<span class="lineNum">     194 </span>            :   Int_t                 fNGloPar;                        // number of global parameters
<span class="lineNum">     195 </span>            :   Int_t                 fNGloParIni;                     // number of global parameters before grouping
<span class="lineNum">     196 </span>            :   Int_t                 fNGloSize;                       // final size of the global matrix (NGloPar+NConstraints)
<span class="lineNum">     197 </span>            :   //
<span class="lineNum">     198 </span>            :   Long_t                fNLocEquations;                  // Number of local equations 
<span class="lineNum">     199 </span>            :   Int_t                 fIter;                           // Current iteration
<span class="lineNum">     200 </span>            :   Int_t                 fMaxIter;                        // Maximum number of iterations
<span class="lineNum">     201 </span>            :   Int_t                 fNStdDev;                        // Number of standard deviations for chi2 cut 
<span class="lineNum">     202 </span>            :   Int_t                 fNGloConstraints;                // Number of constraint equations
<span class="lineNum">     203 </span>            :   Int_t                 fNLagrangeConstraints;           // Number of constraint equations requiring Lagrange multiplier
<span class="lineNum">     204 </span>            :   Long_t                fNLocFits;                       // Number of local fits
<span class="lineNum">     205 </span>            :   Long_t                fNLocFitsRejected;               // Number of local fits rejected
<span class="lineNum">     206 </span>            :   Int_t                 fNGloFix;                        // Number of globals fixed by user
<span class="lineNum">     207 </span>            :   Int_t                 fGloSolveStatus;                 // Status of global solver at current step
<span class="lineNum">     208 </span>            :   //
<span class="lineNum">     209 </span>            :   Float_t               fChi2CutFactor;                  // Cut factor for chi2 cut to accept local fit 
<span class="lineNum">     210 </span>            :   Float_t               fChi2CutRef;                     // Reference cut for chi2 cut to accept local fit 
<span class="lineNum">     211 </span>            :   Float_t               fResCutInit;                     // Cut in residual for first iterartion
<span class="lineNum">     212 </span>            :   Float_t               fResCut;                         // Cut in residual for other iterartiona
<span class="lineNum">     213 </span>            :   Int_t                 fMinPntValid;                    // min number of points for global to vary
<span class="lineNum">     214 </span>            :   //
<span class="lineNum">     215 </span>            :   Int_t                 fNGroupsSet;                     // number of groups set
<span class="lineNum">     216 </span>            :   Int_t                *fParamGrID;                      //[fNGloPar] group id for the every parameter
<span class="lineNum">     217 </span>            :   Int_t                *fProcPnt;                        //[fNGloPar] N of processed points per global variable
<span class="lineNum">     218 </span>            :   Double_t             *fVecBLoc;                        //[fNLocPar] Vector B local (parameters) 
<span class="lineNum">     219 </span>            :   Double_t             *fDiagCGlo;                       //[fNGloPar] Initial diagonal elements of C global matrix
<span class="lineNum">     220 </span>            :   Double_t             *fVecBGlo;                        //! Vector B global (parameters)
<span class="lineNum">     221 </span>            :   //
<span class="lineNum">     222 </span>            :   Double_t             *fInitPar;                        //[fNGloPar] Initial global parameters
<span class="lineNum">     223 </span>            :   Double_t             *fDeltaPar;                       //[fNGloPar] Variation of global parameters
<span class="lineNum">     224 </span>            :   Double_t             *fSigmaPar;                       //[fNGloPar] Sigma of allowed variation of global parameter
<span class="lineNum">     225 </span>            :   //
<span class="lineNum">     226 </span>            :   Bool_t               *fIsLinear;                       //[fNGloPar] Flag for linear parameters
<span class="lineNum">     227 </span>            :   Bool_t               *fConstrUsed;                     //! Flag for used constraints
<span class="lineNum">     228 </span>            :   //
<span class="lineNum">     229 </span>            :   Int_t                *fGlo2CGlo;                       //[fNGloPar] global ID to compressed ID buffer
<span class="lineNum">     230 </span>            :   Int_t                *fCGlo2Glo;                       //[fNGloPar] compressed ID to global ID buffer
<span class="lineNum">     231 </span>            :   //
<span class="lineNum">     232 </span>            :   // Matrices
<span class="lineNum">     233 </span>            :   AliSymMatrix         *fMatCLoc;                        // Matrix C local
<span class="lineNum">     234 </span>            :   AliMatrixSq          *fMatCGlo;                        // Matrix C global
<span class="lineNum">     235 </span>            :   AliRectMatrix        *fMatCGloLoc;                     // Rectangular matrix C g*l 
<span class="lineNum">     236 </span>            :   Int_t                *fFillIndex;                      //[fNGloPar] auxilary index array for fast matrix fill
<span class="lineNum">     237 </span>            :   Double_t             *fFillValue;                      //[fNGloPar] auxilary value array for fast matrix fill
<span class="lineNum">     238 </span>            :   //
<span class="lineNum">     239 </span>            :   // processed data record bufferization   
<span class="lineNum">     240 </span>            :   TString               fRecDataTreeName;                // Name of data records tree
<span class="lineNum">     241 </span>            :   TString               fRecConsTreeName;                // Name of constraints records tree
<span class="lineNum">     242 </span>            :   TString               fRecDataBranchName;              // Name of data records branch name
<span class="lineNum">     243 </span>            :   TString               fRecConsBranchName;              // Name of constraints records branch name
<span class="lineNum">     244 </span>            :   
<span class="lineNum">     245 </span>            :   TString               fDataRecFName;                   // Name of File for data records               
<span class="lineNum">     246 </span>            :   AliMillePedeRecord   *fRecord;                         // Buffer of measurements records
<span class="lineNum">     247 </span>            :   TFile                *fDataRecFile;                    // File of processed measurements records
<span class="lineNum">     248 </span>            :   TTree                *fTreeData;                       // Tree of processed measurements records
<span class="lineNum">     249 </span>            :   Int_t                 fRecFileStatus;                  // state of the record file (0-no, 1-read, 2-rw)
<span class="lineNum">     250 </span>            :   //
<span class="lineNum">     251 </span>            :   TString               fConstrRecFName;                 // Name of File for constraints records               
<span class="lineNum">     252 </span>            :   TTree                *fTreeConstr;                     //! Tree of constraint records
<span class="lineNum">     253 </span>            :   TFile                *fConsRecFile;                    //! File of processed constraints records
<span class="lineNum">     254 </span>            :   Long_t                fCurrRecDataID;                  // ID of the current data record
<span class="lineNum">     255 </span>            :   Long_t                fCurrRecConstrID;                // ID of the current constraint record
<span class="lineNum">     256 </span>            :   Bool_t                fLocFitAdd;                      // Add contribution of carrent track (and not eliminate it)
<span class="lineNum">     257 </span>            :   Bool_t                fUseRecordWeight;                // force or ignore the record weight
<span class="lineNum">     258 </span>            :   Int_t                 fMinRecordLength;                // ignore shorter records
<span class="lineNum">     259 </span>            :   Int_t                 fSelFirst;                       // event selection start
<span class="lineNum">     260 </span>            :   Int_t                 fSelLast;                        // event selection end
<span class="lineNum">     261 </span>            :   TArrayL*              fRejRunList;                     // list of runs to reject (if any)
<span class="lineNum">     262 </span>            :   TArrayL*              fAccRunList;                     // list of runs to select (if any)
<span class="lineNum">     263 </span>            :   TArrayF*              fAccRunListWgh;                  // optional weights for data of accepted runs (if any)
<span class="lineNum">     264 </span>            :   Double_t              fRunWgh;                         // run weight
<span class="lineNum">     265 </span>            :   Double_t              fWghScl[2];                      // optional rescaling for odd/even residual weights (see its usage in LocalFit)
<span class="lineNum">     266 </span>            :   const Int_t*          fkReGroup;                       // optional regrouping of parameters wrt ID's from the records
<span class="lineNum">     267 </span>            :   //
<span class="lineNum">     268 </span>            :   static Bool_t         fgInvChol;                       // Invert global matrix in Cholesky solver
<span class="lineNum">     269 </span>            :   static Bool_t         fgWeightSigma;                   // weight parameter constraint by statistics
<span class="lineNum">     270 </span>            :   static Bool_t         fgIsMatGloSparse;                // Type of the global matrix (sparse ...)
<span class="lineNum">     271 </span>            :   static Int_t          fgMinResCondType;                // Type of the preconditioner for MinRes method 
<span class="lineNum">     272 </span>            :   static Double_t       fgMinResTol;                     // Tolerance for MinRes solution
<span class="lineNum">     273 </span>            :   static Int_t          fgMinResMaxIter;                 // Max number of iterations for the MinRes method
<span class="lineNum">     274 </span>            :   static Int_t          fgIterSol;                       // type of iterative solution: MinRes or FGMRES
<a name="275"><span class="lineNum">     275 </span>            :   static Int_t          fgNKrylovV;                      // size of Krylov vectors buffer in FGMRES</a>
<span class="lineNum">     276 </span>            :   //
<span class="lineNum">     277 </span><span class="lineCov">        126 :   ClassDef(AliMillePede2,1)</span>
<span class="lineNum">     278 </span>            : };
<a name="279"><span class="lineNum">     279 </span>            : </a>
<span class="lineNum">     280 </span>            : //_____________________________________________________________________________________________
<span class="lineNum">     281 </span><span class="lineNoCov">          0 : inline void AliMillePede2::ReadRecordData(Long_t recID)       {fTreeData-&gt;GetEntry(recID); fCurrRecDataID=recID;}</span>
<a name="282"><span class="lineNum">     282 </span>            : </a>
<span class="lineNum">     283 </span>            : //_____________________________________________________________________________________________
<span class="lineNum">     284 </span><span class="lineNoCov">          0 : inline void AliMillePede2::ReadRecordConstraint(Long_t recID) {fTreeConstr-&gt;GetEntry(recID); fCurrRecConstrID=recID;}</span>
<a name="285"><span class="lineNum">     285 </span>            : </a>
<span class="lineNum">     286 </span>            : //_____________________________________________________________________________________________
<span class="lineNum">     287 </span><span class="lineNoCov">          0 : inline void AliMillePede2::SaveRecordData()                   {fTreeData-&gt;Fill(); fRecord-&gt;Reset(); fCurrRecDataID++;}</span>
<a name="288"><span class="lineNum">     288 </span>            : </a>
<span class="lineNum">     289 </span>            : //_____________________________________________________________________________________________
<span class="lineNum">     290 </span><span class="lineNoCov">          0 : inline void AliMillePede2::SaveRecordConstraint()             {fTreeConstr-&gt;Fill(); fRecord-&gt;Reset();fCurrRecConstrID++;}</span>
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
