<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - STEER/STEER/AliMillepede.cxx</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">STEER/STEER</a> - AliMillepede.cxx<span style="font-size: 80%;"> (source / <a href="AliMillepede.cxx.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">592</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">22</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**************************************************************************</a>
<span class="lineNum">       2 </span>            :  * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
<span class="lineNum">       3 </span>            :  *                                                                        *
<span class="lineNum">       4 </span>            :  * Author: The ALICE Off-line Project.                                    *
<span class="lineNum">       5 </span>            :  * Contributors are mentioned in the code where appropriate.              *
<span class="lineNum">       6 </span>            :  *                                                                        *
<span class="lineNum">       7 </span>            :  * Permission to use, copy, modify and distribute this software and its   *
<span class="lineNum">       8 </span>            :  * documentation strictly for non-commercial purposes is hereby granted   *
<span class="lineNum">       9 </span>            :  * without fee, provided that the above copyright notice appears in all   *
<span class="lineNum">      10 </span>            :  * copies and that both the copyright notice and this permission notice   *
<span class="lineNum">      11 </span>            :  * appear in the supporting documentation. The authors make no claims     *
<span class="lineNum">      12 </span>            :  * about the suitability of this software for any purpose. It is          *
<span class="lineNum">      13 </span>            :  * provided &quot;as is&quot; without express or implied warranty.                  *
<span class="lineNum">      14 </span>            :  **************************************************************************/
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : /* $Id$ */
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : //-----------------------------------------------------------------------------
<span class="lineNum">      19 </span>            : /// \class AliMillepede
<span class="lineNum">      20 </span>            : /// Detector independent alignment class
<span class="lineNum">      21 </span>            : ///
<span class="lineNum">      22 </span>            : /// This modified C++ version is based on a C++ translation of Millepede used 
<span class="lineNum">      23 </span>            : /// for LHCb Vertex Detector alignment (lhcb-2005-101), available here 
<span class="lineNum">      24 </span>            : /// http://isscvs.cern.ch/cgi-bin/cvsweb.cgi/Alignment/AlignmentTools/src/?cvsroot=lhcb
<span class="lineNum">      25 </span>            : /// The original millepede fortran package is available at:  
<span class="lineNum">      26 </span>            : /// http://www.desy.de/~blobel/wwwmille.html  
<span class="lineNum">      27 </span>            : ///
<span class="lineNum">      28 </span>            : /// \author Javier Castillo
<span class="lineNum">      29 </span>            : //-----------------------------------------------------------------------------
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : #include &lt;TArrayI.h&gt;
<span class="lineNum">      32 </span>            : #include &lt;TArrayD.h&gt;
<span class="lineNum">      33 </span>            : #include &lt;TMath.h&gt;
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : #include &quot;AliLog.h&quot;
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : #include &quot;AliMillepede.h&quot;
<a name="38"><span class="lineNum">      38 </span>            : </a>
<span class="lineNum">      39 </span>            : //=============================================================================
<span class="lineNum">      40 </span>            : AliMillepede::AliMillepede()
<span class="lineNum">      41 </span><span class="lineNoCov">          0 :   : TObject(),</span>
<span class="lineNum">      42 </span><span class="lineNoCov">          0 :     fIndexLocEq(fgkMaxGlobalPar+fgkMaxLocalPar),</span>
<span class="lineNum">      43 </span><span class="lineNoCov">          0 :     fDerivLocEq(fgkMaxGlobalPar+fgkMaxLocalPar),</span>
<span class="lineNum">      44 </span><span class="lineNoCov">          0 :     fIndexAllEqs(1000*fgkMaxGlobalPar+fgkMaxLocalPar),</span>
<span class="lineNum">      45 </span><span class="lineNoCov">          0 :     fDerivAllEqs(1000*fgkMaxGlobalPar+fgkMaxLocalPar),</span>
<span class="lineNum">      46 </span><span class="lineNoCov">          0 :     fLocEqPlace(1000), </span>
<span class="lineNum">      47 </span><span class="lineNoCov">          0 :     fNIndexLocEq(0),</span>
<span class="lineNum">      48 </span><span class="lineNoCov">          0 :     fNDerivLocEq(0),</span>
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :     fNIndexAllEqs(0),</span>
<span class="lineNum">      50 </span><span class="lineNoCov">          0 :     fNDerivAllEqs(0),</span>
<span class="lineNum">      51 </span><span class="lineNoCov">          0 :     fNLocEqPlace(0),</span>
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :     fNLocalEquations(0),</span>
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :     fResCutInit(0.),</span>
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :     fResCut(0.),</span>
<span class="lineNum">      55 </span><span class="lineNoCov">          0 :     fChi2CutFactor(1.0),</span>
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :     fChi2CutRef(1.0),</span>
<span class="lineNum">      57 </span><span class="lineNoCov">          0 :     fIter(0),</span>
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :     fMaxIter(10),</span>
<span class="lineNum">      59 </span><span class="lineNoCov">          0 :     fNStdDev(3),</span>
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :     fNGlobalConstraints(0),</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :     fNLocalFits(0),</span>
<span class="lineNum">      62 </span><span class="lineNoCov">          0 :     fNLocalFitsRejected(0),</span>
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :     fNGlobalPar(0),</span>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :     fNLocalPar(0)</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">      66 </span>            :   /// Standard constructor
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :   AliInfo(&quot;                                           &quot;);</span>
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :   AliInfo(&quot;            * o o                   o      &quot;);</span>
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :   AliInfo(&quot;              o o                   o      &quot;);</span>
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :   AliInfo(&quot;   o ooooo  o o o  oo  ooo   oo   ooo  oo  &quot;);</span>
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :   AliInfo(&quot;    o  o  o o o o o  o o  o o  o o  o o  o &quot;);</span>
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :   AliInfo(&quot;    o  o  o o o o oooo o  o oooo o  o oooo &quot;);</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :   AliInfo(&quot;    o  o  o o o o o    ooo  o    o  o o    &quot;);</span>
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :   AliInfo(&quot;    o  o  o o o o  oo  o     oo   ooo  oo  ++ starts&quot;);       </span>
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :   AliInfo(&quot;                                           &quot;);</span>
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span><span class="lineNoCov">          0 : }</span>
<a name="79"><span class="lineNum">      79 </span>            : </a>
<span class="lineNum">      80 </span>            : //=============================================================================
<span class="lineNum">      81 </span><span class="lineNoCov">          0 : AliMillepede::~AliMillepede() {</span>
<span class="lineNum">      82 </span>            :   /// Destructor
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span><span class="lineNoCov">          0 : }</span>
<a name="85"><span class="lineNum">      85 </span>            : </a>
<span class="lineNum">      86 </span>            : //=============================================================================
<span class="lineNum">      87 </span>            : Int_t AliMillepede::InitMille(int nGlo, int nLoc, int lNStdDev,
<span class="lineNum">      88 </span>            :                               double lResCut, double lResCutInit)
<span class="lineNum">      89 </span>            : {
<span class="lineNum">      90 </span>            :   /// Initialization of millepede
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :   AliDebug(1,&quot;&quot;);</span>
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :   AliDebug(1,&quot;----------------------------------------------------&quot;);</span>
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :   AliDebug(1,&quot;&quot;);</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :   AliDebug(1,&quot;    Entering InitMille&quot;);</span>
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :   AliDebug(1,&quot;&quot;);</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :   AliDebug(1,&quot;-----------------------------------------------------&quot;);</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :   AliDebug(1,&quot;&quot;);</span>
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :   fNGlobalConstraints = 0;</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :   fNLocalFits  = 0;                      // Total number of local fits</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :   fNLocalFitsRejected  = 0;              // Total number of local fits rejected</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :   fChi2CutRef  = 1.0;                    // Reference value for Chi^2/ndof cut</span>
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :   AliMillepede::SetNLocalEquations(0);     // Number of local fits (starts at 0)</span>
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :   fIter    = 0;  // By default iterations are turned off, turned on by use SetIterations</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :   fMaxIter = 10;</span>
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :   fResCutInit = lResCutInit; </span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :   fResCut = lResCut;</span>
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :   fNGlobalPar = nGlo;     // Number of global derivatives</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :   fNLocalPar  = nLoc;     // Number of local derivatives</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :   fNStdDev    = lNStdDev; // Number of StDev for local fit chisquare cut</span>
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :   AliDebug(1,Form(&quot;Number of global parameters   : %d&quot;, fNGlobalPar));</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :   AliDebug(1,Form(&quot;Number of local parameters    : %d&quot;, fNLocalPar));</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :   AliDebug(1,Form(&quot;Number of standard deviations : %d&quot;, fNStdDev));</span>
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :   if (fNGlobalPar&gt;fgkMaxGlobalPar || fNLocalPar&gt;fgkMaxLocalPar) {</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :     AliDebug(1,&quot;Two many parameters !!!!!&quot;);</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     123 </span>            :   }
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span>            :   // Global parameters initializations
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :   for (int i=0; i&lt;fNGlobalPar; i++) {  </span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :     fVecBGlo[i]=0.;</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :     fInitPar[i]=0.;</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :     fDeltaPar[i]=0.;</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :     fSigmaPar[i]=-1.;</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :     fIsNonLinear[i]=0;</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :     fGlo2CGLRow[i]=-1;</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :     fCGLRow2Glo[i]=-1;</span>
<span class="lineNum">     134 </span>            :     
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :     for (int j=0; j&lt;fNGlobalPar;j++) {    </span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :       fMatCGlo[i][j]=0.;</span>
<span class="lineNum">     137 </span>            :     }
<span class="lineNum">     138 </span>            :   }
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            :   // Local parameters initializations
<span class="lineNum">     141 </span>            :   
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :   for (int i=0; i&lt;fNLocalPar; i++) {</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :     fVecBLoc[i]=0.;</span>
<span class="lineNum">     144 </span>            :     
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :     for (int j=0; j&lt;fNLocalPar;j++) {</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :       fMatCLoc[i][j]=0.;</span>
<span class="lineNum">     147 </span>            :     }
<span class="lineNum">     148 </span>            :   }
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span>            :   // Then we fix all parameters...
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :   for (int j=0; j&lt;fNGlobalPar; j++) {</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :     AliMillepede::SetParSigma(j,0.0);</span>
<span class="lineNum">     154 </span>            :   }
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :   fDerivLocEq.Reset();  fNDerivLocEq=0;  </span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :   fIndexLocEq.Reset();  fNIndexLocEq=0; </span>
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :   fIndexAllEqs.Reset();  fNIndexAllEqs=0;</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :   fDerivAllEqs.Reset();  fNDerivAllEqs=0;</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :   fLocEqPlace.Reset();  fNLocEqPlace=0;</span>
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :   AliDebug(1,&quot;&quot;);</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :   AliDebug(1,&quot;----------------------------------------------------&quot;);</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :   AliDebug(1,&quot;&quot;);</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :   AliDebug(1,&quot;    InitMille has been successfully called!&quot;);</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :   AliDebug(1,&quot;&quot;);</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :   AliDebug(1,&quot;-----------------------------------------------------&quot;);</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :   AliDebug(1,&quot;&quot;);</span>
<span class="lineNum">     170 </span>            :         
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :   return 1;</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span>            : /*
<span class="lineNum">     175 </span>            : -----------------------------------------------------------
<span class="lineNum">     176 </span>            :   PARGLO: initialization of global parameters
<span class="lineNum">     177 </span>            : -----------------------------------------------------------
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            :   param    = array of starting values
<span class="lineNum">     180 </span>            : 
<a name="181"><span class="lineNum">     181 </span>            : -----------------------------------------------------------</a>
<span class="lineNum">     182 </span>            : */
<span class="lineNum">     183 </span>            : Int_t AliMillepede::SetGlobalParameters(double *param)
<span class="lineNum">     184 </span>            : {
<span class="lineNum">     185 </span>            :   /// initialization of global parameters
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :   for(Int_t iPar=0; iPar&lt;fNGlobalPar; iPar++){</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :     fInitPar[iPar] = param[iPar];</span>
<span class="lineNum">     188 </span>            :   }
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :  return 1;</span>
<span class="lineNum">     191 </span>            : }
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            : /*
<span class="lineNum">     194 </span>            : -----------------------------------------------------------
<span class="lineNum">     195 </span>            :   PARGLO: initialization of global parameters
<span class="lineNum">     196 </span>            : -----------------------------------------------------------
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span>            :   iPar    = the index of the global parameter in the 
<span class="lineNum">     199 </span>            :              result array (equivalent to fDeltaPar[]).
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            :   param    = the starting value
<span class="lineNum">     202 </span>            : 
<a name="203"><span class="lineNum">     203 </span>            : -----------------------------------------------------------</a>
<span class="lineNum">     204 </span>            : */
<span class="lineNum">     205 </span>            : Int_t AliMillepede::SetGlobalParameter(int iPar, double param)
<span class="lineNum">     206 </span>            : {
<span class="lineNum">     207 </span>            :   /// initialization of global parameter iPar
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :   if (iPar&lt;0 || iPar&gt;=fNGlobalPar) {</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     210 </span>            :   }
<span class="lineNum">     211 </span>            :   else {
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :     fInitPar[iPar] = param;</span>
<span class="lineNum">     213 </span>            :   }
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :   return 1;</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span>            : /*
<span class="lineNum">     219 </span>            : -----------------------------------------------------------
<span class="lineNum">     220 </span>            :   PARSIG: define a constraint for a single global param
<span class="lineNum">     221 </span>            :           param is 'encouraged' to vary within [-sigma;sigma] 
<span class="lineNum">     222 </span>            :           range
<span class="lineNum">     223 </span>            : -----------------------------------------------------------
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            :   iPar    = the index of the global parameter in the 
<span class="lineNum">     226 </span>            :              result array (equivalent to fDeltaPar[]).
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span>            :   sigma    = value of the constraint (sigma &lt;= 0. will 
<span class="lineNum">     229 </span>            :              mean that parameter is FIXED !!!) 
<span class="lineNum">     230 </span>            :  
<a name="231"><span class="lineNum">     231 </span>            : -----------------------------------------------------------</a>
<span class="lineNum">     232 </span>            : */ 
<span class="lineNum">     233 </span>            : Int_t AliMillepede::SetParSigma(int iPar, double sigma)
<span class="lineNum">     234 </span>            : {
<span class="lineNum">     235 </span>            :   /// Define a range [-sigma;sigma] where iPar is encourage to vary 
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :   if (iPar&gt;=fNGlobalPar) {</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     238 </span>            :   }
<span class="lineNum">     239 </span>            :   else {
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :     fSigmaPar[iPar] = sigma;</span>
<span class="lineNum">     241 </span>            :   }
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :   return 1;</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span>            : /*
<span class="lineNum">     248 </span>            : -----------------------------------------------------------
<span class="lineNum">     249 </span>            :   NONLIN: set nonlinear flag for a single global param
<span class="lineNum">     250 </span>            :           update of param durin iterations will not
<span class="lineNum">     251 </span>            :           consider initial starting value
<span class="lineNum">     252 </span>            : -----------------------------------------------------------
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            :   iPar    = the index of the global parameter in the 
<span class="lineNum">     255 </span>            :              result array (equivalent to fDeltaPar[]).
<span class="lineNum">     256 </span>            : 
<a name="257"><span class="lineNum">     257 </span>            : -----------------------------------------------------------</a>
<span class="lineNum">     258 </span>            : */
<span class="lineNum">     259 </span>            : Int_t AliMillepede::SetNonLinear(int iPar)
<span class="lineNum">     260 </span>            : {
<span class="lineNum">     261 </span>            :   /// Set nonlinear flag for iPar 
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :   if (iPar&lt;0 || iPar&gt;=fNGlobalPar) {</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     264 </span>            :   }
<span class="lineNum">     265 </span>            :   else {
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :     fIsNonLinear[iPar] = 1;</span>
<span class="lineNum">     267 </span>            :   }
<span class="lineNum">     268 </span>            :   
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :   return 1;</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span>            : /*
<span class="lineNum">     274 </span>            : -----------------------------------------------------------
<span class="lineNum">     275 </span>            :   INITUN: unit for iteration
<span class="lineNum">     276 </span>            : -----------------------------------------------------------
<span class="lineNum">     277 </span>            :   
<span class="lineNum">     278 </span>            :   lChi2CutFac is used by Fitloc to define the Chi^2/ndof cut value
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span>            :   A large cutfac value enables to take a wider range of tracks 
<span class="lineNum">     281 </span>            :   for first iterations, which might be useful if misalignments
<span class="lineNum">     282 </span>            :   are large.
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span>            :   As soon as cutfac differs from 0 iteration are requested.
<span class="lineNum">     285 </span>            :   cutfac is then reduced, from one iteration to the other,
<span class="lineNum">     286 </span>            :   and iterations are stopped when it reaches the value 1.
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            :   At least one more iteration is often needed in order to remove
<span class="lineNum">     289 </span>            :   tracks containing outliers.
<span class="lineNum">     290 </span>            :   
<a name="291"><span class="lineNum">     291 </span>            : -----------------------------------------------------------</a>
<span class="lineNum">     292 </span>            : */
<span class="lineNum">     293 </span>            : Int_t AliMillepede::SetIterations(double lChi2CutFac)
<span class="lineNum">     294 </span>            : {
<span class="lineNum">     295 </span>            :   /// Number of iterations is calculated from lChi2CutFac 
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :   fChi2CutFactor = TMath::Max(1.0, lChi2CutFac);</span>
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :   AliInfo(Form(&quot;Initial cut factor is %f&quot;,fChi2CutFactor));</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :   fIter = 1; // Initializes the iteration process</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :   return 1;</span>
<span class="lineNum">     301 </span>            : }
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span>            : /*
<span class="lineNum">     304 </span>            : -----------------------------------------------------------
<span class="lineNum">     305 </span>            :   CONSTF: define a constraint equation in AliMillepede
<span class="lineNum">     306 </span>            : -----------------------------------------------------------
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            :   dercs    = the row containing constraint equation 
<span class="lineNum">     309 </span>            :              derivatives (put into the final matrix)
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            :   lLagMult      = the lagrange multiplier value (sum of equation)            
<span class="lineNum">     312 </span>            : 
<a name="313"><span class="lineNum">     313 </span>            : -----------------------------------------------------------</a>
<span class="lineNum">     314 </span>            : */
<span class="lineNum">     315 </span>            : Int_t AliMillepede::SetGlobalConstraint(double dercs[], double lLagMult)
<span class="lineNum">     316 </span>            : { 
<span class="lineNum">     317 </span>            :   /// Define a constraint equation
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :   if (fNGlobalConstraints&gt;=fgkMaxGloCsts) {  </span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :     AliInfo(&quot;Too many constraints !!!&quot;);</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     321 </span>            :   }
<span class="lineNum">     322 </span>            :         
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :   for (int i=0; i&lt;fNGlobalPar; i++) {</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :     fMatDerConstr[fNGlobalConstraints][i] = dercs[i];</span>
<span class="lineNum">     325 </span>            :   }
<span class="lineNum">     326 </span>            :         
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :   fLagMult[fNGlobalConstraints] = lLagMult;</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :   fNGlobalConstraints++ ;</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :   AliInfo(Form(&quot;Number of constraints increased to %d&quot;,fNGlobalConstraints));</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :   return 1;</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            : /*
<span class="lineNum">     335 </span>            : -----------------------------------------------------------
<span class="lineNum">     336 </span>            :   EQULOC: write ONE equation in the matrices
<span class="lineNum">     337 </span>            : -----------------------------------------------------------
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            :   dergb[1..fNGlobalPar] = global parameters derivatives
<span class="lineNum">     340 </span>            :   derlc[1..fNLocalPar]  = local parameters derivatives
<span class="lineNum">     341 </span>            :   rmeas                 = measured value
<span class="lineNum">     342 </span>            :   sigma                 = error on measured value (nothing to do with SetParSigma!!!)
<span class="lineNum">     343 </span>            : 
<a name="344"><span class="lineNum">     344 </span>            : -----------------------------------------------------------</a>
<span class="lineNum">     345 </span>            : */
<span class="lineNum">     346 </span>            : Int_t AliMillepede::SetLocalEquation(double dergb[], double derlc[], double lMeas, double lSigma)
<span class="lineNum">     347 </span>            : {       
<span class="lineNum">     348 </span>            :   /// Write one local equation
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :   if (lSigma&lt;=0.0) { // If parameter is fixed, then no equation</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :     for (int i=0; i&lt;fNLocalPar; i++) {</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :       derlc[i] = 0.0;</span>
<span class="lineNum">     352 </span>            :     }
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :     for (int i=0; i&lt;fNGlobalPar; i++) {</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :       dergb[i] = 0.0;</span>
<span class="lineNum">     355 </span>            :     }
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :     return 1;</span>
<span class="lineNum">     357 </span>            :   }
<span class="lineNum">     358 </span>            :     
<span class="lineNum">     359 </span>            :   // Serious equation, initialize parameters    
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :   double lWeight =  1.0/(lSigma*lSigma);</span>
<span class="lineNum">     361 </span>            :   int iLocFirst  = -1;
<span class="lineNum">     362 </span>            :   int iLocLast   = -1;
<span class="lineNum">     363 </span>            :   int iGlobFirst = -1;
<span class="lineNum">     364 </span>            :   int iGlobLast  = -1;
<span class="lineNum">     365 </span>            :  
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :   for (int i=0; i&lt;fNLocalPar; i++) { // Retrieve local param interesting indices</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :     if (derlc[i]!=0.0) {</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :       if (iLocFirst == -1) { </span>
<span class="lineNum">     369 </span>            :         iLocFirst = i;  // first index
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     371 </span>            :       iLocLast = i;     // last index
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     373 </span>            :   }
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :   AliDebug(2,Form(&quot;%d / %d&quot;,iLocFirst, iLocLast));</span>
<span class="lineNum">     375 </span>            :         
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :   for (int i=0; i&lt;fNGlobalPar; i++) { // Idem for global parameters</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :     if (dergb[i]!=0.0) {</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :       if (iGlobFirst == -1) {</span>
<span class="lineNum">     379 </span>            :         iGlobFirst = i;  // first index
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     381 </span>            :       iGlobLast = i;     // last index
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     383 </span>            :   }
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :   AliDebug(2,Form(&quot;%d / %d&quot;,iGlobFirst,iGlobLast));</span>
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :   if (fNIndexLocEq==fIndexLocEq.GetSize()) fIndexLocEq.Set(2*fNIndexLocEq);</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :   fIndexLocEq.AddAt(-1,fNIndexLocEq++);    </span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :   if (fNDerivLocEq==fDerivLocEq.GetSize()) fDerivLocEq.Set(2*fNDerivLocEq);</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :   fDerivLocEq.AddAt(lMeas,fNDerivLocEq++);    </span>
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :   for (int i=iLocFirst; i&lt;=iLocLast; i++) { // Store interesting local parameters</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :     if (derlc[i]!=0.0) {</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :       if (fNIndexLocEq==fIndexLocEq.GetSize()) fIndexLocEq.Set(2*fNIndexLocEq);</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :       fIndexLocEq.AddAt(i,fNIndexLocEq++);    </span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :       if (fNDerivLocEq==fDerivLocEq.GetSize()) fDerivLocEq.Set(2*fNDerivLocEq);</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :       fDerivLocEq.AddAt(derlc[i],fNDerivLocEq++);    </span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :       derlc[i] = 0.0;</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     400 </span>            :   }
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :   if (fNIndexLocEq==fIndexLocEq.GetSize()) fIndexLocEq.Set(2*fNIndexLocEq);</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :   fIndexLocEq.AddAt(-1,fNIndexLocEq++);    </span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :   if (fNDerivLocEq==fDerivLocEq.GetSize()) fDerivLocEq.Set(2*fNDerivLocEq);</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :   fDerivLocEq.AddAt(lWeight,fNDerivLocEq++);    </span>
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :   for (int i=iGlobFirst; i&lt;=iGlobLast; i++) { // Store interesting global parameters</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :     if (dergb[i]!=0.0) {</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :       if (fNIndexLocEq==fIndexLocEq.GetSize()) fIndexLocEq.Set(2*fNIndexLocEq);</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :       fIndexLocEq.AddAt(i,fNIndexLocEq++);    </span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :       if (fNDerivLocEq==fDerivLocEq.GetSize()) fDerivLocEq.Set(2*fNDerivLocEq);</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :       fDerivLocEq.AddAt(dergb[i],fNDerivLocEq++);    </span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :       dergb[i] = 0.0;</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     415 </span>            :   }
<span class="lineNum">     416 </span>            :   
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :   AliDebug(2,Form(&quot;Out Equloc --  NST = %d&quot;,fNDerivLocEq));</span>
<span class="lineNum">     418 </span>            :   return 1;     
<span class="lineNum">     419 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span>            : /*
<span class="lineNum">     422 </span>            : -----------------------------------------------------------
<span class="lineNum">     423 </span>            :   FITLOC:  perform local params fit, once all the equations
<span class="lineNum">     424 </span>            :            have been written by EquLoc
<span class="lineNum">     425 </span>            : -----------------------------------------------------------
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span>            :   iFit        = number of the fit, it is used to store 
<span class="lineNum">     428 </span>            :                 fit parameters and then retrieve them 
<span class="lineNum">     429 </span>            :                 for iterations (via FINDEXALLEQS and FDERIVALLEQS)
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span>            :   localParams = contains the fitted track parameters and
<span class="lineNum">     432 </span>            :                 related errors
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span>            :   bSingleFit  = is an option, if it is set to 1, we don't 
<span class="lineNum">     435 </span>            :                 perform the last loop. It is used to update 
<span class="lineNum">     436 </span>            :                 the track parameters without modifying global
<span class="lineNum">     437 </span>            :                 matrices
<span class="lineNum">     438 </span>            : 
<a name="439"><span class="lineNum">     439 </span>            : -----------------------------------------------------------</a>
<span class="lineNum">     440 </span>            : */
<span class="lineNum">     441 </span>            : Int_t AliMillepede::LocalFit(int iFit, double localParams[], Bool_t bSingleFit)
<span class="lineNum">     442 </span>            : {
<span class="lineNum">     443 </span>            :   /// Perform local parameters fit once all the local equations have been set
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span>            :   // Few initializations
<span class="lineNum">     446 </span>            :   int iEqTerm = 0;
<span class="lineNum">     447 </span>            :   int i, j, k;
<span class="lineNum">     448 </span>            :   int iIdx, jIdx, kIdx;
<span class="lineNum">     449 </span>            :   int iIdxIdx, jIdxIdx;
<span class="lineNum">     450 </span>            :   int iMeas   = -1;
<span class="lineNum">     451 </span>            :   int iWeight = 0;
<span class="lineNum">     452 </span>            :   int iLocFirst = 0;
<span class="lineNum">     453 </span>            :   int iLocLast  = 0;
<span class="lineNum">     454 </span>            :   int iGloFirst = 0;
<span class="lineNum">     455 </span>            :   int iGloLast  = 0;
<span class="lineNum">     456 </span>            :   int nGloInFit = 0;
<span class="lineNum">     457 </span>            :         
<span class="lineNum">     458 </span>            :   double lMeas    = 0.0;
<span class="lineNum">     459 </span>            :   double lWeight  = 0.0;
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span>            :   double lChi2    = 0.0;
<span class="lineNum">     462 </span>            :   double lRedChi2 = 0.0;
<span class="lineNum">     463 </span>            :   double lChi2Cut = 0.0;
<span class="lineNum">     464 </span>            :   int nEq  = 0;
<span class="lineNum">     465 </span>            :   int nDoF = 0;
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :   int nEqTerms = fNDerivLocEq; // Number of terms (local + global derivatives,           </span>
<span class="lineNum">     467 </span>            :                                // measurement and weight) involved in this local equation
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span>            :   // Fill the track store at first pass
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :   if (fIter &lt; 2 &amp;&amp; !bSingleFit) { // Do it only once </span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :     AliDebug(1,Form(&quot;Store equation no: %d&quot;, iFit)); </span>
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :     for (i=0; i&lt;nEqTerms; i++) { // Store the track parameters</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :       if (fNIndexAllEqs==fIndexAllEqs.GetSize()) fIndexAllEqs.Set(2*fNIndexAllEqs);</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :       fIndexAllEqs.AddAt(fIndexLocEq[i],fNIndexAllEqs++);</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :       if (fNDerivAllEqs==fDerivAllEqs.GetSize()) fDerivAllEqs.Set(2*fNDerivAllEqs);</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :       fDerivAllEqs.AddAt(fDerivLocEq[i],fNDerivAllEqs++);</span>
<span class="lineNum">     480 </span>            :     }
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :     if (fNLocEqPlace==fLocEqPlace.GetSize()) fLocEqPlace.Set(2*fNLocEqPlace);</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :     fLocEqPlace.AddAt(fNIndexAllEqs,fNLocEqPlace++);</span>
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span>            :     
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :     AliDebug(2,Form(&quot;FLocEqPlace size = %d&quot;,fLocEqPlace[iFit])); </span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :     AliDebug(2,Form(&quot;FIndexAllEqs size   = %d&quot;,fNIndexAllEqs)); </span>
<span class="lineNum">     487 </span>            :   }
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :   for (i=0; i&lt;fNLocalPar; i++) { // reset local params</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :     fVecBLoc[i] = 0.0;</span>
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :     for (j=0; j&lt;fNLocalPar; j++) {</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :       fMatCLoc[i][j] = 0.0;</span>
<span class="lineNum">     495 </span>            :     }
<span class="lineNum">     496 </span>            :   }
<span class="lineNum">     497 </span>            :         
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :   for (i=0; i&lt;fNGlobalPar; i++) {</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :     fGlo2CGLRow[i] = -1;  // reset mixed params</span>
<span class="lineNum">     500 </span>            :   }
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span>            : /*
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span>            :   LOOPS : HOW DOES IT WORKS ?   
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span>            :   Now start by reading the informations stored with EquLoc.
<span class="lineNum">     508 </span>            :   Those informations are in vector FINDEXSTORE and FDERIVSTORE.
<span class="lineNum">     509 </span>            :   Each -1 in FINDEXSTORE delimits the equation parameters:
<span class="lineNum">     510 </span>            :   
<span class="lineNum">     511 </span>            :   First -1  ---&gt; lMeas in FDERIVSTORE 
<span class="lineNum">     512 </span>            :   Then we have indices of local eq in FINDEXSTORE, and derivatives in FDERIVSTORE
<span class="lineNum">     513 </span>            :   Second -1 ---&gt; weight in FDERIVSTORE
<span class="lineNum">     514 </span>            :   Then follows indices and derivatives of global eq.
<span class="lineNum">     515 </span>            :   ....
<span class="lineNum">     516 </span>            :   
<span class="lineNum">     517 </span>            :   We took them and store them into matrices.
<span class="lineNum">     518 </span>            :   
<span class="lineNum">     519 </span>            :   As we want ONLY local params, we substract the part of the estimated value
<span class="lineNum">     520 </span>            :   due to global params. Indeed we could have already an idea of these params,
<span class="lineNum">     521 </span>            :   with previous alignment constants for example (set with PARGLO). Also if there
<span class="lineNum">     522 </span>            :   are more than one iteration (FITLOC could be called by FITGLO)
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span>            : */
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span>            :     
<span class="lineNum">     527 </span>            : //
<span class="lineNum">     528 </span>            : // FIRST LOOP : local track fit
<span class="lineNum">     529 </span>            : //
<span class="lineNum">     530 </span>            :         
<span class="lineNum">     531 </span>            :   iEqTerm = 0;
<span class="lineNum">     532 </span>            : //   fIndexLocEq.push_back(-1);
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :   if (fNIndexLocEq==fIndexLocEq.GetSize()) fIndexLocEq.Set(2*fNIndexLocEq);</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :   fIndexLocEq.AddAt(-1,fNIndexLocEq++);    </span>
<span class="lineNum">     535 </span>            :   
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :   while (iEqTerm &lt;= nEqTerms) {</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :     if (fIndexLocEq[iEqTerm] == -1) {</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :       if (iMeas == -1) {        // First  -1 : lMeas</span>
<span class="lineNum">     539 </span>            :         iMeas = iEqTerm;
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :         iLocFirst = iEqTerm+1;</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :       }  </span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :       else if (iWeight == 0) {  // Second -1 : weight </span>
<span class="lineNum">     543 </span>            :         iWeight = iEqTerm;
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :         iLocLast = iEqTerm-1;</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :         iGloFirst = iEqTerm+1;</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :       } </span>
<span class="lineNum">     547 </span>            :       else {                    // Third  -1 : end of equation; start of next  
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :         iGloLast = iEqTerm-1;</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :         lMeas   = fDerivLocEq[iMeas];</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :         lWeight         = fDerivLocEq[iWeight];</span>
<span class="lineNum">     551 </span>            : //      AliDebug(1,Form(&quot;lMeas = %f&quot;, lMeas));
<span class="lineNum">     552 </span>            : //      AliDebug(1,Form(&quot;lWeight = %f&quot;, lWeight));
<span class="lineNum">     553 </span>            :         
<span class="lineNum">     554 </span>            :         // Now suppress the global part (only relevant with iterations)
<span class="lineNum">     555 </span>            :         // 
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :         for (i=iGloFirst; i&lt;=iGloLast; i++) {</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :           iIdx = fIndexLocEq[i];              // Global param indice</span>
<span class="lineNum">     558 </span>            : //        AliDebug(2,Form(&quot;fDeltaPar[%d] = %f&quot;, iIdx, fDeltaPar[iIdx]));        
<span class="lineNum">     559 </span>            : //        AliDebug(2,Form(&quot;Starting misalignment = %f&quot;,fInitPar[iIdx]));        
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :           if (fIsNonLinear[iIdx] == 0)</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :             lMeas -= fDerivLocEq[i]*(fInitPar[iIdx]+fDeltaPar[iIdx]); // linear parameter</span>
<span class="lineNum">     562 </span>            :           else
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :             lMeas -= fDerivLocEq[i]*(fDeltaPar[iIdx]); // nonlinear parameter</span>
<span class="lineNum">     564 </span>            :         }
<span class="lineNum">     565 </span>            : //      AliDebug(2,Form(&quot;lMeas after global stuff removal = %f&quot;, lMeas));
<span class="lineNum">     566 </span>            :                                 
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :         for (i=iLocFirst; i&lt;=iLocLast; i++) { // Finally fill local matrix and vector</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :           iIdx = fIndexLocEq[i];   // Local param indice (the matrix line) </span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :           fVecBLoc[iIdx] += lWeight*lMeas*fDerivLocEq[i];  </span>
<span class="lineNum">     570 </span>            : //        AliDebug(2,Form(&quot;fVecBLoc[%d] = %f&quot;, iIdx, fVecBLoc[iIdx]));
<span class="lineNum">     571 </span>            :                                         
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :           for (j=iLocFirst; j&lt;=i ; j++) { // Symmetric matrix, don't bother j&gt;i coeffs</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :             jIdx = fIndexLocEq[j];                                              </span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :             fMatCLoc[iIdx][jIdx] += lWeight*fDerivLocEq[i]*fDerivLocEq[j];          </span>
<span class="lineNum">     575 </span>            : //          AliDebug(2,Form(&quot;fMatCLoc[%d][%d] = &quot;, iIdx, jIdx, fMatCLoc[iIdx][jIdx]));
<span class="lineNum">     576 </span>            :           }
<span class="lineNum">     577 </span>            :         }
<span class="lineNum">     578 </span>            :         iMeas   = -1;
<span class="lineNum">     579 </span>            :         iWeight = 0;
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :         iEqTerm--;   // end of one equation is the beginning of next</span>
<span class="lineNum">     581 </span>            :       } // End of &quot;end of equation&quot; operations
<span class="lineNum">     582 </span>            :     } // End of loop on equation
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :     iEqTerm++;</span>
<span class="lineNum">     584 </span>            :   } // End of loop on all equations used in the fit
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span>            : //
<span class="lineNum">     588 </span>            : // Local params matrix is completed, now invert to solve...
<span class="lineNum">     589 </span>            : //
<span class="lineNum">     590 </span>            :         
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :   Int_t nRank = AliMillepede::SpmInv(fMatCLoc, fVecBLoc, fNLocalPar);</span>
<span class="lineNum">     592 </span>            :   // nRank is the number of nonzero diagonal elements 
<span class="lineNum">     593 </span>            :         
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :   AliDebug(1,&quot;&quot;);</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :   AliDebug(1,&quot; __________________________________________________&quot;);</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :   AliDebug(1,Form(&quot; Printout of local fit  (FITLOC)  with rank= %d&quot;, nRank));</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :   AliDebug(1,&quot; Result of local fit :      (index/parameter/error)&quot;);</span>
<span class="lineNum">     598 </span>            :   
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :   for (i=0; i&lt;fNLocalPar; i++) {</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :     AliDebug(1,Form(&quot;%d   /   %.6f   /   %.6f&quot;, i, fVecBLoc[i], TMath::Sqrt(fMatCLoc[i][i])));        </span>
<span class="lineNum">     601 </span>            :   }
<span class="lineNum">     602 </span>            :   
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span>            : // Store the track params and errors
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :   for (i=0; i&lt;fNLocalPar; i++) {</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :     localParams[2*i] = fVecBLoc[i];</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :     localParams[2*i+1] = TMath::Sqrt(TMath::Abs(fMatCLoc[i][i]));</span>
<span class="lineNum">     609 </span>            :   }
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span>            :     
<span class="lineNum">     612 </span>            : //
<span class="lineNum">     613 </span>            : // SECOND LOOP : residual calculation
<span class="lineNum">     614 </span>            : //
<span class="lineNum">     615 </span>            :   
<span class="lineNum">     616 </span>            :   iEqTerm = 0;
<span class="lineNum">     617 </span>            :   iMeas = -1;
<span class="lineNum">     618 </span>            :   iWeight = 0;
<span class="lineNum">     619 </span>            : 
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :   while (iEqTerm &lt;= nEqTerms) {</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :     if (fIndexLocEq[iEqTerm] == -1) {</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :       if (iMeas == -1) {        // First  -1 : lMeas</span>
<span class="lineNum">     623 </span>            :         iMeas = iEqTerm;
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :         iLocFirst = iEqTerm+1;</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :       }  </span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :       else if (iWeight == 0) {  // Second -1 : weight </span>
<span class="lineNum">     627 </span>            :         iWeight = iEqTerm;
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :         iLocLast = iEqTerm-1;</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :         iGloFirst = iEqTerm+1;</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :       } </span>
<span class="lineNum">     631 </span>            :       else {                    // Third  -1 : end of equation; start of next  
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :         iGloLast = iEqTerm-1;</span>
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :         lMeas   = fDerivLocEq[iMeas];</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :         lWeight         = fDerivLocEq[iWeight];</span>
<span class="lineNum">     635 </span>            :         
<span class="lineNum">     636 </span>            :         // Print all (for debugging purposes)
<span class="lineNum">     637 </span>            : 
<span class="lineNum">     638 </span>            : //      int nDerLoc = iLocLast-iLocFirst+1;   // Number of local derivatives involved
<span class="lineNum">     639 </span>            : //      int nDerGlo = iGloLast-iGloFirst+1;   // Number of global derivatives involved
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span>            : //      AliDebug(2,&quot;&quot;);
<span class="lineNum">     642 </span>            : //      AliDebug(2,Form(&quot;. equation:  measured value %.6f +/- %.6f&quot;, lMeas, 1.0/TMath::Sqrt(lWeight)));
<span class="lineNum">     643 </span>            : //      AliDebug(2,Form(&quot;Number of derivatives (global, local): %d, %d&quot;,nDerGlo,nDerLoc));
<span class="lineNum">     644 </span>            : //      AliDebug(2,&quot;Global derivatives are: (index/derivative/parvalue) &quot;);
<span class="lineNum">     645 </span>            :         
<span class="lineNum">     646 </span>            : //      for (i=iGloFirst; i&lt;=iGloLast; i++) {
<span class="lineNum">     647 </span>            : //        AliDebug(2,Form(&quot;%d / %.6f / %.6f&quot;,fIndexLocEq[i],fDerivLocEq[i],fInitPar[fIndexLocEq[i]]));
<span class="lineNum">     648 </span>            : //      } 
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span>            : //      AliDebug(2,&quot;Local derivatives are: (index/derivative) &quot;);
<span class="lineNum">     651 </span>            :         
<span class="lineNum">     652 </span>            : //      for (i=(ja+1); i&lt;jb; i++) {AliDebug(2,Form(&quot;%d / %.6f&quot;,fIndexLocEq[i], fDerivLocEq[i]));}    
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span>            :         // Now suppress local and global parts to LMEAS;
<span class="lineNum">     655 </span>            :         //
<span class="lineNum">     656 </span>            :         // First the local part 
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :         for (i=iLocFirst; i&lt;=iLocLast; i++) { </span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :           iIdx = fIndexLocEq[i];</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :           lMeas -= fDerivLocEq[i]*fVecBLoc[iIdx];</span>
<span class="lineNum">     660 </span>            :         }
<span class="lineNum">     661 </span>            :         // Then the global part
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :         for (i=iGloFirst; i&lt;=iGloLast; i++) {</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :           iIdx = fIndexLocEq[i];</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :           if (fIsNonLinear[iIdx] == 0)</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :             lMeas -= fDerivLocEq[i]*(fInitPar[iIdx]+fDeltaPar[iIdx]); // linear parameter</span>
<span class="lineNum">     666 </span>            :           else
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :             lMeas -= fDerivLocEq[i]*(fDeltaPar[iIdx]); // nonlinear parameter</span>
<span class="lineNum">     668 </span>            :         }
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span>            :         // lMeas contains now the residual value
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :         AliDebug(2,Form(&quot;Residual value : %.6f&quot;, lMeas));</span>
<span class="lineNum">     672 </span>            : 
<span class="lineNum">     673 </span>            :         // reject the track if lMeas is too important (outlier)
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :         if (TMath::Abs(lMeas) &gt;= fResCutInit &amp;&amp; fIter &lt;= 1) {</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :           AliDebug(2,&quot;Rejected track !!!!!&quot;);</span>
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :           fNLocalFitsRejected++;      </span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :           fIndexLocEq.Reset();  fNIndexLocEq=0; // reset stores and go to the next track </span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :           fDerivLocEq.Reset();  fNDerivLocEq=0;   </span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :           return 0;</span>
<span class="lineNum">     680 </span>            :         }
<span class="lineNum">     681 </span>            : 
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :         if (TMath::Abs(lMeas) &gt;= fResCut &amp;&amp; fIter &gt; 1) {</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :           AliDebug(2,&quot;Rejected track !!!!!&quot;);</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :           fNLocalFitsRejected++;      </span>
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :           fIndexLocEq.Reset();  fNIndexLocEq=0; // reset stores and go to the next track </span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :           fDerivLocEq.Reset();  fNDerivLocEq=0;   </span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :           return 0;</span>
<span class="lineNum">     688 </span>            :         }
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :         lChi2 += lWeight*lMeas*lMeas ; // total chi^2</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :         nEq++;                    // number of equations                        </span>
<span class="lineNum">     692 </span>            :         iMeas   = -1;
<span class="lineNum">     693 </span>            :         iWeight = 0;
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :         iEqTerm--;</span>
<span class="lineNum">     695 </span>            :       } // End of &quot;end of equation&quot; operations
<span class="lineNum">     696 </span>            :     }   // End of loop on equation
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :     iEqTerm++;</span>
<span class="lineNum">     698 </span>            :   } // End of loop on all equations used in the fit
<span class="lineNum">     699 </span>            : 
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :   nDoF = nEq-nRank;     </span>
<span class="lineNum">     701 </span>            :   lRedChi2 = 0.0;
<span class="lineNum">     702 </span>            : 
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :   AliDebug(1,Form(&quot;Final chi square / degrees of freedom %.2f / %d&quot;,lChi2, nDoF));</span>
<span class="lineNum">     704 </span>            :   
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :   if (nDoF &gt; 0) lRedChi2 = lChi2/float(nDoF);  // Chi^2/dof</span>
<span class="lineNum">     706 </span>            :         
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :   fNLocalFits++;</span>
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :   if (fNStdDev != 0 &amp;&amp; nDoF &gt; 0 &amp;&amp; !bSingleFit) // Chisquare cut</span>
<span class="lineNum">     710 </span>            :   {
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :     lChi2Cut = AliMillepede::Chi2DoFLim(fNStdDev, nDoF)*fChi2CutFactor;</span>
<span class="lineNum">     712 </span>            :     
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :     AliDebug(1,Form(&quot;Reject if Chisq/Ndf = %.4f &gt; %.4f&quot;,lRedChi2,lChi2Cut));</span>
<span class="lineNum">     714 </span>            :  
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :     if (lRedChi2 &gt; lChi2Cut) // Reject the track if too much...</span>
<span class="lineNum">     716 </span>            :     {
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :       AliDebug(2,&quot;Rejected track !!!!!&quot;);</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :       fNLocalFitsRejected++;      </span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :       fIndexLocEq.Reset();  fNIndexLocEq=0; // reset stores and go to the next track </span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :       fDerivLocEq.Reset();  fNDerivLocEq=0;</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">     722 </span>            :     }
<span class="lineNum">     723 </span>            :   }
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :   if (bSingleFit) // Stop here if just updating the track parameters</span>
<span class="lineNum">     726 </span>            :   {
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :     fIndexLocEq.Reset();  fNIndexLocEq=0; // Reset store for the next track </span>
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :     fDerivLocEq.Reset();  fNDerivLocEq=0;</span>
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :     return 1;</span>
<span class="lineNum">     730 </span>            :   }
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span>            : //  
<span class="lineNum">     733 </span>            : // THIRD LOOP: local operations are finished, track is accepted 
<span class="lineNum">     734 </span>            : // We now update the global parameters (other matrices)
<span class="lineNum">     735 </span>            : //
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span>            :   iEqTerm = 0;
<span class="lineNum">     738 </span>            :   iMeas = -1;
<span class="lineNum">     739 </span>            :   iWeight = 0;
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :   while (iEqTerm &lt;= nEqTerms)</span>
<span class="lineNum">     742 </span>            :   {
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :     if (fIndexLocEq[iEqTerm] == -1)</span>
<span class="lineNum">     744 </span>            :     {
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :       if (iMeas == -1) {        // First  -1 : lMeas</span>
<span class="lineNum">     746 </span>            :         iMeas = iEqTerm;
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :         iLocFirst = iEqTerm+1;</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :       }  </span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :       else if (iWeight == 0) {  // Second -1 : weight </span>
<span class="lineNum">     750 </span>            :         iWeight = iEqTerm;
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :         iLocLast = iEqTerm-1;</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :         iGloFirst = iEqTerm+1;</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :       } </span>
<span class="lineNum">     754 </span>            :       else {                    // Third  -1 : end of equation; start of next  
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :         iGloLast = iEqTerm-1;</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :         lMeas   = fDerivLocEq[iMeas];</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :         lWeight         = fDerivLocEq[iWeight];</span>
<span class="lineNum">     758 </span>            : 
<span class="lineNum">     759 </span>            :         // Now suppress the global part
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :         for (i=iGloFirst; i&lt;=iGloLast; i++) {</span>
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :           iIdx = fIndexLocEq[i];   // Global param indice</span>
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :           if (fIsNonLinear[iIdx] == 0)</span>
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :             lMeas -= fDerivLocEq[i]*(fInitPar[iIdx]+fDeltaPar[iIdx]); // linear parameter</span>
<span class="lineNum">     764 </span>            :           else
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :             lMeas -= fDerivLocEq[i]*(fDeltaPar[iIdx]); // nonlinear parameter</span>
<span class="lineNum">     766 </span>            :         }
<span class="lineNum">     767 </span>            :         
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :         for (i=iGloFirst; i&lt;=iGloLast; i++) {</span>
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :           iIdx = fIndexLocEq[i];   // Global param indice (the matrix line)          </span>
<span class="lineNum">     770 </span>            :         
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :           fVecBGlo[iIdx] += lWeight*lMeas*fDerivLocEq[i];  </span>
<span class="lineNum">     772 </span>            : //        AliDebug(2,Form(&quot;fVecBGlo[%d] = %.6f&quot;, j, fVecBGlo[j] ));
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span>            :           // First of all, the global/global terms (exactly like local matrix)
<span class="lineNum">     775 </span>            :           //      
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :           for (j=iGloFirst; j&lt;=iGloLast; j++) {        </span>
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :             jIdx = fIndexLocEq[j];                      </span>
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :             fMatCGlo[iIdx][jIdx] += lWeight*fDerivLocEq[i]*fDerivLocEq[j];</span>
<span class="lineNum">     779 </span>            : //          AliDebug(2,Form(&quot;fMatCGlo[%d][%d] = %.6f&quot;,iIdx,jIdx,fMatCGlo[iIdx][jIdx]));
<span class="lineNum">     780 </span>            :           } 
<span class="lineNum">     781 </span>            : 
<span class="lineNum">     782 </span>            :           // Now we have also rectangular matrices containing global/local terms.
<span class="lineNum">     783 </span>            :           //
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :           iIdxIdx = fGlo2CGLRow[iIdx];  // Index of index          </span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :           if (iIdxIdx == -1) {    // New global variable         </span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :             for (k=0; k&lt;fNLocalPar; k++) {</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :               fMatCGloLoc[nGloInFit][k] = 0.0;  // Initialize the row</span>
<span class="lineNum">     788 </span>            :             }
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :             fGlo2CGLRow[iIdx] = nGloInFit;</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :             fCGLRow2Glo[nGloInFit] = iIdx;</span>
<span class="lineNum">     791 </span>            :             iIdxIdx = nGloInFit;
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :             nGloInFit++;</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span>            :           // Now fill the rectangular matrix
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :           for (k=iLocFirst; k&lt;=iLocLast ; k++) {</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :             kIdx = fIndexLocEq[k];                                              </span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :             fMatCGloLoc[iIdxIdx][kIdx] += lWeight*fDerivLocEq[i]*fDerivLocEq[k];</span>
<span class="lineNum">     799 </span>            : //          AliDebug(2,Form(&quot;fMatCGloLoc[%d][%d] = %.6f&quot;,iIdxIdx,kIdx,fMatCGloLoc[iIdxIdx][kIdx]));
<span class="lineNum">     800 </span>            :           } 
<span class="lineNum">     801 </span>            :         }
<span class="lineNum">     802 </span>            :         iMeas   = -1;
<span class="lineNum">     803 </span>            :         iWeight =  0;
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :         iEqTerm--;</span>
<span class="lineNum">     805 </span>            :       } // End of &quot;end of equation&quot; operations
<span class="lineNum">     806 </span>            :     }   // End of loop on equation
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :     iEqTerm++;</span>
<span class="lineNum">     808 </span>            :   } // End of loop on all equations used in the fit
<span class="lineNum">     809 </span>            :         
<span class="lineNum">     810 </span>            :   // Third loop is finished, now we update the correction matrices
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :   AliMillepede::SpAVAt(fMatCLoc, fMatCGloLoc, fMatCGloCorr, fNLocalPar, nGloInFit);</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :   AliMillepede::SpAX(fMatCGloLoc, fVecBLoc, fVecBGloCorr, fNLocalPar, nGloInFit);</span>
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :   for (iIdxIdx=0; iIdxIdx&lt;nGloInFit; iIdxIdx++) {</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :     iIdx = fCGLRow2Glo[iIdxIdx];</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :     fVecBGlo[iIdx] -= fVecBGloCorr[iIdxIdx];</span>
<span class="lineNum">     817 </span>            :     
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :     for (jIdxIdx=0; jIdxIdx&lt;=iIdxIdx; jIdxIdx++) {    </span>
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :       jIdx = fCGLRow2Glo[jIdxIdx];</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :       fMatCGlo[iIdx][jIdx] -= fMatCGloCorr[iIdxIdx][jIdxIdx];</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :       fMatCGlo[jIdx][iIdx] = fMatCGlo[iIdx][jIdx];</span>
<span class="lineNum">     822 </span>            :     }
<span class="lineNum">     823 </span>            :   }
<span class="lineNum">     824 </span>            :         
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :   fIndexLocEq.Reset();  fNIndexLocEq=0; // Reset store for the next track </span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :   fDerivLocEq.Reset();  fNDerivLocEq=0;</span>
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :   return 1;</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     830 </span>            :  
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span>            : /*
<span class="lineNum">     833 </span>            : -----------------------------------------------------------
<span class="lineNum">     834 </span>            :   MAKEGLOBALFIT:  perform global params fit, once all the 'tracks'
<span class="lineNum">     835 </span>            :                   have been fitted by FitLoc
<span class="lineNum">     836 </span>            : -----------------------------------------------------------
<span class="lineNum">     837 </span>            : 
<span class="lineNum">     838 </span>            :   par[]        = array containing the computed global 
<span class="lineNum">     839 </span>            :                  parameters (the misalignment constants)
<span class="lineNum">     840 </span>            : 
<span class="lineNum">     841 </span>            :   error[]      = array containing the error on global 
<span class="lineNum">     842 </span>            :                  parameters (estimated by AliMillepede)
<span class="lineNum">     843 </span>            : 
<span class="lineNum">     844 </span>            :   pull[]        = array containing the corresponding pulls 
<span class="lineNum">     845 </span>            : 
<a name="846"><span class="lineNum">     846 </span>            : -----------------------------------------------------------</a>
<span class="lineNum">     847 </span>            : */
<span class="lineNum">     848 </span>            : Int_t AliMillepede::GlobalFit(double par[], double error[], double pull[])
<span class="lineNum">     849 </span>            : {
<span class="lineNum">     850 </span>            :   /// perform global parameters fit once all the local equations have been fitted
<span class="lineNum">     851 </span>            :   int i, j;
<span class="lineNum">     852 </span>            :   int nVar    = 0;
<span class="lineNum">     853 </span>            :   int nGloFix = 0;
<span class="lineNum">     854 </span>            :   double lConstraint;
<span class="lineNum">     855 </span>            : 
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :   double step[fgkMaxGlobalPar]={0};</span>
<span class="lineNum">     857 </span>            : 
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :   double localPars[2*fgkMaxLocalPar];</span>
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span>            :   int nLocFitsGood = 0;
<span class="lineNum">     861 </span>            :   int nLocFitsTot  = 0;
<span class="lineNum">     862 </span>            :   int nLocFits     = 0;
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :   AliInfo(&quot;..... Making global fit .....&quot;);</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :   AliInfo(Form(&quot;First Iteration with cut factor %.2f&quot;, fChi2CutFactor));</span>
<span class="lineNum">     866 </span>            : 
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :   nLocFitsTot = AliMillepede::GetNLocalEquations();</span>
<span class="lineNum">     868 </span>            :         
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :   while (fIter &lt; fMaxIter)  // Iteration for the final loop</span>
<span class="lineNum">     870 </span>            :   {
<span class="lineNum">     871 </span>            : 
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :     nLocFits = AliMillepede::GetNLocalEquations();</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :     AliInfo(Form(&quot;...using %d local fits...&quot;,nLocFits));</span>
<span class="lineNum">     874 </span>            : 
<span class="lineNum">     875 </span>            : // Start by saving the diagonal elements
<span class="lineNum">     876 </span>            :     
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :     for (i=0; i&lt;fNGlobalPar; i++) {</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :       fDiagCGlo[i] = fMatCGlo[i][i];</span>
<span class="lineNum">     879 </span>            :     }
<span class="lineNum">     880 </span>            : 
<span class="lineNum">     881 </span>            : //  Then we retrieve the different constraints: fixed parameter or global equation
<span class="lineNum">     882 </span>            : 
<span class="lineNum">     883 </span>            :     nGloFix = 0; // First look at the fixed global params
<span class="lineNum">     884 </span>            :     
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :     for (i=0; i&lt;fNGlobalPar; i++) {    </span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :       if (fSigmaPar[i] &lt;= 0.0) {  // fixed global param</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :         nGloFix++;</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :         for (j=0; j&lt;fNGlobalPar; j++) {</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :           fMatCGlo[i][j] = 0.0;  // Reset row and column</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :           fMatCGlo[j][i] = 0.0;</span>
<span class="lineNum">     891 </span>            :         }
<span class="lineNum">     892 </span>            :       }
<span class="lineNum">     893 </span>            :       else {
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :         fMatCGlo[i][i] += 1.0/(fSigmaPar[i]*fSigmaPar[i]);</span>
<span class="lineNum">     895 </span>            :       }
<span class="lineNum">     896 </span>            :     }
<span class="lineNum">     897 </span>            :         
<span class="lineNum">     898 </span>            :     nVar = fNGlobalPar;  // Current number of equations 
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :     AliDebug(1,Form(&quot;Number of constraint equations : %d&quot;, fNGlobalConstraints));</span>
<span class="lineNum">     900 </span>            :     
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :     for (i=0; i&lt;fNGlobalConstraints; i++) { // Then the constraint equation    </span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :       lConstraint = fLagMult[i];</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :       for (j=0; j&lt;fNGlobalPar; j++) {        </span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :         fMatCGlo[nVar][j] = float(nLocFits)*fMatDerConstr[i][j];</span>
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :         fMatCGlo[j][nVar] = float(nLocFits)*fMatDerConstr[i][j];          </span>
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :         lConstraint -= fMatDerConstr[i][j]*(fInitPar[j]+fDeltaPar[j]);</span>
<span class="lineNum">     907 </span>            :       }
<span class="lineNum">     908 </span>            :         
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :       fMatCGlo[nVar][nVar] = 0.0;</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :       fVecBGlo[nVar] = float(nLocFits)*lConstraint;</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :       nVar++;</span>
<span class="lineNum">     912 </span>            :     }
<span class="lineNum">     913 </span>            : 
<span class="lineNum">     914 </span>            : 
<span class="lineNum">     915 </span>            :     // Intended to compute the final global chisquare
<span class="lineNum">     916 </span>            : 
<span class="lineNum">     917 </span>            :     double lFinalCor = 0.0;
<span class="lineNum">     918 </span>            : 
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :     if (fIter &gt; 1) {    </span>
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :       for (i=0; i&lt;fNGlobalPar; i++) {        </span>
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :         for (j=0; j&lt;fNGlobalPar; j++) {</span>
<span class="lineNum">     922 </span>            : //        printf(&quot;%d, %d, %.6f  %.6f  %.6f\n&quot;,i,j,step[i],fMatCGlo[i][j],step[j]);
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :           lFinalCor += step[i]*fMatCGlo[i][j]*step[j]; </span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :           if (i == j &amp;&amp; fSigmaPar[i] != 0) {</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :             lFinalCor -= step[i]*step[i]/(fSigmaPar[i]*fSigmaPar[i]);</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">     927 </span>            :         }
<span class="lineNum">     928 </span>            :       }
<span class="lineNum">     929 </span>            :     }
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :     AliInfo(Form(&quot; Final coeff is %.6f&quot;,lFinalCor));          </span>
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :     AliInfo(Form(&quot; Final NDOFs = %d&quot;, fNGlobalPar));</span>
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span>            :     //  The final matrix inversion
<span class="lineNum">     935 </span>            : 
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :     Int_t nRank = AliMillepede::SpmInv(fMatCGlo, fVecBGlo, nVar);</span>
<span class="lineNum">     937 </span>            : 
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :     for (i=0; i&lt;fNGlobalPar; i++) {    </span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :       fDeltaPar[i] += fVecBGlo[i];    // Update global parameters values (for iterations)</span>
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :       AliDebug(1,Form(&quot;fDeltaPar[%d] = %.6f&quot;, i, fDeltaPar[i]));</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :       AliDebug(1,Form(&quot;fMatCGlo[%d][%d] = %.6f&quot;, i, i, fMatCGlo[i][i]));</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :       AliDebug(1,Form(&quot;err = %.6f&quot;, TMath::Sqrt(TMath::Abs(fMatCGlo[i][i]))));</span>
<span class="lineNum">     943 </span>            : 
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :       step[i] = fVecBGlo[i];</span>
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :       if (fIter == 1) error[i] = fMatCGlo[i][i]; // Unfitted error</span>
<span class="lineNum">     947 </span>            :     }
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :     AliInfo(Form(&quot;The rank defect of the symmetric %d by %d matrix is %d (bad if non 0)&quot;,</span>
<span class="lineNum">     949 </span>            :             nVar, nVar, nVar-nGloFix-nRank));
<span class="lineNum">     950 </span>            :                 
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :     AliInfo(Form(&quot;Total : %d local fits, %d rejected.&quot;, fNLocalFits, fNLocalFitsRejected));</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :     if (fIter == 0)  break;  // No iterations set     </span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :     fIter++;</span>
<span class="lineNum">     954 </span>            :         
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :     if (fIter == fMaxIter)  break;  // End of story         </span>
<span class="lineNum">     956 </span>            : 
<span class="lineNum">     957 </span>            :     // Reinitialize parameters for iteration
<span class="lineNum">     958 </span>            :     //
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :     fNLocalFits = 0;</span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :     fNLocalFitsRejected = 0;</span>
<span class="lineNum">     961 </span>            : 
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :     if (fChi2CutFactor != fChi2CutRef) {    </span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :       fChi2CutFactor = TMath::Sqrt(fChi2CutFactor);</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :       if (fChi2CutFactor &lt; 1.2*fChi2CutRef) {</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :         fChi2CutFactor = fChi2CutRef;</span>
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :         fIter = fMaxIter - 1;     // Last iteration</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     968 </span>            :     }
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :     AliInfo(&quot;&quot;);</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :     AliInfo(&quot;----------------------------------------------&quot;);</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :     AliInfo(Form(&quot;Iteration %d with cut factor %.2f&quot;, fIter, fChi2CutFactor));</span>
<span class="lineNum">     972 </span>            :     
<span class="lineNum">     973 </span>            :     // Reset global variables
<span class="lineNum">     974 </span>            :     //    
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :     for (i=0; i&lt;nVar; i++) {    </span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :       fVecBGlo[i] = 0.0;</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :       for (j=0; j&lt;nVar; j++) {     </span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :         fMatCGlo[i][j] = 0.0;</span>
<span class="lineNum">     979 </span>            :       }
<span class="lineNum">     980 </span>            :     }
<span class="lineNum">     981 </span>            : 
<span class="lineNum">     982 </span>            :     //
<span class="lineNum">     983 </span>            :     // We start a new iteration
<span class="lineNum">     984 </span>            :     //
<span class="lineNum">     985 </span>            : 
<span class="lineNum">     986 </span>            :     // First we read the stores for retrieving the local params
<span class="lineNum">     987 </span>            :     //
<span class="lineNum">     988 </span>            :     nLocFitsGood = 0;
<span class="lineNum">     989 </span>            : 
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :     for (i=0; i&lt;nLocFitsTot; i++) {</span>
<span class="lineNum">     991 </span>            :       int iEqFirst = 0;
<span class="lineNum">     992 </span>            :       int iEqLast = 0;
<span class="lineNum">     993 </span>            : 
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :       (i&gt;0) ? iEqFirst = fLocEqPlace[i-1] : iEqFirst = 0;</span>
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :       iEqLast = fLocEqPlace[i];</span>
<span class="lineNum">     996 </span>            : 
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :       AliDebug(2,Form(&quot;Track %d : &quot;,i));</span>
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :       AliDebug(2,Form(&quot;Starts at %d&quot;, iEqFirst));</span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :       AliDebug(2,Form(&quot;Ends at %d&quot;,iEqLast));</span>
<span class="lineNum">    1000 </span>            : 
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :       if (fIndexAllEqs[iEqFirst] != -999) { // Fit is still OK      </span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :         fIndexLocEq.Reset();  fNIndexLocEq=0;</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :         fDerivLocEq.Reset();  fNDerivLocEq=0;</span>
<span class="lineNum">    1004 </span>            :         
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :         for (j=iEqFirst; j&lt;iEqLast; j++) {</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :           if (fNIndexLocEq==fIndexLocEq.GetSize()) fIndexLocEq.Set(2*fNIndexLocEq);</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :           fIndexLocEq.AddAt(fIndexAllEqs[j],fNIndexLocEq++);    </span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :           if (fNDerivLocEq==fDerivLocEq.GetSize()) fDerivLocEq.Set(2*fNDerivLocEq);</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :           fDerivLocEq.AddAt(fDerivAllEqs[j],fNDerivLocEq++);    </span>
<span class="lineNum">    1010 </span>            :         }
<span class="lineNum">    1011 </span>            : 
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :         for (j=0; j&lt;2*fNLocalPar; j++) {</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :           localPars[j] = 0.;</span>
<span class="lineNum">    1014 </span>            :         }       
<span class="lineNum">    1015 </span>            : 
<span class="lineNum">    1016 </span>            : //      Int_t sc = AliMillepede::LocalFit(i,localPars,0);
<span class="lineNum">    1017 </span>            : //      (sc) ? nLocFitsGood++ : fIndexAllEqs[iEqFirst] = -999;   
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :         AliMillepede::LocalFit(i,localPars,0);</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :         nLocFitsGood++;</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1021 </span>            :     } // End of loop on fits
<span class="lineNum">    1022 </span>            : 
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :     AliMillepede::SetNLocalEquations(nLocFitsGood);</span>
<span class="lineNum">    1024 </span>            : 
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :   } // End of iteration loop</span>
<span class="lineNum">    1026 </span>            :         
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :   AliMillepede::PrintGlobalParameters(); // Print the final results</span>
<span class="lineNum">    1028 </span>            : 
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :   for (j=0; j&lt;fNGlobalPar; j++) {  </span>
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :     par[j]   = fInitPar[j]+fDeltaPar[j];</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :     pull[j]  = (fSigmaPar[j] &lt;= 0. || fSigmaPar[j]*fSigmaPar[j]-fMatCGlo[j][j] &lt;=0.) ? 0. : fDeltaPar[j]/TMath::Sqrt(fSigmaPar[j]*fSigmaPar[j]-fMatCGlo[j][j]);</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :     error[j] = TMath::Sqrt(TMath::Abs(fMatCGlo[j][j]));</span>
<span class="lineNum">    1033 </span>            :   }
<span class="lineNum">    1034 </span>            : 
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :   AliInfo(&quot; &quot;);</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :   AliInfo(&quot;            * o o                   o      &quot;);</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :   AliInfo(&quot;              o o                   o      &quot;);</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :   AliInfo(&quot;   o ooooo  o o o  oo  ooo   oo   ooo  oo  &quot;);</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :   AliInfo(&quot;    o  o  o o o o o  o o  o o  o o  o o  o &quot;);</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :   AliInfo(&quot;    o  o  o o o o oooo o  o oooo o  o oooo &quot;);</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :   AliInfo(&quot;    o  o  o o o o o    ooo  o    o  o o    &quot;);</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :   AliInfo(&quot;    o  o  o o o o  oo  o     oo   ooo  oo ++ ends.&quot;);</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :   AliInfo(&quot;                       o                   &quot;);       </span>
<span class="lineNum">    1044 </span>            : 
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :   return 1;</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1047 </span>            : 
<span class="lineNum">    1048 </span>            : /*
<span class="lineNum">    1049 </span>            : -----------------------------------------------------------
<span class="lineNum">    1050 </span>            :   ERRPAR: return error for parameter iPar
<span class="lineNum">    1051 </span>            : -----------------------------------------------------------
<span class="lineNum">    1052 </span>            : 
<span class="lineNum">    1053 </span>            :   iPar     = the index of the global parameter in the 
<span class="lineNum">    1054 </span>            :              result array (equivalent to fDeltaPar[]).
<span class="lineNum">    1055 </span>            :  
<a name="1056"><span class="lineNum">    1056 </span>            : -----------------------------------------------------------</a>
<span class="lineNum">    1057 </span>            : */ 
<span class="lineNum">    1058 </span>            : Double_t AliMillepede::GetParError(int iPar) const
<span class="lineNum">    1059 </span>            : {
<span class="lineNum">    1060 </span>            :   /// return error for parameter iPar
<span class="lineNum">    1061 </span>            :   Double_t lErr = -1.;
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :   if (iPar&gt;=0 &amp;&amp; iPar&lt;fNGlobalPar) {</span>
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :     lErr = TMath::Sqrt(TMath::Abs(fMatCGlo[iPar][iPar]));</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :   return lErr;</span>
<span class="lineNum">    1066 </span>            : }
<span class="lineNum">    1067 </span>            : 
<span class="lineNum">    1068 </span>            : 
<span class="lineNum">    1069 </span>            : /*
<span class="lineNum">    1070 </span>            : -----------------------------------------------------------
<span class="lineNum">    1071 </span>            :   SPMINV:  obtain solution of a system of linear equations with symmetric matrix 
<span class="lineNum">    1072 </span>            :            and the inverse (using 'singular-value friendly' GAUSS pivot)
<span class="lineNum">    1073 </span>            : -----------------------------------------------------------
<span class="lineNum">    1074 </span>            : 
<span class="lineNum">    1075 </span>            :         Solve the equation :  V * X = B
<span class="lineNum">    1076 </span>            :         
<span class="lineNum">    1077 </span>            :         V is replaced by inverse matrix and B by X, the solution vector
<a name="1078"><span class="lineNum">    1078 </span>            : -----------------------------------------------------------</a>
<span class="lineNum">    1079 </span>            : */
<span class="lineNum">    1080 </span>            : int AliMillepede::SpmInv(double matV[][fgkMaxGloPC], double vecB[], int nGlo)
<span class="lineNum">    1081 </span>            : {
<span class="lineNum">    1082 </span>            :   ///  Obtain solution of a system of linear equations with symmetric matrix 
<span class="lineNum">    1083 </span>            :   ///  and the inverse (using 'singular-value friendly' GAUSS pivot)
<span class="lineNum">    1084 </span>            :     
<span class="lineNum">    1085 </span>            :   Int_t nRank = 0;
<span class="lineNum">    1086 </span>            :   int iPivot;
<span class="lineNum">    1087 </span>            :   double vPivot = 0.;
<span class="lineNum">    1088 </span>            :   double eps = 0.00000000000001;
<span class="lineNum">    1089 </span>            : 
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :   bool *bUnUsed = new bool[nGlo];</span>
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :   double *diagV = new double[nGlo];</span>
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :   double *rowMax = new double[nGlo];</span>
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :   double *colMax = new double[nGlo];</span>
<span class="lineNum">    1094 </span>            : 
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :   double *temp = new double[nGlo];</span>
<span class="lineNum">    1096 </span>            : 
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;nGlo; i++) {</span>
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :     rowMax[i] = 0.0;</span>
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :     colMax[i] = 0.0;</span>
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :     bUnUsed[i] = true;</span>
<span class="lineNum">    1101 </span>            : 
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :     for (Int_t j=0; j&lt;i; j++) {</span>
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :       if (matV[j][i] == 0) {</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :         matV[j][i] = matV[i][j];</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1106 </span>            :     }
<span class="lineNum">    1107 </span>            :   }
<span class="lineNum">    1108 </span>            :   
<span class="lineNum">    1109 </span>            :   // Small loop for matrix equilibration (gives a better conditioning) 
<span class="lineNum">    1110 </span>            : 
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;nGlo; i++) {</span>
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :     for (Int_t j=0; j&lt;nGlo; j++) { </span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :       if (TMath::Abs(matV[i][j]) &gt;= rowMax[i]) rowMax[i] = TMath::Abs(matV[i][j]); // Max elemt of row i</span>
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :       if (TMath::Abs(matV[j][i]) &gt;= colMax[i]) colMax[i] = TMath::Abs(matV[j][i]); // Max elemt of column i</span>
<span class="lineNum">    1115 </span>            :     }
<span class="lineNum">    1116 </span>            :   }
<span class="lineNum">    1117 </span>            : 
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;nGlo; i++) {</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :     if (0.0 != rowMax[i]) rowMax[i] = 1./rowMax[i]; // Max elemt of row i</span>
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :     if (0.0 != colMax[i]) colMax[i] = 1./colMax[i]; // Max elemt of column i</span>
<span class="lineNum">    1121 </span>            :   }
<span class="lineNum">    1122 </span>            : 
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;nGlo; i++) {</span>
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :     for (Int_t j=0; j&lt;nGlo; j++) {</span>
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :       matV[i][j] = TMath::Sqrt(rowMax[i])*matV[i][j]*TMath::Sqrt(colMax[j]); // Equilibrate the V matrix</span>
<span class="lineNum">    1126 </span>            :     }
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :     diagV[i] = TMath::Abs(matV[i][i]); // save diagonal elem absolute values    </span>
<span class="lineNum">    1128 </span>            :   }
<span class="lineNum">    1129 </span>            : 
<span class="lineNum">    1130 </span>            : 
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;nGlo; i++) {</span>
<span class="lineNum">    1132 </span>            :     vPivot = 0.0;
<span class="lineNum">    1133 </span>            :     iPivot = -1;
<span class="lineNum">    1134 </span>            :     
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :     for (Int_t j=0; j&lt;nGlo; j++) { // First look for the pivot, ie max unused diagonal element       </span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :       if (bUnUsed[j] &amp;&amp; (TMath::Abs(matV[j][j])&gt;TMath::Max(TMath::Abs(vPivot),eps*diagV[j]))) {    </span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :         vPivot = matV[j][j];</span>
<span class="lineNum">    1138 </span>            :         iPivot = j;
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1140 </span>            :     }
<span class="lineNum">    1141 </span>            :     
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :     if (iPivot &gt;= 0) {   // pivot found          </span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :       nRank++;</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :       bUnUsed[iPivot] = false; // This value is used</span>
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :       vPivot = 1.0/vPivot;</span>
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :       matV[iPivot][iPivot] = -vPivot; // Replace pivot by its inverse</span>
<span class="lineNum">    1147 </span>            :       
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :       for (Int_t j=0; j&lt;nGlo; j++) {      </span>
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :         for (Int_t jj=0; jj&lt;nGlo; jj++) {  </span>
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :           if (j != iPivot &amp;&amp; jj != iPivot) {// Other elements (!!! do them first as you use old matV[k][j]'s !!!)         </span>
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :             matV[j][jj] = matV[j][jj] - vPivot*matV[j][iPivot]*matV[iPivot][jj];</span>
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    1153 </span>            :         }
<span class="lineNum">    1154 </span>            :       }
<span class="lineNum">    1155 </span>            :       
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :       for (Int_t j=0; j&lt;nGlo; j++) {      </span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :         if (j != iPivot) { // Pivot row or column elements </span>
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :           matV[j][iPivot] = matV[j][iPivot]*vPivot;     // Column</span>
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :           matV[iPivot][j] = matV[iPivot][j]*vPivot;     // Line</span>
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1161 </span>            :       }
<span class="lineNum">    1162 </span>            :     }
<span class="lineNum">    1163 </span>            :     else {  // No more pivot value (clear those elements)
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :       for (Int_t j=0; j&lt;nGlo; j++) {</span>
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :         if (bUnUsed[j]) {</span>
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :           vecB[j] = 0.0;</span>
<span class="lineNum">    1167 </span>            : 
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :           for (Int_t k=0; k&lt;nGlo; k++) {</span>
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :             matV[j][k] = 0.0;</span>
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :             matV[k][j] = 0.0;</span>
<span class="lineNum">    1171 </span>            :           }
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1173 </span>            :       }
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :       break;  // No more pivots anyway, stop here</span>
<span class="lineNum">    1175 </span>            :     }
<span class="lineNum">    1176 </span>            :   }
<span class="lineNum">    1177 </span>            :   
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;nGlo; i++) {</span>
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :     for (Int_t j=0; j&lt;nGlo; j++) {</span>
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :       matV[i][j] = TMath::Sqrt(colMax[i])*matV[i][j]*TMath::Sqrt(rowMax[j]); // Correct matrix V</span>
<span class="lineNum">    1181 </span>            :     }
<span class="lineNum">    1182 </span>            :   }
<span class="lineNum">    1183 </span>            :   
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :   for (Int_t j=0; j&lt;nGlo; j++) {</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :     temp[j] = 0.0;</span>
<span class="lineNum">    1186 </span>            :     
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :     for (Int_t jj=0; jj&lt;nGlo; jj++) { // Reverse matrix elements</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :       matV[j][jj] = -matV[j][jj];</span>
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :       temp[j] += matV[j][jj]*vecB[jj];</span>
<span class="lineNum">    1190 </span>            :     }           
<span class="lineNum">    1191 </span>            :   }
<span class="lineNum">    1192 </span>            : 
<span class="lineNum">    1193 </span><span class="lineNoCov">          0 :   for (Int_t j=0; j&lt;nGlo; j++) {</span>
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :     vecB[j] = temp[j]; // The final result</span>
<span class="lineNum">    1195 </span>            :   }
<span class="lineNum">    1196 </span>            :   
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :   delete [] temp;</span>
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :   delete [] bUnUsed;</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :   delete [] diagV;</span>
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :   delete [] rowMax;</span>
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :   delete [] colMax;</span>
<span class="lineNum">    1202 </span>            : 
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :   return nRank;</span>
<span class="lineNum">    1204 </span>            : }
<span class="lineNum">    1205 </span>            : 
<span class="lineNum">    1206 </span>            : //
<a name="1207"><span class="lineNum">    1207 </span>            : // Same method but for local fit, so heavily simplified</a>
<span class="lineNum">    1208 </span>            : //
<span class="lineNum">    1209 </span>            : int AliMillepede::SpmInv(double matV[][fgkMaxLocalPar], double vecB[], int nLoc)
<span class="lineNum">    1210 </span>            : {
<span class="lineNum">    1211 </span>            :   ///  Obtain solution of a system of linear equations with symmetric matrix 
<span class="lineNum">    1212 </span>            :   ///  and the inverse (using 'singular-value friendly' GAUSS pivot)
<span class="lineNum">    1213 </span>            : 
<span class="lineNum">    1214 </span>            :   Int_t nRank = 0;
<span class="lineNum">    1215 </span>            :   Int_t iPivot = -1;
<span class="lineNum">    1216 </span>            :   double vPivot = 0.;
<span class="lineNum">    1217 </span>            :   double eps = 0.0000000000001;
<span class="lineNum">    1218 </span>            : 
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :   bool *bUnUsed = new bool[nLoc];</span>
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 :   double *diagV  = new double[nLoc];</span>
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :   double *temp  = new double[nLoc];</span>
<span class="lineNum">    1222 </span>            :   
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;nLoc; i++) {</span>
<span class="lineNum">    1224 </span><span class="lineNoCov">          0 :     bUnUsed[i] = true;</span>
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :     diagV[i] = TMath::Abs(matV[i][i]);     // save diagonal elem absolute values</span>
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :     for (Int_t j=0; j&lt;i; j++) {</span>
<span class="lineNum">    1227 </span><span class="lineNoCov">          0 :       matV[j][i] = matV[i][j] ;</span>
<span class="lineNum">    1228 </span>            :     }
<span class="lineNum">    1229 </span>            :   }
<span class="lineNum">    1230 </span>            :         
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;nLoc; i++) {</span>
<span class="lineNum">    1232 </span>            :     vPivot = 0.0;
<span class="lineNum">    1233 </span>            :     iPivot = -1;
<span class="lineNum">    1234 </span>            :                 
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :     for (Int_t j=0; j&lt;nLoc; j++) { // First look for the pivot, ie max unused diagonal element </span>
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 :       if (bUnUsed[j] &amp;&amp; (TMath::Abs(matV[j][j])&gt;TMath::Max(TMath::Abs(vPivot),eps*diagV[j]))) {</span>
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :         vPivot = matV[j][j];</span>
<span class="lineNum">    1238 </span>            :         iPivot = j;
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1240 </span>            :     }
<span class="lineNum">    1241 </span>            :                 
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :     if (iPivot &gt;= 0) {   // pivot found</span>
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :       nRank++;</span>
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 :       bUnUsed[iPivot] = false;</span>
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :       vPivot = 1.0/vPivot;</span>
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 :       matV[iPivot][iPivot] = -vPivot; // Replace pivot by its inverse</span>
<span class="lineNum">    1247 </span>            :       
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :       for (Int_t j=0; j&lt;nLoc; j++) {</span>
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :         if (j != iPivot) {</span>
<span class="lineNum">    1250 </span><span class="lineNoCov">          0 :           for (Int_t jj=0; jj&lt;=j; jj++) {    </span>
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :             if (jj != iPivot) {// Other elements (!!! do them first as you use old matV[k][j]'s !!!)</span>
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 :               matV[j][jj] = matV[j][jj] - vPivot*matV[j][iPivot]*matV[iPivot][jj];</span>
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :               matV[jj][j] = matV[j][jj];</span>
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    1255 </span>            :           }
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1257 </span>            :       }
<span class="lineNum">    1258 </span>            : 
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :       for (Int_t j=0; j&lt;nLoc; j++) {      </span>
<span class="lineNum">    1260 </span><span class="lineNoCov">          0 :         if (j != iPivot) {      // Pivot row or column elements         </span>
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :           matV[j][iPivot] = matV[j][iPivot]*vPivot; // Column</span>
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :           matV[iPivot][j] = matV[j][iPivot];</span>
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1264 </span>            :       }
<span class="lineNum">    1265 </span>            :     }
<span class="lineNum">    1266 </span>            :     else { // No more pivot value (clear those elements)
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :       for (Int_t j=0; j&lt;nLoc; j++) {</span>
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :         if (bUnUsed[j]) {</span>
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :           vecB[j] = 0.0;</span>
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :           matV[j][j] = 0.0;</span>
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :           for (Int_t k=0; k&lt;j; k++) {          </span>
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :             matV[j][k] = 0.0;</span>
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :             matV[k][j] = 0.0;</span>
<span class="lineNum">    1274 </span>            :           }
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1276 </span>            :       }
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :       break;  // No more pivots anyway, stop here</span>
<span class="lineNum">    1279 </span>            :     }
<span class="lineNum">    1280 </span>            :   }
<span class="lineNum">    1281 </span>            : 
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :   for (Int_t j=0; j&lt;nLoc; j++) {  </span>
<span class="lineNum">    1283 </span><span class="lineNoCov">          0 :     temp[j] = 0.0;    </span>
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :     for (Int_t jj=0; jj&lt;nLoc; jj++) { // Reverse matrix elements</span>
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :       matV[j][jj] = -matV[j][jj];</span>
<span class="lineNum">    1286 </span><span class="lineNoCov">          0 :       temp[j] += matV[j][jj]*vecB[jj];</span>
<span class="lineNum">    1287 </span>            :     }                   
<span class="lineNum">    1288 </span>            :   }
<span class="lineNum">    1289 </span>            : 
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :   for (Int_t j=0; j&lt;nLoc; j++) {</span>
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :     vecB[j] = temp[j];</span>
<span class="lineNum">    1292 </span>            :   }
<span class="lineNum">    1293 </span>            : 
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 :   delete [] bUnUsed;</span>
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 :   delete [] diagV;</span>
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :   delete [] temp;</span>
<span class="lineNum">    1297 </span>            :   
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :   return nRank;</span>
<span class="lineNum">    1299 </span>            : }
<span class="lineNum">    1300 </span>            : 
<span class="lineNum">    1301 </span>            : 
<span class="lineNum">    1302 </span>            : /*
<span class="lineNum">    1303 </span>            : -----------------------------------------------------------
<span class="lineNum">    1304 </span>            :   SPAVAT
<span class="lineNum">    1305 </span>            : -----------------------------------------------------------
<span class="lineNum">    1306 </span>            : 
<span class="lineNum">    1307 </span>            :   multiply symmetric N-by-N matrix from the left with general M-by-N
<span class="lineNum">    1308 </span>            :   matrix and from the right with the transposed of the same  general
<span class="lineNum">    1309 </span>            :   matrix  to  form  symmetric  M-by-M   matrix.
<span class="lineNum">    1310 </span>            :   
<span class="lineNum">    1311 </span>            :                                                        T
<span class="lineNum">    1312 </span>            :   CALL SPAVAT(V,A,W,N,M)      W   =   A   *   V   *   A
<span class="lineNum">    1313 </span>            :                            M*M     M*N     N*N     N*M
<span class="lineNum">    1314 </span>            :   
<span class="lineNum">    1315 </span>            :   where V = symmetric N-by-N matrix
<span class="lineNum">    1316 </span>            :         A = general N-by-M matrix
<span class="lineNum">    1317 </span>            :         W = symmetric M-by-M matrix
<a name="1318"><span class="lineNum">    1318 </span>            : -----------------------------------------------------------</a>
<span class="lineNum">    1319 </span>            : */
<span class="lineNum">    1320 </span>            : Int_t AliMillepede::SpAVAt(double matV[][fgkMaxLocalPar], double matA[][fgkMaxLocalPar], double matW[][fgkMaxGlobalPar], int nLoc, int nGlo)
<span class="lineNum">    1321 </span>            : {
<span class="lineNum">    1322 </span>            :   ///  multiply symmetric N-by-N matrix from the left with general M-by-N
<span class="lineNum">    1323 </span>            :   ///  matrix and from the right with the transposed of the same general
<span class="lineNum">    1324 </span>            :   ///  matrix to form symmetric M-by-M matrix.
<span class="lineNum">    1325 </span>            : 
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;nGlo; i++) {</span>
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :     for (Int_t j=0; j&lt;=i; j++) {  // Matrix w is symmetric</span>
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :       matW[i][j] = 0.0;      // Reset final matrix                      </span>
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :       for (Int_t k=0; k&lt;nLoc; k++) { </span>
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :         matW[i][j] += matA[i][k]*matV[k][k]*matA[j][k];    // diagonal terms of v</span>
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :         for (Int_t l=0; l&lt;k; l++) {    </span>
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :           matW[i][j] += matA[i][k]*matV[k][l]*matA[j][l];  // Use symmetric properties</span>
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 :           matW[i][j] += matA[i][l]*matV[k][l]*matA[j][k];  // of matrix v</span>
<span class="lineNum">    1334 </span>            :         }
<span class="lineNum">    1335 </span>            :       }
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :       if (i!=j){</span>
<span class="lineNum">    1337 </span><span class="lineNoCov">          0 :         matW[j][i] = matW[i][j]; // Matrix w is symmetric</span>
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1339 </span>            :     }
<span class="lineNum">    1340 </span>            :   }
<span class="lineNum">    1341 </span>            :         
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :   return 1;</span>
<span class="lineNum">    1343 </span>            : }
<span class="lineNum">    1344 </span>            : 
<span class="lineNum">    1345 </span>            : 
<span class="lineNum">    1346 </span>            : /*
<span class="lineNum">    1347 </span>            : -----------------------------------------------------------
<span class="lineNum">    1348 </span>            :   SPAX
<span class="lineNum">    1349 </span>            : -----------------------------------------------------------
<span class="lineNum">    1350 </span>            : 
<span class="lineNum">    1351 </span>            :   multiply general M-by-N matrix A and N-vector X
<span class="lineNum">    1352 </span>            :  
<span class="lineNum">    1353 </span>            :   CALL  SPAX(A,X,Y,M,N)          Y =  A * X
<span class="lineNum">    1354 </span>            :                                  M   M*N  N
<span class="lineNum">    1355 </span>            :  
<span class="lineNum">    1356 </span>            :   where A = general M-by-N matrix (A11 A12 ... A1N  A21 A22 ...)
<span class="lineNum">    1357 </span>            :         X = N vector
<span class="lineNum">    1358 </span>            :         Y = M vector
<a name="1359"><span class="lineNum">    1359 </span>            : -----------------------------------------------------------</a>
<span class="lineNum">    1360 </span>            : */
<span class="lineNum">    1361 </span>            : Int_t AliMillepede::SpAX(double matA[][fgkMaxLocalPar], double vecX[], double vecY[], int nCol, int nRow)
<span class="lineNum">    1362 </span>            : {
<span class="lineNum">    1363 </span>            :   ///   multiply general M-by-N matrix A and N-vector X
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :   for (Int_t i=0; i&lt;nRow; i++) {</span>
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :     vecY[i] = 0.0;          // Reset final vector                       </span>
<span class="lineNum">    1366 </span><span class="lineNoCov">          0 :     for (Int_t j=0; j&lt;nCol; j++) {</span>
<span class="lineNum">    1367 </span><span class="lineNoCov">          0 :       vecY[i] += matA[i][j]*vecX[j];  // fill the vector</span>
<span class="lineNum">    1368 </span>            :     }
<span class="lineNum">    1369 </span>            :   }
<span class="lineNum">    1370 </span>            :         
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :   return 1;</span>
<span class="lineNum">    1372 </span>            : }
<span class="lineNum">    1373 </span>            : 
<span class="lineNum">    1374 </span>            : 
<span class="lineNum">    1375 </span>            : /*
<span class="lineNum">    1376 </span>            : -----------------------------------------------------------
<span class="lineNum">    1377 </span>            :   PRTGLO
<span class="lineNum">    1378 </span>            : -----------------------------------------------------------
<span class="lineNum">    1379 </span>            : 
<span class="lineNum">    1380 </span>            :   Print the final results into the logfile
<span class="lineNum">    1381 </span>            : 
<a name="1382"><span class="lineNum">    1382 </span>            : -----------------------------------------------------------</a>
<span class="lineNum">    1383 </span>            : */
<span class="lineNum">    1384 </span>            : Int_t AliMillepede::PrintGlobalParameters() const
<span class="lineNum">    1385 </span>            : {
<span class="lineNum">    1386 </span>            :   ///  Print the final results into the logfile
<span class="lineNum">    1387 </span>            :   double lError = 0.;
<span class="lineNum">    1388 </span>            :   double lGlobalCor =0.;
<span class="lineNum">    1389 </span>            :         
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :   AliInfo(&quot;&quot;);</span>
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :   AliInfo(&quot;   Result of fit for global parameters&quot;);</span>
<span class="lineNum">    1392 </span><span class="lineNoCov">          0 :   AliInfo(&quot;   ===================================&quot;);</span>
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :   AliInfo(&quot;    I       initial       final       differ        lastcor        error       gcor&quot;);</span>
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 :   AliInfo(&quot;-----------------------------------------------------------------------------------&quot;);</span>
<span class="lineNum">    1395 </span>            :         
<span class="lineNum">    1396 </span><span class="lineNoCov">          0 :   for (int i=0; i&lt;fNGlobalPar; i++) {</span>
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :     lError = TMath::Sqrt(TMath::Abs(fMatCGlo[i][i]));</span>
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :     if (fMatCGlo[i][i] &lt; 0.0) lError = -lError;</span>
<span class="lineNum">    1399 </span>            :     lGlobalCor = 0.0;
<span class="lineNum">    1400 </span>            :                 
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :     if (TMath::Abs(fMatCGlo[i][i]*fDiagCGlo[i]) &gt; 0) {    </span>
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 :       lGlobalCor = TMath::Sqrt(TMath::Abs(1.0-1.0/(fMatCGlo[i][i]*fDiagCGlo[i])));</span>
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :       AliInfo(Form(&quot;%d\t %.6f\t %.6f\t %.6f\t %.6f\t %.6f\t %.6f&quot;,</span>
<span class="lineNum">    1404 </span>            :                    i,fInitPar[i],fInitPar[i]+fDeltaPar[i],fDeltaPar[i],fVecBGlo[i],lError,lGlobalCor));
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1406 </span>            :     else {    
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :       AliInfo(Form(&quot;%d\t %.6f\t %.6f\t %.6f\t %.6f\t OFF\t OFF&quot;,i,fInitPar[i],fInitPar[i]+fDeltaPar[i],fDeltaPar[i],fVecBGlo[i]));</span>
<span class="lineNum">    1408 </span>            :     }
<span class="lineNum">    1409 </span>            :   }
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :   return 1;</span>
<span class="lineNum">    1411 </span>            : }
<span class="lineNum">    1412 </span>            : 
<span class="lineNum">    1413 </span>            : 
<span class="lineNum">    1414 </span>            : /*
<span class="lineNum">    1415 </span>            : ----------------------------------------------------------------
<span class="lineNum">    1416 </span>            :   CHI2DOFLIM:  return the limit in chi^2/nd for n sigmas stdev authorized
<span class="lineNum">    1417 </span>            : ----------------------------------------------------------------
<span class="lineNum">    1418 </span>            : 
<span class="lineNum">    1419 </span>            :   Only n=1, 2, and 3 are expected in input
<a name="1420"><span class="lineNum">    1420 </span>            : ----------------------------------------------------------------</a>
<span class="lineNum">    1421 </span>            : */
<span class="lineNum">    1422 </span>            : double AliMillepede::Chi2DoFLim(int nSig, int nDoF)
<span class="lineNum">    1423 </span>            : {
<span class="lineNum">    1424 </span>            :   /// return the limit in chi^2/nd for n sigmas stdev authorized
<span class="lineNum">    1425 </span>            :   int lNSig;
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 :   double sn[3]        = {0.47523, 1.690140, 2.782170};</span>
<span class="lineNum">    1427 </span><span class="lineNoCov">          0 :   double table[3][30] = {{1.0000, 1.1479, 1.1753, 1.1798, 1.1775, 1.1730, 1.1680, 1.1630,</span>
<span class="lineNum">    1428 </span>            :                           1.1581, 1.1536, 1.1493, 1.1454, 1.1417, 1.1383, 1.1351, 1.1321,
<span class="lineNum">    1429 </span>            :                           1.1293, 1.1266, 1.1242, 1.1218, 1.1196, 1.1175, 1.1155, 1.1136,
<span class="lineNum">    1430 </span>            :                           1.1119, 1.1101, 1.1085, 1.1070, 1.1055, 1.1040},
<span class="lineNum">    1431 </span>            :                          {4.0000, 3.0900, 2.6750, 2.4290, 2.2628, 2.1415, 2.0481, 1.9736,
<span class="lineNum">    1432 </span>            :                           1.9124, 1.8610, 1.8171, 1.7791, 1.7457, 1.7161, 1.6897, 1.6658,
<span class="lineNum">    1433 </span>            :                           1.6442, 1.6246, 1.6065, 1.5899, 1.5745, 1.5603, 1.5470, 1.5346,
<span class="lineNum">    1434 </span>            :                           1.5230, 1.5120, 1.5017, 1.4920, 1.4829, 1.4742},
<span class="lineNum">    1435 </span>            :                          {9.0000, 5.9146, 4.7184, 4.0628, 3.6410, 3.3436, 3.1209, 2.9468,
<span class="lineNum">    1436 </span>            :                           2.8063, 2.6902, 2.5922, 2.5082, 2.4352, 2.3711, 2.3143, 2.2635,
<span class="lineNum">    1437 </span>            :                           2.2178, 2.1764, 2.1386, 2.1040, 2.0722, 2.0428, 2.0155, 1.9901,
<span class="lineNum">    1438 </span>            :                           1.9665, 1.9443, 1.9235, 1.9040, 1.8855, 1.8681}};
<span class="lineNum">    1439 </span>            : 
<span class="lineNum">    1440 </span><span class="lineNoCov">          0 :   if (nDoF &lt; 1) {</span>
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :     return 0.0;</span>
<span class="lineNum">    1442 </span>            :   }
<span class="lineNum">    1443 </span>            :   else {  
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :     lNSig = TMath::Max(1,TMath::Min(nSig,3));</span>
<span class="lineNum">    1445 </span>            : 
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :     if (nDoF &lt;= 30) {    </span>
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 :       return table[lNSig-1][nDoF-1];</span>
<span class="lineNum">    1448 </span>            :     }
<span class="lineNum">    1449 </span>            :     else { // approximation
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :       return ((sn[lNSig-1]+TMath::Sqrt(float(2*nDoF-3)))*</span>
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :               (sn[lNSig-1]+TMath::Sqrt(float(2*nDoF-3))))/float(2*nDoF-2);</span>
<span class="lineNum">    1452 </span>            :     }
<span class="lineNum">    1453 </span>            :   }
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
