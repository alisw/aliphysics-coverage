<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - STEER/AOD/AliAODTrack.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">STEER/AOD</a> - AliAODTrack.h<span style="font-size: 80%;"> (source / <a href="AliAODTrack.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">59</td>
            <td class="headerCovTableEntry">228</td>
            <td class="headerCovTableEntryLo">25.9 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">40</td>
            <td class="headerCovTableEntry">187</td>
            <td class="headerCovTableEntryLo">21.4 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : #ifndef AliAODTrack_H</a>
<span class="lineNum">       2 </span>            : #define AliAODTrack_H
<span class="lineNum">       3 </span>            : /* Copyright(c) 1998-2007, ALICE Experiment at CERN, All rights reserved. *
<span class="lineNum">       4 </span>            :  * See cxx source for full Copyright notice                               */
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : /* $Id$ */
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : //-------------------------------------------------------------------------
<span class="lineNum">       9 </span>            : //     AOD track implementation of AliVTrack
<span class="lineNum">      10 </span>            : //     Author: Markus Oldenburg, CERN
<span class="lineNum">      11 </span>            : //-------------------------------------------------------------------------
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : #include &lt;TRef.h&gt;
<span class="lineNum">      14 </span>            : #include &lt;TBits.h&gt;
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : #include &quot;AliVTrack.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;AliAODVertex.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;AliAODRedCov.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;AliAODPid.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;AliExternalTrackParam.h&quot;
<span class="lineNum">      21 </span>            :  
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : class AliVVertex;
<span class="lineNum">      24 </span>            : class AliDetectorPID;
<span class="lineNum">      25 </span>            : class AliTPCdEdxInfo;
<span class="lineNum">      26 </span>            : class AliAODEvent;
<span class="lineNum">      27 </span>            : class AliTOFHeader;
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : class AliAODTrack : public AliVTrack {
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            :  public:
<span class="lineNum">      32 </span>            :   
<span class="lineNum">      33 </span>            :   enum AODTrk_t {kUndef = -1, 
<span class="lineNum">      34 </span>            :                  kPrimary, 
<span class="lineNum">      35 </span>            :                  kFromDecayVtx, 
<span class="lineNum">      36 </span>            :                  kOrphan}; // Please note that this flag does not guarantee that the particle is a Physical Primary, it simply identifies the algorithm which was used to filter the track. In general, the following associations are used (check the filter macro to be sure, as this comment may be outdated): 
<span class="lineNum">      37 </span>            :                            //kPrimary: TPC only tracks, global constrained tracks, primary tracks, kink mothers; 
<span class="lineNum">      38 </span>            :                            //kFromDecayVtx: bachelor tracks from cascades, tracks from V0, kink daughters; 
<span class="lineNum">      39 </span>            :                            //kUndef:TRD matched tracks
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            :   enum AODTrkBits_t {
<span class="lineNum">      42 </span>            :     kIsDCA=BIT(14),   // set if fPosition is the DCA and not the position of the first point
<span class="lineNum">      43 </span>            :     kUsedForVtxFit=BIT(15), // set if this track was used to fit the vertex it is attached to
<span class="lineNum">      44 </span>            :     kUsedForPrimVtxFit=BIT(16), // set if this track was used to fit the primary vertex
<span class="lineNum">      45 </span>            :     kIsTPCConstrained=BIT(17), // set if this track is a SA TPC track constrained to the SPD vertex, needs to be skipped in any track loop to avoid double counting
<span class="lineNum">      46 </span>            :     kIsHybridTPCCG=BIT(18), // set if this track can be used as a hybrid track i.e. Gbobal tracks with certain slecetion plus the TPC constrained tracks that did not pass the selection
<span class="lineNum">      47 </span>            :     kIsGlobalConstrained=BIT(19), // set if this track is a global track constrained to the vertex, needs to be skipped in any track loop to avoid double counting
<span class="lineNum">      48 </span>            :     kIsHybridGCG=BIT(20)// set if this track can be used as a hybrid track i.e. tracks with certain slecetion plus the global constraint tracks that did not pass the selection
<span class="lineNum">      49 </span>            :   };
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            :   enum AODTrkFilterBits_t {
<span class="lineNum">      53 </span>            :     kTrkTPCOnly            = BIT(0), // Standard TPC only tracks
<span class="lineNum">      54 </span>            :     kTrkITSsa              = BIT(1), // ITS standalone
<span class="lineNum">      55 </span>            :     kTrkITSConstrained     = BIT(2), // Pixel OR necessary for the electrons
<span class="lineNum">      56 </span>            :     kTrkElectronsPID       = BIT(3),    // PID for the electrons
<span class="lineNum">      57 </span>            :     kTrkGlobalNoDCA        = BIT(4), // standard cuts with very loose DCA
<span class="lineNum">      58 </span>            :     kTrkGlobal             = BIT(5),  // standard cuts with tight DCA cut
<span class="lineNum">      59 </span>            :     kTrkGlobalSDD          = BIT(6), // standard cuts with tight DCA but with requiring the first SDD cluster instead of an SPD cluster tracks selected by this cut are exclusive to those selected by the previous cut
<span class="lineNum">      60 </span>            :     kTrkTPCOnlyConstrained = BIT(7) // TPC only tracks: TPConly information constrained to SPD vertex in the filter below
<span class="lineNum">      61 </span>            :   };
<span class="lineNum">      62 </span>            :   
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            :   enum AODTrkPID_t {
<span class="lineNum">      65 </span>            :     kElectron     =  0,
<span class="lineNum">      66 </span>            :     kMuon         =  1,
<span class="lineNum">      67 </span>            :     kPion         =  2,
<span class="lineNum">      68 </span>            :     kKaon         =  3,
<span class="lineNum">      69 </span>            :     kProton       =  4,
<span class="lineNum">      70 </span>            :     kDeuteron     =  5,
<span class="lineNum">      71 </span>            :     kTriton       =  6,
<span class="lineNum">      72 </span>            :     kHelium3      =  7,
<span class="lineNum">      73 </span>            :     kAlpha        =  8,
<span class="lineNum">      74 </span>            :     kUnknown      =  9,
<span class="lineNum">      75 </span>            :     kMostProbable = -1
<span class="lineNum">      76 </span>            :   };
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span>            :   AliAODTrack();
<span class="lineNum">      79 </span>            :   AliAODTrack(Short_t id,
<span class="lineNum">      80 </span>            :               Int_t label,
<span class="lineNum">      81 </span>            :               Double_t p[3],
<span class="lineNum">      82 </span>            :               Bool_t cartesian,
<span class="lineNum">      83 </span>            :               Double_t x[3],
<span class="lineNum">      84 </span>            :               Bool_t dca,
<span class="lineNum">      85 </span>            :               Double_t covMatrix[21],
<span class="lineNum">      86 </span>            :               Short_t q,
<span class="lineNum">      87 </span>            :               UChar_t itsClusMap,
<span class="lineNum">      88 </span>            :               AliAODVertex *prodVertex,
<span class="lineNum">      89 </span>            :               Bool_t usedForVtxFit,
<span class="lineNum">      90 </span>            :               Bool_t usedForPrimVtxFit,
<span class="lineNum">      91 </span>            :               AODTrk_t ttype=kUndef,
<span class="lineNum">      92 </span>            :               UInt_t selectInfo=0,
<span class="lineNum">      93 </span>            :               Float_t chi2perNDF = -999.);
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span>            :   AliAODTrack(Short_t id,
<span class="lineNum">      97 </span>            :               Int_t label,
<span class="lineNum">      98 </span>            :               Float_t p[3],
<span class="lineNum">      99 </span>            :               Bool_t cartesian,
<span class="lineNum">     100 </span>            :               Float_t x[3],
<span class="lineNum">     101 </span>            :               Bool_t dca,
<span class="lineNum">     102 </span>            :               Float_t covMatrix[21],
<span class="lineNum">     103 </span>            :               Short_t q,
<span class="lineNum">     104 </span>            :               UChar_t itsClusMap,
<span class="lineNum">     105 </span>            :               AliAODVertex *prodVertex,
<span class="lineNum">     106 </span>            :               Bool_t usedForVtxFit,
<span class="lineNum">     107 </span>            :               Bool_t usedForPrimVtxFit,
<span class="lineNum">     108 </span>            :               AODTrk_t ttype=kUndef,
<span class="lineNum">     109 </span>            :               UInt_t selectInfo=0,
<span class="lineNum">     110 </span>            :               Float_t chi2perNDF = -999.);
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span>            :   virtual ~AliAODTrack();
<span class="lineNum">     113 </span>            :   AliAODTrack(const AliAODTrack&amp; trk); 
<span class="lineNum">     114 </span>            :   AliAODTrack&amp; operator=(const AliAODTrack&amp; trk);
<a name="115"><span class="lineNum">     115 </span>            : </a>
<a name="116"><span class="lineNum">     116 </span>            :   // kinematics</a>
<a name="117"><span class="lineNum">     117 </span><span class="lineNoCov">          0 :   virtual Double_t OneOverPt() const { return (fMomentum[0] != 0.) ? 1./fMomentum[0] : -999.; }</span></a>
<span class="lineNum">     118 </span><span class="lineCov">         28 :   virtual Double_t Phi()       const { return fMomentum[1]; }</span>
<a name="119"><span class="lineNum">     119 </span><span class="lineNoCov">          0 :   virtual Double_t Theta()     const { return fMomentum[2]; }</span></a>
<a name="120"><span class="lineNum">     120 </span>            :   </a>
<a name="121"><span class="lineNum">     121 </span><span class="lineNoCov">          0 :   virtual Double_t Px() const { return fMomentum[0] * TMath::Cos(fMomentum[1]); }</span></a>
<a name="122"><span class="lineNum">     122 </span><span class="lineNoCov">          0 :   virtual Double_t Py() const { return fMomentum[0] * TMath::Sin(fMomentum[1]); }</span></a>
<a name="123"><span class="lineNum">     123 </span><span class="lineCov">        548 :   virtual Double_t Pz() const { return fMomentum[0] / TMath::Tan(fMomentum[2]); }</span></a>
<a name="124"><span class="lineNum">     124 </span><span class="lineCov">        822 :   virtual Double_t Pt() const { return fMomentum[0]; }</span></a>
<span class="lineNum">     125 </span><span class="lineCov">        274 :   virtual Double_t P()  const { return TMath::Sqrt(Pt()*Pt()+Pz()*Pz()); }</span>
<a name="126"><span class="lineNum">     126 </span><span class="lineNoCov">          0 :   virtual Bool_t   PxPyPz(Double_t p[3]) const { p[0] = Px(); p[1] = Py(); p[2] = Pz(); return kTRUE; }</span></a>
<a name="127"><span class="lineNum">     127 </span>            : </a>
<a name="128"><span class="lineNum">     128 </span><span class="lineNoCov">          0 :   virtual Double_t Xv() const { return GetProdVertex() ? GetProdVertex()-&gt;GetX() : -999.; }</span></a>
<a name="129"><span class="lineNum">     129 </span><span class="lineNoCov">          0 :   virtual Double_t Yv() const { return GetProdVertex() ? GetProdVertex()-&gt;GetY() : -999.; }</span></a>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :   virtual Double_t Zv() const { return GetProdVertex() ? GetProdVertex()-&gt;GetZ() : -999.; }</span>
<a name="131"><span class="lineNum">     131 </span><span class="lineNoCov">          0 :   virtual Bool_t   XvYvZv(Double_t x[3]) const { x[0] = Xv(); x[1] = Yv(); x[2] = Zv(); return kTRUE; }</span></a>
<span class="lineNum">     132 </span>            : 
<a name="133"><span class="lineNum">     133 </span><span class="lineNoCov">          0 :   Double_t Chi2perNDF()  const { return fChi2perNDF; }</span></a>
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            :   UShort_t GetTPCnclsS(Int_t i0=0,Int_t i1=159)  const { 
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :     UShort_t cl = fTPCSharedMap.CountBits(i0)-fTPCSharedMap.CountBits(i1);</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :     return cl;</span>
<a name="138"><span class="lineNum">     138 </span>            :   }</a>
<span class="lineNum">     139 </span>            :   
<span class="lineNum">     140 </span>            :   UShort_t GetTPCncls(Int_t i0=0,Int_t i1=159)  const { 
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :     UShort_t cl = fTPCFitMap.CountBits(i0)-fTPCFitMap.CountBits(i1);</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :     if(cl==0)cl = fTPCClusterMap.CountBits(i0)-fTPCClusterMap.CountBits(i1);// backward compatibility</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :     return cl;</span>
<a name="144"><span class="lineNum">     144 </span>            :   }</a>
<span class="lineNum">     145 </span>            :   
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :   UShort_t GetTPCNcls()  const { return GetTPCncls(); }</span>
<span class="lineNum">     147 </span>            : 
<a name="148"><span class="lineNum">     148 </span>            :   Int_t GetNcls(Int_t idet) const;</a>
<span class="lineNum">     149 </span>            : 
<a name="150"><span class="lineNum">     150 </span><span class="lineNoCov">          0 :   virtual Double_t M() const { return M(GetMostProbablePID()); }</span></a>
<span class="lineNum">     151 </span>            :   Double_t M(AODTrkPID_t pid) const;
<a name="152"><span class="lineNum">     152 </span><span class="lineNoCov">          0 :   virtual Double_t E() const { return E(GetMostProbablePID()); }</span></a>
<a name="153"><span class="lineNum">     153 </span>            :   Double_t E(AODTrkPID_t pid) const;</a>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :   Double_t E(Double_t m) const { return TMath::Sqrt(P()*P() + m*m); }</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :   virtual Double_t Y() const { return Y(GetMostProbablePID()); }</span>
<span class="lineNum">     156 </span>            :   Double_t Y(AODTrkPID_t pid) const;
<a name="157"><span class="lineNum">     157 </span>            :   Double_t Y(Double_t m) const;</a>
<span class="lineNum">     158 </span>            :   
<a name="159"><span class="lineNum">     159 </span><span class="lineCov">         28 :   virtual Double_t Eta() const { return -TMath::Log(TMath::Tan(0.5 * fMomentum[2])); }</span></a>
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span><span class="lineCov">        822 :   virtual Short_t  Charge() const {return fCharge; }</span>
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            :   virtual Bool_t   PropagateToDCA(const AliVVertex *vtx, 
<span class="lineNum">     164 </span>            :           Double_t b, Double_t maxd, Double_t dz[2], Double_t covar[3]);
<a name="165"><span class="lineNum">     165 </span>            : </a>
<span class="lineNum">     166 </span>            :   // PID
<span class="lineNum">     167 </span><span class="lineCov">        274 :   virtual const Double_t *PID() const { return fPID; }</span>
<a name="168"><span class="lineNum">     168 </span>            :   AODTrkPID_t GetMostProbablePID() const;</a>
<span class="lineNum">     169 </span>            :   void ConvertAliPIDtoAODPID();
<a name="170"><span class="lineNum">     170 </span><span class="lineCov">        240 :   void SetDetPID(AliAODPid *aodpid) {fDetPid = aodpid;}</span></a>
<a name="171"><span class="lineNum">     171 </span>            : </a>
<span class="lineNum">     172 </span><span class="lineCov">        274 :   void     SetPIDForTracking(Int_t pid) {fPIDForTracking = pid;}</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :   Int_t    GetPIDForTracking()  const   {return fPIDForTracking;}</span>
<span class="lineNum">     174 </span>            :   Double_t GetMassForTracking() const;
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            :   template &lt;typename T&gt; void GetPID(T *pid) const {
<a name="177"><span class="lineNum">     177 </span>            :     for(Int_t i=0; i&lt;10; ++i) pid[i] = fPID ? fPID[i]:0;}</a>
<span class="lineNum">     178 </span>            :  
<span class="lineNum">     179 </span>            :   template &lt;typename T&gt; void SetPID(const T *pid) {
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :     if (pid) {</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :       if (!fPID) fPID = new Double32_t[10];</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :       for(Int_t i=0; i&lt;10; ++i) fPID[i]=pid[i];</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :     else {delete[] fPID; fPID = 0;}</span>
<a name="185"><span class="lineNum">     185 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="186"><span class="lineNum">     186 </span>            :   </a>
<a name="187"><span class="lineNum">     187 </span><span class="lineNoCov">          0 :   Bool_t IsOn(Int_t mask) const {return (fFlags&amp;mask)&gt;0;}</span></a>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :   ULong_t GetStatus() const { return GetFlags(); }</span>
<a name="189"><span class="lineNum">     189 </span><span class="lineNoCov">          0 :   ULong_t GetFlags() const { return fFlags; }</span></a>
<a name="190"><span class="lineNum">     190 </span>            : </a>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :   Int_t   GetID() const { return (Int_t)fID; }</span>
<span class="lineNum">     192 </span><span class="lineCov">        260 :   Int_t   GetLabel() const { return fLabel; } </span>
<span class="lineNum">     193 </span>            :   void    GetTOFLabel(Int_t *p) const;
<a name="194"><span class="lineNum">     194 </span>            : </a>
<span class="lineNum">     195 </span>            : 
<a name="196"><span class="lineNum">     196 </span><span class="lineNoCov">          0 :   Char_t  GetType() const { return fType;}</span></a>
<a name="197"><span class="lineNum">     197 </span>            :   Bool_t  IsPrimaryCandidate() const;</a>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :   Bool_t  GetUsedForVtxFit() const { return TestBit(kUsedForVtxFit); }</span>
<a name="199"><span class="lineNum">     199 </span><span class="lineNoCov">          0 :   Bool_t  GetUsedForPrimVtxFit() const { return TestBit(kUsedForPrimVtxFit); }</span></a>
<a name="200"><span class="lineNum">     200 </span>            : </a>
<a name="201"><span class="lineNum">     201 </span><span class="lineNoCov">          0 :   Bool_t  IsHybridGlobalConstrainedGlobal() const { return TestBit(kIsHybridGCG); }</span></a>
<a name="202"><span class="lineNum">     202 </span><span class="lineNoCov">          0 :   Bool_t  IsHybridTPCConstrainedGlobal() const { return TestBit(kIsHybridTPCCG); }</span></a>
<a name="203"><span class="lineNum">     203 </span><span class="lineNoCov">          0 :   Bool_t  IsTPCOnly() const { return IsTPCConstrained(); } // obsolete bad naming</span></a>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :   Bool_t  IsTPCConstrained() const { return TestBit(kIsTPCConstrained); }</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :   Bool_t  IsGlobalConstrained() const { return TestBit(kIsGlobalConstrained); }</span>
<span class="lineNum">     206 </span>            :   //
<span class="lineNum">     207 </span>            :   Int_t   GetTOFBunchCrossing(Double_t b=0, Bool_t tpcPIDonly=kFALSE) const;
<a name="208"><span class="lineNum">     208 </span>            :   //</a>
<span class="lineNum">     209 </span>            :   using AliVTrack::GetP;
<span class="lineNum">     210 </span>            :   template &lt;typename T&gt; void GetP(T *p) const {
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :     p[0]=fMomentum[0]; p[1]=fMomentum[1]; p[2]=fMomentum[2];}</span>
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span>            : //  template &lt;typename T&gt; void GetPxPyPz(T *p) const {
<span class="lineNum">     214 </span>            : //    p[0] = Px(); p[1] = Py(); p[2] = Pz();}
<a name="215"><span class="lineNum">     215 </span>            :   Bool_t GetPxPyPz(Double_t *p) const;</a>
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span>            :   template &lt;typename T&gt; Bool_t GetPosition(T *x) const {
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :     x[0]=fPosition[0]; x[1]=fPosition[1]; x[2]=fPosition[2];</span>
<a name="219"><span class="lineNum">     219 </span><span class="lineNoCov">          0 :     return TestBit(kIsDCA);}</span></a>
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span>            :   template &lt;typename T&gt; void SetCovMatrix(const T *covMatrix) {
<span class="lineNum">     222 </span><span class="lineCov">        484 :     if(!fCovMatrix) fCovMatrix=new AliAODRedCov&lt;6&gt;();</span>
<a name="223"><span class="lineNum">     223 </span><span class="lineCov">        121 :     fCovMatrix-&gt;SetCovMatrix(covMatrix);}</span></a>
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            :   template &lt;typename T&gt; Bool_t GetCovMatrix(T *covMatrix) const {
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :     if(!fCovMatrix) return kFALSE;</span>
<a name="227"><span class="lineNum">     227 </span><span class="lineNoCov">          0 :     fCovMatrix-&gt;GetCovMatrix(covMatrix); return kTRUE;}</span></a>
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span>            :   Bool_t GetXYZ(Double_t *p) const {
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     return GetPosition(p); }  </span>
<span class="lineNum">     231 </span>            :   
<span class="lineNum">     232 </span>            :   Bool_t GetXYZAt(Double_t x, Double_t b, Double_t *r) const;
<a name="233"><span class="lineNum">     233 </span>            :   Bool_t GetXYZatR(Double_t xr,Double_t bz, Double_t *xyz=0, Double_t* alpSect=0) const;  </a>
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            :   Bool_t GetCovarianceXYZPxPyPz(Double_t cv[21]) const {
<a name="236"><span class="lineNum">     236 </span><span class="lineNoCov">          0 :     return GetCovMatrix(cv);}</span></a>
<span class="lineNum">     237 </span>            : 
<a name="238"><span class="lineNum">     238 </span><span class="lineNoCov">          0 :   void RemoveCovMatrix() {delete fCovMatrix; fCovMatrix=NULL;}</span></a>
<a name="239"><span class="lineNum">     239 </span>            : </a>
<a name="240"><span class="lineNum">     240 </span><span class="lineNoCov">          0 :   Double_t XAtDCA() const { return fPositionAtDCA[0]; } //makes sense only for constrained tracks, returns dummy values for all other tracks</span></a>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :   Double_t YAtDCA() const { return fPositionAtDCA[1]; } //makes sense only for constrained tracks, returns dummy values for all other tracks</span>
<span class="lineNum">     242 </span>            :   Double_t ZAtDCA() const {
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :     if (IsMuonTrack()) return fPosition[2];</span>
<a name="244"><span class="lineNum">     244 </span><span class="lineNoCov">          0 :     else if (TestBit(kIsDCA)) return fPosition[1];</span></a>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :     else return -999.; }                                //makes sense only for constrained tracks, returns dummy values for all other tracks</span>
<a name="246"><span class="lineNum">     246 </span><span class="lineNoCov">          0 :   Bool_t   XYZAtDCA(Double_t x[3]) const { x[0] = XAtDCA(); x[1] = YAtDCA(); x[2] = ZAtDCA(); return kTRUE; }</span></a>
<span class="lineNum">     247 </span>            :   
<span class="lineNum">     248 </span>            :   Double_t DCA() const {
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :     if (IsMuonTrack()) return TMath::Sqrt(XAtDCA()*XAtDCA() + YAtDCA()*YAtDCA());</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :     else if (TestBit(kIsDCA)) return fPosition[0];</span>
<a name="251"><span class="lineNum">     251 </span><span class="lineNoCov">          0 :     else return -999.; }</span></a>
<a name="252"><span class="lineNum">     252 </span>            :   </a>
<a name="253"><span class="lineNum">     253 </span><span class="lineNoCov">          0 :   Double_t PxAtDCA() const { return fMomentumAtDCA[0]; } //makes sense only for constrained tracks, returns dummy values for all other tracks</span></a>
<a name="254"><span class="lineNum">     254 </span><span class="lineNoCov">          0 :   Double_t PyAtDCA() const { return fMomentumAtDCA[1]; } //makes sense only for constrained tracks, returns dummy values for all other tracks</span></a>
<a name="255"><span class="lineNum">     255 </span><span class="lineNoCov">          0 :   Double_t PzAtDCA() const { return fMomentumAtDCA[2]; } //makes sense only for constrained tracks, returns dummy values for all other tracks</span></a>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :   Double_t PAtDCA() const { return TMath::Sqrt(PxAtDCA()*PxAtDCA() + PyAtDCA()*PyAtDCA() + PzAtDCA()*PzAtDCA()); }</span>
<a name="257"><span class="lineNum">     257 </span><span class="lineNoCov">          0 :   Bool_t   PxPyPzAtDCA(Double_t p[3]) const { p[0] = PxAtDCA(); p[1] = PyAtDCA(); p[2] = PzAtDCA(); return kTRUE; }</span></a>
<span class="lineNum">     258 </span>            :   
<a name="259"><span class="lineNum">     259 </span><span class="lineNoCov">          0 :   Double_t GetRAtAbsorberEnd() const { return fRAtAbsorberEnd; }</span></a>
<a name="260"><span class="lineNum">     260 </span>            :   </a>
<a name="261"><span class="lineNum">     261 </span><span class="lineNoCov">          0 :   Double_t GetITSchi2()       const       {return fITSchi2;}</span></a>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :   UChar_t  GetITSClusterMap() const       { return (UChar_t)(fITSMuonClusterMap&amp;0xff); }</span>
<a name="263"><span class="lineNum">     263 </span><span class="lineNoCov">          0 :   UChar_t  GetITSSharedClusterMap() const { return (UChar_t)((fITSMuonClusterMap&amp;0xff00)&gt;&gt;8); }</span></a>
<a name="264"><span class="lineNum">     264 </span>            :   Int_t    GetITSNcls() const; </a>
<a name="265"><span class="lineNum">     265 </span><span class="lineNoCov">          0 :   Bool_t   HasPointOnITSLayer(Int_t i) const { return TESTBIT(GetITSClusterMap(),i); }</span></a>
<a name="266"><span class="lineNum">     266 </span><span class="lineNoCov">          0 :   Bool_t   HasSharedPointOnITSLayer(Int_t i) const { return TESTBIT(GetITSSharedClusterMap(),i); }</span></a>
<span class="lineNum">     267 </span><span class="lineCov">        274 :   UInt_t   GetMUONClusterMap() const      { return (fITSMuonClusterMap&amp;0x3ff0000)&gt;&gt;16; }</span>
<a name="268"><span class="lineNum">     268 </span><span class="lineNoCov">          0 :   UInt_t   GetITSMUONClusterMap() const   { return fITSMuonClusterMap; }</span></a>
<a name="269"><span class="lineNum">     269 </span>            :   </a>
<a name="270"><span class="lineNum">     270 </span><span class="lineNoCov">          0 :   Bool_t  TestFilterBit(UInt_t filterBit) const {return (Bool_t) ((filterBit &amp; fFilterMap) != 0);}</span></a>
<a name="271"><span class="lineNum">     271 </span><span class="lineNoCov">          0 :   Bool_t  TestFilterMask(UInt_t filterMask) const {return (Bool_t) ((filterMask &amp; fFilterMap) == filterMask);}</span></a>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :   void    SetFilterMap(UInt_t i){fFilterMap = i;}</span>
<a name="273"><span class="lineNum">     273 </span><span class="lineNoCov">          0 :   UInt_t  GetFilterMap() const {return fFilterMap;}</span></a>
<a name="274"><span class="lineNum">     274 </span>            : </a>
<a name="275"><span class="lineNum">     275 </span><span class="lineNoCov">          0 :   const TBits&amp; GetTPCClusterMap() const {return fTPCClusterMap;}</span></a>
<a name="276"><span class="lineNum">     276 </span><span class="lineNoCov">          0 :   const TBits* GetTPCClusterMapPtr() const {return &amp;fTPCClusterMap;}</span></a>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :   const TBits&amp; GetTPCFitMap() const {return fTPCFitMap;}</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :   const TBits* GetTPCFitMapPtr() const {return &amp;fTPCFitMap;}</span>
<a name="279"><span class="lineNum">     279 </span>            :   Float_t GetTPCClusterInfo(Int_t nNeighbours=3, Int_t type=0, Int_t row0=0, Int_t row1=159, Int_t /*type*/=0) const;</a>
<a name="280"><span class="lineNum">     280 </span>            :   </a>
<a name="281"><span class="lineNum">     281 </span><span class="lineNoCov">          0 :   const TBits&amp; GetTPCSharedMap() const {return fTPCSharedMap;}</span></a>
<a name="282"><span class="lineNum">     282 </span><span class="lineNoCov">          0 :   const TBits* GetTPCSharedMapPtr() const {return &amp;fTPCSharedMap;}</span></a>
<a name="283"><span class="lineNum">     283 </span><span class="lineCov">        242 :   void    SetTPCClusterMap(const TBits amap) {fTPCClusterMap = amap;}</span></a>
<a name="284"><span class="lineNum">     284 </span><span class="lineCov">        242 :   void    SetTPCSharedMap(const TBits amap) {fTPCSharedMap = amap;}</span></a>
<a name="285"><span class="lineNum">     285 </span><span class="lineCov">        242 :   void    SetTPCFitMap(const TBits amap) {fTPCFitMap = amap;}</span></a>
<span class="lineNum">     286 </span><span class="lineCov">        242 :   void    SetTPCPointsF(UShort_t  findable){fTPCnclsF = findable;}</span>
<a name="287"><span class="lineNum">     287 </span><span class="lineCov">        242 :   void    SetTPCNCrossedRows(UInt_t n)     {fTPCNCrossedRows = n;}</span></a>
<a name="288"><span class="lineNum">     288 </span>            :   </a>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :   virtual const    AliExternalTrackParam * GetInnerParam() const { return NULL; }</span>
<a name="290"><span class="lineNum">     290 </span><span class="lineNoCov">          0 :   virtual const    AliExternalTrackParam * GetOuterParam() const { return NULL; }</span></a>
<a name="291"><span class="lineNum">     291 </span>            : </a>
<a name="292"><span class="lineNum">     292 </span><span class="lineNoCov">          0 :   UShort_t GetTPCNclsF() const { return fTPCnclsF;}</span></a>
<a name="293"><span class="lineNum">     293 </span><span class="lineNoCov">          0 :   UShort_t GetTPCNCrossedRows()  const { return fTPCNCrossedRows;}</span></a>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :   Float_t GetTPCCrossedRows() const {return (Float_t) GetTPCNCrossedRows();}</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :   Float_t  GetTPCFoundFraction() const { return fTPCNCrossedRows&gt;0 ? float(GetTPCNcls())/fTPCNCrossedRows : 0;}</span>
<a name="296"><span class="lineNum">     296 </span>            : </a>
<a name="297"><span class="lineNum">     297 </span>            :   // Calorimeter Cluster</a>
<a name="298"><span class="lineNum">     298 </span><span class="lineNoCov">          0 :   Int_t GetEMCALcluster() const {return fCaloIndex;}</span></a>
<span class="lineNum">     299 </span><span class="lineCov">         36 :   void SetEMCALcluster(Int_t index) {fCaloIndex=index;}</span>
<a name="300"><span class="lineNum">     300 </span><span class="lineNoCov">          0 :   Bool_t IsEMCAL() const {return fFlags&amp;kEMCALmatch;}</span></a>
<a name="301"><span class="lineNum">     301 </span>            : </a>
<a name="302"><span class="lineNum">     302 </span><span class="lineNoCov">          0 :   Double_t GetTrackPhiOnEMCal() const {return fTrackPhiOnEMCal;}</span></a>
<a name="303"><span class="lineNum">     303 </span><span class="lineNoCov">          0 :   Double_t GetTrackEtaOnEMCal() const {return fTrackEtaOnEMCal;}</span></a>
<a name="304"><span class="lineNum">     304 </span><span class="lineNoCov">          0 :   Double_t GetTrackPtOnEMCal() const {return fTrackPtOnEMCal;}</span></a>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :   Double_t GetTrackPOnEMCal() const {return TMath::Abs(fTrackEtaOnEMCal) &lt; 1 ? fTrackPtOnEMCal*TMath::CosH(fTrackEtaOnEMCal) : -999;}</span>
<a name="306"><span class="lineNum">     306 </span><span class="lineCov">        242 :   void SetTrackPhiEtaPtOnEMCal(Double_t phi,Double_t eta,Double_t pt) {fTrackPhiOnEMCal=phi;fTrackEtaOnEMCal=eta;fTrackPtOnEMCal=pt;}</span></a>
<a name="307"><span class="lineNum">     307 </span>            : </a>
<a name="308"><span class="lineNum">     308 </span><span class="lineNoCov">          0 :   Int_t GetPHOScluster() const {return fCaloIndex;}</span></a>
<span class="lineNum">     309 </span><span class="lineCov">          8 :   void SetPHOScluster(Int_t index) {fCaloIndex=index;}</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :   Bool_t IsPHOS() const {return fFlags&amp;kPHOSmatch;}</span>
<a name="311"><span class="lineNum">     311 </span>            : </a>
<span class="lineNum">     312 </span>            :   //pid signal interface
<a name="313"><span class="lineNum">     313 </span><span class="lineNoCov">          0 :   Double_t  GetITSsignal()       const { return fDetPid?fDetPid-&gt;GetITSsignal():0.;    }</span></a>
<a name="314"><span class="lineNum">     314 </span>            :   void      GetITSdEdxSamples(Double_t s[4]) const;</a>
<a name="315"><span class="lineNum">     315 </span><span class="lineNoCov">          0 :   Double_t  GetITSsignalTunedOnData() const {return fITSsignalTuned ;}</span></a>
<a name="316"><span class="lineNum">     316 </span><span class="lineNoCov">          0 :   void      SetITSsignalTunedOnData(Double_t signal) {fITSsignalTuned = signal;}</span></a>
<a name="317"><span class="lineNum">     317 </span><span class="lineNoCov">          0 :   Double_t  GetTPCsignal()       const { return fDetPid?fDetPid-&gt;GetTPCsignal():0.;    }</span></a>
<a name="318"><span class="lineNum">     318 </span><span class="lineNoCov">          0 :   Double_t  GetTPCsignalTunedOnData() const { return fTPCsignalTuned;}</span></a>
<a name="319"><span class="lineNum">     319 </span><span class="lineNoCov">          0 :   void      SetTPCsignalTunedOnData(Double_t signal) {fTPCsignalTuned = signal;}</span></a>
<a name="320"><span class="lineNum">     320 </span><span class="lineNoCov">          0 :   UShort_t  GetTPCsignalN()      const { return fDetPid?fDetPid-&gt;GetTPCsignalN():0;    }</span></a>
<a name="321"><span class="lineNum">     321 </span><span class="lineNoCov">          0 :   virtual AliTPCdEdxInfo* GetTPCdEdxInfo() const {return fDetPid?fDetPid-&gt;GetTPCdEdxInfo():0;}</span></a>
<a name="322"><span class="lineNum">     322 </span><span class="lineNoCov">          0 :   Double_t  GetTPCmomentum()     const { return fDetPid?fDetPid-&gt;GetTPCmomentum():0.;  }</span></a>
<a name="323"><span class="lineNum">     323 </span><span class="lineNoCov">          0 :   Double_t  GetTPCTgl()          const { return fDetPid?fDetPid-&gt;GetTPCTgl():0.;  }</span></a>
<a name="324"><span class="lineNum">     324 </span><span class="lineNoCov">          0 :   Double_t  GetTOFsignal()       const { return fDetPid?fDetPid-&gt;GetTOFsignal():0.;    }</span></a>
<a name="325"><span class="lineNum">     325 </span><span class="lineNoCov">          0 :   Double_t  GetIntegratedLength() const { return fTrackLength;}</span></a>
<a name="326"><span class="lineNum">     326 </span><span class="lineCov">        242 :   void      SetIntegratedLength(Double_t l) {fTrackLength = l;}</span></a>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :   Double_t  GetTOFsignalTunedOnData() const { return fTOFsignalTuned;}</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :   void      SetTOFsignalTunedOnData(Double_t signal) {fTOFsignalTuned = signal;}</span>
<span class="lineNum">     329 </span>            :   Double_t  GetHMPIDsignal()     const; 
<span class="lineNum">     330 </span>            :   Double_t  GetHMPIDoccupancy()  const;
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            :   Int_t     GetHMPIDcluIdx()     const;
<span class="lineNum">     333 </span>            :     
<span class="lineNum">     334 </span>            :   void GetHMPIDtrk(Float_t &amp;x, Float_t &amp;y, Float_t &amp;th, Float_t &amp;ph) const;  
<span class="lineNum">     335 </span>            :   void GetHMPIDmip(Float_t &amp;x,Float_t &amp;y,Int_t &amp;q,Int_t &amp;nph) const;
<span class="lineNum">     336 </span>            :   
<a name="337"><span class="lineNum">     337 </span>            :   Bool_t GetOuterHmpPxPyPz(Double_t *p) const;</a>
<span class="lineNum">     338 </span>            :   
<a name="339"><span class="lineNum">     339 </span><span class="lineNoCov">          0 :   void      GetIntegratedTimes(Double_t *times, Int_t nspec=AliPID::kSPECIES) const {if (fDetPid) fDetPid-&gt;GetIntegratedTimes(times, nspec);}</span></a>
<span class="lineNum">     340 </span>            :   Double_t  GetTRDslice(Int_t plane, Int_t slice) const;
<a name="341"><span class="lineNum">     341 </span><span class="lineNoCov">          0 :   Double_t  GetTRDsignal()                        const {return fDetPid ? fDetPid-&gt;GetTRDsignal() : 0;}</span></a>
<span class="lineNum">     342 </span>            :   Double_t  GetTRDmomentum(Int_t plane, Double_t */*sp*/=0x0) const;
<a name="343"><span class="lineNum">     343 </span><span class="lineNoCov">          0 :   Double_t  GetTRDchi2()                 const {return fDetPid ? fDetPid-&gt;GetTRDChi2() : -1;}</span></a>
<span class="lineNum">     344 </span>            :   UChar_t   GetTRDncls(Int_t layer)      const;
<a name="345"><span class="lineNum">     345 </span><span class="lineNoCov">          0 :   UChar_t   GetTRDncls()                 const {return GetTRDncls(-1);}</span></a>
<a name="346"><span class="lineNum">     346 </span>            :   UChar_t   GetTRDntrackletsPID() const;</a>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :   Int_t     GetNumberOfTRDslices() const { return fDetPid?fDetPid-&gt;GetTRDnSlices():0; }</span>
<a name="348"><span class="lineNum">     348 </span><span class="lineNoCov">          0 :   void      GetHMPIDpid(Double_t */*p*/) const { return; } // TODO: To be implemented properly with the new HMPID object</span></a>
<a name="349"><span class="lineNum">     349 </span>            : </a>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :   void SetMFTClusterPattern(ULong_t mftClusterPattern) { fMFTClusterPattern = mftClusterPattern; }   // AU</span>
<a name="351"><span class="lineNum">     351 </span><span class="lineNoCov">          0 :   ULong_t GetMFTClusterPattern() { return fMFTClusterPattern; }                                      // AU</span></a>
<a name="352"><span class="lineNum">     352 </span>            : </a>
<a name="353"><span class="lineNum">     353 </span><span class="lineNoCov">          0 :   const AliAODEvent* GetAODEvent() const {return fAODEvent;}</span></a>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :   virtual const AliVEvent* GetEvent() const {return (AliVEvent*)fAODEvent;}</span>
<span class="lineNum">     355 </span><span class="lineCov">        242 :   void SetAODEvent(const AliAODEvent* ptr){fAODEvent = ptr;}</span>
<a name="356"><span class="lineNum">     356 </span>            :   const AliTOFHeader* GetTOFHeader() const;</a>
<a name="357"><span class="lineNum">     357 </span>            : </a>
<span class="lineNum">     358 </span><span class="lineCov">        240 :   AliAODPid    *GetDetPid() const { return fDetPid; }</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :   AliAODVertex *GetProdVertex() const { return (AliAODVertex*)fProdVertex.GetObject(); }</span>
<span class="lineNum">     360 </span>            :   
<span class="lineNum">     361 </span>            :   // print
<span class="lineNum">     362 </span>            :   void  Print(const Option_t *opt = &quot;&quot;) const;
<a name="363"><span class="lineNum">     363 </span>            : </a>
<a name="364"><span class="lineNum">     364 </span>            :   // setters</a>
<a name="365"><span class="lineNum">     365 </span><span class="lineCov">        242 :   void SetFlags(ULong_t flags) { fFlags = flags; }</span></a>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :   void SetStatus(ULong_t flags) { fFlags|=flags; }</span>
<a name="367"><span class="lineNum">     367 </span><span class="lineNoCov">          0 :   void ResetStatus(ULong_t flags) { fFlags&amp;=~flags; }</span></a>
<a name="368"><span class="lineNum">     368 </span>            : </a>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :   void SetID(Short_t id) { fID = id; }</span>
<span class="lineNum">     370 </span><span class="lineCov">        122 :   void SetLabel(Int_t label) { fLabel = label; }</span>
<span class="lineNum">     371 </span>            :   void SetTOFLabel(const Int_t* p);
<span class="lineNum">     372 </span>            :   template &lt;typename T&gt; void SetPosition(const T *x, Bool_t isDCA = kFALSE);
<a name="373"><span class="lineNum">     373 </span>            :   template &lt;typename T&gt; void SetP(const T *p, const Bool_t cartesian);</a>
<a name="374"><span class="lineNum">     374 </span>            :   void SetDCA(Double_t d, Double_t z);</a>
<span class="lineNum">     375 </span><span class="lineCov">        411 :   void SetUsedForVtxFit(Bool_t used = kTRUE) { used ? SetBit(kUsedForVtxFit) : ResetBit(kUsedForVtxFit); }</span>
<a name="376"><span class="lineNum">     376 </span><span class="lineCov">        411 :   void SetUsedForPrimVtxFit(Bool_t used = kTRUE) { used ? SetBit(kUsedForPrimVtxFit) : ResetBit(kUsedForPrimVtxFit); }</span></a>
<span class="lineNum">     377 </span>            : 
<a name="378"><span class="lineNum">     378 </span><span class="lineNoCov">          0 :   void SetIsTPCOnly(Bool_t b = kTRUE) { SetIsTPCConstrained(b); }// obsolete bad naming</span></a>
<a name="379"><span class="lineNum">     379 </span>            : </a>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :   void SetIsTPCConstrained(Bool_t b = kTRUE) { b ? SetBit(kIsTPCConstrained) : ResetBit(kIsTPCConstrained); }</span>
<a name="381"><span class="lineNum">     381 </span><span class="lineNoCov">          0 :   void SetIsHybridTPCConstrainedGlobal(Bool_t hybrid = kTRUE) { hybrid ? SetBit(kIsHybridTPCCG) : ResetBit(kIsHybridTPCCG); }</span></a>
<a name="382"><span class="lineNum">     382 </span>            : </a>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :   void SetIsGlobalConstrained(Bool_t b = kTRUE) { b ? SetBit(kIsGlobalConstrained) : ResetBit(kIsGlobalConstrained); }</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :   void SetIsHybridGlobalConstrainedGlobal(Bool_t hybrid = kTRUE) { hybrid ? SetBit(kIsHybridGCG) : ResetBit(kIsHybridGCG); }</span>
<span class="lineNum">     385 </span>            : 
<a name="386"><span class="lineNum">     386 </span>            : </a>
<a name="387"><span class="lineNum">     387 </span>            : </a>
<a name="388"><span class="lineNum">     388 </span><span class="lineNoCov">          0 :   void SetOneOverPt(Double_t oneOverPt) { fMomentum[0] = 1. / oneOverPt; }</span></a>
<a name="389"><span class="lineNum">     389 </span><span class="lineNoCov">          0 :   void SetPt(Double_t pt) { fMomentum[0] = pt; };</span></a>
<a name="390"><span class="lineNum">     390 </span><span class="lineNoCov">          0 :   void SetPhi(Double_t phi) { fMomentum[1] = phi; }</span></a>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :   void SetTheta(Double_t theta) { fMomentum[2] = theta; }</span>
<a name="392"><span class="lineNum">     392 </span><span class="lineCov">          4 :   void SetP() {fMomentum[0]=fMomentum[1]=fMomentum[2]=-999.;}</span></a>
<a name="393"><span class="lineNum">     393 </span>            : </a>
<span class="lineNum">     394 </span><span class="lineCov">        278 :   void SetXYAtDCA(Double_t x, Double_t y) {fPositionAtDCA[0] = x; fPositionAtDCA[1] = y;}</span>
<a name="395"><span class="lineNum">     395 </span><span class="lineCov">        278 :   void SetPxPyPzAtDCA(Double_t pX, Double_t pY, Double_t pZ) {fMomentumAtDCA[0] = pX; fMomentumAtDCA[1] = pY; fMomentumAtDCA[2] = pZ;}</span></a>
<span class="lineNum">     396 </span>            :   
<a name="397"><span class="lineNum">     397 </span><span class="lineNoCov">          0 :   void SetRAtAbsorberEnd(Double_t r) { fRAtAbsorberEnd = r; }</span></a>
<a name="398"><span class="lineNum">     398 </span>            :   </a>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :   void SetCharge(Short_t q) { fCharge = q; }</span>
<a name="400"><span class="lineNum">     400 </span><span class="lineCov">        238 :   void SetChi2perNDF(Double_t chi2perNDF) { fChi2perNDF = chi2perNDF; }</span></a>
<a name="401"><span class="lineNum">     401 </span>            : </a>
<a name="402"><span class="lineNum">     402 </span><span class="lineCov">        242 :   void SetITSchi2(Double_t ITSchi2)                         {fITSchi2 = ITSchi2;}</span></a>
<a name="403"><span class="lineNum">     403 </span><span class="lineCov">        274 :   void SetITSClusterMap(UChar_t itsClusMap)                 { fITSMuonClusterMap = (fITSMuonClusterMap&amp;0xffffff00)|(((UInt_t)itsClusMap)&amp;0xff); }</span></a>
<a name="404"><span class="lineNum">     404 </span><span class="lineCov">        242 :   void SetITSSharedMap(UChar_t map)                         { fITSMuonClusterMap = (fITSMuonClusterMap&amp;0xffff00ff)|((((UInt_t)map)&amp;0xff)&lt;&lt;8); }</span></a>
<a name="405"><span class="lineNum">     405 </span><span class="lineNoCov">          0 :   void SetMuonClusterMap(UInt_t muonClusMap)                { fITSMuonClusterMap = (fITSMuonClusterMap&amp;0xfc00ffff)|((muonClusMap&amp;0x3ff)&lt;&lt;16); }</span></a>
<a name="406"><span class="lineNum">     406 </span><span class="lineNoCov">          0 :   void SetITSMuonClusterMap(UInt_t itsMuonClusMap)          { fITSMuonClusterMap = itsMuonClusMap; }</span></a>
<a name="407"><span class="lineNum">     407 </span><span class="lineNoCov">          0 :   void SetMUONtrigHitsMapTrg(UInt_t muonTrigHitsMap) { fMUONtrigHitsMapTrg = muonTrigHitsMap; }</span></a>
<a name="408"><span class="lineNum">     408 </span><span class="lineNoCov">          0 :   UInt_t GetMUONTrigHitsMapTrg() const { return fMUONtrigHitsMapTrg; }</span></a>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :   void SetMUONtrigHitsMapTrk(UInt_t muonTrigHitsMap) { fMUONtrigHitsMapTrk = muonTrigHitsMap; }</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :   UInt_t GetMUONTrigHitsMapTrk() const { return fMUONtrigHitsMapTrk; }</span>
<a name="411"><span class="lineNum">     411 </span>            :   Int_t GetMuonTrigDevSign() const;</a>
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :   Int_t GetMatchTrigger() const {return fITSMuonClusterMap&gt;&gt;30;}</span>
<span class="lineNum">     414 </span>            :                                         //  0 Muon track does not match trigger
<span class="lineNum">     415 </span>            :                                         //  1 Muon track match but does not pass pt cut
<span class="lineNum">     416 </span>            :                                         //  2 Muon track match Low pt cut
<a name="417"><span class="lineNum">     417 </span>            :                                         //  3 Muon track match High pt cut</a>
<a name="418"><span class="lineNum">     418 </span>            :   void     SetMatchTrigger(Int_t MatchTrigger);</a>
<a name="419"><span class="lineNum">     419 </span><span class="lineNoCov">          0 :   Bool_t   MatchTrigger() const { return (GetMatchTrigger()&gt;0); }      //  Muon track matches trigger track</span></a>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :   Bool_t   MatchTriggerLowPt()   const  { return (GetMatchTrigger()&gt;1); } //  Muon track matches trigger track and passes Low pt cut</span>
<a name="421"><span class="lineNum">     421 </span><span class="lineNoCov">          0 :   Bool_t   MatchTriggerHighPt()  const  { return (GetMatchTrigger()&gt;2); } //  Muon track matches trigger track and passes High pt cut</span></a>
<a name="422"><span class="lineNum">     422 </span>            :   Bool_t   MatchTriggerDigits()  const;                                   //  Muon track matches trigger digits</a>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :   Double_t GetChi2MatchTrigger() const  { return fChi2MatchTrigger;}</span>
<a name="424"><span class="lineNum">     424 </span><span class="lineNoCov">          0 :   void     SetChi2MatchTrigger(Double_t Chi2MatchTrigger) {fChi2MatchTrigger = Chi2MatchTrigger; }</span></a>
<span class="lineNum">     425 </span>            :   Bool_t   HitsMuonChamber(Int_t MuonChamber, Int_t cathode = -1) const;  // Check if track hits Muon chambers
<a name="426"><span class="lineNum">     426 </span><span class="lineCov">        427 :   Bool_t   IsMuonTrack() const { return ( (GetMUONClusterMap()&gt;0) &amp;&amp; !fIsMuonGlobalTrack ) ? kTRUE : kFALSE; }</span></a>
<a name="427"><span class="lineNum">     427 </span>            :   </a>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :   Bool_t   IsMuonGlobalTrack() const { return fIsMuonGlobalTrack; }                                     // AU</span>
<a name="429"><span class="lineNum">     429 </span><span class="lineNoCov">          0 :   void     SetIsMuonGlobalTrack(Bool_t isMuonGlobalTrack) { fIsMuonGlobalTrack = isMuonGlobalTrack; }   // AU</span></a>
<a name="430"><span class="lineNum">     430 </span>            : </a>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :   void     Connected(Bool_t flag) {flag ? SETBIT(fITSMuonClusterMap,26) : CLRBIT(fITSMuonClusterMap,26);}</span>
<a name="432"><span class="lineNum">     432 </span><span class="lineNoCov">          0 :   Bool_t   IsConnected() const {return TESTBIT(fITSMuonClusterMap,26);}</span></a>
<a name="433"><span class="lineNum">     433 </span>            : </a>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :   void     SetProdVertex(TObject *vertex) { fProdVertex = vertex; }</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :   void     SetType(AODTrk_t ttype) { fType=ttype; }</span>
<span class="lineNum">     436 </span>            : 
<a name="437"><span class="lineNum">     437 </span>            :   // Trasient PID object, is owned by the track</a>
<span class="lineNum">     438 </span>            :   virtual void  SetDetectorPID(const AliDetectorPID *pid);
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :   virtual const AliDetectorPID* GetDetectorPID() const { return fDetectorPID; }</span>
<a name="440"><span class="lineNum">     440 </span>            : </a>
<span class="lineNum">     441 </span>            :   // Dummy
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :   Int_t    PdgCode() const {return 0;}</span>
<span class="lineNum">     443 </span>            :   
<span class="lineNum">     444 </span>            :  private :
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            :   // Momentum &amp; position
<span class="lineNum">     447 </span>            :   Double32_t    fMomentum[3];       // momemtum stored in pt, phi, theta
<span class="lineNum">     448 </span>            :   Double32_t    fPosition[3];       // position of first point on track or dca
<span class="lineNum">     449 </span>            :   
<span class="lineNum">     450 </span>            :   Double32_t    fMomentumAtDCA[3];  // momentum (px,py,pz) at DCA
<span class="lineNum">     451 </span>            :   Double32_t    fPositionAtDCA[2];  // trasverse position (x,y) at DCA
<span class="lineNum">     452 </span>            :   
<span class="lineNum">     453 </span>            :   Double32_t    fRAtAbsorberEnd;    // transverse position r at the end of the muon absorber
<span class="lineNum">     454 </span>            :   
<span class="lineNum">     455 </span>            :   Double32_t    fChi2perNDF;        // chi2/NDF of momentum fit
<span class="lineNum">     456 </span>            :   Double32_t    fChi2MatchTrigger;  // chi2 of trigger/track matching
<span class="lineNum">     457 </span>            :   Double32_t*   fPID;               //! [0.,1.,8] pointer to PID object
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span>            :   Double32_t    fITSchi2;           // ITS chi2
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span>            :   ULong_t       fFlags;             // reconstruction status flags 
<span class="lineNum">     462 </span>            :   Int_t         fLabel;             // track label, points back to MC track
<span class="lineNum">     463 </span>            :   Int_t         fTOFLabel[3];       // TOF label
<span class="lineNum">     464 </span>            :   Double32_t    fTrackLength;       // Track length
<span class="lineNum">     465 </span>            :   UInt_t        fITSMuonClusterMap; // map of ITS and muon clusters, one bit per layer
<span class="lineNum">     466 </span>            :                                     // (ITS: bit 1-8, muon trigger or ITS shared: bit 9-16, muon tracker: bit 17-26, muon match trigger: bit 31-32) 
<span class="lineNum">     467 </span>            :   UInt_t        fMUONtrigHitsMapTrg; // Muon trigger hits map from trigger
<span class="lineNum">     468 </span>            :   UInt_t        fMUONtrigHitsMapTrk; // Muon trigger hits map from tracker track extrapolation
<span class="lineNum">     469 </span>            :   UInt_t        fFilterMap;         // filter information, one bit per set of cuts
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span>            :   TBits         fTPCFitMap;      // Map of clusters, one bit per padrow; if has a cluster on given padrow which is used in the fit   
<span class="lineNum">     472 </span>            :   TBits         fTPCClusterMap;     // Map of clusters, one bit per padrow; 1 if has a cluster on given padrow
<span class="lineNum">     473 </span>            :   TBits         fTPCSharedMap;      // Map of clusters, one bit per padrow; 1 if has a shared cluster on given padrow
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span>            :   UShort_t      fTPCnclsF;          // findable clusters
<span class="lineNum">     476 </span>            :   UShort_t      fTPCNCrossedRows;   // n crossed rows
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            :   Short_t       fID;                // unique track ID, points back to the ESD track
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            :   Char_t        fCharge;            // particle charge
<span class="lineNum">     481 </span>            :   Char_t        fType;              // Track Type, explanation close to the enum AODTrk_t
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span>            :   Char_t        fPIDForTracking;    // pid using for tracking of ESD track
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span>            :   Int_t         fCaloIndex;         // index of associated EMCAL/PHOS cluster (AliAODCaloCluster)
<span class="lineNum">     486 </span>            : 
<span class="lineNum">     487 </span>            :   
<span class="lineNum">     488 </span>            :   AliAODRedCov&lt;6&gt; *fCovMatrix;      // covariance matrix (x, y, z, px, py, pz)
<span class="lineNum">     489 </span>            :   AliAODPid    *fDetPid;            // more detailed or detector specific raw pid information
<span class="lineNum">     490 </span>            :   mutable const AliDetectorPID* fDetectorPID; //! transient object to cache calibrated PID information
<span class="lineNum">     491 </span>            :   TRef          fProdVertex;        // vertex of origin
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span>            :   Double32_t    fTrackPhiOnEMCal;   // phi of track after being propagated to the EMCal surface (default r = 440 cm)
<span class="lineNum">     494 </span>            :   Double32_t    fTrackEtaOnEMCal;   // eta of track after being propagated to the EMCal surface (default r = 440 cm)
<span class="lineNum">     495 </span>            :   Double32_t    fTrackPtOnEMCal;    // pt of track after being propagated to the EMCal surface (default r = 440 cm)
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span>            :   Bool_t fIsMuonGlobalTrack;        // True if the track is built from the combination of MUON and MFT clusters     // AU
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span>            :   Double32_t    fITSsignalTuned;    //! ITS signal tuned on data when using MC
<span class="lineNum">     500 </span>            :   Double32_t    fTPCsignalTuned;    //! TPC signal tuned on data when using MC
<span class="lineNum">     501 </span>            :   Double32_t    fTOFsignalTuned;    //! TOF signal tuned on data when using MC
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span>            :   ULong_t fMFTClusterPattern;       // Tells us which MFT clusters are contained in the track, and which one is a good one (if MC)  // AU
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span>            :   const AliAODEvent* fAODEvent;     //! pointer back to the event the track belongs to
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span>            :   //---------------------------------------------------------------------------
<span class="lineNum">     508 </span>            :   //--the calibration interface--
<span class="lineNum">     509 </span>            :   //--to be used in online calibration/QA
<span class="lineNum">     510 </span>            :   //--should also be implemented in ESD so it works offline as well
<span class="lineNum">     511 </span>            :   //-----------
<span class="lineNum">     512 </span>            :   virtual Int_t GetTrackParam         ( AliExternalTrackParam &amp;p ) const;
<span class="lineNum">     513 </span>            :   virtual Int_t GetTrackParamRefitted ( AliExternalTrackParam &amp;p ) const;
<span class="lineNum">     514 </span>            :   virtual Int_t GetTrackParamIp       ( AliExternalTrackParam &amp;p ) const;
<span class="lineNum">     515 </span>            :   virtual Int_t GetTrackParamTPCInner ( AliExternalTrackParam &amp;p ) const;
<span class="lineNum">     516 </span>            :   virtual Int_t GetTrackParamOp       ( AliExternalTrackParam &amp;p ) const;
<a name="517"><span class="lineNum">     517 </span>            :   virtual Int_t GetTrackParamCp       ( AliExternalTrackParam &amp;p ) const;</a>
<a name="518"><span class="lineNum">     518 </span>            :   virtual Int_t GetTrackParamITSOut   ( AliExternalTrackParam &amp;p ) const;</a>
<a name="519"><span class="lineNum">     519 </span><span class="lineNoCov">          0 :   Int_t GetNumberOfITSClusters() const { return GetITSNcls();}</span></a>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :   Int_t GetNumberOfTPCClusters() const { return GetTPCncls();}  </span>
<a name="521"><span class="lineNum">     521 </span><span class="lineNoCov">          0 :   Int_t GetNumberOfTRDClusters() const { return GetTRDncls();}  </span></a>
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span><span class="lineCov">        212 :   ClassDef(AliAODTrack, 25);</span>
<a name="524"><span class="lineNum">     524 </span>            : };</a>
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span>            : inline Bool_t  AliAODTrack::IsPrimaryCandidate() const
<span class="lineNum">     527 </span>            : {
<span class="lineNum">     528 </span>            :     // True of track passes primary particle selection (independent of type) 
<span class="lineNum">     529 </span>            :     // 
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :     if (fFilterMap) {</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :         return kTRUE;</span>
<span class="lineNum">     532 </span>            :     } else {
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :         return kFALSE;</span>
<span class="lineNum">     534 </span>            :     }
<a name="535"><span class="lineNum">     535 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span>            : inline Int_t AliAODTrack::GetITSNcls() const 
<span class="lineNum">     538 </span>            : {
<span class="lineNum">     539 </span>            :   // Number of points in ITS
<span class="lineNum">     540 </span>            :   Int_t n=0;
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :   for(Int_t i=0;i&lt;6;i++) if(HasPointOnITSLayer(i)) n++;</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :   return n;</span>
<span class="lineNum">     543 </span>            : }
<span class="lineNum">     544 </span>            : 
<a name="545"><span class="lineNum">     545 </span>            : //______________________________________________________________________________</a>
<span class="lineNum">     546 </span>            : template &lt;typename T&gt; 
<span class="lineNum">     547 </span>            : void AliAODTrack::SetPosition(const T *x, const Bool_t dca) 
<span class="lineNum">     548 </span>            : {
<span class="lineNum">     549 </span>            :   // set the position
<span class="lineNum">     550 </span>            : 
<span class="lineNum">     551 </span><span class="lineCov">        139 :   if (x) {</span>
<span class="lineNum">     552 </span><span class="lineCov">        274 :     if (!dca) {</span>
<span class="lineNum">     553 </span><span class="lineCov">        137 :       ResetBit(kIsDCA);</span>
<span class="lineNum">     554 </span>            : 
<span class="lineNum">     555 </span><span class="lineCov">        137 :       fPosition[0] = x[0];</span>
<span class="lineNum">     556 </span><span class="lineCov">        137 :       fPosition[1] = x[1];</span>
<span class="lineNum">     557 </span><span class="lineCov">        137 :       fPosition[2] = x[2];</span>
<span class="lineNum">     558 </span><span class="lineCov">        137 :     } else {</span>
<span class="lineNum">     559 </span><span class="lineCov">        137 :       SetBit(kIsDCA);</span>
<span class="lineNum">     560 </span>            :       // don't know any better yet
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :       fPosition[0] = -999.;</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :       fPosition[1] = -999.;</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :       fPosition[2] = -999.;</span>
<span class="lineNum">     564 </span>            :     }
<span class="lineNum">     565 </span>            :   } else {
<span class="lineNum">     566 </span><span class="lineCov">          2 :     ResetBit(kIsDCA);</span>
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span><span class="lineCov">          2 :     fPosition[0] = -999.;</span>
<span class="lineNum">     569 </span><span class="lineCov">          2 :     fPosition[1] = -999.;</span>
<span class="lineNum">     570 </span><span class="lineCov">          2 :     fPosition[2] = -999.;</span>
<span class="lineNum">     571 </span>            :   }
<span class="lineNum">     572 </span><span class="lineCov">        139 : }</span>
<span class="lineNum">     573 </span>            : 
<a name="574"><span class="lineNum">     574 </span>            : </a>
<span class="lineNum">     575 </span>            : //______________________________________________________________________________
<span class="lineNum">     576 </span>            : template &lt;typename T&gt; void AliAODTrack::SetP(const T *p, const Bool_t cartesian) 
<span class="lineNum">     577 </span>            : {
<span class="lineNum">     578 </span>            :   // Set the momentum
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span><span class="lineCov">        137 :   if (p) {</span>
<span class="lineNum">     581 </span><span class="lineCov">        137 :     if (cartesian) {</span>
<span class="lineNum">     582 </span><span class="lineCov">        137 :       Double_t pt2 = p[0]*p[0] + p[1]*p[1];</span>
<span class="lineNum">     583 </span><span class="lineCov">        137 :       Double_t pp  = TMath::Sqrt(pt2 + p[2]*p[2]);</span>
<span class="lineNum">     584 </span>            :       
<span class="lineNum">     585 </span><span class="lineCov">        137 :       fMomentum[0] = TMath::Sqrt(pt2); // pt</span>
<span class="lineNum">     586 </span><span class="lineCov">        411 :       fMomentum[1] = (pt2 != 0.) ? TMath::Pi()+TMath::ATan2(-p[1], -p[0]) : -999; // phi</span>
<span class="lineNum">     587 </span><span class="lineCov">        411 :       fMomentum[2] = (pp != 0.) ? TMath::ACos(p[2] / pp) : -999.; // theta</span>
<span class="lineNum">     588 </span><span class="lineCov">        137 :     } else {</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :       fMomentum[0] = p[0];  // pt</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :       fMomentum[1] = p[1];  // phi</span>
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :       fMomentum[2] = p[2];  // theta</span>
<span class="lineNum">     592 </span>            :     }
<span class="lineNum">     593 </span>            :   } else {
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :     fMomentum[0] = -999.;</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :     fMomentum[1] = -999.;</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :     fMomentum[2] = -999.;</span>
<span class="lineNum">     597 </span>            :   }
<span class="lineNum">     598 </span><span class="lineCov">        137 : }</span>
<span class="lineNum">     599 </span>            : 
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span>            : //template&lt;&gt; void AliAODTrack::SetPosition(const double *, Bool_t);
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
