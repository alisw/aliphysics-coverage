<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - /Users/ktf/work/active/sw/osx_x86-64/ROOT/v5-34-30-alice_COVERAGE-2/include/TClass.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../../../index.html">top level</a> - <a href="index.html">Users/ktf/work/active/sw/osx_x86-64/ROOT/v5-34-30-alice_COVERAGE-2/include</a> - TClass.h<span style="font-size: 80%;"> (source / <a href="TClass.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-07 11:22:50</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // @(#)root/meta:$Id$</a>
<span class="lineNum">       2 </span>            : // Author: Rene Brun   07/01/95
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : /*************************************************************************
<span class="lineNum">       5 </span>            :  * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
<span class="lineNum">       6 </span>            :  * All rights reserved.                                                  *
<span class="lineNum">       7 </span>            :  *                                                                       *
<span class="lineNum">       8 </span>            :  * For the licensing terms see $ROOTSYS/LICENSE.                         *
<span class="lineNum">       9 </span>            :  * For the list of contributors see $ROOTSYS/README/CREDITS.             *
<span class="lineNum">      10 </span>            :  *************************************************************************/
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #ifndef ROOT_TClass
<span class="lineNum">      13 </span>            : #define ROOT_TClass
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : //////////////////////////////////////////////////////////////////////////
<span class="lineNum">      17 </span>            : //                                                                      //
<span class="lineNum">      18 </span>            : // TClass                                                               //
<span class="lineNum">      19 </span>            : //                                                                      //
<span class="lineNum">      20 </span>            : // Dictionary of a class.                                               //
<span class="lineNum">      21 </span>            : //                                                                      //
<span class="lineNum">      22 </span>            : //////////////////////////////////////////////////////////////////////////
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : #ifndef ROOT_TDictionary
<span class="lineNum">      25 </span>            : #include &quot;TDictionary.h&quot;
<span class="lineNum">      26 </span>            : #endif
<span class="lineNum">      27 </span>            : #ifndef ROOT_TString
<span class="lineNum">      28 </span>            : #include &quot;TString.h&quot;
<span class="lineNum">      29 </span>            : #endif
<span class="lineNum">      30 </span>            : #ifndef ROOT_TObjArray
<span class="lineNum">      31 </span>            : #include &quot;TObjArray.h&quot;
<span class="lineNum">      32 </span>            : #endif
<span class="lineNum">      33 </span>            : #ifndef ROOT_TObjString
<span class="lineNum">      34 </span>            : #include &quot;TObjString.h&quot;
<span class="lineNum">      35 </span>            : #endif
<span class="lineNum">      36 </span>            : #include &lt;map&gt;
<span class="lineNum">      37 </span>            : #include &lt;string&gt;
<span class="lineNum">      38 </span>            : #if __cplusplus &gt;= 201103L
<span class="lineNum">      39 </span>            : #include &lt;atomic&gt;
<span class="lineNum">      40 </span>            : #endif
<span class="lineNum">      41 </span>            : #ifndef ROOT_ThreadLocalStorage
<span class="lineNum">      42 </span>            : #include &quot;ThreadLocalStorage.h&quot;
<span class="lineNum">      43 </span>            : #endif
<span class="lineNum">      44 </span>            : class TBaseClass;
<span class="lineNum">      45 </span>            : class TBrowser;
<span class="lineNum">      46 </span>            : class TDataMember;
<span class="lineNum">      47 </span>            : class TMethod;
<span class="lineNum">      48 </span>            : class TRealData;
<span class="lineNum">      49 </span>            : class TCint;
<span class="lineNum">      50 </span>            : class TBuffer;
<span class="lineNum">      51 </span>            : class TVirtualStreamerInfo;
<span class="lineNum">      52 </span>            : class TVirtualCollectionProxy;
<span class="lineNum">      53 </span>            : class TMethodCall;
<span class="lineNum">      54 </span>            : class TVirtualIsAProxy;
<span class="lineNum">      55 </span>            : class TVirtualRefProxy;
<span class="lineNum">      56 </span>            : class THashTable;
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : namespace clang {
<span class="lineNum">      59 </span>            :    class Decl;
<span class="lineNum">      60 </span>            : }
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            : namespace ROOT {
<span class="lineNum">      63 </span>            :    class TGenericClassInfo;
<span class="lineNum">      64 </span>            :    class TCollectionProxyInfo;
<span class="lineNum">      65 </span>            :    class TSchemaRuleSet;
<span class="lineNum">      66 </span>            : }
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            : namespace ROOT {
<span class="lineNum">      69 </span>            :    class TMapTypeToTClass;
<span class="lineNum">      70 </span>            : }
<span class="lineNum">      71 </span>            : typedef ROOT::TMapTypeToTClass IdMap_t;
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : class TClass : public TDictionary {
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            : friend class TCint;
<span class="lineNum">      76 </span>            : friend class TCintWithCling;
<span class="lineNum">      77 </span>            : friend void ROOT::ResetClassVersion(TClass*, const char*, Short_t);
<span class="lineNum">      78 </span>            : friend class ROOT::TGenericClassInfo;
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            : public:
<span class="lineNum">      81 </span>            :    // TClass status bits
<span class="lineNum">      82 </span>            :    enum { kClassSaved  = BIT(12), kIgnoreTObjectStreamer = BIT(15),
<span class="lineNum">      83 </span>            :           kUnloaded    = BIT(16), kIsTObject = BIT(17),
<span class="lineNum">      84 </span>            :           kIsForeign   = BIT(18), kIsEmulation = BIT(19),
<span class="lineNum">      85 </span>            :           kStartWithTObject = BIT(20),  // see comments for IsStartingWithTObject()
<span class="lineNum">      86 </span>            :           kWarned      = BIT(21),
<span class="lineNum">      87 </span>            :           kHasNameMapNode = BIT(22)
<span class="lineNum">      88 </span>            :    };
<span class="lineNum">      89 </span>            :    enum ENewType { kRealNew = 0, kClassNew, kDummyNew };
<span class="lineNum">      90 </span>            :    enum ECheckSum {
<span class="lineNum">      91 </span>            :       kCurrentCheckSum = 0,
<span class="lineNum">      92 </span>            :       kNoEnum          = 1, // Used since v3.3
<span class="lineNum">      93 </span>            :       kNoRange         = 2, // Up to v5.17
<span class="lineNum">      94 </span>            :       kWithTypeDef     = 3, // Up to v5.34.18 and v5.99/06
<span class="lineNum">      95 </span>            :       kNoBaseCheckSum  = 4, // Up to v5.34.18 and v5.99/06
<span class="lineNum">      96 </span>            :       kLatestCheckSum  = 5
<span class="lineNum">      97 </span>            :    };
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span>            : private:
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            :    // TClass objects can be created as a result of opening a TFile (in which
<span class="lineNum">     102 </span>            :    // they are in emulated mode) or as a result of loading the dictionary for
<span class="lineNum">     103 </span>            :    // the corresponding class.   When a dictionary is loaded any pre-existing
<span class="lineNum">     104 </span>            :    // emulated TClass is replaced by the one created/coming from the dictionary.
<span class="lineNum">     105 </span>            :    // To have a reference that always point to the 'current' TClass object for
<span class="lineNum">     106 </span>            :    // a given class, one should use a TClassRef.
<span class="lineNum">     107 </span>            :    // TClassRef works by holding on to the fPersistentRef which is updated
<span class="lineNum">     108 </span>            :    // atomically whenever a TClass is replaced.  During the replacement the
<span class="lineNum">     109 </span>            :    // value of fPersistentRef is set to zero, leading the TClassRef to call
<span class="lineNum">     110 </span>            :    // TClass::GetClass which is also locked by the replacement.   At the end
<span class="lineNum">     111 </span>            :    // of the replacement, fPersistentRef points to the new TClass object.
<span class="lineNum">     112 </span>            : #if __cplusplus &gt;= 201103L
<span class="lineNum">     113 </span>            :    std::atomic&lt;TClass**&gt; fPersistentRef;//!Persistent address of pointer to this TClass object and its successors.
<span class="lineNum">     114 </span>            : #else
<span class="lineNum">     115 </span>            :    TClass           **fPersistentRef;   //!Persistent address of pointer to this TClass object and its successors.
<span class="lineNum">     116 </span>            : #endif
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span>            :    mutable TObjArray *fStreamerInfo;    //Array of TVirtualStreamerInfo
<span class="lineNum">     120 </span>            : #if __cplusplus &gt;= 201103L
<span class="lineNum">     121 </span>            :    mutable std::atomic&lt;std::map&lt;std::string, TObjArray*&gt;*&gt; fConversionStreamerInfo; //Array of the streamer infos derived from another class.
<span class="lineNum">     122 </span>            : #else
<span class="lineNum">     123 </span>            :    mutable std::map&lt;std::string, TObjArray*&gt; *fConversionStreamerInfo; //Array of the streamer infos derived from another class.
<span class="lineNum">     124 </span>            : #endif
<span class="lineNum">     125 </span>            :    TList             *fRealData;        //linked list for persistent members including base classes
<span class="lineNum">     126 </span>            :    TList             *fBase;            //linked list for base classes
<span class="lineNum">     127 </span>            :    TList             *fData;            //linked list for data members
<span class="lineNum">     128 </span>            :    TList             *fMethod;          //linked list for methods
<span class="lineNum">     129 </span>            :    TList             *fAllPubData;      //all public data members (including from base classes)
<span class="lineNum">     130 </span>            :    TList             *fAllPubMethod;    //all public methods (including from base classes)
<span class="lineNum">     131 </span>            :    mutable TList     *fClassMenuList;   //list of class menu items
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            :    const char        *fDeclFileName;    //name of class declaration file
<span class="lineNum">     134 </span>            :    const char        *fImplFileName;    //name of class implementation file
<span class="lineNum">     135 </span>            :    Short_t            fDeclFileLine;    //line of class declaration
<span class="lineNum">     136 </span>            :    Short_t            fImplFileLine;    //line of class implementation
<span class="lineNum">     137 </span>            :    UInt_t             fInstanceCount;   //number of instances of this class
<span class="lineNum">     138 </span>            :    UInt_t             fOnHeap;          //number of instances on heap
<span class="lineNum">     139 </span>            :    mutable UInt_t     fCheckSum;        //checksum of data members and base classes
<span class="lineNum">     140 </span>            :    TVirtualCollectionProxy *fCollectionProxy; //Collection interface
<span class="lineNum">     141 </span>            :    Version_t          fClassVersion;    //Class version Identifier
<span class="lineNum">     142 </span>            :    ClassInfo_t       *fClassInfo;       //pointer to CINT class info class
<span class="lineNum">     143 </span>            :    TString            fContextMenuTitle;//context menu title
<span class="lineNum">     144 </span>            :    const type_info   *fTypeInfo;        //pointer to the C++ type information.
<span class="lineNum">     145 </span>            :    ShowMembersFunc_t  fShowMembers;     //pointer to the class's ShowMembers function
<span class="lineNum">     146 </span>            : #if __cplusplus &gt;= 201103L
<span class="lineNum">     147 </span>            :    mutable std::atomic&lt;void*&gt; fInterShowMembers;//Interpreter call setup for ShowMembers
<span class="lineNum">     148 </span>            : #else
<span class="lineNum">     149 </span>            :    mutable void      *fInterShowMembers;//Interpreter call setup for ShowMembers
<span class="lineNum">     150 </span>            : #endif
<span class="lineNum">     151 </span>            :    TClassStreamer    *fStreamer;        //pointer to streamer function
<span class="lineNum">     152 </span>            :    TString            fSharedLibs;      //shared libraries containing class code
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            :    TVirtualIsAProxy  *fIsA;             //!pointer to the class's IsA proxy.
<span class="lineNum">     155 </span>            :    IsAGlobalFunc_t    fGlobalIsA;       //pointer to a global IsA function.
<span class="lineNum">     156 </span>            : #if __cplusplus &gt;= 201103L
<span class="lineNum">     157 </span>            :    mutable std::atomic&lt;TMethodCall*&gt; fIsAMethod;       //!saved info to call a IsA member function
<span class="lineNum">     158 </span>            : #else
<span class="lineNum">     159 </span>            :    mutable TMethodCall *fIsAMethod;       //!saved info to call a IsA member function
<span class="lineNum">     160 </span>            : #endif
<span class="lineNum">     161 </span>            : 
<span class="lineNum">     162 </span>            :    ROOT::MergeFunc_t   fMerge;          //pointer to a function implementing Merging objects of this class.
<span class="lineNum">     163 </span>            :    ROOT::ResetAfterMergeFunc_t fResetAfterMerge; //pointer to a function implementing Merging objects of this class.
<span class="lineNum">     164 </span>            :    ROOT::NewFunc_t     fNew;            //pointer to a function newing one object.
<span class="lineNum">     165 </span>            :    ROOT::NewArrFunc_t  fNewArray;       //pointer to a function newing an array of objects.
<span class="lineNum">     166 </span>            :    ROOT::DelFunc_t     fDelete;         //pointer to a function deleting one object.
<span class="lineNum">     167 </span>            :    ROOT::DelArrFunc_t  fDeleteArray;    //pointer to a function deleting an array of objects.
<span class="lineNum">     168 </span>            :    ROOT::DesFunc_t     fDestructor;     //pointer to a function call an object's destructor.
<span class="lineNum">     169 </span>            :    ROOT::DirAutoAdd_t  fDirAutoAdd;     //pointer which implements the Directory Auto Add feature for this class.']'
<span class="lineNum">     170 </span>            :    ClassStreamerFunc_t fStreamerFunc;   //Wrapper around this class custom Streamer member function.
<span class="lineNum">     171 </span>            :    Int_t               fSizeof;         //Sizeof the class.
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span>            :    mutable Int_t      fCanSplit;        //!Indicates whether this class can be split or not.
<span class="lineNum">     174 </span>            : #if __cplusplus &gt;= 201103L
<span class="lineNum">     175 </span>            :    mutable std::atomic&lt;Long_t&gt; fProperty;        //!Property
<span class="lineNum">     176 </span>            :    mutable std::atomic&lt;Bool_t&gt; fVersionUsed;     //!Indicates whether GetClassVersion has been called
<span class="lineNum">     177 </span>            : #else
<span class="lineNum">     178 </span>            :    mutable Long_t     fProperty;        //!Property
<span class="lineNum">     179 </span>            :    mutable Bool_t     fVersionUsed;     //!Indicates whether GetClassVersion has been called
<span class="lineNum">     180 </span>            : #endif
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            :    mutable Bool_t     fIsOffsetStreamerSet; //!saved remember if fOffsetStreamer has been set.
<span class="lineNum">     183 </span>            :    mutable Long_t     fOffsetStreamer;  //!saved info to call Streamer
<span class="lineNum">     184 </span>            :    Int_t              fStreamerType;    //!cached of the streaming method to use
<span class="lineNum">     185 </span>            : #if __cplusplus &gt;= 201103L
<span class="lineNum">     186 </span>            :    mutable std::atomic&lt;TVirtualStreamerInfo*&gt;  fCurrentInfo;     //!cached current streamer info.
<span class="lineNum">     187 </span>            :    mutable std::atomic&lt;TVirtualStreamerInfo*&gt;  fLastReadInfo;    //!cached streamer info used in the last read.
<span class="lineNum">     188 </span>            : #else
<span class="lineNum">     189 </span>            :    mutable TVirtualStreamerInfo     *fCurrentInfo;     //!cached current streamer info.
<span class="lineNum">     190 </span>            :    mutable TVirtualStreamerInfo     *fLastReadInfo;    //!cached streamer info used in the last read.
<span class="lineNum">     191 </span>            : #endif
<span class="lineNum">     192 </span>            :    TVirtualRefProxy  *fRefProxy;        //!Pointer to reference proxy if this class represents a reference
<span class="lineNum">     193 </span>            :    ROOT::TSchemaRuleSet *fSchemaRules;  //! Schema evolution rules
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            :    typedef void (TClass::*StreamerImpl_t)(void *obj, TBuffer &amp;b, const TClass *onfile_class) const;
<span class="lineNum">     196 </span>            :    mutable StreamerImpl_t fStreamerImpl;//! Pointer to the function implementing the right streaming behavior for the class represented by this object.
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span>            :    TMethod           *GetClassMethod(Long_t faddr);
<span class="lineNum">     199 </span>            :    TMethod           *GetClassMethod(const char *name, const char *signature);
<span class="lineNum">     200 </span>            :    Int_t              GetBaseClassOffsetRecurse(const TClass *base);
<span class="lineNum">     201 </span>            :    void Init(const char *name, Version_t cversion, const type_info *info,
<span class="lineNum">     202 </span>            :              TVirtualIsAProxy *isa, ShowMembersFunc_t showmember,
<span class="lineNum">     203 </span>            :              const char *dfil, const char *ifil,
<span class="lineNum">     204 </span>            :              Int_t dl, Int_t il,
<span class="lineNum">     205 </span>            :              Bool_t silent);
<span class="lineNum">     206 </span>            :    void ForceReload (TClass* oldcl);
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span>            :    void               SetClassVersion(Version_t version);
<span class="lineNum">     209 </span>            :    void               SetClassSize(Int_t sizof) { fSizeof = sizof; }
<span class="lineNum">     210 </span>            :    TVirtualStreamerInfo* DetermineCurrentStreamerInfo();
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span>            :    // Various implementation for TClass::Stramer
<span class="lineNum">     213 </span>            :    void StreamerExternal(void *object, TBuffer &amp;b, const TClass *onfile_class) const;
<span class="lineNum">     214 </span>            :    void StreamerTObject(void *object, TBuffer &amp;b, const TClass *onfile_class) const;
<span class="lineNum">     215 </span>            :    void StreamerTObjectInitialized(void *object, TBuffer &amp;b, const TClass *onfile_class) const;
<span class="lineNum">     216 </span>            :    void StreamerTObjectEmulated(void *object, TBuffer &amp;b, const TClass *onfile_class) const;
<span class="lineNum">     217 </span>            :    void StreamerInstrumented(void *object, TBuffer &amp;b, const TClass *onfile_class) const;
<span class="lineNum">     218 </span>            :    void StreamerStreamerInfo(void *object, TBuffer &amp;b, const TClass *onfile_class) const;
<span class="lineNum">     219 </span>            :    void StreamerDefault(void *object, TBuffer &amp;b, const TClass *onfile_class) const;
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span>            :    static IdMap_t    *GetIdMap();       //Map from typeid to TClass pointer
<span class="lineNum">     222 </span>            : #if __cplusplus &gt;= 201103L
<span class="lineNum">     223 </span>            :    static std::atomic&lt;Int_t&gt;     fgClassCount;  //provides unique id for a each class
<span class="lineNum">     224 </span>            :                                                 //stored in TObject::fUniqueID
<span class="lineNum">     225 </span>            : #else
<span class="lineNum">     226 </span>            :    static Int_t       fgClassCount;             //provides unique id for a each class
<span class="lineNum">     227 </span>            :                                                 //stored in TObject::fUniqueID
<span class="lineNum">     228 </span>            : #endif
<span class="lineNum">     229 </span>            :    // Internal status bits
<span class="lineNum">     230 </span>            :    enum { kLoading = BIT(14) };
<span class="lineNum">     231 </span>            :    // Internal streamer type.
<span class="lineNum">     232 </span>            :    enum EStreamerType {kDefault=0, kEmulated=1, kTObject=2, kInstrumented=4, kForeign=8, kExternal=16};
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span>            :    // When a new class is created, we need to be able to find
<span class="lineNum">     235 </span>            :    // if there are any existing classes that have the same name
<span class="lineNum">     236 </span>            :    // after any typedefs are expanded.  (This only really affects
<span class="lineNum">     237 </span>            :    // template arguments.)  To avoid having to search through all classes
<span class="lineNum">     238 </span>            :    // in that case, we keep a hash table mapping from the fully
<span class="lineNum">     239 </span>            :    // typedef-expanded names to the original class names.
<span class="lineNum">     240 </span>            :    // An entry is made in the table only if they are actually different.
<span class="lineNum">     241 </span>            :    //
<span class="lineNum">     242 </span>            :    // In these objects, the TObjString base holds the typedef-expanded
<span class="lineNum">     243 </span>            :    // name (the hash key), and fOrigName holds the original class name
<span class="lineNum">     244 </span>            :    // (the value to which the key maps).
<span class="lineNum">     245 </span>            :    //
<span class="lineNum">     246 </span>            :    class TNameMapNode : public TObjString
<span class="lineNum">     247 </span>            :    {
<span class="lineNum">     248 </span>            :    public:
<span class="lineNum">     249 </span>            :       TNameMapNode (const char* typedf, const char* orig);
<span class="lineNum">     250 </span>            :       TString fOrigName;
<span class="lineNum">     251 </span>            :    };
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span>            :    // These are the above-referenced hash tables.  (The pointers are null
<span class="lineNum">     254 </span>            :    // if no entries have been made.)  There are actually two variants.
<span class="lineNum">     255 </span>            :    // In the first, the typedef names are resolved with
<span class="lineNum">     256 </span>            :    // TClassEdit::ResolveTypedef; in the second, the class names
<span class="lineNum">     257 </span>            :    // are first massaged with TClassEdit::ShortType with kDropStlDefault.
<span class="lineNum">     258 </span>            :    // (??? Are the two distinct tables really needed?)
<span class="lineNum">     259 </span>            :    static THashTable* fgClassTypedefHash;
<span class="lineNum">     260 </span>            :    static THashTable* fgClassShortTypedefHash;
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            : private:
<span class="lineNum">     263 </span>            :    TClass(const TClass&amp; tc);
<span class="lineNum">     264 </span>            :    TClass&amp; operator=(const TClass&amp;);
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            : protected:
<span class="lineNum">     267 </span>            :    TVirtualStreamerInfo     *FindStreamerInfo(TObjArray* arr, UInt_t checksum) const;
<span class="lineNum">     268 </span>            :    static THashTable        *GetClassShortTypedefHash();
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            : public:
<span class="lineNum">     271 </span>            :    TClass();
<span class="lineNum">     272 </span>            :    TClass(const char *name, Bool_t silent = kFALSE);
<span class="lineNum">     273 </span>            :    TClass(const char *name, Version_t cversion,
<span class="lineNum">     274 </span>            :           const char *dfil = 0, const char *ifil = 0,
<span class="lineNum">     275 </span>            :           Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE);
<span class="lineNum">     276 </span>            :    TClass(const char *name, Version_t cversion,
<span class="lineNum">     277 </span>            :           const type_info &amp;info, TVirtualIsAProxy *isa,
<span class="lineNum">     278 </span>            :           ShowMembersFunc_t showmember,
<span class="lineNum">     279 </span>            :           const char *dfil, const char *ifil,
<span class="lineNum">     280 </span>            :           Int_t dl, Int_t il, Bool_t silent = kFALSE);
<span class="lineNum">     281 </span>            :    virtual           ~TClass();
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            :    void               AddInstance(Bool_t heap = kFALSE) { fInstanceCount++; if (heap) fOnHeap++; }
<span class="lineNum">     284 </span>            :    void               AddImplFile(const char *filename, int line);
<span class="lineNum">     285 </span>            :    static Bool_t      AddRule(const char *rule);
<span class="lineNum">     286 </span>            :    static Int_t       ReadRules(const char *filename);
<span class="lineNum">     287 </span>            :    static Int_t       ReadRules();
<span class="lineNum">     288 </span>            :    void               AdoptSchemaRules( ROOT::TSchemaRuleSet *rules );
<span class="lineNum">     289 </span>            :    virtual void       Browse(TBrowser *b);
<span class="lineNum">     290 </span>            :    void               BuildRealData(void *pointer=0, Bool_t isTransient = kFALSE);
<span class="lineNum">     291 </span>            :    void               BuildEmulatedRealData(const char *name, Long_t offset, TClass *cl);
<span class="lineNum">     292 </span>            :    void               CalculateStreamerOffset() const;
<span class="lineNum">     293 </span>            :    Bool_t             CallShowMembers(void* obj, TMemberInspector &amp;insp,
<span class="lineNum">     294 </span>            :                                       Int_t isATObject = -1) const;
<span class="lineNum">     295 </span>            :    Bool_t             CanSplit() const;
<span class="lineNum">     296 </span>            :    Bool_t             CanIgnoreTObjectStreamer() { return TestBit(kIgnoreTObjectStreamer);}
<span class="lineNum">     297 </span>            :    TObject           *Clone(const char *newname=&quot;&quot;) const;
<span class="lineNum">     298 </span>            :    void               CopyCollectionProxy(const TVirtualCollectionProxy&amp;);
<span class="lineNum">     299 </span>            :    void               Draw(Option_t *option=&quot;&quot;);
<span class="lineNum">     300 </span>            :    void               Dump() const { TDictionary::Dump(); }
<span class="lineNum">     301 </span>            :    void               Dump(void *obj) const;
<span class="lineNum">     302 </span>            :    char              *EscapeChars(const char *text) const;
<span class="lineNum">     303 </span>            :    TVirtualStreamerInfo     *FindStreamerInfo(UInt_t checksum) const;
<span class="lineNum">     304 </span>            :    TVirtualStreamerInfo     *GetConversionStreamerInfo( const char* onfile_classname, Int_t version ) const;
<span class="lineNum">     305 </span>            :    TVirtualStreamerInfo     *FindConversionStreamerInfo( const char* onfile_classname, UInt_t checksum ) const;
<span class="lineNum">     306 </span>            :    TVirtualStreamerInfo     *GetConversionStreamerInfo( const TClass* onfile_cl, Int_t version ) const;
<span class="lineNum">     307 </span>            :    TVirtualStreamerInfo     *FindConversionStreamerInfo( const TClass* onfile_cl, UInt_t checksum ) const;
<span class="lineNum">     308 </span>            :    Bool_t             HasDefaultConstructor() const;
<span class="lineNum">     309 </span>            :    UInt_t             GetCheckSum(ECheckSum code = kCurrentCheckSum) const;
<span class="lineNum">     310 </span>            :    TVirtualCollectionProxy *GetCollectionProxy() const;
<span class="lineNum">     311 </span>            :    TVirtualIsAProxy  *GetIsAProxy() const;
<span class="lineNum">     312 </span>            :    Version_t          GetClassVersion() const { fVersionUsed = kTRUE; return fClassVersion; }
<span class="lineNum">     313 </span>            :    Int_t              GetClassSize() const { return Size(); }
<span class="lineNum">     314 </span>            :    TDataMember       *GetDataMember(const char *datamember) const;
<span class="lineNum">     315 </span>            :    Long_t              GetDataMemberOffset(const char *membername) const;
<span class="lineNum">     316 </span>            :    const char        *GetDeclFileName() const { return fDeclFileName; }
<span class="lineNum">     317 </span>            :    Short_t            GetDeclFileLine() const { return fDeclFileLine; }
<span class="lineNum">     318 </span>            :    ROOT::DelFunc_t    GetDelete() const;
<span class="lineNum">     319 </span>            :    ROOT::DesFunc_t    GetDestructor() const;
<span class="lineNum">     320 </span>            :    ROOT::DelArrFunc_t GetDeleteArray() const;
<span class="lineNum">     321 </span>            :    ClassInfo_t       *GetClassInfo() const { return fClassInfo; }
<span class="lineNum">     322 </span>            :    const char        *GetContextMenuTitle() const { return fContextMenuTitle; }
<span class="lineNum">     323 </span>            :    TVirtualStreamerInfo     *GetCurrentStreamerInfo() {
<span class="lineNum">     324 </span>            :       if (fCurrentInfo) return fCurrentInfo;
<span class="lineNum">     325 </span>            :       else return DetermineCurrentStreamerInfo();
<span class="lineNum">     326 </span>            :    }
<span class="lineNum">     327 </span>            :    TVirtualStreamerInfo     *GetLastReadInfo() const { return fLastReadInfo; }
<span class="lineNum">     328 </span>            :    void                      SetLastReadInfo(TVirtualStreamerInfo *info) { fLastReadInfo = info; }
<span class="lineNum">     329 </span>            :    TList             *GetListOfDataMembers();
<a name="330"><span class="lineNum">     330 </span>            :    TList             *GetListOfBases();</a>
<span class="lineNum">     331 </span>            :    TList             *GetListOfMethods();
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :    TList             *GetListOfRealData() const { return fRealData; }</span>
<span class="lineNum">     333 </span>            :    TList             *GetListOfAllPublicMethods();
<span class="lineNum">     334 </span>            :    TList             *GetListOfAllPublicDataMembers();
<span class="lineNum">     335 </span>            :    const char        *GetImplFileName() const { return fImplFileName; }
<span class="lineNum">     336 </span>            :    Short_t            GetImplFileLine() const { return fImplFileLine; }
<span class="lineNum">     337 </span>            :    TClass            *GetActualClass(const void *object) const;
<span class="lineNum">     338 </span>            :    TClass            *GetBaseClass(const char *classname);
<span class="lineNum">     339 </span>            :    TClass            *GetBaseClass(const TClass *base);
<span class="lineNum">     340 </span>            :    Int_t              GetBaseClassOffset(const TClass *base);
<span class="lineNum">     341 </span>            :    TClass            *GetBaseDataMember(const char *datamember);
<span class="lineNum">     342 </span>            :    ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const;
<span class="lineNum">     343 </span>            :    UInt_t             GetInstanceCount() const { return fInstanceCount; }
<span class="lineNum">     344 </span>            :    UInt_t             GetHeapInstanceCount() const { return fOnHeap; }
<span class="lineNum">     345 </span>            :    void               GetMenuItems(TList *listitems);
<span class="lineNum">     346 </span>            :    TList             *GetMenuList() const;
<span class="lineNum">     347 </span>            :    TMethod           *GetMethod(const char *method, const char *params);
<span class="lineNum">     348 </span>            :    TMethod           *GetMethodWithPrototype(const char *method, const char *proto);
<span class="lineNum">     349 </span>            :    TMethod           *GetMethodAny(const char *method);
<span class="lineNum">     350 </span>            :    TMethod           *GetMethodAllAny(const char *method);
<span class="lineNum">     351 </span>            :    Int_t              GetNdata();
<span class="lineNum">     352 </span>            :    ROOT::MergeFunc_t  GetMerge() const;
<span class="lineNum">     353 </span>            :    ROOT::ResetAfterMergeFunc_t  GetResetAfterMerge() const;
<span class="lineNum">     354 </span>            :    ROOT::NewFunc_t    GetNew() const;
<span class="lineNum">     355 </span>            :    ROOT::NewArrFunc_t GetNewArray() const;
<span class="lineNum">     356 </span>            :    Int_t              GetNmethods();
<span class="lineNum">     357 </span>            : #ifdef __CINT__
<span class="lineNum">     358 </span>            :    TClass           **GetPersistentRef() const { return fPersistentRef; }
<span class="lineNum">     359 </span>            : #else
<span class="lineNum">     360 </span>            :    TClass      *const*GetPersistentRef() const { return fPersistentRef; }
<span class="lineNum">     361 </span>            : #endif
<span class="lineNum">     362 </span>            :    TRealData         *GetRealData(const char *name) const;
<span class="lineNum">     363 </span>            :    TVirtualRefProxy  *GetReferenceProxy()  const   {  return fRefProxy; }
<span class="lineNum">     364 </span>            :    const ROOT::TSchemaRuleSet *GetSchemaRules() const;
<span class="lineNum">     365 </span>            :    ROOT::TSchemaRuleSet *GetSchemaRules(Bool_t create = kFALSE);
<span class="lineNum">     366 </span>            :    const char        *GetSharedLibs();
<span class="lineNum">     367 </span>            :    ShowMembersFunc_t  GetShowMembersWrapper() const { return fShowMembers; }
<span class="lineNum">     368 </span>            :    TClassStreamer    *GetStreamer() const;
<span class="lineNum">     369 </span>            :    ClassStreamerFunc_t GetStreamerFunc() const;
<span class="lineNum">     370 </span>            :    TObjArray         *GetStreamerInfos() const { return fStreamerInfo; }
<span class="lineNum">     371 </span>            :    TVirtualStreamerInfo     *GetStreamerInfo(Int_t version=0) const;
<span class="lineNum">     372 </span>            :    TVirtualStreamerInfo     *GetStreamerInfoAbstractEmulated(Int_t version=0) const;
<span class="lineNum">     373 </span>            :    TVirtualStreamerInfo     *FindStreamerInfoAbstractEmulated(UInt_t checksum) const;
<span class="lineNum">     374 </span>            :    const type_info   *GetTypeInfo() const { return fTypeInfo; };
<span class="lineNum">     375 </span>            :    void               IgnoreTObjectStreamer(Bool_t ignore=kTRUE);
<span class="lineNum">     376 </span>            :    Bool_t             InheritsFrom(const char *cl) const;
<span class="lineNum">     377 </span>            :    Bool_t             InheritsFrom(const TClass *cl) const;
<span class="lineNum">     378 </span>            :    void               InterpretedShowMembers(void* obj, TMemberInspector &amp;insp);
<span class="lineNum">     379 </span>            :    Bool_t             IsFolder() const { return kTRUE; }
<span class="lineNum">     380 </span>            :    Bool_t             IsLoaded() const;
<span class="lineNum">     381 </span>            :    Bool_t             IsForeign() const;
<span class="lineNum">     382 </span>            :    Bool_t             IsStartingWithTObject() const;
<span class="lineNum">     383 </span>            :    Bool_t             IsVersioned() const { return !( GetClassVersion()&lt;=1 &amp;&amp; IsForeign() ); }
<span class="lineNum">     384 </span>            :    Bool_t             IsTObject() const;
<span class="lineNum">     385 </span>            :    void               ls(Option_t *opt=&quot;&quot;) const;
<span class="lineNum">     386 </span>            :    void               MakeCustomMenuList();
<span class="lineNum">     387 </span>            :    Bool_t             MatchLegacyCheckSum(UInt_t checksum) const;
<span class="lineNum">     388 </span>            :    void               Move(void *arenaFrom, void *arenaTo) const;
<span class="lineNum">     389 </span>            :    void              *New(ENewType defConstructor = kClassNew) const;
<span class="lineNum">     390 </span>            :    void              *New(void *arena, ENewType defConstructor = kClassNew) const;
<span class="lineNum">     391 </span>            :    void              *NewArray(Long_t nElements, ENewType defConstructor = kClassNew) const;
<span class="lineNum">     392 </span>            :    void              *NewArray(Long_t nElements, void *arena, ENewType defConstructor = kClassNew) const;
<span class="lineNum">     393 </span>            :    virtual void       PostLoadCheck();
<span class="lineNum">     394 </span>            :    Long_t             Property() const;
<span class="lineNum">     395 </span>            :    Int_t              ReadBuffer(TBuffer &amp;b, void *pointer, Int_t version, UInt_t start, UInt_t count);
<span class="lineNum">     396 </span>            :    Int_t              ReadBuffer(TBuffer &amp;b, void *pointer);
<span class="lineNum">     397 </span>            :    void               ReplaceWith(TClass *newcl, Bool_t recurse = kTRUE) const;
<span class="lineNum">     398 </span>            :    void               ResetClassInfo(Long_t tagnum);
<span class="lineNum">     399 </span>            :    void               ResetInstanceCount() { fInstanceCount = fOnHeap = 0; }
<span class="lineNum">     400 </span>            :    void               ResetMenuList();
<span class="lineNum">     401 </span>            :    Int_t              Size() const;
<span class="lineNum">     402 </span>            :    void               SetCanSplit(Int_t splitmode);
<span class="lineNum">     403 </span>            :    void               SetCollectionProxy(const ROOT::TCollectionProxyInfo&amp;);
<span class="lineNum">     404 </span>            :    void               SetContextMenuTitle(const char *title);
<span class="lineNum">     405 </span>            :    void               SetCurrentStreamerInfo(TVirtualStreamerInfo *info);
<span class="lineNum">     406 </span>            :    void               SetGlobalIsA(IsAGlobalFunc_t);
<span class="lineNum">     407 </span>            :    void               SetDeclFile(const char *name, int line) { fDeclFileName = name; fDeclFileLine = line; }
<span class="lineNum">     408 </span>            :    void               SetDelete(ROOT::DelFunc_t deleteFunc);
<span class="lineNum">     409 </span>            :    void               SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc);
<span class="lineNum">     410 </span>            :    void               SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc);
<span class="lineNum">     411 </span>            :    void               SetDestructor(ROOT::DesFunc_t destructorFunc);
<span class="lineNum">     412 </span>            :    void               SetImplFileName(const char *implFileName) { fImplFileName = implFileName; }
<span class="lineNum">     413 </span>            :    void               SetMerge(ROOT::MergeFunc_t mergeFunc);
<span class="lineNum">     414 </span>            :    void               SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc);
<span class="lineNum">     415 </span>            :    void               SetNew(ROOT::NewFunc_t newFunc);
<span class="lineNum">     416 </span>            :    void               SetNewArray(ROOT::NewArrFunc_t newArrayFunc);
<span class="lineNum">     417 </span>            :    TVirtualStreamerInfo     *SetStreamerInfo(Int_t version, const char *info=&quot;&quot;);
<span class="lineNum">     418 </span>            :    void               SetUnloaded();
<span class="lineNum">     419 </span>            :    Int_t              WriteBuffer(TBuffer &amp;b, void *pointer, const char *info=&quot;&quot;);
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span>            :    void               AdoptReferenceProxy(TVirtualRefProxy* proxy);
<span class="lineNum">     422 </span>            :    void               AdoptStreamer(TClassStreamer *strm);
<span class="lineNum">     423 </span>            :    void               AdoptMemberStreamer(const char *name, TMemberStreamer *strm);
<span class="lineNum">     424 </span>            :    void               SetMemberStreamer(const char *name, MemberStreamerFunc_t strm);
<span class="lineNum">     425 </span>            :    void               SetStreamerFunc(ClassStreamerFunc_t strm);
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span>            :    // Function to retrieve the TClass object and dictionary function
<span class="lineNum">     428 </span>            :    static void           AddClass(TClass *cl);
<span class="lineNum">     429 </span>            :    static void           RemoveClass(TClass *cl);
<span class="lineNum">     430 </span>            :    static TClass        *GetClass(const char *name, Bool_t load = kTRUE, Bool_t silent = kFALSE);
<span class="lineNum">     431 </span>            :    static TClass        *GetClass(const type_info &amp;typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE);
<span class="lineNum">     432 </span>            :    static VoidFuncPtr_t  GetDict (const char *cname);
<span class="lineNum">     433 </span>            :    static VoidFuncPtr_t  GetDict (const type_info &amp;info);
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span>            :    static Int_t       AutoBrowse(TObject *obj, TBrowser *browser);
<span class="lineNum">     436 </span>            :    static ENewType    IsCallingNew();
<span class="lineNum">     437 </span>            :    static TClass     *Load(TBuffer &amp;b);
<span class="lineNum">     438 </span>            :    void               Store(TBuffer &amp;b) const;
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span>            :    // Pseudo-method apply to the 'obj'. In particular those are used to
<span class="lineNum">     441 </span>            :    // implement TObject like methods for non-TObject classes
<span class="lineNum">     442 </span>            : 
<span class="lineNum">     443 </span>            :    Int_t              Browse(void *obj, TBrowser *b) const;
<span class="lineNum">     444 </span>            :    void               DeleteArray(void *ary, Bool_t dtorOnly = kFALSE);
<span class="lineNum">     445 </span>            :    void               Destructor(void *obj, Bool_t dtorOnly = kFALSE);
<span class="lineNum">     446 </span>            :    void              *DynamicCast(const TClass *base, void *obj, Bool_t up = kTRUE);
<span class="lineNum">     447 </span>            :    Bool_t             IsFolder(void *obj) const;
<span class="lineNum">     448 </span>            :    inline void        Streamer(void *obj, TBuffer &amp;b, const TClass *onfile_class = 0) const
<span class="lineNum">     449 </span>            :    {
<span class="lineNum">     450 </span>            :       // Inline for performance, skipping one function call.
<span class="lineNum">     451 </span>            :       (this-&gt;*fStreamerImpl)(obj,b,onfile_class);
<span class="lineNum">     452 </span>            :    }
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            :    ClassDef(TClass,0)  //Dictionary containing class information
<span class="lineNum">     455 </span>            : };
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span>            : namespace ROOT {
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span>            : #ifndef R__NO_CLASS_TEMPLATE_SPECIALIZATION
<span class="lineNum">     460 </span>            :    template &lt;typename T&gt; struct IsPointer { enum { kVal = 0 }; };
<span class="lineNum">     461 </span>            :    template &lt;typename T&gt; struct IsPointer&lt;T*&gt; { enum { kVal = 1 }; };
<span class="lineNum">     462 </span>            : #else
<span class="lineNum">     463 </span>            :    template &lt;typename T&gt; Bool_t IsPointer(const T* /* dummy */) { return false; };
<span class="lineNum">     464 </span>            :    template &lt;typename T&gt; Bool_t IsPointer(const T** /* dummy */) { return true; };
<span class="lineNum">     465 </span>            : #endif
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            :    template &lt;typename T&gt; TClass* GetClass(      T* /* dummy */)        { return TClass::GetClass(typeid(T)); }
<span class="lineNum">     468 </span>            :    template &lt;typename T&gt; TClass* GetClass(const T* /* dummy */)        { return TClass::GetClass(typeid(T)); }
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span>            : #ifndef R__NO_CLASS_TEMPLATE_SPECIALIZATION
<span class="lineNum">     471 </span>            :    // This can only be used when the template overload resolution can distringuish between
<span class="lineNum">     472 </span>            :    // T* and T**
<span class="lineNum">     473 </span>            :    template &lt;typename T&gt; TClass* GetClass(      T**       /* dummy */) { return GetClass((T*)0); }
<span class="lineNum">     474 </span>            :    template &lt;typename T&gt; TClass* GetClass(const T**       /* dummy */) { return GetClass((T*)0); }
<span class="lineNum">     475 </span>            :    template &lt;typename T&gt; TClass* GetClass(      T* const* /* dummy */) { return GetClass((T*)0); }
<span class="lineNum">     476 </span>            :    template &lt;typename T&gt; TClass* GetClass(const T* const* /* dummy */) { return GetClass((T*)0); }
<span class="lineNum">     477 </span>            : #endif
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span>            :    extern TClass *CreateClass(const char *cname, Version_t id,
<span class="lineNum">     480 </span>            :                               const char *dfil, const char *ifil,
<span class="lineNum">     481 </span>            :                               Int_t dl, Int_t il);
<span class="lineNum">     482 </span>            : }
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span>            : #endif // ROOT_TClass
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
