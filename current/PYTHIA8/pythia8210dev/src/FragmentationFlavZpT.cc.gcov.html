<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - PYTHIA8/pythia8210dev/src/FragmentationFlavZpT.cc</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">PYTHIA8/pythia8210dev/src</a> - FragmentationFlavZpT.cc<span style="font-size: 80%;"> (source / <a href="FragmentationFlavZpT.cc.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">422</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">11</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // FragmentationFlavZpT.cc is a part of the PYTHIA event generator.</a>
<span class="lineNum">       2 </span>            : // Copyright (C) 2015 Torbjorn Sjostrand.
<span class="lineNum">       3 </span>            : // PYTHIA is licenced under the GNU GPL version 2, see COPYING for details.
<span class="lineNum">       4 </span>            : // Please respect the MCnet Guidelines, see GUIDELINES for details.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : // Function definitions (not found in the header) for the
<span class="lineNum">       7 </span>            : // StringFlav, StringZ and StringPT classes.
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;Pythia8/FragmentationFlavZpT.h&quot;
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : namespace Pythia8 {
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : //==========================================================================
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : // The StringFlav class.
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : // Constants: could be changed here if desired, but normally should not.
<span class="lineNum">      20 </span>            : // These are of technical nature, as described for each.
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : // Offset for different meson multiplet id values.
<span class="lineNum">      23 </span>            : const int StringFlav::mesonMultipletCode[6]
<span class="lineNum">      24 </span>            :   = { 1, 3, 10003, 10001, 20003, 5};
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : // Clebsch-Gordan coefficients for baryon octet and decuplet are
<span class="lineNum">      27 </span>            : // fixed once and for all, so only weighted sum needs to be edited.
<span class="lineNum">      28 </span>            : // Order: ud0 + u, ud0 + s, uu1 + u, uu1 + d, ud1 + u, ud1 + s.
<span class="lineNum">      29 </span>            : const double StringFlav::baryonCGOct[6]
<span class="lineNum">      30 </span>            :   = { 0.75, 0.5, 0., 0.1667, 0.0833, 0.1667};
<span class="lineNum">      31 </span>            : const double StringFlav::baryonCGDec[6]
<span class="lineNum">      32 </span>            :   = { 0.,  0.,  1., 0.3333, 0.6667, 0.3333};
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      35 </span>            : 
<a name="36"><span class="lineNum">      36 </span>            : // Initialize data members of the flavour generation.</a>
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : void StringFlav::init(Settings&amp; settings, Rndm* rndmPtrIn) {
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            :   // Save pointer.
<span class="lineNum">      41 </span><span class="lineNoCov">          0 :   rndmPtr         = rndmPtrIn;</span>
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            :   // Basic parameters for generation of new flavour.
<span class="lineNum">      44 </span><span class="lineNoCov">          0 :   probQQtoQ       = settings.parm(&quot;StringFlav:probQQtoQ&quot;);</span>
<span class="lineNum">      45 </span><span class="lineNoCov">          0 :   probStoUD       = settings.parm(&quot;StringFlav:probStoUD&quot;);</span>
<span class="lineNum">      46 </span><span class="lineNoCov">          0 :   probSQtoQQ      = settings.parm(&quot;StringFlav:probSQtoQQ&quot;);</span>
<span class="lineNum">      47 </span><span class="lineNoCov">          0 :   probQQ1toQQ0    = settings.parm(&quot;StringFlav:probQQ1toQQ0&quot;);</span>
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            :   // Parameters derived from above.
<span class="lineNum">      50 </span><span class="lineNoCov">          0 :   probQandQQ      = 1. + probQQtoQ;</span>
<span class="lineNum">      51 </span><span class="lineNoCov">          0 :   probQandS       = 2. + probStoUD;</span>
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :   probQandSinQQ   = 2. + probSQtoQQ * probStoUD;</span>
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :   probQQ1corr     = 3. * probQQ1toQQ0;</span>
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :   probQQ1corrInv  = 1. / probQQ1corr;</span>
<span class="lineNum">      55 </span><span class="lineNoCov">          0 :   probQQ1norm     = probQQ1corr / (1. + probQQ1corr);</span>
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            :   // Spin parameters for combining two quarks to a diquark.
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :   vector&lt;double&gt; pQQ1tmp = settings.pvec(&quot;StringFlav:probQQ1toQQ0join&quot;);</span>
<span class="lineNum">      59 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; 4; ++i)</span>
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :     probQQ1join[i] = 3. * pQQ1tmp[i] / (1. + 3. * pQQ1tmp[i]);</span>
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            :   // Parameters for normal meson production.
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; 4; ++i) mesonRate[i][0] = 1.;</span>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :   mesonRate[0][1] = settings.parm(&quot;StringFlav:mesonUDvector&quot;);</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :   mesonRate[1][1] = settings.parm(&quot;StringFlav:mesonSvector&quot;);</span>
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :   mesonRate[2][1] = settings.parm(&quot;StringFlav:mesonCvector&quot;);</span>
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :   mesonRate[3][1] = settings.parm(&quot;StringFlav:mesonBvector&quot;);</span>
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            :   // Parameters for L=1 excited-meson production.
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :   mesonRate[0][2] = settings.parm(&quot;StringFlav:mesonUDL1S0J1&quot;);</span>
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :   mesonRate[1][2] = settings.parm(&quot;StringFlav:mesonSL1S0J1&quot;);</span>
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :   mesonRate[2][2] = settings.parm(&quot;StringFlav:mesonCL1S0J1&quot;);</span>
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :   mesonRate[3][2] = settings.parm(&quot;StringFlav:mesonBL1S0J1&quot;);</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :   mesonRate[0][3] = settings.parm(&quot;StringFlav:mesonUDL1S1J0&quot;);</span>
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :   mesonRate[1][3] = settings.parm(&quot;StringFlav:mesonSL1S1J0&quot;);</span>
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :   mesonRate[2][3] = settings.parm(&quot;StringFlav:mesonCL1S1J0&quot;);</span>
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :   mesonRate[3][3] = settings.parm(&quot;StringFlav:mesonBL1S1J0&quot;);</span>
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :   mesonRate[0][4] = settings.parm(&quot;StringFlav:mesonUDL1S1J1&quot;);</span>
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :   mesonRate[1][4] = settings.parm(&quot;StringFlav:mesonSL1S1J1&quot;);</span>
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :   mesonRate[2][4] = settings.parm(&quot;StringFlav:mesonCL1S1J1&quot;);</span>
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :   mesonRate[3][4] = settings.parm(&quot;StringFlav:mesonBL1S1J1&quot;);</span>
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :   mesonRate[0][5] = settings.parm(&quot;StringFlav:mesonUDL1S1J2&quot;);</span>
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :   mesonRate[1][5] = settings.parm(&quot;StringFlav:mesonSL1S1J2&quot;);</span>
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :   mesonRate[2][5] = settings.parm(&quot;StringFlav:mesonCL1S1J2&quot;);</span>
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :   mesonRate[3][5] = settings.parm(&quot;StringFlav:mesonBL1S1J2&quot;);</span>
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            :   // Store sum over multiplets for Monte Carlo generation.
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; 4; ++i) mesonRateSum[i]</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :     = mesonRate[i][0] + mesonRate[i][1] + mesonRate[i][2]</span>
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :     + mesonRate[i][3] + mesonRate[i][4] + mesonRate[i][5];</span>
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            :   // Parameters for uubar - ddbar - ssbar meson mixing.
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :   for (int spin = 0; spin &lt; 6; ++spin) {</span>
<span class="lineNum">      94 </span>            :     double theta;
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :     if      (spin == 0) theta = settings.parm(&quot;StringFlav:thetaPS&quot;);</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :     else if (spin == 1) theta = settings.parm(&quot;StringFlav:thetaV&quot;);</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :     else if (spin == 2) theta = settings.parm(&quot;StringFlav:thetaL1S0J1&quot;);</span>
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :     else if (spin == 3) theta = settings.parm(&quot;StringFlav:thetaL1S1J0&quot;);</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :     else if (spin == 4) theta = settings.parm(&quot;StringFlav:thetaL1S1J1&quot;);</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :     else                theta = settings.parm(&quot;StringFlav:thetaL1S1J2&quot;);</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :     double alpha = (spin == 0) ? 90. - (theta + 54.7) : theta + 54.7;</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :     alpha *= M_PI / 180.;</span>
<span class="lineNum">     103 </span>            :     // Fill in (flavour, spin)-dependent probability of producing
<span class="lineNum">     104 </span>            :     // the lightest or the lightest two mesons of the nonet.
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :     mesonMix1[0][spin] = 0.5;</span>
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :     mesonMix2[0][spin] = 0.5 * (1. + pow2(sin(alpha)));</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :     mesonMix1[1][spin] = 0.;</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :     mesonMix2[1][spin] = pow2(cos(alpha));</span>
<span class="lineNum">     109 </span>            :   }
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            :   // Additional suppression of eta and etaPrime.
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :   etaSup      = settings.parm(&quot;StringFlav:etaSup&quot;);</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :   etaPrimeSup = settings.parm(&quot;StringFlav:etaPrimeSup&quot;);</span>
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            :   // Sum of baryon octet and decuplet weights.
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :   decupletSup = settings.parm(&quot;StringFlav:decupletSup&quot;);</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; 6; ++i) baryonCGSum[i]</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :     = baryonCGOct[i] + decupletSup * baryonCGDec[i];</span>
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            :   // Maximum SU(6) weight for ud0, ud1, uu1 types.
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :   baryonCGMax[0] = max( baryonCGSum[0], baryonCGSum[1]);</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :   baryonCGMax[1] = baryonCGMax[0];</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :   baryonCGMax[2] = max( baryonCGSum[2], baryonCGSum[3]);</span>
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :   baryonCGMax[3] = baryonCGMax[2];</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :   baryonCGMax[4] = max( baryonCGSum[4], baryonCGSum[5]);</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :   baryonCGMax[5] = baryonCGMax[4];</span>
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            :   // Popcorn baryon parameters.
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :   popcornRate    = settings.parm(&quot;StringFlav:popcornRate&quot;);</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :   popcornSpair   = settings.parm(&quot;StringFlav:popcornSpair&quot;);</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :   popcornSmeson  = settings.parm(&quot;StringFlav:popcornSmeson&quot;);</span>
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            :   // Suppression of leading (= first-rank) baryons.
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :   suppressLeadingB = settings.flag(&quot;StringFlav:suppressLeadingB&quot;);</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :   lightLeadingBSup = settings.parm(&quot;StringFlav:lightLeadingBSup&quot;);</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :   heavyLeadingBSup = settings.parm(&quot;StringFlav:heavyLeadingBSup&quot;);</span>
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            :   // Begin calculation of derived parameters for baryon production.
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            :   // Enumerate distinguishable diquark types (in diquark first is popcorn q).
<span class="lineNum">     141 </span>            :   enum Diquark {ud0, ud1, uu1, us0, su0, us1, su1, ss1};
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span>            :   // Maximum SU(6) weight by diquark type.
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :   double barCGMax[8];</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :   barCGMax[ud0] = baryonCGMax[0];</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :   barCGMax[ud1] = baryonCGMax[4];</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :   barCGMax[uu1] = baryonCGMax[2];</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :   barCGMax[us0] = baryonCGMax[0];</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :   barCGMax[su0] = baryonCGMax[0];</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :   barCGMax[us1] = baryonCGMax[4];</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :   barCGMax[su1] = baryonCGMax[4];</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :   barCGMax[ss1] = baryonCGMax[2];</span>
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            :   // Diquark SU(6) survival = Sum_quark (quark tunnel weight) * SU(6).
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :   double dMB[8];</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :   dMB[ud0] = 2. * baryonCGSum[0] + probStoUD * baryonCGSum[1];</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :   dMB[ud1] = 2. * baryonCGSum[4] + probStoUD * baryonCGSum[5];</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :   dMB[uu1] = baryonCGSum[2] + (1. + probStoUD) * baryonCGSum[3];</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :   dMB[us0] = (1. + probStoUD) * baryonCGSum[0] + baryonCGSum[1];</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :   dMB[su0] = dMB[us0];</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :   dMB[us1] = (1. + probStoUD) * baryonCGSum[4] + baryonCGSum[5];</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :   dMB[su1] = dMB[us1];</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :   dMB[ss1] = probStoUD * baryonCGSum[2] + 2. * baryonCGSum[3];</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :   for (int i = 1; i &lt; 8; ++i) dMB[i] = dMB[i] / dMB[0];</span>
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            :   // Tunneling factors for diquark production; only half a pair = sqrt.
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :   double probStoUDroot    = sqrt(probStoUD);</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :   double probSQtoQQroot   = sqrt(probSQtoQQ);</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :   double probQQ1toQQ0root = sqrt(probQQ1toQQ0);</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :   double qBB[8];</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :   qBB[ud1] = probQQ1toQQ0root;</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :   qBB[uu1] = probQQ1toQQ0root;</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :   qBB[us0] = probSQtoQQroot;</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :   qBB[su0] = probStoUDroot * probSQtoQQroot;</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :   qBB[us1] = probQQ1toQQ0root * qBB[us0];</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :   qBB[su1] = probQQ1toQQ0root * qBB[su0];</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :   qBB[ss1] = probStoUDroot * pow2(probSQtoQQroot) * probQQ1toQQ0root;</span>
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            :   // spin * (vertex factor) * (half-tunneling factor above).
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :   double qBM[8];</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :   qBM[ud1] = 3. * qBB[ud1];</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :   qBM[uu1] = 6. * qBB[uu1];</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :   qBM[us0] = probStoUD * qBB[us0];</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :   qBM[su0] = qBB[su0];</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :   qBM[us1] = probStoUD * 3. * qBB[us1];</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :   qBM[su1] = 3. * qBB[su1];</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :   qBM[ss1] = probStoUD * 6. * qBB[ss1];</span>
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            :   // Combine above two into total diquark weight for q -&gt; B Bbar.
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :   for (int i = 1; i &lt; 8; ++i) qBB[i] = qBB[i] * qBM[i];</span>
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            :   // Suppression from having strange popcorn meson.
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :   qBM[us0] *= popcornSmeson;</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :   qBM[us1] *= popcornSmeson;</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :   qBM[ss1] *= popcornSmeson;</span>
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span>            :   // Suppression for a heavy quark of a diquark to fit into a baryon
<span class="lineNum">     198 </span>            :   // on the other side of popcorn meson: (0) s/u for q -&gt; B M;
<span class="lineNum">     199 </span>            :   // (1) s/u for rank 0 diquark su -&gt; M B; (2) ditto for s -&gt; c/b.
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :   double uNorm = 1. + qBM[ud1] + qBM[uu1] + qBM[us0] + qBM[us1];</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :   scbBM[0] = (2. * (qBM[su0] + qBM[su1]) + qBM[ss1]) / uNorm;</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :   scbBM[1] = scbBM[0] * popcornSpair * qBM[su0] / qBM[us0];</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :   scbBM[2] = (1. + qBM[ud1]) * (2. + qBM[us0]) / uNorm;</span>
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span>            :   // Include maximum of Clebsch-Gordan coefficients.
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :   for (int i = 1; i &lt; 8; ++i) dMB[i] *= qBM[i];</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :   for (int i = 1; i &lt; 8; ++i) qBM[i] *= barCGMax[i] / barCGMax[0];</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :   for (int i = 1; i &lt; 8; ++i) qBB[i] *= barCGMax[i] / barCGMax[0];</span>
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span>            :   // Popcorn fraction for normal diquark production.
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :   double qNorm = uNorm * popcornRate / 3.;</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :   double sNorm = scbBM[0] * popcornSpair;</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :   popFrac = qNorm * (1. + qBM[ud1] + qBM[uu1] + qBM[us0] + qBM[us1]</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :     + sNorm * (qBM[su0] + qBM[su1] + 0.5 * qBM[ss1])) / (1. +  qBB[ud1]</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :     + qBB[uu1] + 2. * (qBB[us0] + qBB[us1]) + 0.5 * qBB[ss1]);</span>
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span>            :   // Popcorn fraction for rank 0 diquarks, depending on number of s quarks.
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :   popS[0] = qNorm * qBM[ud1] / qBB[ud1];</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :   popS[1] = qNorm * 0.5 * (qBM[us1] / qBB[us1]</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :     + sNorm * qBM[su1] / qBB[su1]);</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :   popS[2] = qNorm * sNorm * qBM[ss1] / qBB[ss1];</span>
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            :   // Recombine diquark weights to flavour and spin ratios. Second index:
<span class="lineNum">     224 </span>            :   // 0 = s/u popcorn quark ratio.
<span class="lineNum">     225 </span>            :   // 1, 2 = s/u ratio for vertex quark if popcorn quark is u/d or s.
<span class="lineNum">     226 </span>            :   // 3 = q/q' vertex quark ratio if popcorn quark is light and = q.
<span class="lineNum">     227 </span>            :   // 4, 5, 6 = (spin 1)/(spin 0) ratio for su, us and ud.
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span>            :   // Case 0: q -&gt; B B.
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :   dWT[0][0] = (2. * (qBB[su0] + qBB[su1]) + qBB[ss1])</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :     / (1. + qBB[ud1] + qBB[uu1] + qBB[us0] + qBB[us1]);</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :   dWT[0][1] = 2. * (qBB[us0] + qBB[us1]) / (1. + qBB[ud1] + qBB[uu1]);</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :   dWT[0][2] = qBB[ss1] / (qBB[su0] + qBB[su1]);</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :   dWT[0][3] = qBB[uu1] / (1. + qBB[ud1] + qBB[uu1]);</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :   dWT[0][4] = qBB[su1] / qBB[su0];</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :   dWT[0][5] = qBB[us1] / qBB[us0];</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :   dWT[0][6] = qBB[ud1];</span>
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span>            :   // Case 1: q -&gt; B M B.
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :   dWT[1][0] = (2. * (qBM[su0] + qBM[su1]) + qBM[ss1])</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :     / (1. + qBM[ud1] + qBM[uu1] + qBM[us0] + qBM[us1]);</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :   dWT[1][1] = 2. * (qBM[us0] + qBM[us1]) / (1. + qBM[ud1] + qBM[uu1]);</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :   dWT[1][2] = qBM[ss1] / (qBM[su0] + qBM[su1]);</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :   dWT[1][3] = qBM[uu1] / (1. + qBM[ud1] + qBM[uu1]);</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :   dWT[1][4] = qBM[su1] / qBM[su0];</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :   dWT[1][5] = qBM[us1] / qBM[us0];</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :   dWT[1][6] = qBM[ud1];</span>
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            :   // Case 2: qq -&gt; M B; diquark inside chain.
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :   dWT[2][0] = (2. * (dMB[su0] + dMB[su1]) + dMB[ss1])</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :     / (1. + dMB[ud1] + dMB[uu1] + dMB[us0] + dMB[us1]);</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :   dWT[2][1] = 2. * (dMB[us0] + dMB[us1]) / (1. + dMB[ud1] + dMB[uu1]);</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :   dWT[2][2] = dMB[ss1] / (dMB[su0] + dMB[su1]);</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :   dWT[2][3] = dMB[uu1] / (1. + dMB[ud1] + dMB[uu1]);</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :   dWT[2][4] = dMB[su1] / dMB[su0];</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :   dWT[2][5] = dMB[us1] / dMB[us0];</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :   dWT[2][6] = dMB[ud1];</span>
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     262 </span>            : 
<a name="263"><span class="lineNum">     263 </span>            : // Pick a new flavour (including diquarks) given an incoming one.</a>
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            : FlavContainer StringFlav::pick(FlavContainer&amp; flavOld) {
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            :   // Initial values for new flavour.
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :   FlavContainer flavNew;</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :   flavNew.rank = flavOld.rank + 1;</span>
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            :   // For original diquark assign popcorn quark and whether popcorn meson.
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :   int idOld = abs(flavOld.id);</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :   if (flavOld.rank == 0 &amp;&amp; idOld &gt; 1000) assignPopQ(flavOld);</span>
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            :   // Diquark exists, to be forced into baryon now.
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :   bool doOldBaryon    = (idOld &gt; 1000 &amp;&amp; flavOld.nPop == 0);</span>
<span class="lineNum">     277 </span>            :   // Diquark exists, but do meson now.
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :   bool doPopcornMeson = flavOld.nPop &gt; 0;</span>
<span class="lineNum">     279 </span>            :   // Newly created diquark gives baryon now, antibaryon later.
<span class="lineNum">     280 </span>            :   bool doNewBaryon    = false;
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span>            :   // Choose whether to generate a new meson or a new baryon.
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :   if (!doOldBaryon &amp;&amp; !doPopcornMeson &amp;&amp; probQandQQ * rndmPtr-&gt;flat() &gt; 1.) {</span>
<span class="lineNum">     284 </span>            :     doNewBaryon = true;
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :     if ((1. + popFrac) * rndmPtr-&gt;flat() &gt; 1.) flavNew.nPop = 1;</span>
<span class="lineNum">     286 </span>            :   }
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            :   // Optional suppression of first-rank baryon.
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :   if (flavOld.rank == 0 &amp;&amp; doNewBaryon &amp;&amp; suppressLeadingB) {</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :     double leadingBSup = (idOld &lt; 4) ? lightLeadingBSup : heavyLeadingBSup;</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :     if (rndmPtr-&gt;flat() &gt; leadingBSup) {</span>
<span class="lineNum">     292 </span>            :       doNewBaryon = false;
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :       flavNew.nPop = 0;</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span>            :   // Single quark for new meson or for baryon where diquark already exists.
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :   if (!doPopcornMeson &amp;&amp; !doNewBaryon) {</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :     flavNew.id = pickLightQ();</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :     if ( (flavOld.id &gt; 0 &amp;&amp; flavOld.id &lt; 9) || flavOld.id &lt; -1000 )</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :       flavNew.id = -flavNew.id;</span>
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span>            :     // Done for simple-quark case.
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :     return flavNew;</span>
<span class="lineNum">     305 </span>            :   }
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            :   // Case: 0 = q -&gt; B B, 1 = q -&gt; B M B, 2 = qq -&gt; M B.
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :   int iCase = flavNew.nPop;</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :   if (flavOld.nPop == 1) iCase = 2;</span>
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            :   // Flavour of popcorn quark (= q shared between B and Bbar).
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :   if (doNewBaryon) {</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :     double sPopWT = dWT[iCase][0];</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :     if (iCase == 1) sPopWT *= scbBM[0] * popcornSpair;</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :     double rndmFlav = (2. + sPopWT) * rndmPtr-&gt;flat();</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :     flavNew.idPop = 1;</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :     if (rndmFlav &gt; 1.) flavNew.idPop = 2;</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :     if (rndmFlav &gt; 2.) flavNew.idPop = 3;</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :   } else flavNew.idPop = flavOld.idPop;</span>
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span>            :   // Flavour of vertex quark.
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :   double sVtxWT = dWT[iCase][1];</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :   if (flavNew.idPop &gt;= 3) sVtxWT = dWT[iCase][2];</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :   if (flavNew.idPop &gt; 3) sVtxWT *= 0.5 * (1. + 1./dWT[iCase][4]);</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :   double rndmFlav = (2. + sVtxWT) * rndmPtr-&gt;flat();</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :   flavNew.idVtx = 1;</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :   if (rndmFlav &gt; 1.) flavNew.idVtx = 2;</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :   if (rndmFlav &gt; 2.) flavNew.idVtx = 3;</span>
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            :   // Special case for light flavours, possibly identical.
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :   if (flavNew.idPop &lt; 3 &amp;&amp; flavNew.idVtx &lt; 3) {</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :     flavNew.idVtx = flavNew.idPop;</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :     if (rndmPtr-&gt;flat() &gt; dWT[iCase][3]) flavNew.idVtx = 3 - flavNew.idPop;</span>
<span class="lineNum">     334 </span>            :   }
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            :   // Pick 2 * spin + 1.
<span class="lineNum">     337 </span>            :   int spin = 3;
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :   if (flavNew.idVtx != flavNew.idPop) {</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :     double spinWT = dWT[iCase][6];</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :     if (flavNew.idVtx == 3) spinWT = dWT[iCase][5];</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :     if (flavNew.idPop &gt;= 3) spinWT = dWT[iCase][4];</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :     if ((1. + spinWT) * rndmPtr-&gt;flat() &lt; 1.) spin = 1;</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            :   // Form outgoing diquark. Done.
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :   flavNew.id = 1000 * max(flavNew.idVtx, flavNew.idPop)</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :     + 100 * min(flavNew.idVtx, flavNew.idPop) + spin;</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :   if ( (flavOld.id &lt; 0 &amp;&amp; flavOld.id &gt; -9) || flavOld.id &gt; 1000 )</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :     flavNew.id = -flavNew.id;</span>
<span class="lineNum">     350 </span>            :   return flavNew;
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span>            : // Combine two flavours (including diquarks) to produce a hadron.
<a name="357"><span class="lineNum">     357 </span>            : // The weighting of the combination may fail, giving output 0.</a>
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span>            : int StringFlav::combine(FlavContainer&amp; flav1, FlavContainer&amp; flav2) {
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            :   // Recognize largest and smallest flavour.
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :   int id1Abs = abs(flav1.id);</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :   int id2Abs = abs(flav2.id);</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :   int idMax = max(id1Abs, id2Abs);</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :   int idMin = min(id1Abs, id2Abs);</span>
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span>            :   // Construct a meson.
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :   if (idMax &lt; 9 || idMin &gt; 1000) {</span>
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            :     // Popcorn meson: use only vertex quarks. Fail if none.
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :     if (idMin &gt; 1000) {</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :       id1Abs = flav1.idVtx;</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :       id2Abs = flav2.idVtx;</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :       idMax = max(id1Abs, id2Abs);</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :       idMin = min(id1Abs, id2Abs);</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :       if (idMin == 0) return 0;</span>
<span class="lineNum">     377 </span>            :     }
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span>            :     // Pick spin state and preliminary code.
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :     int flav = (idMax &lt; 3) ? 0 : idMax - 2;</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :     double rndmSpin = mesonRateSum[flav] * rndmPtr-&gt;flat();</span>
<span class="lineNum">     382 </span>            :     int spin = -1;
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :     do rndmSpin -= mesonRate[flav][++spin];</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :     while (rndmSpin &gt; 0.);</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :     int idMeson = 100 * idMax + 10 * idMin + mesonMultipletCode[spin];</span>
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span>            :     // For nondiagonal mesons distinguish particle/antiparticle.
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :     if (idMax != idMin) {</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :       int sign = (idMax%2 == 0) ? 1 : -1;</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :       if ( (idMax == id1Abs &amp;&amp; flav1.id &lt; 0)</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :         || (idMax == id2Abs &amp;&amp; flav2.id &lt; 0) ) sign = -sign;</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :       idMeson *= sign;</span>
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span>            :     // For light diagonal mesons include uubar - ddbar - ssbar mixing.
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :     } else if (flav &lt; 2) {</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :       double rMix = rndmPtr-&gt;flat();</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :       if      (rMix &lt; mesonMix1[flav][spin]) idMeson = 110;</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :       else if (rMix &lt; mesonMix2[flav][spin]) idMeson = 220;</span>
<span class="lineNum">     399 </span>            :       else                                   idMeson = 330;
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :       idMeson += mesonMultipletCode[spin];</span>
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            :       // Additional suppression of eta and eta' may give failure.
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :       if (idMeson == 221 &amp;&amp; etaSup &lt; rndmPtr-&gt;flat()) return 0;</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :       if (idMeson == 331 &amp;&amp; etaPrimeSup &lt; rndmPtr-&gt;flat()) return 0;</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span>            :     // Finished for mesons.
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :     return idMeson;</span>
<span class="lineNum">     409 </span>            :   }
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            :   // SU(6) factors for baryon production may give failure.
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :   int idQQ1 = idMax / 1000;</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :   int idQQ2 = (idMax / 100) % 10;</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :   int spinQQ = idMax % 10;</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :   int spinFlav = spinQQ - 1;</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :   if (spinFlav == 2 &amp;&amp; idQQ1 != idQQ2) spinFlav = 4;</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :   if (idMin != idQQ1 &amp;&amp; idMin != idQQ2) spinFlav++;</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :   if (baryonCGSum[spinFlav] &lt; rndmPtr-&gt;flat() * baryonCGMax[spinFlav])</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span>            :   // Order quarks to form baryon. Pick spin.
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :   int idOrd1 = max( idMin, max( idQQ1, idQQ2) );</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :   int idOrd3 = min( idMin, min( idQQ1, idQQ2) );</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :   int idOrd2 = idMin + idQQ1 + idQQ2 - idOrd1 - idOrd3;</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :   int spinBar = (baryonCGSum[spinFlav] * rndmPtr-&gt;flat()</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :     &lt; baryonCGOct[spinFlav]) ? 2 : 4;</span>
<span class="lineNum">     427 </span>            : 
<span class="lineNum">     428 </span>            :   // Distinguish Lambda- and Sigma-like.
<span class="lineNum">     429 </span>            :   bool LambdaLike = false;
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :   if (spinBar == 2 &amp;&amp; idOrd1 &gt; idOrd2 &amp;&amp; idOrd2 &gt; idOrd3) {</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :     LambdaLike = (spinQQ == 1);</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :     if (idOrd1 != idMin &amp;&amp; spinQQ == 1) LambdaLike = (rndmPtr-&gt;flat() &lt; 0.25);</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :     else if (idOrd1 != idMin)           LambdaLike = (rndmPtr-&gt;flat() &lt; 0.75);</span>
<span class="lineNum">     434 </span>            :   }
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span>            :   // Form baryon code and return with sign.
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :   int idBaryon = (LambdaLike)</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :     ? 1000 * idOrd1 + 100 * idOrd3 + 10 * idOrd2 + spinBar</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :     : 1000 * idOrd1 + 100 * idOrd2 + 10 * idOrd3 + spinBar;</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :    return (flav1.id &gt; 0) ? idBaryon : -idBaryon;</span>
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     445 </span>            : 
<a name="446"><span class="lineNum">     446 </span>            : // Assign popcorn quark inside an original (= rank 0) diquark.</a>
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span>            : void StringFlav::assignPopQ(FlavContainer&amp; flav) {
<span class="lineNum">     449 </span>            : 
<span class="lineNum">     450 </span>            :   // Safety check that intended to do something.
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :   int idAbs = abs(flav.id);</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :   if (flav.rank &gt; 0 || idAbs &lt; 1000) return;</span>
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            :   // Make choice of popcorn quark.
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :   int id1 = (idAbs/1000)%10;</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :   int id2 = (idAbs/100)%10;</span>
<span class="lineNum">     457 </span>            :   double pop2WT = 1.;
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :        if (id1 == 3) pop2WT = scbBM[1];</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :   else if (id1 &gt;  3) pop2WT = scbBM[2];</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :        if (id2 == 3) pop2WT /= scbBM[1];</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :   else if (id2 &gt;  3) pop2WT /= scbBM[2];</span>
<span class="lineNum">     462 </span>            :   // Agrees with Patrik code, but opposite to intention??
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :   flav.idPop = ((1. + pop2WT) * rndmPtr-&gt;flat() &gt; 1.) ? id2 : id1;</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :   flav.idVtx = id1 + id2 - flav.idPop;</span>
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span>            :   // Also determine if to produce popcorn meson.
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :   flav.nPop = 0;</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :   double popWT = popS[0];</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :   if (id1 == 3) popWT = popS[1];</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :   if (id2 == 3) popWT = popS[2];</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :   if (idAbs%10 == 1) popWT *= sqrt(probQQ1toQQ0);</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :   if ((1. + popWT) * rndmPtr-&gt;flat() &gt; 1.) flav.nPop = 1;</span>
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     475 </span>            : 
<span class="lineNum">     476 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            : // Combine two quarks to produce a diquark.
<span class="lineNum">     479 </span>            : // Normally according to production composition, but nonvanishing idHad
<a name="480"><span class="lineNum">     480 </span>            : // means diquark from known hadron content, so use SU(6) wave fucntion.</a>
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span>            : int StringFlav::makeDiquark(int id1, int id2, int idHad) {
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span>            :   // Initial values.
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :   int idMin = min( abs(id1), abs(id2));</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :   int idMax = max( abs(id1), abs(id2));</span>
<span class="lineNum">     487 </span>            :   int spin = 1;
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span>            :   // Select spin of diquark formed from two valence quarks in proton.
<span class="lineNum">     490 </span>            :   // (More hadron cases??)
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :   if (abs(idHad) == 2212 || abs(idHad) == 2112) {</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :     if (idMin == 1 &amp;&amp; idMax == 2 &amp;&amp; rndmPtr-&gt;flat() &lt; 0.75) spin = 0;</span>
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span>            :   // Else select spin of diquark according to assumed spin-1 suppression.
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :   } else if (idMin != idMax) {</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :     if (rndmPtr-&gt;flat() &gt; probQQ1join[min(idMax,5) - 2]) spin = 0;</span>
<span class="lineNum">     497 </span>            :   }
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span>            :   // Combined diquark code.
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :   int idNewAbs = 1000 * idMax + 100 * idMin + 2 * spin + 1;</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :   return (id1 &gt; 0) ? idNewAbs : -idNewAbs;</span>
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span>            : //==========================================================================
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span>            : // The StringZ class.
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span>            : // Constants: could be changed here if desired, but normally should not.
<span class="lineNum">     512 </span>            : // These are of technical nature, as described for each.
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span>            : // When a or c are close to special cases, default to these.
<span class="lineNum">     515 </span>            : const double StringZ::CFROMUNITY = 0.01;
<span class="lineNum">     516 </span>            : const double StringZ::AFROMZERO  = 0.02;
<span class="lineNum">     517 </span>            : const double StringZ::AFROMC     = 0.01;
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span>            : // Do not take exponent of too large or small number.
<span class="lineNum">     520 </span>            : const double StringZ::EXPMAX     = 50.;
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     523 </span>            : 
<a name="524"><span class="lineNum">     524 </span>            : // Initialize data members of the string z selection.</a>
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span>            : void StringZ::init(Settings&amp; settings, ParticleData&amp; particleData,
<span class="lineNum">     527 </span>            :   Rndm* rndmPtrIn) {
<span class="lineNum">     528 </span>            : 
<span class="lineNum">     529 </span>            :   // Save pointer.
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :   rndmPtr       = rndmPtrIn;</span>
<span class="lineNum">     531 </span>            : 
<span class="lineNum">     532 </span>            :   // c and b quark masses.
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :   mc2           = pow2( particleData.m0(4));</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :   mb2           = pow2( particleData.m0(5));</span>
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span>            :   // Paramaters of Lund/Bowler symmetric fragmentation function.
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :   aLund         = settings.parm(&quot;StringZ:aLund&quot;);</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :   bLund         = settings.parm(&quot;StringZ:bLund&quot;);</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :   aExtraSQuark  = settings.parm(&quot;StringZ:aExtraSQuark&quot;);</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :   aExtraDiquark = settings.parm(&quot;StringZ:aExtraDiquark&quot;);</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :   rFactC        = settings.parm(&quot;StringZ:rFactC&quot;);</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :   rFactB        = settings.parm(&quot;StringZ:rFactB&quot;);</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :   rFactH        = settings.parm(&quot;StringZ:rFactH&quot;);</span>
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span>            :   // Flags and parameters of nonstandard Lund fragmentation functions.
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :   useNonStandC  = settings.flag(&quot;StringZ:useNonstandardC&quot;);</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :   useNonStandB  = settings.flag(&quot;StringZ:useNonstandardB&quot;);</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :   useNonStandH  = settings.flag(&quot;StringZ:useNonstandardH&quot;);</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :   aNonC         = settings.parm(&quot;StringZ:aNonstandardC&quot;);</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :   aNonB         = settings.parm(&quot;StringZ:aNonstandardB&quot;);</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :   aNonH         = settings.parm(&quot;StringZ:aNonstandardH&quot;);</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :   bNonC         = settings.parm(&quot;StringZ:bNonstandardC&quot;);</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :   bNonB         = settings.parm(&quot;StringZ:bNonstandardB&quot;);</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :   bNonH         = settings.parm(&quot;StringZ:bNonstandardH&quot;);</span>
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span>            :   // Flags and parameters of Peterson/SLAC fragmentation function.
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :   usePetersonC  = settings.flag(&quot;StringZ:usePetersonC&quot;);</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :   usePetersonB  = settings.flag(&quot;StringZ:usePetersonB&quot;);</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :   usePetersonH  = settings.flag(&quot;StringZ:usePetersonH&quot;);</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :   epsilonC      = settings.parm(&quot;StringZ:epsilonC&quot;);</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :   epsilonB      = settings.parm(&quot;StringZ:epsilonB&quot;);</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :   epsilonH      = settings.parm(&quot;StringZ:epsilonH&quot;);</span>
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span>            :   // Parameters for joining procedure.
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :   stopM         = settings.parm(&quot;StringFragmentation:stopMass&quot;);</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :   stopNF        = settings.parm(&quot;StringFragmentation:stopNewFlav&quot;);</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :   stopS         = settings.parm(&quot;StringFragmentation:stopSmear&quot;);</span>
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span>            : // Generate the fraction z that the next hadron will take,
<span class="lineNum">     574 </span>            : // using either Lund/Bowler or, for heavy, Peterson/SLAC functions.
<a name="575"><span class="lineNum">     575 </span>            : // Note: for a heavy new coloured particle we assume pT negligible.</a>
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span>            : double StringZ::zFrag( int idOld, int idNew, double mT2) {
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span>            :   // Find if old or new flavours correspond to diquarks.
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :   int idOldAbs = abs(idOld);</span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :   int idNewAbs = abs(idNew);</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :   bool isOldSQuark = (idOldAbs == 3);</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :   bool isNewSQuark = (idNewAbs == 3);</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :   bool isOldDiquark = (idOldAbs &gt; 1000 &amp;&amp; idOldAbs &lt; 10000);</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :   bool isNewDiquark = (idNewAbs &gt; 1000 &amp;&amp; idNewAbs &lt; 10000);</span>
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span>            :   // Find heaviest quark in fragmenting parton/diquark.
<span class="lineNum">     588 </span>            :   int idFrag = idOldAbs;
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :   if (isOldDiquark) idFrag = max( idOldAbs / 1000, (idOldAbs / 100) % 10);</span>
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span>            :   // Use Peterson where explicitly requested for heavy flavours.
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :   if (idFrag == 4 &amp;&amp; usePetersonC) return zPeterson( epsilonC);</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :   if (idFrag == 5 &amp;&amp; usePetersonB) return zPeterson( epsilonB);</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :   if (idFrag &gt;  5 &amp;&amp; usePetersonH) {</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :     double epsilon = epsilonH * mb2 / mT2;</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :     return zPeterson( epsilon);</span>
<span class="lineNum">     597 </span>            :   }
<span class="lineNum">     598 </span>            : 
<span class="lineNum">     599 </span>            :   // Nonstandard a and b values implemented for heavy flavours.
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :   double aNow = aLund;</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :   double bNow = bLund;</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :   if (idFrag == 4 &amp;&amp; useNonStandC) {</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :     aNow = aNonC;</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :     bNow = bNonC;</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :   } else if (idFrag == 5 &amp;&amp; useNonStandB) {</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :     aNow = aNonB;</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :     bNow = bNonB;</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :   } else if (idFrag &gt;  5 &amp;&amp; useNonStandH) {</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :     aNow = aNonH;</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :     bNow = bNonH;</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span>            :   // Shape parameters of Lund symmetric fragmentation function.
<span class="lineNum">     614 </span>            :   double aShape = aNow;
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :   if (isOldSQuark)  aShape += aExtraSQuark;</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :   if (isOldDiquark) aShape += aExtraDiquark;</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :   double bShape = bNow * mT2;</span>
<span class="lineNum">     618 </span>            :   double cShape = 1.;
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :   if (isOldSQuark)  cShape -= aExtraSQuark;</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :   if (isNewSQuark)  cShape += aExtraSQuark;</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :   if (isOldDiquark) cShape -= aExtraDiquark;</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :   if (isNewDiquark) cShape += aExtraDiquark;</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :   if (idFrag == 4) cShape += rFactC * bNow * mc2;</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :   if (idFrag == 5) cShape += rFactB * bNow * mb2;</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :   if (idFrag &gt;  5) cShape += rFactH * bNow * mT2;</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :   return zLund( aShape, bShape, cShape);</span>
<span class="lineNum">     627 </span>            : 
<span class="lineNum">     628 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span>            : // Generate a random z according to the Lund/Bowler symmetric
<span class="lineNum">     633 </span>            : // fragmentation function f(z) = (1 -z)^a * exp(-b/z) / z^c.
<span class="lineNum">     634 </span>            : // Normalized so that f(z_max) = 1  it can also be written as
<span class="lineNum">     635 </span>            : // f(z) = exp( a * ln( (1 - z) / (1 - z_max) ) + b * (1/z_max - 1/z)
<a name="636"><span class="lineNum">     636 </span>            : //           + c * ln(z_max/z) ).</a>
<span class="lineNum">     637 </span>            : 
<span class="lineNum">     638 </span>            : double StringZ::zLund( double a, double b, double c) {
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span>            :   // Special cases for c = 1, a = 0 and a = c.
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :   bool cIsUnity = (abs( c - 1.) &lt; CFROMUNITY);</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :   bool aIsZero = (a &lt; AFROMZERO);</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :   bool aIsC = (abs(a - c) &lt; AFROMC);</span>
<span class="lineNum">     644 </span>            : 
<span class="lineNum">     645 </span>            :   // Determine position of maximum.
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :   double zMax;</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :   if (aIsZero) zMax = (c &gt; b) ? b / c : 1.;</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :   else if (aIsC) zMax = b / (b + c);</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :   else { zMax = 0.5 * (b + c - sqrt( pow2(b - c) + 4. * a * b)) / (c - a);</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :          if (zMax &gt; 0.9999 &amp;&amp; b &gt; 100.) zMax = min(zMax, 1. - a / b); }</span>
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span>            :   // Subdivide z range if distribution very peaked near either endpoint.
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :   bool peakedNearZero = (zMax &lt; 0.1);</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :   bool peakedNearUnity = (zMax &gt; 0.85 &amp;&amp; b &gt; 1.);</span>
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span>            :   // Find integral of trial function everywhere bigger than f.
<span class="lineNum">     657 </span>            :   // (Dummy start values.)
<span class="lineNum">     658 </span>            :   double fIntLow = 1.;
<span class="lineNum">     659 </span>            :   double fIntHigh = 1.;
<span class="lineNum">     660 </span>            :   double fInt = 2.;
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :   double zDiv = 0.5;</span>
<span class="lineNum">     662 </span>            :   double zDivC = 0.5;
<span class="lineNum">     663 </span>            :   // When z_max is small use that f(z)
<span class="lineNum">     664 </span>            :   //   &lt; 1     for z &lt; z_div = 2.75 * z_max,
<span class="lineNum">     665 </span>            :   //   &lt; (z_div/z)^c for z &gt; z_div (=&gt; logarithm for c = 1, else power).
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :   if (peakedNearZero) {</span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :     zDiv = 2.75 * zMax;</span>
<span class="lineNum">     668 </span>            :     fIntLow = zDiv;
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :     if (cIsUnity) fIntHigh = -zDiv * log(zDiv);</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :     else { zDivC = pow( zDiv, 1. - c);</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :            fIntHigh = zDiv * (1. - 1./zDivC) / (c - 1.);}</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :     fInt = fIntLow + fIntHigh;</span>
<span class="lineNum">     673 </span>            :   // When z_max large use that f(z)
<span class="lineNum">     674 </span>            :   //   &lt; exp( b * (z - z_div) ) for z &lt; z_div with z_div messy expression,
<span class="lineNum">     675 </span>            :   //   &lt; 1   for z &gt; z_div.
<span class="lineNum">     676 </span>            :   // To simplify expressions the integral is extended to z =  -infinity.
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :   } else if (peakedNearUnity) {</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :     double rcb = sqrt(4. + pow2(c / b));</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :     zDiv = rcb - 1./zMax - (c / b) * log( zMax * 0.5 * (rcb + c / b) );</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :     if (!aIsZero) zDiv += (a/b) * log(1. - zMax);</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :     zDiv = min( zMax, max(0., zDiv));</span>
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :     fIntLow = 1. / b;</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :     fIntHigh = 1. - zDiv;</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :     fInt = fIntLow + fIntHigh;</span>
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span>            :   // Choice of z, preweighted for peaks at low or high z. (Dummy start values.)
<span class="lineNum">     688 </span>            :   double z = 0.5;
<span class="lineNum">     689 </span>            :   double fPrel = 1.;
<span class="lineNum">     690 </span>            :   double fVal = 1.;
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :   do {</span>
<span class="lineNum">     692 </span>            :     // Choice of z flat good enough for distribution peaked in the middle;
<span class="lineNum">     693 </span>            :     // if not this z can be reused as a random number in general.
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :     z = rndmPtr-&gt;flat();</span>
<span class="lineNum">     695 </span>            :     fPrel = 1.;
<span class="lineNum">     696 </span>            :     // When z_max small use flat below z_div and 1/z^c above z_div.
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :     if (peakedNearZero) {</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :       if (fInt * rndmPtr-&gt;flat() &lt; fIntLow) z = zDiv * z;</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :       else if (cIsUnity) {z = pow( zDiv, z); fPrel = zDiv / z;}</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :       else { z = pow( zDivC + (1. - zDivC) * z, 1. / (1. - c) );</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :              fPrel = pow( zDiv / z, c); }</span>
<span class="lineNum">     702 </span>            :     // When z_max large use exp( b * (z -z_div) ) below z_div
<span class="lineNum">     703 </span>            :     // and flat above it.
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :     } else if (peakedNearUnity) {</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :       if (fInt * rndmPtr-&gt;flat() &lt; fIntLow) {</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :         z = zDiv + log(z) / b;</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :         fPrel = exp( b * (z - zDiv) );</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :       } else z = zDiv + (1. - zDiv) * z;</span>
<span class="lineNum">     709 </span>            :     }
<span class="lineNum">     710 </span>            : 
<span class="lineNum">     711 </span>            :     // Evaluate actual f(z) (if in physical range) and correct.
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :     if (z &gt; 0 &amp;&amp; z &lt; 1) {</span>
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :       double fExp = b * (1. / zMax - 1. / z)+ c * log(zMax / z);</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :       if (!aIsZero) fExp += a * log( (1. - z) / (1. - zMax) );</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :       fVal = exp( max( -EXPMAX, min( EXPMAX, fExp) ) ) ;</span>
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :     } else fVal = 0.;</span>
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :   } while (fVal &lt; rndmPtr-&gt;flat() * fPrel);</span>
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span>            :   // Done.
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :   return z;</span>
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     723 </span>            : 
<span class="lineNum">     724 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     725 </span>            : 
<span class="lineNum">     726 </span>            : // Generate a random z according to the Peterson/SLAC formula
<span class="lineNum">     727 </span>            : // f(z) = 1 / ( z * (1 - 1/z - epsilon/(1-z))^2 )
<a name="728"><span class="lineNum">     728 </span>            : //      = z * (1-z)^2 / ((1-z)^2 + epsilon * z)^2.</a>
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span>            : double StringZ::zPeterson( double epsilon) {
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span>            :   double z, fVal;
<span class="lineNum">     733 </span>            : 
<span class="lineNum">     734 </span>            :   // For large epsilon pick z flat and reject,
<span class="lineNum">     735 </span>            :   // knowing that 4 * epsilon * f(z) &lt; 1 everywhere.
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :   if (epsilon &gt; 0.01) {</span>
<span class="lineNum">     737 </span>            :     do {
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :       z = rndmPtr-&gt;flat();</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :       fVal = 4. * epsilon * z * pow2(1. - z)</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :         / pow2( pow2(1. - z) + epsilon * z);</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :     } while (fVal &lt; rndmPtr-&gt;flat());</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :     return z;</span>
<span class="lineNum">     743 </span>            :   }
<span class="lineNum">     744 </span>            : 
<span class="lineNum">     745 </span>            :   // Else split range, using that 4 * epsilon * f(z)
<span class="lineNum">     746 </span>            :   //   &lt; 4 * epsilon / (1 - z)^2 for 0 &lt; z &lt; 1 - 2 * sqrt(epsilon)
<span class="lineNum">     747 </span>            :   //   &lt; 1                       for 1 - 2 * sqrt(epsilon) &lt; z &lt; 1
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :   double epsRoot = sqrt(epsilon);</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :   double epsComb = 0.5 / epsRoot - 1.;</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :   double fIntLow = 4. * epsilon * epsComb;</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :   double fInt = fIntLow + 2. * epsRoot;</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :   do {</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :     if (rndmPtr-&gt;flat() * fInt &lt; fIntLow) {</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :       z = 1. - 1. / (1. + rndmPtr-&gt;flat() * epsComb);</span>
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :       fVal = z * pow2( pow2(1. - z) / (pow2(1. - z) + epsilon * z) );</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :       z = 1. - 2. * epsRoot * rndmPtr-&gt;flat();</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :       fVal = 4. * epsilon * z * pow2(1. - z)</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :         / pow2( pow2(1. - z) + epsilon * z);</span>
<span class="lineNum">     760 </span>            :     }
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :   } while (fVal &lt; rndmPtr-&gt;flat());</span>
<span class="lineNum">     762 </span>            :   return z;
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     765 </span>            : 
<span class="lineNum">     766 </span>            : //==========================================================================
<span class="lineNum">     767 </span>            : 
<span class="lineNum">     768 </span>            : // The StringPT class.
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     771 </span>            : 
<span class="lineNum">     772 </span>            : // Constants: could be changed here if desired, but normally should not.
<span class="lineNum">     773 </span>            : // These are of technical nature, as described for each.
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span>            : // To avoid division by zero one must have sigma &gt; 0.
<span class="lineNum">     776 </span>            : const double StringPT::SIGMAMIN     = 0.2;
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     779 </span>            : 
<a name="780"><span class="lineNum">     780 </span>            : // Initialize data members of the string pT selection.</a>
<span class="lineNum">     781 </span>            : 
<span class="lineNum">     782 </span>            : void StringPT::init(Settings&amp; settings,  ParticleData&amp; , Rndm* rndmPtrIn) {
<span class="lineNum">     783 </span>            : 
<span class="lineNum">     784 </span>            :   // Save pointer.
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :   rndmPtr        = rndmPtrIn;</span>
<span class="lineNum">     786 </span>            : 
<span class="lineNum">     787 </span>            :   // Parameters of the pT width and enhancement.
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :   double sigma     = settings.parm(&quot;StringPT:sigma&quot;);</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :   sigmaQ           = sigma / sqrt(2.);</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :   enhancedFraction = settings.parm(&quot;StringPT:enhancedFraction&quot;);</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :   enhancedWidth    = settings.parm(&quot;StringPT:enhancedWidth&quot;);</span>
<span class="lineNum">     792 </span>            : 
<span class="lineNum">     793 </span>            :   // Parameter for pT suppression in MiniStringFragmentation.
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :   sigma2Had        = 2. * pow2( max( SIGMAMIN, sigma) );</span>
<span class="lineNum">     795 </span>            : 
<span class="lineNum">     796 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     799 </span>            : 
<span class="lineNum">     800 </span>            : // Generate Gaussian pT such that &lt;p_x^2&gt; = &lt;p_x^2&gt; = sigma^2 = width^2/2,
<a name="801"><span class="lineNum">     801 </span>            : // but with small fraction multiplied up to a broader spectrum.</a>
<span class="lineNum">     802 </span>            : 
<span class="lineNum">     803 </span>            : pair&lt;double, double&gt; StringPT::pxy() {
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :   double sigma = sigmaQ;</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :   if (rndmPtr-&gt;flat() &lt; enhancedFraction) sigma *= enhancedWidth;</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :   pair&lt;double, double&gt; gauss2 = rndmPtr-&gt;gauss2();</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :   return pair&lt;double, double&gt;(sigma * gauss2.first, sigma * gauss2.second);</span>
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     811 </span>            : 
<span class="lineNum">     812 </span>            : //==========================================================================
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span>            : } // end namespace Pythia8
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
