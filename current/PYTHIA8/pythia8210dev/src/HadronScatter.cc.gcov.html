<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - PYTHIA8/pythia8210dev/src/HadronScatter.cc</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">PYTHIA8/pythia8210dev/src</a> - HadronScatter.cc<span style="font-size: 80%;"> (source / <a href="HadronScatter.cc.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">583</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">17</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // HadronScatter.cc is a part of the PYTHIA event generator.</a>
<span class="lineNum">       2 </span>            : // Copyright (C) 2015 Torbjorn Sjostrand.
<span class="lineNum">       3 </span>            : // PYTHIA is licenced under the GNU GPL version 2, see COPYING for details.
<span class="lineNum">       4 </span>            : // Please respect the MCnet Guidelines, see GUIDELINES for details.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : #include &quot;Pythia8/HadronScatter.h&quot;
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : namespace Pythia8 {
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : //==========================================================================
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : // The SigmaPartialWave class
<span class="lineNum">      13 </span>            : //  Reads in tables of partial wave data to provide dSigma/dCos(theta)
<span class="lineNum">      14 </span>            : //  The generic classes of process are:
<span class="lineNum">      15 </span>            : //    process = 0 (pi-pi), 1 (pi-K), 2 (pi-N)
<span class="lineNum">      16 </span>            : //  Subprocesses are defined (along with isospin coefficients) in:
<span class="lineNum">      17 </span>            : //    setupSubprocesses();
<span class="lineNum">      18 </span>            : //  Individual subprocesses are selected using:
<span class="lineNum">      19 </span>            : //    setSubprocess(subprocess); or setSubprocess(PDG1, PDG2);
<span class="lineNum">      20 </span>            : //  Internally, there are two std::map's, to convert between:
<span class="lineNum">      21 </span>            : //    subprocess &lt;==&gt; PDG1, PDG2
<span class="lineNum">      22 </span>            : //
<span class="lineNum">      23 </span>            : //  Data are read in from files:
<span class="lineNum">      24 </span>            : //   Lines starting with a '#' are comments
<span class="lineNum">      25 </span>            : //   Lines starting with 'set' provide options:
<span class="lineNum">      26 </span>            : //    set eType   [Wcm | Tlab] - energy bins in Wcm or Tlab
<span class="lineNum">      27 </span>            : //    set eUnit   [MeV | GeV]  - energy unit
<span class="lineNum">      28 </span>            : //    set input   [eta,delta | Sn,delta  | Tr,Ti | mod,phi ]
<span class="lineNum">      29 </span>            : //                             - format of columns in partial waves
<span class="lineNum">      30 </span>            : //    set dUnit   [deg | rad]  - unit of phase shifts
<span class="lineNum">      31 </span>            : //    set norm    [0 | 1]      - normalisation
<span class="lineNum">      32 </span>            : //   Column headers give L,2I[,2J] (2J for e.g. piN)
<span class="lineNum">      33 </span>            : //   Input types: Sn,delta -&gt; Sn = 1 - eta^2
<span class="lineNum">      34 </span>            : //                mod,phi  -&gt; amplitude T_L = |T_L| exp(i phi_L)
<span class="lineNum">      35 </span>            : //   Normalisation: 0 -&gt; dSigma/dOmega = 1 / k^2 |T_L|^2
<span class="lineNum">      36 </span>            : //                  1 -&gt; dSigma/dOmega = 16 / s  |T_L|^2
<span class="lineNum">      37 </span>            : //
<span class="lineNum">      38 </span>            : //  Internally data is stored as (J = 0 for spinless):
<span class="lineNum">      39 </span>            : //   pwData[L * LSHIFT + 2I * ISHIFT + J][energy_bin_centre] = T
<span class="lineNum">      40 </span>            : //  where the energy is Wcm in GeV.
<span class="lineNum">      41 </span>            : //
<span class="lineNum">      42 </span>            : //  This is stored using std::map's, to take into account that not all
<span class="lineNum">      43 </span>            : //  L,I,J states are always present (e.g. negligable contributions or
<span class="lineNum">      44 </span>            : //  conservation rules) and that bin sizes are not fixed.
<span class="lineNum">      45 </span>            : //
<span class="lineNum">      46 </span>            : //  Re[T] and Im[T] are interpolated between bins and extrapolated down to
<span class="lineNum">      47 </span>            : //  threshold from the first two bins. Above energy_bin_centre of the final
<span class="lineNum">      48 </span>            : //  bin, no extrapolation is done and the final bin value is always used.
<span class="lineNum">      49 </span>            : //
<span class="lineNum">      50 </span>            : //  A simple scheme to provide correct distributions for cos(theta) at a
<span class="lineNum">      51 </span>            : //  given CM energy is included. Efficiency is not too bad, but can likely
<span class="lineNum">      52 </span>            : //  be greatly improved.
<span class="lineNum">      53 </span>            : //
<span class="lineNum">      54 </span>            : //  For each subprocess, a grid in bins of Wcm and cos(theta) is setup with:
<span class="lineNum">      55 </span>            : //    setupGrid();
<span class="lineNum">      56 </span>            : //  The size of the grid is set by the constants:
<span class="lineNum">      57 </span>            : //    const double SigmaPartialWave::WCMBIN;
<span class="lineNum">      58 </span>            : //    const double SigmaPartialWave::CTBIN;
<span class="lineNum">      59 </span>            : //  For each bin of (Wcm, ct), the maximum sigma elastic is found by
<span class="lineNum">      60 </span>            : //  splitting this bin into subbins multiple times, controlled by:
<span class="lineNum">      61 </span>            : //    const int SigmaPartialWave::SUBBIN;
<span class="lineNum">      62 </span>            : //    const int SigmaPartialWave::ITER
<span class="lineNum">      63 </span>            : //  With the final maxium sigma elastic given by this value multipled by
<span class="lineNum">      64 </span>            : //  a safety factor:
<span class="lineNum">      65 </span>            : //    const double SigmaPartialWave::GRIDSAFETY
<span class="lineNum">      66 </span>            : //
<span class="lineNum">      67 </span>            : //  To pick values of cos(theta) for a given CM energy, a:
<span class="lineNum">      68 </span>            : //    pickCosTheta(Wcm);
<span class="lineNum">      69 </span>            : //  function is provided. The above grid is used as an overestimate, to
<span class="lineNum">      70 </span>            : //  pick properly distributed values of cos(theta).
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            : // Constants
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            : // pwData[L * LSHIFT + 2I * ISHIFT + J]
<span class="lineNum">      77 </span>            : const int     SigmaPartialWave::LSHIFT     = 1000000;
<span class="lineNum">      78 </span>            : const int     SigmaPartialWave::ISHIFT     = 1000;
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            : // Convert GeV^-2 to mb
<span class="lineNum">      81 </span>            : const double  SigmaPartialWave::CONVERT2MB = 0.389380;
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span>            : // Size of bin in Wcm and cos(theta)
<span class="lineNum">      84 </span>            : const double  SigmaPartialWave::WCMBIN     = 0.005;
<span class="lineNum">      85 </span>            : const double  SigmaPartialWave::CTBIN      = 0.2;
<span class="lineNum">      86 </span>            : // Number of subbins and iterations
<span class="lineNum">      87 </span>            : const int     SigmaPartialWave::SUBBIN     = 2;
<span class="lineNum">      88 </span>            : const int     SigmaPartialWave::ITER       = 2;
<span class="lineNum">      89 </span>            : // Safety value to add on to grid maxima
<span class="lineNum">      90 </span>            : const double  SigmaPartialWave::MASSSAFETY = 0.001;
<span class="lineNum">      91 </span>            : const double  SigmaPartialWave::GRIDSAFETY = 0.05;
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      95 </span>            : 
<a name="96"><span class="lineNum">      96 </span>            : // Perform initialization and store pointers.</a>
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            : bool SigmaPartialWave::init(int processIn, string xmlPath, string filename,
<span class="lineNum">      99 </span>            :                             Info *infoPtrIn, ParticleData *particleDataPtrIn,
<span class="lineNum">     100 </span>            :                             Rndm *rndmPtrIn) {
<span class="lineNum">     101 </span>            :   // Store incoming pointers
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :   infoPtr         = infoPtrIn;</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :   particleDataPtr = particleDataPtrIn;</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :   rndmPtr         = rndmPtrIn;</span>
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            :   // Check incoming process is okay
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :   if (processIn &lt; 0 || processIn &gt; 2) {</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :     infoPtr-&gt;errorMsg(&quot;Error in SigmaPartialWave::init: &quot;</span>
<span class="lineNum">     109 </span>            :       &quot;unknown process&quot;);
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     111 </span>            :   }
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :   process = processIn;</span>
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            :   // Setup subprocesses and isospin coefficients
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :   setupSubprocesses();</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :   setSubprocess(0);</span>
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span>            :   // Read in partial-wave data
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :   if (!readFile(xmlPath, filename)) return false;</span>
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            :   // Setup vector for Legendre polynomials
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :   PlVec.resize(Lmax);</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :   if (Lmax &gt; 0) PlVec[0] = 1.;</span>
<span class="lineNum">     124 </span>            :   // And derivatives if needed
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :   if (process == 2) {</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :     PlpVec.resize(Lmax);</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :     if (Lmax &gt; 0) PlpVec[0] = 0.;</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :     if (Lmax &gt; 1) PlpVec[1] = 1.;</span>
<span class="lineNum">     129 </span>            :   }
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span>            :   // Setup grid for integration
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :   setupGrid();</span>
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     139 </span>            : 
<a name="140"><span class="lineNum">     140 </span>            : // Read input data file</a>
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            : bool SigmaPartialWave::readFile(string xmlPath, string filename) {
<span class="lineNum">     143 </span>            :   // Create full path and open file
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :   string fullPath = xmlPath + filename;</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :   ifstream ifs(fullPath.c_str());</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :   if (!ifs.good()) {</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :     infoPtr-&gt;errorMsg(&quot;Error in SigmaPartialWave::init: &quot;</span>
<span class="lineNum">     148 </span>            :       &quot;could not read data file&quot;);
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     150 </span>            :   }
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            :   // Default unit settings
<span class="lineNum">     153 </span>            :   int eType = 0;  // 0 = Wcm, 1 = Tlab
<span class="lineNum">     154 </span>            :   int eUnit = 0;  // 0 = GeV, 1 = MeV
<span class="lineNum">     155 </span>            :   int input = 0;  // 0 = eta, delta; 1 = Sn, delta (Sn = 1 - eta^2);
<span class="lineNum">     156 </span>            :                   // 2 = Treal, Tim, 3 = mod, phi
<span class="lineNum">     157 </span>            :   int dUnit = 0;  // 0 = deg, 1 = rad
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :       norm  = 0;  // 0 = standard, 1 = sqrt(s) / sqrt(s - 4Mpi^2)</span>
<span class="lineNum">     159 </span>            : 
<span class="lineNum">     160 </span>            :   // Once we have a header line, each column corresponds to
<span class="lineNum">     161 </span>            :   // values of L, I and J.
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :   Lmax = Imax = 0;</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :   binMax = 0.;</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :   vector &lt; int &gt; Lvec, Ivec, Jvec;</span>
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            :   // Parse the file
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :   string line;</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :   while (ifs.good()) {</span>
<span class="lineNum">     169 </span>            :     // Get line, convert to lowercase and strip leading whitespace
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :     getline(ifs, line);</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :     for (unsigned int i = 0; i &lt; line.length(); i++)</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :       line[i] = tolower(line[i]);</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :     string::size_type startPos = line.find_first_not_of(&quot;  &quot;);</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :     if (startPos != string::npos) line = line.substr(startPos);</span>
<span class="lineNum">     175 </span>            :     // Skip blank lines and lines that start with '#'
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :     if (line.length() == 0 || line[0] == '#') continue;</span>
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            :     // Tokenise line on whitespace (spaces or tabs)
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :     string lineT = line;</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :     vector &lt; string &gt; token;</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :     while (true) {</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :       startPos = lineT.find_first_of(&quot;   &quot;);</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :       token.push_back(lineT.substr(0, startPos));</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :       if (startPos == string::npos) break;</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :       startPos = lineT.find_first_not_of(&quot;       &quot;, startPos + 1);</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :       if (startPos == string::npos) break;</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :       lineT = lineT.substr(startPos);</span>
<span class="lineNum">     188 </span>            :     }
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            :     // Settings
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :     if (token[0] == &quot;set&quot;) {</span>
<span class="lineNum">     192 </span>            :       bool badSetting = false;
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            :       // eType
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :       if        (token[1] == &quot;etype&quot;) {</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :         if      (token[2] == &quot;wcm&quot;)       eType = 0;</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :         else if (token[2] == &quot;tlab&quot;)      eType = 1;</span>
<span class="lineNum">     198 </span>            :         else    badSetting = true;
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span>            :       // eUnit
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :       } else if (token[1] == &quot;eunit&quot;) {</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :         if      (token[2] == &quot;gev&quot;)       eUnit = 0;</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :         else if (token[2] == &quot;mev&quot;)       eUnit = 1;</span>
<span class="lineNum">     204 </span>            :         else    badSetting = true;
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            :       // input
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :       } else if (token[1] == &quot;input&quot;) {</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :         if      (token[2] == &quot;eta,delta&quot;) input = 0;</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :         else if (token[2] == &quot;sn,delta&quot;)  input = 1;</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :         else if (token[2] == &quot;tr,ti&quot;)     input = 2;</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :         else if (token[2] == &quot;mod,phi&quot;)   input = 3;</span>
<span class="lineNum">     212 </span>            :         else    badSetting = true;
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            :       // dUnit
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :       } else if (token[1] == &quot;dunit&quot;) {</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :         if      (token[2] == &quot;deg&quot;)       dUnit = 0;</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :         else if (token[2] == &quot;rad&quot;)       dUnit = 1;</span>
<span class="lineNum">     218 </span>            :         else    badSetting = true;
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            :       // norm
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :       } else if (token[1] == &quot;norm&quot;) {</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :         if      (token[2] == &quot;0&quot;)         norm = 0;</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :         else if (token[2] == &quot;1&quot;)         norm = 1;</span>
<span class="lineNum">     224 </span>            :         else    badSetting = true;
<span class="lineNum">     225 </span>            :       }
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            :       // Bad setting
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :       if (badSetting) {</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :         infoPtr-&gt;errorMsg(&quot;Error in SigmaPartialWave::init: &quot;</span>
<span class="lineNum">     230 </span>            :           &quot;bad setting line&quot;);
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     232 </span>            :       }
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">     234 </span>            :     }
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            :     // Header line
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :     if (line.substr(0, 1).find_first_of(&quot;0123456789.&quot;) != 0) {</span>
<span class="lineNum">     238 </span>            :       // Clear current stored L,2I,2J values
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :       Lvec.clear(); Ivec.clear(); Jvec.clear();</span>
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span>            :       // Parse header
<span class="lineNum">     242 </span>            :       bool badHeader = false;
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :       for (unsigned int i = 1; i &lt; token.size(); i++) {</span>
<span class="lineNum">     244 </span>            :         // Extract L
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :         startPos = token[i].find_first_of(&quot;,&quot;);</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :         if (startPos == string::npos) { badHeader = true; break; }</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :         string Lstr = token[i].substr(0, startPos);</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :         token[i] = token[i].substr(startPos + 1);</span>
<span class="lineNum">     249 </span>            :         // Extract 2I
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :         string Istr;</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :         startPos = token[i].find_first_of(&quot;,     &quot;);</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :         if (startPos == string::npos) {</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :           Istr = token[i];</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :           token[i] = &quot;&quot;;</span>
<span class="lineNum">     255 </span>            :         } else {
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :           Istr = token[i].substr(0, startPos);</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :           token[i] = token[i].substr(startPos + 1);</span>
<span class="lineNum">     258 </span>            :         }
<span class="lineNum">     259 </span>            :         // Extract 2J
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :         string Jstr(&quot;0&quot;);</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :         if (token[i].length() != 0) Jstr = token[i];</span>
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            :         // Convert to integers and store
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :         int L, I, J;</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :         stringstream Lss(Lstr); Lss &gt;&gt; L;</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :         stringstream Iss(Istr); Iss &gt;&gt; I;</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :         stringstream Jss(Jstr); Jss &gt;&gt; J;</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :         if (Lss.fail() || Iss.fail() || Jss.fail())</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :           { badHeader = true; break; }</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :         Lvec.push_back(L);</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :         Ivec.push_back(I);</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :         Jvec.push_back(J);</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :         Lmax = max(Lmax, L);</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :         Imax = max(Imax, I);</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :       if (badHeader) {</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :         infoPtr-&gt;errorMsg(&quot;Error in SigmaPartialWave::init: &quot;</span>
<span class="lineNum">     278 </span>            :           &quot;malformed header line&quot;);
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     280 </span>            :       }
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span>            :     // Data line
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">     284 </span>            :       bool badData = false;
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            :       // Check there are the correct number of columns
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :       if (token.size() != 2 * Lvec.size() + 1) badData = true;</span>
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            :       // Extract energy
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :       double eNow = 0.;</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :       if (!badData) {</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :         stringstream eSS(token[0]);</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :         eSS &gt;&gt; eNow;</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :         if (eSS.fail()) badData = true;</span>
<span class="lineNum">     295 </span>            :         // Convert to GeV if needed
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :         if (eUnit == 1) eNow *= 1e-3;</span>
<span class="lineNum">     297 </span>            :         // Convert to Wcm if needed
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :         if (eType == 1) eNow = sqrt(2. * mB * eNow + pow2(mA + mB));</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :         binMax = max(binMax, eNow);</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span>            :       // Extract eta/phase shifts
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :       if (!badData) {</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :         for (unsigned int i = 1; i &lt; token.size(); i += 2) {</span>
<span class="lineNum">     305 </span>            :           // L,2I,2J
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :           int LIJidx = (i - 1) / 2;</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :           int L = Lvec[LIJidx];</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :           int I = Ivec[LIJidx];</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :           int J = Jvec[LIJidx];</span>
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :           double i1, i2;</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :           stringstream i1SS(token[i]);     i1SS &gt;&gt; i1;</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :           stringstream i2SS(token[i + 1]); i2SS &gt;&gt; i2;</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :           if (i1SS.fail() || i2SS.fail()) { badData = true; break; }</span>
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span>            :           // Sn to eta
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :           if (input == 1) i1 = sqrt(1. - i1);</span>
<span class="lineNum">     318 </span>            :           // Degrees to radians
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :           if ((input == 0 || input == 1 || input == 3) &amp;&amp;</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :               dUnit == 0) i2 *= M_PI / 180.;</span>
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            :           // Convert to Treal and Timg
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :           complex T(0., 0.);</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :           if (input == 0 || input == 1) {</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :             T = (i1 * exp(2. * complex(0., 1.) * i2) - 1.) /</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :                 2. / complex(0., 1.);</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :           } else if (input == 2) {</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :             T = complex(i1, i2);</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :           } else if (input == 3) {</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :             T = i1 * exp(complex(0., 1.) * i2);</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span>            :           // Store
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :           pwData[L * LSHIFT + I * ISHIFT + J][eNow] = T;</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :       if (badData) {</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :         infoPtr-&gt;errorMsg(&quot;Error in SigmaPartialWave::init: &quot;</span>
<span class="lineNum">     339 </span>            :           &quot;malformed data line&quot;);
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     341 </span>            :       }
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            :   // Make sure it was EOF that caused us to end
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :   if (!ifs.eof()) { ifs.close(); return false; }</span>
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span>            :   // Maximum values of L and I
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :   Lmax++; Imax++;</span>
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     356 </span>            : 
<a name="357"><span class="lineNum">     357 </span>            : // Setup isospin coefficients and subprocess mapping</a>
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span>            : void SigmaPartialWave::setupSubprocesses() {
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            :   // Setup isospin coefficients
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :   switch (process) {</span>
<span class="lineNum">     363 </span>            :   // pi-pi
<span class="lineNum">     364 </span>            :   case 0:
<span class="lineNum">     365 </span>            :     // Map subprocess to incoming
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :     subprocessMax = 6;</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :     sp2in[0] = pair &lt; int, int &gt; ( 211,  211);</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :     sp2in[1] = pair &lt; int, int &gt; ( 211, -211);</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :     sp2in[2] = pair &lt; int, int &gt; ( 211,  111);</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :     sp2in[3] = pair &lt; int, int &gt; ( 111,  111);</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :     sp2in[4] = pair &lt; int, int &gt; (-211,  111);</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :     sp2in[5] = pair &lt; int, int &gt; (-211, -211);</span>
<span class="lineNum">     373 </span>            :     // Incoming to subprocess
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; subprocessMax; i++) in2sp[sp2in[i]] = i;</span>
<span class="lineNum">     375 </span>            :     // Isospin coefficients
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :     isoCoeff[0][0] = 0.;    isoCoeff[0][2] = 0.;    isoCoeff[0][4] = 1.;</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :     isoCoeff[1][0] = 1./3.; isoCoeff[1][2] = 1./2.; isoCoeff[1][4] = 1./6.;</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :     isoCoeff[2][0] = 0.;    isoCoeff[2][2] = 1./2.; isoCoeff[2][4] = 1./2.;</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :     isoCoeff[3][0] = 1./3.; isoCoeff[3][2] = 0.;    isoCoeff[3][4] = 2./3.;</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :     isoCoeff[4][0] = 0.;    isoCoeff[4][2] = 1./2.; isoCoeff[4][4] = 1./2.;</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :     isoCoeff[5][0] = 0.;    isoCoeff[5][2] = 0.;    isoCoeff[5][4] = 1.;</span>
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            :   // pi-K and pi-N
<span class="lineNum">     386 </span>            :   case 1: case 2:
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :     int id1, id2;</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :     if (process == 1) { id1 = 321;  id2 = 311;  }</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :     else              { id1 = 2212; id2 = 2112; }</span>
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span>            :     // Map subprocess to incoming
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :     subprocessMax = 12;</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :     sp2in[0] = pair &lt; int, int &gt; ( 211, id1);</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :     sp2in[1] = pair &lt; int, int &gt; ( 211, id2);</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :     sp2in[2] = pair &lt; int, int &gt; ( 111, id1);</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :     sp2in[3] = pair &lt; int, int &gt; ( 111, id2);</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :     sp2in[4] = pair &lt; int, int &gt; (-211, id1);</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :     sp2in[5] = pair &lt; int, int &gt; (-211, id2);</span>
<span class="lineNum">     399 </span>            :     // Isospin coefficients
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :     isoCoeff[0][1]  = 0.;      isoCoeff[0][3]  = 1.;</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :     isoCoeff[1][1]  = 2. / 3.; isoCoeff[1][3]  = 1. / 3.;</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :     isoCoeff[2][1]  = 1. / 3.; isoCoeff[2][3]  = 2. / 3.;</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :     isoCoeff[3][1]  = 1. / 3.; isoCoeff[3][3]  = 2. / 3.;</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :     isoCoeff[4][1]  = 2. / 3.; isoCoeff[4][3]  = 1. / 3.;</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :     isoCoeff[5][1]  = 0.;      isoCoeff[5][3]  = 1.;</span>
<span class="lineNum">     406 </span>            :     // Antiparticles
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; 6; i++) {</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :       id1 = ((sp2in[i].first == 111) ? +1 : -1) * sp2in[i].first;</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :       sp2in[i + 6] = pair &lt; int, int &gt; (id1, -sp2in[i].second);</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :       isoCoeff[i + 6] = isoCoeff[i];</span>
<span class="lineNum">     411 </span>            :     }
<span class="lineNum">     412 </span>            :     // Map incoming to subprocess
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; subprocessMax; i++) in2sp[sp2in[i]] = i;</span>
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            :     break;
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :   return;</span>
<span class="lineNum">     419 </span>            : }
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     423 </span>            : 
<a name="424"><span class="lineNum">     424 </span>            : // Setup grids for integration</a>
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span>            : void SigmaPartialWave::setupGrid() {
<span class="lineNum">     427 </span>            :   // Reset sigma maximum
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :   sigElMax = 0.;</span>
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            :   // Go through each subprocess
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :   gridMax.resize(subprocessMax);</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :   gridNorm.resize(subprocessMax);</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :   for (int sp = 0; sp &lt; subprocessMax; sp++) {</span>
<span class="lineNum">     434 </span>            :     // Setup subprocess
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :     setSubprocess(sp);</span>
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span>            :     // Bins in Wcm
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :     int nBin1 = int( (binMax - mA - mB) / WCMBIN );</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :     gridMax[subprocess].resize(nBin1);</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :     gridNorm[subprocess].resize(nBin1);</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :     for (int n1 = 0; n1 &lt; nBin1; n1++) {</span>
<span class="lineNum">     442 </span>            :       // Bin lower and upper
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :       double bl1 = mA + mB + double(n1) * WCMBIN;</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :       double bu1 = bl1 + WCMBIN;</span>
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            :       // Bins in cos(theta)
<span class="lineNum">     447 </span>            :       int    nBin2 = int( 2. / CTBIN );
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :       gridMax[subprocess][n1].resize(nBin2);</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :       for (int n2 = 0; n2 &lt; nBin2; n2++) {</span>
<span class="lineNum">     450 </span>            :         // Bin lower and upper
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :         double bl2 = -1. + double(n2) * CTBIN;</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :         double bu2 = bl2 + CTBIN;</span>
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            :         // Find maximum
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :         double maxSig = 0.;</span>
<span class="lineNum">     456 </span>            :         double bl3 = bl1, bu3 = bu1, bl4 = bl2, bu4 = bu2;
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :         for (int iter = 0; iter &lt; ITER; iter++) {</span>
<span class="lineNum">     458 </span>            :           int    i3Save = -1, i4Save = -1;
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :           double step3 = (bu3 - bl3) / double(SUBBIN);</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :           double step4 = (bu4 - bl4) / double(SUBBIN);</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :           for (int i3 = 0; i3 &lt;= SUBBIN; i3++) {</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :             double Wcm = bl3 + double(i3) * step3;</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :             for (int i4 = 0; i4 &lt;= SUBBIN; i4++) {</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :               double ct = bl4 + double(i4) * step4;</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :               double ds = dSigma(Wcm, ct);</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :               if (ds &gt; maxSig) {</span>
<span class="lineNum">     467 </span>            :                 i3Save = i3;
<span class="lineNum">     468 </span>            :                 i4Save = i4;
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :                 maxSig = ds;</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :               }</span>
<span class="lineNum">     471 </span>            :             }
<span class="lineNum">     472 </span>            :           }
<span class="lineNum">     473 </span>            :           // Set new min/max
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :           if (i3Save == -1 &amp;&amp; i4Save == -1) break;</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :           if (i3Save &gt; -1) {</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :             bl3 = bl3 + ((i3Save == 0)      ? 0. : i3Save - 1.) * step3;</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :             bu3 = bl3 + ((i3Save == SUBBIN) ? 1. : 2.)          * step3;</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :           if (i4Save &gt; -1) {</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :             bl4 = bl4 + ((i4Save == 0)      ? 0. : i4Save - 1.) * step4;</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :             bu4 = bl4 + ((i4Save == SUBBIN) ? 1. : 2.)          * step4;</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :         } // for (iter)</span>
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span>            :         // Save maximum value
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :         gridMax[subprocess][n1][n2]  = maxSig * (1. + GRIDSAFETY);</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :         gridNorm[subprocess][n1]    += maxSig * (1. + GRIDSAFETY) * CTBIN;</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :         sigElMax = max(sigElMax, maxSig);</span>
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :       } // for (n2)</span>
<span class="lineNum">     491 </span>            :     } // for (n1)
<span class="lineNum">     492 </span>            :   } // for (sp)
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :   return;</span>
<span class="lineNum">     495 </span>            : }
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     499 </span>            : 
<a name="500"><span class="lineNum">     500 </span>            : // Pick a cos(theta) value</a>
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span>            : double SigmaPartialWave::pickCosTheta(double Wcm) {
<span class="lineNum">     503 </span>            :   // Find grid bin in Wcm
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :   int WcmBin = int((Wcm - mA - mB) / WCMBIN);</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :   if (WcmBin &lt; 0) WcmBin = 0;</span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :   if (WcmBin &gt;= int(gridMax[subprocess].size()))</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :     WcmBin = int(gridMax[subprocess].size() - 1);</span>
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span>            :   // Pick a value of cos(theta)
<span class="lineNum">     510 </span>            :   double ct, wgt;
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :   do {</span>
<span class="lineNum">     513 </span>            :     // Sample from overestimate and inverse
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :     double y   = rndmPtr-&gt;flat() * gridNorm[subprocess][WcmBin];</span>
<span class="lineNum">     515 </span>            :     double sum = 0.;
<span class="lineNum">     516 </span>            :     int    ctBin;
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :     for (ctBin = 0; ctBin &lt; int(2. / CTBIN); ctBin++) {</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :       if (sum + CTBIN * gridMax[subprocess][WcmBin][ctBin] &gt; y) break;</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :       sum += CTBIN * gridMax[subprocess][WcmBin][ctBin];</span>
<span class="lineNum">     520 </span>            :     }
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span>            :     // Linear interpolation
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :     double x1 = -1. + CTBIN * double(ctBin);</span>
<span class="lineNum">     524 </span>            :     double y1 = sum;
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :     double x2 = x1 + CTBIN;</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :     double y2 = sum + CTBIN * gridMax[subprocess][WcmBin][ctBin];</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :            ct = (x2 - x1) / (y2 - y1) * (y - y1) + x1;</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :     wgt = dSigma(Wcm, ct) / gridMax[subprocess][WcmBin][ctBin];</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :     if (wgt &gt;= 1.) {</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :       infoPtr-&gt;errorMsg(&quot;Warning in SigmaPartialWave::pickCosTheta: &quot;</span>
<span class="lineNum">     531 </span>            :         &quot;weight above unity&quot;);
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     533 </span>            :     }
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :   } while (wgt &lt;= rndmPtr-&gt;flat());</span>
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :   return ct;</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     540 </span>            : 
<a name="541"><span class="lineNum">     541 </span>            : // Set subprocess</a>
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span>            : bool SigmaPartialWave::setSubprocess(int spIn) {
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :   if (sp2in.find(spIn) == sp2in.end()) return false;</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :   subprocess = spIn;</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :   pair &lt; int, int &gt; in = sp2in[spIn];</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :   idA = in.first;</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :   mA  = particleDataPtr-&gt;m0(idA);</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :   idB = in.second;</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :   mB  = particleDataPtr-&gt;m0(idB);</span>
<span class="lineNum">     551 </span>            :   return true;
<a name="552"><span class="lineNum">     552 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span>            : bool SigmaPartialWave::setSubprocess(int idAin, int idBin) {
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :   pair &lt; int, int &gt; in = pair &lt; int, int &gt; (idAin, idBin);</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :   if (in2sp.find(in) == in2sp.end()) {</span>
<span class="lineNum">     557 </span>            :     // Try the other way around as well
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :     swap(in.first, in.second);</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :     if (in2sp.find(in) == in2sp.end()) return false;</span>
<span class="lineNum">     560 </span>            :   }
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :   subprocess = in2sp[in];</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :   idA = idAin;</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :   mA  = particleDataPtr-&gt;m0(idA);</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :   idB = idBin;</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :   mB  = particleDataPtr-&gt;m0(idB);</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     570 </span>            : 
<a name="571"><span class="lineNum">     571 </span>            : // Calculate: mode = 0 (sigma elastic), 1 (sigma total), 2 (dSigma/dcTheta)</a>
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span>            : double SigmaPartialWave::sigma(int mode, double Wcm, double cTheta) {
<span class="lineNum">     574 </span>            :   // Below threshold, return 0
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :   if (Wcm &lt; (mA + mB + MASSSAFETY)) return 0.;</span>
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span>            :   // Return values
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :   complex amp[2] = { complex(0., 0.) };</span>
<span class="lineNum">     579 </span>            :   double  sig    = 0.;
<span class="lineNum">     580 </span>            : 
<span class="lineNum">     581 </span>            :   // Kinematic variables
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :   double s  = pow2(Wcm);</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :   double k2 = (s - pow2(mB + mA)) * (s - pow2(mB - mA)) / 4. / s;</span>
<span class="lineNum">     584 </span>            : 
<span class="lineNum">     585 </span>            :   // Precompute all required Pl and Pl' values
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :   double sTheta = 0.;</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :   if (mode == 2) {</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :     if (process == 2) sTheta = sqrt(1. - pow2(cTheta));</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :     legendreP(cTheta, ((process == 2) ? true : false));</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     591 </span>            : 
<span class="lineNum">     592 </span>            :   // Loop over L
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :   for (int L = 0; L &lt; Lmax; L++) {</span>
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span>            :     // Loop over J (only J = 0 for spinless)
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :     complex ampJ[2] = { complex(0., 0.) };</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :     int Jstart = (process != 2) ? 0 : 2 * L - 1;</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :     int Jend   = (process != 2) ? 1 : 2 * L + 2;</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :     int Jstep  = (process != 2) ? 1 : 2;</span>
<span class="lineNum">     600 </span>            :     int Jcount = 0;
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :     for (int J = Jstart; J &lt; Jend; J += Jstep, Jcount++) {</span>
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span>            :       // Loop over isospin coefficients
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :       for (int I = 0; I &lt; Imax; I++) {</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :         if (isoCoeff[subprocess][I] == 0.) continue;</span>
<span class="lineNum">     606 </span>            : 
<span class="lineNum">     607 </span>            :         // Check wave exists
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :         int LIJ = L * LSHIFT + I * ISHIFT + J;</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :         if (pwData.find(LIJ) == pwData.end()) continue;</span>
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span>            :         // Extrapolation / interpolation (not for last bin)
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :         map &lt; double, complex &gt;::iterator it = pwData[LIJ].upper_bound(Wcm);</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :         if (it == pwData[LIJ].begin()) ++it;</span>
<span class="lineNum">     614 </span>            :         double ar, ai;
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :         if (it == pwData[LIJ].end()) {</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :           ar = (--it)-&gt;second.real();</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :           ai = it-&gt;second.imag();</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :           double  eA   = it-&gt;first;</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :           complex ampA = (it--)-&gt;second;</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :           double  eB   = it-&gt;first;</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :           complex ampB = it-&gt;second;</span>
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :           ar = (ampA.real() - ampB.real()) / (eA - eB) *</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :                (Wcm - eB) + ampB.real();</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :           ai = (ampA.imag() - ampB.imag()) / (eA - eB) *</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :                (Wcm - eB) + ampB.imag();</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span>            :         // Isospin sum
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :         ampJ[Jcount] += isoCoeff[subprocess][I] * complex(ar, ai);</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     633 </span>            :     }
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span>            :     // Partial wave sum. Sigma elastic
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :     if (mode == 0) {</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :       if        (process == 0 || process == 1) {</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :         sig += (2. * L + 1.) * (ampJ[0] * conj(ampJ[0])).real();</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :       } else if (process == 2) {</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :         sig += ( (L + 0.) * (ampJ[0] * conj(ampJ[0])).real() +</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :                  (L + 1.) * (ampJ[1] * conj(ampJ[1])).real() );</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     643 </span>            : 
<span class="lineNum">     644 </span>            :     // Sigma total
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :     } else if (mode == 1) {</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :       if        (process == 0 || process == 1) {</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :         sig += (2. * L + 1.) * ampJ[0].imag();</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :       } else if (process == 2) {</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :         sig += ( (L + 0.) * ampJ[0].imag() + (L + 1.) * ampJ[1].imag() );</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span>            :     // dSigma
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :     } else if (mode == 2) {</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :       if        (process == 0 || process == 1) {</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :         amp[0] += (2. * L + 1.) * ampJ[0] * PlVec[L];</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :       } else if (process == 2) {</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :         amp[0] += ((L + 0.) * ampJ[0] + double(L + 1.) * ampJ[1]) * PlVec[L];</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :         amp[1] += complex(0., 1.) * (ampJ[1] - ampJ[0]) * sTheta * PlpVec[L];</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     660 </span>            :     }
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :   } // for (L)</span>
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span>            :   // Normalisation and return
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :   if (mode == 0 || mode == 1) {</span>
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :     if      (norm == 0)  sig *= 4.  * M_PI / k2 * CONVERT2MB;</span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :     else if (norm == 1)  sig *= 64. * M_PI / s  * CONVERT2MB;</span>
<span class="lineNum">     668 </span>            : 
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :   } else if (mode == 2) {</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :     sig = (amp[0] * conj(amp[0])).real() + (amp[1] * conj(amp[1])).real();</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :     if      (norm == 0) sig *= 2.  * M_PI / k2 * CONVERT2MB;</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :     else if (norm == 1) sig *= 32. * M_PI / s  * CONVERT2MB;</span>
<span class="lineNum">     673 </span>            :   }
<span class="lineNum">     674 </span>            :   // Half for identical
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :   return ((idA == idB) ? 0.5 : 1.) * sig;</span>
<span class="lineNum">     676 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span>            : 
<span class="lineNum">     679 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     680 </span>            : 
<a name="681"><span class="lineNum">     681 </span>            : // Bonnet's recursion formula for Legendre polynomials and derivatives</a>
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span>            : void SigmaPartialWave::legendreP(double ct, bool deriv) {
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :   if (Lmax &gt; 1) PlVec[1] = ct;</span>
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :   for (int L = 2; L &lt; Lmax; L++) {</span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :     PlVec[L] = ( (2. * L - 1.) * ct * PlVec[L - 1] -</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :                  (L - 1.) * PlVec[L - 2] ) / double(L);</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :     if (deriv)</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :       PlpVec[L] = ( (2. * L - 1.) * (PlVec[L - 1] + ct * PlpVec[L - 1]) -</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :                     (L - 1.) * PlpVec[L - 2] ) / double(L);</span>
<span class="lineNum">     691 </span>            :   }
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :   return;</span>
<span class="lineNum">     693 </span>            : }
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span>            : 
<span class="lineNum">     696 </span>            : //==========================================================================
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span>            : // HadronScatter class
<span class="lineNum">     699 </span>            : 
<span class="lineNum">     700 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     701 </span>            : 
<a name="702"><span class="lineNum">     702 </span>            : // Perform initialization and store pointers.</a>
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span>            : bool HadronScatter::init(Info* infoPtrIn, Settings&amp; settings,
<span class="lineNum">     705 </span>            :                          Rndm *rndmPtrIn, ParticleData *particleDataPtr) {
<span class="lineNum">     706 </span>            :   // Save incoming pointers
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :   infoPtr = infoPtrIn;</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :   rndmPtr = rndmPtrIn;</span>
<span class="lineNum">     709 </span>            : 
<span class="lineNum">     710 </span>            :   // Main settings
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :   doHadronScatter = settings.flag(&quot;HadronScatter:scatter&quot;);</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :   afterDecay      = settings.flag(&quot;HadronScatter:afterDecay&quot;);</span>
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :   allowDecayProd  = settings.flag(&quot;HadronScatter:allowDecayProd&quot;);</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :   scatterRepeat   = settings.flag(&quot;HadronScatter:scatterRepeat&quot;);</span>
<span class="lineNum">     715 </span>            :   // Hadron selection
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :   hadronSelect    = settings.mode(&quot;HadronScatter:hadronSelect&quot;);</span>
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :   Npar            = settings.parm(&quot;HadronScatter:N&quot;);</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :   kPar            = settings.parm(&quot;HadronScatter:k&quot;);</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :   pPar            = settings.parm(&quot;HadronScatter:p&quot;);</span>
<span class="lineNum">     720 </span>            :   // Scattering probability
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :   scatterProb     = settings.mode(&quot;HadronScatter:scatterProb&quot;);</span>
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :   jPar            = settings.parm(&quot;HadronScatter:j&quot;);</span>
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :   rMax            = settings.parm(&quot;HadronScatter:rMax&quot;);</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :   rMax2           = rMax * rMax;</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :   doTile          = settings.flag(&quot;HadronScatter:tile&quot;);</span>
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span>            :   // String fragmentation and MPI settings
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :   pTsigma         = 2.0 * settings.parm(&quot;StringPT:sigma&quot;);</span>
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :   pTsigma2        = pTsigma * pTsigma;</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :   double pT0ref   = settings.parm(&quot;MultipartonInteractions:pT0ref&quot;);</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :   double eCMref   = settings.parm(&quot;MultipartonInteractions:eCMref&quot;);</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :   double eCMpow   = settings.parm(&quot;MultipartonInteractions:eCMpow&quot;);</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :   double eCMnow   = infoPtr-&gt;eCM();</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :   pT0MPI          = pT0ref * pow(eCMnow / eCMref, eCMpow);</span>
<span class="lineNum">     735 </span>            : 
<span class="lineNum">     736 </span>            :   // Tiling
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :   double mp2 = particleDataPtr-&gt;m0(111) * particleDataPtr-&gt;m0(111);</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :   double eA  = infoPtr-&gt;eA();</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :   double eB  = infoPtr-&gt;eB();</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :   double pzA =  sqrt(eA * eA - mp2);</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :   double pzB = -sqrt(eB * eB - mp2);</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :   yMax = 0.5 * log((eA + pzA) / (eA - pzA));</span>
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :   yMin = 0.5 * log((eB + pzB) / (eB - pzB));</span>
<span class="lineNum">     744 </span>            :   // Size in y and phi
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :   if (doTile) {</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :     ytMax  = int((yMax - yMin) / rMax);</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :     ytSize = (yMax - yMin) / double(ytMax);</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :     ptMax  = int(2. * M_PI / rMax);</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :     ptSize = 2. * M_PI / double(ptMax);</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :     ytMax  = 1;</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :     ytSize = yMax - yMin;</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :     ptMax  = 1;</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :     ptSize = 2. * M_PI;</span>
<span class="lineNum">     755 </span>            :   }
<span class="lineNum">     756 </span>            :   // Initialise tiles
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :   tile.resize(ytMax);</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :   for (int yt = 0; yt &lt; ytMax; yt++) tile[yt].resize(ptMax);</span>
<span class="lineNum">     759 </span>            : 
<span class="lineNum">     760 </span>            :   // Find path to data files, i.e. xmldoc directory location.
<span class="lineNum">     761 </span>            :   // Environment variable takes precedence, else use constructor input.
<span class="lineNum">     762 </span>            :   // XXX - as in Pythia.cc, but not passed around in e.g. Info/Settings,
<span class="lineNum">     763 </span>            :   //       so redo here
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :   string xmlPath = &quot;&quot;;</span>
<span class="lineNum">     765 </span>            :   const char* PYTHIA8DATA = &quot;PYTHIA8DATA&quot;;
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :   char* envPath = getenv(PYTHIA8DATA);</span>
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :   if (envPath != 0 &amp;&amp; *envPath != '\0') {</span>
<span class="lineNum">     768 </span>            :     int i = 0;
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :     while (*(envPath+i) != '\0') xmlPath += *(envPath+(i++));</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :   } else xmlPath = &quot;../xmldoc&quot;;</span>
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :   if (xmlPath[ xmlPath.length() - 1 ] != '/') xmlPath += &quot;/&quot;;</span>
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span>            :   // Hadron scattering partial wave cross sections
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :   if ( !sigmaPW[0].init(0, xmlPath, &quot;pipi-Froggatt.dat&quot;,</span>
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :                         infoPtr, particleDataPtr, rndmPtr) ) return false;</span>
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :   if ( !sigmaPW[1].init(1, xmlPath, &quot;piK-Estabrooks.dat&quot;,</span>
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :                         infoPtr, particleDataPtr, rndmPtr) ) return false;</span>
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :   if ( !sigmaPW[2].init(2, xmlPath, &quot;piN-SAID-WI08.dat&quot;,</span>
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :                         infoPtr, particleDataPtr, rndmPtr) ) return false;</span>
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :   sigElMax = 0.;</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :   sigElMax = max(sigElMax, sigmaPW[0].getSigmaElMax());</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :   sigElMax = max(sigElMax, sigmaPW[1].getSigmaElMax());</span>
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :   sigElMax = max(sigElMax, sigmaPW[2].getSigmaElMax());</span>
<span class="lineNum">     784 </span>            : 
<span class="lineNum">     785 </span>            :   // DEBUG
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :   debugOutput();</span>
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     793 </span>            : 
<a name="794"><span class="lineNum">     794 </span>            : // Debug output</a>
<span class="lineNum">     795 </span>            : 
<span class="lineNum">     796 </span>            : void HadronScatter::debugOutput() {
<span class="lineNum">     797 </span>            :   // Print settings
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :   cout &lt;&lt; &quot;Hadron scattering:&quot; &lt;&lt; endl</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :        &lt;&lt; &quot; scatter        = &quot; &lt;&lt; ((doHadronScatter) ? &quot;on&quot; : &quot;off&quot;) &lt;&lt; endl</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :        &lt;&lt; &quot; afterDecay     = &quot; &lt;&lt; ((afterDecay)      ? &quot;on&quot; : &quot;off&quot;) &lt;&lt; endl</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :        &lt;&lt; &quot; allowDecayProd = &quot; &lt;&lt; ((allowDecayProd)  ? &quot;on&quot; : &quot;off&quot;) &lt;&lt; endl</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :        &lt;&lt; &quot; scatterRepeat  = &quot; &lt;&lt; ((scatterRepeat)   ? &quot;on&quot; : &quot;off&quot;) &lt;&lt; endl</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :        &lt;&lt; &quot; tile           = &quot; &lt;&lt; ((doTile) ? &quot;on&quot; : &quot;off&quot;) &lt;&lt; endl</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :        &lt;&lt; &quot;  yMin          = &quot; &lt;&lt; yMin &lt;&lt; endl</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :        &lt;&lt; &quot;  yMax          = &quot; &lt;&lt; yMax &lt;&lt; endl</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :        &lt;&lt; &quot;  ytMax         = &quot; &lt;&lt; ytMax &lt;&lt; endl</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :        &lt;&lt; &quot;  ytSize        = &quot; &lt;&lt; ytSize &lt;&lt; endl</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :        &lt;&lt; &quot;  ptMax         = &quot; &lt;&lt; ptMax &lt;&lt; endl</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :        &lt;&lt; &quot;  ptSize        = &quot; &lt;&lt; ptSize &lt;&lt; endl</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :        &lt;&lt; endl</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :        &lt;&lt; &quot; hadronSelect   = &quot; &lt;&lt; hadronSelect &lt;&lt; endl</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :        &lt;&lt; &quot;  N             = &quot; &lt;&lt; Npar &lt;&lt; endl</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :        &lt;&lt; &quot;  k             = &quot; &lt;&lt; kPar &lt;&lt; endl</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :        &lt;&lt; &quot;  p             = &quot; &lt;&lt; pPar &lt;&lt; endl</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :        &lt;&lt; endl</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :        &lt;&lt; &quot; scatterProb    = &quot; &lt;&lt; scatterProb &lt;&lt; endl</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :        &lt;&lt; &quot;  j             = &quot; &lt;&lt; jPar &lt;&lt; endl</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :        &lt;&lt; &quot;  rMax          = &quot; &lt;&lt; rMax &lt;&lt; endl</span>
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :        &lt;&lt; endl</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :        &lt;&lt; &quot; pTsigma        = &quot; &lt;&lt; pTsigma2 &lt;&lt; endl</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :        &lt;&lt; &quot; pT0MPI         = &quot; &lt;&lt; pT0MPI &lt;&lt; endl</span>
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :        &lt;&lt; endl</span>
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :        &lt;&lt; &quot; sigElMax       = &quot; &lt;&lt; sigElMax &lt;&lt; endl &lt;&lt; endl;</span>
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :   return;</span>
<span class="lineNum">     826 </span>            : }
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span>            : 
<span class="lineNum">     829 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     830 </span>            : 
<a name="831"><span class="lineNum">     831 </span>            : // Perform hadron scattering</a>
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span>            : void HadronScatter::scatter(Event&amp; event) {
<span class="lineNum">     834 </span>            :   // Reset tiles
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :   for (int yt = 0; yt &lt; ytMax; yt++)</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :     for (int pt = 0; pt &lt; ptMax; pt++)</span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :       tile[yt][pt].clear();</span>
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span>            :   // Generate list of hadrons which can take part in the scattering
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; event.size(); i++)</span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :     if (event[i].isFinal() &amp;&amp; event[i].isHadron() &amp;&amp; canScatter(event, i))</span>
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :       tile[yTile(event, i)][pTile(event, i)].insert(HSIndex(i, i));</span>
<span class="lineNum">     843 </span>            : 
<span class="lineNum">     844 </span>            :   // Generate all pairwise interaction probabilities
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :   vector &lt; HadronScatterPair &gt; scatterList;</span>
<span class="lineNum">     846 </span>            :   // For each tile and for each hadron in the tile do pairing
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :   for (int pt1 = 0; pt1 &lt; ptMax; pt1++)</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :     for (int yt1 = 0; yt1 &lt; ytMax; yt1++)</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :       for (set &lt; HSIndex &gt;::iterator si1 = tile[yt1][pt1].begin();</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :            si1 != tile[yt1][pt1].end(); si1++)</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :         tileIntProb(scatterList, event, *si1, yt1, pt1, false);</span>
<span class="lineNum">     852 </span>            :   // Sort by ordering measure (largest to smallest)
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :   sort(scatterList.rbegin(), scatterList.rend());</span>
<span class="lineNum">     854 </span>            : 
<span class="lineNum">     855 </span>            :   // Reset list of things that have scattered
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :   if (scatterRepeat) scattered.clear();</span>
<span class="lineNum">     857 </span>            : 
<span class="lineNum">     858 </span>            :   // Do scatterings
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :   while (scatterList.size() &gt; 0) {</span>
<span class="lineNum">     860 </span>            :     // Check still valid and scatter
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :     HadronScatterPair &amp;hsp = scatterList[0];</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :     if (!event[hsp.i1.second].isFinal() || !event[hsp.i2.second].isFinal()) {</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :       scatterList.erase(scatterList.begin());</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">     865 </span>            :     }
<span class="lineNum">     866 </span>            :     // Remove old entries in tiles and scatter
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :     tile[hsp.yt1][hsp.pt1].erase(hsp.i1);</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :     tile[hsp.yt2][hsp.pt2].erase(hsp.i2);</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :     hadronScatter(event, hsp);</span>
<span class="lineNum">     870 </span>            :     // Store new indices for later
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :     HSIndex iNew1 = hsp.i1, iNew2 = hsp.i2;</span>
<span class="lineNum">     872 </span>            : 
<span class="lineNum">     873 </span>            :     // Check if hadrons can scatter again
<span class="lineNum">     874 </span>            :     bool resort = false;
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :     if (scatterRepeat) {</span>
<span class="lineNum">     876 </span>            :       // Check for new scatters of iNew1 and iNew2
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :       HSIndex iNew = iNew1;</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :       for (int i = 0; i &lt; 2; i++) {</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :         if (canScatter(event, iNew.second)) {</span>
<span class="lineNum">     880 </span>            :           // If both can scatter again, make sure they can't scatter
<span class="lineNum">     881 </span>            :           // with each other
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :           if (i == 1) scattered.insert(HSIndex(min(iNew1.first, iNew2.first),</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :                                              max(iNew1.first, iNew2.first)));</span>
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :           int yt = yTile(event, iNew.second);</span>
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :           int pt = pTile(event, iNew.second);</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :           resort = tileIntProb(scatterList, event, iNew, yt, pt, true);</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :           tile[yt][pt].insert(iNew);</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :         iNew = iNew2;</span>
<span class="lineNum">     890 </span>            :       } // for (i)
<span class="lineNum">     891 </span>            : 
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :     } // if (scatterRepeat)</span>
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span>            :     // Remove the old entry and onto next
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :     scatterList.erase(scatterList.begin());</span>
<span class="lineNum">     896 </span>            :     // Resort list if anything added
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :     if (resort) sort(scatterList.rbegin(), scatterList.rend());</span>
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :   } // while (scatterList.size() &gt; 0)</span>
<span class="lineNum">     900 </span>            : 
<span class="lineNum">     901 </span>            :   // Done.
<span class="lineNum">     902 </span>            :   return;
<span class="lineNum">     903 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     904 </span>            : 
<span class="lineNum">     905 </span>            : 
<span class="lineNum">     906 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     907 </span>            : 
<a name="908"><span class="lineNum">     908 </span>            : // Criteria for if a hadron is allowed to scatter or not</a>
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span>            : bool HadronScatter::canScatter(Event&amp; event, int i) {
<span class="lineNum">     911 </span>            :   // Probability to accept
<span class="lineNum">     912 </span>            :   double p = 0.;
<span class="lineNum">     913 </span>            : 
<span class="lineNum">     914 </span>            :   // Pions, K+, K-, p+, pbar- only
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :   if (scatterProb == 1 || scatterProb == 2)</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :     if (event[i].idAbs() != 111 &amp;&amp; event[i].idAbs() != 211 &amp;&amp;</span>
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :         event[i].idAbs() != 321 &amp;&amp; event[i].idAbs() != 2212)</span>
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     919 </span>            : 
<span class="lineNum">     920 </span>            :   // Probability
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :   switch (hadronSelect) {</span>
<span class="lineNum">     922 </span>            :   case 0:
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :     double t1 = exp( - event[i].pT2() / 2. / pTsigma2);</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :     double t2 = pow(pT0MPI, pPar) /</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :                 pow(pT0MPI * pT0MPI + event[i].pT2(), pPar / 2.);</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :     p = Npar * t1 / ( (1 - kPar) * t1 + kPar * t2 );</span>
<span class="lineNum">     927 </span>            :     break;
<span class="lineNum">     928 </span>            :   }
<span class="lineNum">     929 </span>            : 
<span class="lineNum">     930 </span>            :   // Return true/false
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :   if (p &gt; rndmPtr-&gt;flat()) return true;</span>
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :   else                     return false;</span>
<span class="lineNum">     933 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span>            : 
<span class="lineNum">     936 </span>            : //--------------------------------------------------------------------------
<a name="937"><span class="lineNum">     937 </span>            : </a>
<span class="lineNum">     938 </span>            : // Probability for scattering
<span class="lineNum">     939 </span>            : bool HadronScatter::doesScatter(Event&amp; event, const HSIndex &amp;i1,
<span class="lineNum">     940 </span>            :   const HSIndex &amp;i2) {
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :   Particle &amp;p1 = event[i1.second];</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :   Particle &amp;p2 = event[i2.second];</span>
<span class="lineNum">     943 </span>            : 
<span class="lineNum">     944 </span>            :   // Can't come from the same decay
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :   if (!allowDecayProd &amp;&amp; event[i1.first].mother1() ==</span>
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :       event[i2.first].mother1() &amp;&amp; event[event[i1.first].mother1()].isHadron())</span>
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     948 </span>            : 
<span class="lineNum">     949 </span>            :   // Check that the two hadrons have not already scattered
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :   if (scatterRepeat &amp;&amp;</span>
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :       scattered.find(HSIndex(min(i1.first, i2.first), max(i1.first, i2.first)))</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :       != scattered.end()) return false;</span>
<span class="lineNum">     953 </span>            : 
<span class="lineNum">     954 </span>            :   // K-K, p-p and K-p not allowed
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :   int id1 = min(p1.idAbs(), p2.idAbs());</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :   int id2 = max(p1.idAbs(), p2.idAbs());</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :   if (scatterProb == 1 || scatterProb == 2) {</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :     if ((id1 == 321 || id1 == 2212) &amp;&amp; id1 == id2) return false;</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :     if (id1 == 321 &amp;&amp; id2 == 2212)                 return false;</span>
<span class="lineNum">     960 </span>            :   }
<span class="lineNum">     961 </span>            : 
<span class="lineNum">     962 </span>            :   // Distance in y - phi space
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :   double dy  = p1.y() - p2.y();</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :   double dp  = abs(p1.phi() - p2.phi());</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :   if (dp &gt; M_PI) dp = 2 * M_PI - dp;</span>
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :   double dr2 = dy * dy + dp * dp;</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :   double p   = max(0., 1. - dr2 / rMax2);</span>
<span class="lineNum">     968 </span>            : 
<span class="lineNum">     969 </span>            :   // Additional factor depending on scatterProb
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :   if (scatterProb == 0 || scatterProb == 1) {</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :     p *= jPar;</span>
<span class="lineNum">     972 </span>            : 
<span class="lineNum">     973 </span>            :   // Additional pair dependent probability
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :   } else if (scatterProb == 2) {</span>
<span class="lineNum">     975 </span>            :     // Wcm and which partial wave amplitude to use
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :     double Wcm = (p1.p() + p2.p()).mCalc();</span>
<span class="lineNum">     977 </span>            :     int    pw = 0;
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :     if      ((id1 == 111 || id1 == 211) &amp;&amp; (id2 == 111 || id2 == 211)) pw = 0;</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :     else if ((id1 == 111 || id1 == 211) &amp;&amp; id2 == 321)                 pw = 1;</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :     else if ((id1 == 111 || id1 == 211) &amp;&amp; id2 == 2212)                pw = 2;</span>
<span class="lineNum">     981 </span>            :     else {
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :       infoPtr-&gt;errorMsg(&quot;Error in HadronScatter::doesScatter:&quot;</span>
<span class="lineNum">     983 </span>            :         &quot;unknown subprocess&quot;);
<span class="lineNum">     984 </span>            :     }
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :     if (!sigmaPW[pw].setSubprocess(p1.id(), p2.id())) {</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :       infoPtr-&gt;errorMsg(&quot;Error in HadronScatter::doesScatter:&quot;</span>
<span class="lineNum">     987 </span>            :         &quot;setSubprocess failed&quot;);
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :       p *= 1 - exp(-jPar * sigmaPW[pw].sigmaEl(Wcm));</span>
<span class="lineNum">     990 </span>            :     }
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span>            :   // Return true/false
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :   return (p &gt; rndmPtr-&gt;flat());</span>
<span class="lineNum">     995 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     996 </span>            : 
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     999 </span>            : 
<a name="1000"><span class="lineNum">    1000 </span>            : // Calculate ordering measure</a>
<span class="lineNum">    1001 </span>            : 
<span class="lineNum">    1002 </span>            : double HadronScatter::measure(Event&amp; event, int idx1, int idx2) {
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :   Particle &amp;p1 = event[idx1];</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :   Particle &amp;p2 = event[idx2];</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :   return abs(p1.pT() / p1.mT() - p2.pT() / p2.mT());</span>
<span class="lineNum">    1006 </span>            : }
<span class="lineNum">    1007 </span>            : 
<span class="lineNum">    1008 </span>            : 
<span class="lineNum">    1009 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1010 </span>            : 
<a name="1011"><span class="lineNum">    1011 </span>            : // Scatter a pair</a>
<span class="lineNum">    1012 </span>            : 
<span class="lineNum">    1013 </span>            : bool HadronScatter::hadronScatter(Event&amp; event, HadronScatterPair &amp;hsp) {
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :   bool doSwap = (0.5 &lt; rndmPtr-&gt;flat()) ? true : false;</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :   if (doSwap) swap(hsp.i1, hsp.i2);</span>
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :   Particle &amp;p1 = event[hsp.i1.second];</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :   Particle &amp;p2 = event[hsp.i2.second];</span>
<span class="lineNum">    1019 </span>            : 
<span class="lineNum">    1020 </span>            :   // Pick theta and phi (always flat)
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :   double ct = 0., phi = 2 * M_PI * rndmPtr-&gt;flat();</span>
<span class="lineNum">    1022 </span>            : 
<span class="lineNum">    1023 </span>            :   // Flat for all flavours
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :   if (scatterProb == 0 || scatterProb == 1) {</span>
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :     ct  = 2. * rndmPtr-&gt;flat() - 1.;</span>
<span class="lineNum">    1026 </span>            : 
<span class="lineNum">    1027 </span>            :   // pi-pi, pi-K and pi-p only using partial wave amplitudes
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :   } else if (scatterProb == 2) {</span>
<span class="lineNum">    1029 </span>            :     // Wcm and which partial wave amplitude to use
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :     int    id1 = min(p1.idAbs(), p2.idAbs());</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :     int    id2 = max(p1.idAbs(), p2.idAbs());</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :     double Wcm = (p1.p() + p2.p()).mCalc();</span>
<span class="lineNum">    1033 </span>            :     int    pw  = 0;
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :     if      ((id1 == 111 || id1 == 211) &amp;&amp; (id2 == 111 || id2 == 211)) pw = 0;</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :     else if ((id1 == 111 || id1 == 211) &amp;&amp; id2 == 321)                 pw = 1;</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :     else if ((id1 == 111 || id1 == 211) &amp;&amp; id2 == 2212)                pw = 2;</span>
<span class="lineNum">    1037 </span>            :     else {
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :       infoPtr-&gt;errorMsg(&quot;Error in HadronScatter::hadronScatter:&quot;</span>
<span class="lineNum">    1039 </span>            :         &quot;unknown subprocess&quot;);
<span class="lineNum">    1040 </span>            :     }
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :     sigmaPW[pw].setSubprocess(p1.id(), p2.id());</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :     ct = sigmaPW[pw].pickCosTheta(Wcm);</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1044 </span>            : 
<span class="lineNum">    1045 </span>            :   // Rotation
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :   RotBstMatrix sMat;</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :   sMat.toCMframe(p1.p(), p2.p());</span>
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :   sMat.rot(acos(ct), phi);</span>
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :   sMat.fromCMframe(p1.p(), p2.p());</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :   Vec4 v1 = p1.p(), v2 = p2.p();</span>
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :   v1.rotbst(sMat);</span>
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :   v2.rotbst(sMat);</span>
<span class="lineNum">    1053 </span>            : 
<span class="lineNum">    1054 </span>            :   // Update event record
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :   int iNew1 = event.copy(hsp.i1.second, 98);</span>
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :   event[iNew1].p(v1);</span>
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :   event[iNew1].e(event[iNew1].eCalc());</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :   event[hsp.i1.second].statusNeg();</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :   int iNew2 = event.copy(hsp.i2.second, 98);</span>
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :   event[iNew2].p(v2);</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :   event[iNew2].e(event[iNew2].eCalc());</span>
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :   event[hsp.i2.second].statusNeg();</span>
<span class="lineNum">    1063 </span>            : 
<span class="lineNum">    1064 </span>            :   // New indices in event record
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :   hsp.i1.second = iNew1;</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :   hsp.i2.second = iNew2;</span>
<span class="lineNum">    1067 </span>            : 
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :   if (doSwap) swap(hsp.i1, hsp.i2);</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1071 </span>            : 
<span class="lineNum">    1072 </span>            : 
<span class="lineNum">    1073 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1074 </span>            : 
<span class="lineNum">    1075 </span>            : // Calculate pair interaction probabilities in nearest-neighbour tiles
<span class="lineNum">    1076 </span>            : // (yt1, pt1) represents centre cell (8):
<span class="lineNum">    1077 </span>            : //    7 | 0 | 1
<span class="lineNum">    1078 </span>            : //   -----------
<span class="lineNum">    1079 </span>            : //    6 | 8 | 2
<span class="lineNum">    1080 </span>            : //   -----------
<a name="1081"><span class="lineNum">    1081 </span>            : //    5 | 4 | 3</a>
<span class="lineNum">    1082 </span>            : 
<span class="lineNum">    1083 </span>            : bool HadronScatter::tileIntProb(vector &lt; HadronScatterPair &gt; &amp;hsp,
<span class="lineNum">    1084 </span>            :     Event &amp;event, const HSIndex &amp;i1, int yt1, int pt1, bool doAll) {
<span class="lineNum">    1085 </span>            :   // Track if a new pair is added
<span class="lineNum">    1086 </span>            :   bool pairAdded = false;
<span class="lineNum">    1087 </span>            : 
<span class="lineNum">    1088 </span>            :   // Special handling for pairing in own tile
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :   if (!doAll) {</span>
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :     set &lt; HSIndex &gt;::iterator si2 = tile[yt1][pt1].find(i1);</span>
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :     while (++si2 != tile[yt1][pt1].end())</span>
<span class="lineNum">    1092 </span>            :       // Calculate if scatters
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :       if (doesScatter(event, i1, *si2)) {</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :         double m = measure(event, i1.second, si2-&gt;second);</span>
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :         hsp.push_back(HadronScatterPair(i1, yt1, pt1, *si2, yt1, pt1, m));</span>
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1098 </span>            : 
<span class="lineNum">    1099 </span>            :   // And the rest
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :   int tileMax = (doAll) ? 9 : 4;</span>
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :   for (int tileNow = 0; tileNow &lt; tileMax; tileNow++) {</span>
<span class="lineNum">    1102 </span>            :     // New (yt, pt) coordinate
<span class="lineNum">    1103 </span>            :     int yt2 = yt1, pt2 = pt1;
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :     switch (tileNow) {</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :     case 0:        ++pt2; break;</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :     case 1: ++yt2; ++pt2; break;</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :     case 2: ++yt2;        break;</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :     case 3: ++yt2; --pt2; break;</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :     case 4:        --pt2; break;</span>
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :     case 5: --yt2; --pt2; break;</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :     case 6: --yt2;        break;</span>
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :     case 7: --yt2; ++pt2; break;</span>
<span class="lineNum">    1113 </span>            :     }
<span class="lineNum">    1114 </span>            : 
<span class="lineNum">    1115 </span>            :     // Limit in rapidity tiles
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :     if (yt2 &lt; 0 || yt2 &gt;= ytMax) continue;</span>
<span class="lineNum">    1117 </span>            :     // Wraparound for phi tiles
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :     if (pt2 &lt; 0) {</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :       pt2 = ptMax - 1;</span>
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :       if (pt2 == pt1 || pt2 == pt1 + 1) continue;</span>
<span class="lineNum">    1121 </span>            : 
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :     } else if (pt2 &gt;= ptMax) {</span>
<span class="lineNum">    1123 </span>            :       pt2 = 0;
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :       if (pt2 == pt1 || pt2 == pt1 - 1) continue;</span>
<span class="lineNum">    1125 </span>            :     }
<span class="lineNum">    1126 </span>            : 
<span class="lineNum">    1127 </span>            :     // Interaction probability
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :     for (set &lt; HSIndex &gt;::iterator si2 = tile[yt2][pt2].begin();</span>
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :          si2 != tile[yt2][pt2].end(); si2++) {</span>
<span class="lineNum">    1130 </span>            :       // Calculate if scatters
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :       if (doesScatter(event, i1, *si2)) {</span>
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :         double m = measure(event, i1.second, si2-&gt;second);</span>
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :         hsp.push_back(HadronScatterPair(i1, yt1, pt1, *si2, yt2, pt2, m));</span>
<span class="lineNum">    1134 </span>            :         pairAdded = true;
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1136 </span>            :     }
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1138 </span>            : 
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :   return pairAdded;</span>
<span class="lineNum">    1140 </span>            : }
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span>            : //==========================================================================
<span class="lineNum">    1143 </span>            : 
<span class="lineNum">    1144 </span>            : } // namespace Pythia8
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
