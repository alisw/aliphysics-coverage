<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - PYTHIA8/pythia8210dev/src/PartonLevel.cc</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">PYTHIA8/pythia8210dev/src</a> - PartonLevel.cc<span style="font-size: 80%;"> (source / <a href="PartonLevel.cc.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">1362</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">13</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // PartonLevel.cc is a part of the PYTHIA event generator.</a>
<span class="lineNum">       2 </span>            : // Copyright (C) 2015 Torbjorn Sjostrand.
<span class="lineNum">       3 </span>            : // PYTHIA is licenced under the GNU GPL version 2, see COPYING for details.
<span class="lineNum">       4 </span>            : // Please respect the MCnet Guidelines, see GUIDELINES for details.
<span class="lineNum">       5 </span>            : // Hard diffraction added by Christine Rasmussen.
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : // Function definitions (not found in the header) for the PartonLevel class.
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;Pythia8/PartonLevel.h&quot;
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : namespace Pythia8 {
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : //==========================================================================
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : // The PartonLevel class.
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : // Constants: could be changed here if desired, but normally should not.
<span class="lineNum">      20 </span>            : // These are of technical nature, as described for each.
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : // Maximum number of tries to produce parton level from given input.
<span class="lineNum">      23 </span>            : const int PartonLevel::NTRY = 10;
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      26 </span>            : 
<a name="27"><span class="lineNum">      27 </span>            : // Main routine to initialize the parton-level generation process.</a>
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : bool PartonLevel::init( Info* infoPtrIn, Settings&amp; settings,
<span class="lineNum">      30 </span>            :   ParticleData* particleDataPtrIn, Rndm* rndmPtrIn,
<span class="lineNum">      31 </span>            :   BeamParticle* beamAPtrIn, BeamParticle* beamBPtrIn,
<span class="lineNum">      32 </span>            :   BeamParticle* beamPomAPtrIn, BeamParticle* beamPomBPtrIn,
<span class="lineNum">      33 </span>            :   Couplings* couplingsPtrIn, PartonSystems* partonSystemsPtrIn,
<span class="lineNum">      34 </span>            :   SigmaTotal* sigmaTotPtr, TimeShower* timesDecPtrIn, TimeShower* timesPtrIn,
<span class="lineNum">      35 </span>            :   SpaceShower* spacePtrIn, RHadrons* rHadronsPtrIn, UserHooks* userHooksPtrIn,
<span class="lineNum">      36 </span>            :   MergingHooks* mergingHooksPtrIn, bool useAsTrial ) {
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            :   // Store input pointers and modes for future use.
<span class="lineNum">      39 </span><span class="lineNoCov">          0 :   infoPtr            = infoPtrIn;</span>
<span class="lineNum">      40 </span><span class="lineNoCov">          0 :   particleDataPtr    = particleDataPtrIn;</span>
<span class="lineNum">      41 </span><span class="lineNoCov">          0 :   rndmPtr            = rndmPtrIn;</span>
<span class="lineNum">      42 </span><span class="lineNoCov">          0 :   beamAPtr           = beamAPtrIn;</span>
<span class="lineNum">      43 </span><span class="lineNoCov">          0 :   beamBPtr           = beamBPtrIn;</span>
<span class="lineNum">      44 </span><span class="lineNoCov">          0 :   beamHadAPtr        = beamAPtr;</span>
<span class="lineNum">      45 </span><span class="lineNoCov">          0 :   beamHadBPtr        = beamBPtr;</span>
<span class="lineNum">      46 </span><span class="lineNoCov">          0 :   beamPomAPtr        = beamPomAPtrIn;</span>
<span class="lineNum">      47 </span><span class="lineNoCov">          0 :   beamPomBPtr        = beamPomBPtrIn;</span>
<span class="lineNum">      48 </span><span class="lineNoCov">          0 :   couplingsPtr       = couplingsPtrIn;</span>
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :   partonSystemsPtr   = partonSystemsPtrIn;</span>
<span class="lineNum">      50 </span><span class="lineNoCov">          0 :   timesDecPtr        = timesDecPtrIn;</span>
<span class="lineNum">      51 </span><span class="lineNoCov">          0 :   timesPtr           = timesPtrIn;</span>
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :   spacePtr           = spacePtrIn;</span>
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :   rHadronsPtr        = rHadronsPtrIn;</span>
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :   userHooksPtr       = userHooksPtrIn;</span>
<span class="lineNum">      55 </span><span class="lineNoCov">          0 :   mergingHooksPtr    = mergingHooksPtrIn;</span>
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            :   // Min bias and diffraction processes need special treatment.
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :   bool doSQ          = settings.flag(&quot;SoftQCD:all&quot;)</span>
<span class="lineNum">      59 </span><span class="lineNoCov">          0 :                     || settings.flag(&quot;SoftQCD:inelastic&quot;);</span>
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :   bool doND          = settings.flag(&quot;SoftQCD:nonDiffractive&quot;);</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :   bool doSD          = settings.flag(&quot;SoftQCD:singleDiffractive&quot;);</span>
<span class="lineNum">      62 </span><span class="lineNoCov">          0 :   bool doDD          = settings.flag(&quot;SoftQCD:doubleDiffractive&quot;);</span>
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :   bool doCD          = settings.flag(&quot;SoftQCD:centralDiffractive&quot;);</span>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :   doNonDiff          =  doSQ || doND;</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :   doDiffraction      =  doSQ || doSD || doDD || doCD;</span>
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :   doHardDiff         = settings.flag(&quot;Diffraction:doHard&quot;);</span>
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :   sampleTypeDiff     = (doHardDiff) ? settings.mode(&quot;Diffraction:sampleType&quot;)</span>
<span class="lineNum">      68 </span>            :                      : 0;
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            :   // Separate low-mass (unresolved) and high-mass (perturbative) diffraction.
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :   mMinDiff           = settings.parm(&quot;Diffraction:mMinPert&quot;);</span>
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :   mWidthDiff         = settings.parm(&quot;Diffraction:mWidthPert&quot;);</span>
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :   pMaxDiff           = settings.parm(&quot;Diffraction:probMaxPert&quot;);</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :   if (mMinDiff &gt; infoPtr-&gt;eCM()) doDiffraction = false;</span>
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            :   // Need MPI initialization for soft QCD processes, even if only first MPI.
<span class="lineNum">      77 </span>            :   // But no need to initialize MPI if never going to use it.
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :   doMPI              = settings.flag(&quot;PartonLevel:MPI&quot;);</span>
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :   doMPIMB            = doMPI;</span>
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :   doMPISDA           = doMPI;</span>
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :   doMPISDB           = doMPI;</span>
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :   doMPICD            = doMPI;</span>
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :   doMPIinit          = doMPI;</span>
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :   if (doNonDiff || doDiffraction)        doMPIinit = true;</span>
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :   if (!settings.flag(&quot;PartonLevel:all&quot;)) doMPIinit = false;</span>
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            :   // Initialise trial shower switch.
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :   doTrial            = useAsTrial;</span>
<span class="lineNum">      89 </span>            :   // Merging initialization.
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :   bool hasMergingHooks = (mergingHooksPtr != 0);</span>
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :   canRemoveEvent       = !doTrial &amp;&amp; hasMergingHooks</span>
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :     &amp;&amp; ( mergingHooksPtr-&gt;doCKKWLMerging() || mergingHooksPtr-&gt;doNL3Merging());</span>
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :   canRemoveEmission    = !doTrial &amp;&amp; hasMergingHooks</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :     &amp;&amp; ( mergingHooksPtr-&gt;doUMEPSMerging() || mergingHooksPtr-&gt;doNL3Merging()</span>
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :       || mergingHooksPtr-&gt;doUNLOPSMerging() );</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :   nTrialEmissions    = 1;</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :   pTLastBranch       = 0.0;</span>
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :   typeLastBranch     = 0;</span>
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            :   // Flags for showers: ISR and FSR.
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :   doISR              = settings.flag(&quot;PartonLevel:ISR&quot;);</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :   bool FSR           = settings.flag(&quot;PartonLevel:FSR&quot;);</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :   bool FSRinProcess  = settings.flag(&quot;PartonLevel:FSRinProcess&quot;);</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :   bool interleaveFSR = settings.flag(&quot;TimeShower:interleave&quot;);</span>
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :   doFSRduringProcess = FSR &amp;&amp; FSRinProcess &amp;&amp;  interleaveFSR;</span>
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :   doFSRafterProcess  = FSR &amp;&amp; FSRinProcess &amp;&amp; !interleaveFSR;</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :   doFSRinResonances  = FSR &amp;&amp; settings.flag(&quot;PartonLevel:FSRinResonances&quot;);</span>
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            :   // Flags for colour reconnection.
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :   doReconnect        = settings.flag(&quot;ColourReconnection:reconnect&quot;);</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :   reconnectMode      = settings.mode(&quot;ColourReconnection:mode&quot;);</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :   forceResonanceCR   = settings.flag(&quot;ColourReconnection:forceResonance&quot;);</span>
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            :   // Some other flags.
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :   doRemnants         = settings.flag(&quot;PartonLevel:Remnants&quot;);</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :   doSecondHard       = settings.flag(&quot;SecondHard:generate&quot;);</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :   earlyResDec        = settings.flag(&quot;PartonLevel:earlyResDec&quot;);</span>
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span>            :   // Allow R-hadron formation.
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :   allowRH            = settings.flag(&quot;RHadrons:allow&quot;);</span>
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            :   // Possibility to allow user veto during evolution.
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :   canVetoPT          = (userHooksPtr != 0)</span>
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :                      ? userHooksPtr-&gt;canVetoPT()   : false;</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :   pTvetoPT           = (canVetoPT)</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :                      ? userHooksPtr-&gt;scaleVetoPT() : -1.;</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :   canVetoStep        = (userHooksPtr != 0)</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :                      ? userHooksPtr-&gt;canVetoStep() : false;</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :   nVetoStep          = (canVetoStep)</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :                      ? userHooksPtr-&gt;numberVetoStep() : -1;</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :   canVetoMPIStep     = (userHooksPtr != 0)</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :                      ? userHooksPtr-&gt;canVetoMPIStep() : false;</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :   nVetoMPIStep       = (canVetoMPIStep)</span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :                      ? userHooksPtr-&gt;numberVetoMPIStep() : -1;</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :   canVetoEarly       = (userHooksPtr != 0)</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :                      ? userHooksPtr-&gt;canVetoPartonLevelEarly() : false;</span>
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            :   // Settings for vetoing of QCD emission for Drell-Yan weak boson production.
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :   vetoWeakJets       = settings.flag(&quot;WeakShower:vetoQCDjets&quot;);</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :   vetoWeakDeltaR2    = pow2(settings.parm(&quot;WeakShower:vetoWeakDeltaR&quot;));</span>
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            :   // Possibility to set maximal shower scale in resonance decays.
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :   canSetScale        = (userHooksPtr != 0)</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :                      ? userHooksPtr-&gt;canSetResonanceScale() : false;</span>
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            :   // Possibility to reconnect specifically for resonance decays.
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :   canReconResSys     = (userHooksPtr != 0)</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :                      ? userHooksPtr-&gt;canReconnectResonanceSystems() : false;</span>
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span>            :   // Done with initialization only for FSR in resonance decays.
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :   if (beamAPtr == 0 || beamBPtr == 0) return true;</span>
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span>            :   // Flag if lepton beams, and if non-resolved ones. May change main flags.
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :   hasTwoLeptonBeams  =  beamAPtr-&gt;isLepton() &amp;&amp; beamBPtr-&gt;isLepton();</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :   hasOneLeptonBeam   = (beamAPtr-&gt;isLepton() || beamBPtr-&gt;isLepton())</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :                     &amp;&amp; !hasTwoLeptonBeams;</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :   hasPointLeptons    = (hasOneLeptonBeam || hasTwoLeptonBeams)</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :     &amp;&amp; (beamAPtr-&gt;isUnresolved() || beamBPtr-&gt;isUnresolved());</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :   if (hasOneLeptonBeam || hasTwoLeptonBeams) {</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :     doMPIMB          = false;</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :     doMPISDA         = false;</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :     doMPISDB         = false;</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :     doMPICD          = false;</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :     doMPIinit        = false;</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :   if (hasTwoLeptonBeams &amp;&amp; hasPointLeptons) {</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :     doISR            = false;</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :     doRemnants       = false;</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            :   // Set info and initialize the respective program elements.
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :   timesPtr-&gt;init( beamAPtr, beamBPtr);</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :   if (doISR) spacePtr-&gt;init( beamAPtr, beamBPtr);</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :   doMPIMB  =  multiMB.init( doMPIinit, 0, infoPtr, settings, particleDataPtr,</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :     rndmPtr, beamAPtr, beamBPtr, couplingsPtr, partonSystemsPtr, sigmaTotPtr,</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :     userHooksPtr);</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :   if (doSD || doDD || doSQ || doHardDiff) doMPISDA = multiSDA.init( doMPIinit,</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :     1, infoPtr, settings, particleDataPtr, rndmPtr, beamAPtr, beamPomBPtr,</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :     couplingsPtr, partonSystemsPtr, sigmaTotPtr, userHooksPtr);</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :   if (doSD || doDD || doSQ || doHardDiff) doMPISDB = multiSDB.init( doMPIinit,</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :     2, infoPtr, settings, particleDataPtr, rndmPtr, beamPomAPtr, beamBPtr,</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :     couplingsPtr, partonSystemsPtr, sigmaTotPtr, userHooksPtr);</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :   if (doCD || doSQ) doMPICD = multiCD.init( doMPIinit, 3, infoPtr, settings,</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :     particleDataPtr, rndmPtr, beamPomAPtr, beamPomBPtr, couplingsPtr,</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :     partonSystemsPtr, sigmaTotPtr, userHooksPtr);</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :   if (!remnants.init( infoPtr, settings, rndmPtr, beamAPtr, beamBPtr,</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :     partonSystemsPtr, particleDataPtr, &amp;colourReconnection)) return false;</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :   resonanceDecays.init( infoPtr, particleDataPtr, rndmPtr);</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :   colourReconnection.init( infoPtr, settings, rndmPtr, particleDataPtr,</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :     beamAPtr, beamBPtr, partonSystemsPtr);</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :   junctionSplitting.init(infoPtr, settings, rndmPtr, particleDataPtr);</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :   if (doHardDiff) hardDiffraction.init(infoPtr, settings, rndmPtr, beamAPtr,</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :     beamBPtr, beamPomAPtr, beamPomBPtr);</span>
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            :   // Succeeded, or not.
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :   multiPtr       = &amp;multiMB;</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :   if (doMPIinit &amp;&amp; !doMPIMB) return false;</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :   if (doMPIinit &amp;&amp; (doSD || doDD || doSQ) &amp;&amp; (!doMPISDA || !doMPISDB))</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :      return false;</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :   if (doMPIinit &amp;&amp; (doCD || doSQ) &amp;&amp; !doMPICD) return false;</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :   if (!doMPIMB || !doMPISDA || !doMPISDB || !doMPICD) doMPI = false;</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     207 </span>            : 
<a name="208"><span class="lineNum">     208 </span>            : // Function to reset PartonLevel object for trial shower usage.</a>
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span>            : void PartonLevel::resetTrial() {
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span>            :   // Clear input pointers.
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :   partonSystemsPtr-&gt;clear();</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :   beamAPtr-&gt;clear();</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :   beamBPtr-&gt;clear();</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :   beamHadAPtr-&gt;clear();</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :   beamHadBPtr-&gt;clear();</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :   beamPomAPtr-&gt;clear();</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :   beamPomBPtr-&gt;clear();</span>
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span>            :   // Clear last branching return values.
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :   pTLastBranch   = 0.0;</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :   typeLastBranch = 0;</span>
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     228 </span>            : 
<a name="229"><span class="lineNum">     229 </span>            : // Main routine to do the parton-level evolution.</a>
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span>            : bool PartonLevel::next( Event&amp; process, Event&amp; event) {
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span>            :   // Current event classification.
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :   isResolved     = infoPtr-&gt;isResolved();</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :   isResolvedA    = isResolved;</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :   isResolvedB    = isResolved;</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :   isResolvedC    = isResolved;</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :   isDiffA        = infoPtr-&gt;isDiffractiveA();</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :   isDiffB        = infoPtr-&gt;isDiffractiveB();</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :   isDiffC        = infoPtr-&gt;isDiffractiveC();</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :   isDiff         = isDiffA || isDiffB || isDiffC;</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :   isCentralDiff  = isDiffC;</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :   isDoubleDiff   = isDiffA &amp;&amp; isDiffB;</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :   isSingleDiff   = isDiff &amp;&amp; !isDoubleDiff  &amp;&amp; !isCentralDiff;</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :   isNonDiff      = infoPtr-&gt;isNonDiffractive();</span>
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span>            :   // Default values for what is to come.
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :   isHardDiffA    = false;</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :   isHardDiffB    = false;</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :   isHardDiff     = false;</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :   doDiffVeto     = false;</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :   isSetupDiff    = false;</span>
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            :   // The setup of the diffractive events can come after the first evolution.
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :   doVeto         = false;</span>
<span class="lineNum">     256 </span>            :   int nHardDiffLoop = 1;
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :   infoPtr-&gt;setAbortPartonLevel(false);</span>
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            :   // Mark hard diffractive events to handle CR correctly.
<span class="lineNum">     260 </span>            :   bool doDiffCR = false;
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            :   // Prepare for a potential hard diffractive event.
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :   if (doHardDiff) {</span>
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            :     // Preliminary decision based on diffractive-to-inclusive PDF ratio.
<span class="lineNum">     266 </span>            :     // If Pomeron taken from side A(=1), then B is the diffractive system
<span class="lineNum">     267 </span>            :     // If Pomeron taken from side B(=2), then A is the diffractive system
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :     isHardDiffA = hardDiffraction.isDiffractive(2, infoPtr-&gt;id2pdf(),</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :       infoPtr-&gt;x2pdf(), infoPtr-&gt;Q2Fac(), infoPtr-&gt;pdf2());</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :     isHardDiffB = hardDiffraction.isDiffractive(1, infoPtr-&gt;id1pdf(),</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :       infoPtr-&gt;x1pdf(), infoPtr-&gt;Q2Fac(), infoPtr-&gt;pdf1());</span>
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span>            :     // No hard double diffraction yet, so randomly choose one of the sides.
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :     if (isHardDiffA &amp;&amp; isHardDiffB) {</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :       if (rndmPtr-&gt; flat() &lt; 0.5) isHardDiffA = false;</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :       else isHardDiffB = false;</span>
<span class="lineNum">     277 </span>            :     }
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :     isHardDiff = isHardDiffA || isHardDiffB;</span>
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span>            :     // Save diffractive values.
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :     double xPomA = (isHardDiffB) ? hardDiffraction.getXPomeronA() : 0.;</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :     double xPomB = (isHardDiffA) ? hardDiffraction.getXPomeronB() : 0.;</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :     double tPomA = (isHardDiffB) ? hardDiffraction.getTPomeronA() : 0.;</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :     double tPomB = (isHardDiffA) ? hardDiffraction.getTPomeronB() : 0.;</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :     infoPtr-&gt;setHardDiff( false, isHardDiffA, isHardDiffB,</span>
<span class="lineNum">     286 </span>            :       xPomA, xPomB, tPomA, tPomB);
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            :     // Discard all nondiffractive events if only diffractive sample is wanted.
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :     if (!isHardDiff &amp;&amp; (sampleTypeDiff == 3 || sampleTypeDiff == 4)) {</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :       doDiffVeto = true;</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     292 </span>            :     }
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :     if (isHardDiff) {</span>
<span class="lineNum">     295 </span>            :       // Discard all diffractive events if only want nondiffractive sample.
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :       if (sampleTypeDiff == 5) {</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :         infoPtr-&gt;setHardDiff( false, false, false, 0., 0., 0., 0.);</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :         doDiffVeto = true;</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     300 </span>            :       }
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span>            :       // Set up the diffractive system if run without MPI veto.
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :       else if (sampleTypeDiff == 1 || sampleTypeDiff ==  3)</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :         setupHardDiff( process);</span>
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span>            :       // Allow for second loop if run with MPI veto.
<span class="lineNum">     307 </span>            :       else nHardDiffLoop = 2;
<span class="lineNum">     308 </span>            :     }
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            :   // nHardLoop counts how many hard-scattering subsystems are to be processed.
<span class="lineNum">     312 </span>            :   // Almost always 1, but elastic and low-mass diffraction gives 0, while
<span class="lineNum">     313 </span>            :   // double diffraction can give up to 2. Not to be confused with SecondHard.
<span class="lineNum">     314 </span>            :   int nHardLoop  = 1;
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :   if (!isResolved) nHardLoop = (isDiff) ? decideResolvedDiff( process) : 0;</span>
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span>            :   // Handle unresolved subsystems. Done if no resolved ones.
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :   sizeProcess    = 0;</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :   sizeEvent      = 0;</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :   if (!isResolvedA || !isResolvedB || !isResolvedC) {</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :     bool physical = setupUnresolvedSys( process, event);</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :     if (!physical || nHardLoop == 0) return physical;</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :     sizeProcess  = process.size();</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :     sizeEvent    = event.size();</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            :   // Number of actual branchings.
<span class="lineNum">     328 </span>            :   int nBranch        = 0;
<span class="lineNum">     329 </span>            :   // Number of desired branchings, negative value means no restriction.
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :   int nBranchMax     = (doTrial) ? nTrialEmissions : -1;</span>
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            :   // Store merging weight.
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :   bool hasMergingHooks = (mergingHooksPtr != 0);</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :   if ( hasMergingHooks &amp;&amp; canRemoveEvent )</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :     mergingHooksPtr-&gt;storeWeights(infoPtr-&gt;getWeightCKKWL());</span>
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            :   // Loop to set up diffractive system if run with MPI veto.
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :   for (int iHardDiffLoop = 1; iHardDiffLoop &lt;= nHardDiffLoop;</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :     ++iHardDiffLoop) {</span>
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span>            :   // Big outer loop to handle up to two systems (in double diffraction),
<span class="lineNum">     342 </span>            :   // but normally one. (Not indented in following, but end clearly marked.)
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :   for (int iHardLoop = 1; iHardLoop &lt;= nHardLoop; ++iHardLoop) {</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :     infoPtr-&gt;setCounter(20, iHardLoop);</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :     infoPtr-&gt;setCounter(21);</span>
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span>            :   // Classification of diffractive system: 1 = A, 2 = B, 3 = central.
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :   iDS = 0;</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :   if (isDiffA || isDiffB) iDS = (iHardLoop == 2 || !isResolvedA) ? 2 : 1;</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :   if (isDiffC) iDS = 3;</span>
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span>            :   // Process and event records can be out of step for diffraction.
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :   if (iHardLoop == 2) {</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :     sizeProcess = process.size();</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :     sizeEvent   = event.size();</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :     partonSystemsPtr-&gt;clear();</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :     if (event.lastColTag() &gt; process.lastColTag())</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :       process.initColTag(event.lastColTag());</span>
<span class="lineNum">     359 </span>            :   }
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            :   // If you need to restore then do not throw existing diffractive system.
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :   if (isDiff) {</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :     event.saveSize();</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :     event.saveJunctionSize();</span>
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span>            :     // Allow special treatment of diffractive systems.
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :     setupResolvedDiff( process);</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            :   // Prepare to do multiparton interactions; at new mass for diffraction.
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :   if (doMPIinit) multiPtr-&gt;reset();</span>
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            :   // Special case if nondiffractive: do hardest interaction.
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :   if (isNonDiff || isDiff) {</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :     multiPtr-&gt;pTfirst();</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :     multiPtr-&gt;setupFirstSys( process);</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span>            :   // Allow up to ten tries; failure possible for beam remnants.
<span class="lineNum">     380 </span>            :   // Main cause: inconsistent colour flow at the end of the day.
<span class="lineNum">     381 </span>            :   bool physical = true;
<span class="lineNum">     382 </span>            :   int  nRad     = 0;
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :   for (int iTry = 0; iTry &lt; NTRY; ++ iTry) {</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :     infoPtr-&gt;addCounter(21);</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :     for (int i = 22; i &lt; 32; ++i) infoPtr-&gt;setCounter(i);</span>
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span>            :     // Reset flag, counters and max scales.
<span class="lineNum">     388 </span>            :     physical   = true;
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :     nMPI       = (doSecondHard) ? 2 : 1;</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :     nISR       = 0;</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :     nFSRinProc = 0;</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :     nFSRinRes  = 0;</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :     nISRhard   = 0;</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :     nFSRhard   = 0;</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :     pTsaveMPI  = 0.;</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :     pTsaveISR  = 0.;</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :     pTsaveFSR  = 0.;</span>
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span>            :     // Identify hard interaction system for showers.
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :     setupHardSys( process, event);</span>
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            :     // Optionally check for a veto after the hardest interaction.
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :     if (canVetoMPIStep) {</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :       doVeto = userHooksPtr-&gt;doVetoMPIStep( 1, event);</span>
<span class="lineNum">     405 </span>            :       // Abort event if vetoed.
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :       if (doVeto) {</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :         if (isDiff) leaveResolvedDiff( iHardLoop, process, event);</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     409 </span>            :       }
<span class="lineNum">     410 </span>            :     }
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span>            :     // Check matching of process scale to maximum ISR/FSR/MPI scales.
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :     double Q2Fac       = infoPtr-&gt;Q2Fac();</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :     double Q2Ren       = infoPtr-&gt;Q2Ren();</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :     bool limitPTmaxISR = (doISR)</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :       ? spacePtr-&gt;limitPTmax( event, Q2Fac, Q2Ren) : false;</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :     bool limitPTmaxFSR = (doFSRduringProcess)</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :       ? timesPtr-&gt;limitPTmax( event, Q2Fac, Q2Ren) : false;</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :     bool limitPTmaxMPI = (doMPI)  ? multiPtr-&gt;limitPTmax( event) : false;</span>
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span>            :     // Global recoil: reset counters and store locations of outgoing partons.
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :     timesPtr-&gt;prepareGlobal( event);</span>
<span class="lineNum">     423 </span>            :     bool isFirstTrial = true;
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span>            :     // Set hard scale, maximum for showers and multiparton interactions.
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :     double pTscaleRad  = process.scale();</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :     double pTscaleMPI  = pTscaleRad;</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :     if (doSecondHard) {</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :       pTscaleRad       = max( pTscaleRad, process.scaleSecond() );</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :       pTscaleMPI       = min( pTscaleMPI, process.scaleSecond() );</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :     double pTmaxMPI = (limitPTmaxMPI)  ? pTscaleMPI : infoPtr-&gt;eCM();</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :     double pTmaxISR = (limitPTmaxISR) ? spacePtr-&gt;enhancePTmax() * pTscaleRad</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :                                       : infoPtr-&gt;eCM();</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :     double pTmaxFSR = (limitPTmaxFSR) ? timesPtr-&gt;enhancePTmax() * pTscaleRad</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :                                       : infoPtr-&gt;eCM();</span>
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            :     // Potentially reset up starting scales for matrix element merging.
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :     if ( hasMergingHooks &amp;&amp; (doTrial || canRemoveEvent || canRemoveEmission) )</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :       mergingHooksPtr-&gt;setShowerStartingScales( doTrial,</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :         (canRemoveEvent || canRemoveEmission), pTscaleRad, process, pTmaxFSR,</span>
<span class="lineNum">     442 </span>            :         limitPTmaxFSR, pTmaxISR, limitPTmaxISR, pTmaxMPI, limitPTmaxMPI );
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :     double pTmax    = max( pTmaxMPI, max( pTmaxISR, pTmaxFSR) );</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :     pTsaveMPI       = pTmaxMPI;</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :     pTsaveISR       = pTmaxISR;</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :     pTsaveFSR       = pTmaxFSR;</span>
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span>            :     // Prepare the classes to begin the generation.
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :     if (doMPI) multiPtr-&gt;prepare( event, pTmaxMPI);</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :     if (doISR) spacePtr-&gt;prepare( 0, event, limitPTmaxISR);</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :     if (doFSRduringProcess) timesPtr-&gt;prepare( 0, event, limitPTmaxFSR);</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :     if (doSecondHard &amp;&amp; doISR) spacePtr-&gt;prepare( 1, event, limitPTmaxISR);</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :     if (doSecondHard &amp;&amp; doFSRduringProcess) timesPtr-&gt;prepare( 1, event,</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :        limitPTmaxFSR);</span>
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span>            :     // Impact parameter has now been chosen, except for diffraction.
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :     if (!isDiff) infoPtr-&gt;setImpact( multiPtr-&gt;bMPI(),</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :       multiPtr-&gt;enhanceMPI(), true);</span>
<span class="lineNum">     459 </span>            :     // Set up initial veto scale.
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :     doVeto        = false;</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :     double pTveto = pTvetoPT;</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :     typeLatest    = 0;</span>
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span>            :     // Begin evolution down in pT from hard pT scale.
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :     do {</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :       infoPtr-&gt;addCounter(22);</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :       typeVetoStep = 0;</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :       nRad         =  nISR + nFSRinProc;</span>
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span>            :       // Find next pT value for FSR, MPI and ISR.
<span class="lineNum">     471 </span>            :       // Order calls to minimize time expenditure.
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :       double pTgen = 0.;</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :       double pTtimes = (doFSRduringProcess)</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :         ? timesPtr-&gt;pTnext( event, pTmaxFSR, pTgen, isFirstTrial) : -1.;</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :       pTgen = max( pTgen, pTtimes);</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :       double pTmulti = (doMPI)</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :         ? multiPtr-&gt;pTnext( pTmaxMPI, pTgen, event) : -1.;</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :       pTgen = max( pTgen, pTmulti);</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :       double pTspace = (doISR)</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :         ? spacePtr-&gt;pTnext( event, pTmaxISR, pTgen, nRad) : -1.;</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :       double pTnow = max( pTtimes, max( pTmulti, pTspace));</span>
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span>            :       // Update information.
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :       infoPtr-&gt;setPTnow( pTnow);</span>
<span class="lineNum">     485 </span>            :       isFirstTrial = false;
<span class="lineNum">     486 </span>            : 
<span class="lineNum">     487 </span>            :       // Allow a user veto. Only do it once, so remember to change pTveto.
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :       if (pTveto &gt; 0. &amp;&amp; pTveto &gt; pTnow) {</span>
<span class="lineNum">     489 </span>            :         pTveto = -1.;
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :         doVeto = userHooksPtr-&gt;doVetoPT( typeLatest, event);</span>
<span class="lineNum">     491 </span>            :         // Abort event if vetoed.
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :         if (doVeto) {</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :           if (isDiff) leaveResolvedDiff( iHardLoop, process, event);</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">     495 </span>            :         }
<span class="lineNum">     496 </span>            :       }
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span>            :       // Do a multiparton interaction (if allowed).
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :       if (pTmulti &gt; 0. &amp;&amp; pTmulti &gt; pTspace &amp;&amp; pTmulti &gt; pTtimes) {</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :         infoPtr-&gt;addCounter(23);</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :         if (multiPtr-&gt;scatter( event)) {</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :           typeLatest = 1;</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :           ++nMPI;</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :           if (canVetoMPIStep &amp;&amp; nMPI &lt;= nVetoMPIStep) typeVetoStep = 1;</span>
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span>            :           // Break for exclusive hard diffraction with MPI veto.
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :           if (isHardDiff &amp;&amp; sampleTypeDiff == 4 &amp;&amp; iHardDiffLoop == 1) {</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :             infoPtr-&gt;setHardDiff( false, false, false, 0., 0., 0., 0.);</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :             doDiffVeto = true;</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     511 </span>            :           }
<span class="lineNum">     512 </span>            : 
<span class="lineNum">     513 </span>            :           // Update ISR and FSR dipoles.
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :           if (doISR)              spacePtr-&gt;prepare( nMPI - 1, event);</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :           if (doFSRduringProcess) timesPtr-&gt;prepare( nMPI - 1, event);</span>
<span class="lineNum">     516 </span>            :         }
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span>            :         // Set maximal scales for next pT to pick.
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :         pTmaxMPI = pTmulti;</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :         pTmaxISR = min(pTmulti, pTmaxISR);</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :         pTmaxFSR = min(pTmulti, pTmaxFSR);</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :         pTmax    = pTmulti;</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :         nBranch++;</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :         pTLastBranch = pTmulti;</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :         typeLastBranch = 1;</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     527 </span>            : 
<span class="lineNum">     528 </span>            :       // Do an initial-state emission (if allowed).
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :       else if (pTspace &gt; 0. &amp;&amp; pTspace &gt; pTtimes) {</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :         infoPtr-&gt;addCounter(24);</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :         if (spacePtr-&gt;branch( event)) {</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :           typeLatest = 2;</span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :           iSysNow = spacePtr-&gt;system();</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :           ++nISR;</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :           if (iSysNow == 0) ++nISRhard;</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :           if (canVetoStep &amp;&amp; iSysNow == 0 &amp;&amp; nISRhard &lt;= nVetoStep)</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :             typeVetoStep = 2;</span>
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span>            :           // Update FSR dipoles.
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :           if (doFSRduringProcess) timesPtr-&gt;update( iSysNow, event,</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :             spacePtr-&gt;getHasWeaklyRadiated());</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :           nBranch++;</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :           pTLastBranch = pTspace;</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :           typeLastBranch = 2;</span>
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span>            :         // Rescatter: it is possible for kinematics to fail, in which
<span class="lineNum">     547 </span>            :         //            case we need to restart the parton level processing.
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :         } else if (spacePtr-&gt;doRestart()) {</span>
<span class="lineNum">     549 </span>            :           physical = false;
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     551 </span>            :         }
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span>            :         // Set maximal scales for next pT to pick.
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :         pTmaxMPI = min(pTspace, pTmaxMPI);</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :         pTmaxISR = pTspace;</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :         pTmaxFSR = min(pTspace, pTmaxFSR);</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :         pTmax    = pTspace;</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span>            :       // Do a final-state emission (if allowed).
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :       else if (pTtimes &gt; 0.) {</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :         infoPtr-&gt;addCounter(25);</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :         if (timesPtr-&gt;branch( event, true)) {</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :           typeLatest = 3;</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :           iSysNow = timesPtr-&gt;system();</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :           ++nFSRinProc;</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :           if (iSysNow == 0) ++nFSRhard;</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :           if (canVetoStep &amp;&amp; iSysNow == 0 &amp;&amp; nFSRhard &lt;= nVetoStep)</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :             typeVetoStep = 3;</span>
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span>            :           // Update ISR dipoles.
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :           if (doISR) spacePtr-&gt;update( iSysNow, event,</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :             timesPtr-&gt;getHasWeaklyRadiated());</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :           nBranch++;</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :           pTLastBranch = pTtimes;</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :           typeLastBranch = 3;</span>
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span>            :         // Set maximal scales for next pT to pick.
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :         pTmaxMPI = min(pTtimes, pTmaxMPI);</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :         pTmaxISR = min(pTtimes, pTmaxISR);</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :         pTmaxFSR = pTtimes;</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :         pTmax    = pTtimes;</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span>            :       // If no pT scales above zero then nothing to be done.
<span class="lineNum">     588 </span>            :       else pTmax = 0.;
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span>            :       // Check for double counting for Drell-Yan weak production.
<span class="lineNum">     591 </span>            :       // Only look at the second emission.
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :       if ( (infoPtr-&gt;code() == 221 || infoPtr-&gt;code() == 222) &amp;&amp;</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :             nISRhard + nFSRhard == 2 &amp;&amp; vetoWeakJets) {</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :         int id1 = event[partonSystemsPtr-&gt;getOut(0,0)].id();</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :         int id2 = event[partonSystemsPtr-&gt;getOut(0,1)].id();</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :         int id3 = event[partonSystemsPtr-&gt;getOut(0,2)].id();</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :         Vec4 p1 = event[partonSystemsPtr-&gt;getOut(0,0)].p();</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :         Vec4 p2 = event[partonSystemsPtr-&gt;getOut(0,1)].p();</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :         Vec4 p3 = event[partonSystemsPtr-&gt;getOut(0,2)].p();</span>
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span>            :         // Make sure id1 is weak boson, and check that there
<span class="lineNum">     602 </span>            :         // only is a single weak boson and no photons.
<span class="lineNum">     603 </span>            :         bool doubleCountEvent = true;
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :         if (abs(id1) == 24 || abs(id1) == 23) {</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :           if (abs(id2) &gt; 21 || abs(id3) &gt; 21)</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :             doubleCountEvent = false;</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :         } else if (abs(id2) == 24 || abs(id2) == 23) {</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :           swap(id1,id2);</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :           swap(p1,p2);</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :           if (abs(id3) &gt; 21)</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :             doubleCountEvent = false;</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :         } else if ( abs(id3) == 24 || abs(id3) == 23) {</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :           swap(id1,id3);</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :           swap(p1,p3);</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :         if (doubleCountEvent) {</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :           double d = p1.pT2();</span>
<span class="lineNum">     619 </span>            :           bool cut = true;
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :           if (p2.pT2() &lt; d) {d = p2.pT2(); cut = false;}</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :           if (p3.pT2() &lt; d) {d = p3.pT2(); cut = false;}</span>
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span>            :           // Check for angle between weak boson and quarks.
<span class="lineNum">     624 </span>            :           // (require final state particle to be a fermion)
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :           if (abs(id2) &lt; 20) {</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :             double dij = min(p1.pT2(),p2.pT2())</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :               * pow2(RRapPhi(p1,p2)) / vetoWeakDeltaR2;</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :             if (dij &lt; d) {</span>
<span class="lineNum">     629 </span>            :               d = dij;
<span class="lineNum">     630 </span>            :               cut = true;
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :           if (abs(id3) &lt; 20) {</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :             double dij = min(p1.pT2(),p3.pT2())</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :               * pow2(RRapPhi(p1,p3)) / vetoWeakDeltaR2;</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :             if (dij &lt; d) {</span>
<span class="lineNum">     638 </span>            :               d = dij;
<span class="lineNum">     639 </span>            :               cut = true;
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span>            :           // Check for angle between recoiler and radiator,
<span class="lineNum">     644 </span>            :           // if it is a quark anti-quark pair
<span class="lineNum">     645 </span>            :           // or if the recoiler is a gluon.
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :           if (abs(id2) == 21 || abs(id3) == 21 || id2 == - id3) {</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :             double dij = min(p2.pT2(),p3.pT2())</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :               * pow2(RRapPhi(p2,p3)) / vetoWeakDeltaR2;</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :             if (dij &lt; d) {</span>
<span class="lineNum">     650 </span>            :               d = dij;
<span class="lineNum">     651 </span>            :               cut = false;
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">     654 </span>            : 
<span class="lineNum">     655 </span>            :           // Veto event if it does not belong to Drell-Yan production.
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :           if (cut) return false;</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span>            :       // Optionally check for a veto after the first few interactions,
<span class="lineNum">     661 </span>            :       // or after the first few emissions, ISR or FSR, in the hardest system.
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :       if (typeVetoStep == 1) {</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :         doVeto = userHooksPtr-&gt;doVetoMPIStep( nMPI, event);</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :       } else if (typeVetoStep &gt; 1) {</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :         doVeto = userHooksPtr-&gt;doVetoStep( typeVetoStep, nISRhard,</span>
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :           nFSRhard, event);</span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     668 </span>            : 
<span class="lineNum">     669 </span>            :       // Abort event if vetoed.
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :       if (doVeto) {</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :         if (isDiff) leaveResolvedDiff( iHardLoop, process, event);</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     673 </span>            :       }
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span>            :       // Keep on evolving until nothing is left to be done.
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :       if (typeLatest &gt; 0 &amp;&amp; typeLatest &lt; 4)</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :         infoPtr-&gt;addCounter(25 + typeLatest);</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :       if (!isDiff) infoPtr-&gt;setPartEvolved( nMPI, nISR);</span>
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span>            :       // Handle potential merging veto.
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :       if ( canRemoveEvent &amp;&amp; nISRhard + nFSRhard == 1 ){</span>
<span class="lineNum">     682 </span>            :         // Simply check, and possibly reset weights.
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :         mergingHooksPtr-&gt;doVetoStep( process, event );</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span>            :     // End loop evolution down in pT from hard pT scale.
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :     } while (pTmax &gt; 0.  &amp;&amp; (nBranchMax &lt;= 0 || nBranch &lt; nBranchMax) );</span>
<span class="lineNum">     688 </span>            : 
<span class="lineNum">     689 </span>            :     // Do all final-state emissions if not already considered above.
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :     if (doFSRafterProcess &amp;&amp; (nBranchMax &lt;= 0 || nBranch &lt; nBranchMax) ) {</span>
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span>            :       // Find largest scale for final partons.
<span class="lineNum">     693 </span>            :       pTmax = 0.;
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :       for (int i = 0; i &lt; event.size(); ++i)</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :         if (event[i].isFinal() &amp;&amp; event[i].scale() &gt; pTmax)</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :           pTmax = event[i].scale();</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :       pTsaveFSR = pTmax;</span>
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span>            :       // Prepare all subsystems for evolution.
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :       for (int iSys = 0; iSys &lt; partonSystemsPtr-&gt;sizeSys(); ++iSys)</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :         timesPtr-&gt;prepare( iSys, event);</span>
<span class="lineNum">     702 </span>            : 
<span class="lineNum">     703 </span>            :       // Set up initial veto scale.
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :       doVeto = false;</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :       pTveto = pTvetoPT;</span>
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span>            :       // Begin evolution down in pT from hard pT scale.
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :       do {</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :         infoPtr-&gt;addCounter(29);</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :         typeVetoStep = 0;</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :         double pTtimes = timesPtr-&gt;pTnext( event, pTmax, 0.);</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :         infoPtr-&gt;setPTnow( pTtimes);</span>
<span class="lineNum">     713 </span>            : 
<span class="lineNum">     714 </span>            :         // Allow a user veto. Only do it once, so remember to change pTveto.
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :         if (pTveto &gt; 0. &amp;&amp; pTveto &gt; pTtimes) {</span>
<span class="lineNum">     716 </span>            :           pTveto = -1.;
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :           doVeto = userHooksPtr-&gt;doVetoPT( 4, event);</span>
<span class="lineNum">     718 </span>            :           // Abort event if vetoed.
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :           if (doVeto) {</span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :             if (isDiff) leaveResolvedDiff( iHardLoop, process, event);</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     722 </span>            :           }
<span class="lineNum">     723 </span>            :         }
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span>            :         // Do a final-state emission (if allowed).
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :         if (pTtimes &gt; 0.) {</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :           infoPtr-&gt;addCounter(30);</span>
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :           if (timesPtr-&gt;branch( event, true)) {</span>
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :             iSysNow = timesPtr-&gt;system();</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :             ++nFSRinProc;</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :             if (iSysNow == 0) ++nFSRhard;</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :             if (canVetoStep &amp;&amp; iSysNow == 0 &amp;&amp; nFSRhard &lt;= nVetoStep)</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :             typeVetoStep = 4;</span>
<span class="lineNum">     734 </span>            : 
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :             nBranch++;</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :             pTLastBranch = pTtimes;</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :             typeLastBranch = 4;</span>
<span class="lineNum">     738 </span>            : 
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">     740 </span>            :           pTmax = pTtimes;
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span>            :         // If no pT scales above zero then nothing to be done.
<span class="lineNum">     744 </span>            :         else pTmax = 0.;
<span class="lineNum">     745 </span>            : 
<span class="lineNum">     746 </span>            :         // Optionally check for a veto after the first few emissions.
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :         if (typeVetoStep &gt; 0) {</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :           doVeto = userHooksPtr-&gt;doVetoStep( typeVetoStep, nISRhard,</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :             nFSRhard, event);</span>
<span class="lineNum">     750 </span>            :           // Abort event if vetoed.
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :           if (doVeto) {</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :             if (isDiff) leaveResolvedDiff( iHardLoop, process, event);</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     754 </span>            :           }
<span class="lineNum">     755 </span>            :         }
<span class="lineNum">     756 </span>            : 
<span class="lineNum">     757 </span>            :         // Handle potential merging veto.
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :         if ( canRemoveEvent &amp;&amp; nISRhard + nFSRhard == 1 ){</span>
<span class="lineNum">     759 </span>            :           // Simply check, and possibly reset weights.
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :           mergingHooksPtr-&gt;doVetoStep( process, event );</span>
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span>            :         // Keep on evolving until nothing is left to be done.
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :         infoPtr-&gt;addCounter(31);</span>
<span class="lineNum">     765 </span>            : 
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :       } while (pTmax &gt; 0.  &amp;&amp; (nBranchMax &lt;= 0 || nBranch &lt; nBranchMax) );</span>
<span class="lineNum">     767 </span>            :     }
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span>            :     // Handle veto after ISR + FSR + MPI, but before beam remnants
<span class="lineNum">     770 </span>            :     // and resonance decays, e.g. for MLM matching.
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :     if (canVetoEarly &amp;&amp; userHooksPtr-&gt;doVetoPartonLevelEarly( event)) {</span>
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :       doVeto = true;</span>
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :       if (isDiff) leaveResolvedDiff( iHardLoop, process, event);</span>
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     775 </span>            :     }
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span>            :     // Perform showers in resonance decay chains before beams &amp; reconnection.
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :     if (earlyResDec) {</span>
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :       int oldSizeEvt = event.size();</span>
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :       int oldSizeSys = partonSystemsPtr-&gt;sizeSys();</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :       if (nBranchMax &lt;= 0 || nBranch &lt; nBranchMax)</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :         doVeto = !resonanceShowers( process, event, true);</span>
<span class="lineNum">     783 </span>            :       // Abort event if vetoed.
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :       if (doVeto) return false;</span>
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span>            :       // Reassign new decay products to original system.
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :       for (int iSys = oldSizeSys; iSys &lt; partonSystemsPtr-&gt;sizeSys(); ++iSys)</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :         for (int iOut = 0; iOut &lt; partonSystemsPtr-&gt;sizeOut(iSys); ++iOut)</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :           partonSystemsPtr-&gt;addOut(0, partonSystemsPtr-&gt;getOut( iSys, iOut) );</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :       partonSystemsPtr-&gt;setSizeSys( oldSizeSys);</span>
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span>            :       // Perform decays and showers of W and Z emitted in shower.
<span class="lineNum">     793 </span>            :       // To do:check if W/Z emission is on in ISR or FSR??
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :       if (!wzDecayShowers( event)) return false;</span>
<span class="lineNum">     795 </span>            : 
<span class="lineNum">     796 </span>            :       // User hook to reconnect colours specifically in resonance decays.
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :       if (canReconResSys &amp;&amp; !userHooksPtr-&gt;doReconnectResonanceSystems(</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :         oldSizeEvt, event)) return false;</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span>            :     // Find the first particle in the current diffractive system.
<span class="lineNum">     802 </span>            :     int  iFirst    = 0;
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :     if (isDiff) {</span>
<span class="lineNum">     804 </span>            :       doDiffCR = isDiff;
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :       iFirst    = (iHardLoop == 1) ? 5 + sizeEvent - sizeProcess : sizeEvent;</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :       if (isDiffC) iFirst = 6 + sizeEvent - sizeProcess;</span>
<span class="lineNum">     807 </span>            :     }
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span>            :     // Change the first particle for hard diffraction.
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :     if (sampleTypeDiff == 1 || sampleTypeDiff == 3 || iHardDiffLoop == 2) {</span>
<span class="lineNum">     811 </span>            :       doDiffCR = true;
<span class="lineNum">     812 </span>            :       iFirst    = 5;
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     814 </span>            : 
<span class="lineNum">     815 </span>            :     // Add beam remnants, including primordial kT kick and colour tracing.
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :     if (!doTrial &amp;&amp; physical &amp;&amp; doRemnants</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :       &amp;&amp; !remnants.add( event, iFirst, doDiffCR)) physical = false;</span>
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span>            :     // If no problems then done.
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :     if (physical) break;</span>
<span class="lineNum">     821 </span>            : 
<span class="lineNum">     822 </span>            :     // Else restore and loop, but do not throw existing diffractive system.
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :     if (!isDiff) event.clear();</span>
<span class="lineNum">     824 </span>            :     else {
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :       event.restoreSize();</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :       event.restoreJunctionSize();</span>
<span class="lineNum">     827 </span>            :     }
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :     beamAPtr-&gt;clear();</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :     beamBPtr-&gt;clear();</span>
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :     partonSystemsPtr-&gt;clear();</span>
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span>            :   // End loop over ten tries. Restore from diffraction. Hopefully it worked.
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :   if (isDiff) leaveResolvedDiff( iHardLoop, process, event);</span>
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :   if (!physical) {</span>
<span class="lineNum">     836 </span>            :     // Leave hard diffractive system properly if beam remnant failed.
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :     if (isHardDiff) leaveHardDiff( process, event);</span>
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     839 </span>            :   }
<span class="lineNum">     840 </span>            : 
<span class="lineNum">     841 </span>            :   // End big outer loop to handle two systems in double diffraction.
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     843 </span>            : 
<span class="lineNum">     844 </span>            :   // If no additional MPI has been found then set up the diffractive
<span class="lineNum">     845 </span>            :   // system the first time around.
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :   if (isHardDiff &amp;&amp; (sampleTypeDiff == 2 || sampleTypeDiff == 4) &amp;&amp;</span>
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :     iHardDiffLoop == 1 &amp;&amp; nMPI == 1) {</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :     event.clear();</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :     beamAPtr-&gt;clear();</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :     beamBPtr-&gt;clear();</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :     partonSystemsPtr-&gt;clear();</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :     setupHardDiff( process);</span>
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :     continue;</span>
<span class="lineNum">     854 </span>            :   }
<span class="lineNum">     855 </span>            : 
<span class="lineNum">     856 </span>            :   // Do colour reconnection for non-diffractive events before resonance decays.
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :   if (doReconnect &amp;&amp; !doDiffCR &amp;&amp; reconnectMode &gt; 0) {</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :     Event eventSave = event;</span>
<span class="lineNum">     859 </span>            :     bool colCorrect = false;
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; 10; ++i) {</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :       colourReconnection.next(event, 0);</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :       if (junctionSplitting.checkColours(event)) {</span>
<span class="lineNum">     863 </span>            :         colCorrect = true;
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     865 </span>            :       }
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :       else event = eventSave;</span>
<span class="lineNum">     867 </span>            :     }
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :     if (!colCorrect) {</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :       infoPtr-&gt;errorMsg(&quot;Error in PartonLevel::next: &quot;</span>
<span class="lineNum">     870 </span>            :         &quot;Colour reconnection failed.&quot;);
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     872 </span>            :     }
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     874 </span>            : 
<span class="lineNum">     875 </span>            :   // Perform showers in resonance decay chains after beams &amp; reconnection.
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :   int oldSizeEvt = event.size();</span>
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :   if (!earlyResDec) {</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :     if (nBranchMax &lt;= 0 || nBranch &lt; nBranchMax)</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :       doVeto = !resonanceShowers( process, event, true);</span>
<span class="lineNum">     880 </span>            :     // Abort event if vetoed.
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :     if (doVeto) return false;</span>
<span class="lineNum">     882 </span>            : 
<span class="lineNum">     883 </span>            :     // Perform decays and showers of W and Z emitted in shower.
<span class="lineNum">     884 </span>            :     // To do:check if W/Z emission is on in ISR or FSR??
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :     if (!wzDecayShowers( event)) return false;</span>
<span class="lineNum">     886 </span>            : 
<span class="lineNum">     887 </span>            :     // User hook to reconnect colours specifically in resonance decays.
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :     if (canReconResSys &amp;&amp; !userHooksPtr-&gt;doReconnectResonanceSystems(</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :       oldSizeEvt, event)) return false;</span>
<span class="lineNum">     890 </span>            :   }
<span class="lineNum">     891 </span>            : 
<span class="lineNum">     892 </span>            :   // Store event properties. Not available for diffraction.
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :   if (!isDiff) infoPtr-&gt;setEvolution( pTsaveMPI, pTsaveISR, pTsaveFSR,</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :     nMPI, nISR, nFSRinProc, nFSRinRes);</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :   if (isDiff) {</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :     multiPtr-&gt;setEmpty();</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :     infoPtr-&gt;setImpact( multiPtr-&gt;bMPI(), multiPtr-&gt;enhanceMPI(), false);</span>
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     899 </span>            : 
<span class="lineNum">     900 </span>            : 
<span class="lineNum">     901 </span>            :   // Do colour reconnection for resonance decays.
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :   if (!earlyResDec &amp;&amp; forceResonanceCR &amp;&amp; doReconnect &amp;&amp;</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :       !doDiffCR &amp;&amp; reconnectMode != 0) {</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :     Event eventSave = event;</span>
<span class="lineNum">     905 </span>            :     bool colCorrect = false;
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; 10; ++i) {</span>
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :       colourReconnection.next(event, oldSizeEvt);</span>
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :       if (junctionSplitting.checkColours(event)) {</span>
<span class="lineNum">     909 </span>            :         colCorrect = true;
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     911 </span>            :       }
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :       else event = eventSave;</span>
<span class="lineNum">     913 </span>            :     }
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :     if (!colCorrect) {</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :       infoPtr-&gt;errorMsg(&quot;Error in PartonLevel::next: &quot;</span>
<span class="lineNum">     916 </span>            :         &quot;Colour reconnection failed.&quot;);
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     918 </span>            :     }
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     920 </span>            : 
<span class="lineNum">     921 </span>            :   // Leave diffractive events.
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :   if (isHardDiff) {</span>
<span class="lineNum">     923 </span>            : 
<span class="lineNum">     924 </span>            :     // If inclusive sample wanted for MPI veto and nMPI &gt; 1
<span class="lineNum">     925 </span>            :     // then event is non-diffractive and we can break the loop.
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :     if (sampleTypeDiff == 2 &amp;&amp; iHardDiffLoop == 1 &amp;&amp; nMPI &gt; 1) {</span>
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :       infoPtr-&gt;setHardDiff( false, false, false, 0., 0., 0., 0.);</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     929 </span>            :     }
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span>            :     // Leave diffractive system properly.
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :     if (sampleTypeDiff == 1 || sampleTypeDiff == 3 || iHardDiffLoop == 2)</span>
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :       leaveHardDiff( process, event);</span>
<span class="lineNum">     934 </span>            :   }
<span class="lineNum">     935 </span>            : 
<span class="lineNum">     936 </span>            :   // End big outer loop to handle the setup of the diffractive system.
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     938 </span>            : 
<span class="lineNum">     939 </span>            :   // Done.
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">     941 </span>            : 
<span class="lineNum">     942 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     943 </span>            : 
<span class="lineNum">     944 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     945 </span>            : 
<a name="946"><span class="lineNum">     946 </span>            : // Decide which diffractive subsystems are resolved (= perturbative).</a>
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span>            : int PartonLevel::decideResolvedDiff( Event&amp; process) {
<span class="lineNum">     949 </span>            : 
<span class="lineNum">     950 </span>            :   // Loop over two systems.
<span class="lineNum">     951 </span>            :   int nHighMass = 0;
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :   int iDSmin    = (isDiffC) ? 3 : 1;</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :   int iDSmax    = (isDiffC) ? 3 : 2;</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :   for (int iDSnow = iDSmin; iDSnow &lt;= iDSmax; ++iDSnow) {</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :     int iDiffMot = iDSnow + 2;</span>
<span class="lineNum">     956 </span>            : 
<span class="lineNum">     957 </span>            :     // Only high-mass diffractive systems should be resolved.
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :     double mDiff = process[iDiffMot].m();</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :     bool isHighMass = ( mDiff &gt; mMinDiff &amp;&amp; rndmPtr-&gt;flat()</span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :       &lt; pMaxDiff * ( 1. - exp( -(mDiff - mMinDiff) / mWidthDiff ) ) );</span>
<span class="lineNum">     961 </span>            : 
<span class="lineNum">     962 </span>            :     // Set outcome and done.
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :     if (isHighMass) ++nHighMass;</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :     if (iDSnow == 1) isResolvedA = isHighMass;</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :     if (iDSnow == 2) isResolvedB = isHighMass;</span>
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :     if (iDSnow == 3) isResolvedC = isHighMass;</span>
<span class="lineNum">     967 </span>            :   }
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :   return nHighMass;</span>
<span class="lineNum">     969 </span>            : 
<span class="lineNum">     970 </span>            : }
<span class="lineNum">     971 </span>            : 
<span class="lineNum">     972 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     973 </span>            : 
<a name="974"><span class="lineNum">     974 </span>            : // Set up an unresolved process, i.e. elastic or diffractive.</a>
<span class="lineNum">     975 </span>            : 
<span class="lineNum">     976 </span>            : bool PartonLevel::setupUnresolvedSys( Event&amp; process, Event&amp; event) {
<span class="lineNum">     977 </span>            : 
<span class="lineNum">     978 </span>            :   // No hard scale in event.
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :   process.scale( 0.);</span>
<span class="lineNum">     980 </span>            : 
<span class="lineNum">     981 </span>            :   // Copy particles from process to event.
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; process.size(); ++ i) event.append( process[i]);</span>
<span class="lineNum">     983 </span>            : 
<span class="lineNum">     984 </span>            :   // Loop to find diffractively excited beams.
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :   for (iDS = 1; iDS &lt; 4; ++iDS)</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :   if ( (iDS == 1 &amp;&amp; isDiffA &amp;&amp; !isResolvedA)</span>
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :     || (iDS == 2 &amp;&amp; isDiffB &amp;&amp; !isResolvedB)</span>
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :     || (iDS == 3 &amp;&amp; isDiffC &amp;&amp; !isResolvedC) ) {</span>
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :     int iBeam = iDS + 2;</span>
<span class="lineNum">     990 </span>            : 
<span class="lineNum">     991 </span>            :     // Diffractive mass. Boost and rotation from diffractive system
<span class="lineNum">     992 </span>            :     // rest frame, aligned along z axis, to event cm frame.
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :     double mDiff  = process[iBeam].m();</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :     double m2Diff = mDiff * mDiff;</span>
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :     Vec4 pDiffA   = (iDS == 1) ? process[1].p()</span>
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :                                : process[1].p() - process[3].p();</span>
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :     Vec4 pDiffB   = (iDS == 2) ? process[2].p()</span>
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :                                : process[2].p() - process[4].p();</span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :     RotBstMatrix MtoCM;</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :     MtoCM.fromCMframe( pDiffA, pDiffB);</span>
<span class="lineNum">    1001 </span>            : 
<span class="lineNum">    1002 </span>            :     // Beam Particle used for flavour content kicked out by Pomeron.
<span class="lineNum">    1003 </span>            :     // Randomize for central diffraction; misses closed gluon loop case.
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :     bool beamSideA = (iDS == 1 || (iDS == 3 &amp;&amp; rndmPtr-&gt;flat() &lt; 0.5));</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :     BeamParticle* beamPtr = (beamSideA) ? beamAPtr    : beamBPtr;</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :     if (iDS == 3) beamPtr = (beamSideA) ? beamPomAPtr : beamPomBPtr;</span>
<span class="lineNum">    1007 </span>            : 
<span class="lineNum">    1008 </span>            :     // Pick quark or gluon kicked out and flavour subdivision.
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :     beamPtr-&gt;newValenceContent();</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :     bool gluonIsKicked = beamPtr-&gt;pickGluon(mDiff);</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :     int id1 = beamPtr-&gt;pickValence();</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :     int id2 = beamPtr-&gt;pickRemnant();</span>
<span class="lineNum">    1013 </span>            : 
<span class="lineNum">    1014 </span>            :     // Find flavour masses. Scale them down if too big.
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :     double m1 = particleDataPtr-&gt;constituentMass(id1);</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :     double m2 = particleDataPtr-&gt;constituentMass(id2);</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :     if (m1 + m2 &gt; 0.5 * mDiff) {</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :       double reduce = 0.5 * mDiff / (m1 + m2);</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :       m1 *= reduce;</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :       m2 *= reduce;</span>
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1022 </span>            : 
<span class="lineNum">    1023 </span>            :     // If quark is kicked out, then trivial kinematics in rest frame.
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :     if (!gluonIsKicked) {</span>
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :       double pAbs = sqrt( pow2(m2Diff - m1*m1 - m2*m2)</span>
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :         - pow2(2. * m1 * m2) ) / (2. * mDiff);</span>
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :       if (!beamSideA) pAbs = -pAbs;</span>
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :       double e1 = (m2Diff + m1*m1 - m2*m2) / (2. * mDiff);</span>
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :       double e2 = (m2Diff + m2*m2 - m1*m1) / (2. * mDiff);</span>
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :       Vec4 p1( 0., 0., -pAbs, e1);</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :       Vec4 p2( 0., 0.,  pAbs, e2);</span>
<span class="lineNum">    1032 </span>            : 
<span class="lineNum">    1033 </span>            :       // Boost and rotate to event cm frame.
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :       p1.rotbst( MtoCM);</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :       p2.rotbst( MtoCM);</span>
<span class="lineNum">    1036 </span>            : 
<span class="lineNum">    1037 </span>            :       // Set colours.
<span class="lineNum">    1038 </span>            :       int col1, acol1, col2, acol2;
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :       if (particleDataPtr-&gt;colType(id1) == 1) {</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :         col1  = event.nextColTag();</span>
<span class="lineNum">    1041 </span>            :         acol1 = 0;
<span class="lineNum">    1042 </span>            :         col2  = 0;
<span class="lineNum">    1043 </span>            :         acol2 = col1;
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :       } else {</span>
<span class="lineNum">    1045 </span>            :         col1  = 0;
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :         acol1 = event.nextColTag();</span>
<span class="lineNum">    1047 </span>            :         col2  = acol1;
<span class="lineNum">    1048 </span>            :         acol2 = 0;
<span class="lineNum">    1049 </span>            :       }
<span class="lineNum">    1050 </span>            :      // Update process colours to stay in step.
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :       process.nextColTag();</span>
<span class="lineNum">    1052 </span>            : 
<span class="lineNum">    1053 </span>            :       // Store partons of diffractive system and mark system decayed.
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :       int iDauBeg = event.append( id1, 24, iBeam, 0, 0, 0, col1, acol1,</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :         p1, m1);</span>
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :       int iDauEnd = event.append( id2, 63, iBeam, 0, 0, 0, col2, acol2,</span>
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :         p2, m2);</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :       event[iBeam].statusNeg();</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :       event[iBeam].daughters(iDauBeg, iDauEnd);</span>
<span class="lineNum">    1060 </span>            : 
<span class="lineNum">    1061 </span>            :     // If gluon is kicked out: share momentum between two remnants.
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">    1063 </span>            :       double m2Sys, zSys, pxSys, pySys, mTS1, mTS2;
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :       zSys = beamPtr-&gt;zShare(mDiff, m1, m2);</span>
<span class="lineNum">    1065 </span>            : 
<span class="lineNum">    1066 </span>            :       // Provide relative pT kick in remnant. Construct (transverse) masses.
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :       pxSys = beamPtr-&gt;pxShare();</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :       pySys = beamPtr-&gt;pyShare();</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :       mTS1  = m1*m1 + pxSys*pxSys + pySys*pySys;</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :       mTS2  = m2*m2 + pxSys*pxSys + pySys*pySys;</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :       m2Sys = mTS1 / zSys + mTS2 / (1. - zSys);</span>
<span class="lineNum">    1072 </span>            : 
<span class="lineNum">    1073 </span>            :       // Momentum of kicked-out massless gluon in diffractive rest frame.
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :       double pAbs  = (m2Diff - m2Sys) / (2. * mDiff);</span>
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :       double pLRem = (beamSideA) ? pAbs : -pAbs;</span>
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :       Vec4 pG(  0., 0., -pLRem, pAbs);</span>
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :       Vec4 pRem(0., 0.,  pLRem, mDiff - pAbs);</span>
<span class="lineNum">    1078 </span>            : 
<span class="lineNum">    1079 </span>            :       // Momenta of the two beam remnant flavours. (Lightcone p+ = m_diff!)
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :       double e1 = 0.5 * (zSys * mDiff + mTS1 / (zSys * mDiff));</span>
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :       double pL1 = 0.5 * (zSys * mDiff - mTS1 / (zSys * mDiff));</span>
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :       if (!beamSideA) pL1 = -pL1;</span>
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :       Vec4 p1(pxSys, pySys, pL1, e1);</span>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :       Vec4 p2 = pRem - p1;</span>
<span class="lineNum">    1085 </span>            : 
<span class="lineNum">    1086 </span>            :       // Boost and rotate to event cm frame. Improve precision.
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :       pG.rotbst( MtoCM);</span>
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :       p1.rotbst( MtoCM);</span>
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :       p2.rotbst( MtoCM);</span>
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :       pG.e( pG.pAbs());</span>
<span class="lineNum">    1091 </span>            : 
<span class="lineNum">    1092 </span>            :       // Set colours.
<span class="lineNum">    1093 </span>            :       int colG, acolG, col1, acol1, col2, acol2;
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :       if (particleDataPtr-&gt;colType(id1) == 1) {</span>
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :         col1  = event.nextColTag();</span>
<span class="lineNum">    1096 </span>            :         acol1 = 0;
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :         colG  = event.nextColTag();</span>
<span class="lineNum">    1098 </span>            :         acolG = col1;
<span class="lineNum">    1099 </span>            :         col2  = 0;
<span class="lineNum">    1100 </span>            :         acol2 = colG;
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :       } else {</span>
<span class="lineNum">    1102 </span>            :         col1  = 0;
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :         acol1 = event.nextColTag();</span>
<span class="lineNum">    1104 </span>            :         colG  = acol1;
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :         acolG = event.nextColTag();</span>
<span class="lineNum">    1106 </span>            :         col2  = acolG;
<span class="lineNum">    1107 </span>            :         acol2 = 0;
<span class="lineNum">    1108 </span>            :       }
<span class="lineNum">    1109 </span>            :       // Update process colours to stay in step.
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :       process.nextColTag();</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :       process.nextColTag();</span>
<span class="lineNum">    1112 </span>            : 
<span class="lineNum">    1113 </span>            :       // Store partons of diffractive system and mark system decayed.
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :       int iDauBeg = event.append( 21, 24, iBeam, 0, 0, 0, colG, acolG, pG, 0.);</span>
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :       event.append( id1, 63, iBeam, 0, 0, 0, col1, acol1, p1, m1);</span>
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :       int iDauEnd = event.append( id2, 63, iBeam, 0, 0, 0, col2, acol2,</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :         p2, m2);</span>
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :       event[iBeam].statusNeg();</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :       event[iBeam].daughters(iDauBeg, iDauEnd);</span>
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1121 </span>            : 
<span class="lineNum">    1122 </span>            :   // End loop over beams. Done.
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    1125 </span>            : 
<span class="lineNum">    1126 </span>            : }
<span class="lineNum">    1127 </span>            : 
<span class="lineNum">    1128 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1129 </span>            : 
<a name="1130"><span class="lineNum">    1130 </span>            : // Set up the hard process(es), excluding subsequent resonance decays.</a>
<span class="lineNum">    1131 </span>            : 
<span class="lineNum">    1132 </span>            : void PartonLevel::setupHardSys( Event&amp; process, Event&amp; event) {
<span class="lineNum">    1133 </span>            : 
<span class="lineNum">    1134 </span>            :   // Incoming partons to hard process are stored in slots 3 and 4.
<span class="lineNum">    1135 </span>            :   int inS = 0;
<span class="lineNum">    1136 </span>            :   int inP = 3;
<span class="lineNum">    1137 </span>            :   int inM = 4;
<span class="lineNum">    1138 </span>            : 
<span class="lineNum">    1139 </span>            :   // Mother and last entry of diffractive system. Offset.
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :   int iDiffMot = iDS + 2;</span>
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :   int iDiffDau = process.size() - 1;</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :   int nOffset  = sizeEvent - sizeProcess;</span>
<span class="lineNum">    1143 </span>            : 
<span class="lineNum">    1144 </span>            :   // Corrected information for hard diffraction.
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :   if (isSetupDiff) {</span>
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :     iDiffMot = (isHardDiffB) ? 4 : 3;</span>
<span class="lineNum">    1147 </span>            :     inS      = iDiffMot;
<span class="lineNum">    1148 </span>            :     inP      = 7;
<span class="lineNum">    1149 </span>            :     inM      = 8;
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1151 </span>            : 
<span class="lineNum">    1152 </span>            :   // Resolved diffraction means more entries.
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :   if (isDiff) {</span>
<span class="lineNum">    1154 </span>            :     inS   = iDiffMot;
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :     inP   = iDiffDau - 3;</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :     inM   = iDiffDau - 2;</span>
<span class="lineNum">    1157 </span>            : 
<span class="lineNum">    1158 </span>            :     // Diffractively excited particle described as Pomeron-hadron beams.
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :     event[inS].statusNeg();</span>
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :     event[inS].daughters( inP - 2 + nOffset, inM - 2 + nOffset);</span>
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1162 </span>            : 
<span class="lineNum">    1163 </span>            :   // If two hard interactions then find where second begins.
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :   int iBeginSecond = process.size();</span>
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :   if (doSecondHard) {</span>
<span class="lineNum">    1166 </span>            :     iBeginSecond = 5;
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :     while (process[iBeginSecond].status() != -21) ++iBeginSecond;</span>
<span class="lineNum">    1168 </span>            :   }
<span class="lineNum">    1169 </span>            : 
<span class="lineNum">    1170 </span>            :   // If incoming partons are massive then recalculate to put them massless.
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :   if (process[inP].m() != 0. || process[inM].m() != 0.) {</span>
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :     double pPos = process[inP].pPos() + process[inM].pPos();</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :     double pNeg = process[inP].pNeg() + process[inM].pNeg();</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :     process[inP].pz( 0.5 * pPos);</span>
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :     process[inP].e(  0.5 * pPos);</span>
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 :     process[inP].m(  0.);</span>
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :     process[inM].pz(-0.5 * pNeg);</span>
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :     process[inM].e(  0.5 * pNeg);</span>
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :     process[inM].m(  0.);</span>
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1181 </span>            : 
<span class="lineNum">    1182 </span>            :   // Add incoming hard-scattering partons to list in beam remnants.
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :   double x1 = process[inP].pPos() / process[inS].m();</span>
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :   beamAPtr-&gt;append( inP + nOffset, process[inP].id(), x1);</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :   double x2 = process[inM].pNeg() / process[inS].m();</span>
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :   beamBPtr-&gt;append( inM + nOffset, process[inM].id(), x2);</span>
<span class="lineNum">    1187 </span>            : 
<span class="lineNum">    1188 </span>            :   // Scale. Find whether incoming partons are valence or sea. Store.
<span class="lineNum">    1189 </span>            :   // When an x-dependent matter profile is used with nonDiffractive,
<span class="lineNum">    1190 </span>            :   // trial interactions mean that the valence/sea choice has already
<span class="lineNum">    1191 </span>            :   // been made and should be restored here.
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :   double scale = process.scale();</span>
<span class="lineNum">    1193 </span>            :   int vsc1, vsc2;
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :   beamAPtr-&gt;xfISR( 0, process[inP].id(), x1, scale*scale);</span>
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :   if (isNonDiff &amp;&amp; (vsc1 = multiPtr-&gt;getVSC1()) != 0)</span>
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :     (*beamAPtr)[0].companion(vsc1);</span>
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :   else vsc1 = beamAPtr-&gt;pickValSeaComp();</span>
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :   beamBPtr-&gt;xfISR( 0, process[inM].id(), x2, scale*scale);</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :   if (isNonDiff &amp;&amp; (vsc2 = multiPtr-&gt;getVSC2()) != 0)</span>
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :     (*beamBPtr)[0].companion(vsc2);</span>
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :   else vsc2 = beamBPtr-&gt;pickValSeaComp();</span>
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :   bool isVal1 = (vsc1 == -3);</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :   bool isVal2 = (vsc2 == -3);</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :   infoPtr-&gt;setValence( isVal1, isVal2);</span>
<span class="lineNum">    1205 </span>            : 
<span class="lineNum">    1206 </span>            :   // Initialize info needed for subsequent sequential decays + showers.
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :   nHardDone = sizeProcess;</span>
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :   iPosBefShow.resize( process.size() );</span>
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :   fill( iPosBefShow.begin(), iPosBefShow.end(), 0);</span>
<span class="lineNum">    1210 </span>            : 
<span class="lineNum">    1211 </span>            :   // Add the beam and hard subprocess partons to the event record.
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :   for (int i = sizeProcess; i &lt; iBeginSecond; ++i) {</span>
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :     if (process[i].mother1() &gt; inM) break;</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :     int j = event.append(process[i]);</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :     iPosBefShow[i] = i;</span>
<span class="lineNum">    1216 </span>            : 
<span class="lineNum">    1217 </span>            :     // Offset history if process and event not in step.
<span class="lineNum">    1218 </span><span class="lineNoCov">          0 :     if (nOffset != 0) {</span>
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :       int iOrd = i - iBeginSecond + 7;</span>
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 :       if (iOrd == 1 || iOrd == 2)</span>
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :         event[j].offsetHistory( 0, 0, 0, nOffset);</span>
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :       else if (iOrd == 3 || iOrd == 4)</span>
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :         event[j].offsetHistory( 0, nOffset, 0, nOffset);</span>
<span class="lineNum">    1224 </span><span class="lineNoCov">          0 :       else if (iOrd == 5 || iOrd == 6)</span>
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :         event[j].offsetHistory( 0, nOffset, 0, 0);</span>
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1227 </span>            : 
<span class="lineNum">    1228 </span>            :     // Currently outgoing ones should not count as decayed.
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :     if (event[j].status() == -22) {</span>
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :       event[j].statusPos();</span>
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :       event[j].daughters(0, 0);</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1233 </span>            : 
<span class="lineNum">    1234 </span>            :     // Complete task of copying hard subsystem into event record.
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :     ++nHardDone;</span>
<span class="lineNum">    1236 </span>            :   }
<span class="lineNum">    1237 </span>            : 
<span class="lineNum">    1238 </span>            :   // Store participating partons as first set in list of all systems.
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :   partonSystemsPtr-&gt;addSys();</span>
<span class="lineNum">    1240 </span><span class="lineNoCov">          0 :   partonSystemsPtr-&gt;setInA(0, inP + nOffset);</span>
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :   partonSystemsPtr-&gt;setInB(0, inM + nOffset);</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :   for (int i = inM + 1; i &lt; nHardDone; ++i)</span>
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :     partonSystemsPtr-&gt;addOut(0, i + nOffset);</span>
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 :   partonSystemsPtr-&gt;setSHat( 0,</span>
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :     (event[inP + nOffset].p() + event[inM + nOffset].p()).m2Calc() );</span>
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 :   partonSystemsPtr-&gt;setPTHat( 0, scale);</span>
<span class="lineNum">    1247 </span>            : 
<span class="lineNum">    1248 </span>            :   // Identify second hard process where applicable.
<span class="lineNum">    1249 </span>            :   // Since internally generated incoming partons are guaranteed massless.
<span class="lineNum">    1250 </span><span class="lineNoCov">          0 :   if (doSecondHard) {</span>
<span class="lineNum">    1251 </span>            :     int inP2 = iBeginSecond;
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 :     int inM2 = iBeginSecond + 1;</span>
<span class="lineNum">    1253 </span>            : 
<span class="lineNum">    1254 </span>            :     // Add incoming hard-scattering partons to list in beam remnants.
<span class="lineNum">    1255 </span>            :     // Not valid if not in rest frame??
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :     x1 = process[inP2].pPos() / process[0].e();</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :     beamAPtr-&gt;append( inP2, process[inP2].id(), x1);</span>
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :     x2 = process[inM2].pNeg() / process[0].e();</span>
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :     beamBPtr-&gt;append( inM2, process[inM2].id(), x2);</span>
<span class="lineNum">    1260 </span>            : 
<span class="lineNum">    1261 </span>            :     // Find whether incoming partons are valence or sea.
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :     scale = process.scaleSecond();</span>
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :     beamAPtr-&gt;xfISR( 1, process[inP2].id(), x1, scale*scale);</span>
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :     beamAPtr-&gt;pickValSeaComp();</span>
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :     beamBPtr-&gt;xfISR( 1, process[inM2].id(), x2, scale*scale);</span>
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :     beamBPtr-&gt;pickValSeaComp();</span>
<span class="lineNum">    1267 </span>            : 
<span class="lineNum">    1268 </span>            :     // Add the beam and hard subprocess partons to the event record.
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :     for (int i = inP2; i &lt; process.size(); ++ i) {</span>
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :       int mother = process[i].mother1();</span>
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :       if ( (mother &gt; 2 &amp;&amp; mother &lt; inP2) || mother &gt; inM2 ) break;</span>
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :       event.append(process[i]);</span>
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :       iPosBefShow[i] = i;</span>
<span class="lineNum">    1274 </span>            : 
<span class="lineNum">    1275 </span>            :       // Currently outgoing ones should not count as decayed.
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :       if (event[i].status() == -22) {</span>
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :         event[i].statusPos();</span>
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :         event[i].daughters(0, 0);</span>
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1280 </span>            : 
<span class="lineNum">    1281 </span>            :       // Complete task of copying hard subsystem into event record.
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :       ++nHardDone;</span>
<span class="lineNum">    1283 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1284 </span>            : 
<span class="lineNum">    1285 </span>            :     // Store participating partons as second set in list of all systems.
<span class="lineNum">    1286 </span><span class="lineNoCov">          0 :     partonSystemsPtr-&gt;addSys();</span>
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 :     partonSystemsPtr-&gt;setInA(1, inP2);</span>
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :     partonSystemsPtr-&gt;setInB(1, inM2);</span>
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 :     for (int i = inM2 + 1; i &lt; nHardDone; ++i)</span>
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :       partonSystemsPtr-&gt;addOut(1, i);</span>
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :     partonSystemsPtr-&gt;setSHat( 1,</span>
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :       (event[inP2].p() + event[inM2].p()).m2Calc() );</span>
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :     partonSystemsPtr-&gt;setPTHat( 1, scale);</span>
<span class="lineNum">    1294 </span>            : 
<span class="lineNum">    1295 </span>            :   // End code for second hard process.
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1297 </span>            : 
<span class="lineNum">    1298 </span>            :   // Update event colour tag to maximum in whole process.
<span class="lineNum">    1299 </span>            :   int maxColTag = 0;
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; process.size(); ++ i) {</span>
<span class="lineNum">    1301 </span><span class="lineNoCov">          0 :     if (process[i].col() &gt; maxColTag) maxColTag = process[i].col();</span>
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 :     if (process[i].acol() &gt; maxColTag) maxColTag = process[i].acol();</span>
<span class="lineNum">    1303 </span>            :   }
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 :   event.initColTag(maxColTag);</span>
<span class="lineNum">    1305 </span>            : 
<span class="lineNum">    1306 </span>            :   // Copy junctions from process to event.
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :   for (int iJun = 0; iJun &lt; process.sizeJunction(); ++iJun) {</span>
<span class="lineNum">    1308 </span>            :     // Resonance decay products may not have been copied from process to
<span class="lineNum">    1309 </span>            :     // event yet. If so, do not add junctions associated with decays yet.
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :     int kindJunction = process.kindJunction(iJun);</span>
<span class="lineNum">    1311 </span>            :     bool doCopy = true;
<span class="lineNum">    1312 </span>            :     // For junction types &lt;= 4, check if final-state legs were copied.
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :     if (kindJunction &lt;= 4) {</span>
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :       int iLegF1 = (kindJunction - 1) / 2;</span>
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :       for (int iLeg = iLegF1; iLeg &lt;= 2; ++iLeg) {</span>
<span class="lineNum">    1316 </span>            :         bool colFound = false;
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :         for (int i = inM + 1; i &lt; event.size(); ++i) {</span>
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :           int col = (kindJunction % 2 == 1) ? event[i].col() : event[i].acol();</span>
<span class="lineNum">    1319 </span><span class="lineNoCov">          0 :           if (col == process.colJunction(iJun,iLeg)) colFound = true;</span>
<span class="lineNum">    1320 </span>            :         }
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :         if (!colFound) doCopy = false;</span>
<span class="lineNum">    1322 </span>            :       }
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :     if (doCopy) event.appendJunction( process.getJunction(iJun));</span>
<span class="lineNum">    1325 </span>            :   }
<span class="lineNum">    1326 </span>            : 
<span class="lineNum">    1327 </span>            :   // Done.
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1329 </span>            : 
<span class="lineNum">    1330 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1331 </span>            : 
<a name="1332"><span class="lineNum">    1332 </span>            : // Set up the event for subsequent resonance decays and showers.</a>
<span class="lineNum">    1333 </span>            : 
<span class="lineNum">    1334 </span>            : void PartonLevel::setupShowerSys( Event&amp; process, Event&amp; event) {
<span class="lineNum">    1335 </span>            : 
<span class="lineNum">    1336 </span>            :   // Reset event record to only contain line 0.
<span class="lineNum">    1337 </span><span class="lineNoCov">          0 :   event.clear();</span>
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :   event.append( process[0]);</span>
<span class="lineNum">    1339 </span>            : 
<span class="lineNum">    1340 </span>            :   // Initialize info needed for subsequent sequential decays + showers.
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :   nHardDone = 1;</span>
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :   iPosBefShow.resize( process.size());</span>
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :   fill( iPosBefShow.begin(), iPosBefShow.end(), 0);</span>
<span class="lineNum">    1344 </span>            : 
<span class="lineNum">    1345 </span>            :   // Add the hard subprocess partons to the event record.
<span class="lineNum">    1346 </span><span class="lineNoCov">          0 :   for (int i = 1; i &lt; process.size(); ++i) {</span>
<span class="lineNum">    1347 </span><span class="lineNoCov">          0 :     if (process[i].mother1() &gt; 0) break;</span>
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 :     int j = event.append(process[i]);</span>
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :     iPosBefShow[i] = i;</span>
<span class="lineNum">    1350 </span>            : 
<span class="lineNum">    1351 </span>            :     // Currently outgoing ones should not count as decayed.
<span class="lineNum">    1352 </span><span class="lineNoCov">          0 :     if (event[j].status() == -22) {</span>
<span class="lineNum">    1353 </span><span class="lineNoCov">          0 :       event[j].statusPos();</span>
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 :       event[j].daughters(0, 0);</span>
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1356 </span>            : 
<span class="lineNum">    1357 </span>            :     // Complete task of copying hard subsystem into event record.
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 :     ++nHardDone;</span>
<span class="lineNum">    1359 </span>            :   }
<span class="lineNum">    1360 </span>            : 
<span class="lineNum">    1361 </span>            :   // Store participating partons as first set in list of all systems.
<span class="lineNum">    1362 </span><span class="lineNoCov">          0 :   partonSystemsPtr-&gt;clear();</span>
<span class="lineNum">    1363 </span><span class="lineNoCov">          0 :   partonSystemsPtr-&gt;addSys();</span>
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :   for (int i = 1; i &lt; nHardDone; ++i) partonSystemsPtr-&gt;addOut(0, i);</span>
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :   partonSystemsPtr-&gt;setSHat( 0, pow2(process[0].m()) );</span>
<span class="lineNum">    1366 </span><span class="lineNoCov">          0 :   partonSystemsPtr-&gt;setPTHat( 0, 0.5 * process[0].m() );</span>
<span class="lineNum">    1367 </span>            : 
<span class="lineNum">    1368 </span>            :   // Copy junctions from process to event.
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :   for (int iJun = 0; iJun &lt; process.sizeJunction(); ++iJun) {</span>
<span class="lineNum">    1370 </span>            :     // Resonance decay products may not have been copied from process to
<span class="lineNum">    1371 </span>            :     // event yet. If so, do not add junctions associated with decays yet.
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :     int kindJunction = process.kindJunction(iJun);</span>
<span class="lineNum">    1373 </span>            :     bool doCopy = true;
<span class="lineNum">    1374 </span>            :     // For junction types &lt;= 4, check if final-state legs were copied.
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :     if (kindJunction &lt;= 4) {</span>
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 :       int iLegF1 = (kindJunction - 1) / 2;</span>
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :       for (int iLeg = iLegF1; iLeg &lt;= 2; ++iLeg) {</span>
<span class="lineNum">    1378 </span>            :         bool colFound = false;
<span class="lineNum">    1379 </span><span class="lineNoCov">          0 :         for (int i = 1; i &lt; event.size(); ++i) {</span>
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :           int col = (kindJunction % 2 == 1) ? event[i].col() : event[i].acol();</span>
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :           if (col == process.colJunction(iJun,iLeg)) colFound = true;</span>
<span class="lineNum">    1382 </span>            :         }
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 :         if (!colFound) doCopy = false;</span>
<span class="lineNum">    1384 </span>            :       }
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 :     if (doCopy) event.appendJunction( process.getJunction(iJun));</span>
<span class="lineNum">    1387 </span>            :   }
<span class="lineNum">    1388 </span>            : 
<span class="lineNum">    1389 </span>            :   // Done.
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1391 </span>            : 
<span class="lineNum">    1392 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1393 </span>            : 
<a name="1394"><span class="lineNum">    1394 </span>            : // Resolved diffraction: replace full event with diffractive subsystem.</a>
<span class="lineNum">    1395 </span>            : 
<span class="lineNum">    1396 </span>            : void PartonLevel::setupResolvedDiff( Event&amp; process) {
<span class="lineNum">    1397 </span>            : 
<span class="lineNum">    1398 </span>            :   // Mother and last entry of diffractive system.
<span class="lineNum">    1399 </span><span class="lineNoCov">          0 :   int iDiffMot     = iDS + 2;</span>
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :   int iDiffDau     = process.size() - 1;</span>
<span class="lineNum">    1401 </span>            : 
<span class="lineNum">    1402 </span>            :   // Diffractively excited particle to be replaced by Pomeron-hadron beams
<span class="lineNum">    1403 </span>            :   // (or Pomeron-Pomeron beams for central diffraction).
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 :   process[iDiffMot].statusNeg();</span>
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 :   process[iDiffMot].daughters( iDiffDau + 1, iDiffDau + 2);</span>
<span class="lineNum">    1406 </span>            : 
<span class="lineNum">    1407 </span>            :   // Diffractive system mass.
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :   double mDiff   = process[iDiffMot].m();</span>
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 :   double m2Diff  = mDiff * mDiff;</span>
<span class="lineNum">    1410 </span>            : 
<span class="lineNum">    1411 </span>            :   // Set up Pomeron-proton or Pomeron-Pomeron system as if it were
<span class="lineNum">    1412 </span>            :   // the complete collision. Set Pomeron &quot;beam particle&quot; massless.
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :   int idDiffA    = (iDS == 1) ? process[1].id() : 990;</span>
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :   int idDiffB    = (iDS == 2) ? process[2].id() : 990;</span>
<span class="lineNum">    1415 </span><span class="lineNoCov">          0 :   double mDiffA  = (iDS == 1) ? process[1].m() : 0.;</span>
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :   double mDiffB  = (iDS == 2) ? process[2].m() : 0.;</span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :   double m2DiffA = mDiffA * mDiffA;</span>
<span class="lineNum">    1418 </span><span class="lineNoCov">          0 :   double m2DiffB = mDiffB * mDiffB;</span>
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :   double eDiffA  = 0.5 * (m2Diff + m2DiffA - m2DiffB) / mDiff;</span>
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :   double eDiffB  = 0.5 * (m2Diff + m2DiffB - m2DiffA) / mDiff;</span>
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 :   double pzDiff  = 0.5 * sqrtpos( pow2(m2Diff - m2DiffA - m2DiffB)</span>
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :                  - 4. * m2DiffA * m2DiffB ) / mDiff;</span>
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :   process.append( idDiffA, 13, iDiffMot, 0, 0, 0, 0, 0,</span>
<span class="lineNum">    1424 </span>            :                    0., 0.,  pzDiff, eDiffA, mDiffA);
<span class="lineNum">    1425 </span><span class="lineNoCov">          0 :   process.append( idDiffB, 13, iDiffMot, 0, 0, 0, 0, 0,</span>
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 :                    0., 0., -pzDiff, eDiffB, mDiffB);</span>
<span class="lineNum">    1427 </span>            : 
<span class="lineNum">    1428 </span>            :   // Reassign beam pointers to refer to subsystem effective beams.
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 :   beamAPtr       = (iDS == 1) ? beamHadAPtr : beamPomAPtr;</span>
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :   beamBPtr       = (iDS == 2) ? beamHadBPtr : beamPomBPtr;</span>
<span class="lineNum">    1431 </span>            : 
<span class="lineNum">    1432 </span>            :   // Pretend that the diffractive system is the whole collision.
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :   eCMsave = infoPtr-&gt;eCM();</span>
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :   infoPtr-&gt;setECM( mDiff);</span>
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :   beamAPtr-&gt;newPzE(  pzDiff, eDiffA);</span>
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :   beamBPtr-&gt;newPzE( -pzDiff, eDiffB);</span>
<span class="lineNum">    1437 </span>            : 
<span class="lineNum">    1438 </span>            :   // Beams not found in normal slots 1 and 2.
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :   int beamOffset = (sizeEvent &gt; 0) ? sizeEvent - 1 : 4;</span>
<span class="lineNum">    1440 </span>            : 
<span class="lineNum">    1441 </span>            :   // Reassign beam pointers in other classes.
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :   timesPtr-&gt;reassignBeamPtrs( beamAPtr, beamBPtr, beamOffset);</span>
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :   spacePtr-&gt;reassignBeamPtrs( beamAPtr, beamBPtr, beamOffset);</span>
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :   remnants.reassignBeamPtrs(  beamAPtr, beamBPtr, iDS);</span>
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :   colourReconnection.reassignBeamPtrs(  beamAPtr, beamBPtr);</span>
<span class="lineNum">    1446 </span>            : 
<span class="lineNum">    1447 </span>            :   // Reassign multiparton interactions pointer to right object.
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :   if      (iDS == 1) multiPtr = &amp;multiSDA;</span>
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :   else if (iDS == 2) multiPtr = &amp;multiSDB;</span>
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :   else               multiPtr = &amp;multiCD;</span>
<span class="lineNum">    1451 </span>            : 
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1453 </span>            : 
<span class="lineNum">    1454 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1455 </span>            : 
<a name="1456"><span class="lineNum">    1456 </span>            : // Resolved diffraction: restore to original behaviour.</a>
<span class="lineNum">    1457 </span>            : 
<span class="lineNum">    1458 </span>            : void PartonLevel::leaveResolvedDiff( int iHardLoop, Event&amp; process,
<span class="lineNum">    1459 </span>            :   Event&amp; event) {
<span class="lineNum">    1460 </span>            : 
<span class="lineNum">    1461 </span>            :   // Reconstruct boost and rotation to event cm frame.
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :   Vec4 pDiffA = (iDS == 1) ? process[1].p()</span>
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :                            : process[1].p() - process[3].p();</span>
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 :   Vec4 pDiffB = (iDS == 2) ? process[2].p()</span>
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :                            : process[2].p() - process[4].p();</span>
<span class="lineNum">    1466 </span><span class="lineNoCov">          0 :   RotBstMatrix MtoCM;</span>
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 :   MtoCM.fromCMframe( pDiffA, pDiffB);</span>
<span class="lineNum">    1468 </span>            : 
<span class="lineNum">    1469 </span>            :   // Perform rotation and boost on diffractive system.
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :   for (int i = sizeProcess; i &lt; process.size(); ++i)</span>
<span class="lineNum">    1471 </span><span class="lineNoCov">          0 :     process[i].rotbst( MtoCM);</span>
<span class="lineNum">    1472 </span><span class="lineNoCov">          0 :   int iFirst = (iHardLoop == 1) ? 5 + sizeEvent - sizeProcess : sizeEvent;</span>
<span class="lineNum">    1473 </span><span class="lineNoCov">          0 :   if(isDiffC)  iFirst = 6 + sizeEvent - sizeProcess;</span>
<span class="lineNum">    1474 </span><span class="lineNoCov">          0 :   for (int i = iFirst; i &lt; event.size(); ++i)</span>
<span class="lineNum">    1475 </span><span class="lineNoCov">          0 :     event[i].rotbst( MtoCM);</span>
<span class="lineNum">    1476 </span>            : 
<span class="lineNum">    1477 </span>            :   // Restore cm energy.
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :   infoPtr-&gt;setECM( eCMsave);</span>
<span class="lineNum">    1479 </span><span class="lineNoCov">          0 :   beamAPtr-&gt;newPzE( event[1].pz(), event[1].e());</span>
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :   beamBPtr-&gt;newPzE( event[2].pz(), event[2].e());</span>
<span class="lineNum">    1481 </span>            : 
<span class="lineNum">    1482 </span>            :   // Restore beam pointers to incoming hadrons.
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 :   beamAPtr = beamHadAPtr;</span>
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :   beamBPtr = beamHadBPtr;</span>
<span class="lineNum">    1485 </span>            : 
<span class="lineNum">    1486 </span>            :   // Reassign beam pointers in other classes.
<span class="lineNum">    1487 </span><span class="lineNoCov">          0 :   timesPtr-&gt;reassignBeamPtrs( beamAPtr, beamBPtr, 0);</span>
<span class="lineNum">    1488 </span><span class="lineNoCov">          0 :   spacePtr-&gt;reassignBeamPtrs( beamAPtr, beamBPtr, 0);</span>
<span class="lineNum">    1489 </span><span class="lineNoCov">          0 :   remnants.reassignBeamPtrs(  beamAPtr, beamBPtr, 0);</span>
<span class="lineNum">    1490 </span><span class="lineNoCov">          0 :   colourReconnection.reassignBeamPtrs(  beamAPtr, beamBPtr);</span>
<span class="lineNum">    1491 </span>            : 
<span class="lineNum">    1492 </span>            :   // Restore multiparton interactions pointer to default object.
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :   multiPtr = &amp;multiMB;</span>
<span class="lineNum">    1494 </span>            : 
<span class="lineNum">    1495 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1496 </span>            : 
<span class="lineNum">    1497 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1498 </span>            : 
<a name="1499"><span class="lineNum">    1499 </span>            : // Set up special handling of hard diffraction.</a>
<span class="lineNum">    1500 </span>            : 
<span class="lineNum">    1501 </span>            : void PartonLevel::setupHardDiff( Event&amp; process) {
<span class="lineNum">    1502 </span>            : 
<span class="lineNum">    1503 </span>            :   // Create a temporary event record holding the info of the hard process.
<span class="lineNum">    1504 </span><span class="lineNoCov">          0 :   Event tmpProcess = process;</span>
<span class="lineNum">    1505 </span><span class="lineNoCov">          0 :   process.clear();</span>
<span class="lineNum">    1506 </span><span class="lineNoCov">          0 :   process.scale(tmpProcess.scale());</span>
<span class="lineNum">    1507 </span>            : 
<span class="lineNum">    1508 </span>            :   // Add the first three entries: system + incoming beams.
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :   for (int iEntry = 0; iEntry &lt; 3; ++iEntry)</span>
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 :     process.append( tmpProcess[iEntry]);</span>
<span class="lineNum">    1511 </span>            : 
<span class="lineNum">    1512 </span>            :   // Get system info and calculate diffractive system mass.
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :   double eCM    = infoPtr-&gt;eCM();</span>
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 :   double sNow   = eCM * eCM;</span>
<span class="lineNum">    1515 </span><span class="lineNoCov">          0 :   double xPom   = (isHardDiffB) ? infoPtr-&gt;xPomeronA()</span>
<span class="lineNum">    1516 </span><span class="lineNoCov">          0 :                 : infoPtr-&gt;xPomeronB();</span>
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 :   double m2Diff = xPom * sNow;</span>
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :   double mDiff  = sqrt(m2Diff);</span>
<span class="lineNum">    1519 </span>            : 
<span class="lineNum">    1520 </span>            :   // Particle masses. If isHardDiffB then m3 is a proton and m4 the
<span class="lineNum">    1521 </span>            :   // diffractive system.
<span class="lineNum">    1522 </span><span class="lineNoCov">          0 :   double m1 = process[1].m();</span>
<span class="lineNum">    1523 </span><span class="lineNoCov">          0 :   double m2 = process[2].m();</span>
<span class="lineNum">    1524 </span><span class="lineNoCov">          0 :   double m3 = (isHardDiffB) ? m1 : mDiff;</span>
<span class="lineNum">    1525 </span><span class="lineNoCov">          0 :   double m4 = (isHardDiffA) ? m2 : mDiff;</span>
<span class="lineNum">    1526 </span>            : 
<span class="lineNum">    1527 </span>            :   // Evaluate momenta of outgoing p and p_diff, initially along beam axis.
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 :   double s3 = pow2(m3);</span>
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 :   double s4 = pow2(m4);</span>
<span class="lineNum">    1530 </span><span class="lineNoCov">          0 :   double lambda34 = sqrtpos( pow2( sNow - s3 - s4) - 4. * s3 * s4 );</span>
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :   double pAbs = 0.5 * lambda34 / eCM;</span>
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :   Vec4 p3 = Vec4( 0., 0.,  pAbs, 0.5 * (sNow + s3 - s4) / eCM);</span>
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 :   Vec4 p4 = Vec4( 0., 0., -pAbs, 0.5 * (sNow + s4 - s3) / eCM);</span>
<span class="lineNum">    1534 </span>            : 
<span class="lineNum">    1535 </span>            :   // Take copies for later longitudinal boost; then rotate outgoing beams.
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 :   Vec4 pD3 = p3;</span>
<span class="lineNum">    1537 </span><span class="lineNoCov">          0 :   Vec4 pD4 = p4;</span>
<span class="lineNum">    1538 </span><span class="lineNoCov">          0 :   double phi   = 2. * M_PI * rndmPtr-&gt;flat();</span>
<span class="lineNum">    1539 </span><span class="lineNoCov">          0 :   double theta = (isHardDiffB) ? hardDiffraction.getThetaPomeronA() :</span>
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :     hardDiffraction.getThetaPomeronB();</span>
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 :   p3.rot( theta, phi);</span>
<span class="lineNum">    1542 </span><span class="lineNoCov">          0 :   p4.rot( theta, phi);</span>
<span class="lineNum">    1543 </span>            : 
<span class="lineNum">    1544 </span>            :   //  Append intermediate states to the event record.
<span class="lineNum">    1545 </span><span class="lineNoCov">          0 :   int status3 = (isHardDiffB) ? 14 : 15;</span>
<span class="lineNum">    1546 </span><span class="lineNoCov">          0 :   int status4 = (isHardDiffA) ? 14 : 15;</span>
<span class="lineNum">    1547 </span>            :   int sign = 0;
<span class="lineNum">    1548 </span><span class="lineNoCov">          0 :   if      (isHardDiffB) sign = (process[2].id() &gt; 0) ? 1 : -1;</span>
<span class="lineNum">    1549 </span><span class="lineNoCov">          0 :   else if (isHardDiffA) sign = (process[1].id() &gt; 0) ? 1 : -1;</span>
<span class="lineNum">    1550 </span><span class="lineNoCov">          0 :   int id3     = (isHardDiffB) ? process[1].id() : sign * 9902210;</span>
<span class="lineNum">    1551 </span><span class="lineNoCov">          0 :   int id4     = (isHardDiffA) ? process[2].id() : sign * 9902210;</span>
<span class="lineNum">    1552 </span><span class="lineNoCov">          0 :   process.append( id3, status3, 1, 0, 0, 0, 0, 0, p3, m3);</span>
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :   process.append( id4, status4, 2, 0, 0, 0, 0, 0, p4, m4);</span>
<span class="lineNum">    1554 </span>            : 
<span class="lineNum">    1555 </span>            :   // Correct event record history accordingly.
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 :   process[1].daughters(3, 0);</span>
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :   process[2].daughters(4, 0);</span>
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 :   int iDiffMot     = (isHardDiffB) ? 4 : 3;</span>
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :   int iDiffRad     = process.size() - 1;</span>
<span class="lineNum">    1560 </span><span class="lineNoCov">          0 :   process[iDiffMot].statusNeg();</span>
<span class="lineNum">    1561 </span><span class="lineNoCov">          0 :   process[iDiffMot].daughters( iDiffRad + 1, iDiffRad + 2);</span>
<span class="lineNum">    1562 </span>            : 
<span class="lineNum">    1563 </span>            :   // Set up Pomeron-proton system as if it were the complete collision.
<span class="lineNum">    1564 </span>            :   // Set Pomeron &quot;beam particle&quot; massless.
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :   int idDiffA    = (isHardDiffB) ? 990 : process[1].id();</span>
<span class="lineNum">    1566 </span><span class="lineNoCov">          0 :   int idDiffB    = (isHardDiffA) ? 990 : process[2].id();</span>
<span class="lineNum">    1567 </span><span class="lineNoCov">          0 :   double mDiffA  = (isHardDiffB) ? 0. : process[1].m();</span>
<span class="lineNum">    1568 </span><span class="lineNoCov">          0 :   double mDiffB  = (isHardDiffA) ? 0. : process[2].m();</span>
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :   double m2DiffA = mDiffA * mDiffA;</span>
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :   double m2DiffB = mDiffB * mDiffB;</span>
<span class="lineNum">    1571 </span><span class="lineNoCov">          0 :   double eDiffA  = 0.5 * (m2Diff + m2DiffA - m2DiffB) / mDiff;</span>
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :   double eDiffB  = 0.5 * (m2Diff + m2DiffB - m2DiffA) / mDiff;</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :   double pzDiff  = 0.5 * sqrtpos( pow2(m2Diff - m2DiffA - m2DiffB)</span>
<span class="lineNum">    1574 </span><span class="lineNoCov">          0 :                  - 4. * m2DiffA * m2DiffB ) / mDiff;</span>
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :   process.append( idDiffA, 13, iDiffMot, 0, 0, 0, 0, 0,</span>
<span class="lineNum">    1576 </span>            :                    0., 0.,  pzDiff, eDiffA, mDiffA);
<span class="lineNum">    1577 </span><span class="lineNoCov">          0 :   process.append( idDiffB, 13, iDiffMot, 0, 0, 0, 0, 0,</span>
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 :                    0., 0., -pzDiff, eDiffB, mDiffB);</span>
<span class="lineNum">    1579 </span>            : 
<span class="lineNum">    1580 </span>            :   // Append hard process.
<span class="lineNum">    1581 </span><span class="lineNoCov">          0 :   vector&lt;int&gt; hardParton;</span>
<span class="lineNum">    1582 </span><span class="lineNoCov">          0 :   for (int iHard = 3; iHard &lt; tmpProcess.size(); ++iHard)</span>
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :     hardParton.push_back( process.append(tmpProcess[iHard]) );</span>
<span class="lineNum">    1584 </span>            : 
<span class="lineNum">    1585 </span>            :   // Boost the hard partons in z-direction (from pp to Pp system).
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :   Vec4 pDiffA = (isHardDiffA) ? process[1].p() : process[1].p() - pD3;</span>
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :   Vec4 pDiffB = (isHardDiffB) ? process[2].p() : process[2].p() - pD4;</span>
<span class="lineNum">    1588 </span><span class="lineNoCov">          0 :   RotBstMatrix MtoCM;</span>
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :   MtoCM.toCMframe( pDiffA, pDiffB);</span>
<span class="lineNum">    1590 </span><span class="lineNoCov">          0 :   for (unsigned int i = 0; i &lt; hardParton.size(); ++i)</span>
<span class="lineNum">    1591 </span><span class="lineNoCov">          0 :     process[hardParton[i]].rotbst(MtoCM);</span>
<span class="lineNum">    1592 </span>            : 
<span class="lineNum">    1593 </span>            :   // Change mothers and daughters after appending hard process.
<span class="lineNum">    1594 </span><span class="lineNoCov">          0 :   for (unsigned int j = 0; j &lt; hardParton.size(); ++j){</span>
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 :     int mother1 = (tmpProcess[j+3].mother1() == 0)</span>
<span class="lineNum">    1596 </span><span class="lineNoCov">          0 :       ? 0 : tmpProcess[j+3].mother1() + 4;</span>
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :     int mother2 = (tmpProcess[j+3].mother2() == 0)</span>
<span class="lineNum">    1598 </span><span class="lineNoCov">          0 :       ? 0 : tmpProcess[j+3].mother2() + 4;</span>
<span class="lineNum">    1599 </span><span class="lineNoCov">          0 :     int daughter1 = (tmpProcess[j+3].daughter1() == 0)</span>
<span class="lineNum">    1600 </span><span class="lineNoCov">          0 :       ? 0 : tmpProcess[j+3].daughter1() + 4;</span>
<span class="lineNum">    1601 </span><span class="lineNoCov">          0 :     int daughter2 = (tmpProcess[j+3].daughter2() == 0)</span>
<span class="lineNum">    1602 </span><span class="lineNoCov">          0 :       ? 0 : tmpProcess[j+3].daughter2() + 4;</span>
<span class="lineNum">    1603 </span><span class="lineNoCov">          0 :     process[hardParton[j]].mothers( mother1,mother2);</span>
<span class="lineNum">    1604 </span><span class="lineNoCov">          0 :     process[hardParton[j]].daughters( daughter1, daughter2);</span>
<span class="lineNum">    1605 </span>            :   }
<span class="lineNum">    1606 </span>            : 
<span class="lineNum">    1607 </span>            :   // Search for pomeron and proton with status codes 13 (beam-inside-beam)
<span class="lineNum">    1608 </span>            :   int iPomeron = 0;
<span class="lineNum">    1609 </span>            :   int iProton  = 0;
<span class="lineNum">    1610 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; process.size(); ++i) {</span>
<span class="lineNum">    1611 </span><span class="lineNoCov">          0 :     if (process[i].id() == 990 &amp;&amp; process[i].status() == 13) iPomeron = i;</span>
<span class="lineNum">    1612 </span><span class="lineNoCov">          0 :     if (abs(process[i].id()) == 2212 &amp;&amp; process[i].status() == 13) iProton = i;</span>
<span class="lineNum">    1613 </span>            :   }
<span class="lineNum">    1614 </span>            : 
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :   if (isHardDiffB){</span>
<span class="lineNum">    1616 </span><span class="lineNoCov">          0 :     process[iPomeron].daughters(hardParton[0], 0);</span>
<span class="lineNum">    1617 </span><span class="lineNoCov">          0 :     process[iProton].daughters(hardParton[1],0);</span>
<span class="lineNum">    1618 </span><span class="lineNoCov">          0 :     process[hardParton[0]].mothers(iPomeron,0);</span>
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :     process[hardParton[1]].mothers(iProton, 0);</span>
<span class="lineNum">    1620 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">    1621 </span><span class="lineNoCov">          0 :     process[iPomeron].daughters(hardParton[1], 0);</span>
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 :     process[iProton].daughters(hardParton[0],0);</span>
<span class="lineNum">    1623 </span><span class="lineNoCov">          0 :     process[hardParton[1]].mothers(iPomeron,0);</span>
<span class="lineNum">    1624 </span><span class="lineNoCov">          0 :     process[hardParton[0]].mothers(iProton, 0);</span>
<span class="lineNum">    1625 </span>            :   }
<span class="lineNum">    1626 </span>            : 
<span class="lineNum">    1627 </span>            :   // Negate status of Pomeron and proton
<span class="lineNum">    1628 </span><span class="lineNoCov">          0 :   process[iPomeron].statusNeg();</span>
<span class="lineNum">    1629 </span><span class="lineNoCov">          0 :   process[iProton].statusNeg();</span>
<span class="lineNum">    1630 </span>            : 
<span class="lineNum">    1631 </span>            :   // Change state of system to unresolved to avoid aborting from Pythia.
<span class="lineNum">    1632 </span><span class="lineNoCov">          0 :   infoPtr-&gt;setHasUnresolvedBeams( true);</span>
<span class="lineNum">    1633 </span>            : 
<span class="lineNum">    1634 </span>            :   // Reassign beam pointers to refer to subsystem effective beams.
<span class="lineNum">    1635 </span><span class="lineNoCov">          0 :   beamAPtr = (isHardDiffB) ? beamPomAPtr : beamHadAPtr;</span>
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :   beamBPtr = (isHardDiffA) ? beamPomBPtr : beamHadBPtr;</span>
<span class="lineNum">    1637 </span>            : 
<span class="lineNum">    1638 </span>            :   // Pretend that the diffractive system is the whole collision.
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 :   eCMsave = infoPtr-&gt;eCM();</span>
<span class="lineNum">    1640 </span><span class="lineNoCov">          0 :   infoPtr-&gt;setECM( mDiff);</span>
<span class="lineNum">    1641 </span><span class="lineNoCov">          0 :   beamAPtr-&gt;newPzE(  pzDiff, eDiffA);</span>
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 :   beamBPtr-&gt;newPzE( -pzDiff, eDiffB);</span>
<span class="lineNum">    1643 </span>            : 
<span class="lineNum">    1644 </span>            :   // Beams not found in normal slots 1 and 2.
<span class="lineNum">    1645 </span>            :   int beamOffset = 4;
<span class="lineNum">    1646 </span>            : 
<span class="lineNum">    1647 </span>            :   // Reassign beam pointers in other classes.
<span class="lineNum">    1648 </span><span class="lineNoCov">          0 :   timesPtr-&gt;reassignBeamPtrs( beamAPtr, beamBPtr, beamOffset);</span>
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 :   spacePtr-&gt;reassignBeamPtrs( beamAPtr, beamBPtr, beamOffset);</span>
<span class="lineNum">    1650 </span><span class="lineNoCov">          0 :   remnants.reassignBeamPtrs(  beamAPtr, beamBPtr, (isHardDiffB) ? 2 : 1);</span>
<span class="lineNum">    1651 </span><span class="lineNoCov">          0 :   colourReconnection.reassignBeamPtrs(  beamAPtr, beamBPtr);</span>
<span class="lineNum">    1652 </span>            : 
<span class="lineNum">    1653 </span>            :   // Reassign multiparton interactions pointer to right object.
<span class="lineNum">    1654 </span><span class="lineNoCov">          0 :   if      (isHardDiffA) multiPtr = &amp;multiSDA;</span>
<span class="lineNum">    1655 </span><span class="lineNoCov">          0 :   else if (isHardDiffB) multiPtr = &amp;multiSDB;</span>
<span class="lineNum">    1656 </span>            : 
<span class="lineNum">    1657 </span>            :   // Done.
<span class="lineNum">    1658 </span><span class="lineNoCov">          0 :   isSetupDiff = true;</span>
<span class="lineNum">    1659 </span>            : 
<span class="lineNum">    1660 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1661 </span>            : 
<span class="lineNum">    1662 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1663 </span>            : 
<a name="1664"><span class="lineNum">    1664 </span>            : // Leave special handling of hard diffraction.</a>
<span class="lineNum">    1665 </span>            : 
<span class="lineNum">    1666 </span>            : void PartonLevel::leaveHardDiff( Event&amp; process, Event&amp; event) {
<span class="lineNum">    1667 </span>            : 
<span class="lineNum">    1668 </span>            :   // Reconstruct boost and rotation to event cm frame.
<span class="lineNum">    1669 </span><span class="lineNoCov">          0 :   Vec4 pDiffA = (isHardDiffA) ? process[1].p()</span>
<span class="lineNum">    1670 </span><span class="lineNoCov">          0 :               : process[1].p() - process[3].p();</span>
<span class="lineNum">    1671 </span><span class="lineNoCov">          0 :   Vec4 pDiffB = (isHardDiffB) ? process[2].p()</span>
<span class="lineNum">    1672 </span><span class="lineNoCov">          0 :               : process[2].p() - process[4].p();</span>
<span class="lineNum">    1673 </span><span class="lineNoCov">          0 :   RotBstMatrix MtoCM;</span>
<span class="lineNum">    1674 </span><span class="lineNoCov">          0 :   MtoCM.fromCMframe( pDiffA, pDiffB);</span>
<span class="lineNum">    1675 </span>            : 
<span class="lineNum">    1676 </span>            :   // Perform rotation and boost on diffractive system.
<span class="lineNum">    1677 </span><span class="lineNoCov">          0 :   for (int i = 5; i &lt; process.size(); ++i) process[i].rotbst( MtoCM);</span>
<span class="lineNum">    1678 </span><span class="lineNoCov">          0 :   for (int i = 5; i &lt; event.size(); ++i) event[i].rotbst( MtoCM);</span>
<span class="lineNum">    1679 </span>            : 
<span class="lineNum">    1680 </span>            :   // Clear diffractive info.
<span class="lineNum">    1681 </span><span class="lineNoCov">          0 :   isHardDiffA = isHardDiffB = isHardDiff = false;</span>
<span class="lineNum">    1682 </span>            : 
<span class="lineNum">    1683 </span>            :   // Restore cm energy.
<span class="lineNum">    1684 </span><span class="lineNoCov">          0 :   infoPtr-&gt;setECM( eCMsave);</span>
<span class="lineNum">    1685 </span><span class="lineNoCov">          0 :   beamAPtr-&gt;newPzE( event[1].pz(), event[1].e());</span>
<span class="lineNum">    1686 </span><span class="lineNoCov">          0 :   beamBPtr-&gt;newPzE( event[2].pz(), event[2].e());</span>
<span class="lineNum">    1687 </span>            : 
<span class="lineNum">    1688 </span>            :   // Restore beam pointers to incoming hadrons.
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 :   beamAPtr = beamHadAPtr;</span>
<span class="lineNum">    1690 </span><span class="lineNoCov">          0 :   beamBPtr = beamHadBPtr;</span>
<span class="lineNum">    1691 </span>            : 
<span class="lineNum">    1692 </span>            :   // Reassign beam pointers in other classes.
<span class="lineNum">    1693 </span><span class="lineNoCov">          0 :   timesPtr-&gt;reassignBeamPtrs( beamAPtr, beamBPtr, 0);</span>
<span class="lineNum">    1694 </span><span class="lineNoCov">          0 :   spacePtr-&gt;reassignBeamPtrs( beamAPtr, beamBPtr, 0);</span>
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :   remnants.reassignBeamPtrs(  beamAPtr, beamBPtr, 0);</span>
<span class="lineNum">    1696 </span><span class="lineNoCov">          0 :   colourReconnection.reassignBeamPtrs(  beamAPtr, beamBPtr);</span>
<span class="lineNum">    1697 </span>            : 
<span class="lineNum">    1698 </span>            :   // Restore multiparton interactions pointer to default object.
<span class="lineNum">    1699 </span><span class="lineNoCov">          0 :   multiPtr = &amp;multiMB;</span>
<span class="lineNum">    1700 </span>            : 
<span class="lineNum">    1701 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1702 </span>            : 
<span class="lineNum">    1703 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1704 </span>            : 
<a name="1705"><span class="lineNum">    1705 </span>            : // Handle showers in successive resonance decays.</a>
<span class="lineNum">    1706 </span>            : 
<span class="lineNum">    1707 </span>            : bool PartonLevel::resonanceShowers( Event&amp; process, Event&amp; event,
<span class="lineNum">    1708 </span>            :   bool skipForR) {
<span class="lineNum">    1709 </span>            : 
<span class="lineNum">    1710 </span>            :   // Prepare to start over from beginning for R-hadron decays.
<span class="lineNum">    1711 </span><span class="lineNoCov">          0 :   if (allowRH) {</span>
<span class="lineNum">    1712 </span><span class="lineNoCov">          0 :     if (skipForR) {</span>
<span class="lineNum">    1713 </span><span class="lineNoCov">          0 :       nHardDoneRHad = nHardDone;</span>
<span class="lineNum">    1714 </span><span class="lineNoCov">          0 :       inRHadDecay.resize(0);</span>
<span class="lineNum">    1715 </span><span class="lineNoCov">          0 :       for (int i = 0; i &lt; process.size(); ++i)</span>
<span class="lineNum">    1716 </span><span class="lineNoCov">          0 :         inRHadDecay.push_back( false);</span>
<span class="lineNum">    1717 </span><span class="lineNoCov">          0 :     } else nHardDone = nHardDoneRHad;</span>
<span class="lineNum">    1718 </span>            :   }
<span class="lineNum">    1719 </span>            : 
<span class="lineNum">    1720 </span>            :   // Isolate next system to be processed, if anything remains.
<span class="lineNum">    1721 </span>            :   int nRes    = 0;
<span class="lineNum">    1722 </span>            :   int nFSRres = 0;
<span class="lineNum">    1723 </span>            :   // Number of desired branchings, negative value means no restriction.
<span class="lineNum">    1724 </span><span class="lineNoCov">          0 :   int nBranchMax = (doTrial) ? nTrialEmissions : -1;</span>
<span class="lineNum">    1725 </span>            :   // Vector to tell which junctions have already been copied
<span class="lineNum">    1726 </span><span class="lineNoCov">          0 :   vector&lt;int&gt; iJunCopied;</span>
<span class="lineNum">    1727 </span>            : 
<span class="lineNum">    1728 </span><span class="lineNoCov">          0 :   while (nHardDone &lt; process.size()) {</span>
<span class="lineNum">    1729 </span><span class="lineNoCov">          0 :     ++nRes;</span>
<span class="lineNum">    1730 </span><span class="lineNoCov">          0 :     int iBegin = nHardDone;</span>
<span class="lineNum">    1731 </span>            : 
<span class="lineNum">    1732 </span>            :     // In first call (skipForR = true) skip over resonances
<span class="lineNum">    1733 </span>            :     // that should form R-hadrons, and their daughters.
<span class="lineNum">    1734 </span><span class="lineNoCov">          0 :     if (allowRH) {</span>
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 :       if (skipForR) {</span>
<span class="lineNum">    1736 </span>            :         bool comesFromR = false;
<span class="lineNum">    1737 </span>            :         int iTraceUp = iBegin;
<span class="lineNum">    1738 </span><span class="lineNoCov">          0 :         do {</span>
<span class="lineNum">    1739 </span><span class="lineNoCov">          0 :           if ( rHadronsPtr-&gt;givesRHadron(process[iTraceUp].id()) )</span>
<span class="lineNum">    1740 </span><span class="lineNoCov">          0 :             comesFromR = true;</span>
<span class="lineNum">    1741 </span><span class="lineNoCov">          0 :           iTraceUp = process[iTraceUp].mother1();</span>
<span class="lineNum">    1742 </span><span class="lineNoCov">          0 :         } while (iTraceUp &gt; 0 &amp;&amp; !comesFromR);</span>
<span class="lineNum">    1743 </span><span class="lineNoCov">          0 :         if (comesFromR) {</span>
<span class="lineNum">    1744 </span><span class="lineNoCov">          0 :           inRHadDecay[iBegin] = true;</span>
<span class="lineNum">    1745 </span><span class="lineNoCov">          0 :           ++nHardDone;</span>
<span class="lineNum">    1746 </span><span class="lineNoCov">          0 :           continue;</span>
<span class="lineNum">    1747 </span>            :         }
<span class="lineNum">    1748 </span>            : 
<span class="lineNum">    1749 </span>            :       // In optional second call (skipForR = false) process decay chains
<span class="lineNum">    1750 </span>            :       // inside R-hadrons.
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :       } else if (!inRHadDecay[iBegin]) {</span>
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :         ++nHardDone;</span>
<span class="lineNum">    1753 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    1754 </span>            :       }
<span class="lineNum">    1755 </span>            :     }
<span class="lineNum">    1756 </span>            : 
<span class="lineNum">    1757 </span>            :     // Mother in hard process and in complete event (after shower).
<span class="lineNum">    1758 </span><span class="lineNoCov">          0 :     int iHardMother      = process[iBegin].mother1();</span>
<span class="lineNum">    1759 </span><span class="lineNoCov">          0 :     Particle&amp; hardMother = process[iHardMother];</span>
<span class="lineNum">    1760 </span><span class="lineNoCov">          0 :     int iBefMother       = iPosBefShow[iHardMother];</span>
<span class="lineNum">    1761 </span><span class="lineNoCov">          0 :     int iAftMother       = event[iBefMother].iBotCopyId();</span>
<span class="lineNum">    1762 </span>            :     // Possibly trace across intermediate R-hadron state.
<span class="lineNum">    1763 </span><span class="lineNoCov">          0 :     if (allowRH) {</span>
<span class="lineNum">    1764 </span><span class="lineNoCov">          0 :       int iTraceRHadron    = rHadronsPtr-&gt;trace( iAftMother);</span>
<span class="lineNum">    1765 </span><span class="lineNoCov">          0 :       if (iTraceRHadron &gt; 0) iAftMother = iTraceRHadron;</span>
<span class="lineNum">    1766 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1767 </span><span class="lineNoCov">          0 :     Particle&amp; aftMother  = event[iAftMother];</span>
<span class="lineNum">    1768 </span>            : 
<span class="lineNum">    1769 </span>            :     // From now on mother counts as decayed.
<span class="lineNum">    1770 </span><span class="lineNoCov">          0 :     aftMother.statusNeg();</span>
<span class="lineNum">    1771 </span>            : 
<span class="lineNum">    1772 </span>            :     // Mother can have been moved by showering (in any of previous steps),
<span class="lineNum">    1773 </span>            :     // so prepare to update colour and momentum information for system.
<span class="lineNum">    1774 </span><span class="lineNoCov">          0 :     int colBef  = hardMother.col();</span>
<span class="lineNum">    1775 </span><span class="lineNoCov">          0 :     int acolBef = hardMother.acol();</span>
<span class="lineNum">    1776 </span><span class="lineNoCov">          0 :     int colAft  = aftMother.col();</span>
<span class="lineNum">    1777 </span><span class="lineNoCov">          0 :     int acolAft = aftMother.acol();</span>
<span class="lineNum">    1778 </span><span class="lineNoCov">          0 :     RotBstMatrix M;</span>
<span class="lineNum">    1779 </span><span class="lineNoCov">          0 :     M.bst( hardMother.p(), aftMother.p());</span>
<span class="lineNum">    1780 </span>            : 
<span class="lineNum">    1781 </span>            :     // New colour reconnection can not handle late resonance decay
<span class="lineNum">    1782 </span>            :     // of coloured particles so abort event.
<span class="lineNum">    1783 </span><span class="lineNoCov">          0 :     if ( (colBef != 0 || acolBef != 0) &amp;&amp; doReconnect &amp;&amp; reconnectMode == 1</span>
<span class="lineNum">    1784 </span><span class="lineNoCov">          0 :       &amp;&amp; forceResonanceCR &amp;&amp; !earlyResDec) {</span>
<span class="lineNum">    1785 </span><span class="lineNoCov">          0 :       infoPtr-&gt;errorMsg(&quot;Abort in PartonLevel::resonanceShower: &quot;</span>
<span class="lineNum">    1786 </span>            :         &quot;new CR can't handle separate CR for coloured resonance decays&quot;);
<span class="lineNum">    1787 </span><span class="lineNoCov">          0 :       infoPtr-&gt;setAbortPartonLevel(true);</span>
<span class="lineNum">    1788 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    1789 </span>            :     }
<span class="lineNum">    1790 </span>            : 
<span class="lineNum">    1791 </span>            :     // Extract next partons from hard event into normal event record.
<span class="lineNum">    1792 </span><span class="lineNoCov">          0 :     vector&lt;bool&gt; doCopyJun;</span>
<span class="lineNum">    1793 </span><span class="lineNoCov">          0 :     for (int i = iBegin; i &lt; process.size(); ++i) {</span>
<span class="lineNum">    1794 </span><span class="lineNoCov">          0 :       if (process[i].mother1() != iHardMother) break;</span>
<span class="lineNum">    1795 </span><span class="lineNoCov">          0 :       int iNow = event.append( process[i] );</span>
<span class="lineNum">    1796 </span><span class="lineNoCov">          0 :       iPosBefShow[i] = iNow;</span>
<span class="lineNum">    1797 </span><span class="lineNoCov">          0 :       Particle&amp; now = event.back();</span>
<span class="lineNum">    1798 </span>            : 
<span class="lineNum">    1799 </span>            :       // Currently outgoing ones should not count as decayed.
<span class="lineNum">    1800 </span><span class="lineNoCov">          0 :       if (now.status() == -22) {</span>
<span class="lineNum">    1801 </span><span class="lineNoCov">          0 :         now.statusPos();</span>
<span class="lineNum">    1802 </span><span class="lineNoCov">          0 :         now.daughters(0, 0);</span>
<span class="lineNum">    1803 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1804 </span>            : 
<span class="lineNum">    1805 </span>            :       // Update daughter and mother information.
<span class="lineNum">    1806 </span><span class="lineNoCov">          0 :       if (i == iBegin) event[iAftMother].daughter1( iNow);</span>
<span class="lineNum">    1807 </span><span class="lineNoCov">          0 :       else             event[iAftMother].daughter2( iNow);</span>
<span class="lineNum">    1808 </span><span class="lineNoCov">          0 :       now.mother1(iAftMother);</span>
<span class="lineNum">    1809 </span>            : 
<span class="lineNum">    1810 </span>            :       // Check if this parton carries a junction color in hard event.
<span class="lineNum">    1811 </span><span class="lineNoCov">          0 :       for (int iJun = 0; iJun &lt; process.sizeJunction(); ++iJun) {</span>
<span class="lineNum">    1812 </span><span class="lineNoCov">          0 :         if (iJun &gt;= int(doCopyJun.size())) doCopyJun.push_back(false);</span>
<span class="lineNum">    1813 </span>            :         // Only consider junctions that can appear in decays.
<span class="lineNum">    1814 </span><span class="lineNoCov">          0 :         int kindJunction = process.kindJunction(iJun);</span>
<span class="lineNum">    1815 </span><span class="lineNoCov">          0 :         if (kindJunction &gt;= 5) continue;</span>
<span class="lineNum">    1816 </span><span class="lineNoCov">          0 :         int col = (kindJunction % 2 == 1) ? now.col() : now.acol();</span>
<span class="lineNum">    1817 </span><span class="lineNoCov">          0 :         int iLegF1 = (kindJunction - 1) / 2;</span>
<span class="lineNum">    1818 </span><span class="lineNoCov">          0 :         for (int iLeg = iLegF1; iLeg &lt;= 2; ++iLeg)</span>
<span class="lineNum">    1819 </span><span class="lineNoCov">          0 :         if (col == process.colJunction(iJun,iLeg)) doCopyJun[iJun] = true;</span>
<span class="lineNum">    1820 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1821 </span>            : 
<span class="lineNum">    1822 </span>            :       // Update colour and momentum information.
<span class="lineNum">    1823 </span><span class="lineNoCov">          0 :       if (now.col() == colBef) now.col( colAft);</span>
<span class="lineNum">    1824 </span><span class="lineNoCov">          0 :       if (now.acol() == acolBef) now.acol( acolAft);</span>
<span class="lineNum">    1825 </span>            :       // Sextet mothers have additional (negative) tag
<span class="lineNum">    1826 </span><span class="lineNoCov">          0 :       if (now.col() == -acolBef) now.col( -acolAft);</span>
<span class="lineNum">    1827 </span><span class="lineNoCov">          0 :       if (now.acol() == -colBef) now.acol( -colAft);</span>
<span class="lineNum">    1828 </span><span class="lineNoCov">          0 :       now.rotbst( M);</span>
<span class="lineNum">    1829 </span>            : 
<span class="lineNum">    1830 </span>            :       // Update vertex information.
<span class="lineNum">    1831 </span><span class="lineNoCov">          0 :       if (now.hasVertex()) now.vProd( event[iAftMother].vDec() );</span>
<span class="lineNum">    1832 </span>            : 
<span class="lineNum">    1833 </span>            :       // Complete task of copying next subsystem into event record.
<span class="lineNum">    1834 </span><span class="lineNoCov">          0 :       ++nHardDone;</span>
<span class="lineNum">    1835 </span>            :     }
<span class="lineNum">    1836 </span><span class="lineNoCov">          0 :     int iEnd = nHardDone - 1;</span>
<span class="lineNum">    1837 </span>            : 
<span class="lineNum">    1838 </span>            :     // Copy down junctions from hard event into normal event record.
<span class="lineNum">    1839 </span><span class="lineNoCov">          0 :     for (int iJun = 0; iJun &lt; int(doCopyJun.size()); ++iJun) {</span>
<span class="lineNum">    1840 </span>            :       // Check if this junction was already copied
<span class="lineNum">    1841 </span><span class="lineNoCov">          0 :       for (int jJun = 0; jJun &lt; int(iJunCopied.size()); ++jJun)</span>
<span class="lineNum">    1842 </span><span class="lineNoCov">          0 :         if (iJunCopied[jJun] == iJun) doCopyJun[iJun] = false;</span>
<span class="lineNum">    1843 </span>            :       // Skip if not doing anything
<span class="lineNum">    1844 </span><span class="lineNoCov">          0 :       if (!doCopyJun[iJun]) continue;</span>
<span class="lineNum">    1845 </span>            :       // Check for changed colors and update as necessary.
<span class="lineNum">    1846 </span><span class="lineNoCov">          0 :       Junction junCopy = process.getJunction(iJun);</span>
<span class="lineNum">    1847 </span><span class="lineNoCov">          0 :       for (int iLeg = 0; iLeg &lt;= 2; ++iLeg) {</span>
<span class="lineNum">    1848 </span><span class="lineNoCov">          0 :         int colLeg = junCopy.col(iLeg);</span>
<span class="lineNum">    1849 </span><span class="lineNoCov">          0 :         if (colLeg == colBef) junCopy.col(iLeg, colAft);</span>
<span class="lineNum">    1850 </span><span class="lineNoCov">          0 :         if (colLeg == acolBef) junCopy.col(iLeg, acolAft);</span>
<span class="lineNum">    1851 </span>            :       }
<span class="lineNum">    1852 </span><span class="lineNoCov">          0 :       event.appendJunction(junCopy);</span>
<span class="lineNum">    1853 </span>            :       // Mark junction as copied (to avoid later recopying)
<span class="lineNum">    1854 </span><span class="lineNoCov">          0 :       iJunCopied.push_back(iJun);</span>
<span class="lineNum">    1855 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1856 </span>            : 
<span class="lineNum">    1857 </span>            :     // Reset pT of last branching
<span class="lineNum">    1858 </span><span class="lineNoCov">          0 :     pTLastBranch = 0.0;</span>
<span class="lineNum">    1859 </span>            : 
<span class="lineNum">    1860 </span>            :     // Add new system, automatically with two empty beam slots.
<span class="lineNum">    1861 </span><span class="lineNoCov">          0 :     int iSys = partonSystemsPtr-&gt;addSys();</span>
<span class="lineNum">    1862 </span><span class="lineNoCov">          0 :     partonSystemsPtr-&gt;setSHat(iSys, pow2(hardMother.m()) );</span>
<span class="lineNum">    1863 </span><span class="lineNoCov">          0 :     partonSystemsPtr-&gt;setPTHat(iSys, 0.5 * hardMother.m() );</span>
<span class="lineNum">    1864 </span>            : 
<span class="lineNum">    1865 </span>            :     // Loop over allowed range to find all final-state particles.
<span class="lineNum">    1866 </span><span class="lineNoCov">          0 :     for (int i = iPosBefShow[iBegin]; i &lt;= iPosBefShow[iEnd]; ++i)</span>
<span class="lineNum">    1867 </span><span class="lineNoCov">          0 :     if (event[i].isFinal()) partonSystemsPtr-&gt;addOut( iSys, i);</span>
<span class="lineNum">    1868 </span>            : 
<span class="lineNum">    1869 </span>            :     // Do parton showers inside subsystem: maximum scale by mother mass.
<span class="lineNum">    1870 </span><span class="lineNoCov">          0 :     if (doFSRinResonances) {</span>
<span class="lineNum">    1871 </span><span class="lineNoCov">          0 :       double pTmax = 0.5 * hardMother.m();</span>
<span class="lineNum">    1872 </span><span class="lineNoCov">          0 :       if (canSetScale) pTmax</span>
<span class="lineNum">    1873 </span><span class="lineNoCov">          0 :         = userHooksPtr-&gt;scaleResonance( iAftMother, event);</span>
<span class="lineNum">    1874 </span><span class="lineNoCov">          0 :       nFSRhard     = 0;</span>
<span class="lineNum">    1875 </span>            : 
<span class="lineNum">    1876 </span>            :       // Set correct scale for trial showers.
<span class="lineNum">    1877 </span><span class="lineNoCov">          0 :       if (doTrial) pTmax = process.scale();</span>
<span class="lineNum">    1878 </span>            : 
<span class="lineNum">    1879 </span>            :       // Let prepare routine do the setup.
<span class="lineNum">    1880 </span><span class="lineNoCov">          0 :       timesDecPtr-&gt;prepare( iSys, event);</span>
<span class="lineNum">    1881 </span>            : 
<span class="lineNum">    1882 </span>            :        // Number of actual branchings
<span class="lineNum">    1883 </span>            :       int nBranch = 0;
<span class="lineNum">    1884 </span>            : 
<span class="lineNum">    1885 </span>            :       // Set up initial veto scale.
<span class="lineNum">    1886 </span><span class="lineNoCov">          0 :       doVeto        = false;</span>
<span class="lineNum">    1887 </span><span class="lineNoCov">          0 :       double pTveto = pTvetoPT;</span>
<span class="lineNum">    1888 </span>            : 
<span class="lineNum">    1889 </span>            :       // Begin evolution down in pT from hard pT scale.
<span class="lineNum">    1890 </span><span class="lineNoCov">          0 :       do {</span>
<span class="lineNum">    1891 </span><span class="lineNoCov">          0 :         typeVetoStep = 0;</span>
<span class="lineNum">    1892 </span><span class="lineNoCov">          0 :         double pTtimes = timesDecPtr-&gt;pTnext( event, pTmax, 0.);</span>
<span class="lineNum">    1893 </span>            : 
<span class="lineNum">    1894 </span>            :         // Allow a user veto. Only do it once, so remember to change pTveto.
<span class="lineNum">    1895 </span><span class="lineNoCov">          0 :         if (pTveto &gt; 0. &amp;&amp; pTveto &gt; pTtimes) {</span>
<span class="lineNum">    1896 </span>            :           pTveto = -1.;
<span class="lineNum">    1897 </span><span class="lineNoCov">          0 :           doVeto = userHooksPtr-&gt;doVetoPT( 5, event);</span>
<span class="lineNum">    1898 </span>            :           // Abort event if vetoed.
<span class="lineNum">    1899 </span><span class="lineNoCov">          0 :           if (doVeto) return false;</span>
<span class="lineNum">    1900 </span>            :         }
<span class="lineNum">    1901 </span>            : 
<span class="lineNum">    1902 </span>            :         // Do a final-state emission (if allowed).
<span class="lineNum">    1903 </span><span class="lineNoCov">          0 :         if (pTtimes &gt; 0.) {</span>
<span class="lineNum">    1904 </span><span class="lineNoCov">          0 :           if (timesDecPtr-&gt;branch( event)) {</span>
<span class="lineNum">    1905 </span><span class="lineNoCov">          0 :             ++nFSRres;</span>
<span class="lineNum">    1906 </span><span class="lineNoCov">          0 :             ++nFSRhard;</span>
<span class="lineNum">    1907 </span><span class="lineNoCov">          0 :             if (canVetoStep &amp;&amp; nFSRhard &lt;= nVetoStep) typeVetoStep = 5;</span>
<span class="lineNum">    1908 </span>            : 
<span class="lineNum">    1909 </span><span class="lineNoCov">          0 :             nBranch++;</span>
<span class="lineNum">    1910 </span><span class="lineNoCov">          0 :             pTLastBranch = pTtimes;</span>
<span class="lineNum">    1911 </span><span class="lineNoCov">          0 :             typeLastBranch = 5;</span>
<span class="lineNum">    1912 </span>            : 
<span class="lineNum">    1913 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    1914 </span>            :           pTmax = pTtimes;
<span class="lineNum">    1915 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1916 </span>            : 
<span class="lineNum">    1917 </span>            :         // If no pT scales above zero then nothing to be done.
<span class="lineNum">    1918 </span>            :         else pTmax = 0.;
<span class="lineNum">    1919 </span>            : 
<span class="lineNum">    1920 </span>            :         // Optionally check for a veto after the first few emissions.
<span class="lineNum">    1921 </span><span class="lineNoCov">          0 :         if (typeVetoStep &gt; 0) {</span>
<span class="lineNum">    1922 </span><span class="lineNoCov">          0 :           doVeto = userHooksPtr-&gt;doVetoStep( typeVetoStep, 0, nFSRhard,</span>
<span class="lineNum">    1923 </span>            :             event);
<span class="lineNum">    1924 </span>            :           // Abort event if vetoed.
<span class="lineNum">    1925 </span><span class="lineNoCov">          0 :           if (doVeto) return false;</span>
<span class="lineNum">    1926 </span>            :         }
<span class="lineNum">    1927 </span>            : 
<span class="lineNum">    1928 </span>            :         // Handle potential merging veto.
<span class="lineNum">    1929 </span><span class="lineNoCov">          0 :         if ( canRemoveEvent &amp;&amp; nFSRhard == 1 ) {</span>
<span class="lineNum">    1930 </span>            :           // Simply check, and possibly reset weights.
<span class="lineNum">    1931 </span><span class="lineNoCov">          0 :           mergingHooksPtr-&gt;doVetoStep( process, event, true );</span>
<span class="lineNum">    1932 </span>            :         }
<span class="lineNum">    1933 </span>            : 
<span class="lineNum">    1934 </span>            :       // Keep on evolving until nothing is left to be done.
<span class="lineNum">    1935 </span><span class="lineNoCov">          0 :       } while (pTmax &gt; 0.  &amp;&amp; (nBranchMax &lt;= 0 || nBranch &lt; nBranchMax) );</span>
<span class="lineNum">    1936 </span>            : 
<span class="lineNum">    1937 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1938 </span>            : 
<span class="lineNum">    1939 </span>            :   // No more systems to be processed. Set total number of emissions.
<span class="lineNum">    1940 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1941 </span><span class="lineNoCov">          0 :   if (skipForR) nFSRinRes = nFSRres;</span>
<span class="lineNum">    1942 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    1943 </span>            : 
<span class="lineNum">    1944 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1945 </span>            : 
<span class="lineNum">    1946 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1947 </span>            : 
<a name="1948"><span class="lineNum">    1948 </span>            : // Perform decays and showers of W and Z emitted in shower.</a>
<span class="lineNum">    1949 </span>            : 
<span class="lineNum">    1950 </span>            : bool PartonLevel::wzDecayShowers( Event&amp; event) {
<span class="lineNum">    1951 </span>            : 
<span class="lineNum">    1952 </span>            :   // Identify W/Z produced by a parton shower.
<span class="lineNum">    1953 </span><span class="lineNoCov">          0 :   for (int iWZ = 0; iWZ &lt; event.size(); ++iWZ)</span>
<span class="lineNum">    1954 </span><span class="lineNoCov">          0 :   if (event[iWZ].isFinal()</span>
<span class="lineNum">    1955 </span><span class="lineNoCov">          0 :     &amp;&amp; (event[iWZ].id() == 23 || event[iWZ].idAbs() == 24) ) {</span>
<span class="lineNum">    1956 </span><span class="lineNoCov">          0 :     int iWZtop = event[iWZ].iTopCopy();</span>
<span class="lineNum">    1957 </span>            :     int typeWZ = 0;
<span class="lineNum">    1958 </span><span class="lineNoCov">          0 :     if (event[iWZtop].statusAbs() == 56) typeWZ = 1;</span>
<span class="lineNum">    1959 </span><span class="lineNoCov">          0 :     if (event[iWZtop].statusAbs() == 47) typeWZ = 2;</span>
<span class="lineNum">    1960 </span><span class="lineNoCov">          0 :     int sizeSave = event.size();</span>
<span class="lineNum">    1961 </span>            : 
<span class="lineNum">    1962 </span>            :     // Map id_Z = 23 -&gt; 93 and id_W = 24 -&gt; 94, for separate decay settings.
<span class="lineNum">    1963 </span>            :     // Let W/Z resonance decay. Restore correct identity and status codes.
<span class="lineNum">    1964 </span><span class="lineNoCov">          0 :     if (typeWZ &gt; 0) {</span>
<span class="lineNum">    1965 </span><span class="lineNoCov">          0 :       int idSave     = event[iWZ].id();</span>
<span class="lineNum">    1966 </span><span class="lineNoCov">          0 :       event[iWZ].id( (idSave &gt; 0) ? idSave + 70 : idSave - 70);</span>
<span class="lineNum">    1967 </span><span class="lineNoCov">          0 :       int statusSave = event[iWZ].status();</span>
<span class="lineNum">    1968 </span><span class="lineNoCov">          0 :       resonanceDecays.next( event, iWZ);</span>
<span class="lineNum">    1969 </span><span class="lineNoCov">          0 :       event[iWZ].id( idSave);</span>
<span class="lineNum">    1970 </span><span class="lineNoCov">          0 :       if (event.size() - sizeSave != 2) return true;</span>
<span class="lineNum">    1971 </span><span class="lineNoCov">          0 :       event[iWZ].status( -statusSave);</span>
<span class="lineNum">    1972 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1973 </span>            : 
<span class="lineNum">    1974 </span>            :     // FSR decays.
<span class="lineNum">    1975 </span><span class="lineNoCov">          0 :     if (typeWZ == 1) {</span>
<span class="lineNum">    1976 </span>            : 
<span class="lineNum">    1977 </span>            :       // Identify fermion after W/Z emission.
<span class="lineNum">    1978 </span><span class="lineNoCov">          0 :       vector&lt;int&gt;  iSisters = event[iWZtop].sisterList();</span>
<span class="lineNum">    1979 </span><span class="lineNoCov">          0 :       if (iSisters.size() != 1) {</span>
<span class="lineNum">    1980 </span><span class="lineNoCov">          0 :         infoPtr-&gt;errorMsg(&quot;Error in PartonLevel::wzDecayShowers: &quot;</span>
<span class="lineNum">    1981 </span>            :           &quot;Not able to find a single sister particle&quot;);
<span class="lineNum">    1982 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1983 </span>            :       }
<span class="lineNum">    1984 </span><span class="lineNoCov">          0 :       int iEmitter = iSisters[0];</span>
<span class="lineNum">    1985 </span>            : 
<span class="lineNum">    1986 </span>            :       // Boosts to study decay in W/Z rest frame.
<span class="lineNum">    1987 </span><span class="lineNoCov">          0 :       RotBstMatrix MtoNew, MtoRest, MtoCM;</span>
<span class="lineNum">    1988 </span><span class="lineNoCov">          0 :       MtoNew.bst( event[iWZtop].p(), event[iWZ].p());</span>
<span class="lineNum">    1989 </span><span class="lineNoCov">          0 :       MtoRest.bstback( event[iWZ].p());</span>
<span class="lineNum">    1990 </span><span class="lineNoCov">          0 :       MtoCM.bst( event[iWZ].p());</span>
<span class="lineNum">    1991 </span>            : 
<span class="lineNum">    1992 </span>            :       // Emitter and recoiler in W/Z rest frame.
<span class="lineNum">    1993 </span><span class="lineNoCov">          0 :       Vec4 pEmitter = event[iEmitter].p();</span>
<span class="lineNum">    1994 </span><span class="lineNoCov">          0 :       pEmitter.rotbst( MtoNew);</span>
<span class="lineNum">    1995 </span><span class="lineNoCov">          0 :       pEmitter.rotbst( MtoRest);</span>
<span class="lineNum">    1996 </span><span class="lineNoCov">          0 :       if (event[iWZtop + 1].statusAbs() != 52) {</span>
<span class="lineNum">    1997 </span><span class="lineNoCov">          0 :         infoPtr-&gt;errorMsg(&quot;Error in PartonLevel::wzDecayShowers: &quot;</span>
<span class="lineNum">    1998 </span>            :           &quot;Found wrong recoiler&quot;);
<span class="lineNum">    1999 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    2000 </span>            :       }
<span class="lineNum">    2001 </span><span class="lineNoCov">          0 :       Vec4 pRecoiler = event[iWZtop + 1].p();</span>
<span class="lineNum">    2002 </span><span class="lineNoCov">          0 :       pRecoiler.rotbst( MtoNew);</span>
<span class="lineNum">    2003 </span><span class="lineNoCov">          0 :       pRecoiler.rotbst( MtoRest);</span>
<span class="lineNum">    2004 </span><span class="lineNoCov">          0 :       Vec4 pWZRest = event[iWZ].p();</span>
<span class="lineNum">    2005 </span><span class="lineNoCov">          0 :       pWZRest.rotbst( MtoRest);</span>
<span class="lineNum">    2006 </span>            : 
<span class="lineNum">    2007 </span>            :       // Always choose p4 as the particle and p5 as the anti-particle.
<span class="lineNum">    2008 </span><span class="lineNoCov">          0 :       Vec4 p4 = pEmitter;</span>
<span class="lineNum">    2009 </span><span class="lineNoCov">          0 :       Vec4 p5 = pRecoiler;</span>
<span class="lineNum">    2010 </span><span class="lineNoCov">          0 :       if (event[iEmitter].id() &lt; 0) swap( p4, p5);</span>
<span class="lineNum">    2011 </span>            : 
<span class="lineNum">    2012 </span>            :       // Decay daughters in W/Z rest frame.
<span class="lineNum">    2013 </span>            :       // Always choose pDec1 as the particle and p2Dec as the anti-particle.
<span class="lineNum">    2014 </span><span class="lineNoCov">          0 :       Vec4 pDec1 = event[sizeSave].p();</span>
<span class="lineNum">    2015 </span><span class="lineNoCov">          0 :       Vec4 pDec2 = event[sizeSave + 1].p();</span>
<span class="lineNum">    2016 </span><span class="lineNoCov">          0 :       if (event[sizeSave].id() &lt; 0) swap( pDec1, pDec2);</span>
<span class="lineNum">    2017 </span><span class="lineNoCov">          0 :       pDec1.rotbst( MtoRest);</span>
<span class="lineNum">    2018 </span><span class="lineNoCov">          0 :       pDec2.rotbst( MtoRest);</span>
<span class="lineNum">    2019 </span>            : 
<span class="lineNum">    2020 </span>            :       // Couplings.
<span class="lineNum">    2021 </span>            :       double li2, ri2, lf2, rf2;
<span class="lineNum">    2022 </span>            :       // Z couplings: make use of initial fermion polarization if set.
<span class="lineNum">    2023 </span><span class="lineNoCov">          0 :       if (event[iWZ].id() == 23) {</span>
<span class="lineNum">    2024 </span><span class="lineNoCov">          0 :         li2 = pow2(couplingsPtr-&gt;lf( event[iEmitter].idAbs() ));</span>
<span class="lineNum">    2025 </span><span class="lineNoCov">          0 :         ri2 = pow2(couplingsPtr-&gt;rf( event[iEmitter].idAbs() ));</span>
<span class="lineNum">    2026 </span><span class="lineNoCov">          0 :         lf2 = pow2(couplingsPtr-&gt;lf( event[sizeSave].idAbs() ));</span>
<span class="lineNum">    2027 </span><span class="lineNoCov">          0 :         rf2 = pow2(couplingsPtr-&gt;rf( event[sizeSave].idAbs() ));</span>
<span class="lineNum">    2028 </span><span class="lineNoCov">          0 :         if ( abs( event[iEmitter].pol() + 1.) &lt; 0.1) ri2 = 0.;</span>
<span class="lineNum">    2029 </span><span class="lineNoCov">          0 :         if ( abs( event[iEmitter].pol() - 1.) &lt; 0.1) li2 = 0.;</span>
<span class="lineNum">    2030 </span>            :       // W couplings.
<span class="lineNum">    2031 </span>            :       } else {
<span class="lineNum">    2032 </span>            :         li2 = 1.;
<span class="lineNum">    2033 </span>            :         ri2 = 0.;
<span class="lineNum">    2034 </span>            :         lf2 = 1.;
<span class="lineNum">    2035 </span>            :         rf2 = 0.;
<span class="lineNum">    2036 </span>            :       }
<span class="lineNum">    2037 </span>            : 
<span class="lineNum">    2038 </span>            :       // Different needed kinematic variables.
<span class="lineNum">    2039 </span><span class="lineNoCov">          0 :       double sWZER = (p4 + pWZRest + p5).m2Calc();</span>
<span class="lineNum">    2040 </span><span class="lineNoCov">          0 :       double x1    = 2. * p4 * (p4 + pWZRest + p5) / sWZER;</span>
<span class="lineNum">    2041 </span><span class="lineNoCov">          0 :       double x2    = 2. * p5 * (p4 + pWZRest + p5) / sWZER;</span>
<span class="lineNum">    2042 </span><span class="lineNoCov">          0 :       double x1s   = x1 * x1;</span>
<span class="lineNum">    2043 </span><span class="lineNoCov">          0 :       double x2s   = x2 * x2;</span>
<span class="lineNum">    2044 </span><span class="lineNoCov">          0 :       double m2Sel = pWZRest.m2Calc();</span>
<span class="lineNum">    2045 </span><span class="lineNoCov">          0 :       double rWZER = m2Sel / sWZER;</span>
<span class="lineNum">    2046 </span>            : 
<span class="lineNum">    2047 </span>            :       // Calculate constants needed in correction.
<span class="lineNum">    2048 </span><span class="lineNoCov">          0 :       double con[9];</span>
<span class="lineNum">    2049 </span><span class="lineNoCov">          0 :       con[0] = 2. * m2Sel * (1.-x1) * ((x2s+1.-x1-x2) - rWZER * (1.-x2))</span>
<span class="lineNum">    2050 </span><span class="lineNoCov">          0 :              * (li2 * lf2 + ri2 * rf2);</span>
<span class="lineNum">    2051 </span><span class="lineNoCov">          0 :       con[1] = 2. * m2Sel * (1.-x2) * ((x1s+1.-x1-x2) - rWZER * (1.-x1))</span>
<span class="lineNum">    2052 </span><span class="lineNoCov">          0 :              * (li2 * rf2 + ri2 * lf2);</span>
<span class="lineNum">    2053 </span><span class="lineNoCov">          0 :       con[2] = 2. * m2Sel * (1.-x1) * ((x2s+1.-x1-x2) - rWZER * (1.-x2))</span>
<span class="lineNum">    2054 </span><span class="lineNoCov">          0 :              * (li2 * rf2 + ri2 * lf2);</span>
<span class="lineNum">    2055 </span><span class="lineNoCov">          0 :       con[3] = 2. * m2Sel * (1.-x2) * ((x1s+1.-x1-x2) - rWZER * (1.-x1))</span>
<span class="lineNum">    2056 </span><span class="lineNoCov">          0 :              * (li2 * lf2 + ri2 * rf2);</span>
<span class="lineNum">    2057 </span><span class="lineNoCov">          0 :       con[4] = m2Sel * sWZER * (1.-x1) * (1.-x2) * ((x1+x2-1.) + rWZER)</span>
<span class="lineNum">    2058 </span><span class="lineNoCov">          0 :              * (li2 + ri2) * (lf2 + rf2);</span>
<span class="lineNum">    2059 </span><span class="lineNoCov">          0 :       con[5] = -4. * (1.-x1) * (1.-x2) * (li2 + ri2) * (lf2 + rf2);</span>
<span class="lineNum">    2060 </span><span class="lineNoCov">          0 :       con[6] = -4. * (1.-x1) * (1.-x2) * (li2 + ri2) * (lf2 + rf2);</span>
<span class="lineNum">    2061 </span><span class="lineNoCov">          0 :       con[7] = 4. * (1.-x1) * ((1.-x1) - rWZER * (1.-x2))</span>
<span class="lineNum">    2062 </span><span class="lineNoCov">          0 :              * (li2 + ri2) * (lf2 + rf2);</span>
<span class="lineNum">    2063 </span><span class="lineNoCov">          0 :       con[8] = 4. * (1.-x2) * ((1.-x2) - rWZER * (1.-x1))</span>
<span class="lineNum">    2064 </span><span class="lineNoCov">          0 :              * (li2 + ri2) * (lf2 + rf2);</span>
<span class="lineNum">    2065 </span>            : 
<span class="lineNum">    2066 </span>            :       // Find maximum value: try pDec1 and pDec2 = -pDec1 along +-x, +-y, +-z.
<span class="lineNum">    2067 </span>            :       double wtMax  = 0.;
<span class="lineNum">    2068 </span><span class="lineNoCov">          0 :       double pAbs12 = pDec1.pAbs();</span>
<span class="lineNum">    2069 </span><span class="lineNoCov">          0 :       for (int j = 0; j &lt; 6; ++j) {</span>
<span class="lineNum">    2070 </span><span class="lineNoCov">          0 :         Vec4 pDec1Test( 0., 0., 0., pDec1.e());</span>
<span class="lineNum">    2071 </span><span class="lineNoCov">          0 :         Vec4 pDec2Test( 0., 0., 0., pDec2.e());</span>
<span class="lineNum">    2072 </span><span class="lineNoCov">          0 :         if      (j == 0) { pDec1Test.px(  pAbs12);  pDec1Test.px( -pAbs12);}</span>
<span class="lineNum">    2073 </span><span class="lineNoCov">          0 :         else if (j == 1) { pDec1Test.px( -pAbs12);  pDec1Test.px(  pAbs12);}</span>
<span class="lineNum">    2074 </span><span class="lineNoCov">          0 :         else if (j == 2) { pDec1Test.py(  pAbs12);  pDec1Test.py( -pAbs12);}</span>
<span class="lineNum">    2075 </span><span class="lineNoCov">          0 :         else if (j == 3) { pDec1Test.py( -pAbs12);  pDec1Test.py(  pAbs12);}</span>
<span class="lineNum">    2076 </span><span class="lineNoCov">          0 :         else if (j == 4) { pDec1Test.pz(  pAbs12);  pDec1Test.pz( -pAbs12);}</span>
<span class="lineNum">    2077 </span><span class="lineNoCov">          0 :         else if (j == 5) { pDec1Test.pz( -pAbs12);  pDec1Test.pz(  pAbs12);}</span>
<span class="lineNum">    2078 </span>            : 
<span class="lineNum">    2079 </span>            :         // Evaluate matrix element and compare with current maximum.
<span class="lineNum">    2080 </span><span class="lineNoCov">          0 :         double p2p4Test = p4 * pDec1Test;</span>
<span class="lineNum">    2081 </span><span class="lineNoCov">          0 :         double p3p4Test = p4 * pDec2Test;</span>
<span class="lineNum">    2082 </span><span class="lineNoCov">          0 :         double p2p5Test = p5 * pDec1Test;</span>
<span class="lineNum">    2083 </span><span class="lineNoCov">          0 :         double p3p5Test = p5 * pDec2Test;</span>
<span class="lineNum">    2084 </span><span class="lineNoCov">          0 :         double testValues[9] = { p2p4Test, p2p5Test, p3p4Test, p3p5Test, 1.,</span>
<span class="lineNum">    2085 </span><span class="lineNoCov">          0 :           p2p5Test * p3p4Test, p2p4Test * p3p5Test, p2p4Test * p3p4Test,</span>
<span class="lineNum">    2086 </span><span class="lineNoCov">          0 :           p2p5Test * p3p5Test};</span>
<span class="lineNum">    2087 </span>            :         double wtTest = 0.;
<span class="lineNum">    2088 </span><span class="lineNoCov">          0 :         for (int i = 0; i &lt; 9; ++i) wtTest += con[i] * testValues[i];</span>
<span class="lineNum">    2089 </span><span class="lineNoCov">          0 :         if (wtTest &gt; wtMax) wtMax = wtTest;</span>
<span class="lineNum">    2090 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    2091 </span>            : 
<span class="lineNum">    2092 </span>            :       // Multiply by four to ensure maximum is an overestimate.
<span class="lineNum">    2093 </span><span class="lineNoCov">          0 :       wtMax *= 4.;</span>
<span class="lineNum">    2094 </span>            : 
<span class="lineNum">    2095 </span>            :       // Iterate with new angles until weighting succeeds.
<span class="lineNum">    2096 </span>            :       int nRot = -1;
<span class="lineNum">    2097 </span>            :       double wt = 0.;
<span class="lineNum">    2098 </span><span class="lineNoCov">          0 :       do {</span>
<span class="lineNum">    2099 </span><span class="lineNoCov">          0 :         ++nRot;</span>
<span class="lineNum">    2100 </span><span class="lineNoCov">          0 :         if (nRot &gt; 0) {</span>
<span class="lineNum">    2101 </span><span class="lineNoCov">          0 :           RotBstMatrix MrndmRot;</span>
<span class="lineNum">    2102 </span><span class="lineNoCov">          0 :           MrndmRot.rot( acos(2. * rndmPtr-&gt;flat() - 1.),</span>
<span class="lineNum">    2103 </span><span class="lineNoCov">          0 :             2. * M_PI * rndmPtr-&gt;flat());</span>
<span class="lineNum">    2104 </span><span class="lineNoCov">          0 :           pDec1.rotbst(MrndmRot);</span>
<span class="lineNum">    2105 </span><span class="lineNoCov">          0 :           pDec2.rotbst(MrndmRot);</span>
<span class="lineNum">    2106 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2107 </span>            : 
<span class="lineNum">    2108 </span>            :         // p2 is decay product, p3 is anti decay product,
<span class="lineNum">    2109 </span>            :         // p4 is dipole particle, p5 is dipole anti particle.
<span class="lineNum">    2110 </span>            :         // So far assumed that we always have qQ-dipole.
<span class="lineNum">    2111 </span><span class="lineNoCov">          0 :         double p2p4 = p4 * pDec1;</span>
<span class="lineNum">    2112 </span><span class="lineNoCov">          0 :         double p3p4 = p4 * pDec2;</span>
<span class="lineNum">    2113 </span><span class="lineNoCov">          0 :         double p2p5 = p5 * pDec1;</span>
<span class="lineNum">    2114 </span><span class="lineNoCov">          0 :         double p3p5 = p5 * pDec2;</span>
<span class="lineNum">    2115 </span>            : 
<span class="lineNum">    2116 </span>            :         // Calculate weight and compare with maximum weight.
<span class="lineNum">    2117 </span><span class="lineNoCov">          0 :         double wtValues[9] = { p2p4, p2p5, p3p4, p3p5, 1., p2p5 * p3p4,</span>
<span class="lineNum">    2118 </span><span class="lineNoCov">          0 :           p2p4 * p3p5, p2p4 * p3p4, p2p5 * p3p5};</span>
<span class="lineNum">    2119 </span>            :         wt =  0.;
<span class="lineNum">    2120 </span><span class="lineNoCov">          0 :         for (int i = 0; i &lt; 9; ++i) wt += con[i] * wtValues[i];</span>
<span class="lineNum">    2121 </span><span class="lineNoCov">          0 :         if (wt &gt; wtMax || wt &lt; 0.) {</span>
<span class="lineNum">    2122 </span><span class="lineNoCov">          0 :           infoPtr-&gt;errorMsg(&quot;Error in PartonLevel::wzDecayShowers: &quot;</span>
<span class="lineNum">    2123 </span>            :           &quot;wt bigger than wtMax or less than zero&quot;);
<span class="lineNum">    2124 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">    2125 </span>            :         }
<span class="lineNum">    2126 </span><span class="lineNoCov">          0 :       } while (wt &lt; wtMax * rndmPtr-&gt;flat());</span>
<span class="lineNum">    2127 </span>            : 
<span class="lineNum">    2128 </span>            :       // If momenta rotated then store new ones.
<span class="lineNum">    2129 </span><span class="lineNoCov">          0 :       if (nRot &gt; 0) {</span>
<span class="lineNum">    2130 </span><span class="lineNoCov">          0 :         pDec1.rotbst( MtoCM);</span>
<span class="lineNum">    2131 </span><span class="lineNoCov">          0 :         pDec2.rotbst( MtoCM);</span>
<span class="lineNum">    2132 </span><span class="lineNoCov">          0 :         if (event[sizeSave].id() &gt; 0) {</span>
<span class="lineNum">    2133 </span><span class="lineNoCov">          0 :           event[sizeSave].p( pDec1);</span>
<span class="lineNum">    2134 </span><span class="lineNoCov">          0 :           event[sizeSave + 1].p( pDec2);</span>
<span class="lineNum">    2135 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2136 </span>            :         else {
<span class="lineNum">    2137 </span><span class="lineNoCov">          0 :           event[sizeSave].p( pDec2);</span>
<span class="lineNum">    2138 </span><span class="lineNoCov">          0 :           event[sizeSave + 1].p( pDec1);</span>
<span class="lineNum">    2139 </span>            :         }
<span class="lineNum">    2140 </span>            :       }
<span class="lineNum">    2141 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2142 </span>            : 
<span class="lineNum">    2143 </span>            :     // ISR decays.
<span class="lineNum">    2144 </span><span class="lineNoCov">          0 :     if (typeWZ == 2) {</span>
<span class="lineNum">    2145 </span>            : 
<span class="lineNum">    2146 </span>            :       // Identify mother of W/Z emission.
<span class="lineNum">    2147 </span><span class="lineNoCov">          0 :       double iMother = event[iWZtop].mother1();</span>
<span class="lineNum">    2148 </span>            : 
<span class="lineNum">    2149 </span>            :       // Boosts to study decay in W/Z rest frame.
<span class="lineNum">    2150 </span><span class="lineNoCov">          0 :       RotBstMatrix MtoNew, MtoRest, MtoCM;</span>
<span class="lineNum">    2151 </span><span class="lineNoCov">          0 :       MtoNew.bst( event[iWZtop].p(), event[iWZ].p());</span>
<span class="lineNum">    2152 </span><span class="lineNoCov">          0 :       MtoRest.bstback( event[iWZ].p());</span>
<span class="lineNum">    2153 </span><span class="lineNoCov">          0 :       MtoCM.bst( event[iWZ].p());</span>
<span class="lineNum">    2154 </span>            : 
<span class="lineNum">    2155 </span>            :       // Find recoiler.
<span class="lineNum">    2156 </span>            :       int iRecoiler;
<span class="lineNum">    2157 </span><span class="lineNoCov">          0 :       if (event[iMother + 1].statusAbs() == 42) iRecoiler = iMother + 1;</span>
<span class="lineNum">    2158 </span><span class="lineNoCov">          0 :       else if (event[iMother - 1].statusAbs() == 42) iRecoiler = iMother - 1;</span>
<span class="lineNum">    2159 </span>            :       else {
<span class="lineNum">    2160 </span><span class="lineNoCov">          0 :         infoPtr-&gt;errorMsg(&quot;Error in PartonLevel::wzDecayShowers: &quot;</span>
<span class="lineNum">    2161 </span>            :           &quot;Found wrong recoiler&quot;);
<span class="lineNum">    2162 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    2163 </span>            :       }
<span class="lineNum">    2164 </span>            : 
<span class="lineNum">    2165 </span>            :       // Emitter and recoiler in W/Z rest frame.
<span class="lineNum">    2166 </span><span class="lineNoCov">          0 :       Vec4 pMother = event[iMother].p();</span>
<span class="lineNum">    2167 </span><span class="lineNoCov">          0 :       pMother.rotbst( MtoNew);</span>
<span class="lineNum">    2168 </span><span class="lineNoCov">          0 :       pMother.rotbst( MtoRest);</span>
<span class="lineNum">    2169 </span><span class="lineNoCov">          0 :       Vec4 pRecoiler = event[iRecoiler].p();</span>
<span class="lineNum">    2170 </span><span class="lineNoCov">          0 :       pRecoiler.rotbst( MtoNew);</span>
<span class="lineNum">    2171 </span><span class="lineNoCov">          0 :       pRecoiler.rotbst( MtoRest);</span>
<span class="lineNum">    2172 </span><span class="lineNoCov">          0 :       Vec4 pWZRest = event[iWZ].p();</span>
<span class="lineNum">    2173 </span><span class="lineNoCov">          0 :       pWZRest.rotbst( MtoRest);</span>
<span class="lineNum">    2174 </span>            : 
<span class="lineNum">    2175 </span>            :       // Always choose p1 as the particle and p2 as the anti-particle.
<span class="lineNum">    2176 </span>            :       // If no anti-particles just continue.
<span class="lineNum">    2177 </span><span class="lineNoCov">          0 :       Vec4 p1 = pMother;</span>
<span class="lineNum">    2178 </span><span class="lineNoCov">          0 :       Vec4 p2 = pRecoiler;</span>
<span class="lineNum">    2179 </span><span class="lineNoCov">          0 :       if (event[iMother].id() &lt; 0) swap( p1, p2);</span>
<span class="lineNum">    2180 </span>            : 
<span class="lineNum">    2181 </span>            :       // Decay daughters in W/Z rest frame.
<span class="lineNum">    2182 </span>            :       // Always choose pDec1 as the particle and p2Dec as the anti-particle.
<span class="lineNum">    2183 </span><span class="lineNoCov">          0 :       Vec4 pDec1 = event[sizeSave].p();</span>
<span class="lineNum">    2184 </span><span class="lineNoCov">          0 :       Vec4 pDec2 = event[sizeSave + 1].p();</span>
<span class="lineNum">    2185 </span><span class="lineNoCov">          0 :       if (event[sizeSave].id() &lt; 0) swap( pDec1, pDec2);</span>
<span class="lineNum">    2186 </span><span class="lineNoCov">          0 :       pDec1.rotbst( MtoRest);</span>
<span class="lineNum">    2187 </span><span class="lineNoCov">          0 :       pDec2.rotbst( MtoRest);</span>
<span class="lineNum">    2188 </span>            : 
<span class="lineNum">    2189 </span>            :       // Couplings.
<span class="lineNum">    2190 </span>            :       double li2, ri2, lf2, rf2;
<span class="lineNum">    2191 </span>            :       // Z couplings: make use of initial fermion polarization if set.
<span class="lineNum">    2192 </span><span class="lineNoCov">          0 :       if (event[iWZ].id() == 23) {</span>
<span class="lineNum">    2193 </span><span class="lineNoCov">          0 :         li2 = pow2(couplingsPtr-&gt;lf( event[iMother].idAbs() ));</span>
<span class="lineNum">    2194 </span><span class="lineNoCov">          0 :         ri2 = pow2(couplingsPtr-&gt;rf( event[iMother].idAbs() ));</span>
<span class="lineNum">    2195 </span><span class="lineNoCov">          0 :         lf2 = pow2(couplingsPtr-&gt;lf( event[sizeSave].idAbs() ));</span>
<span class="lineNum">    2196 </span><span class="lineNoCov">          0 :         rf2 = pow2(couplingsPtr-&gt;rf( event[sizeSave].idAbs() ));</span>
<span class="lineNum">    2197 </span><span class="lineNoCov">          0 :         if ( abs( event[iMother].pol() + 1.) &lt; 0.1) ri2 = 0.;</span>
<span class="lineNum">    2198 </span><span class="lineNoCov">          0 :         if ( abs( event[iMother].pol() - 1.) &lt; 0.1) li2 = 0.;</span>
<span class="lineNum">    2199 </span>            :       // W couplings.
<span class="lineNum">    2200 </span>            :       } else {
<span class="lineNum">    2201 </span>            :         li2 = 1.;
<span class="lineNum">    2202 </span>            :         ri2 = 0.;
<span class="lineNum">    2203 </span>            :         lf2 = 1.;
<span class="lineNum">    2204 </span>            :         rf2 = 0.;
<span class="lineNum">    2205 </span>            :       }
<span class="lineNum">    2206 </span>            : 
<span class="lineNum">    2207 </span>            :       // Different needed kinematic variables.
<span class="lineNum">    2208 </span><span class="lineNoCov">          0 :       double s = (p1 + p2).m2Calc();</span>
<span class="lineNum">    2209 </span><span class="lineNoCov">          0 :       double t = (p1-pWZRest).m2Calc();</span>
<span class="lineNum">    2210 </span><span class="lineNoCov">          0 :       double u = (p2-pWZRest).m2Calc();</span>
<span class="lineNum">    2211 </span><span class="lineNoCov">          0 :       double m2Sel = pWZRest.m2Calc();</span>
<span class="lineNum">    2212 </span><span class="lineNoCov">          0 :       double m2Final = t + u + s - m2Sel;</span>
<span class="lineNum">    2213 </span>            : 
<span class="lineNum">    2214 </span>            :       // Calculate constants needed in correction.
<span class="lineNum">    2215 </span><span class="lineNoCov">          0 :       double con[9];</span>
<span class="lineNum">    2216 </span><span class="lineNoCov">          0 :       con[0] = 2. * m2Sel * (u * (1. - m2Final / t) + s)</span>
<span class="lineNum">    2217 </span><span class="lineNoCov">          0 :         * (li2 * rf2 + ri2 * lf2);</span>
<span class="lineNum">    2218 </span><span class="lineNoCov">          0 :       con[1] = 2. * m2Sel * (u * (1. - m2Final / t) + s)</span>
<span class="lineNum">    2219 </span><span class="lineNoCov">          0 :         * (li2 * lf2 + ri2 * rf2);</span>
<span class="lineNum">    2220 </span><span class="lineNoCov">          0 :       con[2] = 2. * m2Sel * (t * (1. - m2Final / u) + s)</span>
<span class="lineNum">    2221 </span><span class="lineNoCov">          0 :         * (li2 * lf2 + ri2 * rf2);</span>
<span class="lineNum">    2222 </span><span class="lineNoCov">          0 :       con[3] = 2. * m2Sel * (t * (1. - m2Final / u) + s)</span>
<span class="lineNum">    2223 </span><span class="lineNoCov">          0 :         * (li2 * rf2 + ri2 * lf2);</span>
<span class="lineNum">    2224 </span><span class="lineNoCov">          0 :       con[4] = m2Sel * m2Final * s * (li2 + ri2) * (lf2 + rf2);</span>
<span class="lineNum">    2225 </span><span class="lineNoCov">          0 :       con[5] = -4. * m2Final * (li2 + ri2) * (lf2 + rf2);</span>
<span class="lineNum">    2226 </span><span class="lineNoCov">          0 :       con[6] = -4. * m2Final * (li2 + ri2) * (lf2 + rf2);</span>
<span class="lineNum">    2227 </span><span class="lineNoCov">          0 :       con[7] = 4. * (m2Final * u / t - m2Sel) * (li2 + ri2) * (lf2 + rf2);</span>
<span class="lineNum">    2228 </span><span class="lineNoCov">          0 :       con[8] = 4. * (m2Final * t / u - m2Sel) * (li2 + ri2) * (lf2 + rf2);</span>
<span class="lineNum">    2229 </span>            : 
<span class="lineNum">    2230 </span>            :       // Find maximum value: try pDec1 and pDec2 = -pDec1 along +-x, +-y, +-z.
<span class="lineNum">    2231 </span>            :       double wtMax  = 0.;
<span class="lineNum">    2232 </span><span class="lineNoCov">          0 :       double pAbs12 = pDec1.pAbs();</span>
<span class="lineNum">    2233 </span><span class="lineNoCov">          0 :       for (int j = 0; j &lt; 6; ++j) {</span>
<span class="lineNum">    2234 </span><span class="lineNoCov">          0 :         Vec4 pDec1Test( 0., 0., 0., pDec1.e());</span>
<span class="lineNum">    2235 </span><span class="lineNoCov">          0 :         Vec4 pDec2Test( 0., 0., 0., pDec2.e());</span>
<span class="lineNum">    2236 </span><span class="lineNoCov">          0 :         if      (j == 0) { pDec1Test.px(  pAbs12);  pDec1Test.px( -pAbs12);}</span>
<span class="lineNum">    2237 </span><span class="lineNoCov">          0 :         else if (j == 1) { pDec1Test.px( -pAbs12);  pDec1Test.px(  pAbs12);}</span>
<span class="lineNum">    2238 </span><span class="lineNoCov">          0 :         else if (j == 2) { pDec1Test.py(  pAbs12);  pDec1Test.py( -pAbs12);}</span>
<span class="lineNum">    2239 </span><span class="lineNoCov">          0 :         else if (j == 3) { pDec1Test.py( -pAbs12);  pDec1Test.py(  pAbs12);}</span>
<span class="lineNum">    2240 </span><span class="lineNoCov">          0 :         else if (j == 4) { pDec1Test.pz(  pAbs12);  pDec1Test.pz( -pAbs12);}</span>
<span class="lineNum">    2241 </span><span class="lineNoCov">          0 :         else if (j == 5) { pDec1Test.pz( -pAbs12);  pDec1Test.pz(  pAbs12);}</span>
<span class="lineNum">    2242 </span>            : 
<span class="lineNum">    2243 </span>            :         // Evaluate matrix element and compare with current maximum.
<span class="lineNum">    2244 </span><span class="lineNoCov">          0 :         double p1p4Test = p1 * pDec1Test;</span>
<span class="lineNum">    2245 </span><span class="lineNoCov">          0 :         double p1p5Test = p1 * pDec2Test;</span>
<span class="lineNum">    2246 </span><span class="lineNoCov">          0 :         double p2p4Test = p2 * pDec1Test;</span>
<span class="lineNum">    2247 </span><span class="lineNoCov">          0 :         double p2p5Test = p2 * pDec2Test;</span>
<span class="lineNum">    2248 </span><span class="lineNoCov">          0 :         double testValues[9] = { p1p4Test, p1p5Test, p2p4Test, p2p5Test, 1.,</span>
<span class="lineNum">    2249 </span><span class="lineNoCov">          0 :           p1p4Test * p2p5Test, p1p5Test * p2p4Test, p1p4Test * p1p5Test,</span>
<span class="lineNum">    2250 </span><span class="lineNoCov">          0 :           p2p4Test * p2p5Test};</span>
<span class="lineNum">    2251 </span>            :         double wtTest = 0.;
<span class="lineNum">    2252 </span><span class="lineNoCov">          0 :         for (int i = 0; i &lt; 9; ++i) wtTest += con[i] * testValues[i];</span>
<span class="lineNum">    2253 </span><span class="lineNoCov">          0 :         if (wtTest &gt; wtMax) wtMax = wtTest;</span>
<span class="lineNum">    2254 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    2255 </span>            : 
<span class="lineNum">    2256 </span>            :       // Multiply by four to ensure maximum is an overestimate.
<span class="lineNum">    2257 </span><span class="lineNoCov">          0 :       wtMax *= 4.;</span>
<span class="lineNum">    2258 </span>            : 
<span class="lineNum">    2259 </span>            :       // Iterate with new angles until weighting succeeds.
<span class="lineNum">    2260 </span>            :       int nRot = -1;
<span class="lineNum">    2261 </span>            :       double wt = 0.;
<span class="lineNum">    2262 </span><span class="lineNoCov">          0 :       do {</span>
<span class="lineNum">    2263 </span><span class="lineNoCov">          0 :         ++nRot;</span>
<span class="lineNum">    2264 </span><span class="lineNoCov">          0 :         if (nRot &gt; 0) {</span>
<span class="lineNum">    2265 </span><span class="lineNoCov">          0 :           RotBstMatrix MrndmRot;</span>
<span class="lineNum">    2266 </span><span class="lineNoCov">          0 :           MrndmRot.rot( acos(2. * rndmPtr-&gt;flat() - 1.),</span>
<span class="lineNum">    2267 </span><span class="lineNoCov">          0 :             2. * M_PI * rndmPtr-&gt;flat());</span>
<span class="lineNum">    2268 </span><span class="lineNoCov">          0 :           pDec1.rotbst(MrndmRot);</span>
<span class="lineNum">    2269 </span><span class="lineNoCov">          0 :           pDec2.rotbst(MrndmRot);</span>
<span class="lineNum">    2270 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2271 </span>            : 
<span class="lineNum">    2272 </span>            :         // p2 is decay product, p3 is anti decay product,
<span class="lineNum">    2273 </span>            :         // p4 is dipole particle, p5 is dipole anti particle.
<span class="lineNum">    2274 </span>            :         // So far assumed that we always have qQ-dipole.
<span class="lineNum">    2275 </span><span class="lineNoCov">          0 :         double p1p4 = p1 * pDec1;</span>
<span class="lineNum">    2276 </span><span class="lineNoCov">          0 :         double p1p5 = p1 * pDec2;</span>
<span class="lineNum">    2277 </span><span class="lineNoCov">          0 :         double p2p4 = p2 * pDec1;</span>
<span class="lineNum">    2278 </span><span class="lineNoCov">          0 :         double p2p5 = p2 * pDec2;</span>
<span class="lineNum">    2279 </span>            : 
<span class="lineNum">    2280 </span>            :         // Calculate weight and compare with maximum weight.
<span class="lineNum">    2281 </span><span class="lineNoCov">          0 :         double wtValues[9] = { p1p4, p1p5, p2p4, p2p5, 1., p1p4 * p2p5,</span>
<span class="lineNum">    2282 </span><span class="lineNoCov">          0 :           p1p5 * p2p4, p1p4 * p1p5, p2p4 * p2p5};</span>
<span class="lineNum">    2283 </span>            :         wt =  0.;
<span class="lineNum">    2284 </span><span class="lineNoCov">          0 :         for (int i = 0; i &lt; 9; ++i) wt += con[i] * wtValues[i];</span>
<span class="lineNum">    2285 </span><span class="lineNoCov">          0 :         if (wt &gt; wtMax || wt &lt; 0.) {</span>
<span class="lineNum">    2286 </span><span class="lineNoCov">          0 :           infoPtr-&gt;errorMsg(&quot;Error in PartonLevel::wzDecayShowers: &quot;</span>
<span class="lineNum">    2287 </span>            :             &quot;wt bigger than wtMax or less than zero&quot;);
<span class="lineNum">    2288 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">    2289 </span>            :         }
<span class="lineNum">    2290 </span><span class="lineNoCov">          0 :       } while (wt &lt; wtMax * rndmPtr-&gt;flat());</span>
<span class="lineNum">    2291 </span>            : 
<span class="lineNum">    2292 </span>            :       // If momenta rotated then store new ones.
<span class="lineNum">    2293 </span><span class="lineNoCov">          0 :       if (nRot &gt; 0) {</span>
<span class="lineNum">    2294 </span><span class="lineNoCov">          0 :         pDec1.rotbst( MtoCM);</span>
<span class="lineNum">    2295 </span><span class="lineNoCov">          0 :         pDec2.rotbst( MtoCM);</span>
<span class="lineNum">    2296 </span><span class="lineNoCov">          0 :         if (event[sizeSave].id() &gt; 0) {</span>
<span class="lineNum">    2297 </span><span class="lineNoCov">          0 :           event[sizeSave].p( pDec1);</span>
<span class="lineNum">    2298 </span><span class="lineNoCov">          0 :           event[sizeSave + 1].p( pDec2);</span>
<span class="lineNum">    2299 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2300 </span>            :         else {
<span class="lineNum">    2301 </span><span class="lineNoCov">          0 :           event[sizeSave].p( pDec2);</span>
<span class="lineNum">    2302 </span><span class="lineNoCov">          0 :           event[sizeSave + 1].p( pDec1);</span>
<span class="lineNum">    2303 </span>            :         }
<span class="lineNum">    2304 </span>            :       }
<span class="lineNum">    2305 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2306 </span>            : 
<span class="lineNum">    2307 </span>            :     // Add new system, automatically with two empty beam slots.
<span class="lineNum">    2308 </span><span class="lineNoCov">          0 :     if (typeWZ &gt; 0) {</span>
<span class="lineNum">    2309 </span>            :       // Maximum shower scale set by mother mass.
<span class="lineNum">    2310 </span><span class="lineNoCov">          0 :       double pTmax = 0.5 * event[iWZ].m();</span>
<span class="lineNum">    2311 </span><span class="lineNoCov">          0 :       int iSys = partonSystemsPtr-&gt;addSys();</span>
<span class="lineNum">    2312 </span><span class="lineNoCov">          0 :       partonSystemsPtr-&gt;setSHat(iSys, pow2(event[iWZ].m()) );</span>
<span class="lineNum">    2313 </span><span class="lineNoCov">          0 :       partonSystemsPtr-&gt;setPTHat(iSys, pTmax );</span>
<span class="lineNum">    2314 </span><span class="lineNoCov">          0 :       for (int i = sizeSave; i &lt; event.size(); ++i)</span>
<span class="lineNum">    2315 </span><span class="lineNoCov">          0 :         partonSystemsPtr-&gt;addOut( iSys, i);</span>
<span class="lineNum">    2316 </span>            : 
<span class="lineNum">    2317 </span>            :       // Do parton showers inside subsystem.
<span class="lineNum">    2318 </span><span class="lineNoCov">          0 :       if (doFSRinResonances) {</span>
<span class="lineNum">    2319 </span>            : 
<span class="lineNum">    2320 </span>            :         // Let prepare routine do the setup.
<span class="lineNum">    2321 </span><span class="lineNoCov">          0 :         timesDecPtr-&gt;prepare( iSys, event);</span>
<span class="lineNum">    2322 </span>            : 
<span class="lineNum">    2323 </span>            :         // Begin evolution down in pT from hard pT scale.
<span class="lineNum">    2324 </span><span class="lineNoCov">          0 :         do {</span>
<span class="lineNum">    2325 </span><span class="lineNoCov">          0 :           double pTtimes = timesDecPtr-&gt;pTnext( event, pTmax, 0.);</span>
<span class="lineNum">    2326 </span>            : 
<span class="lineNum">    2327 </span>            :           // Do a final-state emission (if allowed).
<span class="lineNum">    2328 </span><span class="lineNoCov">          0 :           if (pTtimes &gt; 0.) {</span>
<span class="lineNum">    2329 </span><span class="lineNoCov">          0 :             timesDecPtr-&gt;branch( event);</span>
<span class="lineNum">    2330 </span>            :             pTmax = pTtimes;
<span class="lineNum">    2331 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    2332 </span>            : 
<span class="lineNum">    2333 </span>            :           // If no pT scales above zero then nothing to be done.
<span class="lineNum">    2334 </span>            :           else pTmax = 0.;
<span class="lineNum">    2335 </span>            : 
<span class="lineNum">    2336 </span>            :           // Keep on evolving until nothing is left to be done.
<span class="lineNum">    2337 </span><span class="lineNoCov">          0 :         } while (pTmax &gt; 0.);</span>
<span class="lineNum">    2338 </span>            :       }
<span class="lineNum">    2339 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2340 </span>            : 
<span class="lineNum">    2341 </span>            :   // End loop over event to find W/Z gauge bosons.
<span class="lineNum">    2342 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2343 </span>            : 
<span class="lineNum">    2344 </span>            :   // Done.
<span class="lineNum">    2345 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    2346 </span>            : 
<span class="lineNum">    2347 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2348 </span>            : 
<span class="lineNum">    2349 </span>            : //==========================================================================
<span class="lineNum">    2350 </span>            : 
<span class="lineNum">    2351 </span>            : } // end namespace Pythia8
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
