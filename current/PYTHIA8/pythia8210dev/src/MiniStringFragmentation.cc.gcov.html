<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - PYTHIA8/pythia8210dev/src/MiniStringFragmentation.cc</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">PYTHIA8/pythia8210dev/src</a> - MiniStringFragmentation.cc<span style="font-size: 80%;"> (source / <a href="MiniStringFragmentation.cc.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">174</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">4</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // MiniStringFragmentation.cc is a part of the PYTHIA event generator.</a>
<span class="lineNum">       2 </span>            : // Copyright (C) 2015 Torbjorn Sjostrand.
<span class="lineNum">       3 </span>            : // PYTHIA is licenced under the GNU GPL version 2, see COPYING for details.
<span class="lineNum">       4 </span>            : // Please respect the MCnet Guidelines, see GUIDELINES for details.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : // Function definitions (not found in the header) for the .
<span class="lineNum">       7 </span>            : // MiniStringFragmentation class
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;Pythia8/MiniStringFragmentation.h&quot;
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : namespace Pythia8 {
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : //==========================================================================
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : // The MiniStringFragmentation class.
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : // Constants: could be changed here if desired, but normally should not.
<span class="lineNum">      20 </span>            : // These are of technical nature, as described for each.
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : // Since diffractive by definition is &gt; 1 particle, try hard.
<span class="lineNum">      23 </span>            : const int MiniStringFragmentation::NTRYDIFFRACTIVE = 200;
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : // After one-body fragmentation failed, try two-body once more.
<span class="lineNum">      26 </span>            : const int MiniStringFragmentation::NTRYLASTRESORT  = 100;
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : // Loop try to combine available endquarks to valid hadron.
<span class="lineNum">      29 </span>            : const int MiniStringFragmentation::NTRYFLAV        = 10;
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      32 </span>            : 
<a name="33"><span class="lineNum">      33 </span>            : // Initialize and save pointers.</a>
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : void MiniStringFragmentation::init(Info* infoPtrIn, Settings&amp; settings,
<span class="lineNum">      36 </span>            :    ParticleData* particleDataPtrIn, Rndm* rndmPtrIn,
<span class="lineNum">      37 </span>            :    StringFlav* flavSelPtrIn, StringPT* pTSelPtrIn, StringZ* zSelPtrIn) {
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            :   // Save pointers.
<span class="lineNum">      40 </span><span class="lineNoCov">          0 :   infoPtr         = infoPtrIn;</span>
<span class="lineNum">      41 </span><span class="lineNoCov">          0 :   particleDataPtr = particleDataPtrIn;</span>
<span class="lineNum">      42 </span><span class="lineNoCov">          0 :   rndmPtr         = rndmPtrIn;</span>
<span class="lineNum">      43 </span><span class="lineNoCov">          0 :   flavSelPtr      = flavSelPtrIn;</span>
<span class="lineNum">      44 </span><span class="lineNoCov">          0 :   pTSelPtr        = pTSelPtrIn;</span>
<span class="lineNum">      45 </span><span class="lineNoCov">          0 :   zSelPtr         = zSelPtrIn;</span>
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            :   // Initialize the MiniStringFragmentation class proper.
<span class="lineNum">      48 </span><span class="lineNoCov">          0 :   nTryMass        = settings.mode(&quot;MiniStringFragmentation:nTry&quot;);</span>
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            :   // Initialize the b parameter of the z spectrum, used when joining jets.
<span class="lineNum">      51 </span><span class="lineNoCov">          0 :   bLund           = zSelPtr-&gt;bAreaLund();</span>
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      56 </span>            : 
<a name="57"><span class="lineNum">      57 </span>            : // Do the fragmentation: driver routine.</a>
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            : bool MiniStringFragmentation::fragment(int iSub, ColConfig&amp; colConfig,
<span class="lineNum">      60 </span>            :   Event&amp; event, bool isDiff) {
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            :   // Junction topologies not yet considered - is very rare.
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :   iParton  = colConfig[iSub].iParton;</span>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :   if (iParton.front() &lt; 0) {</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :     infoPtr-&gt;errorMsg(&quot;Error in MiniStringFragmentation::fragment: &quot;</span>
<span class="lineNum">      66 </span>            :       &quot;very low-mass junction topologies not yet handled&quot;);
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">      68 </span>            :   }
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            :   // Read in info on system to be treated.
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :   flav1    = FlavContainer( event[ iParton.front() ].id() );</span>
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :   flav2    = FlavContainer( event[ iParton.back() ].id() );</span>
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :   pSum     = colConfig[iSub].pSum;</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :   mSum     = colConfig[iSub].mass;</span>
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :   m2Sum    = mSum*mSum;</span>
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :   isClosed = colConfig[iSub].isClosed;</span>
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span>            :   // Do not want diffractive systems to easily collapse to one particle.
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :   int nTryFirst = (isDiff) ? NTRYDIFFRACTIVE : nTryMass;</span>
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span>            :   // First try to produce two particles from the system.
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :   if (ministring2two( nTryFirst, event)) return true;</span>
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span>            :   // If this fails, then form one hadron and shuffle momentum.
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :   if (ministring2one( iSub, colConfig, event)) return true;</span>
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            :   // If also this fails, then try harder to produce two particles.
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :   if (ministring2two( NTRYLASTRESORT, event)) return true;</span>
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            :   // Else complete failure.
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :   infoPtr-&gt;errorMsg(&quot;Error in MiniStringFragmentation::fragment: &quot;</span>
<span class="lineNum">      92 </span>            :       &quot;no 1- or 2-body state found above mass threshold&quot;);
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      98 </span>            : 
<a name="99"><span class="lineNum">      99 </span>            :   // Attempt to produce two particles from the ministring.</a>
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            : bool MiniStringFragmentation::ministring2two( int nTry, Event&amp; event) {
<span class="lineNum">     102 </span>            : 
<span class="lineNum">     103 </span>            :   // Properties of the produced hadrons.
<span class="lineNum">     104 </span>            :   int    idHad1  = 0;
<span class="lineNum">     105 </span>            :   int    idHad2  = 0;
<span class="lineNum">     106 </span>            :   double mHad1   = 0.;
<span class="lineNum">     107 </span>            :   double mHad2   = 0.;
<span class="lineNum">     108 </span>            :   double mHadSum = 0.;
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span>            :   // Allow a few attempts to find a particle pair with low enough masses.
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :   for (int iTry = 0; iTry &lt; nTry; ++iTry) {</span>
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            :     // For closed gluon loop need to pick an initial flavour.
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :     if (isClosed) do {</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :       int idStart = flavSelPtr-&gt;pickLightQ();</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :       FlavContainer flavStart(idStart, 1);</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :       flavStart = flavSelPtr-&gt;pick( flavStart);</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :       flav1 = flavSelPtr-&gt;pick( flavStart);</span>
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :       flav2.anti(flav1);</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :     } while (flav1.id == 0 || flav1.nPop &gt; 0);</span>
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            :     // Create a new q qbar flavour to form two hadrons.
<span class="lineNum">     123 </span>            :     // Start from a diquark, if any.
<span class="lineNum">     124 </span>            :     do {
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :       FlavContainer flav3 =</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :         (flav1.isDiquark() || (!flav2.isDiquark() &amp;&amp; rndmPtr-&gt;flat() &lt; 0.5) )</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :         ? flavSelPtr-&gt;pick( flav1) : flavSelPtr-&gt;pick( flav2).anti();</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :       idHad1 = flavSelPtr-&gt;combine( flav1, flav3);</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :       idHad2 = flavSelPtr-&gt;combine( flav2, flav3.anti());</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :     } while (idHad1 == 0 || idHad2 == 0);</span>
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            :     // Check whether the mass sum fits inside the available phase space.
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :     mHad1 = particleDataPtr-&gt;mSel(idHad1);</span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :     mHad2 = particleDataPtr-&gt;mSel(idHad2);</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :     mHadSum = mHad1 + mHad2;</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :     if (mHadSum &lt; mSum) break;</span>
<span class="lineNum">     137 </span>            :   }
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :   if (mHadSum &gt;= mSum) return false;</span>
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            :   // Define an effective two-parton string, by splitting intermediate
<span class="lineNum">     141 </span>            :   // gluon momenta in proportion to their closeness to either endpoint.
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :   Vec4 pSum1 = event[ iParton.front() ].p();</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :   Vec4 pSum2 = event[ iParton.back() ].p();</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :   if (iParton.size() &gt; 2) {</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :     Vec4 pEnd1 = pSum1;</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :     Vec4 pEnd2 = pSum2;</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :     Vec4 pEndSum = pEnd1 + pEnd2;</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :     for (int i = 1; i &lt; int(iParton.size()) - 1 ; ++i) {</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :       Vec4 pNow = event[ iParton[i] ].p();</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :       double ratio = (pEnd2 * pNow) / (pEndSum * pNow);</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :       pSum1 += ratio * pNow;</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :       pSum2 += (1. - ratio) * pNow;</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span>            :   // If split did not provide an axis then pick random axis to break tie.
<span class="lineNum">     157 </span>            :   // (Needed for low-mass q-g-qbar with q-qbar perfectly parallel.)
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :   if (pSum1.mCalc() + pSum2.mCalc() &gt; 0.999999 * mSum) {</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :     double cthe = 2. * rndmPtr-&gt;flat() - 1.;</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :     double sthe = sqrtpos(1. - cthe * cthe);</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :     double phi  = 2. * M_PI * rndmPtr-&gt;flat();</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :     Vec4 delta  = 0.5 * min( pSum1.e(), pSum2.e())</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :         * Vec4( sthe * sin(phi), sthe * cos(phi), cthe, 0.);</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :     pSum1 += delta;</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :     pSum2 -= delta;</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :     infoPtr-&gt;errorMsg(&quot;Warning in MiniStringFragmentation::ministring2two: &quot;</span>
<span class="lineNum">     167 </span>            :       &quot;random axis needed to break tie&quot;);
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span>            :   // Set up a string region based on the two effective endpoints.
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :   StringRegion region;</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :   region.setUp( pSum1, pSum2);</span>
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span>            :   // Generate an isotropic decay in the ministring rest frame,
<span class="lineNum">     175 </span>            :   // suppressed at large pT by a fragmentation pT Gaussian.
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :   double pAbs2 = 0.25 * ( pow2(m2Sum - mHad1*mHad1 - mHad2*mHad2)</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :     - pow2(2. * mHad1 * mHad2) ) / m2Sum;</span>
<span class="lineNum">     178 </span>            :   double pT2 = 0.;
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :   do {</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :     double cosTheta = rndmPtr-&gt;flat();</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :     pT2 = (1. - pow2(cosTheta)) * pAbs2;</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :   } while (pTSelPtr-&gt;suppressPT2(pT2) &lt; rndmPtr-&gt;flat() );</span>
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            :   // Construct the forward-backward asymmetry of the two particles.
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :   double mT21 = mHad1*mHad1 + pT2;</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :   double mT22 = mHad2*mHad2 + pT2;</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :   double lambda = sqrtpos( pow2(m2Sum  - mT21 - mT22) - 4. * mT21 * mT22 );</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :   double probReverse = 1. / (1. + exp( min( 50., bLund * lambda) ) );</span>
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            :   // Construct kinematics, as viewed in the transverse rest frame.
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :   double xpz1 = 0.5 * lambda/ m2Sum;</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :   if (probReverse &gt; rndmPtr-&gt;flat()) xpz1 = -xpz1;</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :   double xmDiff = (mT21 - mT22) / m2Sum;</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :   double xe1 = 0.5 * (1. + xmDiff);</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :   double xe2 = 0.5 * (1. - xmDiff );</span>
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span>            :   // Distribute pT isotropically in angle.
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :   double phi = 2. * M_PI * rndmPtr-&gt;flat();</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :   double pT  = sqrt(pT2);</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :   double px  = pT * cos(phi);</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :   double py  = pT * sin(phi);</span>
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span>            :   // Translate this into kinematics in the string frame.
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :   Vec4 pHad1 = region.pHad( xe1 + xpz1, xe1 - xpz1,  px,  py);</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :   Vec4 pHad2 = region.pHad( xe2 - xpz1, xe2 + xpz1, -px, -py);</span>
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span>            :   // Mark hadrons from junction fragmentation with different status.
<span class="lineNum">     208 </span>            :   int statusHadPos = 82, statusHadNeg = 82;
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :   if (abs(idHad1) &gt; 1000 &amp;&amp; abs(idHad1) &lt; 10000 &amp;&amp;</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :       abs(idHad2) &gt; 1000 &amp;&amp; abs(idHad2) &lt; 10000) {</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :     if (event[ iParton.front() ].statusAbs() == 74) statusHadPos = 89;</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :     if (event[ iParton.back() ].statusAbs() == 74)  statusHadNeg = 89;</span>
<span class="lineNum">     213 </span>            :   }
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :   else if (abs(idHad1) &gt; 1000 &amp;&amp; abs(idHad1) &lt; 10000) {</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :     if (event[ iParton.front() ].statusAbs() == 74 ||</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :         event[ iParton.back() ].statusAbs() == 74) statusHadPos = 89;</span>
<span class="lineNum">     217 </span>            :   }
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :   else if (abs(idHad2) &gt; 1000 &amp;&amp; abs(idHad2) &lt; 10000) {</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :     if (event[ iParton.front() ].statusAbs() == 74 ||</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :         event[ iParton.back() ].statusAbs() == 74) statusHadNeg = 89;</span>
<span class="lineNum">     221 </span>            :   }
<span class="lineNum">     222 </span>            :   // Add produced particles to the event record.
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :   int iFirst = event.append( idHad1, statusHadPos, iParton.front(),</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :     iParton.back(), 0, 0, 0, 0, pHad1, mHad1);</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :   int iLast = event.append( idHad2, statusHadNeg, iParton.front(),</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :     iParton.back(), 0, 0, 0, 0, pHad2, mHad2);</span>
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span>            :   // Set decay vertex when this is displaced.
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :   if (event[iParton.front()].hasVertex()) {</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     Vec4 vDec = event[iParton.front()].vDec();</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :     event[iFirst].vProd( vDec );</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :     event[iLast].vProd( vDec );</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            :   // Set lifetime of hadrons.
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :   event[iFirst].tau( event[iFirst].tau0() * rndmPtr-&gt;exp() );</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :   event[iLast].tau( event[iLast].tau0() * rndmPtr-&gt;exp() );</span>
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span>            :   // Mark original partons as hadronized and set their daughter range.
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; int(iParton.size()); ++i) {</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :     event[ iParton[i] ].statusNeg();</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :     event[ iParton[i] ].daughters(iFirst, iLast);</span>
<span class="lineNum">     243 </span>            :   }
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            :   // Successfully done.
<span class="lineNum">     246 </span>            :   return true;
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            : // Attempt to produce one particle from a ministring.
<span class="lineNum">     253 </span>            : // Current algorithm: find the system with largest invariant mass
<span class="lineNum">     254 </span>            : // relative to the existing one, and boost that system appropriately.
<span class="lineNum">     255 </span>            : // Try more sophisticated alternatives later?? (Z0 mass shifted??)
<a name="256"><span class="lineNum">     256 </span>            : // Also, if problems, attempt several times to obtain closer mass match??</a>
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            : bool MiniStringFragmentation::ministring2one( int iSub,
<span class="lineNum">     259 </span>            :   ColConfig&amp; colConfig, Event&amp; event) {
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span>            :   // Cannot handle qq + qbarqbar system.
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :   if (abs(flav1.id) &gt; 100 &amp;&amp; abs(flav2.id) &gt; 100) return false;</span>
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span>            :   // For closed gluon loop need to pick an initial flavour.
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :   if (isClosed) do {</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :     int idStart = flavSelPtr-&gt;pickLightQ();</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :     FlavContainer flavStart(idStart, 1);</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :     flav1 = flavSelPtr-&gt;pick( flavStart);</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :     flav2 = flav1.anti();</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :   } while (abs(flav1.id) &gt; 100);</span>
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span>            :   // Select hadron flavour from available quark flavours.
<span class="lineNum">     273 </span>            :   int idHad = 0;
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :   for (int iTryFlav = 0; iTryFlav &lt; NTRYFLAV; ++iTryFlav) {</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :     idHad = flavSelPtr-&gt;combine( flav1, flav2);</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :     if (idHad != 0) break;</span>
<span class="lineNum">     277 </span>            :   }
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :   if (idHad == 0) return false;</span>
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span>            :   // Find mass.
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :   double mHad = particleDataPtr-&gt;mSel(idHad);</span>
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            :   // Find the untreated parton system which combines to the largest
<span class="lineNum">     284 </span>            :   // squared mass above mimimum required.
<span class="lineNum">     285 </span>            :   int iMax = -1;
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :   double deltaM2 = mHad*mHad - mSum*mSum;</span>
<span class="lineNum">     287 </span>            :   double delta2Max = 0.;
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :   for (int iRec = iSub + 1; iRec &lt; colConfig.size(); ++iRec) {</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :     double delta2Rec = 2. * (pSum * colConfig[iRec].pSum) - deltaM2</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :       - 2. * mHad * colConfig[iRec].mass;</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :     if (delta2Rec &gt; delta2Max) { iMax = iRec; delta2Max = delta2Rec;}</span>
<span class="lineNum">     292 </span>            :   }
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :   if (iMax == -1) return false;</span>
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span>            :   // Construct kinematics of the hadron and recoiling system.
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :   Vec4&amp; pRec     = colConfig[iMax].pSum;</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :   double mRec    = colConfig[iMax].mass;</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :   double vecProd = pSum * pRec;</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :   double coefOld = mSum*mSum + vecProd;</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :   double coefNew = mHad*mHad + vecProd;</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :   double coefRec = mRec*mRec + vecProd;</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :   double coefSum = coefOld + coefNew;</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :   double sHat    = coefOld + coefRec;</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :   double root    = sqrtpos( (pow2(coefSum) - 4. * sHat * mHad*mHad)</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :     / (pow2(vecProd) - pow2(mSum * mRec)) );</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :   double k2      = 0.5 * (coefOld * root - coefSum) / sHat;</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :   double k1      = (coefRec * k2 + 0.5 * deltaM2) / coefOld;</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :   Vec4 pHad      = (1. + k1) * pSum - k2 * pRec;</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :   Vec4 pRecNew   = (1. + k2) * pRec - k1 * pSum;</span>
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            :   // Mark hadrons from junction split off with status 89.
<span class="lineNum">     312 </span>            :   int statusHad = 81;
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :   if (abs(idHad) &gt; 1000 &amp;&amp; abs(idHad) &lt; 10000 &amp;&amp;</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :       (event[ iParton.front() ].statusAbs() == 74 ||</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :        event[ iParton.back() ].statusAbs() == 74)) statusHad = 89;</span>
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span>            :   // Add the produced particle to the event record.
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :   int iHad = event.append( idHad, statusHad, iParton.front(), iParton.back(),</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :     0, 0, 0, 0, pHad, mHad);</span>
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span>            :   // Set decay vertex when this is displaced.
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :   if (event[iParton.front()].hasVertex()) {</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :     Vec4 vDec = event[iParton.front()].vDec();</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :     event[iHad].vProd( vDec );</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            :   // Set lifetime of hadron.
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :   event[iHad].tau( event[iHad].tau0() * rndmPtr-&gt;exp() );</span>
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            :   // Mark original partons as hadronized and set their daughter range.
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; int(iParton.size()); ++i) {</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :     event[ iParton[i] ].statusNeg();</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :     event[ iParton[i] ].daughters(iHad, iHad);</span>
<span class="lineNum">     334 </span>            :   }
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            :   // Copy down recoiling system, with boosted momentum. Update current partons.
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :   RotBstMatrix M;</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :   M.bst(pRec, pRecNew);</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; colConfig[iMax].size(); ++i) {</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :     int iOld = colConfig[iMax].iParton[i];</span>
<span class="lineNum">     341 </span>            :     // Do not touch negative iOld = beginning of new junction leg.
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :     if (iOld &gt;= 0) {</span>
<span class="lineNum">     343 </span>            :       int iNew;
<span class="lineNum">     344 </span>            :       // Keep track of 74 throughout the event.
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :       if (event[iOld].status() == 74) iNew = event.copy(iOld, 74);</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :       else iNew = event.copy(iOld, 72);</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :       event[iNew].rotbst(M);</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :       colConfig[iMax].iParton[i] = iNew;</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     350 </span>            :   }
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :   colConfig[iMax].pSum = pRecNew;</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :   colConfig[iMax].isCollected = true;</span>
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            :   // Successfully done.
<span class="lineNum">     355 </span>            :   return true;
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span>            : //==========================================================================
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            : } // end namespace Pythia8
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
