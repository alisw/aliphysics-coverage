<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - PYTHIA8/pythia8210dev/src/SigmaOnia.cc</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">PYTHIA8/pythia8210dev/src</a> - SigmaOnia.cc<span style="font-size: 80%;"> (source / <a href="SigmaOnia.cc.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">616</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">27</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // SigmaOnia.cc is a part of the PYTHIA event generator.</a>
<span class="lineNum">       2 </span>            : // Copyright (C) 2015 Torbjorn Sjostrand.
<span class="lineNum">       3 </span>            : // PYTHIA is licenced under the GNU GPL version 2, see COPYING for details.
<span class="lineNum">       4 </span>            : // Please respect the MCnet Guidelines, see GUIDELINES for details.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : // Function definitions (not found in the header) for the
<span class="lineNum">       7 </span>            : // charmonia/bottomonia simulation classes.
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;Pythia8/SigmaOnia.h&quot;
<span class="lineNum">      10 </span>            : #include &lt;limits&gt;
<span class="lineNum">      11 </span>            : namespace Pythia8 {
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : //==========================================================================
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : // SigmaOniaSetup class.
<span class="lineNum">      16 </span>            : // A helper class used to setup the SigmaOnia processes.
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      19 </span>            : 
<a name="20"><span class="lineNum">      20 </span>            : // The constructor.</a>
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span><span class="lineNoCov">          0 : SigmaOniaSetup::SigmaOniaSetup(Info* infoPtrIn, Settings* settingsPtrIn,</span>
<span class="lineNum">      23 </span>            :   ParticleData* particleDataPtrIn, int flavourIn)
<span class="lineNum">      24 </span><span class="lineNoCov">          0 :   : valid3S1(true), valid3PJ(true), valid3DJ(true), flavour(flavourIn) {</span>
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            :   // Set the pointers and category/key strings and mass splitting.
<span class="lineNum">      27 </span><span class="lineNoCov">          0 :   infoPtr = infoPtrIn;</span>
<span class="lineNum">      28 </span><span class="lineNoCov">          0 :   settingsPtr = settingsPtrIn;</span>
<span class="lineNum">      29 </span><span class="lineNoCov">          0 :   particleDataPtr = particleDataPtrIn;</span>
<span class="lineNum">      30 </span><span class="lineNoCov">          0 :   cat   = (flavour == 4) ? &quot;Charmonium&quot; : &quot;Bottomonium&quot;;</span>
<span class="lineNum">      31 </span><span class="lineNoCov">          0 :   key   = (flavour == 4) ? &quot;ccbar&quot; : &quot;bbbar&quot;;</span>
<span class="lineNum">      32 </span><span class="lineNoCov">          0 :   mSplit = settingsPtr-&gt;parm(&quot;Onia:massSplit&quot;);</span>
<span class="lineNum">      33 </span><span class="lineNoCov">          0 :   if (!settingsPtr-&gt;flag(&quot;Onia:forceMassSplit&quot;)) mSplit = -mSplit;</span>
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            :   // Set the general switch settings.
<span class="lineNum">      36 </span><span class="lineNoCov">          0 :   onia        = settingsPtr-&gt;flag(&quot;Onia:all&quot;);</span>
<span class="lineNum">      37 </span><span class="lineNoCov">          0 :   onia3S1     = settingsPtr-&gt;flag(&quot;Onia:all(3S1)&quot;);</span>
<span class="lineNum">      38 </span><span class="lineNoCov">          0 :   onia3PJ     = settingsPtr-&gt;flag(&quot;Onia:all(3PJ)&quot;);</span>
<span class="lineNum">      39 </span><span class="lineNoCov">          0 :   onia3DJ     = settingsPtr-&gt;flag(&quot;Onia:all(3DJ)&quot;);</span>
<span class="lineNum">      40 </span><span class="lineNoCov">          0 :   oniaFlavour = settingsPtr-&gt;flag(cat + &quot;:all&quot;);</span>
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            :   // Set the names of the matrix element settings.
<span class="lineNum">      43 </span><span class="lineNoCov">          0 :   meNames3S1.push_back(cat + &quot;:O(3S1)[3S1(1)]&quot;);</span>
<span class="lineNum">      44 </span><span class="lineNoCov">          0 :   meNames3S1.push_back(cat + &quot;:O(3S1)[3S1(8)]&quot;);</span>
<span class="lineNum">      45 </span><span class="lineNoCov">          0 :   meNames3S1.push_back(cat + &quot;:O(3S1)[1S0(8)]&quot;);</span>
<span class="lineNum">      46 </span><span class="lineNoCov">          0 :   meNames3S1.push_back(cat + &quot;:O(3S1)[3P0(8)]&quot;);</span>
<span class="lineNum">      47 </span><span class="lineNoCov">          0 :   meNames3PJ.push_back(cat + &quot;:O(3PJ)[3P0(1)]&quot;);</span>
<span class="lineNum">      48 </span><span class="lineNoCov">          0 :   meNames3PJ.push_back(cat + &quot;:O(3PJ)[3S1(8)]&quot;);</span>
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :   meNames3DJ.push_back(cat + &quot;:O(3DJ)[3D1(1)]&quot;);</span>
<span class="lineNum">      50 </span><span class="lineNoCov">          0 :   meNames3DJ.push_back(cat + &quot;:O(3DJ)[3P0(8)]&quot;);</span>
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            :   // Set the names of the production settings.
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :   ggNames3S1.push_back(cat + &quot;:gg2&quot; + key + &quot;(3S1)[3S1(1)]g&quot;);</span>
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :   ggNames3S1.push_back(cat + &quot;:gg2&quot; + key + &quot;(3S1)[3S1(8)]g&quot;);</span>
<span class="lineNum">      55 </span><span class="lineNoCov">          0 :   ggNames3S1.push_back(cat + &quot;:gg2&quot; + key + &quot;(3S1)[1S0(8)]g&quot;);</span>
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :   ggNames3S1.push_back(cat + &quot;:gg2&quot; + key + &quot;(3S1)[3PJ(8)]g&quot;);</span>
<span class="lineNum">      57 </span><span class="lineNoCov">          0 :   qgNames3S1.push_back(cat + &quot;:qg2&quot; + key + &quot;(3S1)[3S1(8)]q&quot;);</span>
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :   qgNames3S1.push_back(cat + &quot;:qg2&quot; + key + &quot;(3S1)[1S0(8)]q&quot;);</span>
<span class="lineNum">      59 </span><span class="lineNoCov">          0 :   qgNames3S1.push_back(cat + &quot;:qg2&quot; + key + &quot;(3S1)[3PJ(8)]q&quot;);</span>
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :   qqNames3S1.push_back(cat + &quot;:qqbar2&quot; + key + &quot;(3S1)[3S1(8)]g&quot;);</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :   qqNames3S1.push_back(cat + &quot;:qqbar2&quot; + key + &quot;(3S1)[1S0(8)]g&quot;);</span>
<span class="lineNum">      62 </span><span class="lineNoCov">          0 :   qqNames3S1.push_back(cat + &quot;:qqbar2&quot; + key + &quot;(3S1)[3PJ(8)]g&quot;);</span>
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :   ggNames3PJ.push_back(cat + &quot;:gg2&quot; + key + &quot;(3PJ)[3PJ(1)]g&quot;);</span>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :   ggNames3PJ.push_back(cat + &quot;:gg2&quot; + key + &quot;(3PJ)[3S1(8)]g&quot;);</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :   qgNames3PJ.push_back(cat + &quot;:qg2&quot; + key + &quot;(3PJ)[3PJ(1)]q&quot;);</span>
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :   qgNames3PJ.push_back(cat + &quot;:qg2&quot; + key + &quot;(3PJ)[3S1(8)]q&quot;);</span>
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :   qqNames3PJ.push_back(cat + &quot;:qqbar2&quot; + key + &quot;(3PJ)[3PJ(1)]g&quot;);</span>
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :   qqNames3PJ.push_back(cat + &quot;:qqbar2&quot; + key + &quot;(3PJ)[3S1(8)]g&quot;);</span>
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :   ggNames3DJ.push_back(cat + &quot;:gg2&quot; + key + &quot;(3DJ)[3DJ(1)]g&quot;);</span>
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :   ggNames3DJ.push_back(cat + &quot;:gg2&quot; + key + &quot;(3DJ)[3PJ(8)]g&quot;);</span>
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :   qgNames3DJ.push_back(cat + &quot;:qg2&quot; + key + &quot;(3DJ)[3PJ(8)]q&quot;);</span>
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :   qqNames3DJ.push_back(cat + &quot;:qqbar2&quot; + key + &quot;(3DJ)[3PJ(8)]g&quot;);</span>
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            :   // Initialise and check all settings.
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :   states3S1 = settingsPtr-&gt;mvec(cat + &quot;:states(3S1)&quot;);</span>
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :   initStates(&quot;3S1&quot;, states3S1, spins3S1, valid3S1);</span>
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :   initSettings(&quot;3S1&quot;, states3S1.size(), meNames3S1, mes3S1, valid3S1);</span>
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :   initSettings(&quot;3S1&quot;, states3S1.size(), ggNames3S1, ggs3S1, valid3S1);</span>
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :   initSettings(&quot;3S1&quot;, states3S1.size(), qgNames3S1, qgs3S1, valid3S1);</span>
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :   initSettings(&quot;3S1&quot;, states3S1.size(), qqNames3S1, qqs3S1, valid3S1);</span>
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :   states3PJ = settingsPtr-&gt;mvec(cat + &quot;:states(3PJ)&quot;);</span>
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :   initStates(&quot;3PJ&quot;, states3PJ, spins3PJ, valid3PJ);</span>
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :   initSettings(&quot;3PJ&quot;, states3PJ.size(), meNames3PJ, mes3PJ, valid3PJ);</span>
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :   initSettings(&quot;3PJ&quot;, states3PJ.size(), ggNames3PJ, ggs3PJ, valid3PJ);</span>
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :   initSettings(&quot;3PJ&quot;, states3PJ.size(), qgNames3PJ, qgs3PJ, valid3PJ);</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :   initSettings(&quot;3PJ&quot;, states3PJ.size(), qqNames3PJ, qqs3PJ, valid3PJ);</span>
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :   states3DJ = settingsPtr-&gt;mvec(cat + &quot;:states(3DJ)&quot;);</span>
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :   initStates(&quot;3DJ&quot;, states3DJ, spins3DJ, valid3DJ);</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :   initSettings(&quot;3DJ&quot;, states3DJ.size(), meNames3DJ, mes3DJ, valid3DJ);</span>
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :   initSettings(&quot;3DJ&quot;, states3DJ.size(), ggNames3DJ, ggs3DJ, valid3DJ);</span>
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :   initSettings(&quot;3DJ&quot;, states3DJ.size(), qgNames3DJ, qgs3DJ, valid3DJ);</span>
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :   initSettings(&quot;3DJ&quot;, states3DJ.size(), qqNames3DJ, qqs3DJ, valid3DJ);</span>
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      97 </span>            : 
<a name="98"><span class="lineNum">      98 </span>            : // Initialise the SigmaProcesses for g g -&gt; X g production.</a>
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            : void SigmaOniaSetup::setupSigma2gg(vector&lt;SigmaProcess*&gt; &amp;procs, bool oniaIn) {
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            :   // Initialise the 3S1 processes.
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :   if (valid3S1) {</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :     for (unsigned int i = 0; i &lt; states3S1.size(); ++i) {</span>
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :       bool flag = oniaIn || onia || onia3S1 || oniaFlavour;</span>
<span class="lineNum">     106 </span>            :       // Colour-singlet.
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :       if (flag || ggs3S1[0][i])</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :         procs.push_back(new Sigma2gg2QQbar3S11g</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :           (states3S1[i], mes3S1[0][i], flavour*100 + 1));</span>
<span class="lineNum">     110 </span>            :       // Colour-octet.
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :       if (flag || ggs3S1[1][i])</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :         procs.push_back(new Sigma2gg2QQbarX8g</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :           (states3S1[i], mes3S1[1][i], 0, mSplit, flavour*100+2));</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :       if (flag || ggs3S1[2][i])</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :         procs.push_back(new Sigma2gg2QQbarX8g</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :           (states3S1[i], mes3S1[2][i], 1, mSplit, flavour*100+5));</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :       if (flag || ggs3S1[3][i])</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :         procs.push_back(new Sigma2gg2QQbarX8g</span>
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :           (states3S1[i], mes3S1[3][i], 2, mSplit, flavour*100+8));</span>
<span class="lineNum">     120 </span>            :     }
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            :   // Initialise the 3PJ processes.
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :   if (valid3PJ) {</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :     for (unsigned int i = 0; i &lt; states3PJ.size(); ++i) {</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :       bool flag = oniaIn || onia || onia3PJ || oniaFlavour;</span>
<span class="lineNum">     127 </span>            :       // Colour-singlet.
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :       if (flag || ggs3PJ[0][i]) {</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :         procs.push_back(new Sigma2gg2QQbar3PJ1g</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :           (states3PJ[i], mes3PJ[0][i], spins3PJ[i], flavour*100 + 11));</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     132 </span>            :       // Colour-octet.
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :       if (flag || ggs3PJ[1][i])</span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :         procs.push_back(new Sigma2gg2QQbarX8g</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :           (states3PJ[i], mes3PJ[1][i], 0, mSplit, flavour*100+14));</span>
<span class="lineNum">     136 </span>            :     }
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span>            :   // Initialise the 3DJ processes.
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :   if (valid3DJ) {</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :     for (unsigned int i = 0; i &lt; states3DJ.size(); ++i) {</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :       bool flag = oniaIn || onia || onia3DJ || oniaFlavour;</span>
<span class="lineNum">     143 </span>            :       // Colour-singlet.
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :       if (flag || ggs3DJ[0][i]) {</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :         procs.push_back(new Sigma2gg2QQbar3DJ1g</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :           (states3DJ[i], mes3DJ[0][i], spins3DJ[i], flavour*100 + 17));</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     148 </span>            :       // Colour-octet.
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :       if (flag || ggs3DJ[1][i]) {</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :         procs.push_back(new Sigma2gg2QQbarX8g</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :           (states3DJ[i], mes3DJ[1][i], 2, mSplit, flavour*100+18));</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     153 </span>            :     }
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     159 </span>            : 
<a name="160"><span class="lineNum">     160 </span>            : // Initialise the SigmaProcesses for q g -&gt; X q production.</a>
<span class="lineNum">     161 </span>            : 
<span class="lineNum">     162 </span>            : void SigmaOniaSetup::setupSigma2qg(vector&lt;SigmaProcess*&gt; &amp;procs, bool oniaIn) {
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            :   // Initialise the 3S1 processes.
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :   if (valid3S1) {</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :     for (unsigned int i = 0; i &lt; states3S1.size(); ++i) {</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :       bool flag = oniaIn || onia || onia3S1 || oniaFlavour;</span>
<span class="lineNum">     168 </span>            :       // Colour-octet.
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :       if (flag || qgs3S1[0][i])</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :         procs.push_back(new Sigma2qg2QQbarX8q</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :           (states3S1[i], mes3S1[1][i], 0, mSplit, flavour*100+3));</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :       if (flag || qgs3S1[1][i])</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :         procs.push_back(new Sigma2qg2QQbarX8q</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :           (states3S1[i], mes3S1[2][i], 1, mSplit, flavour*100+6));</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :       if (flag || qgs3S1[2][i])</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :         procs.push_back(new Sigma2qg2QQbarX8q</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :           (states3S1[i], mes3S1[3][i], 2, mSplit, flavour*100+9));</span>
<span class="lineNum">     178 </span>            :     }
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span>            :   // Initialise the 3PJ processes.
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :   if (valid3PJ) {</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :     for (unsigned int i = 0; i &lt; states3PJ.size(); ++i) {</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :       bool flag = oniaIn || onia || onia3PJ || oniaFlavour;</span>
<span class="lineNum">     185 </span>            :       // Colour-singlet.
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :       if (flag || qgs3PJ[0][i])</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :         procs.push_back(new Sigma2qg2QQbar3PJ1q</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :           (states3PJ[i], mes3PJ[0][i], spins3PJ[i], flavour*100 + 12));</span>
<span class="lineNum">     189 </span>            :       // Colour-octet.
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :       if (flag || qgs3PJ[1][i])</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :         procs.push_back(new Sigma2qg2QQbarX8q</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :           (states3PJ[i], mes3PJ[1][i], 0, mSplit, flavour*100+15));</span>
<span class="lineNum">     193 </span>            :     }
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span>            :   // Initialise the 3DJ processes.
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :   if (valid3DJ) {</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :     for (unsigned int i = 0; i &lt; states3DJ.size(); ++i) {</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :       bool flag = oniaIn || onia || onia3DJ || oniaFlavour;</span>
<span class="lineNum">     200 </span>            :       // Colour-octet.
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :       if (flag || qgs3DJ[0][i])</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :         procs.push_back(new Sigma2qg2QQbarX8q</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :           (states3DJ[i], mes3DJ[1][i], 2, mSplit, flavour*100+19));</span>
<span class="lineNum">     204 </span>            :     }
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     210 </span>            : 
<a name="211"><span class="lineNum">     211 </span>            : // Initialise the SigmaProcesses for q qbar -&gt; X g production.</a>
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span>            : void SigmaOniaSetup::setupSigma2qq(vector&lt;SigmaProcess*&gt; &amp;procs, bool oniaIn) {
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span>            :   // Initialise the 3S1 processes.
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :   if (valid3S1) {</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :     for (unsigned int i = 0; i &lt; states3S1.size(); ++i) {</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :       bool flag = oniaIn || onia || onia3S1 || oniaFlavour;</span>
<span class="lineNum">     219 </span>            :       // Colour-octet.
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :       if (flag || qqs3S1[0][i])</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :         procs.push_back(new Sigma2qqbar2QQbarX8g</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :           (states3S1[i], mes3S1[1][i], 0, mSplit, flavour*100+4));</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :       if (flag || qqs3S1[1][i])</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :         procs.push_back(new Sigma2qqbar2QQbarX8g</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :           (states3S1[i], mes3S1[2][i], 1, mSplit, flavour*100+7));</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :       if (flag || qqs3S1[2][i])</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :         procs.push_back(new Sigma2qqbar2QQbarX8g</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :           (states3S1[i], mes3S1[3][i], 2, mSplit, flavour*100+10));</span>
<span class="lineNum">     229 </span>            :     }
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            :   // Initialise the 3PJ processes.
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :   if (valid3PJ) {</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :     for (unsigned int i = 0; i &lt; states3PJ.size(); ++i) {</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :       bool flag = oniaIn || onia || onia3PJ || oniaFlavour;</span>
<span class="lineNum">     236 </span>            :       // Colour-singlet.
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :       if (flag || qqs3PJ[0][i])</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :         procs.push_back(new Sigma2qqbar2QQbar3PJ1g</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :           (states3PJ[i], mes3PJ[0][i], spins3PJ[i], flavour*100 + 13));</span>
<span class="lineNum">     240 </span>            :       // Colour-octet.
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :       if (flag || qqs3PJ[1][i])</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :         procs.push_back(new Sigma2qqbar2QQbarX8g</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :           (states3PJ[i], mes3PJ[1][i], 0, mSplit, flavour*100+16));</span>
<span class="lineNum">     244 </span>            :     }
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span>            :   // Initialise the 3DJ processes.
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :   if (valid3DJ) {</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :     for (unsigned int i = 0; i &lt; states3DJ.size(); ++i) {</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :       bool flag = oniaIn || onia || onia3DJ || oniaFlavour;</span>
<span class="lineNum">     251 </span>            :       // Colour-octet.
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :       if (flag || qqs3DJ[0][i])</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :         procs.push_back(new Sigma2qqbar2QQbarX8g</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :           (states3DJ[i], mes3DJ[1][i], 2, mSplit, flavour*100+20));</span>
<span class="lineNum">     255 </span>            :     }
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     261 </span>            : 
<a name="262"><span class="lineNum">     262 </span>            : // Initialise and check the flavour, j-number, and validity of states.</a>
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span>            : void SigmaOniaSetup::initStates(string wave, const vector&lt;int&gt; &amp;states,
<span class="lineNum">     265 </span>            :   vector&lt;int&gt; &amp;jnums, bool &amp;valid) {
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :   set&lt;int&gt; unique;</span>
<span class="lineNum">     268 </span>            :   unsigned int nstates(0);
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :   for (unsigned int i = 0; i &lt; states.size(); ++i) {</span>
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            :     // Check state is unique and remove if not.
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :     stringstream state;</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :     state &lt;&lt; states[i];</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :     unique.insert(states[i]);</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :     if (nstates + 1 != unique.size()) {</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :       infoPtr-&gt;errorMsg(&quot;Error in SigmaOniaSetup::initStates: particle &quot;</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :                         + state.str() + &quot; in mvec &quot; + cat + &quot;:states(&quot;</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :                         + wave + &quot;)&quot;, &quot;has duplicates&quot;);</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :       valid = false;</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :     } else ++nstates;</span>
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span>            :     // Determine quark composition and quantum numbers.
<span class="lineNum">     283 </span>            :     int mod1(10), mod2(1);
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :     vector&lt;int&gt; digits;</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :     while (digits.size() &lt; 7) {</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :       digits.push_back((states[i]%mod1 - states[i]%mod2) / mod2);</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :       mod1 *= 10;</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :       mod2 *= 10;</span>
<span class="lineNum">     289 </span>            :     }
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :     int s, l, j((digits[0] - 1)/2);</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :     if (j != 0) {</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :       if      (digits[4] == 0) {l = j - 1; s = 1;}</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :       else if (digits[4] == 1) {l = j;     s = 0;}</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :       else if (digits[4] == 2) {l = j;     s = 1;}</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :       else                     {l = j + 1; s = 1;}</span>
<span class="lineNum">     296 </span>            :     } else {
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :       if      (digits[4] == 0) {l = 0;  s = 0;}</span>
<span class="lineNum">     298 </span>            :       else                     {l = 1;  s = 1;}
<span class="lineNum">     299 </span>            :     }
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            :     // Check state validity.
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :     if (states[i] != 0) {</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :       if (!particleDataPtr-&gt;isParticle(states[i])) {</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :         infoPtr-&gt;errorMsg(&quot;Error in SigmaOniaSetup::initStates: particle &quot;</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :                           + state.str() + &quot; in mvec &quot; + cat + &quot;:states(&quot;</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :                           + wave + &quot;)&quot;, &quot;is unknown&quot;);</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :         valid = false;</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :       if (digits[3] != 0) {</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :         infoPtr-&gt;errorMsg(&quot;Error in SigmaOniaSetup::initStates: particle &quot;</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :                           + state.str() + &quot; in mvec &quot; + cat + &quot;:states(&quot;</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :                           + wave + &quot;)&quot;, &quot; is not a meson&quot;);</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :         valid = false;</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :       if (digits[2] != digits[1] || digits[1] != flavour) {</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :         infoPtr-&gt;errorMsg(&quot;Error in SigmaOniaSetup::initStates: particle &quot;</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :                           + state.str() + &quot; in mvec &quot; + cat + &quot;:states(&quot;</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :                           + wave + &quot;)&quot;, &quot;is not a &quot; + key + &quot; state&quot;);</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :         valid = false;</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :       if ((wave == &quot;3S1&quot; &amp;&amp; (s != 1 || l != 0 || j != 1)) ||</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :           (wave == &quot;3PJ&quot; &amp;&amp; (s != 1 || l != 1 || j &lt; 0 || j &gt; 2)) ||</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :           (wave == &quot;3DJ&quot; &amp;&amp; (s != 1 || l != 2 || j &lt; 1 || j &gt; 3))) {</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :         infoPtr-&gt;errorMsg(&quot;Error in SigmaOniaSetup::initStates: particle &quot;</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :                           + state.str() + &quot; in mvec &quot; + cat + &quot;:states(&quot;</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :                           + wave + &quot;)&quot;, &quot;is not a &quot; + wave + &quot; state&quot;);</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :         valid = false;</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :     } else valid = false;</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :     jnums.push_back(j);</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     336 </span>            : 
<a name="337"><span class="lineNum">     337 </span>            : // Initialise and check a group of PVec settings.</a>
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            : void SigmaOniaSetup::initSettings(string wave, unsigned int size,
<span class="lineNum">     340 </span>            :   const vector&lt;string&gt; &amp;names, vector&lt; vector&lt;double&gt; &gt; &amp;pvecs,
<span class="lineNum">     341 </span>            :   bool &amp;valid) {
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :   for (unsigned int i = 0; i &lt; names.size(); ++i) {</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :     pvecs.push_back(settingsPtr-&gt;pvec(names[i]));</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :     if (pvecs.back().size() != size) {</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :       infoPtr-&gt;errorMsg(&quot;Error in SigmaOniaSetup::initSettings: mvec &quot; + cat</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :                         + &quot;:states(&quot; + wave + &quot;)&quot;, &quot;is not the same size as&quot;</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :                         &quot; pvec &quot; + names[i]);</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :       valid = false;</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     351 </span>            :   }
<span class="lineNum">     352 </span>            : 
<span class="lineNum">     353 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     356 </span>            : 
<a name="357"><span class="lineNum">     357 </span>            : // Initialise and check a group of FVec settings.</a>
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span>            : void SigmaOniaSetup::initSettings(string wave, unsigned int size,
<span class="lineNum">     360 </span>            :   const vector&lt;string&gt; &amp;names, vector&lt; vector&lt;bool&gt; &gt; &amp;fvecs,
<span class="lineNum">     361 </span>            :   bool &amp;valid) {
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :   for (unsigned int i = 0; i &lt; names.size(); ++i) {</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :     fvecs.push_back(settingsPtr-&gt;fvec(names[i]));</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :     if (fvecs.back().size() != size) {</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :       infoPtr-&gt;errorMsg(&quot;Error in SigmaOniaSetup::initSettings: mvec &quot; + cat</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :                         + &quot;:states(&quot; + wave + &quot;)&quot;, &quot;is not the same size as&quot;</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :                         &quot; fvec &quot; + names[i]);</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :       valid = false;</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     371 </span>            :   }
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span>            : //==========================================================================
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span>            : // Sigma2gg2QQbar3S11g class.
<span class="lineNum">     378 </span>            : // Cross section g g -&gt; QQbar[3S1(1)] g (Q = c or b).
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     381 </span>            : 
<a name="382"><span class="lineNum">     382 </span>            : // Initialize process.</a>
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span>            : void Sigma2gg2QQbar3S11g::initProc() {
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span>            :   // Process name.
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :   nameSave = &quot;g g -&gt; &quot;</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :     + string((codeSave - codeSave%100)/100 == 4 ? &quot;ccbar&quot; : &quot;bbbar&quot;)</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :     + &quot;(3S1)[3S1(1)] g&quot;;</span>
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     394 </span>            : 
<a name="395"><span class="lineNum">     395 </span>            : // Evaluate d(sigmaHat)/d(tHat); no explicit flavour dependence.</a>
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            : void Sigma2gg2QQbar3S11g::sigmaKin() {
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span>            :   // Calculate kinematics dependence.
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :   double stH = sH + tH;</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :   double tuH = tH + uH;</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :   double usH = uH + sH;</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :   double sig = (10. * M_PI / 81.) * m3 * ( pow2(sH * tuH)</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :     + pow2(tH * usH) + pow2(uH * stH) ) / pow2( stH * tuH * usH );</span>
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span>            :   // Answer.
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :   sigma = (M_PI/sH2) * pow3(alpS) * oniumME * sig;</span>
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     412 </span>            : 
<a name="413"><span class="lineNum">     413 </span>            : // Select identity, colour and anticolour.</a>
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            : void Sigma2gg2QQbar3S11g::setIdColAcol() {
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span>            :   // Flavours are trivial.
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :   setId( id1, id2, idHad, 21);</span>
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span>            :   // Two orientations of colour flow.
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :   setColAcol( 1, 2, 2, 3, 0, 0, 1, 3);</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :   if (rndmPtr-&gt;flat() &gt; 0.5) swapColAcol();</span>
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span>            : //==========================================================================
<span class="lineNum">     427 </span>            : 
<span class="lineNum">     428 </span>            : // Sigma2gg2QQbar3PJ1g class.
<span class="lineNum">     429 </span>            : // Cross section g g -&gt; QQbar[3PJ(1)] g (Q = c or b, J = 0, 1 or 2).
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     432 </span>            : 
<a name="433"><span class="lineNum">     433 </span>            : // Initialize process.</a>
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span>            : void Sigma2gg2QQbar3PJ1g::initProc() {
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span>            :   // Process name.
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :   if (jSave &gt;= 0 &amp;&amp; jSave &lt;= 2)</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :     nameSave = namePrefix() + &quot; -&gt; &quot; + nameMidfix() + &quot;(3PJ)[3PJ(1)] &quot;</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :       + namePostfix();</span>
<span class="lineNum">     441 </span>            :   else
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :     nameSave = &quot;illegal process&quot;;</span>
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     447 </span>            : 
<a name="448"><span class="lineNum">     448 </span>            : // Evaluate d(sigmaHat)/d(tHat); no explicit flavour dependence.</a>
<span class="lineNum">     449 </span>            : 
<span class="lineNum">     450 </span>            : void Sigma2gg2QQbar3PJ1g::sigmaKin() {
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span>            :   // Useful derived kinematics quantities.
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :   double pRat  = (sH * uH + uH * tH + tH * sH)/ sH2;</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :   double qRat  = tH * uH / sH2;</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :   double rRat  = s3 / sH;</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :   double pRat2 = pRat * pRat;</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :   double pRat3 = pRat2 * pRat;</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :   double pRat4 = pRat3 * pRat;</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :   double qRat2 = qRat * qRat;</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :   double qRat3 = qRat2 * qRat;</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :   double qRat4 = qRat3 * qRat;</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :   double rRat2 = rRat * rRat;</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :   double rRat3 = rRat2 * rRat;</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :   double rRat4 = rRat3 * rRat;</span>
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span>            :   // Calculate kinematics dependence.
<span class="lineNum">     467 </span>            :   double sig = 0.;
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :   if (jSave == 0) {</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :     sig = (8. * M_PI / (9. * m3 * sH))</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :       * ( 9. * rRat2 * pRat4 * (rRat4 - 2. * rRat2 * pRat + pRat2)</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :       - 6. * rRat * pRat3 * qRat * (2. * rRat4 - 5. * rRat2 * pRat</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :       + pRat2) - pRat2 * qRat2 * (rRat4 + 2. * rRat2 * pRat - pRat2)</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :       + 2. * rRat * pRat * qRat3 * (rRat2 - pRat) + 6. * rRat2 * qRat4)</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :       / (qRat * pow4(qRat - rRat * pRat));</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :   } else if (jSave == 1) {</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :     sig =  (8. * M_PI / (3.* m3 * sH)) * pRat2</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :       * (rRat * pRat2 * (rRat2 - 4. * pRat)</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :       + 2. * qRat * (-rRat4 + 5. * rRat2 * pRat + pRat2)</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :       - 15. * rRat * qRat2) / pow4(qRat - rRat * pRat);</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :   } else if (jSave == 2) {</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :     sig = (8. * M_PI / (9. * m3 * sH))</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :       * (12. * rRat2 * pRat4 * (rRat4 - 2. * rRat2 * pRat + pRat2)</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :       - 3. * rRat * pRat3 * qRat * (8. * rRat4 - rRat2 * pRat + 4. * pRat2)</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :       + 2. * pRat2 * qRat2 * (-7. * rRat4 + 43. * rRat2 * pRat + pRat2)</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :       + rRat * pRat * qRat3 * (16. * rRat2 - 61. * pRat)</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :       + 12. * rRat2 * qRat4) / (qRat * pow4(qRat-rRat * pRat));</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span>            :   // Answer.
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :   sigma = (M_PI/sH2) * pow3(alpS) * oniumME * sig;</span>
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     495 </span>            : 
<a name="496"><span class="lineNum">     496 </span>            : // Select identity, colour and anticolour.</a>
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span>            : void Sigma2gg2QQbar3PJ1g::setIdColAcol() {
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span>            :   // Flavours are trivial.
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :   setId( id1, id2, idHad, 21);</span>
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span>            :   // Two orientations of colour flow.
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :   setColAcol( 1, 2, 2, 3, 0, 0, 1, 3);</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :   if (rndmPtr-&gt;flat() &gt; 0.5) swapColAcol();</span>
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span>            : //==========================================================================
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span>            : // Sigma2qg2QQbar3PJ1q class.
<span class="lineNum">     512 </span>            : // Cross section q g -&gt; QQbar[3PJ(1)] q (Q = c or b, J = 0, 1 or 2).
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     515 </span>            : 
<a name="516"><span class="lineNum">     516 </span>            : // Evaluate d(sigmaHat)/d(tHat); no explicit flavour dependence.</a>
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span>            : void Sigma2qg2QQbar3PJ1q::sigmaKin() {
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span>            :   // Calculate kinematics dependence.
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :   double usH = uH + sH;</span>
<span class="lineNum">     522 </span>            :   double sig = 0.;
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :   if (jSave == 0) {</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :     sig = - (16. * M_PI / 81.) * pow2(tH - 3. * s3) * (sH2 + uH2)</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :       / (m3 * tH * pow4(usH));</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :   } else if (jSave == 1) {</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :     sig = - (32. * M_PI / 27.) * (4. * s3 * sH * uH + tH * (sH2 + uH2))</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :       / (m3 * pow4(usH));</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :   } else if (jSave == 2) {</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :     sig = - (32. *M_PI / 81.) * ( (6. * s3*s3 + tH2) * pow2(usH)</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :       - 2. * sH * uH * (tH2 + 6. * s3 * usH)) / (m3 * tH * pow4(usH));</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span>            :   // Answer.
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :   sigma = (M_PI/sH2) * pow3(alpS) * oniumME * sig;</span>
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     540 </span>            : 
<a name="541"><span class="lineNum">     541 </span>            : // Select identity, colour and anticolour.</a>
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span>            : void Sigma2qg2QQbar3PJ1q::setIdColAcol() {
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span>            :   // Flavours are trivial.
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :   int idq = (id2 == 21) ? id1 : id2;</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :   setId( id1, id2, idHad, idq);</span>
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span>            :   // tH defined between q_in and q_out: must swap tHat &lt;-&gt; uHat if q g in.
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :   swapTU = (id2 == 21);</span>
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span>            :   // Colour flow topologies. Swap when antiquarks.
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :   if (id2 == 21) setColAcol( 1, 0, 2, 1, 0, 0, 2, 0);</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :   else           setColAcol( 2, 1, 1, 0, 0, 0, 2, 0);</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :   if (idq &lt; 0) swapColAcol();</span>
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     558 </span>            : 
<span class="lineNum">     559 </span>            : //==========================================================================
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span>            : // Sigma2qqbar2QQbar3PJ1g class.
<span class="lineNum">     562 </span>            : // Cross section q qbar -&gt; QQbar[3PJ(1)] g (Q = c or b, J = 0, 1 or 2).
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     565 </span>            : 
<a name="566"><span class="lineNum">     566 </span>            : // Evaluate d(sigmaHat)/d(tHat); no explicit flavour dependence.</a>
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span>            : void Sigma2qqbar2QQbar3PJ1g::sigmaKin() {
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span>            :   // Calculate kinematics dependence.
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :   double tuH = tH + uH;</span>
<span class="lineNum">     572 </span>            :   double sig = 0.;
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :   if (jSave == 0) {</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :     sig =(128. * M_PI / 243.) * pow2(sH - 3. * s3) * (tH2 + uH2)</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :       / (m3 * sH * pow4(tuH));</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :   } else if (jSave == 1) {</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :     sig = (256. * M_PI / 81.) * (4. * s3 * tH * uH + sH * (tH2 + uH2))</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :       / (m3 * pow4(tuH));</span>
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :   } else if (jSave == 2) {</span>
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :     sig = (256. * M_PI / 243.) * ( (6. * s3*s3 + sH2) * pow2(tuH)</span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :       - 2. * tH * uH * (sH2 + 6. * s3 * tuH) )/ (m3 * sH * pow4(tuH));</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     583 </span>            : 
<span class="lineNum">     584 </span>            :   // Answer.
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :   sigma = (M_PI/sH2) * pow3(alpS) * oniumME * sig;</span>
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     588 </span>            : 
<span class="lineNum">     589 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     590 </span>            : 
<a name="591"><span class="lineNum">     591 </span>            : // Select identity, colour and anticolour.</a>
<span class="lineNum">     592 </span>            : 
<span class="lineNum">     593 </span>            : void Sigma2qqbar2QQbar3PJ1g::setIdColAcol() {
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span>            :   // Flavours are trivial.
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :   setId( id1, id2, idHad, 21);</span>
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span>            :   // Colour flow topologies. Swap when antiquarks.
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :   setColAcol( 1, 0, 0, 2, 0, 0, 1, 2);</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :   if (id1 &lt; 0) swapColAcol();</span>
<span class="lineNum">     601 </span>            : 
<span class="lineNum">     602 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span>            : //==========================================================================
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span>            : // Sigma2gg2QQbar3DJ1g class.
<span class="lineNum">     607 </span>            : // Cross section g g -&gt; QQbar[3DJ(1)] g (Q = c or b).
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     610 </span>            : 
<a name="611"><span class="lineNum">     611 </span>            : // Initialize process.</a>
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span>            : void Sigma2gg2QQbar3DJ1g::initProc() {
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span>            :   // Process name.
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :   if (jSave &gt;= 1 &amp;&amp; jSave &lt;= 3)</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :     nameSave = namePrefix() + &quot; -&gt; &quot; + nameMidfix() + &quot;(3DJ)[3DJ(1)] &quot;</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :       + namePostfix();</span>
<span class="lineNum">     619 </span>            :   else
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :     nameSave = &quot;illegal process&quot;;</span>
<span class="lineNum">     621 </span>            : 
<span class="lineNum">     622 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     625 </span>            : 
<a name="626"><span class="lineNum">     626 </span>            : // Evaluate d(sigmaHat)/d(tHat); no explicit flavour dependence.</a>
<span class="lineNum">     627 </span>            : 
<span class="lineNum">     628 </span>            : void Sigma2gg2QQbar3DJ1g::sigmaKin() {
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span>            :   // Calculate kinematics dependence.
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :   double m2V[12], sHV[12], mpsV[8], mmsV[6], mmtV[6], sptV[6];</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :   m2V[0]  = 1;</span>
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :   sHV[0]  = 1;</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :   mmtV[0] = 1;</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :   mpsV[0] = 1;</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :   mmsV[0] = 1;</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :   sptV[0] = 1;</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :   for (int i = 1; i &lt; 12; ++i) {</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :     m2V[i] = m2V[i - 1] * s3;</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :     sHV[i] = sHV[i - 1] * sH;</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :     if (i &lt; 8) {</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :       mpsV[i] = mpsV[i - 1] * (s3 + sH);</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :       if (i &lt; 6) {</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :         mmsV[i] = mmsV[i - 1] * (s3 - sH);</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :         mmtV[i] = mmtV[i - 1] * (s3 - tH);</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :         sptV[i] = sptV[i - 1] * (sH + tH);</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     648 </span>            :     }
<span class="lineNum">     649 </span>            :   }
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :   double fac = (pow3(alpS)*pow2(M_PI));</span>
<span class="lineNum">     651 </span>            :   double sig = 0;
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :   if (jSave == 1) {</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :     fac *= 16. / 81.;</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :     sig  = -25/(sqrt(m2V[1])*mmsV[5]) + (49*sqrt(m2V[3]))/(mmsV[5]*sHV[2])</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :       + (48*sqrt(m2V[3])*sHV[2]*(m2V[2] + sHV[2]))/(mmsV[3]*mmtV[5]*mpsV[3])</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :       - (67*sqrt(m2V[1]))/(mmsV[5]*sHV[1]) - (5*sHV[1])/(sqrt(m2V[3])*mmsV[5])</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :       + (4*sqrt(m2V[1])*(m2V[6] + 97*m2V[4]*sHV[2] - 48*m2V[3]*sHV[3]</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :       + 105*m2V[2]*sHV[4] + 33*sHV[6] -</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :       24*m2V[5]*sHV[1]))/(mmsV[4]*mmtV[4]*mpsV[4]) - (4*(m2V[9] +</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :       197*m2V[7]*sHV[2] - 50*m2V[6]*sHV[3] + 509*m2V[5]*sHV[4] -</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :       416*m2V[4]*sHV[5] + 237*m2V[3]*sHV[6] - 400*m2V[2]*sHV[7] -</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :       10*sHV[9] -</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :       164*m2V[8]*sHV[1]))/(sqrt(m2V[1])*mmsV[5]*mmtV[3]*mpsV[5]*sHV[1]) +</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :       (224*m2V[10] + 1825*m2V[8]*sHV[2] - 3980*m2V[7]*sHV[3] +</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :       3996*m2V[6]*sHV[4] - 4766*m2V[5]*sHV[5] + 10022*m2V[4]*sHV[6] -</span>
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :       5212*m2V[3]*sHV[7] + 6124*m2V[2]*sHV[8] - 869*m2V[1]*sHV[9] +</span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :       145*sHV[10] -</span>
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :       597*m2V[9]*sHV[1])/(sqrt(m2V[1])*mmsV[5]*mmtV[1]*mpsV[7]*sHV[2]) +</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :       (102*m2V[11] + 331*m2V[9]*sHV[2] - 2021*m2V[8]*sHV[3] +</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :       3616*m2V[7]*sHV[4] - 968*m2V[6]*sHV[5] + 3386*m2V[5]*sHV[6] -</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :       6150*m2V[4]*sHV[7] + 666*m2V[3]*sHV[8] - 1134*m2V[2]*sHV[9] -</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :       5*m2V[1]*sHV[10] - 5*sHV[11] -</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :       506*m2V[10]*sHV[1])/(sqrt(m2V[3])*mmsV[5]*mmtV[2]*mpsV[6]*sHV[2]) +</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :       (48*sqrt(m2V[3])*sHV[2]*(m2V[2] + sHV[2]))/(mmsV[3]*mpsV[3]*sptV[5])</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :       + (4*sqrt(m2V[1])*(m2V[6] + 97*m2V[4]*sHV[2] - 48*m2V[3]*sHV[3] +</span>
<span class="lineNum">     676 </span>            :       105*m2V[2]*sHV[4] + 33*sHV[6] -
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :       24*m2V[5]*sHV[1]))/(mmsV[4]*mpsV[4]*sptV[4]) - (4*(m2V[9] +</span>
<span class="lineNum">     678 </span>            :       197*m2V[7]*sHV[2] - 50*m2V[6]*sHV[3] + 509*m2V[5]*sHV[4] -
<span class="lineNum">     679 </span>            :       416*m2V[4]*sHV[5] + 237*m2V[3]*sHV[6] - 400*m2V[2]*sHV[7] -
<span class="lineNum">     680 </span>            :       10*sHV[9] -
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :       164*m2V[8]*sHV[1]))/(sqrt(m2V[1])*mmsV[5]*mpsV[5]*sHV[1]*sptV[3]) +</span>
<span class="lineNum">     682 </span>            :       (102*m2V[11] + 331*m2V[9]*sHV[2] - 2021*m2V[8]*sHV[3] +
<span class="lineNum">     683 </span>            :       3616*m2V[7]*sHV[4] - 968*m2V[6]*sHV[5] + 3386*m2V[5]*sHV[6] -
<span class="lineNum">     684 </span>            :       6150*m2V[4]*sHV[7] + 666*m2V[3]*sHV[8] - 1134*m2V[2]*sHV[9] -
<span class="lineNum">     685 </span>            :       5*m2V[1]*sHV[10] - 5*sHV[11] -
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :       506*m2V[10]*sHV[1])/(sqrt(m2V[3])*mmsV[5]*mpsV[6]*sHV[2]*sptV[2]) +</span>
<span class="lineNum">     687 </span>            :       (224*m2V[10] + 1825*m2V[8]*sHV[2] - 3980*m2V[7]*sHV[3] +
<span class="lineNum">     688 </span>            :       3996*m2V[6]*sHV[4] - 4766*m2V[5]*sHV[5] + 10022*m2V[4]*sHV[6] -
<span class="lineNum">     689 </span>            :       5212*m2V[3]*sHV[7] + 6124*m2V[2]*sHV[8] - 869*m2V[1]*sHV[9] +
<span class="lineNum">     690 </span>            :       145*sHV[10] -
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :       597*m2V[9]*sHV[1])/(sqrt(m2V[1])*mmsV[5]*mpsV[7]*sHV[2]*sptV[1]);</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :   } else if (jSave == 2) {</span>
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :     fac *= 32. / 27.;</span>
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :     sig  = 16/(sqrt(m2V[1])*mmsV[5]) +</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :       (2*sqrt(m2V[3]))/(mmsV[5]*sHV[2]) - (8*sqrt(m2V[3])*sHV[2]*(m2V[2] +</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :       sHV[2]))/(mmsV[3]*mmtV[5]*mpsV[3]) +</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :       (6*sqrt(m2V[1]))/(mmsV[5]*sHV[1]) -</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :       (16*sHV[1])/(sqrt(m2V[3])*mmsV[5]) - (2*sqrt(m2V[1])*(3*m2V[6] -</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :       25*m2V[4]*sHV[2] - 16*m2V[3]*sHV[3] - 33*m2V[2]*sHV[4] - 5*sHV[6] -</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :       8*m2V[5]*sHV[1]))/(mmsV[4]*mmtV[4]*mpsV[4]) + (2*(3*m2V[9] -</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :       41*m2V[7]*sHV[2] - 37*m2V[6]*sHV[3] - 149*m2V[5]*sHV[4] +</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :       55*m2V[4]*sHV[5] - 53*m2V[3]*sHV[6] + 167*m2V[2]*sHV[7] + 16*sHV[9]</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :       + 7*m2V[8]*sHV[1]))/(sqrt(m2V[1])*mmsV[5]*mmtV[3]*mpsV[5]*sHV[1]) +</span>
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :       (2*(m2V[10] + 34*m2V[8]*sHV[2] - 198*m2V[7]*sHV[3] -</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :       140*m2V[6]*sHV[4] - 746*m2V[5]*sHV[5] + 226*m2V[4]*sHV[6] -</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :       486*m2V[3]*sHV[7] + 679*m2V[2]*sHV[8] - 50*m2V[1]*sHV[9] +</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :       112*sHV[10] -</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :       8*m2V[9]*sHV[1]))/(sqrt(m2V[1])*mmsV[5]*mmtV[1]*mpsV[7]*sHV[2]) +</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :       (m2V[11] + 19*m2V[9]*sHV[2] - m2V[8]*sHV[3] + 597*m2V[7]*sHV[4] +</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :       321*m2V[6]*sHV[5] + 797*m2V[5]*sHV[6] - 791*m2V[4]*sHV[7] +</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :       26*m2V[3]*sHV[8] - 468*m2V[2]*sHV[9] - 16*m2V[1]*sHV[10] -</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :       16*sHV[11] -</span>
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :       21*m2V[10]*sHV[1])/(sqrt(m2V[3])*mmsV[5]*mmtV[2]*mpsV[6]*sHV[2]) -</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :       (8*sqrt(m2V[3])*sHV[2]*(m2V[2] + sHV[2]))/(mmsV[3]*mpsV[3]*sptV[5])</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :       - (2*sqrt(m2V[1])*(3*m2V[6] - 25*m2V[4]*sHV[2] - 16*m2V[3]*sHV[3] -</span>
<span class="lineNum">     716 </span>            :       33*m2V[2]*sHV[4] - 5*sHV[6] -
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :       8*m2V[5]*sHV[1]))/(mmsV[4]*mpsV[4]*sptV[4]) + (2*(3*m2V[9] -</span>
<span class="lineNum">     718 </span>            :       41*m2V[7]*sHV[2] - 37*m2V[6]*sHV[3] - 149*m2V[5]*sHV[4] +
<span class="lineNum">     719 </span>            :       55*m2V[4]*sHV[5] - 53*m2V[3]*sHV[6] + 167*m2V[2]*sHV[7] + 16*sHV[9]
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :       + 7*m2V[8]*sHV[1]))/(sqrt(m2V[1])*mmsV[5]*mpsV[5]*sHV[1]*sptV[3]) +</span>
<span class="lineNum">     721 </span>            :       (m2V[11] + 19*m2V[9]*sHV[2] - m2V[8]*sHV[3] + 597*m2V[7]*sHV[4] +
<span class="lineNum">     722 </span>            :       321*m2V[6]*sHV[5] + 797*m2V[5]*sHV[6] - 791*m2V[4]*sHV[7] +
<span class="lineNum">     723 </span>            :       26*m2V[3]*sHV[8] - 468*m2V[2]*sHV[9] - 16*m2V[1]*sHV[10] -
<span class="lineNum">     724 </span>            :       16*sHV[11] -
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :       21*m2V[10]*sHV[1])/(sqrt(m2V[3])*mmsV[5]*mpsV[6]*sHV[2]*sptV[2]) +</span>
<span class="lineNum">     726 </span>            :       (2*(m2V[10] + 34*m2V[8]*sHV[2] - 198*m2V[7]*sHV[3] -
<span class="lineNum">     727 </span>            :       140*m2V[6]*sHV[4] - 746*m2V[5]*sHV[5] + 226*m2V[4]*sHV[6] -
<span class="lineNum">     728 </span>            :       486*m2V[3]*sHV[7] + 679*m2V[2]*sHV[8] - 50*m2V[1]*sHV[9] +
<span class="lineNum">     729 </span>            :       112*sHV[10] -
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :       8*m2V[9]*sHV[1]))/(sqrt(m2V[1])*mmsV[5]*mpsV[7]*sHV[2]*sptV[1]);</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :   } else if (jSave == 3) {</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :     fac *= 256. / 189.;</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :     sig  = 5/(sqrt(m2V[1])*mmsV[5]) + sqrt(m2V[3])/(mmsV[5]*sHV[2]) +</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :       (2*sqrt(m2V[3])*sHV[2]*(m2V[2] + sHV[2]))/(mmsV[3]*mmtV[5]*mpsV[3])</span>
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :       - (3*sqrt(m2V[1]))/(mmsV[5]*sHV[1]) -</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :       (5*sHV[1])/(sqrt(m2V[3])*mmsV[5]) + (sqrt(m2V[1])*(6*m2V[6] +</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :       67*m2V[4]*sHV[2] - 8*m2V[3]*sHV[3] + 45*m2V[2]*sHV[4] + 8*sHV[6] -</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :       4*m2V[5]*sHV[1]))/(mmsV[4]*mmtV[4]*mpsV[4]) + (-6*m2V[9] -</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :       152*m2V[7]*sHV[2] + 80*m2V[6]*sHV[3] - 269*m2V[5]*sHV[4] +</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :       211*m2V[4]*sHV[5] - 77*m2V[3]*sHV[6] + 155*m2V[2]*sHV[7] + 10*sHV[9]</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :       + 64*m2V[8]*sHV[1])/(sqrt(m2V[1])*mmsV[5]*mmtV[3]*mpsV[5]*sHV[1]) +</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :       (16*m2V[10] + 295*m2V[8]*sHV[2] - 555*m2V[7]*sHV[3] +</span>
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :       769*m2V[6]*sHV[4] - 1079*m2V[5]*sHV[5] + 913*m2V[4]*sHV[6] -</span>
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :       603*m2V[3]*sHV[7] + 601*m2V[2]*sHV[8] - 56*m2V[1]*sHV[9] +</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :       70*sHV[10] -</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :       83*m2V[9]*sHV[1])/(sqrt(m2V[1])*mmsV[5]*mmtV[1]*mpsV[7]*sHV[2]) +</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :       (8*m2V[11] + 104*m2V[9]*sHV[2] - 284*m2V[8]*sHV[3] +</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :       549*m2V[7]*sHV[4] - 282*m2V[6]*sHV[5] + 514*m2V[5]*sHV[6] -</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :       520*m2V[4]*sHV[7] + 34*m2V[3]*sHV[8] - 171*m2V[2]*sHV[9] -</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :       5*m2V[1]*sHV[10] - 5*sHV[11] -</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :       54*m2V[10]*sHV[1])/(sqrt(m2V[3])*mmsV[5]*mmtV[2]*mpsV[6]*sHV[2]) +</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :       (2*sqrt(m2V[3])*sHV[2]*(m2V[2] + sHV[2]))/(mmsV[3]*mpsV[3]*sptV[5])</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :       + (sqrt(m2V[1])*(6*m2V[6] + 67*m2V[4]*sHV[2] - 8*m2V[3]*sHV[3] +</span>
<span class="lineNum">     754 </span>            :       45*m2V[2]*sHV[4] + 8*sHV[6] -
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :       4*m2V[5]*sHV[1]))/(mmsV[4]*mpsV[4]*sptV[4]) + (-6*m2V[9] -</span>
<span class="lineNum">     756 </span>            :       152*m2V[7]*sHV[2] + 80*m2V[6]*sHV[3] - 269*m2V[5]*sHV[4] +
<span class="lineNum">     757 </span>            :       211*m2V[4]*sHV[5] - 77*m2V[3]*sHV[6] + 155*m2V[2]*sHV[7] + 10*sHV[9]
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :       + 64*m2V[8]*sHV[1])/(sqrt(m2V[1])*mmsV[5]*mpsV[5]*sHV[1]*sptV[3]) +</span>
<span class="lineNum">     759 </span>            :       (8*m2V[11] + 104*m2V[9]*sHV[2] - 284*m2V[8]*sHV[3] +
<span class="lineNum">     760 </span>            :       549*m2V[7]*sHV[4] - 282*m2V[6]*sHV[5] + 514*m2V[5]*sHV[6] -
<span class="lineNum">     761 </span>            :       520*m2V[4]*sHV[7] + 34*m2V[3]*sHV[8] - 171*m2V[2]*sHV[9] -
<span class="lineNum">     762 </span>            :       5*m2V[1]*sHV[10] - 5*sHV[11] -
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :       54*m2V[10]*sHV[1])/(sqrt(m2V[3])*mmsV[5]*mpsV[6]*sHV[2]*sptV[2]) +</span>
<span class="lineNum">     764 </span>            :       (16*m2V[10] + 295*m2V[8]*sHV[2] - 555*m2V[7]*sHV[3] +
<span class="lineNum">     765 </span>            :       769*m2V[6]*sHV[4] - 1079*m2V[5]*sHV[5] + 913*m2V[4]*sHV[6] -
<span class="lineNum">     766 </span>            :       603*m2V[3]*sHV[7] + 601*m2V[2]*sHV[8] - 56*m2V[1]*sHV[9] +
<span class="lineNum">     767 </span>            :       70*sHV[10] -
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :       83*m2V[9]*sHV[1])/(sqrt(m2V[1])*mmsV[5]*mpsV[7]*sHV[2]*sptV[1]);</span>
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     770 </span>            : 
<span class="lineNum">     771 </span>            :   // Answer.
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :   sigma = ((2.*jSave + 1.) / 3.) * oniumME * fac * sig;</span>
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     775 </span>            : 
<span class="lineNum">     776 </span>            : //==========================================================================
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span>            : // Sigma2gg2QQbarX8g class.
<span class="lineNum">     779 </span>            : // Cross section g g -&gt; QQbar[X(8)] g (Q = c or b, X = 3S1, 1S0 or 3PJ).
<span class="lineNum">     780 </span>            : 
<span class="lineNum">     781 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     782 </span>            : 
<a name="783"><span class="lineNum">     783 </span>            : // Initialize process.</a>
<span class="lineNum">     784 </span>            : 
<span class="lineNum">     785 </span>            : void Sigma2gg2QQbarX8g::initProc() {
<span class="lineNum">     786 </span>            : 
<span class="lineNum">     787 </span>            :   // Return for illegal process.
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :   if (stateSave &lt; 0 || stateSave &gt; 2) {</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :     idHad = 0;</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :     nameSave = &quot;illegal process&quot;;</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     792 </span>            :   }
<span class="lineNum">     793 </span>            : 
<span class="lineNum">     794 </span>            :   // Determine quark composition and quantum numbers.
<span class="lineNum">     795 </span>            :   int mod1(10), mod2(1);
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :   vector&lt;int&gt; digits;</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :   while (digits.size() &lt; 7) {</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :     digits.push_back((idHad%mod1 - idHad%mod2) / mod2);</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :     mod1 *= 10;</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :     mod2 *= 10;</span>
<span class="lineNum">     801 </span>            :   }
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :   int s, l, j((digits[0] - 1)/2);</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :   if (j != 0) {</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :     if      (digits[4] == 0) {l = j - 1; s = 1;}</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :     else if (digits[4] == 1) {l = j;     s = 0;}</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :     else if (digits[4] == 2) {l = j;     s = 1;}</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :     else                     {l = j + 1; s = 1;}</span>
<span class="lineNum">     808 </span>            :   } else {
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :     if      (digits[4] == 0) {l = 0;  s = 0;}</span>
<span class="lineNum">     810 </span>            :     else                     {l = 1;  s = 1;}
<span class="lineNum">     811 </span>            :   }
<span class="lineNum">     812 </span>            : 
<span class="lineNum">     813 </span>            :   // Set the process name.
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :   stringstream sName, jName;</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :   string lName, stateName;</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :   sName &lt;&lt; 2*s + 1;</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :   if (l == 0) jName &lt;&lt; j;</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :   else jName &lt;&lt; &quot;J&quot;;</span>
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :   if (l == 0) lName = &quot;S&quot;;</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :   else if (l == 1) lName = &quot;P&quot;;</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :   else if (l == 2) lName = &quot;D&quot;;</span>
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :   if (stateSave == 0) stateName = &quot;[3S1(8)]&quot;;</span>
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :   else if (stateSave == 1) stateName = &quot;[1S0(8)]&quot;;</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :   else if (stateSave == 2) stateName = &quot;[3PJ(8)]&quot;;</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :   nameSave = namePrefix() + &quot; -&gt; &quot; + (digits[1] == 4 ? &quot;ccbar&quot; : &quot;bbbar&quot;)</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :     + &quot;(&quot; + sName.str() + lName + jName.str() + &quot;)&quot; + stateName</span>
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :     + &quot; &quot; + namePostfix();</span>
<span class="lineNum">     828 </span>            : 
<span class="lineNum">     829 </span>            :   // Ensure the dummy particle for the colour-octet state is valid.
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :   int idOct = 9900000 + digits[1]*10000 + stateSave*1000 + digits[5]*100</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :     + digits[4]*10 + digits[0];</span>
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :   double m0     = particleDataPtr-&gt;m0(idHad) + abs(mSplit);</span>
<span class="lineNum">     833 </span>            :   double mWidth = 0.0;
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :   if (!particleDataPtr-&gt;isParticle(idOct)) {</span>
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :     string nameOct    = particleDataPtr-&gt;name(idHad) + stateName;</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :     int    spinType   = stateSave == 1 ? 1 : 3;</span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :     int    chargeType = particleDataPtr-&gt;chargeType(idHad);</span>
<span class="lineNum">     838 </span>            :     int    colType    = 2;
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :     particleDataPtr-&gt;addParticle(idOct, nameOct, spinType, chargeType, colType,</span>
<span class="lineNum">     840 </span>            :                                  m0, mWidth, m0, m0);
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :     ParticleDataEntry* entry = particleDataPtr-&gt;particleDataEntryPtr(idOct);</span>
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :     if (entry) entry-&gt;addChannel(1, 1.0, 0, idHad, 21);</span>
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :   } else if (mSplit &gt; 0 &amp;&amp; abs(particleDataPtr-&gt;m0(idOct) - m0) &gt; 1E-5) {</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :     particleDataPtr-&gt;m0(idOct, m0);</span>
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :     particleDataPtr-&gt;mWidth(idOct, mWidth);</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :     particleDataPtr-&gt;mMin(idOct, m0);</span>
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :     particleDataPtr-&gt;mMax(idOct, m0);</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :   } else if (particleDataPtr-&gt;m0(idOct) &lt;= particleDataPtr-&gt;m0(idHad)) {</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :     infoPtr-&gt;errorMsg(&quot;Warning in Sigma2gg2QQbarX8g::initProc: mass of &quot;</span>
<span class="lineNum">     850 </span>            :                       &quot;intermediate colour-octet state&quot;
<span class="lineNum">     851 </span>            :                       &quot;increased to be greater than the physical state&quot;);
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :     particleDataPtr-&gt;m0(idOct, m0);</span>
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :     particleDataPtr-&gt;mWidth(idOct, mWidth);</span>
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :     particleDataPtr-&gt;mMin(idOct, m0);</span>
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :     particleDataPtr-&gt;mMax(idOct, m0);</span>
<span class="lineNum">     856 </span>            :   }
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :   idHad = idOct;</span>
<span class="lineNum">     858 </span>            : 
<span class="lineNum">     859 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     862 </span>            : 
<a name="863"><span class="lineNum">     863 </span>            : // Evaluate d(sigmaHat)/d(tHat); no explicit flavour dependence.</a>
<span class="lineNum">     864 </span>            : 
<span class="lineNum">     865 </span>            : void Sigma2gg2QQbarX8g::sigmaKin() {
<span class="lineNum">     866 </span>            : 
<span class="lineNum">     867 </span>            :   // Calculate kinematics dependence.
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :   double stH = sH + tH;</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :   double tuH = tH + uH;</span>
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :   double usH = uH + sH;</span>
<span class="lineNum">     871 </span>            :   double sig = 0.;
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :   if (stateSave == 0) {</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :     sig = (M_PI / 72.) * m3 * ( 27. * (pow2(stH) + pow2(tuH)</span>
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :       + pow2(usH)) / (s3*s3) - 16. ) * ( pow2(sH * tuH)</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :       + pow2(tH * usH) + pow2(uH * stH) ) / pow2( stH * tuH * usH );</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :   } else if (stateSave == 1) {</span>
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :     sig = (5. * M_PI / 16.) * m3 * ( pow2(uH / (tuH * usH))</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :       + pow2(sH / (stH * usH)) + pow2(tH / (stH * tuH)) ) * ( 12.</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :       + (pow4(stH) + pow4(tuH) + pow4(usH)) / (s3 * sH * tH * uH) );</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :   } else if (stateSave == 2) {</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :     double sH3 = sH2 * sH;</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :     double sH4 = sH3 * sH;</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :     double sH5 = sH4 * sH;</span>
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :     double sH6 = sH5 * sH;</span>
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :     double sH7 = sH6 * sH;</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :     double sH8 = sH7 * sH;</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :     double tH3 = tH2 * tH;</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :     double tH4 = tH3 * tH;</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :     double tH5 = tH4 * tH;</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :     double tH6 = tH5 * tH;</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :     double tH7 = tH6 * tH;</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :     double tH8 = tH7 * tH;</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :     double ssttH = sH * sH + sH * tH + tH * tH;</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :     sig = 5. * M_PI * (3. * sH * tH * stH * pow4(ssttH)</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :       - s3 * pow2(ssttH) * (7. * sH6 + 36. * sH5 * tH + 45. * sH4 * tH2</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :         + 28. * sH3 * tH3 + 45. * sH2 * tH4 + 36. * sH * tH5 + 7. * tH6)</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :       + pow2(s3) * stH * (35. *sH8 + 169. * sH7 * tH + 299. * sH6 * tH2</span>
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :         + 401. * sH5 * tH3 + 418. * sH4 * tH4 + 401. * sH3 * tH5</span>
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :         + 299. * sH2 * tH6 + 169. * sH * tH7 + 35. * tH8)</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :       - pow3(s3) * (84. *sH8+432. *sH7*tH+905. *sH6*tH2</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :         + 1287. * sH5 * tH3 + 1436. * sH4 * tH4 +1287. * sH3 * tH5</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :         + 905. * sH2 * tH6 + 432. * sH * tH7 + 84. * tH8)</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :       + pow4(s3) * stH * (126. * sH6 + 451. * sH5 * tH +677. * sH4 * tH2</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :         + 836. * sH3 * tH3 + 677. * sH2 * tH4 + 451. * sH * tH5</span>
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :         + 126. * tH6)</span>
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :       - pow5(s3) * 3. * (42. * sH6 + 171. * sH5 * tH + 304. * sH4 * tH2</span>
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :         + 362. * sH3 * tH3 + 304. * sH2 * tH4 + 171. * sH * tH5</span>
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :         + 42. * tH6)</span>
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :       + pow3(s3 * s3) * 2. * stH * (42. * sH4 + 106. * sH3 * tH</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :         + 119. * sH2 * tH2 + 106. * sH * tH3 + 42. * tH4)</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :       - pow4(s3) * pow3(s3) * (35. * sH4 + 99. * sH3 * tH</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :         + 120. * sH2 * tH2 + 99.  * sH * tH3 + 35.  * tH4)</span>
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :       + pow4(s3 * s3) * 7. * stH * ssttH)</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :       / (sH * tH * uH * s3 * m3 * pow3(stH * tuH * usH));</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     916 </span>            : 
<span class="lineNum">     917 </span>            :   // Answer.
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :   sigma = (M_PI/sH2) * pow3(alpS) * oniumME * sig;</span>
<span class="lineNum">     919 </span>            : 
<span class="lineNum">     920 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     921 </span>            : 
<span class="lineNum">     922 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     923 </span>            : 
<a name="924"><span class="lineNum">     924 </span>            : // Select identity, colour and anticolour.</a>
<span class="lineNum">     925 </span>            : 
<span class="lineNum">     926 </span>            : void Sigma2gg2QQbarX8g::setIdColAcol() {
<span class="lineNum">     927 </span>            : 
<span class="lineNum">     928 </span>            :   // Flavours are trivial.
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :   setId( id1, id2, idHad, 21);</span>
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span>            :   // Split total contribution into different colour flows just like in
<span class="lineNum">     932 </span>            :   // g g -&gt; g g (with kinematics recalculated for massless partons).
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :   double sHr    = - (tH + uH);</span>
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :   double sH2r   = sHr * sHr;</span>
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :   double sigTS  = tH2/sH2r + 2.*tH/sHr + 3. + 2.*sHr/tH + sH2r/tH2;</span>
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :   double sigUS  = uH2/sH2r + 2.*uH/sHr + 3. + 2.*sHr/uH + sH2r/uH2;</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :   double sigTU  = tH2/uH2 + 2.*tH/uH + 3. + 2.*uH/tH + uH2/tH2;</span>
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :   double sigSum = sigTS + sigUS + sigTU;</span>
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span>            :   // Three colour flow topologies, each with two orientations.
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :   double sigRand = sigSum * rndmPtr-&gt;flat();</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :   if (sigRand &lt; sigTS) setColAcol( 1, 2, 2, 3, 1, 4, 4, 3);</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :   else if (sigRand &lt; sigTS + sigUS)</span>
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :                        setColAcol( 1, 2, 3, 1, 3, 4, 4, 2);</span>
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :   else                 setColAcol( 1, 2, 3, 4, 1, 4, 3, 2);</span>
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :   if (rndmPtr-&gt;flat() &gt; 0.5) swapColAcol();</span>
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     949 </span>            : 
<span class="lineNum">     950 </span>            : //==========================================================================
<span class="lineNum">     951 </span>            : 
<span class="lineNum">     952 </span>            : // Sigma2qg2QQbarX8q class.
<span class="lineNum">     953 </span>            : // Cross section q g -&gt; QQbar[X(8)] q (Q = c or b, X = 3S1, 1S0 or 3PJ).
<span class="lineNum">     954 </span>            : 
<span class="lineNum">     955 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     956 </span>            : 
<a name="957"><span class="lineNum">     957 </span>            : // Evaluate d(sigmaHat)/d(tHat); no explicit flavour dependence.</a>
<span class="lineNum">     958 </span>            : 
<span class="lineNum">     959 </span>            : void Sigma2qg2QQbarX8q::sigmaKin() {
<span class="lineNum">     960 </span>            : 
<span class="lineNum">     961 </span>            :   // Calculate kinematics dependence.
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :   double stH  = sH + tH;</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :   double tuH  = tH + uH;</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :   double usH  = uH + sH;</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :   double stH2 = stH * stH;</span>
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :   double tuH2 = tuH * tuH;</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :   double usH2 = usH * usH;</span>
<span class="lineNum">     968 </span>            :   double sig  = 0.;
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :   if (stateSave == 0) {</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :     sig = - (M_PI / 27.)* (4. * (sH2 + uH2) - sH * uH) * (stH2 +tuH2)</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :       / (s3 * m3 * sH * uH * usH2);</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :   } else if (stateSave == 1) {</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :     sig = - (5. * M_PI / 18.) * (sH2 + uH2) / (m3 * tH * usH2);</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :   } else if (stateSave == 2) {</span>
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :     sig = - (10. * M_PI / 9.) * ( (7. * usH + 8. * tH) * (sH2 + uH2)</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :       + 4. * tH * (2. * pow2(s3) - stH2 - tuH2) )</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :       / (s3 * m3 * tH * usH2 * usH);</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     979 </span>            : 
<span class="lineNum">     980 </span>            :   // Answer.
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :   sigma = (M_PI/sH2) * pow3(alpS) * oniumME * sig;</span>
<span class="lineNum">     982 </span>            : 
<span class="lineNum">     983 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     984 </span>            : 
<span class="lineNum">     985 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     986 </span>            : 
<a name="987"><span class="lineNum">     987 </span>            : // Select identity, colour and anticolour.</a>
<span class="lineNum">     988 </span>            : 
<span class="lineNum">     989 </span>            : void Sigma2qg2QQbarX8q::setIdColAcol() {
<span class="lineNum">     990 </span>            : 
<span class="lineNum">     991 </span>            :   // Flavours are trivial.
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :   int idq = (id2 == 21) ? id1 : id2;</span>
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :   setId( id1, id2, idHad, idq);</span>
<span class="lineNum">     994 </span>            : 
<span class="lineNum">     995 </span>            :   // tH defined between q_in and q_out: must swap tHat &lt;-&gt; uHat if q g in.
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :   swapTU = (id2 == 21);</span>
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span>            :   // Split total contribution into different colour flows just like in
<span class="lineNum">     999 </span>            :   // q g -&gt; q g (with kinematics recalculated for massless partons).
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :   double sHr    = - (tH + uH);</span>
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :   double sH2r   = sHr * sHr;</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :   double sigTS  = uH2/tH2 - (4./9.) * uH/sHr;</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :   double sigTU  = sH2r/tH2 - (4./9.) * sHr/uH;</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :   double sigSum = sigTS + sigTU;</span>
<span class="lineNum">    1005 </span>            : 
<span class="lineNum">    1006 </span>            :   // Two colour flow topologies. Swap if first is gluon, or when antiquark.
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :   double sigRand = sigSum * rndmPtr-&gt;flat();</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :   if (sigRand &lt; sigTS) setColAcol( 1, 0, 2, 1, 2, 3, 3, 0);</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :   else                 setColAcol( 1, 0, 2, 3, 1, 3, 2, 0);</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :   if (id1 == 21) swapCol12();</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :   if (idq &lt; 0) swapColAcol();</span>
<span class="lineNum">    1012 </span>            : 
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1014 </span>            : 
<span class="lineNum">    1015 </span>            : //==========================================================================
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span>            : // Sigma2qqbar2QQbarX8g class.
<span class="lineNum">    1018 </span>            : // Cross section q qbar -&gt; QQbar[X(8)] g (Q = c or b, X = 3S1, 1S0 or 3PJ).
<span class="lineNum">    1019 </span>            : 
<span class="lineNum">    1020 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1021 </span>            : 
<a name="1022"><span class="lineNum">    1022 </span>            : // Evaluate d(sigmaHat)/d(tHat); no explicit flavour dependence.</a>
<span class="lineNum">    1023 </span>            : 
<span class="lineNum">    1024 </span>            : void Sigma2qqbar2QQbarX8g::sigmaKin() {
<span class="lineNum">    1025 </span>            : 
<span class="lineNum">    1026 </span>            :   // Calculate kinematics dependence.
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :   double stH  = sH + tH;</span>
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :   double tuH  = tH + uH;</span>
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :   double usH  = uH + sH;</span>
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :   double stH2 = stH * stH;</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :   double tuH2 = tuH * tuH;</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :   double usH2 = usH * usH;</span>
<span class="lineNum">    1033 </span>            :   double sig  = 0.;
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :   if (stateSave == 0) {</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :     sig = (8. * M_PI / 81.) * (4. * (tH2 + uH2) - tH * uH)</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :       * (stH2 + usH2) / (s3 * m3 * tH * uH * tuH2);</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :   } else if (stateSave == 1) {</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :     sig = (20. * M_PI / 27.) * (tH2 + uH2) / (m3 * sH * tuH2);</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :   } else if (stateSave == 2) {</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :     sig = (80. * M_PI / 27.) * ( (7. * tuH + 8. * sH) * (tH2 + uH2)</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :       + 4. * sH * (2. * pow2(s3) - stH2 -usH2) )</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :       / (s3 * m3 * sH * tuH2 * tuH);</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1044 </span>            : 
<span class="lineNum">    1045 </span>            :   // Answer.
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :   sigma = (M_PI/sH2) * pow3(alpS) * oniumME * sig;</span>
<span class="lineNum">    1047 </span>            : 
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1049 </span>            : 
<span class="lineNum">    1050 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1051 </span>            : 
<a name="1052"><span class="lineNum">    1052 </span>            : // Select identity, colour and anticolour.</a>
<span class="lineNum">    1053 </span>            : 
<span class="lineNum">    1054 </span>            : void Sigma2qqbar2QQbarX8g::setIdColAcol() {
<span class="lineNum">    1055 </span>            : 
<span class="lineNum">    1056 </span>            :   // Flavours are trivial.
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :   setId( id1, id2, idHad, 21);</span>
<span class="lineNum">    1058 </span>            : 
<span class="lineNum">    1059 </span>            :   // Split total contribution into different colour flows just like in
<span class="lineNum">    1060 </span>            :   // q qbar -&gt; g g (with kinematics recalculated for massless partons).
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :   double sHr    = - (tH + uH);</span>
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :   double sH2r   = sHr * sHr;</span>
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :   double sigTS  = (4. / 9.) * uH / tH - uH2 / sH2r;</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :   double sigUS  = (4. / 9.) * tH / uH - tH2 / sH2r;</span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :   double sigSum = sigTS + sigUS;</span>
<span class="lineNum">    1066 </span>            : 
<span class="lineNum">    1067 </span>            :   // Two colour flow topologies. Swap if first is antiquark.
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :   double sigRand = sigSum * rndmPtr-&gt;flat();</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :   if (sigRand &lt; sigTS) setColAcol( 1, 0, 0, 2, 1, 3, 3, 2);</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :   else                 setColAcol( 1, 0, 0, 2, 3, 2, 1, 3);</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :   if (id1 &lt; 0) swapColAcol();</span>
<span class="lineNum">    1072 </span>            : 
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1074 </span>            : 
<span class="lineNum">    1075 </span>            : //==========================================================================
<span class="lineNum">    1076 </span>            : 
<span class="lineNum">    1077 </span>            : } // end namespace Pythia8
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
