<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - PYTHIA8/pythia8210dev/src/SpaceShower.cc</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">PYTHIA8/pythia8210dev/src</a> - SpaceShower.cc<span style="font-size: 80%;"> (source / <a href="SpaceShower.cc.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">1368</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">16</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // SpaceShower.cc is a part of the PYTHIA event generator.</a>
<span class="lineNum">       2 </span>            : // Copyright (C) 2015 Torbjorn Sjostrand.
<span class="lineNum">       3 </span>            : // PYTHIA is licenced under the GNU GPL version 2, see COPYING for details.
<span class="lineNum">       4 </span>            : // Please respect the MCnet Guidelines, see GUIDELINES for details.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : // Function definitions (not found in the header) for the
<span class="lineNum">       7 </span>            : // SpaceShower class.
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;Pythia8/SpaceShower.h&quot;
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : namespace Pythia8 {
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : //==========================================================================
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : // The SpaceShower class.
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : // Constants: could be changed here if desired, but normally should not.
<span class="lineNum">      20 </span>            : // These are of technical nature, as described for each.
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : // Leftover companion can give PDF &gt; 0 at small Q2 where other PDF's = 0,
<span class="lineNum">      23 </span>            : // and then one can end in infinite loop of impossible kinematics.
<span class="lineNum">      24 </span>            : const int    SpaceShower::MAXLOOPTINYPDF = 10;
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : // Minimal allowed c and b quark masses, for flavour thresholds.
<span class="lineNum">      27 </span>            : const double SpaceShower::MCMIN          = 1.2;
<span class="lineNum">      28 </span>            : const double SpaceShower::MBMIN          = 4.0;
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : // Switch to alternative (but equivalent) backwards evolution for
<span class="lineNum">      31 </span>            : // g -&gt; Q Qbar (Q = c or b) when below QTHRESHOLD * mQ2.
<span class="lineNum">      32 </span>            : const double SpaceShower::CTHRESHOLD     = 2.0;
<span class="lineNum">      33 </span>            : const double SpaceShower::BTHRESHOLD     = 2.0;
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : // Renew evaluation of PDF's when the pT2 step is bigger than this
<span class="lineNum">      36 </span>            : // (in addition to initial scale and c and b thresholds.)
<span class="lineNum">      37 </span>            : const double SpaceShower::EVALPDFSTEP    = 0.1;
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : // Lower limit on PDF value in order to avoid division by zero.
<span class="lineNum">      40 </span>            : const double SpaceShower::TINYPDF        = 1e-10;
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : // Lower limit on estimated evolution rate, below which stop.
<span class="lineNum">      43 </span>            : const double SpaceShower::TINYKERNELPDF  = 1e-6;
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : // Lower limit on pT2, below which branching is rejected.
<span class="lineNum">      46 </span>            : const double SpaceShower::TINYPT2        = 0.25e-6;
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            : // No attempt to do backwards evolution of a heavy (c or b) quark
<span class="lineNum">      49 </span>            : // if evolution starts at a scale pT2 &lt; HEAVYPT2EVOL * mQ2.
<span class="lineNum">      50 </span>            : const double SpaceShower::HEAVYPT2EVOL   = 1.1;
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : // No attempt to do backwards evolution of a heavy (c or b) quark
<span class="lineNum">      53 </span>            : // if evolution starts at a  x &gt; HEAVYXEVOL * x_max, where
<span class="lineNum">      54 </span>            : // x_max is the largest possible x value for a g -&gt; Q Qbar branching.
<span class="lineNum">      55 </span>            : const double SpaceShower::HEAVYXEVOL     = 0.9;
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            : // When backwards evolution Q -&gt; g + Q creates a heavy quark Q,
<span class="lineNum">      58 </span>            : // an earlier branching g -&gt; Q + Qbar will restrict kinematics
<span class="lineNum">      59 </span>            : // to  M_{Q Qbar}^2 &gt; EXTRASPACEQ * 4 m_Q^2. (Smarter to be found??)
<span class="lineNum">      60 </span>            : const double SpaceShower::EXTRASPACEQ    = 2.0;
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            : // Never pick pT so low that alphaS is evaluated too close to Lambda_3.
<span class="lineNum">      63 </span>            : const double SpaceShower::LAMBDA3MARGIN  = 1.1;
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            : // Do not warn for large PDF ratios at small pT2 scales.
<span class="lineNum">      66 </span>            : const double SpaceShower::PT2MINWARN = 1.;
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            : // Cutoff for f_e^e at x &lt; 1 - 10^{-10} to be used in z selection.
<span class="lineNum">      69 </span>            : // Note: the x_min quantity come from 1 - x_max.
<span class="lineNum">      70 </span>            : const double SpaceShower::LEPTONXMIN     = 1e-10;
<span class="lineNum">      71 </span>            : const double SpaceShower::LEPTONXMAX     = 1. - 1e-10;
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : // Stop l -&gt; l gamma evolution slightly above m2l.
<span class="lineNum">      74 </span>            : const double SpaceShower::LEPTONPT2MIN   = 1.2;
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            : // Enhancement of l -&gt; l gamma trial rate to compensate imperfect modelling.
<span class="lineNum">      77 </span>            : const double SpaceShower::LEPTONFUDGE    = 10.;
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : // Overestimation extra factor for t-channel weak ME corrections.
<span class="lineNum">      80 </span>            : const double SpaceShower::WEAKPSWEIGHT = 5.;
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            : // Overestimation extra factors by branching type
<span class="lineNum">      83 </span>            : const double SpaceShower::HEADROOMQ2G = 1.35;
<span class="lineNum">      84 </span>            : const double SpaceShower::HEADROOMQ2Q = 1.15;
<span class="lineNum">      85 </span>            : const double SpaceShower::HEADROOMG2Q = 1.35;
<span class="lineNum">      86 </span>            : const double SpaceShower::HEADROOMG2G = 1.35;
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      89 </span>            : 
<a name="90"><span class="lineNum">      90 </span>            : // Initialize alphaStrong, alphaEM and related pTmin parameters.</a>
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            : void SpaceShower::init( BeamParticle* beamAPtrIn,
<span class="lineNum">      93 </span>            :   BeamParticle* beamBPtrIn) {
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span>            :   // Store input pointers for future use.
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :   beamAPtr        = beamAPtrIn;</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :   beamBPtr        = beamBPtrIn;</span>
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span>            :   // Main flags to switch on and off branchings.
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :   doQCDshower     = settingsPtr-&gt;flag(&quot;SpaceShower:QCDshower&quot;);</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :   doQEDshowerByQ  = settingsPtr-&gt;flag(&quot;SpaceShower:QEDshowerByQ&quot;);</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :   doQEDshowerByL  = settingsPtr-&gt;flag(&quot;SpaceShower:QEDshowerByL&quot;);</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :   doWeakShower    = settingsPtr-&gt;flag(&quot;SpaceShower:WeakShower&quot;);</span>
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            :   // Matching in pT of hard interaction to shower evolution.
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :   pTmaxMatch      = settingsPtr-&gt;mode(&quot;SpaceShower:pTmaxMatch&quot;);</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :   pTdampMatch     = settingsPtr-&gt;mode(&quot;SpaceShower:pTdampMatch&quot;);</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :   pTmaxFudge      = settingsPtr-&gt;parm(&quot;SpaceShower:pTmaxFudge&quot;);</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :   pTmaxFudgeMPI   = settingsPtr-&gt;parm(&quot;SpaceShower:pTmaxFudgeMPI&quot;);</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :   pTdampFudge     = settingsPtr-&gt;parm(&quot;SpaceShower:pTdampFudge&quot;);</span>
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span>            :   // Optionally force emissions to be ordered in rapidity/angle.
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :   doRapidityOrder = settingsPtr-&gt;flag(&quot;SpaceShower:rapidityOrder&quot;);</span>
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            :   // Charm, bottom and lepton mass thresholds.
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :   mc              = max( MCMIN, particleDataPtr-&gt;m0(4));</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :   mb              = max( MBMIN, particleDataPtr-&gt;m0(5));</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :   m2c             = pow2(mc);</span>
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :   m2b             = pow2(mb);</span>
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            :   // Parameters of scale choices.
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :   renormMultFac     = settingsPtr-&gt;parm(&quot;SpaceShower:renormMultFac&quot;);</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :   factorMultFac     = settingsPtr-&gt;parm(&quot;SpaceShower:factorMultFac&quot;);</span>
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :   useFixedFacScale  = settingsPtr-&gt;flag(&quot;SpaceShower:useFixedFacScale&quot;);</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :   fixedFacScale2    = pow2(settingsPtr-&gt;parm(&quot;SpaceShower:fixedFacScale&quot;));</span>
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            :   // Parameters of alphaStrong generation.
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :   alphaSvalue     = settingsPtr-&gt;parm(&quot;SpaceShower:alphaSvalue&quot;);</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :   alphaSorder     = settingsPtr-&gt;mode(&quot;SpaceShower:alphaSorder&quot;);</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :   alphaSnfmax     = settingsPtr-&gt;mode(&quot;StandardModel:alphaSnfmax&quot;);</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :   alphaSuseCMW    = settingsPtr-&gt;flag(&quot;SpaceShower:alphaSuseCMW&quot;);</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :   alphaS2pi       = 0.5 * alphaSvalue / M_PI;</span>
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            :   // Initialize alpha_strong generation.
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :   alphaS.init( alphaSvalue, alphaSorder, alphaSnfmax, alphaSuseCMW);</span>
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            :   // Lambda for 5, 4 and 3 flavours.
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :   Lambda5flav     = alphaS.Lambda5();</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :   Lambda4flav     = alphaS.Lambda4();</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :   Lambda3flav     = alphaS.Lambda3();</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :   Lambda5flav2    = pow2(Lambda5flav);</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :   Lambda4flav2    = pow2(Lambda4flav);</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :   Lambda3flav2    = pow2(Lambda3flav);</span>
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            :   // Regularization of QCD evolution for pT -&gt; 0. Can be taken
<span class="lineNum">     146 </span>            :   // same as for multiparton interactions, or be set separately.
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :   useSamePTasMPI  = settingsPtr-&gt;flag(&quot;SpaceShower:samePTasMPI&quot;);</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :   if (useSamePTasMPI) {</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :     pT0Ref        = settingsPtr-&gt;parm(&quot;MultipartonInteractions:pT0Ref&quot;);</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :     ecmRef        = settingsPtr-&gt;parm(&quot;MultipartonInteractions:ecmRef&quot;);</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :     ecmPow        = settingsPtr-&gt;parm(&quot;MultipartonInteractions:ecmPow&quot;);</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :     pTmin         = settingsPtr-&gt;parm(&quot;MultipartonInteractions:pTmin&quot;);</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :     pT0Ref        = settingsPtr-&gt;parm(&quot;SpaceShower:pT0Ref&quot;);</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :     ecmRef        = settingsPtr-&gt;parm(&quot;SpaceShower:ecmRef&quot;);</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :     ecmPow        = settingsPtr-&gt;parm(&quot;SpaceShower:ecmPow&quot;);</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :     pTmin         = settingsPtr-&gt;parm(&quot;SpaceShower:pTmin&quot;);</span>
<span class="lineNum">     158 </span>            :   }
<span class="lineNum">     159 </span>            : 
<span class="lineNum">     160 </span>            :   // Calculate nominal invariant mass of events. Set current pT0 scale.
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :   sCM             = m2( beamAPtr-&gt;p(), beamBPtr-&gt;p());</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :   eCM             = sqrt(sCM);</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :   pT0             = pT0Ref * pow(eCM / ecmRef, ecmPow);</span>
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span>            :   // Restrict pTmin to ensure that alpha_s(pTmin^2 + pT_0^2) does not blow up.
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :   double pTminAbs = sqrtpos(pow2(LAMBDA3MARGIN) * Lambda3flav2 / renormMultFac</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :                   - pT0*pT0);</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :   if (pTmin &lt; pTminAbs) {</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :     pTmin         = pTminAbs;</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :     ostringstream newPTmin;</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :     newPTmin &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; pTmin;</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :     infoPtr-&gt;errorMsg(&quot;Warning in SpaceShower::init: pTmin too low&quot;,</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :                       &quot;, raised to &quot; + newPTmin.str() );</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :     infoPtr-&gt;setTooLowPTmin(true);</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span>            :   // Parameters of alphaEM generation.
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :   alphaEMorder    = settingsPtr-&gt;mode(&quot;SpaceShower:alphaEMorder&quot;);</span>
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span>            :   // Initialize alphaEM generation.
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :   alphaEM.init( alphaEMorder, settingsPtr);</span>
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span>            :   // Parameters of QED evolution.
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :   pTminChgQ       = settingsPtr-&gt;parm(&quot;SpaceShower:pTminchgQ&quot;);</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :   pTminChgL       = settingsPtr-&gt;parm(&quot;SpaceShower:pTminchgL&quot;);</span>
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span>            :   // Derived parameters of QCD evolution.
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :   pT20            = pow2(pT0);</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :   pT2min          = pow2(pTmin);</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :   pT2minChgQ      = pow2(pTminChgQ);</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :   pT2minChgL      = pow2(pTminChgL);</span>
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            :   // Parameters of weak evolution.
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :   weakMode           = settingsPtr-&gt;mode(&quot;SpaceShower:weakShowerMode&quot;);</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :   pTweakCut          = settingsPtr-&gt;parm(&quot;SpaceShower:pTminWeak&quot;);</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :   pT2weakCut         = pow2(pTweakCut);</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :   weakEnhancement    = settingsPtr-&gt;parm(&quot;WeakShower:enhancement&quot;);</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :   singleWeakEmission = settingsPtr-&gt;flag(&quot;WeakShower:singleEmission&quot;);</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :   vetoWeakJets       = settingsPtr-&gt;flag(&quot;WeakShower:vetoWeakJets&quot;);</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :   vetoWeakDeltaR2    = pow2(settingsPtr-&gt;parm(&quot;weakShower:vetoWeakDeltaR&quot;));</span>
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span>            :   // Various other parameters.
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :   doMEcorrections    = settingsPtr-&gt;flag(&quot;SpaceShower:MEcorrections&quot;);</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :   doMEafterFirst     = settingsPtr-&gt;flag(&quot;SpaceShower:MEafterFirst&quot;);</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :   doPhiPolAsym       = settingsPtr-&gt;flag(&quot;SpaceShower:phiPolAsym&quot;);</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :   doPhiIntAsym       = settingsPtr-&gt;flag(&quot;SpaceShower:phiIntAsym&quot;);</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :   strengthIntAsym    = settingsPtr-&gt;parm(&quot;SpaceShower:strengthIntAsym&quot;);</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :   nQuarkIn           = settingsPtr-&gt;mode(&quot;SpaceShower:nQuarkIn&quot;);</span>
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span>            :   // Z0 and W+- properties needed for weak showers.
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :   mZ                 = particleDataPtr-&gt;m0(23);</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :   gammaZ             = particleDataPtr-&gt;mWidth(23);</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :   thetaWRat          = 1. / (16. * coupSMPtr-&gt;sin2thetaW()</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :                        * coupSMPtr-&gt;cos2thetaW());</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :   mW                 = particleDataPtr-&gt;m0(24);</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :   gammaW             = particleDataPtr-&gt;mWidth(24);</span>
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span>            :   // Possibility of two predetermined hard emissions in event.
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :   doSecondHard       = settingsPtr-&gt;flag(&quot;SecondHard:generate&quot;);</span>
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span>            :   // Optional dampening at small pT's when large multiplicities.
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :   enhanceScreening</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :     = settingsPtr-&gt;mode(&quot;MultipartonInteractions:enhanceScreening&quot;);</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :   if (!useSamePTasMPI) enhanceScreening = 0;</span>
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            :   // Possibility to allow user veto of emission step.
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :   canVetoEmission    = (userHooksPtr != 0)</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :                      ? userHooksPtr-&gt;canVetoISREmission() : false;</span>
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span>            :   // Default values for the weak shower.
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :   hasWeaklyRadiated  = false;</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :   weakMaxWt          = 1.;</span>
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span>            : // Find whether to limit maximum scale of emissions.
<a name="239"><span class="lineNum">     239 </span>            : // Also allow for dampening at factorization or renormalization scale.</a>
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span>            : bool SpaceShower::limitPTmax( Event&amp; event, double Q2Fac, double Q2Ren) {
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            :   // Find whether to limit pT. Begin by user-set cases.
<span class="lineNum">     244 </span>            :   bool dopTlimit = false;
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :   dopTlimit1 = dopTlimit2 = false;</span>
<span class="lineNum">     246 </span>            :   int nHeavyCol = 0;
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :   if      (pTmaxMatch == 1) dopTlimit = dopTlimit1 = dopTlimit2 = true;</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :   else if (pTmaxMatch == 2) dopTlimit = dopTlimit1 = dopTlimit2 = false;</span>
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span>            :   // Always restrict SoftQCD processes.
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :   else if (infoPtr-&gt;isNonDiffractive() || infoPtr-&gt;isDiffractiveA()</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :     || infoPtr-&gt;isDiffractiveB() || infoPtr-&gt;isDiffractiveC() )</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :     dopTlimit = dopTlimit1 = dopTlimit2 = true;</span>
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            :   // Look if any quark (u, d, s, c, b), gluon or photon in final state.
<span class="lineNum">     256 </span>            :   // Also count number of heavy coloured particles, like top.
<span class="lineNum">     257 </span>            :   else {
<span class="lineNum">     258 </span>            :     int n21 = 0;
<span class="lineNum">     259 </span>            :     int iBegin = 5;
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :     if (infoPtr-&gt;isHardDiffractive()) iBegin = 9;</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :     for (int i = iBegin; i &lt; event.size(); ++i) {</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :       if (event[i].status() == -21) ++n21;</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :       else if (n21 == 0) {</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :         int idAbs = event[i].idAbs();</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :         if (idAbs &lt;= 5 || idAbs == 21 || idAbs == 22) dopTlimit1 = true;</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :         if ( (event[i].col() != 0 || event[i].acol() != 0)</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :           &amp;&amp; idAbs &gt; 5 &amp;&amp; idAbs != 21 ) ++nHeavyCol;</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :       } else if (n21 == 2) {</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :         int idAbs = event[i].idAbs();</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :         if (idAbs &lt;= 5 || idAbs == 21 || idAbs == 22) dopTlimit2 = true;</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     272 </span>            :     }
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :     dopTlimit = (doSecondHard) ? (dopTlimit1 &amp;&amp; dopTlimit2) : dopTlimit1;</span>
<span class="lineNum">     274 </span>            :   }
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            :   // Dampening at factorization or renormalization scale; only for hardest.
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :   dopTdamp   = false;</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :   pT2damp    = 0.;</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :   if (!dopTlimit1 &amp;&amp; (pTdampMatch == 1 || pTdampMatch == 2)) {</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :     dopTdamp = true;</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :     pT2damp  = pow2(pTdampFudge) * ((pTdampMatch == 1) ? Q2Fac : Q2Ren);</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :   if (!dopTlimit1 &amp;&amp; nHeavyCol &gt; 1 &amp;&amp; (pTdampMatch == 3 || pTdampMatch == 4)) {</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :     dopTdamp = true;</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :     pT2damp  = pow2(pTdampFudge) * ((pTdampMatch == 3) ? Q2Fac : Q2Ren);</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            :   // Done.
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :   return dopTlimit;</span>
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            : }
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span>            : // Prepare system for evolution; identify ME.
<a name="296"><span class="lineNum">     296 </span>            : // Routine may be called after multiparton interactions, for a new subystem.</a>
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            : void SpaceShower::prepare( int iSys, Event&amp; event, bool limitPTmaxIn) {
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span>            :   // Reset W/Z radiation flag and counters at first call for new event.
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :   if (iSys == 0) {</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :     nRadA.clear();</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :     nRadB.clear();</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :     hasWeaklyRadiated = false;</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            :   // Find positions of incoming colliding partons.
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :   int in1 = partonSystemsPtr-&gt;getInA(iSys);</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :   int in2 = partonSystemsPtr-&gt;getInB(iSys);</span>
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            :   // Rescattered partons cannot radiate.
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :   bool canRadiate1 = !(event[in1].isRescatteredIncoming());</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :   bool canRadiate2 = !(event[in2].isRescatteredIncoming());</span>
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span>            :   // Reset dipole-ends list for first interaction. Also resonances.
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :   if (iSys == 0) dipEnd.resize(0);</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :   if (iSys == 0) idResFirst  = 0;</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :   if (iSys == 1) idResSecond = 0;</span>
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span>            :   // Find matrix element corrections for system.
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :   int MEtype = findMEtype( iSys, event, false);</span>
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            :   // In case of DPS overwrite limitPTmaxIn by saved value.
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :   if (doSecondHard &amp;&amp; iSys == 0) limitPTmaxIn = dopTlimit1;</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :   if (doSecondHard &amp;&amp; iSys == 1) limitPTmaxIn = dopTlimit2;</span>
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            :   // Maximum pT scale for dipole ends.
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :   double pTmax1 = (limitPTmaxIn) ? event[in1].scale() : eCM;</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :   double pTmax2 = (limitPTmaxIn) ? event[in2].scale() : eCM;</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :   if ( limitPTmaxIn &amp;&amp; (iSys == 0 || (iSys == 1 &amp;&amp; doSecondHard)) ) {</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :     pTmax1 *= pTmaxFudge;</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :     pTmax2 *= pTmaxFudge;</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :   } else if (limitPTmaxIn &amp;&amp; iSys &gt; 0) {</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :     pTmax1 *= pTmaxFudgeMPI;</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :     pTmax2 *= pTmaxFudgeMPI;</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span>            :   // Find dipole ends for QCD radiation.
<span class="lineNum">     339 </span>            :   // Note: colour type can change during evolution, so book also if zero.
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :   if (doQCDshower) {</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :     int colType1 = event[in1].colType();</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :     if (canRadiate1) dipEnd.push_back( SpaceDipoleEnd( iSys,  1,</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :       in1, in2, pTmax1, colType1, 0, 0, MEtype, canRadiate2) );</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :     int colType2 = event[in2].colType();</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :     if (canRadiate2) dipEnd.push_back( SpaceDipoleEnd( iSys,  2,</span>
<span class="lineNum">     346 </span>            :       in2, in1, pTmax2, colType2, 0, 0, MEtype, canRadiate1) );
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span>            :   // Find dipole ends for QED radiation.
<span class="lineNum">     350 </span>            :   // Note: charge type can change during evolution, so book also if zero.
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :   if (doQEDshowerByQ || doQEDshowerByL) {</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :     int chgType1 = ( (event[in1].isQuark() &amp;&amp; doQEDshowerByQ)</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :       || (event[in1].isLepton() &amp;&amp; doQEDshowerByL) )</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :       ? event[in1].chargeType() : 0;</span>
<span class="lineNum">     355 </span>            :     // Special: photons have charge zero, but can evolve (only off Q for now)
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :     if (event[in1].id() == 22 &amp;&amp; doQEDshowerByQ) chgType1 = 22 ;</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :     if (canRadiate1) dipEnd.push_back( SpaceDipoleEnd( iSys, -1,</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :       in1, in2, pTmax1, 0, chgType1, 0, MEtype, canRadiate2) );</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :     int chgType2 = ( (event[in2].isQuark() &amp;&amp; doQEDshowerByQ)</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :       || (event[in2].isLepton() &amp;&amp; doQEDshowerByL) )</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :       ? event[in2].chargeType() : 0;</span>
<span class="lineNum">     362 </span>            :     // Special: photons have charge zero, but can evolve (only off Q for now)
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :     if (event[in2].id() == 22 &amp;&amp; doQEDshowerByQ) chgType2 = 22 ;</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :     if (canRadiate2) dipEnd.push_back( SpaceDipoleEnd( iSys, -2,</span>
<span class="lineNum">     365 </span>            :       in2, in1, pTmax2, 0, chgType2, 0, MEtype, canRadiate1) );
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span>            :   // Find dipole ends for weak radiation. No right-handed W emission.
<span class="lineNum">     369 </span>            :   // Currently leptons are not allow to emit W bosons and only
<span class="lineNum">     370 </span>            :   // emissions from the hard process are included.
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :   if (doWeakShower &amp;&amp; iSys == 0) {</span>
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            :     // Determine what type of 2 -&gt; 2 process it is.
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :     int MEtypeWeak = findMEtype( iSys, event, true);</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :     if (MEtypeWeak == 201 || MEtypeWeak == 202 || MEtypeWeak == 203 ||</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :         MEtypeWeak == 206 || MEtypeWeak == 207 || MEtypeWeak == 208) {</span>
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span>            :       // Nonidentical incoming flavours.
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :       if (event[in1].id() != event[in2].id()) {</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :         if (event[in1].id() == event[in1 + 2].id()) tChannel = true;</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :         else if (event[in2].id() == event[in1 + 2].id()) tChannel = false;</span>
<span class="lineNum">     382 </span>            :         // No quark matches the outgoing, choose randomly.
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :         else tChannel = (rndmPtr-&gt;flat() &lt; 0.5);</span>
<span class="lineNum">     384 </span>            :       // In case of same quark flavours, choose randomly.
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :       } else tChannel = (rndmPtr-&gt;flat() &lt; 0.5);</span>
<span class="lineNum">     386 </span>            :     }
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span>            :     // Set up weak dipole ends for first incoming parton.
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :     int weakPol = (rndmPtr-&gt;flat() &gt; 0.5) ? -1 : 1;</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :     if (event[in1].idAbs() &lt; 20) event[in1].pol(weakPol);</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :     if (canRadiate1) {</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :       if ( (weakMode == 0 || weakMode == 1) &amp;&amp; weakPol == -1</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :         &amp;&amp; event[in1].isQuark() )</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :         dipEnd.push_back( SpaceDipoleEnd( iSys, 1, in1, in2, pTmax1,</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :           0, 0, 1, MEtypeWeak, canRadiate2, weakPol) );</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :       if ( (weakMode == 0 || weakMode == 2)</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :         &amp;&amp; (event[in1].isQuark() || event[in1].isLepton()) )</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :         dipEnd.push_back( SpaceDipoleEnd( iSys, 1, in1, in2, pTmax1,</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :           0, 0, 2, MEtypeWeak + 5, canRadiate2, weakPol) );</span>
<span class="lineNum">     400 </span>            :     }
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            :     // Set up weak dipole ends for second incoming parton.
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :     if (event[in1].id() != - event[in2].id())</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :       weakPol = (rndmPtr-&gt;flat() &gt; 0.5) ? -1 : 1;</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :     if (event[in2].idAbs() &lt; 20) event[in2].pol(weakPol);</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :     if (canRadiate2) {</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :       if ( (weakMode == 0 || weakMode == 1) &amp;&amp; weakPol == -1</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :         &amp;&amp; event[in2].isQuark())</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :         dipEnd.push_back( SpaceDipoleEnd( iSys, 2, in2, in1, pTmax2,</span>
<span class="lineNum">     410 </span>            :           0, 0, 1, MEtypeWeak, canRadiate1, weakPol) );
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :       if ( (weakMode == 0 || weakMode == 2) &amp;&amp;</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :         (event[in2].isQuark() || event[in2].isLepton()) )</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :         dipEnd.push_back( SpaceDipoleEnd( iSys, 2, in2, in1, pTmax2,</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :           0, 0, 2, MEtypeWeak + 5, canRadiate1, weakPol) );</span>
<span class="lineNum">     415 </span>            :     }
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            :   // Store the z and pT2 values of the last previous splitting
<span class="lineNum">     419 </span>            :   // when an event history has already been constructed.
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :   if (iSys == 0 &amp;&amp; infoPtr-&gt;hasHistory()) {</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :     double zNow   = infoPtr-&gt;zNowISR();</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :     double pT2Now = infoPtr-&gt;pT2NowISR();</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :     for (int iDipEnd = 0; iDipEnd &lt; int(dipEnd.size()); ++iDipEnd) {</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :       dipEnd[iDipEnd].zOld = zNow;</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :       dipEnd[iDipEnd].pT2Old = pT2Now;</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :       ++dipEnd[iDipEnd].nBranch;</span>
<span class="lineNum">     427 </span>            :     }
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     433 </span>            : 
<a name="434"><span class="lineNum">     434 </span>            : // Select next pT in downwards evolution of the existing dipoles.</a>
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span>            : double SpaceShower::pTnext( Event&amp; event, double pTbegAll, double pTendAll,
<span class="lineNum">     437 </span>            :   int nRadIn) {
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span>            :   // Current cm energy, in case it varies between events.
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :   sCM           = m2( beamAPtr-&gt;p(), beamBPtr-&gt;p());</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :   eCM           = sqrt(sCM);</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :   pTbegRef      = pTbegAll;</span>
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            :   // Starting values: no radiating dipole found.
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :   nRad          = nRadIn;</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :   double pT2sel = pow2(pTendAll);</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :   iDipSel       = 0;</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :   iSysSel       = 0;</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :   dipEndSel     = 0;</span>
<span class="lineNum">     450 </span>            : 
<span class="lineNum">     451 </span>            :   // Loop over all possible dipole ends.
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :   for (int iDipEnd = 0; iDipEnd &lt; int(dipEnd.size()); ++iDipEnd) {</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :     iDipNow        = iDipEnd;</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :     dipEndNow      = &amp;dipEnd[iDipEnd];</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :     iSysNow        = dipEndNow-&gt;system;</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :     dipEndNow-&gt;pT2 = 0.;</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :     double pTbegDip = min( pTbegAll, dipEndNow-&gt;pTmax );</span>
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span>            :     // Check whether dipole end should be allowed to shower.
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :     double pT2begDip = pow2(pTbegDip);</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :     if (pT2begDip &gt; pT2sel &amp;&amp; ( dipEndNow-&gt;colType != 0</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :       || dipEndNow-&gt;chgType != 0 || dipEndNow-&gt;weakType != 0) ) {</span>
<span class="lineNum">     463 </span>            :       double pT2endDip = 0.;
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            :       // Determine lower cut for evolution, for QCD or QED (q or l).
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :       if (dipEndNow-&gt;colType != 0)</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :         pT2endDip = max( pT2sel, pT2min );</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :       else if (abs(dipEndNow-&gt;weakType) != 0)</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :         pT2endDip = max( pT2sel, pT2weakCut);</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :       else if (abs(dipEndNow-&gt;chgType) != 3 &amp;&amp; dipEndNow-&gt;chgType != 0)</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :         pT2endDip = max( pT2sel, pT2minChgQ );</span>
<span class="lineNum">     472 </span>            :       else
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :         pT2endDip = max( pT2sel, pT2minChgL );</span>
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span>            :       // Find properties of dipole and radiating dipole end.
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :       sideA        = ( abs(dipEndNow-&gt;side) == 1 );</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :       BeamParticle&amp; beamNow = (sideA) ? *beamAPtr : *beamBPtr;</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :       BeamParticle&amp; beamRec = (sideA) ? *beamBPtr : *beamAPtr;</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :       iNow         = beamNow[iSysNow].iPos();</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :       iRec         = beamRec[iSysNow].iPos();</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :       idDaughter   = beamNow[iSysNow].id();</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :       xDaughter    = beamNow[iSysNow].x();</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :       x1Now        = (sideA) ? xDaughter : beamRec[iSysNow].x();</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :       x2Now        = (sideA) ? beamRec[iSysNow].x() : xDaughter;</span>
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            :       // Note dipole mass correction when recoiler is a rescatter.
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :       m2Rec        = (dipEndNow-&gt;normalRecoil) ? 0. : event[iRec].m2();</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :       m2Dip        = x1Now * x2Now * sCM + m2Rec;</span>
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span>            :       // Now do evolution in pT2, for QCD, QED or weak.
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :       if (pT2begDip &gt; pT2endDip) {</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :         if (dipEndNow-&gt;colType != 0)       pT2nextQCD( pT2begDip, pT2endDip);</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :         else if (dipEndNow-&gt;chgType != 0 || idDaughter == 22)</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :           pT2nextQED( pT2begDip, pT2endDip);</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :         else if (dipEndNow-&gt;weakType != 0) pT2nextWeak( pT2begDip, pT2endDip);</span>
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span>            :         // Update if found larger pT than current maximum.
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :         if (dipEndNow-&gt;pT2 &gt; pT2sel) {</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :           pT2sel    = dipEndNow-&gt;pT2;</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :           iDipSel   = iDipNow;</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :           iSysSel   = iSysNow;</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :           dipEndSel = dipEndNow;</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     504 </span>            :       }
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     506 </span>            :   // End loop over dipole ends.
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span>            :   // Return nonvanishing value if found pT is bigger than already found.
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :   return (dipEndSel == 0) ? 0. : sqrt(pT2sel);</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     512 </span>            : 
<span class="lineNum">     513 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     514 </span>            : 
<a name="515"><span class="lineNum">     515 </span>            : // Evolve a QCD dipole end.</a>
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span>            : void SpaceShower::pT2nextQCD( double pT2begDip, double pT2endDip) {
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span>            :   // Some properties and kinematical starting values.
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :   BeamParticle&amp; beam = (sideA) ? *beamAPtr : *beamBPtr;</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :   bool   isGluon     = (idDaughter == 21);</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :   bool   isValence   = beam[iSysNow].isValence();</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :   int    MEtype      = dipEndNow-&gt;MEtype;</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :   double pT2         = pT2begDip;</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :   double xMaxAbs     = beam.xMax(iSysNow);</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :   double zMinAbs     = xDaughter / xMaxAbs;</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :   if (xMaxAbs &lt; 0.) {</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :     infoPtr-&gt;errorMsg(&quot;Warning in SpaceShower::pT2nextQCD: &quot;</span>
<span class="lineNum">     529 </span>            :     &quot;xMaxAbs negative&quot;);
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     531 </span>            :   }
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span>            :   // Starting values for handling of massive quarks (c/b), if any.
<span class="lineNum">     534 </span>            :   double idMassive   = 0;
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :   if ( abs(idDaughter) == 4 ) idMassive = 4;</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :   if ( abs(idDaughter) == 5 ) idMassive = 5;</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :   bool   isMassive   = (idMassive &gt; 0);</span>
<span class="lineNum">     538 </span>            :   double m2Massive   = 0.;
<span class="lineNum">     539 </span>            :   double mRatio      = 0.;
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :   double zMaxMassive = 1.;</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :   double m2Threshold = pT2;</span>
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span>            :   // Evolution below scale of massive quark or at large x is impossible.
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :   if (isMassive) {</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :     m2Massive = (idMassive == 4) ? m2c : m2b;</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :     if (pT2 &lt; HEAVYPT2EVOL * m2Massive) return;</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :     mRatio = sqrt( m2Massive / m2Dip );</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :     zMaxMassive = (1. -  mRatio) / ( 1. +  mRatio * (1. -  mRatio) );</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :     if (xDaughter &gt; HEAVYXEVOL * zMaxMassive * xMaxAbs) return;</span>
<span class="lineNum">     550 </span>            : 
<span class="lineNum">     551 </span>            :     // Find threshold scale below which only g -&gt; Q + Qbar will be allowed.
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :     m2Threshold = (idMassive == 4) ? min( pT2, CTHRESHOLD * m2c)</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :       : min( pT2, BTHRESHOLD * m2b);</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span>            :   // Variables used inside evolution loop. (Mainly dummy starting values.)
<span class="lineNum">     557 </span>            :   int    nFlavour       = 3;
<span class="lineNum">     558 </span>            :   double b0             = 4.5;
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :   double Lambda2        = Lambda3flav2;</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :   double pT2minNow      = pT2endDip;</span>
<span class="lineNum">     561 </span>            :   int    idMother       = 0;
<span class="lineNum">     562 </span>            :   int    idSister       = 0;
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :   double z              = 0.;</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :   double zMaxAbs        = 0.;</span>
<span class="lineNum">     565 </span>            :   double zRootMax       = 0.;
<span class="lineNum">     566 </span>            :   double zRootMin       = 0.;
<span class="lineNum">     567 </span>            :   double g2gInt         = 0.;
<span class="lineNum">     568 </span>            :   double q2gInt         = 0.;
<span class="lineNum">     569 </span>            :   double q2qInt         = 0.;
<span class="lineNum">     570 </span>            :   double g2qInt         = 0.;
<span class="lineNum">     571 </span>            :   double g2Qenhance     = 0.;
<span class="lineNum">     572 </span>            :   double xPDFdaughter   = 0.;
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :   double xPDFmother[21] = {0.};</span>
<span class="lineNum">     574 </span>            :   double xPDFgMother    = 0.;
<span class="lineNum">     575 </span>            :   double xPDFmotherSum  = 0.;
<span class="lineNum">     576 </span>            :   double kernelPDF      = 0.;
<span class="lineNum">     577 </span>            :   double xMother        = 0.;
<span class="lineNum">     578 </span>            :   double wt             = 0.;
<span class="lineNum">     579 </span>            :   double Q2             = 0.;
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :   double mSister        = 0.;</span>
<span class="lineNum">     581 </span>            :   double m2Sister       = 0.;
<span class="lineNum">     582 </span>            :   double pT2corr        = 0.;
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :   double pT2PDF         = pT2;</span>
<span class="lineNum">     584 </span>            :   bool   needNewPDF     = true;
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span>            :   // Begin evolution loop towards smaller pT values.
<span class="lineNum">     587 </span>            :   int    loopTinyPDFdau = 0;
<span class="lineNum">     588 </span>            :   bool   hasTinyPDFdau  = false;
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :   do {</span>
<span class="lineNum">     590 </span>            :     wt = 0.;
<span class="lineNum">     591 </span>            : 
<span class="lineNum">     592 </span>            :     // Bad sign if repeated looping with small daughter PDF, so fail.
<span class="lineNum">     593 </span>            :     // (Example: if all PDF's = 0 below Q_0, except for c/b companion.)
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :     if (hasTinyPDFdau) ++loopTinyPDFdau;</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :     if (loopTinyPDFdau &gt; MAXLOOPTINYPDF) {</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :       infoPtr-&gt;errorMsg(&quot;Warning in SpaceShower::pT2nextQCD: &quot;</span>
<span class="lineNum">     597 </span>            :       &quot;small daughter PDF&quot;);
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     599 </span>            :     }
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span>            :     // Initialize integrals of splitting kernels and evaluate parton
<span class="lineNum">     602 </span>            :     // densities at the beginning. Reinitialize after long evolution
<span class="lineNum">     603 </span>            :     // in pT2 or when crossing c and b flavour thresholds.
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :     if (needNewPDF || pT2 &lt; EVALPDFSTEP * pT2PDF) {</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :       pT2PDF        = pT2;</span>
<span class="lineNum">     606 </span>            :       hasTinyPDFdau = false;
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span>            :       // Determine overestimated z range; switch at c and b masses.
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :       if (pT2 &gt; m2b) {</span>
<span class="lineNum">     610 </span>            :         nFlavour  = 5;
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :         pT2minNow = max( m2b, pT2endDip);</span>
<span class="lineNum">     612 </span>            :         b0        = 23./6.;
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :         Lambda2   = Lambda5flav2;</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :       } else if (pT2 &gt; m2c) {</span>
<span class="lineNum">     615 </span>            :         nFlavour  = 4;
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :         pT2minNow = max( m2c, pT2endDip);</span>
<span class="lineNum">     617 </span>            :         b0        = 25./6.;
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :         Lambda2   = Lambda4flav2;</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :       } else {</span>
<span class="lineNum">     620 </span>            :         nFlavour  = 3;
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :         pT2minNow = pT2endDip;</span>
<span class="lineNum">     622 </span>            :         b0        = 27./6.;
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :         Lambda2   = Lambda3flav2;</span>
<span class="lineNum">     624 </span>            :       }
<span class="lineNum">     625 </span>            :       // A change of renormalization scale expressed by a change of Lambda.
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :       Lambda2    /= renormMultFac;</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :       zMaxAbs     = 1. - 0.5 * (pT2minNow / m2Dip) *</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :         ( sqrt( 1. + 4. * m2Dip / pT2minNow ) - 1. );</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :       if (isMassive) zMaxAbs = min( zMaxAbs, zMaxMassive);</span>
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span>            :       // Go to another z range with lower mass scale if current is closed.
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :       if (zMinAbs &gt; zMaxAbs) {</span>
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :         if (nFlavour == 3 || (idMassive == 4 &amp;&amp; nFlavour == 4)</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :           || idMassive == 5) return;</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :         pT2 = (nFlavour == 4) ? m2c : m2b;</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     637 </span>            :       }
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span>            :       // Parton density of daughter at current scale.
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :       pdfScale2 = (useFixedFacScale) ? fixedFacScale2 : factorMultFac * pT2;</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :       xPDFdaughter = beam.xfISR(iSysNow, idDaughter, xDaughter, pdfScale2);</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :       if (xPDFdaughter &lt; TINYPDF) {</span>
<span class="lineNum">     643 </span>            :         xPDFdaughter  = TINYPDF;
<span class="lineNum">     644 </span>            :         hasTinyPDFdau = true;
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span>            :       // Integrals of splitting kernels for gluons: g -&gt; g, q -&gt; g.
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :       if (isGluon) {</span>
<span class="lineNum">     649 </span>            :         g2gInt = HEADROOMG2G * 6.
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :           * log(zMaxAbs * (1.-zMinAbs) / (zMinAbs * (1.-zMaxAbs)));</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :         if (doMEcorrections) g2gInt *= calcMEmax(MEtype, 21, 21);</span>
<span class="lineNum">     652 </span>            :         q2gInt = HEADROOMQ2G * (16./3.)
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :           * (1./sqrt(zMinAbs) - 1./sqrt(zMaxAbs));</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :         if (doMEcorrections) q2gInt *= calcMEmax(MEtype, 1, 21);</span>
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span>            :         // Parton density of potential quark mothers to a g.
<span class="lineNum">     657 </span>            :         xPDFmotherSum = 0.;
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :         for (int i = -nQuarkIn; i &lt;= nQuarkIn; ++i) {</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :           if (i == 0) {</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :             xPDFmother[10] = 0.;</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :           } else {</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :             xPDFmother[i+10] = beam.xfISR(iSysNow, i, xDaughter, pdfScale2);</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :             xPDFmotherSum += xPDFmother[i+10];</span>
<span class="lineNum">     664 </span>            :           }
<span class="lineNum">     665 </span>            :         }
<span class="lineNum">     666 </span>            : 
<span class="lineNum">     667 </span>            :         // Total QCD evolution coefficient for a gluon.
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :         kernelPDF = g2gInt + q2gInt * xPDFmotherSum / xPDFdaughter;</span>
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span>            :       // For valence quark only need consider q -&gt; q g branchings.
<span class="lineNum">     671 </span>            :       // Introduce an extra factor sqrt(z) to smooth bumps.
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :       } else if (isValence) {</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :         zRootMin = (1. + sqrt(zMinAbs)) / (1. - sqrt(zMinAbs));</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :         zRootMax = (1. + sqrt(zMaxAbs)) / (1. - sqrt(zMaxAbs));</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :         q2qInt = (8./3.) * log( zRootMax / zRootMin );</span>
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :         if (doMEcorrections) q2qInt *= calcMEmax(MEtype, 1, 1);</span>
<span class="lineNum">     677 </span>            :         kernelPDF = q2qInt;
<span class="lineNum">     678 </span>            : 
<span class="lineNum">     679 </span>            :       // Integrals of splitting kernels for quarks: q -&gt; q, g -&gt; q.
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :       } else {</span>
<span class="lineNum">     681 </span>            :         q2qInt = HEADROOMQ2Q * (8./3.)
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :           * log( (1. - zMinAbs) / (1. - zMaxAbs) );</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :         if (doMEcorrections) q2qInt *= calcMEmax(MEtype, 1, 1);</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :         g2qInt = HEADROOMG2Q * 0.5 * (zMaxAbs - zMinAbs);</span>
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :         if (doMEcorrections) g2qInt *= calcMEmax(MEtype, 21, 1);</span>
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span>            :         // Increase estimated upper weight for g -&gt; Q + Qbar.
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :         if (isMassive) {</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :           if (alphaSorder == 0) g2Qenhance = log(pT2/m2Massive)</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :             / log(m2Threshold/m2Massive);</span>
<span class="lineNum">     691 </span>            :           else {
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :             double m2log = log( m2Massive / Lambda2);</span>
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :             g2Qenhance = log( log(pT2/Lambda2) / m2log )</span>
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :               / log( log(m2Threshold/Lambda2) / m2log );</span>
<span class="lineNum">     695 </span>            :           }
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :           g2qInt *= g2Qenhance;</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span>            :         // Parton density of a potential gluon mother to a q.
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :         xPDFgMother = beam.xfISR(iSysNow, 21, xDaughter, pdfScale2);</span>
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span>            :         // Total QCD evolution coefficient for a quark.
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :         kernelPDF = q2qInt + g2qInt * xPDFgMother / xPDFdaughter;</span>
<span class="lineNum">     704 </span>            :       }
<span class="lineNum">     705 </span>            : 
<span class="lineNum">     706 </span>            :       // End evaluation of splitting kernels and parton densities.
<span class="lineNum">     707 </span>            :       needNewPDF = false;
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :     if (kernelPDF &lt; TINYKERNELPDF) return;</span>
<span class="lineNum">     710 </span>            : 
<span class="lineNum">     711 </span>            :     // Pick pT2 (in overestimated z range), for one of three different cases.
<span class="lineNum">     712 </span>            :     // Assume form alphas(pT0^2 + pT^2) * dpT^2/(pT0^2 + pT^2).
<span class="lineNum">     713 </span>            :     double Q2alphaS;
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span>            :     // Fixed alpha_strong.
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :     if (alphaSorder == 0) {</span>
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :       pT2 = (pT2 + pT20) * pow( rndmPtr-&gt;flat(),</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :         1. / (alphaS2pi * kernelPDF)) - pT20;</span>
<span class="lineNum">     719 </span>            : 
<span class="lineNum">     720 </span>            :     // First-order alpha_strong.
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :     } else if (alphaSorder == 1) {</span>
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :       pT2 = Lambda2 * pow( (pT2 + pT20) / Lambda2,</span>
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :         pow(rndmPtr-&gt;flat(), b0 / kernelPDF) ) - pT20;</span>
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span>            :     // For second order reject by second term in alpha_strong expression.
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">     727 </span>            :       do {
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :         pT2 = Lambda2 * pow( (pT2 + pT20) / Lambda2,</span>
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :           pow(rndmPtr-&gt;flat(), b0 / kernelPDF) ) - pT20;</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :         Q2alphaS = renormMultFac * max( pT2 + pT20,</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :           pow2(LAMBDA3MARGIN) * Lambda3flav2);</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :       } while (alphaS.alphaS2OrdCorr(Q2alphaS) &lt; rndmPtr-&gt;flat()</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :         &amp;&amp; pT2 &gt; pT2minNow);</span>
<span class="lineNum">     734 </span>            :     }
<span class="lineNum">     735 </span>            : 
<span class="lineNum">     736 </span>            :     // Check for pT2 values that prompt special action.
<span class="lineNum">     737 </span>            : 
<span class="lineNum">     738 </span>            :     // If fallen into b threshold region, force g -&gt; b + bbar.
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :     if (idMassive == 5 &amp;&amp; pT2 &lt; m2Threshold) {</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :       pT2nearQCDthreshold( beam, m2Massive, m2Threshold, xMaxAbs,</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :         zMinAbs, zMaxMassive );</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     743 </span>            : 
<span class="lineNum">     744 </span>            :     // If crossed b threshold, continue evolution from this threshold.
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :     } else if (nFlavour == 5 &amp;&amp; pT2 &lt; m2b) {</span>
<span class="lineNum">     746 </span>            :       needNewPDF = true;
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :       pT2 = m2b;</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">     749 </span>            : 
<span class="lineNum">     750 </span>            :     // If fallen into c threshold region, force g -&gt; c + cbar.
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :     } else if (idMassive == 4 &amp;&amp; pT2 &lt; m2Threshold) {</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :       pT2nearQCDthreshold( beam, m2Massive, m2Threshold, xMaxAbs,</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :         zMinAbs, zMaxMassive );</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     755 </span>            : 
<span class="lineNum">     756 </span>            :     // If crossed c threshold, continue evolution from this threshold.
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :     } else if (nFlavour == 4 &amp;&amp; pT2 &lt; m2c) {</span>
<span class="lineNum">     758 </span>            :       needNewPDF = true;
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :       pT2 = m2c;</span>
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">     761 </span>            : 
<span class="lineNum">     762 </span>            :     // Abort evolution if below cutoff scale, or below another branching.
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :     } else if (pT2 &lt; pT2endDip) return;</span>
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span>            :     // Select z value of branching to g, and corrective weight.
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :     if (isGluon) {</span>
<span class="lineNum">     767 </span>            :       // g -&gt; g (+ g).
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :       if (rndmPtr-&gt;flat() * kernelPDF &lt; g2gInt) {</span>
<span class="lineNum">     769 </span>            :         idMother = 21;
<span class="lineNum">     770 </span>            :         idSister = 21;
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :         z = 1. / ( 1. + ((1. - zMinAbs) / zMinAbs) * pow( (zMinAbs *</span>
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :           (1. - zMaxAbs)) / (zMaxAbs * (1. - zMinAbs)), rndmPtr-&gt;flat() ) );</span>
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :         wt = pow2( 1. - z * (1. - z));</span>
<span class="lineNum">     774 </span>            :         // Account for headroom factor used to enhance trial probability
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :         wt /= HEADROOMG2G;</span>
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :       } else {</span>
<span class="lineNum">     777 </span>            :       // q -&gt; g (+ q): also select flavour.
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :         double temp = xPDFmotherSum * rndmPtr-&gt;flat();</span>
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :         idMother = -nQuarkIn - 1;</span>
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :         do { temp -= xPDFmother[(++idMother) + 10]; }</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :         while (temp &gt; 0. &amp;&amp; idMother &lt; nQuarkIn);</span>
<span class="lineNum">     782 </span>            :         idSister = idMother;
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :         z = (zMinAbs * zMaxAbs) / pow2( sqrt(zMinAbs) + rndmPtr-&gt;flat()</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :           * ( sqrt(zMaxAbs)- sqrt(zMinAbs) ));</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :         wt = 0.5 * (1. + pow2(1. - z)) * sqrt(z)</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :           * xPDFdaughter / xPDFmother[idMother + 10];</span>
<span class="lineNum">     787 </span>            :         // Account for headroom factor used to enhance trial probability
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :         wt /= HEADROOMQ2G;</span>
<span class="lineNum">     789 </span>            :       }
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span>            :     // Select z value of branching to q, and corrective weight.
<span class="lineNum">     792 </span>            :     // Include massive kernel corrections for c and b quarks.
<span class="lineNum">     793 </span>            :     } else {
<span class="lineNum">     794 </span>            :       // q -&gt; q (+ g).
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :       if (isValence || rndmPtr-&gt;flat() * kernelPDF &lt; q2qInt) {</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :         idMother = idDaughter;</span>
<span class="lineNum">     797 </span>            :         idSister = 21;
<span class="lineNum">     798 </span>            :         // Valence more peaked at large z.
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :         if (isValence) {</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :           double zTmp = zRootMin * pow(zRootMax / zRootMin, rndmPtr-&gt;flat() );</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :           z = pow2( (1. - zTmp) / (1. + zTmp) );</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :           z = 1. - (1. - zMinAbs) * pow( (1. - zMaxAbs) / (1. - zMinAbs),</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :             rndmPtr-&gt;flat() );</span>
<span class="lineNum">     805 </span>            :         }
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :         if (!isMassive) {</span>
<span class="lineNum">     807 </span>            :           wt = 0.5 * (1. + pow2(z));
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">     809 </span>            :         //?? Bug?? should be 2 more for massive part??
<span class="lineNum">     810 </span>            :         //  wt = 0.5 * (1. + pow2(z) - z * pow2(1.-z) * m2Massive / pT2);
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :           wt = 0.5 * (1. + pow2(z)) - z * pow2(1.-z) * m2Massive / pT2;</span>
<span class="lineNum">     812 </span>            :         }
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :         if (isValence) wt *= sqrt(z);</span>
<span class="lineNum">     814 </span>            :         // Account for headroom factor for sea quarks
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :         else wt /= HEADROOMQ2Q;</span>
<span class="lineNum">     816 </span>            :       // g -&gt; q (+ qbar).
<span class="lineNum">     817 </span>            :       } else {
<span class="lineNum">     818 </span>            :         idMother = 21;
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :         idSister = - idDaughter;</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :         z = zMinAbs + rndmPtr-&gt;flat() * (zMaxAbs - zMinAbs);</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :         if (!isMassive) {</span>
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :           wt = (pow2(z) + pow2(1.-z)) * xPDFdaughter / xPDFgMother;</span>
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :           wt = (pow2(z) + pow2(1.-z) + 2. * z * (1.-z) * m2Massive / pT2)</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :             * xPDFdaughter / (xPDFgMother * g2Qenhance) ;</span>
<span class="lineNum">     826 </span>            :         }
<span class="lineNum">     827 </span>            :         // Account for headroom factor for gluons
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :         wt /= HEADROOMG2Q;</span>
<span class="lineNum">     829 </span>            :       }
<span class="lineNum">     830 </span>            :     }
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span>            :     // Derive Q2 and x of mother from pT2 and z.
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :     Q2      = pT2 / (1. - z);</span>
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :     xMother = xDaughter / z;</span>
<span class="lineNum">     835 </span>            :     // Correction to x for massive recoiler from rescattering.
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :     if (!dipEndNow-&gt;normalRecoil) {</span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :       if (sideA) xMother += (m2Rec / (x2Now * sCM)) * (1. / z - 1.);</span>
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :       else       xMother += (m2Rec / (x1Now * sCM)) * (1. / z - 1.);</span>
<span class="lineNum">     839 </span>            :     }
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :     if (xMother &gt; xMaxAbs) { wt = 0.; continue; }</span>
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span>            :     // Forbidden emission if outside allowed z range for given pT2.
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :     mSister = particleDataPtr-&gt;m0(idSister);</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :     m2Sister = pow2(mSister);</span>
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :     pT2corr = Q2 - z * (m2Dip + Q2) * (Q2 + m2Sister) / m2Dip;</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :     if (pT2corr &lt; TINYPT2) { wt = 0.; continue; }</span>
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span>            :     // Optionally veto emissions not ordered in rapidity (= angle).
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :     if ( doRapidityOrder &amp;&amp; dipEndNow-&gt;nBranch &gt; 0</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :       &amp;&amp; pT2 &gt; pow2( (1. - z) / (z * (1. - dipEndNow-&gt;zOld)) )</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :       * dipEndNow-&gt;pT2Old ) { wt = 0.; continue; }</span>
<span class="lineNum">     852 </span>            : 
<span class="lineNum">     853 </span>            :     // If creating heavy quark by Q -&gt; g + Q then next need g -&gt; Q + Qbar.
<span class="lineNum">     854 </span>            :     // So minimum total mass2 is 4 * m2Sister, but use more to be safe.
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :     if ( isGluon &amp;&amp; ( abs(idMother) == 4 || abs(idMother) == 5 )) {</span>
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :       double m2QQsister =  EXTRASPACEQ * 4. * m2Sister;</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :       double pT2QQcorr = Q2 - z * (m2Dip + Q2) * (Q2 + m2QQsister) / m2Dip;</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :       if (pT2QQcorr &lt; TINYPT2) { wt = 0.; continue; }</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span>            :     // Evaluation of ME correction.
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :     if (doMEcorrections) wt *= calcMEcorr(MEtype, idMother, idDaughter,</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :       m2Dip, z, Q2, m2Sister) / calcMEmax(MEtype, idMother, idDaughter);</span>
<span class="lineNum">     864 </span>            : 
<span class="lineNum">     865 </span>            :     // Optional dampening of large pT values in first radiation.
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :     if (dopTdamp &amp;&amp; iSysNow == 0 &amp;&amp; MEtype == 0 &amp;&amp; nRad == 0)</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :       wt *= pT2damp / (pT2 + pT2damp);</span>
<span class="lineNum">     868 </span>            : 
<span class="lineNum">     869 </span>            :     // Idea suggested by Gosta Gustafson: increased screening in events
<span class="lineNum">     870 </span>            :     // with large activity can be simulated by pT0_eff = sqrt(n) * pT0.
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :     if (enhanceScreening == 2) {</span>
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :       int nSysNow     = infoPtr-&gt;nMPI() + infoPtr-&gt;nISR() + 1;</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :       double WTscreen = pow2( (pT2 + pT20) / (pT2 + nSysNow * pT20) );</span>
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :       wt             *= WTscreen;</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     876 </span>            : 
<span class="lineNum">     877 </span>            :     // Evaluation of new daughter and mother PDF's.
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :     pdfScale2 = (useFixedFacScale) ? fixedFacScale2 : factorMultFac * pT2;</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :     double xPDFdaughterNew = max ( TINYPDF,</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :       beam.xfISR(iSysNow, idDaughter, xDaughter, pdfScale2) );</span>
<span class="lineNum">     881 </span>            :     double xPDFmotherNew =
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :       beam.xfISR(iSysNow, idMother, xMother, pdfScale2);</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :     wt *= xPDFmotherNew / xPDFdaughterNew;</span>
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span>            :     // Check that valence step does not cause problem.
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :     if (wt &gt; 1. &amp;&amp; pT2 &gt; PT2MINWARN) infoPtr-&gt;errorMsg(&quot;Warning in &quot;</span>
<span class="lineNum">     887 </span>            :       &quot;SpaceShower::pT2nextQCD: weight above unity&quot;);
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span>            :   // Iterate until acceptable pT (or have fallen below pTmin).
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :   } while (wt &lt; rndmPtr-&gt;flat()) ;</span>
<span class="lineNum">     891 </span>            : 
<span class="lineNum">     892 </span>            :   // Save values for (so far) acceptable branching.
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :   dipEndNow-&gt;store( idDaughter,idMother, idSister, x1Now, x2Now, m2Dip,</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :     pT2, z, xMother, Q2, mSister, m2Sister, pT2corr);</span>
<span class="lineNum">     895 </span>            : 
<span class="lineNum">     896 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     897 </span>            : 
<span class="lineNum">     898 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     899 </span>            : 
<span class="lineNum">     900 </span>            : // Evolve a QCD dipole end near threshold, with g -&gt; Q + Qbar enforced.
<span class="lineNum">     901 </span>            : // Note: No explicit Sudakov factor formalism here. Instead use that
<span class="lineNum">     902 </span>            : // df_Q(x, pT2) = (alpha_s/2pi) * (dT2/pT2) * ((gluon) * (splitting)).
<a name="903"><span class="lineNum">     903 </span>            : // This implies that effects of Q -&gt; Q + g are neglected in this range.</a>
<span class="lineNum">     904 </span>            : 
<span class="lineNum">     905 </span>            : void SpaceShower::pT2nearQCDthreshold( BeamParticle&amp; beam,
<span class="lineNum">     906 </span>            :   double m2Massive, double m2Threshold, double xMaxAbs,
<span class="lineNum">     907 </span>            :   double zMinAbs, double zMaxMassive) {
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span>            :   // Initial values, to be used in kinematics and weighting.
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :   double Lambda2       = (abs(idDaughter) == 4) ? Lambda4flav2 : Lambda5flav2;</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :   Lambda2             /= renormMultFac;</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :   double logM2Lambda2  = (alphaSorder &gt; 0) ? log( m2Massive / Lambda2 ) : 1.;</span>
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :   pdfScale2 = (useFixedFacScale) ? fixedFacScale2</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :     : factorMultFac * m2Threshold;</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :   double xPDFmotherOld = beam.xfISR(iSysNow, 21, xDaughter, pdfScale2);</span>
<span class="lineNum">     916 </span>            : 
<span class="lineNum">     917 </span>            :   // Variables used inside evolution loop. (Mainly dummy start values.)
<span class="lineNum">     918 </span>            :   int    loop    = 0;
<span class="lineNum">     919 </span>            :   double wt      = 0.;
<span class="lineNum">     920 </span>            :   double pT2     = 0.;
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :   double z       = 0.;</span>
<span class="lineNum">     922 </span>            :   double Q2      = 0.;
<span class="lineNum">     923 </span>            :   double pT2corr = 0.;
<span class="lineNum">     924 </span>            :   double xMother = 0.;
<span class="lineNum">     925 </span>            : 
<span class="lineNum">     926 </span>            :   // Begin loop over tries to find acceptable g -&gt; Q + Qbar branching.
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :   do {</span>
<span class="lineNum">     928 </span>            :     wt = 0.;
<span class="lineNum">     929 </span>            : 
<span class="lineNum">     930 </span>            :     // Check that not caught in infinite loop with impossible kinematics.
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :     if (++loop &gt; 100) {</span>
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :       infoPtr-&gt;errorMsg(&quot;Error in SpaceShower::pT2nearQCDthreshold: &quot;</span>
<span class="lineNum">     933 </span>            :         &quot;stuck in loop&quot;);
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     935 </span>            :     }
<span class="lineNum">     936 </span>            : 
<span class="lineNum">     937 </span>            :     // Pick dpT2/pT2 in range [m2Massive,thresholdRatio * m2Massive].
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :     pT2 = m2Massive * pow( m2Threshold / m2Massive, rndmPtr-&gt;flat() );</span>
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span>            :     // Pick z flat in allowed range.
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :     z = zMinAbs + rndmPtr-&gt;flat() * (zMaxMassive - zMinAbs);</span>
<span class="lineNum">     942 </span>            : 
<span class="lineNum">     943 </span>            :     // Check that kinematically possible choice.
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :     Q2 = pT2 / (1.-z) - m2Massive;</span>
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :     pT2corr = Q2 - z * (m2Dip + Q2) * (Q2 + m2Massive) / m2Dip;</span>
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :     if (pT2corr &lt; TINYPT2) continue;</span>
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span>            :     // Correction factor for running alpha_s. (Only first order for now.)
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :     wt = (alphaSorder &gt; 0) ? logM2Lambda2 / log( pT2 / Lambda2 ) : 1.;</span>
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span>            :     // Correction factor for splitting kernel.
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :     wt *= pow2(z) + pow2(1.-z) + 2. * z * (1.-z) * m2Massive / pT2;</span>
<span class="lineNum">     953 </span>            : 
<span class="lineNum">     954 </span>            :     // x, including correction for massive recoiler from rescattering.
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :     xMother = xDaughter / z;</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :     if (!dipEndNow-&gt;normalRecoil) {</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :       if (sideA) xMother += (m2Rec / (x2Now * sCM)) * (1. / z - 1.);</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :       else       xMother += (m2Rec / (x1Now * sCM)) * (1. / z - 1.);</span>
<span class="lineNum">     959 </span>            :     }
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :     if (xMother &gt; xMaxAbs) { wt = 0.; continue; }</span>
<span class="lineNum">     961 </span>            : 
<span class="lineNum">     962 </span>            :     // Correction factor for gluon density.
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :     pdfScale2 = (useFixedFacScale) ? fixedFacScale2 : factorMultFac * pT2;</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :     double xPDFmotherNew = beam.xfISR(iSysNow, 21, xMother, pdfScale2);</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :     wt *= xPDFmotherNew / xPDFmotherOld;</span>
<span class="lineNum">     966 </span>            : 
<span class="lineNum">     967 </span>            :   // Iterate until acceptable pT and z.
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :   } while (wt &lt; rndmPtr-&gt;flat()) ;</span>
<span class="lineNum">     969 </span>            : 
<span class="lineNum">     970 </span>            :   // Save values for (so far) acceptable branching.
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :   double mSister = (abs(idDaughter) == 4) ? mc : mb;</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :   dipEndNow-&gt;store( idDaughter, 21, -idDaughter, x1Now, x2Now, m2Dip,</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :     pT2, z, xMother, Q2, mSister, pow2(mSister), pT2corr);</span>
<span class="lineNum">     974 </span>            : 
<span class="lineNum">     975 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     978 </span>            : 
<a name="979"><span class="lineNum">     979 </span>            : // Evolve a QED dipole end.</a>
<span class="lineNum">     980 </span>            : 
<span class="lineNum">     981 </span>            : void SpaceShower::pT2nextQED( double pT2begDip, double pT2endDip) {
<span class="lineNum">     982 </span>            : 
<span class="lineNum">     983 </span>            :   // Type of dipole and starting values.
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :   BeamParticle&amp; beam  = (sideA) ? *beamAPtr : *beamBPtr;</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :   bool   isLeptonBeam = beam.isLepton();</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :   int    MEtype       = dipEndNow-&gt;MEtype;</span>
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :   bool   isPhoton     = (idDaughter == 22);</span>
<span class="lineNum">     988 </span>            :   double pT2          = pT2begDip;
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :   double m2Lepton     = (isLeptonBeam) ? pow2(beam.m()) : 0.;</span>
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :   if (isLeptonBeam &amp;&amp; pT2begDip &lt; m2Lepton) return;</span>
<span class="lineNum">     991 </span>            : 
<span class="lineNum">     992 </span>            :   // Currently no f -&gt; gamma branching implemented for lepton beams
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :   if (isPhoton &amp;&amp; isLeptonBeam) return;</span>
<span class="lineNum">     994 </span>            : 
<span class="lineNum">     995 </span>            :   // alpha_em at maximum scale provides upper estimate.
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :   double alphaEMmax  = alphaEM.alphaEM(renormMultFac * pT2begDip);</span>
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :   double alphaEM2pi  = alphaEMmax / (2. * M_PI);</span>
<span class="lineNum">     998 </span>            : 
<span class="lineNum">     999 </span>            :   // Maximum x of mother implies minimum z = xDaughter / xMother.
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :   double xMaxAbs  = (isLeptonBeam) ? LEPTONXMAX : beam.xMax(iSysNow);</span>
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :   double zMinAbs  = xDaughter / xMaxAbs;</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :   if (xMaxAbs &lt; 0.) {</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :     infoPtr-&gt;errorMsg(&quot;Warning in SpaceShower::pT2nextQED: &quot;</span>
<span class="lineNum">    1004 </span>            :     &quot;xMaxAbs negative&quot;);
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1006 </span>            :   }
<span class="lineNum">    1007 </span>            : 
<span class="lineNum">    1008 </span>            :   // Maximum z from minimum pT and, for lepton, from minimum x_gamma.
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :   double zMaxAbs = 1. - 0.5 * (pT2endDip / m2Dip) *</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :     ( sqrt( 1. + 4. * m2Dip / pT2endDip ) - 1. );</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :   if (isLeptonBeam) {</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :     double zMaxLepton = xDaughter / (xDaughter + LEPTONXMIN);</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :     if (zMaxLepton &lt; zMaxAbs) zMaxAbs = zMaxLepton;</span>
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :   if (zMaxAbs &lt; zMinAbs) return;</span>
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span>            :   // Variables used inside evolution loop. (Mainly dummy start values.)
<span class="lineNum">    1018 </span>            :   int    idMother = 0;
<span class="lineNum">    1019 </span>            :   int    idSister = 22;
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :   double z        = 0.;</span>
<span class="lineNum">    1021 </span>            :   double xMother  = 0.;
<span class="lineNum">    1022 </span>            :   double wt       = 0.;
<span class="lineNum">    1023 </span>            :   double Q2       = 0.;
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :   double mSister  = 0.;</span>
<span class="lineNum">    1025 </span>            :   double m2Sister = 0.;
<span class="lineNum">    1026 </span>            :   double pT2corr  = 0.;
<span class="lineNum">    1027 </span>            : 
<span class="lineNum">    1028 </span>            :   // QED evolution of fermions
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :   if (!isPhoton) {</span>
<span class="lineNum">    1030 </span>            : 
<span class="lineNum">    1031 </span>            :     // Integrals of splitting kernels for fermions: f -&gt; f. Use 1 + z^2 &lt; 2.
<span class="lineNum">    1032 </span>            :     // Ansatz f(z) = 2 / (1 - z), with + 2 / (z - xDaughter) for lepton.
<span class="lineNum">    1033 </span>            :     double f2fInt  = 0.;
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :     double f2fIntA = 2. * log( (1. - zMinAbs) / (1. - zMaxAbs) );</span>
<span class="lineNum">    1035 </span>            :     double f2fIntB = 0.;
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :     if (isLeptonBeam) {</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :       f2fIntB      = 2. * log( (zMaxAbs - xDaughter) / (zMinAbs - xDaughter) );</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :       f2fInt       = f2fIntA + f2fIntB;</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :     } else f2fInt  = pow2(dipEndNow-&gt;chgType / 3.) * f2fIntA;</span>
<span class="lineNum">    1040 </span>            : 
<span class="lineNum">    1041 </span>            :     // Upper estimate for evolution equation, including fudge factor.
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :     if (doMEcorrections) f2fInt *= calcMEmax(MEtype, 1, 1);</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :     double kernelPDF = alphaEM2pi * f2fInt;</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :     double fudge = (isLeptonBeam) ? LEPTONFUDGE * log(m2Dip/m2Lepton) : 1.;</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :     kernelPDF *= fudge;</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :     if (kernelPDF &lt; TINYKERNELPDF) return;</span>
<span class="lineNum">    1047 </span>            : 
<span class="lineNum">    1048 </span>            :     // Begin evolution loop towards smaller pT values.
<span class="lineNum">    1049 </span>            :     do {
<span class="lineNum">    1050 </span>            : 
<span class="lineNum">    1051 </span>            :       // Pick pT2 (in overestimated z range).
<span class="lineNum">    1052 </span>            :       // For l -&gt; l gamma include extrafactor 1 / ln(pT2 / m2l) in evolution.
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :       double shift = pow(rndmPtr-&gt;flat(), 1. / kernelPDF);</span>
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :       if (isLeptonBeam) pT2 = m2Lepton * pow( pT2 / m2Lepton, shift);</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :       else              pT2 = pT2 * shift;</span>
<span class="lineNum">    1056 </span>            : 
<span class="lineNum">    1057 </span>            :       // Abort evolution if below cutoff scale, or below another branching.
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :       if (pT2 &lt; pT2endDip) return;</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :       if (isLeptonBeam &amp;&amp; pT2 &lt; LEPTONPT2MIN * m2Lepton) return;</span>
<span class="lineNum">    1060 </span>            : 
<span class="lineNum">    1061 </span>            :       // Select z value of branching f -&gt; f + gamma, and corrective weight.
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :       idMother = idDaughter;</span>
<span class="lineNum">    1063 </span>            :       wt = 1.;
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :       if (isLeptonBeam) {</span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :         if (f2fIntA &gt; rndmPtr-&gt;flat() * (f2fIntA + f2fIntB)) {</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :           z = 1. - (1. - zMinAbs)</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :             * pow( (1. - zMaxAbs) / (1. - zMinAbs), rndmPtr-&gt;flat() );</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :           z = xDaughter + (zMinAbs - xDaughter)</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :             * pow( (zMaxAbs - xDaughter) / (zMinAbs - xDaughter),</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :                   rndmPtr-&gt;flat() );</span>
<span class="lineNum">    1072 </span>            :         }
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :         wt *= (z - xDaughter) / (1. - xDaughter);</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :       } else {</span>
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :         z = 1. - (1. - zMinAbs)</span>
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :           * pow( (1. - zMaxAbs) / (1. - zMinAbs), rndmPtr-&gt;flat() );</span>
<span class="lineNum">    1077 </span>            :       }
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :       wt *= 0.5 * (1. + pow2(z));</span>
<span class="lineNum">    1079 </span>            : 
<span class="lineNum">    1080 </span>            :       // Derive Q2 and x of mother from pT2 and z.
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :       Q2      = pT2 / (1. - z);</span>
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :       xMother = xDaughter / z;</span>
<span class="lineNum">    1083 </span>            :       // Correction to x for massive recoiler from rescattering.
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :       if (!dipEndNow-&gt;normalRecoil) {</span>
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :         if (sideA) xMother += (m2Rec / (x2Now * sCM)) * (1. / z - 1.);</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :         else       xMother += (m2Rec / (x1Now * sCM)) * (1. / z - 1.);</span>
<span class="lineNum">    1087 </span>            :       }
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :       if (xMother &gt; xMaxAbs) { wt = 0.; continue; }</span>
<span class="lineNum">    1089 </span>            : 
<span class="lineNum">    1090 </span>            :       // Forbidden emission if outside allowed z range for given pT2.
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :       mSister  = 0.;</span>
<span class="lineNum">    1092 </span>            :       m2Sister = 0.;
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :       pT2corr  = Q2 - z * (m2Dip + Q2) * (Q2 + m2Sister) / m2Dip;</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :       if (pT2corr &lt; TINYPT2) { wt = 0.; continue; }</span>
<span class="lineNum">    1095 </span>            : 
<span class="lineNum">    1096 </span>            :       // Correct by ln(pT2 / m2l) and fudge factor.
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :       if (isLeptonBeam) wt *= log(pT2 / m2Lepton) / fudge;</span>
<span class="lineNum">    1098 </span>            : 
<span class="lineNum">    1099 </span>            :       // Evaluation of ME correction.
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :       if (doMEcorrections) wt *= calcMEcorr(MEtype, idMother, idDaughter,</span>
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :          m2Dip, z, Q2, m2Sister) / calcMEmax(MEtype, idMother, idDaughter);</span>
<span class="lineNum">    1102 </span>            : 
<span class="lineNum">    1103 </span>            :       // Extra QED correction for f fbar -&gt; W+- gamma. Debug??
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :       if (doMEcorrections &amp;&amp; MEtype == 1 &amp;&amp; idDaughter == idMother</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :         &amp;&amp; ( (iSysNow == 0 &amp;&amp; idResFirst  == 24)</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :           || (iSysNow == 1 &amp;&amp; idResSecond == 24) ) ) {</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :         double tHe  = -Q2;</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :         double uHe  = Q2 - m2Dip * (1. - z) / z;</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :         double chg1 = abs(dipEndNow-&gt;chgType / 3.);</span>
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :         double chg2 = 1. - chg1;</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :         wt *= pow2(chg1 * uHe - chg2 * tHe)</span>
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :           / ( (tHe + uHe) * (pow2(chg1) * uHe + pow2(chg2) * tHe) );</span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1114 </span>            : 
<span class="lineNum">    1115 </span>            :       // Optional dampening of large pT values in first radiation.
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :       if (dopTdamp &amp;&amp; iSysNow == 0 &amp;&amp; MEtype == 0 &amp;&amp; nRad == 0)</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :         wt *= pT2damp / (pT2 + pT2damp);</span>
<span class="lineNum">    1118 </span>            : 
<span class="lineNum">    1119 </span>            :       // Correct to current value of alpha_EM.
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :       double alphaEMnow = alphaEM.alphaEM(renormMultFac * pT2);</span>
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :       wt *= (alphaEMnow / alphaEMmax);</span>
<span class="lineNum">    1122 </span>            : 
<span class="lineNum">    1123 </span>            :       // Evaluation of new daughter and mother PDF's.
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :       pdfScale2 = (useFixedFacScale) ? fixedFacScale2 : factorMultFac * pT2;</span>
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :       double xPDFdaughterNew = max ( TINYPDF,</span>
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :         beam.xfISR(iSysNow, idDaughter, xDaughter, pdfScale2) );</span>
<span class="lineNum">    1127 </span>            :       double xPDFmotherNew   =
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :         beam.xfISR(iSysNow, idMother, xMother, pdfScale2);</span>
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :       wt *= xPDFmotherNew / xPDFdaughterNew;</span>
<span class="lineNum">    1130 </span>            : 
<span class="lineNum">    1131 </span>            :     // Iterate until acceptable pT (or have fallen below pTmin).
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :     } while (wt &lt; rndmPtr-&gt;flat()) ;</span>
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1134 </span>            : 
<span class="lineNum">    1135 </span>            :   // QED evolution of photons (so far only for hadron beams).
<span class="lineNum">    1136 </span>            :   else {
<span class="lineNum">    1137 </span>            : 
<span class="lineNum">    1138 </span>            :     // Initial values
<span class="lineNum">    1139 </span>            :     int    nFlavour       = 3;
<span class="lineNum">    1140 </span>            :     double kernelPDF      = 0.0;
<span class="lineNum">    1141 </span>            :     double xPDFdaughter   = 0.;
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :     double xPDFmother[21] = {0.};</span>
<span class="lineNum">    1143 </span>            :     double xPDFmotherSum  = 0.0;
<span class="lineNum">    1144 </span>            :     double pT2PDF         = pT2;
<span class="lineNum">    1145 </span>            :     double pT2minNow      = pT2endDip;
<span class="lineNum">    1146 </span>            :     bool   needNewPDF     = true;
<span class="lineNum">    1147 </span>            : 
<span class="lineNum">    1148 </span>            :     // Begin evolution loop towards smaller pT values.
<span class="lineNum">    1149 </span>            :     int    loopTinyPDFdau = 0;
<span class="lineNum">    1150 </span>            :     bool   hasTinyPDFdau  = false;
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :     do {</span>
<span class="lineNum">    1152 </span>            :       wt = 0.;
<span class="lineNum">    1153 </span>            : 
<span class="lineNum">    1154 </span>            :       // Bad sign if repeated looping with small daughter PDF, so fail.
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :       if (hasTinyPDFdau) ++loopTinyPDFdau;</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :       if (loopTinyPDFdau &gt; MAXLOOPTINYPDF) {</span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :         infoPtr-&gt;errorMsg(&quot;Warning in SpaceShower::pT2nextQED: &quot;</span>
<span class="lineNum">    1158 </span>            :                           &quot;small daughter PDF&quot;);
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1160 </span>            :       }
<span class="lineNum">    1161 </span>            : 
<span class="lineNum">    1162 </span>            :       // Initialize integrals of splitting kernels and evaluate parton
<span class="lineNum">    1163 </span>            :       // densities at the beginning. Reinitialize after long evolution
<span class="lineNum">    1164 </span>            :       // in pT2 or when crossing c and b flavour thresholds.
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :       if (needNewPDF || pT2 &lt; EVALPDFSTEP * pT2PDF) {</span>
<span class="lineNum">    1166 </span>            : 
<span class="lineNum">    1167 </span>            :         pT2PDF        = pT2;
<span class="lineNum">    1168 </span>            :         hasTinyPDFdau = false;
<span class="lineNum">    1169 </span>            : 
<span class="lineNum">    1170 </span>            :         // Determine overestimated z range; switch at c and b masses.
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :         if (pT2 &gt; m2b &amp;&amp; nQuarkIn &gt;= 5) {</span>
<span class="lineNum">    1172 </span>            :           nFlavour  = 5;
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :           pT2minNow = max( m2b, pT2endDip);</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :         } else if (pT2 &gt; m2c &amp;&amp; nQuarkIn &gt;= 4) {</span>
<span class="lineNum">    1175 </span>            :           nFlavour  = 4;
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 :           pT2minNow = max( m2c, pT2endDip);</span>
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">    1178 </span>            :           nFlavour  = 3;
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :           pT2minNow = pT2endDip;</span>
<span class="lineNum">    1180 </span>            :         }
<span class="lineNum">    1181 </span>            : 
<span class="lineNum">    1182 </span>            :         // Compute upper z limit
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :         zMaxAbs = 1. - 0.5 * (pT2minNow / m2Dip) *</span>
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :           ( sqrt( 1. + 4. * m2Dip / pT2minNow ) - 1. );</span>
<span class="lineNum">    1185 </span>            : 
<span class="lineNum">    1186 </span>            :         // Parton density of daughter at current scale.
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :         pdfScale2 = (useFixedFacScale) ? fixedFacScale2 : factorMultFac * pT2;</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :         xPDFdaughter = beam.xfISR(iSysNow, idDaughter, xDaughter, pdfScale2);</span>
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :         if (xPDFdaughter &lt; TINYPDF) {</span>
<span class="lineNum">    1190 </span>            :           xPDFdaughter  = TINYPDF;
<span class="lineNum">    1191 </span>            :           hasTinyPDFdau = true;
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1193 </span>            : 
<span class="lineNum">    1194 </span>            :         // Integral over f -&gt; gamma f splitting kernel.
<span class="lineNum">    1195 </span>            :         // Normalized so: 4/3 aS/2pi P(z) -&gt; eq^2 * aEM/2pi P(z).
<span class="lineNum">    1196 </span>            :         // (Charge-weighting happens below.)
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :         double q2gInt = 4. * (1./sqrt(zMinAbs) - 1./sqrt(zMaxAbs));</span>
<span class="lineNum">    1198 </span>            : 
<span class="lineNum">    1199 </span>            :         // Charge-weighted Parton density of potential quark mothers.
<span class="lineNum">    1200 </span>            :         xPDFmotherSum = 0.;
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :         for (int i = -nFlavour; i &lt;= nFlavour; ++i) {</span>
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :           if (i == 0) {</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :             xPDFmother[10] = 0.;</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :           } else {</span>
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 :             xPDFmother[i+10] = pow2((abs(i+1) % 2 + 1)/3.0)</span>
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :               * beam.xfISR(iSysNow, i, xDaughter, pdfScale2);</span>
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :             xPDFmotherSum += xPDFmother[i+10];</span>
<span class="lineNum">    1208 </span>            :           }
<span class="lineNum">    1209 </span>            :         }
<span class="lineNum">    1210 </span>            : 
<span class="lineNum">    1211 </span>            :         // Total QED evolution coefficient for a photon.
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :         kernelPDF = q2gInt * xPDFmotherSum / xPDFdaughter;</span>
<span class="lineNum">    1213 </span>            : 
<span class="lineNum">    1214 </span>            :         // End evaluation of splitting kernels and parton densities.
<span class="lineNum">    1215 </span>            :         needNewPDF = false;
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :       if (kernelPDF &lt; TINYKERNELPDF) return;</span>
<span class="lineNum">    1218 </span>            : 
<span class="lineNum">    1219 </span>            :       // Select pT2 for next trial branching
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 :       pT2 *= pow( rndmPtr-&gt;flat(), 1. / (alphaEM2pi * kernelPDF));</span>
<span class="lineNum">    1221 </span>            : 
<span class="lineNum">    1222 </span>            :       // If crossed b threshold, continue evolution from this threshold.
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :       if (nFlavour == 5 &amp;&amp; pT2 &lt; m2b) {</span>
<span class="lineNum">    1224 </span>            :         needNewPDF = true;
<span class="lineNum">    1225 </span>            :         pT2 = m2b;
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    1227 </span>            :       }
<span class="lineNum">    1228 </span>            : 
<span class="lineNum">    1229 </span>            :       // If crossed c threshold, continue evolution from this threshold.
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :       else if (nFlavour == 4 &amp;&amp; pT2 &lt; m2c) {</span>
<span class="lineNum">    1231 </span>            :         needNewPDF = true;
<span class="lineNum">    1232 </span>            :         pT2 = m2c;
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    1234 </span>            :       }
<span class="lineNum">    1235 </span>            : 
<span class="lineNum">    1236 </span>            :       // Abort evolution if below cutoff scale, or below another branching.
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :       else if (pT2 &lt; pT2endDip) return;</span>
<span class="lineNum">    1238 </span>            : 
<span class="lineNum">    1239 </span>            :       // Select flavour for trial branching
<span class="lineNum">    1240 </span><span class="lineNoCov">          0 :       double temp = xPDFmotherSum * rndmPtr-&gt;flat();</span>
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :       idMother = -nQuarkIn - 1;</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :       do {</span>
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :         temp -= xPDFmother[(++idMother) + 10];</span>
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 :       } while (temp &gt; 0. &amp;&amp; idMother &lt; nQuarkIn);</span>
<span class="lineNum">    1245 </span>            : 
<span class="lineNum">    1246 </span>            :       // Sister is same as mother, but can have m2 &gt; 0
<span class="lineNum">    1247 </span>            :       idSister = idMother;
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :       mSister = particleDataPtr-&gt;m0(idSister);</span>
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :       m2Sister = pow2(mSister);</span>
<span class="lineNum">    1250 </span>            : 
<span class="lineNum">    1251 </span>            :       // Select z for trial branching
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 :       z = (zMinAbs * zMaxAbs) / pow2( sqrt(zMinAbs) + rndmPtr-&gt;flat()</span>
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :                                       * ( sqrt(zMaxAbs)- sqrt(zMinAbs) ));</span>
<span class="lineNum">    1254 </span>            : 
<span class="lineNum">    1255 </span>            :       // Trial weight: splitting kernel
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :       wt = 0.5 * (1. + pow2(1. - z)) * sqrt(z);</span>
<span class="lineNum">    1257 </span>            : 
<span class="lineNum">    1258 </span>            :       // Trial weight: running alpha_EM
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :       double alphaEMnow = alphaEM.alphaEM(renormMultFac * pT2);</span>
<span class="lineNum">    1260 </span><span class="lineNoCov">          0 :       wt *= (alphaEMnow / alphaEMmax);</span>
<span class="lineNum">    1261 </span>            : 
<span class="lineNum">    1262 </span>            :       // Derive Q2 and x of mother from pT2 and z
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :       Q2      = pT2 / (1. - z);</span>
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :       xMother = xDaughter / z;</span>
<span class="lineNum">    1265 </span>            :       // Correction to x for massive recoiler from rescattering.
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :       if (!dipEndNow-&gt;normalRecoil) {</span>
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :         if (sideA) xMother += (m2Rec / (x2Now * sCM)) * (1. / z - 1.);</span>
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :         else       xMother += (m2Rec / (x1Now * sCM)) * (1. / z - 1.);</span>
<span class="lineNum">    1269 </span>            :       }
<span class="lineNum">    1270 </span>            : 
<span class="lineNum">    1271 </span>            :       // Compute pT2corr
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :       pT2corr  = Q2 - z * (m2Dip + Q2) * (Q2 + m2Sister) / m2Dip;</span>
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :       if (pT2corr &lt; TINYPT2) { wt = 0.; continue; }</span>
<span class="lineNum">    1274 </span>            : 
<span class="lineNum">    1275 </span>            :       // If creating heavy quark by Q -&gt; gamma + Q then next g -&gt; Q + Qbar.
<span class="lineNum">    1276 </span>            :       // So minimum total mass2 is 4 * m2Sister, but use more to be safe.
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :       if ( abs(idMother) == 4 || abs(idMother) == 5 ) {</span>
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :         double m2QQsister =  EXTRASPACEQ * 4. * m2Sister;</span>
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :         double pT2QQcorr = Q2 - z * (m2Dip + Q2) * (Q2 + m2QQsister) / m2Dip;</span>
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :         if (pT2QQcorr &lt; TINYPT2) { wt = 0.; continue; }</span>
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1282 </span>            : 
<span class="lineNum">    1283 </span>            :       // Optional dampening of large pT values in first radiation.
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :       if (dopTdamp &amp;&amp; iSysNow == 0 &amp;&amp; MEtype == 0 &amp;&amp; nRad == 0)</span>
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :         wt *= pT2damp / (pT2 + pT2damp);</span>
<span class="lineNum">    1286 </span>            : 
<span class="lineNum">    1287 </span>            :       // Evaluation of new daughter PDF
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :       pdfScale2 = (useFixedFacScale) ? fixedFacScale2 : factorMultFac * pT2;</span>
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 :       double xPDFdaughterNew = beam.xfISR(iSysNow, idDaughter, xDaughter,</span>
<span class="lineNum">    1290 </span>            :         pdfScale2);
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :       if (xPDFdaughterNew &lt; TINYPDF) {</span>
<span class="lineNum">    1292 </span>            :         xPDFdaughterNew = TINYPDF;
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1294 </span>            : 
<span class="lineNum">    1295 </span>            :       // Evaluation of new charge-weighted mother PDF
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :       double xPDFmotherNew = pow2( (abs(idMother+1) % 2 + 1)/3.0 )</span>
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 :         * beam.xfISR(iSysNow, idMother, xMother, pdfScale2);</span>
<span class="lineNum">    1298 </span>            : 
<span class="lineNum">    1299 </span>            :       // Trial weight: divide out old pdf ratio
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :       wt *= xPDFdaughter / xPDFmother[idMother + 10];</span>
<span class="lineNum">    1301 </span>            : 
<span class="lineNum">    1302 </span>            :       // Trial weight: new pdf ratio
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :       wt *= xPDFmotherNew / xPDFdaughterNew;</span>
<span class="lineNum">    1304 </span>            : 
<span class="lineNum">    1305 </span>            :     // Iterate until acceptable pT (or have fallen below pTmin).
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :     } while (wt &lt; rndmPtr-&gt;flat()) ;</span>
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1308 </span>            : 
<span class="lineNum">    1309 </span>            :   // Save values for (so far) acceptable branching.
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :   dipEndNow-&gt;store( idDaughter, idMother, idSister, x1Now, x2Now, m2Dip,</span>
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 :     pT2, z, xMother, Q2, mSister, m2Sister, pT2corr);</span>
<span class="lineNum">    1312 </span>            : 
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1314 </span>            : 
<a name="1315"><span class="lineNum">    1315 </span>            : //--------------------------------------------------------------------------</a>
<span class="lineNum">    1316 </span>            : 
<span class="lineNum">    1317 </span>            : void SpaceShower::pT2nextWeak( double pT2begDip, double pT2endDip) {
<span class="lineNum">    1318 </span>            : 
<span class="lineNum">    1319 </span>            :   // Type of dipole and starting values.
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :   BeamParticle&amp; beam  = (sideA) ? *beamAPtr : *beamBPtr;</span>
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :   bool   isLeptonBeam = beam.isLepton();</span>
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :   bool   isValence    = beam[iSysNow].isValence();</span>
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :   int    MEtype       = dipEndNow-&gt;MEtype;</span>
<span class="lineNum">    1324 </span>            :   double pT2          = pT2begDip;
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :   double m2Lepton = (isLeptonBeam) ? pow2(beam.m()) : 0.;</span>
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :   if (isLeptonBeam &amp;&amp; pT2begDip &lt; m2Lepton) return;</span>
<span class="lineNum">    1327 </span>            : 
<span class="lineNum">    1328 </span>            :   // alpha_em at maximum scale provides upper estimate.
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :   double alphaEMmax  = alphaEM.alphaEM(pT2begDip);</span>
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :   double alphaEM2pi  = alphaEMmax / (2. * M_PI);</span>
<span class="lineNum">    1331 </span>            : 
<span class="lineNum">    1332 </span>            :   // Maximum x of mother implies minimum z = xDaughter / xMother.
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 :   double xMaxAbs  = (isLeptonBeam) ? LEPTONXMAX : beam.xMax(iSysNow);</span>
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 :   double zMinAbs  = xDaughter / xMaxAbs;</span>
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :   if (xMaxAbs &lt; 0.) {</span>
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :     infoPtr-&gt;errorMsg(&quot;Warning in SpaceShower::pT2nextWeak: &quot;</span>
<span class="lineNum">    1337 </span>            :     &quot;xMaxAbs negative&quot;);
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1339 </span>            :   }
<span class="lineNum">    1340 </span>            : 
<span class="lineNum">    1341 </span>            :   // Maximum z from minimum pT and, for lepton, from minimum x_gamma.
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :   double zMaxAbs = 1. - 0.5 * (pT2endDip / m2Dip) *</span>
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :     ( sqrt( 1. + 4. * m2Dip / pT2endDip ) - 1. );</span>
<span class="lineNum">    1344 </span><span class="lineNoCov">          0 :   if (isLeptonBeam) {</span>
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :     double zMaxLepton = xDaughter / (xDaughter + LEPTONXMIN);</span>
<span class="lineNum">    1346 </span><span class="lineNoCov">          0 :     if (zMaxLepton &lt; zMaxAbs) zMaxAbs = zMaxLepton;</span>
<span class="lineNum">    1347 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 :   if (zMaxAbs &lt; zMinAbs) return;</span>
<span class="lineNum">    1349 </span>            : 
<span class="lineNum">    1350 </span>            :   // Variables used inside evolution loop. (Mainly dummy start values.)
<span class="lineNum">    1351 </span>            :   int    idMother = 0;
<span class="lineNum">    1352 </span>            :   int    idSister = 0;
<span class="lineNum">    1353 </span>            :   // Check whether emission of W+, W- or Z0.
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 :   if (dipEndNow-&gt;weakType == 1) {</span>
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :     idSister = (idDaughter &gt; 0) ? -24 : 24;</span>
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 :     if (abs(idDaughter) % 2 == 1) idSister = -idSister;</span>
<span class="lineNum">    1357 </span><span class="lineNoCov">          0 :   } else if (dipEndNow-&gt;weakType == 2) idSister = 23;</span>
<span class="lineNum">    1358 </span>            :   double z        = 0.;
<span class="lineNum">    1359 </span>            :   double xMother  = 0.;
<span class="lineNum">    1360 </span>            :   double wt       = 0.;
<span class="lineNum">    1361 </span>            :   double Q2       = 0.;
<span class="lineNum">    1362 </span><span class="lineNoCov">          0 :   double mSister  = particleDataPtr-&gt;mSel(idSister);</span>
<span class="lineNum">    1363 </span><span class="lineNoCov">          0 :   double m2Sister = pow2(mSister);</span>
<span class="lineNum">    1364 </span>            :   double pT2corr  = 0.;
<span class="lineNum">    1365 </span>            : 
<span class="lineNum">    1366 </span>            :   // Find maximum z due to massive sister.
<span class="lineNum">    1367 </span>            :   // Still need to prove that this actually is an overestimate.
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :   double mRatio   = mSister/ sqrt(m2Dip);</span>
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :   double m2R1     = 1. + pow2(mRatio);</span>
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :   double zMaxMassive =  1. / (m2R1 + pT2endDip/m2Dip);</span>
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :   if (zMaxMassive &lt; zMaxAbs) zMaxAbs = zMaxMassive;</span>
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :   if (zMaxAbs &lt; zMinAbs) return;</span>
<span class="lineNum">    1373 </span>            : 
<span class="lineNum">    1374 </span>            :   // Weak evolution of fermions.
<span class="lineNum">    1375 </span>            :   // Integrals of splitting kernels for fermions: f -&gt; f.
<span class="lineNum">    1376 </span>            :   // Old ansatz f(z) = 2 / (1 - z), with + 2 / (z - xDaughter) for lepton.
<span class="lineNum">    1377 </span>            :   // New Ansatz f(z) = (1 + (1+r^2)^2) / (1 - z * (1 + r^2)).
<span class="lineNum">    1378 </span>            :   // This should always be an overestimate for massive emissions.
<span class="lineNum">    1379 </span>            :   // Not yet implemented correctly for lepton beam.
<span class="lineNum">    1380 </span>            :   double f2fInt   = 0.;
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :   double f2fIntA  = (1. + pow2(zMaxAbs * m2R1)) / m2R1</span>
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 :     * log( (1. - m2R1 * zMinAbs) / (1. - m2R1 * zMaxAbs) );</span>
<span class="lineNum">    1383 </span>            :   double f2fIntB  = 0.;
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 :   double zRootMin = (1. + sqrt(m2R1 * zMinAbs)) / (1. - sqrt(m2R1 * zMinAbs));</span>
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :   double zRootMax = (1. + sqrt(m2R1 * zMaxAbs)) / (1. - sqrt(m2R1 * zMaxAbs));</span>
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 :   if (isLeptonBeam) {</span>
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :     f2fIntB      = 2. * log( (zMaxAbs - xDaughter) / (zMinAbs - xDaughter) );</span>
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 :     f2fInt       = f2fIntA + f2fIntB;</span>
<span class="lineNum">    1389 </span><span class="lineNoCov">          0 :   } else if (isValence)</span>
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :     f2fInt = (1. + pow2(zMaxAbs) * pow2(m2R1))/ sqrt(m2R1)</span>
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :       * log( zRootMax / zRootMin );</span>
<span class="lineNum">    1392 </span>            :   else
<span class="lineNum">    1393 </span>            :     f2fInt  =  f2fIntA;
<span class="lineNum">    1394 </span>            : 
<span class="lineNum">    1395 </span>            :   // Calculate the weak coupling: separate for left- and right-handed fermions.
<span class="lineNum">    1396 </span>            :   double weakCoupling = 0;
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :   if (dipEndNow-&gt;weakType == 1)</span>
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :     weakCoupling = 2. * alphaEM2pi / (4. * coupSMPtr-&gt;sin2thetaW());</span>
<span class="lineNum">    1399 </span><span class="lineNoCov">          0 :   else if (dipEndNow-&gt;weakType == 2 &amp;&amp; dipEndNow-&gt;weakPol == -1)</span>
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :      weakCoupling = alphaEM2pi * thetaWRat</span>
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :        * pow2(2. * coupSMPtr-&gt;lf( abs(idDaughter) ));</span>
<span class="lineNum">    1402 </span>            :   else
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :      weakCoupling = alphaEM2pi * thetaWRat</span>
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 :        * pow2(2. * coupSMPtr-&gt;rf(abs(idDaughter) ));</span>
<span class="lineNum">    1405 </span>            : 
<span class="lineNum">    1406 </span>            :   // Find the possible mothers for a W emission. So far quarks only.
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :   vector&lt;int&gt; possibleMothers;</span>
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :   if (abs(idDaughter) % 2 == 0) {</span>
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 :     possibleMothers.push_back(1);</span>
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :     possibleMothers.push_back(3);</span>
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :     possibleMothers.push_back(5);</span>
<span class="lineNum">    1412 </span>            :   } else {
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :     possibleMothers.push_back(2);</span>
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :     possibleMothers.push_back(4);</span>
<span class="lineNum">    1415 </span>            :   }
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :   if (idDaughter &lt; 0)</span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :     for (unsigned int i = 0;i &lt; possibleMothers.size();i++)</span>
<span class="lineNum">    1418 </span><span class="lineNoCov">          0 :       possibleMothers[i] = - possibleMothers[i];</span>
<span class="lineNum">    1419 </span>            : 
<span class="lineNum">    1420 </span>            :   // Check if daughter estimate is 0, return in that case.
<span class="lineNum">    1421 </span>            :   // Only write warning if u, d or g is the daughter.
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :   pdfScale2 = (useFixedFacScale) ? fixedFacScale2 : factorMultFac * pT2begDip;</span>
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :   double xPDFdaughter = beam.xfISR(iSysNow, idDaughter, xDaughter, pdfScale2);</span>
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :   if (xPDFdaughter &lt; TINYPDF) {</span>
<span class="lineNum">    1425 </span><span class="lineNoCov">          0 :     if (abs(idDaughter) == 1 || abs(idDaughter) == 2 || abs(idDaughter) == 21)</span>
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 :       infoPtr-&gt;errorMsg(&quot;Warning in SpaceShower::pT2nextWeak: &quot;</span>
<span class="lineNum">    1427 </span>            :                         &quot;very small PDF&quot;);
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1429 </span>            :   }
<span class="lineNum">    1430 </span>            : 
<span class="lineNum">    1431 </span>            :   // PDF and CKM upper estimate needed for W emission.
<span class="lineNum">    1432 </span>            :   double overEstimatePDFCKM = 0.;
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :   if (dipEndNow-&gt;weakType == 1) {</span>
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :     for (unsigned int i = 0; i &lt; possibleMothers.size(); i++)</span>
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :       overEstimatePDFCKM += coupSMPtr-&gt;V2CKMid(idDaughter, possibleMothers[i])</span>
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :         * beam.xfISR(iSysNow, possibleMothers[i], xDaughter, pdfScale2)</span>
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :         / xPDFdaughter;</span>
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :   if (dipEndNow-&gt;weakType == 2) overEstimatePDFCKM = 1.;</span>
<span class="lineNum">    1440 </span>            : 
<span class="lineNum">    1441 </span>            :   // Upper estimate for evolution equation, including fudge factor.
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :   if (doMEcorrections) f2fInt *= calcMEmax(MEtype, 1, 1);</span>
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :   double kernelPDF = weakCoupling * f2fInt * weakEnhancement;</span>
<span class="lineNum">    1444 </span>            : 
<span class="lineNum">    1445 </span>            :   // PDF and CKM overestimate.
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :   kernelPDF *= overEstimatePDFCKM;</span>
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 :   double fudge = (isLeptonBeam) ? LEPTONFUDGE * log(m2Dip/m2Lepton) : 1.;</span>
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :   kernelPDF *= fudge;</span>
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :   if (kernelPDF &lt; TINYKERNELPDF) return;</span>
<span class="lineNum">    1450 </span>            : 
<span class="lineNum">    1451 </span>            :   // Begin evolution loop towards smaller pT values.
<span class="lineNum">    1452 </span>            :   do {
<span class="lineNum">    1453 </span>            : 
<span class="lineNum">    1454 </span>            :     // Pick pT2 (in overestimated z range).
<span class="lineNum">    1455 </span>            :     // For l -&gt; l gamma include extrafactor 1 / ln(pT2 / m2l) in evolution.
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 :     double shift = pow(rndmPtr-&gt;flat(), 1. / kernelPDF);</span>
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :     if (isLeptonBeam) pT2 = m2Lepton * pow( pT2 / m2Lepton, shift);</span>
<span class="lineNum">    1458 </span><span class="lineNoCov">          0 :     else              pT2 = pT2 * shift;</span>
<span class="lineNum">    1459 </span>            : 
<span class="lineNum">    1460 </span>            :     // Abort evolution if below cutoff scale, or below another branching.
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :     if (pT2 &lt; pT2endDip) return;</span>
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :     if (isLeptonBeam &amp;&amp; pT2 &lt; LEPTONPT2MIN * m2Lepton) return;</span>
<span class="lineNum">    1463 </span>            : 
<span class="lineNum">    1464 </span>            :     // Abort evolution if below mass treshold.
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :     if (pT2 &lt; HEAVYPT2EVOL * pow2(particleDataPtr-&gt;m0(idDaughter))) return;</span>
<span class="lineNum">    1466 </span>            : 
<span class="lineNum">    1467 </span>            :     // Set the id for the mother particle to be equal to the daughter
<span class="lineNum">    1468 </span>            :     // particle. This is correct for Z, and it will later be changed for W.
<span class="lineNum">    1469 </span><span class="lineNoCov">          0 :     idMother = idDaughter;</span>
<span class="lineNum">    1470 </span>            : 
<span class="lineNum">    1471 </span>            :     // Select z value of branching f -&gt; f + Z/W, and corrective weight.
<span class="lineNum">    1472 </span>            :     wt = 1.0;
<span class="lineNum">    1473 </span><span class="lineNoCov">          0 :     if (isLeptonBeam) {</span>
<span class="lineNum">    1474 </span><span class="lineNoCov">          0 :       if (f2fIntA &gt; rndmPtr-&gt;flat() * (f2fIntA + f2fIntB)) {</span>
<span class="lineNum">    1475 </span><span class="lineNoCov">          0 :         z = 1. - (1. - zMinAbs)</span>
<span class="lineNum">    1476 </span><span class="lineNoCov">          0 :           * pow( (1. - zMaxAbs) / (1. - zMinAbs), rndmPtr-&gt;flat() );</span>
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :       } else {</span>
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :         z = xDaughter + (zMinAbs - xDaughter)</span>
<span class="lineNum">    1479 </span><span class="lineNoCov">          0 :           * pow( (zMaxAbs - xDaughter) / (zMinAbs - xDaughter),</span>
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :                  rndmPtr-&gt;flat() );</span>
<span class="lineNum">    1481 </span>            :       }
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 :       wt *= (z - xDaughter) / (1. - xDaughter);</span>
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 :     } else if (isValence) {</span>
<span class="lineNum">    1484 </span>            :       // Valence more peaked at large z.
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :       double zTmp = zRootMin * pow(zRootMax / zRootMin, rndmPtr-&gt;flat() );</span>
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :       z = pow2( (1. - zTmp) / (1. + zTmp) ) / m2R1;</span>
<span class="lineNum">    1487 </span><span class="lineNoCov">          0 :       wt *= sqrt(z);</span>
<span class="lineNum">    1488 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">    1489 </span><span class="lineNoCov">          0 :       z = (1. - (1. - zMinAbs * m2R1) * pow( (1. - zMaxAbs * m2R1)</span>
<span class="lineNum">    1490 </span><span class="lineNoCov">          0 :         / (1. - zMinAbs * m2R1), rndmPtr-&gt;flat() ) ) / m2R1;</span>
<span class="lineNum">    1491 </span>            :     }
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :     wt *= (1. + pow2(z * m2R1)) / (1. + pow2(zMaxAbs * m2R1));</span>
<span class="lineNum">    1493 </span>            : 
<span class="lineNum">    1494 </span>            :     // Derive Q2 and x of mother from pT2 and z.
<span class="lineNum">    1495 </span><span class="lineNoCov">          0 :     Q2      = pT2 / (1. - z);</span>
<span class="lineNum">    1496 </span><span class="lineNoCov">          0 :     xMother = xDaughter / z;</span>
<span class="lineNum">    1497 </span>            : 
<span class="lineNum">    1498 </span>            :     // Correction to x for massive recoiler from rescattering.
<span class="lineNum">    1499 </span><span class="lineNoCov">          0 :     if (!dipEndNow-&gt;normalRecoil) {</span>
<span class="lineNum">    1500 </span><span class="lineNoCov">          0 :       if (sideA) xMother += (m2Rec / (x2Now * sCM)) * (1. / z - 1.);</span>
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 :       else       xMother += (m2Rec / (x1Now * sCM)) * (1. / z - 1.);</span>
<span class="lineNum">    1502 </span>            :     }
<span class="lineNum">    1503 </span><span class="lineNoCov">          0 :     if (xMother &gt; xMaxAbs) { wt = 0.; continue; }</span>
<span class="lineNum">    1504 </span>            : 
<span class="lineNum">    1505 </span>            :     // Forbidden emission if outside allowed z range for given pT2.
<span class="lineNum">    1506 </span><span class="lineNoCov">          0 :     pT2corr  = Q2 - z * (m2Dip + Q2) * (Q2 + m2Sister) / m2Dip;</span>
<span class="lineNum">    1507 </span><span class="lineNoCov">          0 :     if (pT2corr &lt; TINYPT2) { wt = 0.; continue; }</span>
<span class="lineNum">    1508 </span>            : 
<span class="lineNum">    1509 </span>            :     // Correct by ln(pT2 / m2l) and fudge factor.
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 :     if (isLeptonBeam) wt *= log(pT2 / m2Lepton) / fudge;</span>
<span class="lineNum">    1511 </span>            : 
<span class="lineNum">    1512 </span>            :     // Evaluation of ME correction.
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :     if (doMEcorrections) wt *= calcMEcorr(MEtype, idMother, idDaughter,</span>
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 :       m2Dip, z, Q2, m2Sister) / calcMEmax(MEtype, idMother, idDaughter);</span>
<span class="lineNum">    1515 </span>            : 
<span class="lineNum">    1516 </span>            :     // Optional dampening of large pT values in first radiation.
<span class="lineNum">    1517 </span>            :     // Allow damping also for corrected matrix elements
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :     if (dopTdamp &amp;&amp; iSysNow == 0  &amp;&amp; nRad == 0)</span>
<span class="lineNum">    1519 </span><span class="lineNoCov">          0 :       wt *= pT2damp / (pT2 + pT2damp);</span>
<span class="lineNum">    1520 </span>            : 
<span class="lineNum">    1521 </span>            :     // Correct to current value of alpha_EM.
<span class="lineNum">    1522 </span><span class="lineNoCov">          0 :     double alphaEMnow = alphaEM.alphaEM(pT2);</span>
<span class="lineNum">    1523 </span><span class="lineNoCov">          0 :     wt *= (alphaEMnow / alphaEMmax);</span>
<span class="lineNum">    1524 </span>            : 
<span class="lineNum">    1525 </span>            :     // Evaluation of new daughter and mother PDF's for Z.
<span class="lineNum">    1526 </span><span class="lineNoCov">          0 :     pdfScale2 = (useFixedFacScale) ? fixedFacScale2 : factorMultFac * pT2;</span>
<span class="lineNum">    1527 </span><span class="lineNoCov">          0 :     double xPDFdaughterNew = max ( TINYPDF,</span>
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 :       beam.xfISR(iSysNow, idDaughter, xDaughter, pdfScale2) );</span>
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 :     if (dipEndNow-&gt;weakType == 2) {</span>
<span class="lineNum">    1530 </span>            :       double xPDFmotherNew
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :         = beam.xfISR(iSysNow, idMother, xMother, pdfScale2);</span>
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :       wt *= xPDFmotherNew / xPDFdaughterNew;</span>
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1534 </span>            : 
<span class="lineNum">    1535 </span>            :     // Evaluation of daughter and mother PDF's for W.
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 :     if (dipEndNow-&gt;weakType == 1) {</span>
<span class="lineNum">    1537 </span><span class="lineNoCov">          0 :       double valPDFCKM[3] = {0.};</span>
<span class="lineNum">    1538 </span>            :       double sumPDFCKM    = 0.;
<span class="lineNum">    1539 </span><span class="lineNoCov">          0 :       for (unsigned int i = 0; i &lt; possibleMothers.size(); i++) {</span>
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :         valPDFCKM[i] = coupSMPtr-&gt;V2CKMid(idDaughter,possibleMothers[i])</span>
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 :           * beam.xfISR(iSysNow, possibleMothers[i], xMother, pdfScale2)</span>
<span class="lineNum">    1542 </span><span class="lineNoCov">          0 :           / xPDFdaughterNew;</span>
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :         sumPDFCKM += valPDFCKM[i];</span>
<span class="lineNum">    1544 </span>            :       }
<span class="lineNum">    1545 </span><span class="lineNoCov">          0 :       wt *= sumPDFCKM / overEstimatePDFCKM;</span>
<span class="lineNum">    1546 </span>            : 
<span class="lineNum">    1547 </span>            :       // Choose id for mother in case of W.
<span class="lineNum">    1548 </span><span class="lineNoCov">          0 :       double pickId    = sumPDFCKM * rndmPtr-&gt;flat();</span>
<span class="lineNum">    1549 </span>            :       int iId    = -1;
<span class="lineNum">    1550 </span><span class="lineNoCov">          0 :       int pmSize = possibleMothers.size();</span>
<span class="lineNum">    1551 </span><span class="lineNoCov">          0 :       do    pickId -= valPDFCKM[++iId];</span>
<span class="lineNum">    1552 </span><span class="lineNoCov">          0 :       while (pickId &gt; 0. &amp;&amp; iId &lt; pmSize);</span>
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :       idMother = possibleMothers[iId];</span>
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1555 </span>            : 
<span class="lineNum">    1556 </span>            :     // Warn if too big weight.
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :     if (wt &gt; 1.) infoPtr-&gt;errorMsg(&quot;Warning in SpaceShower::pT2nextWeak: &quot;</span>
<span class="lineNum">    1558 </span>            :       &quot;weight is above unity.&quot;);
<span class="lineNum">    1559 </span>            : 
<span class="lineNum">    1560 </span>            :     // Iterate until acceptable pT (or have fallen below pTmin).
<span class="lineNum">    1561 </span><span class="lineNoCov">          0 :   } while (wt &lt; rndmPtr-&gt;flat()) ;</span>
<span class="lineNum">    1562 </span>            : 
<span class="lineNum">    1563 </span>            :   // Save values for (so far) acceptable branching.
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :   dipEndNow-&gt;store( idDaughter, idMother, idSister, x1Now, x2Now, m2Dip,</span>
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :                     pT2, z, xMother, Q2, mSister, m2Sister, pT2corr);</span>
<span class="lineNum">    1566 </span>            : 
<span class="lineNum">    1567 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1568 </span>            : 
<span class="lineNum">    1569 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1570 </span>            : 
<span class="lineNum">    1571 </span>            : // Kinematics of branching.
<a name="1572"><span class="lineNum">    1572 </span>            : // Construct mother -&gt; daughter + sister, with recoiler on other side.</a>
<span class="lineNum">    1573 </span>            : 
<span class="lineNum">    1574 </span>            : bool SpaceShower::branch( Event&amp; event) {
<span class="lineNum">    1575 </span>            : 
<span class="lineNum">    1576 </span>            :   // Side on which branching occured.
<span class="lineNum">    1577 </span><span class="lineNoCov">          0 :   int side          = abs(dipEndSel-&gt;side);</span>
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 :   double sideSign   = (side == 1) ? 1. : -1.;</span>
<span class="lineNum">    1579 </span>            : 
<span class="lineNum">    1580 </span>            :   // Read in flavour and colour variables.
<span class="lineNum">    1581 </span><span class="lineNoCov">          0 :   int iDaughter     = partonSystemsPtr-&gt;getInA(iSysSel);</span>
<span class="lineNum">    1582 </span><span class="lineNoCov">          0 :   int iRecoiler     = partonSystemsPtr-&gt;getInB(iSysSel);</span>
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :   if (side == 2) swap(iDaughter, iRecoiler);</span>
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :   int idDaughterNow = dipEndSel-&gt;idDaughter;</span>
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :   int idMother      = dipEndSel-&gt;idMother;</span>
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :   int idSister      = dipEndSel-&gt;idSister;</span>
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :   int idRecoiler    = event[iRecoiler].id();</span>
<span class="lineNum">    1588 </span><span class="lineNoCov">          0 :   int colDaughter   = event[iDaughter].col();</span>
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :   int acolDaughter  = event[iDaughter].acol();</span>
<span class="lineNum">    1590 </span>            : 
<span class="lineNum">    1591 </span>            :   // Recoil parton may be rescatterer, requiring special processing.
<span class="lineNum">    1592 </span><span class="lineNoCov">          0 :   bool normalRecoil = dipEndSel-&gt;normalRecoil;</span>
<span class="lineNum">    1593 </span><span class="lineNoCov">          0 :   int iRecoilMother = event[iRecoiler].mother1();</span>
<span class="lineNum">    1594 </span>            : 
<span class="lineNum">    1595 </span>            :   // Read in kinematical variables.
<span class="lineNum">    1596 </span><span class="lineNoCov">          0 :   double x1         = dipEndSel-&gt;x1;</span>
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :   double x2         = dipEndSel-&gt;x2;</span>
<span class="lineNum">    1598 </span><span class="lineNoCov">          0 :   double xMo        = dipEndSel-&gt;xMo;</span>
<span class="lineNum">    1599 </span><span class="lineNoCov">          0 :   double m2         = dipEndSel-&gt;m2Dip;</span>
<span class="lineNum">    1600 </span><span class="lineNoCov">          0 :   double m          = sqrt(m2);</span>
<span class="lineNum">    1601 </span><span class="lineNoCov">          0 :   double pT2        = dipEndSel-&gt;pT2;</span>
<span class="lineNum">    1602 </span><span class="lineNoCov">          0 :   double z          = dipEndSel-&gt;z;</span>
<span class="lineNum">    1603 </span><span class="lineNoCov">          0 :   double Q2         = dipEndSel-&gt;Q2;</span>
<span class="lineNum">    1604 </span><span class="lineNoCov">          0 :   double mSister    = dipEndSel-&gt;mSister;</span>
<span class="lineNum">    1605 </span><span class="lineNoCov">          0 :   double m2Sister   = dipEndSel-&gt;m2Sister;</span>
<span class="lineNum">    1606 </span><span class="lineNoCov">          0 :   double pT2corr    = dipEndSel-&gt;pT2corr;</span>
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 :   double x1New      = (side == 1) ? xMo : x1;</span>
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 :   double x2New      = (side == 2) ? xMo : x2;</span>
<span class="lineNum">    1609 </span>            : 
<span class="lineNum">    1610 </span>            :   // Read in MEtype:
<span class="lineNum">    1611 </span><span class="lineNoCov">          0 :   int MEtype        = dipEndSel-&gt;MEtype;</span>
<span class="lineNum">    1612 </span>            : 
<span class="lineNum">    1613 </span>            :   // Rescatter: kinematics may fail; use the rescatterFail flag to tell
<span class="lineNum">    1614 </span>            :   //            parton level to try again.
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :   rescatterFail     = false;</span>
<span class="lineNum">    1616 </span>            : 
<span class="lineNum">    1617 </span>            :   // Construct kinematics of mother, sister and recoiler in old rest frame.
<span class="lineNum">    1618 </span>            :   // Normally both mother and recoiler are taken massless.
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :   double eNewRec, pzNewRec, pTbranch, pzMother;</span>
<span class="lineNum">    1620 </span><span class="lineNoCov">          0 :   if (normalRecoil) {</span>
<span class="lineNum">    1621 </span><span class="lineNoCov">          0 :     eNewRec         = 0.5 * (m2 + Q2) / m;</span>
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 :     pzNewRec        = -sideSign * eNewRec;</span>
<span class="lineNum">    1623 </span><span class="lineNoCov">          0 :     pTbranch        = sqrt(pT2corr) * m2 / ( z * (m2 + Q2) );</span>
<span class="lineNum">    1624 </span><span class="lineNoCov">          0 :     pzMother        = sideSign * 0.5 * m * ( (m2 - Q2) / ( z * (m2 + Q2) )</span>
<span class="lineNum">    1625 </span><span class="lineNoCov">          0 :                     + (Q2 + m2Sister) / m2 );</span>
<span class="lineNum">    1626 </span>            :   // More complicated kinematics when recoiler not massless. May fail.
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">    1628 </span><span class="lineNoCov">          0 :     m2Rec           = event[iRecoiler].m2();</span>
<span class="lineNum">    1629 </span><span class="lineNoCov">          0 :     double s1Tmp    = m2 + Q2 - m2Rec;</span>
<span class="lineNum">    1630 </span><span class="lineNoCov">          0 :     double s3Tmp    = m2 / z - m2Rec;</span>
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 :     double r1Tmp    = sqrt(s1Tmp * s1Tmp + 4. * Q2 * m2Rec);</span>
<span class="lineNum">    1632 </span><span class="lineNoCov">          0 :     eNewRec         = 0.5 * (m2 + m2Rec + Q2) / m;</span>
<span class="lineNum">    1633 </span><span class="lineNoCov">          0 :     pzNewRec        = -sideSign * 0.5 * r1Tmp / m;</span>
<span class="lineNum">    1634 </span><span class="lineNoCov">          0 :     double pT2br    = Q2 * s3Tmp * (m2 / z - m2 - Q2)</span>
<span class="lineNum">    1635 </span><span class="lineNoCov">          0 :       - m2Sister * s1Tmp * s3Tmp - m2Rec * pow2(Q2 + m2Sister);</span>
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :     if (pT2br &lt;= 0.) return false;</span>
<span class="lineNum">    1637 </span><span class="lineNoCov">          0 :     pTbranch        = sqrt(pT2br) / r1Tmp;</span>
<span class="lineNum">    1638 </span><span class="lineNoCov">          0 :     pzMother        = sideSign * (m * s3Tmp</span>
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 :       - eNewRec * (m2 / z - Q2 - m2Rec - m2Sister)) / r1Tmp;</span>
<span class="lineNum">    1640 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1641 </span>            :   // Common final kinematics steps for both normal and rescattering.
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 :   double eMother    = sqrt( pow2(pTbranch) + pow2(pzMother) );</span>
<span class="lineNum">    1643 </span><span class="lineNoCov">          0 :   double pzSister   = pzMother + pzNewRec;</span>
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :   double eSister    = sqrt( pow2(pTbranch) + pow2(pzSister) + m2Sister );</span>
<span class="lineNum">    1645 </span><span class="lineNoCov">          0 :   Vec4 pMother( pTbranch, 0., pzMother, eMother );</span>
<span class="lineNum">    1646 </span><span class="lineNoCov">          0 :   Vec4 pSister( pTbranch, 0., pzSister, eSister );</span>
<span class="lineNum">    1647 </span><span class="lineNoCov">          0 :   Vec4 pNewRec(       0., 0., pzNewRec, eNewRec );</span>
<span class="lineNum">    1648 </span>            : 
<span class="lineNum">    1649 </span>            :   // Current event and subsystem size.
<span class="lineNum">    1650 </span><span class="lineNoCov">          0 :   int eventSizeOld  = event.size();</span>
<span class="lineNum">    1651 </span><span class="lineNoCov">          0 :   int systemSizeOld = partonSystemsPtr-&gt;sizeAll(iSysSel);</span>
<span class="lineNum">    1652 </span>            : 
<span class="lineNum">    1653 </span>            :   // Save properties to be restored in case of user-hook veto of emission.
<span class="lineNum">    1654 </span><span class="lineNoCov">          0 :   int beamOff1 = 1 + beamOffset;</span>
<span class="lineNum">    1655 </span><span class="lineNoCov">          0 :   int beamOff2 = 2 + beamOffset;</span>
<span class="lineNum">    1656 </span><span class="lineNoCov">          0 :   int ev1Dau1V = event[beamOff1].daughter1();</span>
<span class="lineNum">    1657 </span><span class="lineNoCov">          0 :   int ev2Dau1V = event[beamOff2].daughter1();</span>
<span class="lineNum">    1658 </span><span class="lineNoCov">          0 :   vector&lt;int&gt; statusV, mother1V, mother2V, daughter1V, daughter2V;</span>
<span class="lineNum">    1659 </span>            : 
<span class="lineNum">    1660 </span>            :   // Check if the first emission shoild be checked for removal
<span class="lineNum">    1661 </span><span class="lineNoCov">          0 :   bool canMergeFirst = (mergingHooksPtr != 0)</span>
<span class="lineNum">    1662 </span><span class="lineNoCov">          0 :                      ? mergingHooksPtr-&gt;canVetoEmission() : false;</span>
<span class="lineNum">    1663 </span><span class="lineNoCov">          0 :   if (canVetoEmission || canMergeFirst || doWeakShower) {</span>
<span class="lineNum">    1664 </span><span class="lineNoCov">          0 :     for ( int iCopy = 0; iCopy &lt; systemSizeOld; ++iCopy) {</span>
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :       int iOldCopy    = partonSystemsPtr-&gt;getAll(iSysSel, iCopy);</span>
<span class="lineNum">    1666 </span><span class="lineNoCov">          0 :       statusV.push_back( event[iOldCopy].status());</span>
<span class="lineNum">    1667 </span><span class="lineNoCov">          0 :       mother1V.push_back( event[iOldCopy].mother1());</span>
<span class="lineNum">    1668 </span><span class="lineNoCov">          0 :       mother2V.push_back( event[iOldCopy].mother2());</span>
<span class="lineNum">    1669 </span><span class="lineNoCov">          0 :       daughter1V.push_back( event[iOldCopy].daughter1());</span>
<span class="lineNum">    1670 </span><span class="lineNoCov">          0 :       daughter2V.push_back( event[iOldCopy].daughter2());</span>
<span class="lineNum">    1671 </span>            :     }
<span class="lineNum">    1672 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1673 </span>            : 
<span class="lineNum">    1674 </span>            :   // Take copy of existing system, to be given modified kinematics.
<span class="lineNum">    1675 </span>            :   // Incoming negative status. Rescattered also negative, but after copy.
<span class="lineNum">    1676 </span><span class="lineNoCov">          0 :   for ( int iCopy = 0; iCopy &lt; systemSizeOld; ++iCopy) {</span>
<span class="lineNum">    1677 </span><span class="lineNoCov">          0 :     int iOldCopy    = partonSystemsPtr-&gt;getAll(iSysSel, iCopy);</span>
<span class="lineNum">    1678 </span><span class="lineNoCov">          0 :     int statusOld   = event[iOldCopy].status();</span>
<span class="lineNum">    1679 </span><span class="lineNoCov">          0 :     int statusNew   = (iOldCopy == iDaughter</span>
<span class="lineNum">    1680 </span><span class="lineNoCov">          0 :       || iOldCopy == iRecoiler) ? statusOld : 44;</span>
<span class="lineNum">    1681 </span><span class="lineNoCov">          0 :     int iNewCopy    = event.copy(iOldCopy, statusNew);</span>
<span class="lineNum">    1682 </span><span class="lineNoCov">          0 :     if (statusOld &lt; 0) event[iNewCopy].statusNeg();</span>
<span class="lineNum">    1683 </span>            :   }
<span class="lineNum">    1684 </span>            : 
<span class="lineNum">    1685 </span>            :   // Define colour flow in branching.
<span class="lineNum">    1686 </span>            :   // Default corresponds to f -&gt; f + gamma.
<span class="lineNum">    1687 </span>            :   int colMother     = colDaughter;
<span class="lineNum">    1688 </span>            :   int acolMother    = acolDaughter;
<span class="lineNum">    1689 </span>            :   int colSister     = 0;
<span class="lineNum">    1690 </span>            :   int acolSister    = 0;
<span class="lineNum">    1691 </span><span class="lineNoCov">          0 :   if (idSister == 22 || idSister == 23 || abs(idSister) == 24) ;</span>
<span class="lineNum">    1692 </span>            :   // q -&gt; q + g and 50% of g -&gt; g + g; need new colour.
<span class="lineNum">    1693 </span><span class="lineNoCov">          0 :   else if (idSister == 21 &amp;&amp; ( (idMother &gt; 0 &amp;&amp; idMother &lt; 9)</span>
<span class="lineNum">    1694 </span><span class="lineNoCov">          0 :   || (idMother == 21 &amp;&amp; rndmPtr-&gt;flat() &lt; 0.5) ) ) {</span>
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :     colMother       = event.nextColTag();</span>
<span class="lineNum">    1696 </span>            :     colSister       = colMother;
<span class="lineNum">    1697 </span>            :     acolSister      = colDaughter;
<span class="lineNum">    1698 </span>            :   // qbar -&gt; qbar + g and other 50% of g -&gt; g + g; need new colour.
<span class="lineNum">    1699 </span><span class="lineNoCov">          0 :   } else if (idSister == 21) {</span>
<span class="lineNum">    1700 </span><span class="lineNoCov">          0 :     acolMother      = event.nextColTag();</span>
<span class="lineNum">    1701 </span>            :     acolSister      = acolMother;
<span class="lineNum">    1702 </span>            :     colSister       = acolDaughter;
<span class="lineNum">    1703 </span>            :   // q -&gt; g + q.
<span class="lineNum">    1704 </span><span class="lineNoCov">          0 :   } else if (idDaughterNow == 21 &amp;&amp; idMother &gt; 0) {</span>
<span class="lineNum">    1705 </span>            :     colMother       = colDaughter;
<span class="lineNum">    1706 </span>            :     acolMother      = 0;
<span class="lineNum">    1707 </span>            :     colSister       = acolDaughter;
<span class="lineNum">    1708 </span>            :   // qbar -&gt; g + qbar
<span class="lineNum">    1709 </span><span class="lineNoCov">          0 :   } else if (idDaughterNow == 21) {</span>
<span class="lineNum">    1710 </span>            :     acolMother      = acolDaughter;
<span class="lineNum">    1711 </span>            :     colMother       = 0;
<span class="lineNum">    1712 </span>            :     acolSister      = colDaughter;
<span class="lineNum">    1713 </span>            :   // g -&gt; q + qbar.
<span class="lineNum">    1714 </span><span class="lineNoCov">          0 :   } else if (idDaughterNow &gt; 0 &amp;&amp; idDaughterNow &lt; 9) {</span>
<span class="lineNum">    1715 </span><span class="lineNoCov">          0 :     acolMother      = event.nextColTag();</span>
<span class="lineNum">    1716 </span>            :     acolSister      = acolMother;
<span class="lineNum">    1717 </span>            :   // g -&gt; qbar + q.
<span class="lineNum">    1718 </span><span class="lineNoCov">          0 :   } else if (idDaughterNow &lt; 0 &amp;&amp; idDaughterNow &gt; -9) {</span>
<span class="lineNum">    1719 </span><span class="lineNoCov">          0 :     colMother       = event.nextColTag();</span>
<span class="lineNum">    1720 </span>            :     colSister       = colMother;
<span class="lineNum">    1721 </span>            :   // q -&gt; gamma + q.
<span class="lineNum">    1722 </span><span class="lineNoCov">          0 :   } else if (idDaughterNow == 22 &amp;&amp; idMother &gt; 0) {</span>
<span class="lineNum">    1723 </span><span class="lineNoCov">          0 :     colMother       = event.nextColTag();</span>
<span class="lineNum">    1724 </span>            :     colSister       = colMother;
<span class="lineNum">    1725 </span>            :    // qbar -&gt; gamma + qbar.
<span class="lineNum">    1726 </span><span class="lineNoCov">          0 :   } else if (idDaughterNow == 22) {</span>
<span class="lineNum">    1727 </span><span class="lineNoCov">          0 :     acolMother      = event.nextColTag();</span>
<span class="lineNum">    1728 </span>            :     acolSister      = acolMother;
<span class="lineNum">    1729 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1730 </span>            : 
<span class="lineNum">    1731 </span>            :   // Indices of partons involved. Add new sister.
<span class="lineNum">    1732 </span><span class="lineNoCov">          0 :   int iMother       = eventSizeOld + side - 1;</span>
<span class="lineNum">    1733 </span><span class="lineNoCov">          0 :   int iNewRecoiler  = eventSizeOld + 2 - side;</span>
<span class="lineNum">    1734 </span><span class="lineNoCov">          0 :   int iSister       = event.append( idSister, 43, iMother, 0, 0, 0,</span>
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 :      colSister, acolSister, pSister, mSister, sqrt(pT2) );</span>
<span class="lineNum">    1736 </span>            : 
<span class="lineNum">    1737 </span>            :   // References to the partons involved.
<span class="lineNum">    1738 </span><span class="lineNoCov">          0 :   Particle&amp; daughter    = event[iDaughter];</span>
<span class="lineNum">    1739 </span><span class="lineNoCov">          0 :   Particle&amp; mother      = event[iMother];</span>
<span class="lineNum">    1740 </span><span class="lineNoCov">          0 :   Particle&amp; newRecoiler = event[iNewRecoiler];</span>
<span class="lineNum">    1741 </span><span class="lineNoCov">          0 :   Particle&amp; sister      = event.back();</span>
<span class="lineNum">    1742 </span>            : 
<span class="lineNum">    1743 </span>            :   // Replace old by new mother; update new recoiler.
<span class="lineNum">    1744 </span><span class="lineNoCov">          0 :   mother.id( idMother );</span>
<span class="lineNum">    1745 </span><span class="lineNoCov">          0 :   mother.status( -41);</span>
<span class="lineNum">    1746 </span><span class="lineNoCov">          0 :   mother.cols( colMother, acolMother);</span>
<span class="lineNum">    1747 </span><span class="lineNoCov">          0 :   mother.p( pMother);</span>
<span class="lineNum">    1748 </span><span class="lineNoCov">          0 :   if (mother.idAbs() == 21 || mother.idAbs() == 22) mother.pol(9);</span>
<span class="lineNum">    1749 </span><span class="lineNoCov">          0 :   newRecoiler.status( (normalRecoil) ? -42 : -46 );</span>
<span class="lineNum">    1750 </span><span class="lineNoCov">          0 :   newRecoiler.p( pNewRec);</span>
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :   if (!normalRecoil) newRecoiler.m( event[iRecoiler].m() );</span>
<span class="lineNum">    1752 </span>            : 
<span class="lineNum">    1753 </span>            :   // Update mother and daughter pointers; also for beams.
<span class="lineNum">    1754 </span><span class="lineNoCov">          0 :   daughter.mothers( iMother, 0);</span>
<span class="lineNum">    1755 </span><span class="lineNoCov">          0 :   mother.daughters( iSister, iDaughter);</span>
<span class="lineNum">    1756 </span><span class="lineNoCov">          0 :   if (iSysSel == 0) {</span>
<span class="lineNum">    1757 </span><span class="lineNoCov">          0 :     event[beamOff1].daughter1( (side == 1) ? iMother : iNewRecoiler );</span>
<span class="lineNum">    1758 </span><span class="lineNoCov">          0 :     event[beamOff2].daughter1( (side == 2) ? iMother : iNewRecoiler );</span>
<span class="lineNum">    1759 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1760 </span>            : 
<span class="lineNum">    1761 </span>            :   // Special checks to set weak particles status equal to 47.
<span class="lineNum">    1762 </span><span class="lineNoCov">          0 :   if (sister.idAbs() == 23 || sister.idAbs() == 24) sister.status(47);</span>
<span class="lineNum">    1763 </span>            : 
<span class="lineNum">    1764 </span>            :   // Find boost to old rest frame.
<span class="lineNum">    1765 </span><span class="lineNoCov">          0 :   RotBstMatrix Mtot;</span>
<span class="lineNum">    1766 </span><span class="lineNoCov">          0 :   if (normalRecoil) Mtot.bst(0., 0., (x2 - x1) / (x1 + x2) );</span>
<span class="lineNum">    1767 </span><span class="lineNoCov">          0 :   else if (side == 1)</span>
<span class="lineNum">    1768 </span><span class="lineNoCov">          0 :        Mtot.toCMframe( event[iDaughter].p(), event[iRecoiler].p() );</span>
<span class="lineNum">    1769 </span><span class="lineNoCov">          0 :   else Mtot.toCMframe( event[iRecoiler].p(), event[iDaughter].p() );</span>
<span class="lineNum">    1770 </span>            : 
<span class="lineNum">    1771 </span>            :   // Initially select phi angle of branching at random.
<span class="lineNum">    1772 </span><span class="lineNoCov">          0 :   double phi = 2. * M_PI * rndmPtr-&gt;flat();</span>
<span class="lineNum">    1773 </span>            : 
<span class="lineNum">    1774 </span>            :   // Evaluate coefficient of azimuthal asymmetry from gluon polarization.
<span class="lineNum">    1775 </span><span class="lineNoCov">          0 :   findAsymPol( event, dipEndSel);</span>
<span class="lineNum">    1776 </span><span class="lineNoCov">          0 :   int    iFinPol = dipEndSel-&gt;iFinPol;</span>
<span class="lineNum">    1777 </span><span class="lineNoCov">          0 :   double cPol    = dipEndSel-&gt;asymPol;</span>
<span class="lineNum">    1778 </span><span class="lineNoCov">          0 :   double phiPol  = (iFinPol == 0) ? 0. : event[iFinPol].phi();</span>
<span class="lineNum">    1779 </span>            : 
<span class="lineNum">    1780 </span>            :   // If interference: try to match sister (anti)colour to final state.
<span class="lineNum">    1781 </span>            :   int    iFinInt = 0;
<span class="lineNum">    1782 </span><span class="lineNoCov">          0 :   double cInt    = 0.;</span>
<span class="lineNum">    1783 </span>            :   double phiInt  = 0.;
<span class="lineNum">    1784 </span><span class="lineNoCov">          0 :   if (doPhiIntAsym) {</span>
<span class="lineNum">    1785 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; partonSystemsPtr-&gt;sizeOut(iSysSel); ++ i) {</span>
<span class="lineNum">    1786 </span><span class="lineNoCov">          0 :       int iOut = partonSystemsPtr-&gt;getOut(iSysSel, i);</span>
<span class="lineNum">    1787 </span><span class="lineNoCov">          0 :       if ( (acolSister != 0 &amp;&amp; event[iOut].col() == acolSister)</span>
<span class="lineNum">    1788 </span><span class="lineNoCov">          0 :         || (colSister != 0 &amp;&amp; event[iOut].acol() == colSister) )</span>
<span class="lineNum">    1789 </span><span class="lineNoCov">          0 :         iFinInt = iOut;</span>
<span class="lineNum">    1790 </span>            :     }
<span class="lineNum">    1791 </span><span class="lineNoCov">          0 :     if (iFinInt != 0) {</span>
<span class="lineNum">    1792 </span>            :       // Boost final-state parton to current frame of new kinematics.
<span class="lineNum">    1793 </span><span class="lineNoCov">          0 :       Vec4 pFinTmp = event[iFinInt].p();</span>
<span class="lineNum">    1794 </span><span class="lineNoCov">          0 :       pFinTmp.rotbst(Mtot);</span>
<span class="lineNum">    1795 </span><span class="lineNoCov">          0 :       double theFin = pFinTmp.theta();</span>
<span class="lineNum">    1796 </span><span class="lineNoCov">          0 :       if (side == 2) theFin = M_PI - theFin;</span>
<span class="lineNum">    1797 </span><span class="lineNoCov">          0 :       double theSis = pSister.theta();</span>
<span class="lineNum">    1798 </span><span class="lineNoCov">          0 :       if (side == 2) theSis = M_PI - theSis;</span>
<span class="lineNum">    1799 </span><span class="lineNoCov">          0 :       cInt = strengthIntAsym * 2. * theSis * theFin</span>
<span class="lineNum">    1800 </span><span class="lineNoCov">          0 :            / (pow2(theSis) + pow2(theFin));</span>
<span class="lineNum">    1801 </span><span class="lineNoCov">          0 :       phiInt = event[iFinInt].phi();</span>
<span class="lineNum">    1802 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1803 </span>            :   }
<span class="lineNum">    1804 </span>            : 
<span class="lineNum">    1805 </span>            :   // Bias phi distribution for polarization and interference.
<span class="lineNum">    1806 </span><span class="lineNoCov">          0 :   if (iFinPol != 0 || iFinInt != 0) {</span>
<span class="lineNum">    1807 </span><span class="lineNoCov">          0 :     double cPhiPol, cPhiInt, weight;</span>
<span class="lineNum">    1808 </span><span class="lineNoCov">          0 :     do {</span>
<span class="lineNum">    1809 </span><span class="lineNoCov">          0 :       phi     = 2. * M_PI * rndmPtr-&gt;flat();</span>
<span class="lineNum">    1810 </span>            :       weight  = 1.;
<span class="lineNum">    1811 </span><span class="lineNoCov">          0 :       if (iFinPol !=0 ) {</span>
<span class="lineNum">    1812 </span><span class="lineNoCov">          0 :         cPhiPol = cos(phi - phiPol);</span>
<span class="lineNum">    1813 </span><span class="lineNoCov">          0 :         weight *= ( 1. + cPol * (2. * pow2(cPhiPol) - 1.) )</span>
<span class="lineNum">    1814 </span><span class="lineNoCov">          0 :           / ( 1. + abs(cPol) );</span>
<span class="lineNum">    1815 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1816 </span><span class="lineNoCov">          0 :       if (iFinInt !=0 ) {</span>
<span class="lineNum">    1817 </span><span class="lineNoCov">          0 :         cPhiInt = cos(phi - phiInt);</span>
<span class="lineNum">    1818 </span><span class="lineNoCov">          0 :         weight *= (1. - cInt) * (1. - cInt * cPhiInt)</span>
<span class="lineNum">    1819 </span><span class="lineNoCov">          0 :           / (1. + pow2(cInt) - 2. * cInt * cPhiInt);</span>
<span class="lineNum">    1820 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1821 </span><span class="lineNoCov">          0 :     } while (weight &lt; rndmPtr-&gt;flat());</span>
<span class="lineNum">    1822 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1823 </span>            : 
<span class="lineNum">    1824 </span>            :   // Include rotation -phi on boost to old rest frame.
<span class="lineNum">    1825 </span><span class="lineNoCov">          0 :   Mtot.rot(0., -phi);</span>
<span class="lineNum">    1826 </span>            : 
<span class="lineNum">    1827 </span>            :   // Find boost from old rest frame to event cm frame.
<span class="lineNum">    1828 </span><span class="lineNoCov">          0 :   RotBstMatrix MfromRest;</span>
<span class="lineNum">    1829 </span>            :   // The boost to the new rest frame.
<span class="lineNum">    1830 </span><span class="lineNoCov">          0 :   Vec4 sumNew       = pMother + pNewRec;</span>
<span class="lineNum">    1831 </span><span class="lineNoCov">          0 :   double betaX      = sumNew.px() / sumNew.e();</span>
<span class="lineNum">    1832 </span><span class="lineNoCov">          0 :   double betaZ      = sumNew.pz() / sumNew.e();</span>
<span class="lineNum">    1833 </span><span class="lineNoCov">          0 :   MfromRest.bst( -betaX, 0., -betaZ);</span>
<span class="lineNum">    1834 </span>            :   // Alignment of  radiator + recoiler to +- z axis, and rotation +phi.
<span class="lineNum">    1835 </span>            :   // Note: with spacelike (E &lt; 0) recoiler p'_x_mother &lt; 0 can happen!
<span class="lineNum">    1836 </span><span class="lineNoCov">          0 :   pMother.rotbst(MfromRest);</span>
<span class="lineNum">    1837 </span><span class="lineNoCov">          0 :   double theta = pMother.theta();</span>
<span class="lineNum">    1838 </span><span class="lineNoCov">          0 :   if (pMother.px() &lt; 0.) theta = -theta;</span>
<span class="lineNum">    1839 </span><span class="lineNoCov">          0 :   if (side == 2) theta += M_PI;</span>
<span class="lineNum">    1840 </span><span class="lineNoCov">          0 :   MfromRest.rot(-theta, phi);</span>
<span class="lineNum">    1841 </span>            :   // Boost to radiator + recoiler in event cm frame.
<span class="lineNum">    1842 </span><span class="lineNoCov">          0 :   if (normalRecoil) {</span>
<span class="lineNum">    1843 </span><span class="lineNoCov">          0 :     MfromRest.bst( 0., 0., (x1New - x2New) / (x1New + x2New) );</span>
<span class="lineNum">    1844 </span><span class="lineNoCov">          0 :   } else if (side == 1) {</span>
<span class="lineNum">    1845 </span><span class="lineNoCov">          0 :     Vec4 pMotherWanted( 0., 0.,  0.5 * eCM * x1New, 0.5 * eCM * x1New);</span>
<span class="lineNum">    1846 </span><span class="lineNoCov">          0 :     MfromRest.fromCMframe( pMotherWanted, event[iRecoiler].p() );</span>
<span class="lineNum">    1847 </span>            : 
<span class="lineNum">    1848 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">    1849 </span><span class="lineNoCov">          0 :     Vec4 pMotherWanted( 0., 0., -0.5 * eCM * x2New, 0.5 * eCM * x2New);</span>
<span class="lineNum">    1850 </span><span class="lineNoCov">          0 :     MfromRest.fromCMframe( event[iRecoiler].p(), pMotherWanted );</span>
<span class="lineNum">    1851 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1852 </span><span class="lineNoCov">          0 :   Mtot.rotbst(MfromRest);</span>
<span class="lineNum">    1853 </span>            : 
<span class="lineNum">    1854 </span>            :   // ME correction for weak emissions in the t-channel.
<span class="lineNum">    1855 </span>            :   double wt;
<span class="lineNum">    1856 </span><span class="lineNoCov">          0 :   if (MEtype == 201 || MEtype == 202 || MEtype == 203 ||</span>
<span class="lineNum">    1857 </span><span class="lineNoCov">          0 :       MEtype == 206 || MEtype == 207 || MEtype == 208) {</span>
<span class="lineNum">    1858 </span>            : 
<span class="lineNum">    1859 </span>            :     // Start by finding the correct outgoing particles
<span class="lineNum">    1860 </span>            :     // to use in the ME correction.
<span class="lineNum">    1861 </span><span class="lineNoCov">          0 :     Vec4 pA0     = mother.p();</span>
<span class="lineNum">    1862 </span><span class="lineNoCov">          0 :     Vec4 pB      = newRecoiler.p();</span>
<span class="lineNum">    1863 </span><span class="lineNoCov">          0 :     bool sideRad = (abs(side) == 1);</span>
<span class="lineNum">    1864 </span><span class="lineNoCov">          0 :     Vec4 p1      = event[5].p();</span>
<span class="lineNum">    1865 </span><span class="lineNoCov">          0 :     Vec4 p2      = event[6].p();</span>
<span class="lineNum">    1866 </span><span class="lineNoCov">          0 :     int id1      = event[5].id();</span>
<span class="lineNum">    1867 </span><span class="lineNoCov">          0 :     int id2      = event[6].id();</span>
<span class="lineNum">    1868 </span><span class="lineNoCov">          0 :     if (!tChannel) {swap(p1,p2); swap(id1,id2);}</span>
<span class="lineNum">    1869 </span><span class="lineNoCov">          0 :     if (!sideRad)  {swap(p1,p2); swap(id1,id2);}</span>
<span class="lineNum">    1870 </span>            : 
<span class="lineNum">    1871 </span>            :     // Rotate with -phi to keep correct for the later +phi rotation.
<span class="lineNum">    1872 </span><span class="lineNoCov">          0 :     p1.rot(0., -phi);</span>
<span class="lineNum">    1873 </span><span class="lineNoCov">          0 :     p2.rot(0., -phi);</span>
<span class="lineNum">    1874 </span>            : 
<span class="lineNum">    1875 </span>            :     // Calculate the actual weight.
<span class="lineNum">    1876 </span><span class="lineNoCov">          0 :     wt = calcMEcorrWeak(MEtype, m2, z, pT2, pA0, pB,</span>
<span class="lineNum">    1877 </span><span class="lineNoCov">          0 :       event[iDaughter].p(), event[iRecoiler].p(), p1, p2, sister.p());</span>
<span class="lineNum">    1878 </span><span class="lineNoCov">          0 :     if (wt &gt; weakMaxWt) {</span>
<span class="lineNum">    1879 </span><span class="lineNoCov">          0 :       weakMaxWt = wt;</span>
<span class="lineNum">    1880 </span><span class="lineNoCov">          0 :       infoPtr-&gt;errorMsg(&quot;Warning in SpaceShower::Branch: &quot;</span>
<span class="lineNum">    1881 </span>            :                         &quot;weight is above unity for weak emission.&quot;);
<span class="lineNum">    1882 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1883 </span>            : 
<span class="lineNum">    1884 </span>            :     // If weighting fails then restore event record to state before emission.
<span class="lineNum">    1885 </span><span class="lineNoCov">          0 :     if (wt &lt; rndmPtr-&gt;flat()) {</span>
<span class="lineNum">    1886 </span><span class="lineNoCov">          0 :       event.popBack( event.size() - eventSizeOld);</span>
<span class="lineNum">    1887 </span><span class="lineNoCov">          0 :       event[beamOff1].daughter1( ev1Dau1V);</span>
<span class="lineNum">    1888 </span><span class="lineNoCov">          0 :       event[beamOff2].daughter1( ev2Dau1V);</span>
<span class="lineNum">    1889 </span><span class="lineNoCov">          0 :       for ( int iCopy = 0; iCopy &lt; systemSizeOld; ++iCopy) {</span>
<span class="lineNum">    1890 </span><span class="lineNoCov">          0 :         int iOldCopy = partonSystemsPtr-&gt;getAll(iSysSel, iCopy);</span>
<span class="lineNum">    1891 </span><span class="lineNoCov">          0 :         event[iOldCopy].status( statusV[iCopy]);</span>
<span class="lineNum">    1892 </span><span class="lineNoCov">          0 :         event[iOldCopy].mothers( mother1V[iCopy], mother2V[iCopy]);</span>
<span class="lineNum">    1893 </span><span class="lineNoCov">          0 :         event[iOldCopy].daughters( daughter1V[iCopy], daughter2V[iCopy]);</span>
<span class="lineNum">    1894 </span>            :       }
<span class="lineNum">    1895 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    1896 </span>            :     }
<span class="lineNum">    1897 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1898 </span>            : 
<span class="lineNum">    1899 </span>            :   // Perform cumulative rotation/boost operation.
<span class="lineNum">    1900 </span>            :   // Mother, recoiler and sister from old rest frame to event cm frame.
<span class="lineNum">    1901 </span><span class="lineNoCov">          0 :   mother.rotbst(MfromRest);</span>
<span class="lineNum">    1902 </span><span class="lineNoCov">          0 :   newRecoiler.rotbst(MfromRest);</span>
<span class="lineNum">    1903 </span><span class="lineNoCov">          0 :   sister.rotbst(MfromRest);</span>
<span class="lineNum">    1904 </span>            :   // The rest from (and to) event cm frame.
<span class="lineNum">    1905 </span><span class="lineNoCov">          0 :   for ( int i = eventSizeOld + 2; i &lt; eventSizeOld + systemSizeOld; ++i)</span>
<span class="lineNum">    1906 </span><span class="lineNoCov">          0 :     event[i].rotbst(Mtot);</span>
<span class="lineNum">    1907 </span>            : 
<span class="lineNum">    1908 </span>            :   // Remove double counting. Only implemented for QCD hard processes
<span class="lineNum">    1909 </span>            :   // and for the first emission.
<span class="lineNum">    1910 </span><span class="lineNoCov">          0 :   if (infoPtr-&gt;nISR() + infoPtr-&gt;nFSRinProc() == 0</span>
<span class="lineNum">    1911 </span><span class="lineNoCov">          0 :       &amp;&amp; infoPtr-&gt;code() &gt; 110 &amp;&amp; infoPtr-&gt;code() &lt; 130</span>
<span class="lineNum">    1912 </span><span class="lineNoCov">          0 :       &amp;&amp; MEtype &gt;= 200 &amp;&amp; MEtype &lt; 210 &amp;&amp; vetoWeakJets) {</span>
<span class="lineNum">    1913 </span>            : 
<span class="lineNum">    1914 </span>            :     // Find outgoing particles.
<span class="lineNum">    1915 </span><span class="lineNoCov">          0 :     int iP1 = event[5].daughter1();</span>
<span class="lineNum">    1916 </span><span class="lineNoCov">          0 :     int iP2 = event[6].daughter1();</span>
<span class="lineNum">    1917 </span><span class="lineNoCov">          0 :     Vec4 pP1 = event[iP1].p();</span>
<span class="lineNum">    1918 </span><span class="lineNoCov">          0 :     Vec4 pP2 = event[iP2].p();</span>
<span class="lineNum">    1919 </span>            : 
<span class="lineNum">    1920 </span>            :     // Set start pT2 as pT2 of emitted particle and therefore no cut.
<span class="lineNum">    1921 </span><span class="lineNoCov">          0 :     double d = sister.pT2();</span>
<span class="lineNum">    1922 </span>            :     bool cut = false;
<span class="lineNum">    1923 </span>            : 
<span class="lineNum">    1924 </span><span class="lineNoCov">          0 :     if (pP1.pT2() &lt; d) {d = pP1.pT2(); cut = true;}</span>
<span class="lineNum">    1925 </span><span class="lineNoCov">          0 :     if (pP2.pT2() &lt; d) {d = pP2.pT2(); cut = true;}</span>
<span class="lineNum">    1926 </span>            : 
<span class="lineNum">    1927 </span>            :     // Check for angle between weak boson and quarks
<span class="lineNum">    1928 </span>            :     // (require final state particle to be a fermion).
<span class="lineNum">    1929 </span><span class="lineNoCov">          0 :     if (event[iP1].idAbs() &lt; 20) {</span>
<span class="lineNum">    1930 </span><span class="lineNoCov">          0 :       double dij = min(pP1.pT2(),sister.pT2())</span>
<span class="lineNum">    1931 </span><span class="lineNoCov">          0 :         * pow2(RRapPhi(pP1,sister.p()))/vetoWeakDeltaR2;</span>
<span class="lineNum">    1932 </span><span class="lineNoCov">          0 :       if (dij &lt; d) {</span>
<span class="lineNum">    1933 </span>            :         d = dij;
<span class="lineNum">    1934 </span>            :         cut = false;
<span class="lineNum">    1935 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1936 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1937 </span>            : 
<span class="lineNum">    1938 </span><span class="lineNoCov">          0 :     if (event[iP2].idAbs() &lt; 20) {</span>
<span class="lineNum">    1939 </span><span class="lineNoCov">          0 :        double dij = min(pP2.pT2(),sister.pT2())</span>
<span class="lineNum">    1940 </span><span class="lineNoCov">          0 :          * pow2(RRapPhi(pP2,sister.p()))/vetoWeakDeltaR2;</span>
<span class="lineNum">    1941 </span><span class="lineNoCov">          0 :       if (dij &lt; d) {</span>
<span class="lineNum">    1942 </span>            :         d = dij;
<span class="lineNum">    1943 </span>            :         cut = false;
<span class="lineNum">    1944 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1945 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1946 </span>            : 
<span class="lineNum">    1947 </span>            :     // Check for angle between recoiler and radiator, if quark anti-quark pair,
<span class="lineNum">    1948 </span>            :     // or if the recoiler is a gluon.
<span class="lineNum">    1949 </span><span class="lineNoCov">          0 :     if (event[iP1].idAbs() == 21 || event[iP2].idAbs() == 21 ||</span>
<span class="lineNum">    1950 </span><span class="lineNoCov">          0 :         event[iP1].id() == - event[iP2].id()) {</span>
<span class="lineNum">    1951 </span><span class="lineNoCov">          0 :       double dij = min(pP1.pT2(),pP2.pT2())</span>
<span class="lineNum">    1952 </span><span class="lineNoCov">          0 :         * pow2(RRapPhi(pP1,pP2))/vetoWeakDeltaR2;</span>
<span class="lineNum">    1953 </span><span class="lineNoCov">          0 :       if (dij &lt; d) {</span>
<span class="lineNum">    1954 </span>            :         d = dij;
<span class="lineNum">    1955 </span>            :         cut = true;
<span class="lineNum">    1956 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1957 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1958 </span>            : 
<span class="lineNum">    1959 </span>            :     // Clean up event if the emission should be removed.
<span class="lineNum">    1960 </span><span class="lineNoCov">          0 :     if (cut) {</span>
<span class="lineNum">    1961 </span><span class="lineNoCov">          0 :       event.popBack( event.size() - eventSizeOld);</span>
<span class="lineNum">    1962 </span><span class="lineNoCov">          0 :       event[beamOff1].daughter1( ev1Dau1V);</span>
<span class="lineNum">    1963 </span><span class="lineNoCov">          0 :       event[beamOff2].daughter1( ev2Dau1V);</span>
<span class="lineNum">    1964 </span><span class="lineNoCov">          0 :       for ( int iCopy = 0; iCopy &lt; systemSizeOld; ++iCopy) {</span>
<span class="lineNum">    1965 </span><span class="lineNoCov">          0 :         int iOldCopy = partonSystemsPtr-&gt;getAll(iSysSel, iCopy);</span>
<span class="lineNum">    1966 </span><span class="lineNoCov">          0 :         event[iOldCopy].status( statusV[iCopy]);</span>
<span class="lineNum">    1967 </span><span class="lineNoCov">          0 :         event[iOldCopy].mothers( mother1V[iCopy], mother2V[iCopy]);</span>
<span class="lineNum">    1968 </span><span class="lineNoCov">          0 :         event[iOldCopy].daughters( daughter1V[iCopy], daughter2V[iCopy]);</span>
<span class="lineNum">    1969 </span>            :       }
<span class="lineNum">    1970 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    1971 </span>            :     }
<span class="lineNum">    1972 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1973 </span>            : 
<span class="lineNum">    1974 </span>            :   // Allow veto of branching. If so restore event record to before emission.
<span class="lineNum">    1975 </span><span class="lineNoCov">          0 :   if ( (canVetoEmission</span>
<span class="lineNum">    1976 </span><span class="lineNoCov">          0 :     &amp;&amp; userHooksPtr-&gt;doVetoISREmission(eventSizeOld, event, iSysSel))</span>
<span class="lineNum">    1977 </span><span class="lineNoCov">          0 :     || (canMergeFirst</span>
<span class="lineNum">    1978 </span><span class="lineNoCov">          0 :     &amp;&amp; mergingHooksPtr-&gt;doVetoEmission( event )) ) {</span>
<span class="lineNum">    1979 </span><span class="lineNoCov">          0 :     event.popBack( event.size() - eventSizeOld);</span>
<span class="lineNum">    1980 </span><span class="lineNoCov">          0 :     event[beamOff1].daughter1( ev1Dau1V);</span>
<span class="lineNum">    1981 </span><span class="lineNoCov">          0 :     event[beamOff2].daughter1( ev2Dau1V);</span>
<span class="lineNum">    1982 </span><span class="lineNoCov">          0 :     for ( int iCopy = 0; iCopy &lt; systemSizeOld; ++iCopy) {</span>
<span class="lineNum">    1983 </span><span class="lineNoCov">          0 :       int iOldCopy = partonSystemsPtr-&gt;getAll(iSysSel, iCopy);</span>
<span class="lineNum">    1984 </span><span class="lineNoCov">          0 :       event[iOldCopy].status( statusV[iCopy]);</span>
<span class="lineNum">    1985 </span><span class="lineNoCov">          0 :       event[iOldCopy].mothers( mother1V[iCopy], mother2V[iCopy]);</span>
<span class="lineNum">    1986 </span><span class="lineNoCov">          0 :       event[iOldCopy].daughters( daughter1V[iCopy], daughter2V[iCopy]);</span>
<span class="lineNum">    1987 </span>            :     }
<span class="lineNum">    1988 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1989 </span>            :   }
<span class="lineNum">    1990 </span>            : 
<span class="lineNum">    1991 </span>            :   // Update list of partons in system; adding newly produced one.
<span class="lineNum">    1992 </span><span class="lineNoCov">          0 :   partonSystemsPtr-&gt;setInA(iSysSel, eventSizeOld);</span>
<span class="lineNum">    1993 </span><span class="lineNoCov">          0 :   partonSystemsPtr-&gt;setInB(iSysSel, eventSizeOld + 1);</span>
<span class="lineNum">    1994 </span><span class="lineNoCov">          0 :   for (int iCopy = 2; iCopy &lt; systemSizeOld; ++iCopy)</span>
<span class="lineNum">    1995 </span><span class="lineNoCov">          0 :     partonSystemsPtr-&gt;setOut(iSysSel, iCopy - 2, eventSizeOld + iCopy);</span>
<span class="lineNum">    1996 </span><span class="lineNoCov">          0 :   partonSystemsPtr-&gt;addOut(iSysSel, eventSizeOld + systemSizeOld);</span>
<span class="lineNum">    1997 </span><span class="lineNoCov">          0 :   partonSystemsPtr-&gt;setSHat(iSysSel, m2 / z);</span>
<span class="lineNum">    1998 </span>            : 
<span class="lineNum">    1999 </span>            :   // Add dipoles for  q -&gt; g q, where the daughter is the gluon.
<span class="lineNum">    2000 </span><span class="lineNoCov">          0 :   if (idDaughter == 21 &amp;&amp; idMother != 21) {</span>
<span class="lineNum">    2001 </span><span class="lineNoCov">          0 :     if (doQEDshowerByQ) {</span>
<span class="lineNum">    2002 </span><span class="lineNoCov">          0 :       dipEnd.push_back( SpaceDipoleEnd( iSysSel, side, iMother,</span>
<span class="lineNum">    2003 </span><span class="lineNoCov">          0 :          iNewRecoiler, pT2, 0, mother.chargeType(), 0, 0, normalRecoil) );</span>
<span class="lineNum">    2004 </span>            :     }
<span class="lineNum">    2005 </span><span class="lineNoCov">          0 :     if (doWeakShower &amp;&amp; iSysSel == 0) {</span>
<span class="lineNum">    2006 </span>            :       int MEtypeNew = 203;
<span class="lineNum">    2007 </span><span class="lineNoCov">          0 :       if (idRecoiler == 21) MEtypeNew = 201;</span>
<span class="lineNum">    2008 </span><span class="lineNoCov">          0 :       if (idRecoiler == idMother) MEtypeNew = 202;</span>
<span class="lineNum">    2009 </span>            :       // If original was a Drell-Yan, keep as Drell-Yan.
<span class="lineNum">    2010 </span><span class="lineNoCov">          0 :       if( event[3].id() == - event[4].id()) MEtypeNew = 200;</span>
<span class="lineNum">    2011 </span><span class="lineNoCov">          0 :       int weakPol = (rndmPtr-&gt;flat() &gt; 0.5) ? -1 : 1;</span>
<span class="lineNum">    2012 </span><span class="lineNoCov">          0 :       event[iMother].pol(weakPol);</span>
<span class="lineNum">    2013 </span><span class="lineNoCov">          0 :       if ((weakMode == 0 || weakMode == 1) &amp;&amp; weakPol == -1)</span>
<span class="lineNum">    2014 </span><span class="lineNoCov">          0 :         dipEnd.push_back( SpaceDipoleEnd( iSysSel, side, iMother,</span>
<span class="lineNum">    2015 </span>            :          iNewRecoiler, pT2, 0, 0, 1, MEtypeNew, normalRecoil, weakPol) );
<span class="lineNum">    2016 </span><span class="lineNoCov">          0 :       if (weakMode == 0 || weakMode == 2)</span>
<span class="lineNum">    2017 </span><span class="lineNoCov">          0 :         dipEnd.push_back( SpaceDipoleEnd( iSysSel, side, iMother,</span>
<span class="lineNum">    2018 </span><span class="lineNoCov">          0 :          iNewRecoiler, pT2, 0, 0, 2, MEtypeNew + 5, normalRecoil, weakPol) );</span>
<span class="lineNum">    2019 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2020 </span>            :   }
<span class="lineNum">    2021 </span>            : 
<span class="lineNum">    2022 </span>            :   // Add dipoles for q -&gt; q gamma, where the daughter is the gamma.
<span class="lineNum">    2023 </span><span class="lineNoCov">          0 :   if (idDaughter == 22 &amp;&amp; idMother != 22) {</span>
<span class="lineNum">    2024 </span><span class="lineNoCov">          0 :     if (doQCDshower &amp;&amp; mother.colType() != 0) {</span>
<span class="lineNum">    2025 </span><span class="lineNoCov">          0 :       dipEnd.push_back( SpaceDipoleEnd( iSysSel, side, iMother,</span>
<span class="lineNum">    2026 </span><span class="lineNoCov">          0 :         iNewRecoiler, pT2, mother.colType(), 0, 0, 0, normalRecoil) );</span>
<span class="lineNum">    2027 </span>            :     }
<span class="lineNum">    2028 </span><span class="lineNoCov">          0 :     if (doQEDshowerByQ &amp;&amp; mother.chargeType() != 3) {</span>
<span class="lineNum">    2029 </span><span class="lineNoCov">          0 :       dipEnd.push_back( SpaceDipoleEnd( iSysSel, side, iMother,</span>
<span class="lineNum">    2030 </span><span class="lineNoCov">          0 :         iNewRecoiler, pT2, 0, mother.chargeType(), 0, 0, normalRecoil) );</span>
<span class="lineNum">    2031 </span>            :     }
<span class="lineNum">    2032 </span><span class="lineNoCov">          0 :     if (doQEDshowerByL &amp;&amp; mother.chargeType() == 3) {</span>
<span class="lineNum">    2033 </span><span class="lineNoCov">          0 :       dipEnd.push_back( SpaceDipoleEnd( iSysSel, side, iMother,</span>
<span class="lineNum">    2034 </span><span class="lineNoCov">          0 :          iNewRecoiler, pT2, 0, mother.chargeType(), 0, 0, normalRecoil) );</span>
<span class="lineNum">    2035 </span>            :     }
<span class="lineNum">    2036 </span><span class="lineNoCov">          0 :     if (doWeakShower &amp;&amp; iSysSel == 0) {</span>
<span class="lineNum">    2037 </span>            :       int MEtypeNew = 203;
<span class="lineNum">    2038 </span><span class="lineNoCov">          0 :       if (idRecoiler == 21) MEtypeNew = 201;</span>
<span class="lineNum">    2039 </span><span class="lineNoCov">          0 :       if (idRecoiler == idMother) MEtypeNew = 202;</span>
<span class="lineNum">    2040 </span>            :       // If original was a Drell-Yan, keep as Drell-Yan.
<span class="lineNum">    2041 </span><span class="lineNoCov">          0 :       if( event[3].id() == - event[4].id()) MEtypeNew = 200;</span>
<span class="lineNum">    2042 </span><span class="lineNoCov">          0 :       int weakPol = (rndmPtr-&gt;flat() &gt; 0.5) ? -1 : 1;</span>
<span class="lineNum">    2043 </span><span class="lineNoCov">          0 :       event[iMother].pol(weakPol);</span>
<span class="lineNum">    2044 </span><span class="lineNoCov">          0 :       if ((weakMode == 0 || weakMode == 1) &amp;&amp; weakPol == -1)</span>
<span class="lineNum">    2045 </span><span class="lineNoCov">          0 :         dipEnd.push_back( SpaceDipoleEnd( iSysSel, side, iMother,</span>
<span class="lineNum">    2046 </span>            :          iNewRecoiler, pT2, 0, 0, 1, MEtypeNew, normalRecoil, weakPol) );
<span class="lineNum">    2047 </span><span class="lineNoCov">          0 :       if (weakMode == 0 || weakMode == 2)</span>
<span class="lineNum">    2048 </span><span class="lineNoCov">          0 :         dipEnd.push_back( SpaceDipoleEnd( iSysSel, side, iMother,</span>
<span class="lineNum">    2049 </span><span class="lineNoCov">          0 :           iNewRecoiler, pT2, 0, 0, 2, MEtypeNew + 5, normalRecoil, weakPol) );</span>
<span class="lineNum">    2050 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2051 </span>            :   }
<span class="lineNum">    2052 </span>            : 
<span class="lineNum">    2053 </span>            :   // dipEnd array may have expanded and been moved, so regenerate dipEndSel.
<span class="lineNum">    2054 </span><span class="lineNoCov">          0 :   dipEndSel = &amp;dipEnd[iDipSel];</span>
<span class="lineNum">    2055 </span>            : 
<span class="lineNum">    2056 </span>            :   // Set flag to tell that a weak emission has happened.
<span class="lineNum">    2057 </span><span class="lineNoCov">          0 :   if (dipEndSel-&gt;weakType != 0) hasWeaklyRadiated = true;</span>
<span class="lineNum">    2058 </span>            : 
<span class="lineNum">    2059 </span>            :   // Update list of QCD emissions in side A and B in given iSysSel
<span class="lineNum">    2060 </span>            :   // This is used to veto jets in W/z events.
<span class="lineNum">    2061 </span><span class="lineNoCov">          0 :   while (iSysSel &gt;= int(nRadA.size()) || iSysSel &gt;= int(nRadB.size())) {</span>
<span class="lineNum">    2062 </span><span class="lineNoCov">          0 :     nRadA.push_back(0);</span>
<span class="lineNum">    2063 </span><span class="lineNoCov">          0 :     nRadB.push_back(0);</span>
<span class="lineNum">    2064 </span>            :   }
<span class="lineNum">    2065 </span><span class="lineNoCov">          0 :   if (dipEndSel-&gt;colType != 0 &amp;&amp; side == 1) ++nRadA[iSysSel];</span>
<span class="lineNum">    2066 </span><span class="lineNoCov">          0 :   else if (dipEndSel-&gt;colType != 0) ++nRadB[iSysSel];</span>
<span class="lineNum">    2067 </span>            : 
<span class="lineNum">    2068 </span>            :   // Update info on radiating dipole ends (QCD, QED or weak).
<span class="lineNum">    2069 </span><span class="lineNoCov">          0 :   for (int iDip = 0; iDip &lt; int(dipEnd.size()); ++iDip)</span>
<span class="lineNum">    2070 </span><span class="lineNoCov">          0 :   if ( dipEnd[iDip].system == iSysSel) {</span>
<span class="lineNum">    2071 </span><span class="lineNoCov">          0 :     if (abs(dipEnd[iDip].side) == side) {</span>
<span class="lineNum">    2072 </span><span class="lineNoCov">          0 :       dipEnd[iDip].iRadiator = iMother;</span>
<span class="lineNum">    2073 </span><span class="lineNoCov">          0 :       dipEnd[iDip].iRecoiler = iNewRecoiler;</span>
<span class="lineNum">    2074 </span><span class="lineNoCov">          0 :       if (dipEnd[iDip].colType  != 0)</span>
<span class="lineNum">    2075 </span><span class="lineNoCov">          0 :         dipEnd[iDip].colType = mother.colType();</span>
<span class="lineNum">    2076 </span><span class="lineNoCov">          0 :       else if (dipEnd[iDip].chgType != 0) {</span>
<span class="lineNum">    2077 </span><span class="lineNoCov">          0 :         dipEnd[iDip].chgType = 0;</span>
<span class="lineNum">    2078 </span><span class="lineNoCov">          0 :         if ( (mother.isQuark() &amp;&amp; doQEDshowerByQ)</span>
<span class="lineNum">    2079 </span><span class="lineNoCov">          0 :           || (mother.isLepton() &amp;&amp; doQEDshowerByL) )</span>
<span class="lineNum">    2080 </span><span class="lineNoCov">          0 :           dipEnd[iDip].chgType = mother.chargeType();</span>
<span class="lineNum">    2081 </span>            :       }
<span class="lineNum">    2082 </span><span class="lineNoCov">          0 :       else if (dipEnd[iDip].weakType != 0) {</span>
<span class="lineNum">    2083 </span>            :         // Kill weak dipole if mother becomes gluon / photon.
<span class="lineNum">    2084 </span><span class="lineNoCov">          0 :         if (!(mother.isLepton() || mother.isQuark()))</span>
<span class="lineNum">    2085 </span><span class="lineNoCov">          0 :           dipEnd[iDip].weakType = 0;</span>
<span class="lineNum">    2086 </span><span class="lineNoCov">          0 :         if (singleWeakEmission &amp;&amp; hasWeaklyRadiated)</span>
<span class="lineNum">    2087 </span><span class="lineNoCov">          0 :           dipEnd[iDip].weakType = 0;</span>
<span class="lineNum">    2088 </span>            :       }
<span class="lineNum">    2089 </span>            : 
<span class="lineNum">    2090 </span>            :       // Kill ME corrections after first emission for everything
<span class="lineNum">    2091 </span>            :       // but weak showers.
<span class="lineNum">    2092 </span><span class="lineNoCov">          0 :       if (dipEnd[iDip].weakType == 0) dipEnd[iDip].MEtype = 0;</span>
<span class="lineNum">    2093 </span>            : 
<span class="lineNum">    2094 </span>            :     // Update info on recoiling dipole ends (QCD or QED).
<span class="lineNum">    2095 </span>            :     } else {
<span class="lineNum">    2096 </span><span class="lineNoCov">          0 :       dipEnd[iDip].iRadiator = iNewRecoiler;</span>
<span class="lineNum">    2097 </span><span class="lineNoCov">          0 :       dipEnd[iDip].iRecoiler = iMother;</span>
<span class="lineNum">    2098 </span>            :       // Optionally also kill recoiler ME corrections after first emission.
<span class="lineNum">    2099 </span><span class="lineNoCov">          0 :       if (!doMEafterFirst &amp;&amp; dipEnd[iDip].weakType == 0)</span>
<span class="lineNum">    2100 </span><span class="lineNoCov">          0 :         dipEnd[iDip].MEtype = 0;</span>
<span class="lineNum">    2101 </span>            :       // Remove weak dipoles if we only want a single emission.
<span class="lineNum">    2102 </span><span class="lineNoCov">          0 :       if (dipEnd[iDip].weakType != 0 &amp;&amp; singleWeakEmission</span>
<span class="lineNum">    2103 </span><span class="lineNoCov">          0 :         &amp;&amp; hasWeaklyRadiated) dipEnd[iDip].weakType = 0;</span>
<span class="lineNum">    2104 </span>            :     }
<span class="lineNum">    2105 </span>            :   }
<span class="lineNum">    2106 </span>            : 
<span class="lineNum">    2107 </span>            :   // Set polarisation of mother for weak emissions.
<span class="lineNum">    2108 </span><span class="lineNoCov">          0 :   if (dipEndSel-&gt;weakType != 0) mother.pol(dipEndSel-&gt;weakPol);</span>
<span class="lineNum">    2109 </span>            : 
<span class="lineNum">    2110 </span>            :   // Update info on beam remnants.
<span class="lineNum">    2111 </span><span class="lineNoCov">          0 :   BeamParticle&amp; beamNow = (side == 1) ? *beamAPtr : *beamBPtr;</span>
<span class="lineNum">    2112 </span><span class="lineNoCov">          0 :   double xNew = (side == 1) ? x1New : x2New;</span>
<span class="lineNum">    2113 </span><span class="lineNoCov">          0 :   beamNow[iSysSel].update( iMother, idMother, xNew);</span>
<span class="lineNum">    2114 </span>            :   // Redo choice of companion kind whenever new flavour.
<span class="lineNum">    2115 </span><span class="lineNoCov">          0 :   if (idMother != idDaughterNow) {</span>
<span class="lineNum">    2116 </span><span class="lineNoCov">          0 :     pdfScale2 = (useFixedFacScale) ? fixedFacScale2 : factorMultFac * pT2;</span>
<span class="lineNum">    2117 </span><span class="lineNoCov">          0 :     beamNow.xfISR( iSysSel, idMother, xNew, pdfScale2);</span>
<span class="lineNum">    2118 </span><span class="lineNoCov">          0 :     beamNow.pickValSeaComp();</span>
<span class="lineNum">    2119 </span>            :   }
<span class="lineNum">    2120 </span><span class="lineNoCov">          0 :   BeamParticle&amp; beamRec = (side == 1) ? *beamBPtr : *beamAPtr;</span>
<span class="lineNum">    2121 </span><span class="lineNoCov">          0 :   beamRec[iSysSel].iPos( iNewRecoiler);</span>
<span class="lineNum">    2122 </span>            : 
<span class="lineNum">    2123 </span>            :   // Store branching values of current dipole. (For rapidity ordering.)
<span class="lineNum">    2124 </span><span class="lineNoCov">          0 :   ++dipEndSel-&gt;nBranch;</span>
<span class="lineNum">    2125 </span><span class="lineNoCov">          0 :   dipEndSel-&gt;pT2Old = pT2;</span>
<span class="lineNum">    2126 </span><span class="lineNoCov">          0 :   dipEndSel-&gt;zOld   = z;</span>
<span class="lineNum">    2127 </span>            : 
<span class="lineNum">    2128 </span>            :   // Update history if recoiler rescatters.
<span class="lineNum">    2129 </span><span class="lineNoCov">          0 :   if (!normalRecoil)</span>
<span class="lineNum">    2130 </span><span class="lineNoCov">          0 :     event[iRecoilMother].daughters( iNewRecoiler, iNewRecoiler);</span>
<span class="lineNum">    2131 </span>            : 
<span class="lineNum">    2132 </span>            :   // Start list of rescatterers that force changed kinematics.
<span class="lineNum">    2133 </span><span class="lineNoCov">          0 :   vector&lt;int&gt; iRescatterer;</span>
<span class="lineNum">    2134 </span><span class="lineNoCov">          0 :   for ( int i = 0; i &lt; systemSizeOld - 2; ++i) {</span>
<span class="lineNum">    2135 </span><span class="lineNoCov">          0 :     int iOutNew = partonSystemsPtr-&gt;getOut( iSysSel, i);</span>
<span class="lineNum">    2136 </span><span class="lineNoCov">          0 :     if (!event[iOutNew].isFinal()) iRescatterer.push_back(iOutNew);</span>
<span class="lineNum">    2137 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2138 </span>            : 
<span class="lineNum">    2139 </span>            :   // Start iterate over list of such rescatterers.
<span class="lineNum">    2140 </span>            :   int iRescNow = -1;
<span class="lineNum">    2141 </span><span class="lineNoCov">          0 :   while (++iRescNow &lt; int(iRescatterer.size())) {</span>
<span class="lineNum">    2142 </span>            : 
<span class="lineNum">    2143 </span>            :     // Identify partons that induce or are affected by rescatter shift.
<span class="lineNum">    2144 </span>            :     // In following Old is before change of kinematics, New after,
<span class="lineNum">    2145 </span>            :     // Out scatterer in outstate and In in instate of another system.
<span class="lineNum">    2146 </span>            :     // Daughter sequence is (iOutOld -&gt;) iOutNew -&gt; iInNew -&gt; iInOld.
<span class="lineNum">    2147 </span><span class="lineNoCov">          0 :     int iOutNew    = iRescatterer[iRescNow];</span>
<span class="lineNum">    2148 </span><span class="lineNoCov">          0 :     int iInOld     = event[iOutNew].daughter1();</span>
<span class="lineNum">    2149 </span><span class="lineNoCov">          0 :     int iSysResc   = partonSystemsPtr-&gt;getSystemOf(iInOld, true);</span>
<span class="lineNum">    2150 </span>            : 
<span class="lineNum">    2151 </span>            :     // Copy incoming partons of rescattered system and hook them up.
<span class="lineNum">    2152 </span><span class="lineNoCov">          0 :     int iOldA      = partonSystemsPtr-&gt;getInA(iSysResc);</span>
<span class="lineNum">    2153 </span><span class="lineNoCov">          0 :     int iOldB      = partonSystemsPtr-&gt;getInB(iSysResc);</span>
<span class="lineNum">    2154 </span><span class="lineNoCov">          0 :     bool rescSideA = event[iOldA].isRescatteredIncoming();</span>
<span class="lineNum">    2155 </span><span class="lineNoCov">          0 :     int statusNewA = (rescSideA) ? -45 : -42;</span>
<span class="lineNum">    2156 </span><span class="lineNoCov">          0 :     int statusNewB = (rescSideA) ? -42 : -45;</span>
<span class="lineNum">    2157 </span><span class="lineNoCov">          0 :     int iNewA      = event.copy(iOldA, statusNewA);</span>
<span class="lineNum">    2158 </span><span class="lineNoCov">          0 :     int iNewB      = event.copy(iOldB, statusNewB);</span>
<span class="lineNum">    2159 </span>            : 
<span class="lineNum">    2160 </span>            :     // Copy outgoing partons of rescattered system and hook them up.
<span class="lineNum">    2161 </span><span class="lineNoCov">          0 :     int eventSize  = event.size();</span>
<span class="lineNum">    2162 </span><span class="lineNoCov">          0 :     int sizeOutAB  = partonSystemsPtr-&gt;sizeOut(iSysResc);</span>
<span class="lineNum">    2163 </span><span class="lineNoCov">          0 :     int iOldAB, statusOldAB, iNewAB;</span>
<span class="lineNum">    2164 </span><span class="lineNoCov">          0 :     for (int iOutAB = 0; iOutAB &lt; sizeOutAB; ++iOutAB) {</span>
<span class="lineNum">    2165 </span><span class="lineNoCov">          0 :       iOldAB       = partonSystemsPtr-&gt;getOut(iSysResc, iOutAB);</span>
<span class="lineNum">    2166 </span><span class="lineNoCov">          0 :       statusOldAB  = event[iOldAB].status();</span>
<span class="lineNum">    2167 </span><span class="lineNoCov">          0 :       iNewAB       = event.copy(iOldAB, 44);</span>
<span class="lineNum">    2168 </span>            :       // Status could be negative for parton that rescatters in its turn.
<span class="lineNum">    2169 </span><span class="lineNoCov">          0 :       if (statusOldAB &lt; 0) {</span>
<span class="lineNum">    2170 </span><span class="lineNoCov">          0 :         event[iNewAB].statusNeg();</span>
<span class="lineNum">    2171 </span><span class="lineNoCov">          0 :         iRescatterer.push_back(iNewAB);</span>
<span class="lineNum">    2172 </span>            :       }
<span class="lineNum">    2173 </span>            :     }
<span class="lineNum">    2174 </span>            : 
<span class="lineNum">    2175 </span>            :     // Hook up new outgoing with new incoming parton.
<span class="lineNum">    2176 </span><span class="lineNoCov">          0 :     int iInNew     = (rescSideA) ? iNewA : iNewB;</span>
<span class="lineNum">    2177 </span><span class="lineNoCov">          0 :     event[iOutNew].daughters( iInNew, iInNew);</span>
<span class="lineNum">    2178 </span><span class="lineNoCov">          0 :     event[iInNew].mothers( iOutNew, iOutNew);</span>
<span class="lineNum">    2179 </span>            : 
<span class="lineNum">    2180 </span>            :     // Rescale recoiling incoming parton for correct invariant mass.
<span class="lineNum">    2181 </span><span class="lineNoCov">          0 :     event[iInNew].p( event[iOutNew].p() );</span>
<span class="lineNum">    2182 </span><span class="lineNoCov">          0 :     double momFac  = (rescSideA)</span>
<span class="lineNum">    2183 </span><span class="lineNoCov">          0 :                    ? event[iInOld].pPos() / event[iInNew].pPos()</span>
<span class="lineNum">    2184 </span><span class="lineNoCov">          0 :                    : event[iInOld].pNeg() / event[iInNew].pNeg();</span>
<span class="lineNum">    2185 </span><span class="lineNoCov">          0 :     int iInRec     = (rescSideA) ? iNewB : iNewA;</span>
<span class="lineNum">    2186 </span>            : 
<span class="lineNum">    2187 </span>            :     // Rescatter: A previous boost may cause the light cone momentum of a
<span class="lineNum">    2188 </span>            :     //            rescattered parton to change sign. If this happens, tell
<span class="lineNum">    2189 </span>            :     //            parton level to try again.
<span class="lineNum">    2190 </span><span class="lineNoCov">          0 :     if (momFac &lt; 0.0) {</span>
<span class="lineNum">    2191 </span><span class="lineNoCov">          0 :       infoPtr-&gt;errorMsg(&quot;Warning in SpaceShower::branch: &quot;</span>
<span class="lineNum">    2192 </span>            :       &quot;change in lightcone momentum sign; retrying parton level&quot;);
<span class="lineNum">    2193 </span><span class="lineNoCov">          0 :       rescatterFail = true;</span>
<span class="lineNum">    2194 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    2195 </span>            :     }
<span class="lineNum">    2196 </span><span class="lineNoCov">          0 :     event[iInRec].rescale4( momFac);</span>
<span class="lineNum">    2197 </span>            : 
<span class="lineNum">    2198 </span>            :     // Boost outgoing partons to new frame of incoming.
<span class="lineNum">    2199 </span><span class="lineNoCov">          0 :     RotBstMatrix MmodResc;</span>
<span class="lineNum">    2200 </span><span class="lineNoCov">          0 :     MmodResc.toCMframe(  event[iOldA].p(), event[iOldB].p());</span>
<span class="lineNum">    2201 </span><span class="lineNoCov">          0 :     MmodResc.fromCMframe(event[iNewA].p(), event[iNewB].p());</span>
<span class="lineNum">    2202 </span><span class="lineNoCov">          0 :     for (int iOutAB = 0; iOutAB &lt; sizeOutAB; ++iOutAB)</span>
<span class="lineNum">    2203 </span><span class="lineNoCov">          0 :       event[eventSize + iOutAB].rotbst(MmodResc);</span>
<span class="lineNum">    2204 </span>            : 
<span class="lineNum">    2205 </span>            :     // Update list of partons in system.
<span class="lineNum">    2206 </span><span class="lineNoCov">          0 :     partonSystemsPtr-&gt;setInA(iSysResc, iNewA);</span>
<span class="lineNum">    2207 </span><span class="lineNoCov">          0 :     partonSystemsPtr-&gt;setInB(iSysResc, iNewB);</span>
<span class="lineNum">    2208 </span><span class="lineNoCov">          0 :     for (int iCopy = 0; iCopy &lt; sizeOutAB; ++iCopy)</span>
<span class="lineNum">    2209 </span><span class="lineNoCov">          0 :       partonSystemsPtr-&gt;setOut(iSysResc, iCopy, eventSize + iCopy);</span>
<span class="lineNum">    2210 </span>            : 
<span class="lineNum">    2211 </span>            :     // Update info on radiating dipole ends (QCD or QED).
<span class="lineNum">    2212 </span><span class="lineNoCov">          0 :     for (int iDip = 0; iDip &lt; int(dipEnd.size()); ++iDip)</span>
<span class="lineNum">    2213 </span><span class="lineNoCov">          0 :     if ( dipEnd[iDip].system == iSysResc) {</span>
<span class="lineNum">    2214 </span><span class="lineNoCov">          0 :       bool sideAnow = (abs(dipEnd[iDip].side) == 1);</span>
<span class="lineNum">    2215 </span><span class="lineNoCov">          0 :       dipEnd[iDip].iRadiator = (sideAnow) ? iNewA : iNewB;</span>
<span class="lineNum">    2216 </span><span class="lineNoCov">          0 :       dipEnd[iDip].iRecoiler = (sideAnow) ? iNewB : iNewA;</span>
<span class="lineNum">    2217 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2218 </span>            : 
<span class="lineNum">    2219 </span>            :     // Update info on beam remnants.
<span class="lineNum">    2220 </span><span class="lineNoCov">          0 :     BeamParticle&amp; beamResc = (rescSideA) ? *beamAPtr : *beamBPtr;</span>
<span class="lineNum">    2221 </span><span class="lineNoCov">          0 :     beamResc[iSysResc].iPos( iInNew);</span>
<span class="lineNum">    2222 </span><span class="lineNoCov">          0 :     beamResc[iSysResc].p( event[iInNew].p() );</span>
<span class="lineNum">    2223 </span><span class="lineNoCov">          0 :     beamResc[iSysResc].scaleX( 1. / momFac  );</span>
<span class="lineNum">    2224 </span><span class="lineNoCov">          0 :     BeamParticle&amp; beamReco = (rescSideA) ? *beamBPtr : *beamAPtr;</span>
<span class="lineNum">    2225 </span><span class="lineNoCov">          0 :     beamReco[iSysResc].iPos( iInRec);</span>
<span class="lineNum">    2226 </span><span class="lineNoCov">          0 :     beamReco[iSysResc].scaleX( momFac);</span>
<span class="lineNum">    2227 </span>            : 
<span class="lineNum">    2228 </span>            :   // End iterate over list of rescatterers.
<span class="lineNum">    2229 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2230 </span>            : 
<span class="lineNum">    2231 </span>            :   // Check that beam momentum not used up by rescattered-system boosts.
<span class="lineNum">    2232 </span><span class="lineNoCov">          0 :   if (beamAPtr-&gt;xMax(-1) &lt; 0.0 || beamBPtr-&gt;xMax(-1) &lt; 0.0) {</span>
<span class="lineNum">    2233 </span><span class="lineNoCov">          0 :     infoPtr-&gt;errorMsg(&quot;Warning in SpaceShower::branch: &quot;</span>
<span class="lineNum">    2234 </span>            :       &quot;used up beam momentum; retrying parton level&quot;);
<span class="lineNum">    2235 </span><span class="lineNoCov">          0 :     rescatterFail = true;</span>
<span class="lineNum">    2236 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2237 </span>            :   }
<span class="lineNum">    2238 </span>            : 
<span class="lineNum">    2239 </span>            :   // Done without any errors.
<span class="lineNum">    2240 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    2241 </span>            : 
<span class="lineNum">    2242 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2243 </span>            : 
<span class="lineNum">    2244 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    2245 </span>            : 
<a name="2246"><span class="lineNum">    2246 </span>            : // Find class of ME correction.</a>
<span class="lineNum">    2247 </span>            : 
<span class="lineNum">    2248 </span>            :   int SpaceShower::findMEtype( int iSys, Event&amp; event, bool weakRadiation) {
<span class="lineNum">    2249 </span>            : 
<span class="lineNum">    2250 </span>            :   // Default values and no action.
<span class="lineNum">    2251 </span>            :   int MEtype = 0;
<span class="lineNum">    2252 </span><span class="lineNoCov">          0 :   if (!doMEcorrections) return MEtype;</span>
<span class="lineNum">    2253 </span>            : 
<span class="lineNum">    2254 </span>            :   // Identify systems producing a single resonance.
<span class="lineNum">    2255 </span><span class="lineNoCov">          0 :   if (partonSystemsPtr-&gt;sizeOut( iSys) == 1 &amp;&amp; !weakRadiation) {</span>
<span class="lineNum">    2256 </span><span class="lineNoCov">          0 :     int idIn1 = event[partonSystemsPtr-&gt;getInA(iSys)].id();</span>
<span class="lineNum">    2257 </span><span class="lineNoCov">          0 :     int idIn2 = event[partonSystemsPtr-&gt;getInA(iSys)].id();</span>
<span class="lineNum">    2258 </span><span class="lineNoCov">          0 :     int idRes = event[partonSystemsPtr-&gt;getOut(iSys, 0)].id();</span>
<span class="lineNum">    2259 </span><span class="lineNoCov">          0 :     if (iSys == 0) idResFirst  = abs(idRes);</span>
<span class="lineNum">    2260 </span><span class="lineNoCov">          0 :     if (iSys == 1) idResSecond = abs(idRes);</span>
<span class="lineNum">    2261 </span>            : 
<span class="lineNum">    2262 </span>            :     // f + fbar -&gt; vector boson.
<span class="lineNum">    2263 </span><span class="lineNoCov">          0 :     if ( (idRes == 23 || abs(idRes) == 24 || idRes == 32</span>
<span class="lineNum">    2264 </span><span class="lineNoCov">          0 :        || idRes == 33 || abs(idRes) == 34 || abs(idRes) == 41)</span>
<span class="lineNum">    2265 </span><span class="lineNoCov">          0 :        &amp;&amp; abs(idIn1) &lt; 20 &amp;&amp; abs(idIn2) &lt; 20 ) MEtype = 1;</span>
<span class="lineNum">    2266 </span>            : 
<span class="lineNum">    2267 </span>            :     // g + g, gamma + gamma  -&gt; Higgs boson.
<span class="lineNum">    2268 </span><span class="lineNoCov">          0 :     if ( (idRes == 25 || idRes == 35 || idRes == 36)</span>
<span class="lineNum">    2269 </span><span class="lineNoCov">          0 :       &amp;&amp; ( ( idIn1 == 21 &amp;&amp; idIn2 == 21 )</span>
<span class="lineNum">    2270 </span><span class="lineNoCov">          0 :         || ( idIn1 == 22 &amp;&amp; idIn2 == 22 ) ) ) MEtype = 2;</span>
<span class="lineNum">    2271 </span>            : 
<span class="lineNum">    2272 </span>            :     // f + fbar  -&gt; Higgs boson.
<span class="lineNum">    2273 </span><span class="lineNoCov">          0 :     if ( (idRes == 25 || idRes == 35 || idRes == 36)</span>
<span class="lineNum">    2274 </span><span class="lineNoCov">          0 :       &amp;&amp; abs(idIn1) &lt; 20 &amp;&amp; abs(idIn2) &lt; 20 ) MEtype = 3;</span>
<span class="lineNum">    2275 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2276 </span>            : 
<span class="lineNum">    2277 </span>            :   // Weak ME corrections.
<span class="lineNum">    2278 </span><span class="lineNoCov">          0 :   if (weakRadiation) {</span>
<span class="lineNum">    2279 </span><span class="lineNoCov">          0 :     if (event[3].id() == -event[4].id()</span>
<span class="lineNum">    2280 </span><span class="lineNoCov">          0 :      || event[event[3].daughter1()].idAbs() == 24 || infoPtr-&gt;nFinal() != 2)</span>
<span class="lineNum">    2281 </span><span class="lineNoCov">          0 :          MEtype = 200;</span>
<span class="lineNum">    2282 </span><span class="lineNoCov">          0 :     else if (event[3].idAbs() == 21 || event[4].idAbs() == 21) MEtype = 201;</span>
<span class="lineNum">    2283 </span><span class="lineNoCov">          0 :     else if (event[3].id() == event[4].id()) MEtype = 202;</span>
<span class="lineNum">    2284 </span>            :     else MEtype = 203;
<span class="lineNum">    2285 </span>            :   }
<span class="lineNum">    2286 </span>            : 
<span class="lineNum">    2287 </span>            :   // Done.
<span class="lineNum">    2288 </span><span class="lineNoCov">          0 :   return MEtype;</span>
<span class="lineNum">    2289 </span>            : 
<span class="lineNum">    2290 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2291 </span>            : 
<span class="lineNum">    2292 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    2293 </span>            : 
<a name="2294"><span class="lineNum">    2294 </span>            : // Provide maximum of expected ME weight; for preweighting of evolution.</a>
<span class="lineNum">    2295 </span>            : 
<span class="lineNum">    2296 </span>            : double SpaceShower::calcMEmax( int MEtype, int idMother, int idDaughterIn) {
<span class="lineNum">    2297 </span>            : 
<span class="lineNum">    2298 </span>            :   // Main non-unity case: g(gamma) f -&gt; V f'.
<span class="lineNum">    2299 </span><span class="lineNoCov">          0 :   if (MEtype == 1 &amp;&amp; idMother &gt; 20 &amp;&amp; idDaughterIn &lt; 20) return 3.;</span>
<span class="lineNum">    2300 </span>            : 
<span class="lineNum">    2301 </span>            :   // Added a case for t-channel W/Z exchange, since the PS is not an
<span class="lineNum">    2302 </span>            :   // overestimate. This does not help fully, but it should only be small
<span class="lineNum">    2303 </span>            :   // pT quarks / gluons that break the overscattering.
<span class="lineNum">    2304 </span><span class="lineNoCov">          0 :   if ( MEtype == 201 || MEtype == 202 || MEtype == 203</span>
<span class="lineNum">    2305 </span><span class="lineNoCov">          0 :     || MEtype == 206 || MEtype == 207 || MEtype == 208) return WEAKPSWEIGHT;</span>
<span class="lineNum">    2306 </span>            : 
<span class="lineNum">    2307 </span>            :   // Default.
<span class="lineNum">    2308 </span><span class="lineNoCov">          0 :   return 1.;</span>
<span class="lineNum">    2309 </span>            : 
<span class="lineNum">    2310 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2311 </span>            : 
<span class="lineNum">    2312 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    2313 </span>            : 
<span class="lineNum">    2314 </span>            : // Provide actual ME weight for current branching.
<span class="lineNum">    2315 </span>            : // Note: currently ME corrections are only allowed for first branching
<a name="2316"><span class="lineNum">    2316 </span>            : // on each side, so idDaughter is essentially known and checks overkill.</a>
<span class="lineNum">    2317 </span>            : 
<span class="lineNum">    2318 </span>            : double SpaceShower::calcMEcorr(int MEtype, int idMother, int idDaughterIn,
<span class="lineNum">    2319 </span>            :   double M2, double z, double Q2, double m2Sister) {
<span class="lineNum">    2320 </span>            : 
<span class="lineNum">    2321 </span>            :   // Convert to Mandelstam variables. Sometimes may need to swap later.
<span class="lineNum">    2322 </span><span class="lineNoCov">          0 :   double sH = M2 / z;</span>
<span class="lineNum">    2323 </span><span class="lineNoCov">          0 :   double tH = -Q2;</span>
<span class="lineNum">    2324 </span><span class="lineNoCov">          0 :   double uH = Q2 - M2 * (1. - z) / z;</span>
<span class="lineNum">    2325 </span><span class="lineNoCov">          0 :   int idMabs = abs(idMother);</span>
<span class="lineNum">    2326 </span><span class="lineNoCov">          0 :   int idDabs = abs(idDaughterIn);</span>
<span class="lineNum">    2327 </span>            : 
<span class="lineNum">    2328 </span>            :   // Corrections for f + fbar -&gt; s-channel vector boson.
<span class="lineNum">    2329 </span><span class="lineNoCov">          0 :   if (MEtype == 1) {</span>
<span class="lineNum">    2330 </span><span class="lineNoCov">          0 :     if (idMabs &lt; 20 &amp;&amp; idDabs &lt; 20) {</span>
<span class="lineNum">    2331 </span><span class="lineNoCov">          0 :       return (tH*tH + uH*uH + 2. * M2 * sH) / (sH*sH + M2*M2);</span>
<span class="lineNum">    2332 </span><span class="lineNoCov">          0 :     } else if (idDabs &lt; 20) {</span>
<span class="lineNum">    2333 </span>            :       // g(gamma) f -&gt; V f': -Q2 = (p_g - p_f')^2 in PS while
<span class="lineNum">    2334 </span>            :       // tHat = (p_f - p_f')^2 in ME so need to swap tHat &lt;-&gt; uHat.
<span class="lineNum">    2335 </span><span class="lineNoCov">          0 :       swap( tH, uH);</span>
<span class="lineNum">    2336 </span><span class="lineNoCov">          0 :       return (sH*sH + uH*uH + 2. * M2 * tH) / (pow2(sH - M2) + M2*M2);</span>
<span class="lineNum">    2337 </span>            :     }
<span class="lineNum">    2338 </span>            : 
<span class="lineNum">    2339 </span>            :   // Corrections for g + g -&gt; Higgs boson.
<span class="lineNum">    2340 </span><span class="lineNoCov">          0 :   } else if (MEtype == 2) {</span>
<span class="lineNum">    2341 </span><span class="lineNoCov">          0 :     if (idMabs &lt; 20 &amp;&amp; idDabs &gt; 20) {</span>
<span class="lineNum">    2342 </span><span class="lineNoCov">          0 :       return (sH*sH + uH*uH) / (sH*sH + pow2(sH - M2));</span>
<span class="lineNum">    2343 </span><span class="lineNoCov">          0 :     } else if (idDabs &gt; 20) {</span>
<span class="lineNum">    2344 </span><span class="lineNoCov">          0 :       return 0.5 * (pow4(sH) + pow4(tH) + pow4(uH) + pow4(M2))</span>
<span class="lineNum">    2345 </span><span class="lineNoCov">          0 :         / pow2(sH*sH - M2 * (sH - M2));</span>
<span class="lineNum">    2346 </span>            :     }
<span class="lineNum">    2347 </span>            : 
<span class="lineNum">    2348 </span>            :   // Corrections for f + fbar -&gt; Higgs boson (f = b mainly).
<span class="lineNum">    2349 </span><span class="lineNoCov">          0 :   } else if (MEtype == 3) {</span>
<span class="lineNum">    2350 </span><span class="lineNoCov">          0 :     if (idMabs &lt; 20 &amp;&amp; idDabs &lt; 20) {</span>
<span class="lineNum">    2351 </span>            :       // The PS and ME answers agree for f fbar -&gt; H g/gamma.
<span class="lineNum">    2352 </span><span class="lineNoCov">          0 :       return 1.;</span>
<span class="lineNum">    2353 </span><span class="lineNoCov">          0 :     } else if (idDabs &lt; 20) {</span>
<span class="lineNum">    2354 </span>            :       // Need to swap tHat &lt;-&gt; uHat, cf. vector-boson production above.
<span class="lineNum">    2355 </span><span class="lineNoCov">          0 :       swap( tH, uH);</span>
<span class="lineNum">    2356 </span><span class="lineNoCov">          0 :       return (sH*sH + uH*uH + 2. * (M2 - uH) * (M2 - sH))</span>
<span class="lineNum">    2357 </span><span class="lineNoCov">          0 :              / (pow2(sH - M2) + M2*M2);</span>
<span class="lineNum">    2358 </span>            :     }
<span class="lineNum">    2359 </span>            : 
<span class="lineNum">    2360 </span>            :   // Corrections for f -&gt; f' + W/Z (s-channel).
<span class="lineNum">    2361 </span><span class="lineNoCov">          0 :   } else if (MEtype == 200 || MEtype == 205) {</span>
<span class="lineNum">    2362 </span>            :     // Need to redo calculations of uH since we now emit a massive particle.
<span class="lineNum">    2363 </span><span class="lineNoCov">          0 :     uH += m2Sister;</span>
<span class="lineNum">    2364 </span><span class="lineNoCov">          0 :     double wtME = (uH*uH + tH*tH + 2 * sH * (m2Sister + M2)) / (uH*tH)</span>
<span class="lineNum">    2365 </span><span class="lineNoCov">          0 :       - M2 * m2Sister * (1/(tH*tH) + 1/(uH*uH));</span>
<span class="lineNum">    2366 </span><span class="lineNoCov">          0 :     double wtPS =  (sH*sH + pow2(M2 + m2Sister)) / (tH*uH);</span>
<span class="lineNum">    2367 </span><span class="lineNoCov">          0 :     return wtME / wtPS;</span>
<span class="lineNum">    2368 </span><span class="lineNoCov">          0 :   } else if (MEtype == 201 || MEtype == 202 || MEtype == 203 ||</span>
<span class="lineNum">    2369 </span><span class="lineNoCov">          0 :              MEtype == 206 ||  MEtype == 207 || MEtype == 208)</span>
<span class="lineNum">    2370 </span><span class="lineNoCov">          0 :     return calcMEmax(MEtype, 0, 0);</span>
<span class="lineNum">    2371 </span>            : 
<span class="lineNum">    2372 </span>            :   // Default.
<span class="lineNum">    2373 </span><span class="lineNoCov">          0 :   return 1.;</span>
<span class="lineNum">    2374 </span>            : 
<span class="lineNum">    2375 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2376 </span>            : 
<span class="lineNum">    2377 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    2378 </span>            : 
<a name="2379"><span class="lineNum">    2379 </span>            : // Provide actual ME weight for current branching for weak t-channel emissions.</a>
<span class="lineNum">    2380 </span>            : 
<span class="lineNum">    2381 </span>            : double SpaceShower::calcMEcorrWeak(int MEtype, double m2, double z,
<span class="lineNum">    2382 </span>            :   double pT2, Vec4 pMother, Vec4 pB, Vec4 pDaughter,
<span class="lineNum">    2383 </span>            :   Vec4 pB0, Vec4 p1, Vec4 p2, Vec4 pSister) {
<span class="lineNum">    2384 </span>            : 
<span class="lineNum">    2385 </span>            :   // Find daughter four-momentum in current frame.
<span class="lineNum">    2386 </span><span class="lineNoCov">          0 :   Vec4 pA = pMother - pSister;</span>
<span class="lineNum">    2387 </span>            : 
<span class="lineNum">    2388 </span>            :   // Scale outgoing vectors to conserve energy / momentum.
<span class="lineNum">    2389 </span><span class="lineNoCov">          0 :   double scaleFactor2 = (pA + pB).m2Calc() / (p1 + p2).m2Calc();</span>
<span class="lineNum">    2390 </span><span class="lineNoCov">          0 :   double scaleFactor  = sqrt(scaleFactor2);</span>
<span class="lineNum">    2391 </span><span class="lineNoCov">          0 :   RotBstMatrix rot2to2frame;</span>
<span class="lineNum">    2392 </span><span class="lineNoCov">          0 :   rot2to2frame.bstback(p1 + p2);</span>
<span class="lineNum">    2393 </span><span class="lineNoCov">          0 :   p1.rotbst(rot2to2frame);</span>
<span class="lineNum">    2394 </span><span class="lineNoCov">          0 :   p2.rotbst(rot2to2frame);</span>
<span class="lineNum">    2395 </span><span class="lineNoCov">          0 :   p1 *= scaleFactor;</span>
<span class="lineNum">    2396 </span><span class="lineNoCov">          0 :   p2 *= scaleFactor;</span>
<span class="lineNum">    2397 </span>            : 
<span class="lineNum">    2398 </span>            :   // Find 2 to 2 rest frame for incoming particles.
<span class="lineNum">    2399 </span>            :   // This is done before one of the two are made virtual (Q^2 mass).
<span class="lineNum">    2400 </span><span class="lineNoCov">          0 :   RotBstMatrix rot2to2frameInc;</span>
<span class="lineNum">    2401 </span><span class="lineNoCov">          0 :   rot2to2frameInc.bstback(pDaughter + pB0);</span>
<span class="lineNum">    2402 </span><span class="lineNoCov">          0 :   pDaughter.rotbst(rot2to2frameInc);</span>
<span class="lineNum">    2403 </span><span class="lineNoCov">          0 :   pB0.rotbst(rot2to2frameInc);</span>
<span class="lineNum">    2404 </span><span class="lineNoCov">          0 :   double sHat = (p1 + p2).m2Calc();</span>
<span class="lineNum">    2405 </span><span class="lineNoCov">          0 :   double tHat = (p1 - pDaughter).m2Calc();</span>
<span class="lineNum">    2406 </span><span class="lineNoCov">          0 :   double uHat = (p1 - pB0).m2Calc();</span>
<span class="lineNum">    2407 </span>            : 
<span class="lineNum">    2408 </span>            :   // Calculate the weak t-channel correction.
<span class="lineNum">    2409 </span><span class="lineNoCov">          0 :   double m2R1 = 1. + pSister.m2Calc() / m2;</span>
<span class="lineNum">    2410 </span><span class="lineNoCov">          0 :   double wt = 4. * sHat / (pMother + pB).m2Calc() * pT2 * ( 1. - z * m2R1)</span>
<span class="lineNum">    2411 </span><span class="lineNoCov">          0 :     / (1. + pow2(z * m2R1)) / (1.-z);</span>
<span class="lineNum">    2412 </span><span class="lineNoCov">          0 :   if (MEtype == 201 || MEtype == 206)</span>
<span class="lineNum">    2413 </span><span class="lineNoCov">          0 :     wt *= weakShowerMEs.getTchanneluGuGZME(pMother, pB, p2, pSister, p1)</span>
<span class="lineNum">    2414 </span><span class="lineNoCov">          0 :         / weakShowerMEs.getTchanneluGuGME(sHat, tHat, uHat);</span>
<span class="lineNum">    2415 </span><span class="lineNoCov">          0 :   else if (MEtype == 202 || MEtype == 207)</span>
<span class="lineNum">    2416 </span><span class="lineNoCov">          0 :     wt *= weakShowerMEs.getTchannelududZME(pMother, pB, pSister, p2, p1)</span>
<span class="lineNum">    2417 </span><span class="lineNoCov">          0 :         / weakShowerMEs.getTchanneluuuuME(sHat, tHat, uHat);</span>
<span class="lineNum">    2418 </span><span class="lineNoCov">          0 :   else if (MEtype == 203 || MEtype == 208)</span>
<span class="lineNum">    2419 </span><span class="lineNoCov">          0 :      wt *= weakShowerMEs.getTchannelududZME(pMother, pB, pSister, p2, p1)</span>
<span class="lineNum">    2420 </span><span class="lineNoCov">          0 :          / weakShowerMEs.getTchannelududME(sHat, tHat, uHat);</span>
<span class="lineNum">    2421 </span>            : 
<span class="lineNum">    2422 </span>            :   // Split of ME into an ISR part and FSR part.
<span class="lineNum">    2423 </span><span class="lineNoCov">          0 :   wt *= (pSister + p1).m2Calc() / ( (pSister + p1).m2Calc()</span>
<span class="lineNum">    2424 </span><span class="lineNoCov">          0 :       + abs((-pMother + pSister).m2Calc()) );</span>
<span class="lineNum">    2425 </span>            : 
<span class="lineNum">    2426 </span>            :   // Remove the addition weight that was used to get an overestimate.
<span class="lineNum">    2427 </span><span class="lineNoCov">          0 :   wt /= calcMEmax(MEtype, 0, 0);</span>
<span class="lineNum">    2428 </span>            : 
<span class="lineNum">    2429 </span><span class="lineNoCov">          0 :   return wt;</span>
<span class="lineNum">    2430 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2431 </span>            : 
<span class="lineNum">    2432 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    2433 </span>            : 
<a name="2434"><span class="lineNum">    2434 </span>            : // Find coefficient of azimuthal asymmetry from gluon polarization.</a>
<span class="lineNum">    2435 </span>            : 
<span class="lineNum">    2436 </span>            : void SpaceShower::findAsymPol( Event&amp; event, SpaceDipoleEnd* dip) {
<span class="lineNum">    2437 </span>            : 
<span class="lineNum">    2438 </span>            :   // Default is no asymmetry. Only gluons are studied.
<span class="lineNum">    2439 </span><span class="lineNoCov">          0 :   dip-&gt;iFinPol   = 0;</span>
<span class="lineNum">    2440 </span><span class="lineNoCov">          0 :   dip-&gt;asymPol   = 0.;</span>
<span class="lineNum">    2441 </span><span class="lineNoCov">          0 :   int iRad       = dip-&gt;iRadiator;</span>
<span class="lineNum">    2442 </span><span class="lineNoCov">          0 :   if (!doPhiPolAsym || dip-&gt;idDaughter != 21) return;</span>
<span class="lineNum">    2443 </span>            : 
<span class="lineNum">    2444 </span>            :   // At least two particles in final state, whereof at least one coloured.
<span class="lineNum">    2445 </span><span class="lineNoCov">          0 :   int systemSizeOut = partonSystemsPtr-&gt;sizeOut( iSysSel);</span>
<span class="lineNum">    2446 </span><span class="lineNoCov">          0 :   if (systemSizeOut &lt; 2) return;</span>
<span class="lineNum">    2447 </span>            :   bool foundColOut  = false;
<span class="lineNum">    2448 </span><span class="lineNoCov">          0 :   for (int ii = 0; ii &lt; systemSizeOut; ++ii) {</span>
<span class="lineNum">    2449 </span><span class="lineNoCov">          0 :     int i = partonSystemsPtr-&gt;getOut( iSysSel, ii);</span>
<span class="lineNum">    2450 </span><span class="lineNoCov">          0 :     if (event[i].col() != 0 || event[i].acol() != 0) foundColOut = true;</span>
<span class="lineNum">    2451 </span>            :   }
<span class="lineNum">    2452 </span><span class="lineNoCov">          0 :   if (!foundColOut) return;</span>
<span class="lineNum">    2453 </span>            : 
<span class="lineNum">    2454 </span>            :   // Check if granddaughter in final state of hard scattering.
<span class="lineNum">    2455 </span>            :   // (May need to trace across carbon copies to find granddaughters.)
<span class="lineNum">    2456 </span>            :   // If so, only accept 2 -&gt; 2 scatterings with gg or qq in final state.
<span class="lineNum">    2457 </span><span class="lineNoCov">          0 :   int iGrandD1 = event[iRad].daughter1();</span>
<span class="lineNum">    2458 </span><span class="lineNoCov">          0 :   int iGrandD2 = event[iRad].daughter2();</span>
<span class="lineNum">    2459 </span>            :   bool traceCopy = false;
<span class="lineNum">    2460 </span><span class="lineNoCov">          0 :   do {</span>
<span class="lineNum">    2461 </span>            :     traceCopy = false;
<span class="lineNum">    2462 </span><span class="lineNoCov">          0 :     if (iGrandD1 &gt; 0 &amp;&amp; iGrandD2 == iGrandD1) {</span>
<span class="lineNum">    2463 </span><span class="lineNoCov">          0 :       iGrandD1 = event[iGrandD2].daughter1();</span>
<span class="lineNum">    2464 </span><span class="lineNoCov">          0 :       iGrandD2 = event[iGrandD2].daughter2();</span>
<span class="lineNum">    2465 </span>            :       traceCopy = true;
<span class="lineNum">    2466 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2467 </span><span class="lineNoCov">          0 :   } while (traceCopy);</span>
<span class="lineNum">    2468 </span><span class="lineNoCov">          0 :   int statusGrandD1 = event[ iGrandD1 ].statusAbs();</span>
<span class="lineNum">    2469 </span><span class="lineNoCov">          0 :   bool isHardProc  = (statusGrandD1 == 23 || statusGrandD1 == 33);</span>
<span class="lineNum">    2470 </span><span class="lineNoCov">          0 :   if (isHardProc) {</span>
<span class="lineNum">    2471 </span><span class="lineNoCov">          0 :     if (iGrandD2 != iGrandD1 + 1) return;</span>
<span class="lineNum">    2472 </span><span class="lineNoCov">          0 :     if (event[iGrandD1].isGluon() &amp;&amp; event[iGrandD2].isGluon());</span>
<span class="lineNum">    2473 </span><span class="lineNoCov">          0 :     else if (event[iGrandD1].isQuark() &amp;&amp; event[iGrandD2].isQuark());</span>
<span class="lineNum">    2474 </span><span class="lineNoCov">          0 :     else return;</span>
<span class="lineNum">    2475 </span>            :   }
<span class="lineNum">    2476 </span><span class="lineNoCov">          0 :   dip-&gt;iFinPol = iGrandD1;</span>
<span class="lineNum">    2477 </span>            : 
<span class="lineNum">    2478 </span>            :   // Coefficient from gluon production.
<span class="lineNum">    2479 </span><span class="lineNoCov">          0 :   if (dip-&gt;idMother == 21) dip-&gt;asymPol = pow2( (1. - dip-&gt;z)</span>
<span class="lineNum">    2480 </span><span class="lineNoCov">          0 :     / (1. - dip-&gt;z * (1. - dip-&gt;z) ) );</span>
<span class="lineNum">    2481 </span><span class="lineNoCov">          0 :   else dip-&gt;asymPol = 2. * (1. - dip-&gt;z) / (1. + pow2(1. - dip-&gt;z) );</span>
<span class="lineNum">    2482 </span>            : 
<span class="lineNum">    2483 </span>            :   // Coefficients from gluon decay. Put z = 1/2 for hard process.
<span class="lineNum">    2484 </span><span class="lineNoCov">          0 :   double zDau  = (isHardProc) ? 0.5 : dip-&gt;zOld;</span>
<span class="lineNum">    2485 </span><span class="lineNoCov">          0 :   if (event[iGrandD1].isGluon()) dip-&gt;asymPol *= pow2( (1. - zDau)</span>
<span class="lineNum">    2486 </span><span class="lineNoCov">          0 :     / (1. - zDau * (1. - zDau) ) );</span>
<span class="lineNum">    2487 </span><span class="lineNoCov">          0 :   else  dip-&gt;asymPol *= -2. * zDau *( 1. - zDau )</span>
<span class="lineNum">    2488 </span><span class="lineNoCov">          0 :     / (1. - 2. * zDau * (1. - zDau) );</span>
<span class="lineNum">    2489 </span>            : 
<span class="lineNum">    2490 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2491 </span>            : 
<span class="lineNum">    2492 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    2493 </span>            : 
<span class="lineNum">    2494 </span>            : // Remove weak dipoles if FSR already emitted a W/Z
<a name="2495"><span class="lineNum">    2495 </span>            : // and only a single weak emission is permited.</a>
<span class="lineNum">    2496 </span>            : 
<span class="lineNum">    2497 </span>            : void SpaceShower::update(int , Event &amp;, bool hasWeakRad) {
<span class="lineNum">    2498 </span>            : 
<span class="lineNum">    2499 </span><span class="lineNoCov">          0 :   if (hasWeakRad &amp;&amp; singleWeakEmission)</span>
<span class="lineNum">    2500 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; int(dipEnd.size()); i++)</span>
<span class="lineNum">    2501 </span><span class="lineNoCov">          0 :       if (dipEnd[i].weakType != 0) dipEnd[i].weakType = 0;</span>
<span class="lineNum">    2502 </span><span class="lineNoCov">          0 :   if (hasWeakRad) hasWeaklyRadiated = true;</span>
<span class="lineNum">    2503 </span>            : 
<span class="lineNum">    2504 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2505 </span>            : 
<span class="lineNum">    2506 </span>            : //-------------------------------------------------------------------------
<span class="lineNum">    2507 </span>            : 
<a name="2508"><span class="lineNum">    2508 </span>            : // Print the list of dipoles.</a>
<span class="lineNum">    2509 </span>            : 
<span class="lineNum">    2510 </span>            : void SpaceShower::list(ostream&amp; os) const {
<span class="lineNum">    2511 </span>            : 
<span class="lineNum">    2512 </span>            :   // Header.
<span class="lineNum">    2513 </span><span class="lineNoCov">          0 :   os &lt;&lt; &quot;\n --------  PYTHIA SpaceShower Dipole Listing  -------------- \n&quot;</span>
<span class="lineNum">    2514 </span><span class="lineNoCov">          0 :      &lt;&lt; &quot;\n    i  syst  side   rad   rec       pTmax  col  chg   ME rec \n&quot;</span>
<span class="lineNum">    2515 </span><span class="lineNoCov">          0 :      &lt;&lt; fixed &lt;&lt; setprecision(3);</span>
<span class="lineNum">    2516 </span>            : 
<span class="lineNum">    2517 </span>            :   // Loop over dipole list and print it.
<span class="lineNum">    2518 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; int(dipEnd.size()); ++i)</span>
<span class="lineNum">    2519 </span><span class="lineNoCov">          0 :   os &lt;&lt; setw(5) &lt;&lt; i &lt;&lt; setw(6) &lt;&lt; dipEnd[i].system</span>
<span class="lineNum">    2520 </span><span class="lineNoCov">          0 :      &lt;&lt; setw(6) &lt;&lt; dipEnd[i].side &lt;&lt; setw(6) &lt;&lt; dipEnd[i].iRadiator</span>
<span class="lineNum">    2521 </span><span class="lineNoCov">          0 :      &lt;&lt; setw(6) &lt;&lt; dipEnd[i].iRecoiler &lt;&lt; setw(12) &lt;&lt; dipEnd[i].pTmax</span>
<span class="lineNum">    2522 </span><span class="lineNoCov">          0 :      &lt;&lt; setw(5) &lt;&lt; dipEnd[i].colType &lt;&lt; setw(5) &lt;&lt; dipEnd[i].chgType</span>
<span class="lineNum">    2523 </span><span class="lineNoCov">          0 :      &lt;&lt; setw(5) &lt;&lt; dipEnd[i].MEtype &lt;&lt; setw(4)</span>
<span class="lineNum">    2524 </span><span class="lineNoCov">          0 :      &lt;&lt; dipEnd[i].normalRecoil &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">    2525 </span>            : 
<span class="lineNum">    2526 </span>            :   // Done.
<span class="lineNum">    2527 </span><span class="lineNoCov">          0 :   os &lt;&lt; &quot;\n --------  End PYTHIA SpaceShower Dipole Listing  ----------&quot;</span>
<span class="lineNum">    2528 </span><span class="lineNoCov">          0 :      &lt;&lt; endl;</span>
<span class="lineNum">    2529 </span>            : 
<span class="lineNum">    2530 </span>            : 
<span class="lineNum">    2531 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2532 </span>            : 
<span class="lineNum">    2533 </span>            : //==========================================================================
<span class="lineNum">    2534 </span>            : 
<span class="lineNum">    2535 </span>            : } // end namespace Pythia8
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
