<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - PYTHIA8/pythia8210dev/src/FJcore.cc</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">PYTHIA8/pythia8210dev/src</a> - FJcore.cc<span style="font-size: 80%;"> (source / <a href="FJcore.cc.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntry">2749</td>
            <td class="headerCovTableEntryLo">0.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntry">813</td>
            <td class="headerCovTableEntryLo">0.2 %</td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // fjcore -- extracted from FastJet v3.0.5 (http://fastjet.fr)</a>
<span class="lineNum">       2 </span>            : //
<span class="lineNum">       3 </span>            : // fjcore constitutes a digest of the main FastJet functionality.
<span class="lineNum">       4 </span>            : // The files fjcore.hh and fjcore.cc are meant to provide easy access to these
<span class="lineNum">       5 </span>            : // core functions, in the form of single files and without the need of a full
<span class="lineNum">       6 </span>            : // FastJet installation:
<span class="lineNum">       7 </span>            : //
<span class="lineNum">       8 </span>            : //     g++ main.cc fjcore.cc
<span class="lineNum">       9 </span>            : //
<span class="lineNum">      10 </span>            : // with main.cc including fjcore.hh.
<span class="lineNum">      11 </span>            : //
<span class="lineNum">      12 </span>            : // The results are expected to be identical to those obtained by linking to
<span class="lineNum">      13 </span>            : // the full FastJet distribution.
<span class="lineNum">      14 </span>            : //
<span class="lineNum">      15 </span>            : // NOTE THAT, IN ORDER TO MAKE IT POSSIBLE FOR FJCORE AND THE FULL FASTJET
<span class="lineNum">      16 </span>            : // TO COEXIST, THE FORMER USES THE &quot;fjcore&quot; NAMESPACE INSTEAD OF &quot;fastjet&quot;.
<span class="lineNum">      17 </span>            : //
<span class="lineNum">      18 </span>            : // In particular, fjcore provides:
<span class="lineNum">      19 </span>            : //
<span class="lineNum">      20 </span>            : //   - access to all native pp and ee algorithms, kt, anti-kt, C/A.
<span class="lineNum">      21 </span>            : //     For C/A, the NlnN method is available, while anti-kt and kt
<span class="lineNum">      22 </span>            : //     are limited to the N^2 one (still the fastest for N &lt; 20k particles)
<span class="lineNum">      23 </span>            : //   - access to selectors, for implementing cuts and selections
<span class="lineNum">      24 </span>            : //   - access to all functionalities related to pseudojets (e.g. a jet's
<span class="lineNum">      25 </span>            : //     structure or user-defined information)
<span class="lineNum">      26 </span>            : //
<span class="lineNum">      27 </span>            : // Instead, it does NOT provide:
<span class="lineNum">      28 </span>            : //
<span class="lineNum">      29 </span>            : //   - jet areas functionality
<span class="lineNum">      30 </span>            : //   - background estimation
<span class="lineNum">      31 </span>            : //   - access to other algorithms via plugins
<span class="lineNum">      32 </span>            : //   - interface to CGAL
<span class="lineNum">      33 </span>            : //   - fastjet tools, e.g. filters, taggers
<span class="lineNum">      34 </span>            : //
<span class="lineNum">      35 </span>            : // If these functionalities are needed, the full FastJet installation must be
<span class="lineNum">      36 </span>            : // used. The code will be fully compatible, with the sole replacement of the
<span class="lineNum">      37 </span>            : // header files and of the fjcore namespace with the fastjet one.
<span class="lineNum">      38 </span>            : //
<span class="lineNum">      39 </span>            : // fjcore.hh and fjcore.cc are not meant to be human-readable.
<span class="lineNum">      40 </span>            : // For documentation, see the full FastJet manual and doxygen at http://fastjet.fr
<span class="lineNum">      41 </span>            : //
<span class="lineNum">      42 </span>            : // Like FastJet, fjcore is released under the terms of the GNU General Public
<span class="lineNum">      43 </span>            : // License version 2 (GPLv2). If you use this code as part of work towards a
<span class="lineNum">      44 </span>            : // scientific publication, whether directly or contained within another program
<span class="lineNum">      45 </span>            : // (e.g. Delphes, SpartyJet, Rivet, LHC collaboration software frameworks,
<span class="lineNum">      46 </span>            : // etc.), you should include a citation to
<span class="lineNum">      47 </span>            : //
<span class="lineNum">      48 </span>            : //   EPJC72(2012)1896 [arXiv:1111.6097] (FastJet User Manual)
<span class="lineNum">      49 </span>            : //   and, optionally, Phys.Lett.B641 (2006) 57 [arXiv:hep-ph/0512210]
<span class="lineNum">      50 </span>            : //
<span class="lineNum">      51 </span>            : // Copyright (c) 2005-2013, Matteo Cacciari, Gavin P. Salam and Gregory Soyez
<span class="lineNum">      52 </span>            : //
<span class="lineNum">      53 </span>            : //----------------------------------------------------------------------
<span class="lineNum">      54 </span>            : // This file is part of FastJet.
<span class="lineNum">      55 </span>            : //
<span class="lineNum">      56 </span>            : //  FastJet is free software; you can redistribute it and/or modify
<span class="lineNum">      57 </span>            : //  it under the terms of the GNU General Public License as published by
<span class="lineNum">      58 </span>            : //  the Free Software Foundation; either version 2 of the License, or
<span class="lineNum">      59 </span>            : //  (at your option) any later version.
<span class="lineNum">      60 </span>            : //
<span class="lineNum">      61 </span>            : //  The algorithms that underlie FastJet have required considerable
<span class="lineNum">      62 </span>            : //  development and are described in hep-ph/0512210. If you use
<span class="lineNum">      63 </span>            : //  FastJet as part of work towards a scientific publication, please
<span class="lineNum">      64 </span>            : //  include a citation to the FastJet paper.
<span class="lineNum">      65 </span>            : //
<span class="lineNum">      66 </span>            : //  FastJet is distributed in the hope that it will be useful,
<span class="lineNum">      67 </span>            : //  but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      68 </span>            : //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      69 </span>            : //  GNU General Public License for more details.
<span class="lineNum">      70 </span>            : //
<span class="lineNum">      71 </span>            : //  You should have received a copy of the GNU General Public License
<span class="lineNum">      72 </span>            : //  along with FastJet. If not, see &lt;http://www.gnu.org/licenses/&gt;.
<span class="lineNum">      73 </span>            : //----------------------------------------------------------------------
<span class="lineNum">      74 </span>            : //
<span class="lineNum">      75 </span>            : //#include &quot;fjcore.hh&quot;
<span class="lineNum">      76 </span>            : // For inclusion in Pythia8 line above is replaced by line below.
<span class="lineNum">      77 </span>            : #include &quot;Pythia8/FJcore.h&quot;
<span class="lineNum">      78 </span>            : #ifndef __FJCORE_VERSION_HH__
<span class="lineNum">      79 </span>            : #define __FJCORE_VERSION_HH__
<span class="lineNum">      80 </span>            : #include&lt;string&gt;
<span class="lineNum">      81 </span>            : FJCORE_BEGIN_NAMESPACE
<span class="lineNum">      82 </span>            : const char* fastjet_version = FJCORE_PACKAGE_VERSION;
<span class="lineNum">      83 </span>            : FJCORE_END_NAMESPACE
<span class="lineNum">      84 </span>            : #endif // __FJCORE_VERSION_HH__
<span class="lineNum">      85 </span>            : #ifndef __FJCORE_CLUSTERQUENCE_N2_ICC__
<a name="86"><span class="lineNum">      86 </span>            : #define __FJCORE_CLUSTERQUENCE_N2_ICC__</a>
<span class="lineNum">      87 </span>            : FJCORE_BEGIN_NAMESPACE      // defined in fastjet/internal/base.hh
<span class="lineNum">      88 </span>            : template&lt;class BJ&gt; void ClusterSequence::_simple_N2_cluster() {
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :   int n = _jets.size();</span>
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :   BJ * briefjets = new BJ[n];</span>
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :   BJ * jetA = briefjets, * jetB;</span>
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :   for (int i = 0; i&lt; n; i++) {</span>
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :     _bj_set_jetinfo(jetA, i);</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :     jetA++; // move on to next entry of briefjets</span>
<span class="lineNum">      95 </span>            :   }
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :   BJ * tail = jetA; // a semaphore for the end of briefjets</span>
<span class="lineNum">      97 </span>            :   BJ * head = briefjets; // a nicer way of naming start
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :   for (jetA = head + 1; jetA != tail; jetA++) {</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :     _bj_set_NN_crosscheck(jetA, head, jetA);</span>
<span class="lineNum">     100 </span>            :   }
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :   double * diJ = new double[n];</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :   jetA = head;</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; n; i++) {</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :     diJ[i] = _bj_diJ(jetA);</span>
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :     jetA++; // have jetA follow i</span>
<span class="lineNum">     106 </span>            :   }
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :   int history_location = n-1;</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :   while (tail != head) {</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :     double diJ_min = diJ[0];</span>
<span class="lineNum">     110 </span>            :     int diJ_min_jet = 0;
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :     for (int i = 1; i &lt; n; i++) {</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :       if (diJ[i] &lt; diJ_min) {diJ_min_jet = i; diJ_min  = diJ[i];}</span>
<span class="lineNum">     113 </span>            :     }
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :     history_location++;</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :     jetA = &amp; briefjets[diJ_min_jet];</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :     jetB = static_cast&lt;BJ *&gt;(jetA-&gt;NN);</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :     diJ_min *= _invR2;</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :     if (jetB != NULL) {</span>
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :       if (jetA &lt; jetB) {std::swap(jetA,jetB);}</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :       int nn; // new jet index</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :       _do_ij_recombination_step(jetA-&gt;_jets_index, jetB-&gt;_jets_index, diJ_min, nn);</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :       _bj_set_jetinfo(jetB, nn);</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :       _do_iB_recombination_step(jetA-&gt;_jets_index, diJ_min);</span>
<span class="lineNum">     125 </span>            :     }
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :     tail--; n--;</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :     *jetA = *tail;</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :     diJ[jetA - head] = diJ[tail-head];</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :     for (BJ * jetI = head; jetI != tail; jetI++) {</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :       if (jetI-&gt;NN == jetA || jetI-&gt;NN == jetB) {</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :         _bj_set_NN_nocross(jetI, head, tail);</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :         diJ[jetI-head] = _bj_diJ(jetI); // update diJ</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :       if (jetB != NULL) {</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :         double dist = _bj_dist(jetI,jetB);</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :         if (dist &lt; jetI-&gt;NN_dist) {</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :           if (jetI != jetB) {</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :             jetI-&gt;NN_dist = dist;</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :             jetI-&gt;NN = jetB;</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :             diJ[jetI-head] = _bj_diJ(jetI); // update diJ...</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">     142 </span>            :         }
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :         if (dist &lt; jetB-&gt;NN_dist) {</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :           if (jetI != jetB) {</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :             jetB-&gt;NN_dist = dist;</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :             jetB-&gt;NN      = jetI;}</span>
<span class="lineNum">     147 </span>            :         }
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :       if (jetI-&gt;NN == tail) {jetI-&gt;NN = jetA;}</span>
<span class="lineNum">     150 </span>            :     }
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :     if (jetB != NULL) {diJ[jetB-head] = _bj_diJ(jetB);}</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :   delete[] diJ;</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :   delete[] briefjets;</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     156 </span>            : FJCORE_END_NAMESPACE
<span class="lineNum">     157 </span>            : #endif // __FJCORE_CLUSTERQUENCE_N2_ICC__
<span class="lineNum">     158 </span>            : #ifndef __FJCORE_DYNAMICNEARESTNEIGHBOURS_HH__
<span class="lineNum">     159 </span>            : #define __FJCORE_DYNAMICNEARESTNEIGHBOURS_HH__
<span class="lineNum">     160 </span>            : #include&lt;vector&gt;
<span class="lineNum">     161 </span>            : #include&lt;string&gt;
<span class="lineNum">     162 </span>            : #include&lt;iostream&gt;
<span class="lineNum">     163 </span>            : #include&lt;sstream&gt;
<span class="lineNum">     164 </span>            : #include&lt;cassert&gt;
<span class="lineNum">     165 </span>            : FJCORE_BEGIN_NAMESPACE      // defined in fastjet/internal/base.hh
<span class="lineNum">     166 </span>            : class EtaPhi {
<a name="167"><span class="lineNum">     167 </span>            : public:</a>
<a name="168"><span class="lineNum">     168 </span>            :   double first, second;</a>
<a name="169"><span class="lineNum">     169 </span><span class="lineNoCov">          0 :   EtaPhi() {}</span></a>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :   EtaPhi(double a, double b) {first = a; second = b;}</span>
<span class="lineNum">     171 </span>            :   void sanitize() {
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :     if (second &lt;  0)     second += twopi;</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :     if (second &gt;= twopi) second -= twopi;</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     175 </span>            : };
<span class="lineNum">     176 </span>            : class DnnError {
<span class="lineNum">     177 </span>            : public:
<span class="lineNum">     178 </span>            :   DnnError() {;};
<span class="lineNum">     179 </span>            :   DnnError(const std::string &amp; message_in) {
<span class="lineNum">     180 </span>            :     _message = message_in; std::cerr &lt;&lt; message_in &lt;&lt; std::endl;};
<span class="lineNum">     181 </span>            :   std::string message() const {return _message;};
<span class="lineNum">     182 </span>            : private:
<span class="lineNum">     183 </span>            :   std::string _message;
<span class="lineNum">     184 </span>            : };
<span class="lineNum">     185 </span>            : class DynamicNearestNeighbours {
<span class="lineNum">     186 </span>            : public:
<span class="lineNum">     187 </span>            :   virtual int NearestNeighbourIndex(const int &amp; ii) const = 0;
<span class="lineNum">     188 </span>            :   virtual double NearestNeighbourDistance(const int &amp; ii) const = 0;
<span class="lineNum">     189 </span>            :   virtual bool Valid(const int &amp; index) const = 0;
<span class="lineNum">     190 </span>            :   virtual void RemoveAndAddPoints(const std::vector&lt;int&gt; &amp; indices_to_remove,
<span class="lineNum">     191 </span>            :                           const std::vector&lt;EtaPhi&gt; &amp; points_to_add,
<span class="lineNum">     192 </span>            :                           std::vector&lt;int&gt; &amp; indices_added,
<span class="lineNum">     193 </span>            :                           std::vector&lt;int&gt; &amp; indices_of_updated_neighbours) = 0;
<span class="lineNum">     194 </span>            :   inline void RemovePoint (const int &amp; index,
<span class="lineNum">     195 </span>            :                            std::vector&lt;int&gt; &amp; indices_of_updated_neighbours) {
<span class="lineNum">     196 </span>            :     std::vector&lt;int&gt; indices_added;
<span class="lineNum">     197 </span>            :     std::vector&lt;EtaPhi&gt; points_to_add;
<span class="lineNum">     198 </span>            :     std::vector&lt;int&gt; indices_to_remove(1);
<span class="lineNum">     199 </span>            :     indices_to_remove[0] = index;
<span class="lineNum">     200 </span>            :     RemoveAndAddPoints(indices_to_remove, points_to_add, indices_added,
<span class="lineNum">     201 </span>            :                        indices_of_updated_neighbours
<span class="lineNum">     202 </span>            :                        );};
<span class="lineNum">     203 </span>            :   inline void RemoveCombinedAddCombination(
<span class="lineNum">     204 </span>            :                         const int &amp; index1, const int &amp; index2,
<span class="lineNum">     205 </span>            :                         const EtaPhi &amp; newpoint,
<span class="lineNum">     206 </span>            :                         int &amp; index3,
<span class="lineNum">     207 </span>            :                         std::vector&lt;int&gt; &amp; indices_of_updated_neighbours) {
<span class="lineNum">     208 </span>            :     std::vector&lt;int&gt; indices_added(1);
<span class="lineNum">     209 </span>            :     std::vector&lt;EtaPhi&gt; points_to_add(1);
<span class="lineNum">     210 </span>            :     std::vector&lt;int&gt; indices_to_remove(2);
<span class="lineNum">     211 </span>            :     indices_to_remove[0] = index1;
<span class="lineNum">     212 </span>            :     indices_to_remove[1] = index2;
<span class="lineNum">     213 </span>            :     points_to_add[0] = newpoint;
<span class="lineNum">     214 </span>            :     RemoveAndAddPoints(indices_to_remove, points_to_add, indices_added,
<span class="lineNum">     215 </span>            :                        indices_of_updated_neighbours
<span class="lineNum">     216 </span>            :                        );
<span class="lineNum">     217 </span>            :     index3 = indices_added[0];
<span class="lineNum">     218 </span>            :   };
<span class="lineNum">     219 </span>            :   virtual ~DynamicNearestNeighbours () {}
<span class="lineNum">     220 </span>            : };
<span class="lineNum">     221 </span>            : FJCORE_END_NAMESPACE
<span class="lineNum">     222 </span>            : #endif // __FJCORE_DYNAMICNEARESTNEIGHBOURS_HH__
<span class="lineNum">     223 </span>            : #ifndef __FJCORE_SEARCHTREE_HH__
<span class="lineNum">     224 </span>            : #define __FJCORE_SEARCHTREE_HH__
<span class="lineNum">     225 </span>            : #include&lt;vector&gt;
<span class="lineNum">     226 </span>            : #include&lt;cassert&gt;
<a name="227"><span class="lineNum">     227 </span>            : #include&lt;cstddef&gt;</a>
<span class="lineNum">     228 </span>            : FJCORE_BEGIN_NAMESPACE      // defined in fastjet/internal/base.hh
<span class="lineNum">     229 </span><span class="lineNoCov">          0 : template&lt;class T&gt; class SearchTree {</span>
<span class="lineNum">     230 </span>            : public:
<span class="lineNum">     231 </span>            :   class Node;
<span class="lineNum">     232 </span>            :   class circulator;
<a name="233"><span class="lineNum">     233 </span>            :   class const_circulator;</a>
<span class="lineNum">     234 </span>            :   SearchTree(const std::vector&lt;T&gt; &amp; init);
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :   SearchTree(const std::vector&lt;T&gt; &amp; init, unsigned int max_size);</span>
<span class="lineNum">     236 </span>            :   void remove(unsigned node_index);
<span class="lineNum">     237 </span>            :   void remove(typename SearchTree::Node * node);
<span class="lineNum">     238 </span>            :   void remove(typename SearchTree::circulator &amp; circ);
<a name="239"><span class="lineNum">     239 </span>            :   circulator insert(const T &amp; value);</a>
<span class="lineNum">     240 </span>            :   const Node &amp; operator[](int i) const {return _nodes[i];};
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :   unsigned int size() const {return _nodes.size() - _available_nodes.size();}</span>
<span class="lineNum">     242 </span>            :   void verify_structure();
<span class="lineNum">     243 </span>            :   void verify_structure_linear() const;
<span class="lineNum">     244 </span>            :   void verify_structure_recursive(const Node * , const Node * , const Node * ) const;
<span class="lineNum">     245 </span>            :   void print_elements();
<span class="lineNum">     246 </span>            : #ifdef __FJCORE_SEARCHTREE_TRACK_DEPTH
<span class="lineNum">     247 </span>            :   inline unsigned int max_depth() const {return _max_depth;};
<span class="lineNum">     248 </span>            : #else
<span class="lineNum">     249 </span>            :   inline unsigned int max_depth() const {return 0;};
<span class="lineNum">     250 </span>            : #endif
<span class="lineNum">     251 </span>            :   int loc(const Node * node) const ;
<span class="lineNum">     252 </span>            :   Node * _find_predecessor(const Node *);
<span class="lineNum">     253 </span>            :   Node * _find_successor(const Node *);
<span class="lineNum">     254 </span>            :   const Node &amp; operator[](unsigned int i) const {return _nodes[i];};
<span class="lineNum">     255 </span>            :   const_circulator somewhere() const;
<span class="lineNum">     256 </span>            :   circulator somewhere();
<span class="lineNum">     257 </span>            : private:
<span class="lineNum">     258 </span>            :   void _initialize(const std::vector&lt;T&gt; &amp; init);
<span class="lineNum">     259 </span>            :   std::vector&lt;Node&gt; _nodes;
<span class="lineNum">     260 </span>            :   std::vector&lt;Node *&gt; _available_nodes;
<span class="lineNum">     261 </span>            :   Node * _top_node;
<span class="lineNum">     262 </span>            :   unsigned int _n_removes;
<span class="lineNum">     263 </span>            :   void _do_initial_connections(unsigned int this_one, unsigned int scale,
<span class="lineNum">     264 </span>            :                                unsigned int left_edge, unsigned int right_edge,
<span class="lineNum">     265 </span>            :                                unsigned int depth);
<span class="lineNum">     266 </span>            : #ifdef __FJCORE_SEARCHTREE_TRACK_DEPTH
<span class="lineNum">     267 </span>            :   unsigned int _max_depth;
<span class="lineNum">     268 </span>            : #endif
<span class="lineNum">     269 </span>            : };
<a name="270"><span class="lineNum">     270 </span>            : template&lt;class T&gt; class SearchTree&lt;T&gt;::Node{</a>
<a name="271"><span class="lineNum">     271 </span>            : public:</a>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :   Node() {}; /// default constructor</span>
<a name="273"><span class="lineNum">     273 </span>            :   bool treelinks_null() const {</a>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :     return ((parent==0) &amp;&amp; (left==0) &amp;&amp; (right==0));};</span>
<span class="lineNum">     275 </span>            :   inline void nullify_treelinks() {
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :     parent = NULL;</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :     left   = NULL;</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :     right  = NULL;</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :   };</span>
<span class="lineNum">     280 </span>            :   void reset_parents_link_to_me(Node * XX);
<span class="lineNum">     281 </span>            :   T      value;
<span class="lineNum">     282 </span>            :   Node * left;
<span class="lineNum">     283 </span>            :   Node * right;
<span class="lineNum">     284 </span>            :   Node * parent;
<span class="lineNum">     285 </span>            :   Node * successor;
<a name="286"><span class="lineNum">     286 </span>            :   Node * predecessor;</a>
<span class="lineNum">     287 </span>            : };
<span class="lineNum">     288 </span>            : template&lt;class T&gt; void SearchTree&lt;T&gt;::Node::reset_parents_link_to_me(typename SearchTree&lt;T&gt;::Node * XX) {
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :   if (parent == NULL) {return;}</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :   if (parent-&gt;right == this) {parent-&gt;right = XX;}</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :   else {parent-&gt;left = XX;}</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     293 </span>            : template&lt;class T&gt; class SearchTree&lt;T&gt;::circulator{
<span class="lineNum">     294 </span>            : public:
<span class="lineNum">     295 </span>            :   // Next line commented out, by author agreement, to avoid compiler warning.
<a name="296"><span class="lineNum">     296 </span>            :   //template&lt;class U&gt; friend class SearchTree&lt;U&gt;::const_circulator;</a>
<a name="297"><span class="lineNum">     297 </span>            :   friend class SearchTree&lt;T&gt;;</a>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :   circulator() : _node(NULL) {}</span>
<a name="299"><span class="lineNum">     299 </span><span class="lineNoCov">          0 :   circulator(Node * node) : _node(node) {}</span></a>
<span class="lineNum">     300 </span>            :   const T * operator-&gt;() const {return &amp;(_node-&gt;value);}
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :   T * operator-&gt;() {return &amp;(_node-&gt;value);}</span>
<a name="302"><span class="lineNum">     302 </span>            :   const T &amp; operator*() const {return _node-&gt;value;}</a>
<span class="lineNum">     303 </span>            :   T &amp; operator*() {return _node-&gt;value;}
<span class="lineNum">     304 </span>            :   circulator &amp; operator++() {
<a name="305"><span class="lineNum">     305 </span><span class="lineNoCov">          0 :     _node = _node-&gt;successor;</span></a>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :     return *this;}</span>
<span class="lineNum">     307 </span>            :   circulator operator++(int) {
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :     circulator tmp = *this;</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :     _node = _node-&gt;successor;</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :     return tmp;}</span>
<span class="lineNum">     311 </span>            :   circulator &amp; operator--() {
<a name="312"><span class="lineNum">     312 </span>            :     _node = _node-&gt;predecessor;</a>
<span class="lineNum">     313 </span>            :     return *this;}
<span class="lineNum">     314 </span>            :   circulator operator--(int) {
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :     circulator tmp = *this;</span>
<a name="316"><span class="lineNum">     316 </span><span class="lineNoCov">          0 :     _node = _node-&gt;predecessor;</span></a>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :     return tmp;}</span>
<span class="lineNum">     318 </span>            :   circulator next() const {
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :     return circulator(_node-&gt;successor);}</span>
<a name="320"><span class="lineNum">     320 </span>            :   circulator previous() const {</a>
<span class="lineNum">     321 </span>            :     return circulator(_node-&gt;predecessor);}
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :   bool operator!=(const circulator &amp; other) const {return other._node != _node;}</span>
<span class="lineNum">     323 </span>            :   bool operator==(const circulator &amp; other) const {return other._node == _node;}
<span class="lineNum">     324 </span>            : private:
<span class="lineNum">     325 </span>            :   Node * _node;
<span class="lineNum">     326 </span>            : };
<span class="lineNum">     327 </span>            : template&lt;class T&gt; class SearchTree&lt;T&gt;::const_circulator{
<span class="lineNum">     328 </span>            : public:
<span class="lineNum">     329 </span>            :   const_circulator() : _node(NULL) {}
<span class="lineNum">     330 </span>            :   const_circulator(const Node * node) : _node(node) {}
<span class="lineNum">     331 </span>            :   const_circulator(const circulator &amp; circ) :_node(circ._node) {}
<span class="lineNum">     332 </span>            :   const T * operator-&gt;() {return &amp;(_node-&gt;value);}
<span class="lineNum">     333 </span>            :   const T &amp; operator*() const {return _node-&gt;value;}
<span class="lineNum">     334 </span>            :   const_circulator &amp; operator++() {
<span class="lineNum">     335 </span>            :     _node = _node-&gt;successor;
<span class="lineNum">     336 </span>            :     return *this;}
<span class="lineNum">     337 </span>            :   const_circulator operator++(int) {
<span class="lineNum">     338 </span>            :     const_circulator tmp = *this;
<span class="lineNum">     339 </span>            :     _node = _node-&gt;successor;
<span class="lineNum">     340 </span>            :     return tmp;}
<span class="lineNum">     341 </span>            :   const_circulator &amp; operator--() {
<span class="lineNum">     342 </span>            :     _node = _node-&gt;predecessor;
<span class="lineNum">     343 </span>            :     return *this;}
<span class="lineNum">     344 </span>            :   const_circulator operator--(int) {
<span class="lineNum">     345 </span>            :     const_circulator tmp = *this;
<span class="lineNum">     346 </span>            :     _node = _node-&gt;predecessor;
<span class="lineNum">     347 </span>            :     return tmp;}
<span class="lineNum">     348 </span>            :   const_circulator next() const {
<span class="lineNum">     349 </span>            :     return const_circulator(_node-&gt;successor);}
<span class="lineNum">     350 </span>            :   const_circulator previous() const {
<span class="lineNum">     351 </span>            :     return const_circulator(_node-&gt;predecessor);}
<span class="lineNum">     352 </span>            :   bool operator!=(const const_circulator &amp; other) const {return other._node != _node;}
<span class="lineNum">     353 </span>            :   bool operator==(const const_circulator &amp; other) const {return other._node == _node;}
<span class="lineNum">     354 </span>            : private:
<a name="355"><span class="lineNum">     355 </span>            :   const Node * _node;</a>
<span class="lineNum">     356 </span>            : };
<span class="lineNum">     357 </span>            : template&lt;class T&gt; SearchTree&lt;T&gt;::SearchTree(const std::vector&lt;T&gt; &amp; init,
<span class="lineNum">     358 </span>            :                                             unsigned int max_size) :
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :   _nodes(max_size) {</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :   _available_nodes.reserve(max_size);</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :   _available_nodes.resize(max_size - init.size());</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :   for (unsigned int i = init.size(); i &lt; max_size; i++) {</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :     _available_nodes[i-init.size()] = &amp;(_nodes[i]);</span>
<span class="lineNum">     364 </span>            :   }
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :   _initialize(init);</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     367 </span>            : template&lt;class T&gt; SearchTree&lt;T&gt;::SearchTree(const std::vector&lt;T&gt; &amp; init) :
<span class="lineNum">     368 </span>            :   _nodes(init.size()), _available_nodes(0) {
<span class="lineNum">     369 </span>            :   _available_nodes.reserve(init.size());
<a name="370"><span class="lineNum">     370 </span>            :   _initialize(init);</a>
<span class="lineNum">     371 </span>            : }
<span class="lineNum">     372 </span>            : template&lt;class T&gt; void SearchTree&lt;T&gt;::_initialize(const std::vector&lt;T&gt; &amp; init) {
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :   _n_removes = 0;</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :   unsigned n = init.size();</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :   assert(n&gt;=1);</span>
<span class="lineNum">     376 </span>            : #ifdef __FJCORE_SEARCHTREE_TRACK_DEPTH
<span class="lineNum">     377 </span>            :   _max_depth     = 0;
<span class="lineNum">     378 </span>            : #endif
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :   for (unsigned int i = 1; i&lt;n; i++) {</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :     assert(!(init[i] &lt; init[i-1]));</span>
<span class="lineNum">     381 </span>            :   }
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :   for(unsigned int i = 0; i &lt; n; i++) {</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :     _nodes[i].value = init[i];</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :     _nodes[i].predecessor = (&amp; (_nodes[i])) - 1;</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :     _nodes[i].successor   = (&amp; (_nodes[i])) + 1;</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :     _nodes[i].nullify_treelinks();</span>
<span class="lineNum">     387 </span>            :   }
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :   _nodes[0].predecessor = (&amp; (_nodes[n-1]));</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :   _nodes[n-1].successor = (&amp; (_nodes[0]));</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :   unsigned int scale = (n+1)/2;</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :   unsigned int top   = std::min(n-1,scale);</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :   _nodes[top].parent = NULL;</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :   _top_node = &amp;(_nodes[top]);</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :   _do_initial_connections(top, scale, 0, n, 0);</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 : }</span>
<a name="396"><span class="lineNum">     396 </span>            : template&lt;class T&gt; inline  int SearchTree&lt;T&gt;::loc(const Node * node) const {return node == NULL?</a>
<span class="lineNum">     397 </span>            :       -999 : node - &amp;(_nodes[0]);}
<span class="lineNum">     398 </span>            : template&lt;class T&gt; void SearchTree&lt;T&gt;::_do_initial_connections(
<span class="lineNum">     399 </span>            :                                          unsigned int this_one,
<span class="lineNum">     400 </span>            :                                          unsigned int scale,
<span class="lineNum">     401 </span>            :                                          unsigned int left_edge,
<span class="lineNum">     402 </span>            :                                          unsigned int right_edge,
<span class="lineNum">     403 </span>            :                                          unsigned int depth
<span class="lineNum">     404 </span>            :                                          ) {
<span class="lineNum">     405 </span>            : #ifdef __FJCORE_SEARCHTREE_TRACK_DEPTH
<span class="lineNum">     406 </span>            :   _max_depth = max(depth, _max_depth);
<span class="lineNum">     407 </span>            : #endif
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :   unsigned int ref_new_scale = (scale+1)/2;</span>
<span class="lineNum">     409 </span>            :   unsigned new_scale = ref_new_scale;
<span class="lineNum">     410 </span>            :   bool     did_child  = false;
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :   while(true) {</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :     int left = this_one - new_scale; // be careful here to use signed int...</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :     if (left &gt;= static_cast&lt;int&gt;(left_edge)</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :                         &amp;&amp; _nodes[left].treelinks_null() ) {</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :       _nodes[left].parent = &amp;(_nodes[this_one]);</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :       _nodes[this_one].left = &amp;(_nodes[left]);</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :       _do_initial_connections(left, new_scale, left_edge, this_one, depth+1);</span>
<span class="lineNum">     418 </span>            :       did_child = true;
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     420 </span>            :     }
<span class="lineNum">     421 </span>            :     unsigned int old_new_scale = new_scale;
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :     new_scale = (old_new_scale + 1)/2;</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :     if (new_scale == old_new_scale) break;</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :   if (!did_child) {_nodes[this_one].left = NULL;}</span>
<span class="lineNum">     426 </span>            :   new_scale = ref_new_scale;
<span class="lineNum">     427 </span>            :   did_child  = false;
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :   while(true) {</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :     unsigned int right = this_one + new_scale;</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :     if (right &lt; right_edge  &amp;&amp; _nodes[right].treelinks_null()) {</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :       _nodes[right].parent = &amp;(_nodes[this_one]);</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :       _nodes[this_one].right = &amp;(_nodes[right]);</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :       _do_initial_connections(right, new_scale, this_one+1,right_edge,depth+1);</span>
<span class="lineNum">     434 </span>            :       did_child = true;
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     436 </span>            :     }
<span class="lineNum">     437 </span>            :     unsigned int old_new_scale = new_scale;
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :     new_scale = (old_new_scale + 1)/2;</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :     if (new_scale == old_new_scale) break;</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :   if (!did_child) {_nodes[this_one].right = NULL;}</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     443 </span>            : template&lt;class T&gt; void SearchTree&lt;T&gt;::remove(unsigned int node_index) {
<a name="444"><span class="lineNum">     444 </span>            :   remove(&amp;(_nodes[node_index]));</a>
<span class="lineNum">     445 </span>            : }
<span class="lineNum">     446 </span>            : template&lt;class T&gt; void SearchTree&lt;T&gt;::remove(circulator &amp; circ) {
<a name="447"><span class="lineNum">     447 </span><span class="lineNoCov">          0 :   remove(circ._node);</span></a>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     449 </span>            : template&lt;class T&gt; void SearchTree&lt;T&gt;::remove(typename SearchTree&lt;T&gt;::Node * node) {
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :   assert(size() &gt; 1); // switch this to throw...?</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :   assert(!node-&gt;treelinks_null());</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :   node-&gt;predecessor-&gt;successor = node-&gt;successor;</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :   node-&gt;successor-&gt;predecessor = node-&gt;predecessor;</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :   if (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL) {</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :     node-&gt;reset_parents_link_to_me(NULL);</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :   } else if (node-&gt;left != NULL &amp;&amp; node-&gt;right == NULL){</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :     node-&gt;reset_parents_link_to_me(node-&gt;left);</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :     node-&gt;left-&gt;parent = node-&gt;parent;</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :     if (_top_node == node) {_top_node = node-&gt;left;}</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :   } else if (node-&gt;left == NULL &amp;&amp; node-&gt;right != NULL){</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :     node-&gt;reset_parents_link_to_me(node-&gt;right);</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :     node-&gt;right-&gt;parent = node-&gt;parent;</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :     if (_top_node == node) {_top_node = node-&gt;right;}</span>
<span class="lineNum">     464 </span>            :   } else {
<span class="lineNum">     465 </span>            :     Node * replacement;
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :     bool use_predecessor = (_n_removes % 2 == 1);</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :     if (use_predecessor) {</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :       replacement = node-&gt;predecessor;</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :       assert(replacement-&gt;right == NULL); // guaranteed if it's our predecessor</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :       if (replacement != node-&gt;left) {</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :         if (replacement-&gt;left != NULL) {</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :           replacement-&gt;left-&gt;parent = replacement-&gt;parent;}</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :         replacement-&gt;reset_parents_link_to_me(replacement-&gt;left);</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :         replacement-&gt;left   = node-&gt;left;</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :       replacement-&gt;parent = node-&gt;parent;</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :       replacement-&gt;right  = node-&gt;right;</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :       replacement = node-&gt;successor;</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :       assert(replacement-&gt;left == NULL); // guaranteed if it's our successor</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :       if (replacement != node-&gt;right) {</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :         if (replacement-&gt;right != NULL) {</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :           replacement-&gt;right-&gt;parent = replacement-&gt;parent;}</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :         replacement-&gt;reset_parents_link_to_me(replacement-&gt;right);</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :         replacement-&gt;right  = node-&gt;right;</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :       replacement-&gt;parent = node-&gt;parent;</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :       replacement-&gt;left   = node-&gt;left;</span>
<span class="lineNum">     489 </span>            :     }
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :     node-&gt;reset_parents_link_to_me(replacement);</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :     if (node-&gt;left  != replacement) {node-&gt;left-&gt;parent  = replacement;}</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :     if (node-&gt;right != replacement) {node-&gt;right-&gt;parent = replacement;}</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :     if (_top_node == node) {_top_node = replacement;}</span>
<span class="lineNum">     494 </span>            :   }
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :   node-&gt;nullify_treelinks();</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :   node-&gt;predecessor = NULL;</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :   node-&gt;successor   = NULL;</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :   _n_removes++;</span>
<a name="499"><span class="lineNum">     499 </span><span class="lineNoCov">          0 :   _available_nodes.push_back(node);</span></a>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     501 </span>            : template&lt;class T&gt; typename SearchTree&lt;T&gt;::circulator SearchTree&lt;T&gt;::insert(const T &amp; value) {
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :   assert(_available_nodes.size() &gt; 0);</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :   Node * node = _available_nodes.back();</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :   _available_nodes.pop_back();</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :   node-&gt;value = value;</span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :   Node * location = _top_node;</span>
<span class="lineNum">     507 </span>            :   Node * old_location = NULL;
<span class="lineNum">     508 </span>            :   bool             on_left = true; // (init not needed -- but soothes g++4)
<span class="lineNum">     509 </span>            : #ifdef __FJCORE_SEARCHTREE_TRACK_DEPTH
<span class="lineNum">     510 </span>            :   unsigned int depth = 0;
<span class="lineNum">     511 </span>            : #endif
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :   while(location != NULL) {</span>
<span class="lineNum">     513 </span>            : #ifdef __FJCORE_SEARCHTREE_TRACK_DEPTH
<span class="lineNum">     514 </span>            :     depth++;
<span class="lineNum">     515 </span>            : #endif
<span class="lineNum">     516 </span>            :     old_location = location;
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :     on_left = value &lt; location-&gt;value;</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :     if (on_left) {location = location-&gt;left;}</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :     else {location = location-&gt;right;}</span>
<span class="lineNum">     520 </span>            :   }
<span class="lineNum">     521 </span>            : #ifdef __FJCORE_SEARCHTREE_TRACK_DEPTH
<span class="lineNum">     522 </span>            :   _max_depth = max(depth, _max_depth);
<span class="lineNum">     523 </span>            : #endif
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :   node-&gt;parent = old_location;</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :   if (on_left) {node-&gt;parent-&gt;left = node;}</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :   else {node-&gt;parent-&gt;right = node;}</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :   node-&gt;left = NULL;</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :   node-&gt;right = NULL;</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :   node-&gt;predecessor = _find_predecessor(node);</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :   if (node-&gt;predecessor != NULL) {</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :     node-&gt;successor = node-&gt;predecessor-&gt;successor;</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :     node-&gt;predecessor-&gt;successor = node;</span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :     node-&gt;successor-&gt;predecessor = node;</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :     node-&gt;successor = _find_successor(node);</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :     assert(node-&gt;successor != NULL); // can only happen if we're sole element</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :     node-&gt;predecessor = node-&gt;successor-&gt;predecessor;</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :     node-&gt;successor-&gt;predecessor = node;</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :     node-&gt;predecessor-&gt;successor = node;</span>
<span class="lineNum">     540 </span>            :   }
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :   return circulator(node);</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     543 </span>            : template&lt;class T&gt; void SearchTree&lt;T&gt;::verify_structure() {
<span class="lineNum">     544 </span>            :   verify_structure_linear();
<span class="lineNum">     545 </span>            :   const Node * left_limit = _top_node;
<span class="lineNum">     546 </span>            :   while (left_limit-&gt;left != NULL) {left_limit = left_limit-&gt;left;}
<span class="lineNum">     547 </span>            :   const Node * right_limit = _top_node;
<span class="lineNum">     548 </span>            :   while (right_limit-&gt;right != NULL) {right_limit = right_limit-&gt;right;}
<span class="lineNum">     549 </span>            :   verify_structure_recursive(_top_node, left_limit, right_limit);
<span class="lineNum">     550 </span>            : }
<span class="lineNum">     551 </span>            : template&lt;class T&gt; void SearchTree&lt;T&gt;::verify_structure_recursive(
<span class="lineNum">     552 </span>            :                       const typename SearchTree&lt;T&gt;::Node * element,
<span class="lineNum">     553 </span>            :                       const typename SearchTree&lt;T&gt;::Node * left_limit,
<span class="lineNum">     554 </span>            :                       const typename SearchTree&lt;T&gt;::Node * right_limit)  const {
<span class="lineNum">     555 </span>            :   assert(!(element-&gt;value &lt; left_limit-&gt;value));
<span class="lineNum">     556 </span>            :   assert(!(right_limit-&gt;value &lt; element-&gt;value));
<span class="lineNum">     557 </span>            :   const Node * left = element-&gt;left;
<span class="lineNum">     558 </span>            :   if (left != NULL) {
<span class="lineNum">     559 </span>            :     assert(!(element-&gt;value &lt; left-&gt;value));
<span class="lineNum">     560 </span>            :     if (left != left_limit) {
<span class="lineNum">     561 </span>            :       verify_structure_recursive(left, left_limit, element);}
<span class="lineNum">     562 </span>            :   }
<span class="lineNum">     563 </span>            :   const Node * right = element-&gt;right;
<span class="lineNum">     564 </span>            :   if (right != NULL) {
<span class="lineNum">     565 </span>            :     assert(!(right-&gt;value &lt; element-&gt;value));
<span class="lineNum">     566 </span>            :     if (right != right_limit) {
<span class="lineNum">     567 </span>            :       verify_structure_recursive(right, element, right_limit);}
<span class="lineNum">     568 </span>            :   }
<span class="lineNum">     569 </span>            : }
<span class="lineNum">     570 </span>            : template&lt;class T&gt; void SearchTree&lt;T&gt;::verify_structure_linear() const {
<span class="lineNum">     571 </span>            :   unsigned n_top = 0;
<span class="lineNum">     572 </span>            :   unsigned n_null = 0;
<span class="lineNum">     573 </span>            :   for(unsigned i = 0; i &lt; _nodes.size(); i++) {
<span class="lineNum">     574 </span>            :     const typename SearchTree&lt;T&gt;::Node * node = &amp;(_nodes[i]);
<span class="lineNum">     575 </span>            :     if (node-&gt;treelinks_null()) {n_null++; continue;}
<span class="lineNum">     576 </span>            :     if (node-&gt;parent == NULL) {
<span class="lineNum">     577 </span>            :       n_top++;
<span class="lineNum">     578 </span>            :     } else {
<span class="lineNum">     579 </span>            :       assert((node-&gt;parent-&gt;left == node) ^ (node-&gt;parent-&gt;right == node));
<span class="lineNum">     580 </span>            :     }
<span class="lineNum">     581 </span>            :     if (node-&gt;left != NULL) {
<span class="lineNum">     582 </span>            :       assert(!(node-&gt;value &lt; node-&gt;left-&gt;value ));}
<span class="lineNum">     583 </span>            :     if (node-&gt;right != NULL) {
<span class="lineNum">     584 </span>            :       assert(!(node-&gt;right-&gt;value &lt; node-&gt;value ));}
<span class="lineNum">     585 </span>            :   }
<span class="lineNum">     586 </span>            :   assert(n_top == 1 || (n_top == 0 &amp;&amp; size() &lt;= 1) );
<span class="lineNum">     587 </span>            :   assert(n_null == _available_nodes.size() ||
<a name="588"><span class="lineNum">     588 </span>            :          (n_null == _available_nodes.size() + 1 &amp;&amp; size() == 1));</a>
<span class="lineNum">     589 </span>            : }
<span class="lineNum">     590 </span>            : template&lt;class T&gt; typename SearchTree&lt;T&gt;::Node * SearchTree&lt;T&gt;::_find_predecessor(const typename SearchTree&lt;T&gt;::Node * node) {
<span class="lineNum">     591 </span>            :   typename SearchTree&lt;T&gt;::Node * newnode;
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :   if (node-&gt;left != NULL) {</span>
<span class="lineNum">     593 </span>            :     newnode = node-&gt;left;
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :     while(newnode-&gt;right != NULL) {newnode = newnode-&gt;right;}</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :     return newnode;</span>
<span class="lineNum">     596 </span>            :   } else {
<span class="lineNum">     597 </span>            :     const typename SearchTree&lt;T&gt;::Node * lastnode = node;
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :     newnode = node-&gt;parent;</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :     while(newnode != NULL) {</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :       if (newnode-&gt;right == lastnode) {return newnode;}</span>
<span class="lineNum">     601 </span>            :       lastnode = newnode;
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :       newnode = newnode-&gt;parent;</span>
<span class="lineNum">     603 </span>            :     }
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :     return newnode;</span>
<a name="605"><span class="lineNum">     605 </span>            :   }</a>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     607 </span>            : template&lt;class T&gt; typename SearchTree&lt;T&gt;::Node * SearchTree&lt;T&gt;::_find_successor(const typename SearchTree&lt;T&gt;::Node * node) {
<span class="lineNum">     608 </span>            :   typename SearchTree&lt;T&gt;::Node * newnode;
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :   if (node-&gt;right != NULL) {</span>
<span class="lineNum">     610 </span>            :     newnode = node-&gt;right;
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :     while(newnode-&gt;left != NULL) {newnode = newnode-&gt;left;}</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :     return newnode;</span>
<span class="lineNum">     613 </span>            :   } else {
<span class="lineNum">     614 </span>            :     const typename SearchTree&lt;T&gt;::Node * lastnode = node;
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :     newnode = node-&gt;parent;</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :     while(newnode != NULL) {</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :       if (newnode-&gt;left == lastnode) {return newnode;}</span>
<span class="lineNum">     618 </span>            :       lastnode = newnode;
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :       newnode = newnode-&gt;parent;</span>
<span class="lineNum">     620 </span>            :     }
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :     return newnode;</span>
<span class="lineNum">     622 </span>            :   }
<span class="lineNum">     623 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     624 </span>            : template&lt;class T&gt; void SearchTree&lt;T&gt;::print_elements() {
<span class="lineNum">     625 </span>            :   typename SearchTree&lt;T&gt;::Node * base_node = &amp;(_nodes[0]);
<span class="lineNum">     626 </span>            :   typename SearchTree&lt;T&gt;::Node * node = base_node;
<span class="lineNum">     627 </span>            :   int n = _nodes.size();
<span class="lineNum">     628 </span>            :   for(; node - base_node &lt; n ; node++) {
<span class="lineNum">     629 </span>            :     printf(&quot;%4d parent:%4d left:%4d right:%4d pred:%4d succ:%4d value:%10.6f\n&quot;,loc(node), loc(node-&gt;parent), loc(node-&gt;left), loc(node-&gt;right), loc(node-&gt;predecessor),loc(node-&gt;successor),node-&gt;value);
<a name="630"><span class="lineNum">     630 </span>            :   }</a>
<span class="lineNum">     631 </span>            : }
<span class="lineNum">     632 </span>            : template&lt;class T&gt; typename SearchTree&lt;T&gt;::circulator SearchTree&lt;T&gt;::somewhere() {
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :   return circulator(_top_node);</span>
<span class="lineNum">     634 </span>            : }
<span class="lineNum">     635 </span>            : template&lt;class T&gt; typename SearchTree&lt;T&gt;::const_circulator SearchTree&lt;T&gt;::somewhere() const {
<span class="lineNum">     636 </span>            :   return const_circulator(_top_node);
<span class="lineNum">     637 </span>            : }
<span class="lineNum">     638 </span>            : FJCORE_END_NAMESPACE
<span class="lineNum">     639 </span>            : #endif // __FJCORE_SEARCHTREE_HH__
<span class="lineNum">     640 </span>            : #ifndef __FJCORE_MINHEAP__HH__
<span class="lineNum">     641 </span>            : #define __FJCORE_MINHEAP__HH__
<span class="lineNum">     642 </span>            : #include&lt;vector&gt;
<span class="lineNum">     643 </span>            : #include&lt;cassert&gt;
<span class="lineNum">     644 </span>            : #include&lt;memory&gt;
<a name="645"><span class="lineNum">     645 </span>            : #include&lt;limits&gt;</a>
<span class="lineNum">     646 </span>            : FJCORE_BEGIN_NAMESPACE      // defined in fastjet/internal/base.hh
<a name="647"><span class="lineNum">     647 </span><span class="lineNoCov">          0 : class MinHeap {</span></a>
<span class="lineNum">     648 </span>            : public:
<a name="649"><span class="lineNum">     649 </span>            :   MinHeap (const std::vector&lt;double&gt; &amp; values, unsigned int max_size) :</a>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :     _heap(max_size) {_initialise(values);};</span>
<a name="651"><span class="lineNum">     651 </span>            :   MinHeap (const std::vector&lt;double&gt; &amp; values) :</a>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :     _heap(values.size()) {_initialise(values);};</span>
<a name="653"><span class="lineNum">     653 </span>            :   inline unsigned int minloc() const {</a>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :     return (_heap[0].minloc) - &amp;(_heap[0]);};</span>
<a name="655"><span class="lineNum">     655 </span><span class="lineNoCov">          0 :   inline double       minval() const {return _heap[0].minloc-&gt;value;};</span></a>
<span class="lineNum">     656 </span>            :   inline double operator[](int i) const {return _heap[i].value;};
<span class="lineNum">     657 </span>            :   void remove(unsigned int loc) {
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :     update(loc,std::numeric_limits&lt;double&gt;::max());};</span>
<span class="lineNum">     659 </span>            :   void update(unsigned int, double);
<span class="lineNum">     660 </span>            : private:
<span class="lineNum">     661 </span>            :   struct ValueLoc{
<span class="lineNum">     662 </span>            :     double value;
<span class="lineNum">     663 </span>            :     ValueLoc * minloc;
<span class="lineNum">     664 </span>            :   };
<span class="lineNum">     665 </span>            :   std::vector&lt;ValueLoc&gt; _heap;
<span class="lineNum">     666 </span>            :   void _initialise(const std::vector&lt;double&gt; &amp; values);
<span class="lineNum">     667 </span>            : };
<span class="lineNum">     668 </span>            : FJCORE_END_NAMESPACE
<span class="lineNum">     669 </span>            : #endif // __FJCORE_MINHEAP__HH__
<span class="lineNum">     670 </span>            : #ifndef __FJCORE_CLOSESTPAIR2DBASE__HH__
<span class="lineNum">     671 </span>            : #define __FJCORE_CLOSESTPAIR2DBASE__HH__
<span class="lineNum">     672 </span>            : #include&lt;vector&gt;
<span class="lineNum">     673 </span>            : FJCORE_BEGIN_NAMESPACE      // defined in fastjet/internal/base.hh
<span class="lineNum">     674 </span>            : class Coord2D {
<a name="675"><span class="lineNum">     675 </span>            : public:</a>
<a name="676"><span class="lineNum">     676 </span>            :   double x, y;</a>
<a name="677"><span class="lineNum">     677 </span><span class="lineNoCov">          0 :   Coord2D() {};</span></a>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :   Coord2D(double a, double b): x(a), y(b) {};</span>
<span class="lineNum">     679 </span>            :   Coord2D operator-(const Coord2D &amp; other) const {
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :     return Coord2D(x - other.x,  y - other.y);};</span>
<span class="lineNum">     681 </span>            :   Coord2D operator+(const Coord2D &amp; other) const {
<span class="lineNum">     682 </span>            :     return Coord2D(x + other.x,  y + other.y);};
<span class="lineNum">     683 </span>            :   Coord2D operator*(double factor) const {return Coord2D(factor*x,factor*y);};
<span class="lineNum">     684 </span>            :   friend Coord2D operator*(double factor, const Coord2D &amp; coord) {
<a name="685"><span class="lineNum">     685 </span>            :     return Coord2D(factor*coord.x,factor*coord.y);</a>
<span class="lineNum">     686 </span>            :   }
<span class="lineNum">     687 </span>            :   Coord2D operator/(double divisor) const {
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :     return Coord2D(x / divisor,  y / divisor);};</span>
<span class="lineNum">     689 </span>            :   friend double distance2(const Coord2D &amp; a, const Coord2D &amp; b) {
<span class="lineNum">     690 </span>            :     double dx = a.x - b.x, dy = a.y-b.y;
<a name="691"><span class="lineNum">     691 </span>            :     return dx*dx+dy*dy;</a>
<span class="lineNum">     692 </span>            :   };
<span class="lineNum">     693 </span>            :   double distance2(const Coord2D &amp; b) const {
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :     double dx = x - b.x, dy = y-b.y;</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :     return dx*dx+dy*dy;</span>
<a name="696"><span class="lineNum">     696 </span>            :   };</a>
<span class="lineNum">     697 </span>            : };
<span class="lineNum">     698 </span><span class="lineNoCov">          0 : class ClosestPair2DBase {</span>
<span class="lineNum">     699 </span>            : public:
<span class="lineNum">     700 </span>            :   virtual void closest_pair(unsigned int &amp; ID1, unsigned int &amp; ID2,
<span class="lineNum">     701 </span>            :                             double &amp; distance2) const = 0;
<a name="702"><span class="lineNum">     702 </span>            :   virtual void remove(unsigned int ID) = 0;</a>
<span class="lineNum">     703 </span>            :   virtual unsigned int insert(const Coord2D &amp; position) = 0;
<span class="lineNum">     704 </span>            :   virtual unsigned int replace(unsigned int ID1, unsigned int ID2,
<span class="lineNum">     705 </span>            :                                const Coord2D &amp; position) {
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :     remove(ID1);</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :     remove(ID2);</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :     unsigned new_ID = insert(position);</span>
<a name="709"><span class="lineNum">     709 </span><span class="lineNoCov">          0 :     return(new_ID);</span></a>
<span class="lineNum">     710 </span>            :   };
<span class="lineNum">     711 </span>            :   virtual void replace_many(const std::vector&lt;unsigned int&gt; &amp; IDs_to_remove,
<span class="lineNum">     712 </span>            :                        const std::vector&lt;Coord2D&gt; &amp; new_positions,
<span class="lineNum">     713 </span>            :                        std::vector&lt;unsigned int&gt; &amp; new_IDs) {
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :     for(unsigned i = 0; i &lt; IDs_to_remove.size(); i++) {</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :       remove(IDs_to_remove[i]);}</span>
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :     new_IDs.resize(0);</span>
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :     for(unsigned i = 0; i &lt; new_positions.size(); i++) {</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :       new_IDs.push_back(insert(new_positions[i]));}</span>
<a name="719"><span class="lineNum">     719 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">     720 </span>            :   virtual unsigned int size() = 0;
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :   virtual ~ClosestPair2DBase() {};</span>
<span class="lineNum">     722 </span>            : };
<span class="lineNum">     723 </span>            : FJCORE_END_NAMESPACE
<span class="lineNum">     724 </span>            : #endif // __FJCORE_CLOSESTPAIR2DBASE__HH__
<span class="lineNum">     725 </span>            : #ifndef __FJCORE_CLOSESTPAIR2D__HH__
<span class="lineNum">     726 </span>            : #define __FJCORE_CLOSESTPAIR2D__HH__
<span class="lineNum">     727 </span>            : #include&lt;vector&gt;
<span class="lineNum">     728 </span>            : #include&lt;stack&gt;
<a name="729"><span class="lineNum">     729 </span>            : #include&lt;iostream&gt;</a>
<span class="lineNum">     730 </span>            : FJCORE_BEGIN_NAMESPACE      // defined in fastjet/internal/base.hh
<a name="731"><span class="lineNum">     731 </span><span class="lineNoCov">          0 : class ClosestPair2D : public ClosestPair2DBase {</span></a>
<span class="lineNum">     732 </span>            : public:
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :   ClosestPair2D(const std::vector&lt;Coord2D&gt; &amp; positions,</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :                 const Coord2D &amp; left_corner, const Coord2D &amp; right_corner) {</span>
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :     _initialize(positions, left_corner, right_corner, positions.size());</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :   };</span>
<span class="lineNum">     737 </span>            :   ClosestPair2D(const std::vector&lt;Coord2D&gt; &amp; positions,
<span class="lineNum">     738 </span>            :                 const Coord2D &amp; left_corner, const Coord2D &amp; right_corner,
<span class="lineNum">     739 </span>            :                 const unsigned int max_size) {
<span class="lineNum">     740 </span>            :     _initialize(positions, left_corner, right_corner, max_size);
<span class="lineNum">     741 </span>            :   };
<span class="lineNum">     742 </span>            :   void closest_pair(unsigned int &amp; ID1, unsigned int &amp; ID2,
<span class="lineNum">     743 </span>            :                     double &amp; distance2) const;
<span class="lineNum">     744 </span>            :   void remove(unsigned int ID);
<span class="lineNum">     745 </span>            :   unsigned int insert(const Coord2D &amp;);
<span class="lineNum">     746 </span>            :   virtual unsigned int replace(unsigned int ID1, unsigned int ID2,
<span class="lineNum">     747 </span>            :                                const Coord2D &amp; position);
<span class="lineNum">     748 </span>            :   virtual void replace_many(const std::vector&lt;unsigned int&gt; &amp; IDs_to_remove,
<span class="lineNum">     749 </span>            :                             const std::vector&lt;Coord2D&gt; &amp; new_positions,
<span class="lineNum">     750 </span>            :                             std::vector&lt;unsigned int&gt; &amp; new_IDs);
<span class="lineNum">     751 </span>            :   inline void print_tree_depths(std::ostream &amp; outdev) const {
<span class="lineNum">     752 </span>            :     outdev    &lt;&lt; _trees[0]-&gt;max_depth() &lt;&lt; &quot; &quot;
<span class="lineNum">     753 </span>            :               &lt;&lt; _trees[1]-&gt;max_depth() &lt;&lt; &quot; &quot;
<span class="lineNum">     754 </span>            :               &lt;&lt; _trees[2]-&gt;max_depth() &lt;&lt; &quot;\n&quot;;
<span class="lineNum">     755 </span>            :   };
<span class="lineNum">     756 </span>            :   unsigned int size();
<span class="lineNum">     757 </span>            : private:
<span class="lineNum">     758 </span>            :   void _initialize(const std::vector&lt;Coord2D&gt; &amp; positions,
<span class="lineNum">     759 </span>            :               const Coord2D &amp; left_corner, const Coord2D &amp; right_corner,
<span class="lineNum">     760 </span>            :               const unsigned int max_size);
<a name="761"><span class="lineNum">     761 </span>            :   static const unsigned int _nshift = 3;</a>
<span class="lineNum">     762 </span>            :   class Point; // will be defined below
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :   template&lt;class T&gt; class triplet {</span>
<a name="764"><span class="lineNum">     764 </span>            :   public:</a>
<span class="lineNum">     765 </span>            :     inline const T &amp; operator[](unsigned int i) const {return _contents[i];};
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :     inline       T &amp; operator[](unsigned int i)       {return _contents[i];};</span>
<span class="lineNum">     767 </span>            :   private:
<span class="lineNum">     768 </span>            :     T _contents[_nshift];
<span class="lineNum">     769 </span>            :   };
<span class="lineNum">     770 </span>            :   class Shuffle {
<span class="lineNum">     771 </span>            :   public:
<span class="lineNum">     772 </span>            :     unsigned int x, y;
<a name="773"><span class="lineNum">     773 </span>            :     Point * point;</a>
<span class="lineNum">     774 </span>            :     bool operator&lt;(const Shuffle &amp;) const;
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :     void operator+=(unsigned int shift) {x += shift; y+= shift;};</span>
<span class="lineNum">     776 </span>            :   };
<span class="lineNum">     777 </span>            :   typedef SearchTree&lt;Shuffle&gt;     Tree;
<span class="lineNum">     778 </span>            :   typedef Tree::circulator        circulator;
<span class="lineNum">     779 </span>            :   typedef Tree::const_circulator  const_circulator;
<span class="lineNum">     780 </span>            :   triplet&lt;std::auto_ptr&lt;Tree&gt; &gt;  _trees;
<span class="lineNum">     781 </span>            :   std::auto_ptr&lt;MinHeap&gt; _heap;
<span class="lineNum">     782 </span>            :   std::vector&lt;Point&gt;     _points;
<span class="lineNum">     783 </span>            :   std::stack&lt;Point *&gt;    _available_points;
<span class="lineNum">     784 </span>            :   std::vector&lt;Point *&gt;   _points_under_review;
<span class="lineNum">     785 </span>            :   static const unsigned int _remove_heap_entry = 1;
<span class="lineNum">     786 </span>            :   static const unsigned int _review_heap_entry = 2;
<span class="lineNum">     787 </span>            :   static const unsigned int _review_neighbour  = 4;
<span class="lineNum">     788 </span>            :   void _add_label(Point * point, unsigned int review_flag);
<span class="lineNum">     789 </span>            :   void _set_label(Point * point, unsigned int review_flag);
<span class="lineNum">     790 </span>            :   void _deal_with_points_to_review();
<span class="lineNum">     791 </span>            :   void _remove_from_search_tree(Point * point_to_remove);
<span class="lineNum">     792 </span>            :   void _insert_into_search_tree(Point * new_point);
<span class="lineNum">     793 </span>            :   void _point2shuffle(Point &amp; , Shuffle &amp; , unsigned int shift);
<span class="lineNum">     794 </span>            :   Coord2D _left_corner;
<span class="lineNum">     795 </span>            :   double _range;
<span class="lineNum">     796 </span>            :   int _ID(const Point *) const;
<span class="lineNum">     797 </span>            :   triplet&lt;unsigned int&gt; _shifts;     // absolute shifts
<span class="lineNum">     798 </span>            :   triplet&lt;unsigned int&gt; _rel_shifts; // shifts relative to previous shift
<a name="799"><span class="lineNum">     799 </span>            :   unsigned int _cp_search_range;</a>
<span class="lineNum">     800 </span>            : };
<span class="lineNum">     801 </span><span class="lineNoCov">          0 : class ClosestPair2D::Point {</span>
<span class="lineNum">     802 </span>            : public:
<span class="lineNum">     803 </span>            :   Coord2D coord;
<span class="lineNum">     804 </span>            :   Point * neighbour;
<span class="lineNum">     805 </span>            :   double  neighbour_dist2;
<a name="806"><span class="lineNum">     806 </span>            :   triplet&lt;circulator&gt; circ;</a>
<span class="lineNum">     807 </span>            :   unsigned int review_flag;
<span class="lineNum">     808 </span>            :   double distance2(const Point &amp; other) const {
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :     return coord.distance2(other.coord);</span>
<a name="810"><span class="lineNum">     810 </span>            :   };</a>
<span class="lineNum">     811 </span>            : };
<span class="lineNum">     812 </span>            : inline bool floor_ln2_less(unsigned x, unsigned y) {
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :   if (x&gt;y) return false;</span>
<a name="814"><span class="lineNum">     814 </span><span class="lineNoCov">          0 :   return (x &lt; (x^y)); // beware of operator precedence...</span></a>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     816 </span>            : inline int ClosestPair2D::_ID(const Point * point) const {
<a name="817"><span class="lineNum">     817 </span><span class="lineNoCov">          0 :   return point - &amp;(_points[0]);</span></a>
<span class="lineNum">     818 </span>            : }
<span class="lineNum">     819 </span>            : inline unsigned int ClosestPair2D::size() {
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :   return _points.size() - _available_points.size();</span>
<span class="lineNum">     821 </span>            : }
<span class="lineNum">     822 </span>            : FJCORE_END_NAMESPACE
<span class="lineNum">     823 </span>            : #endif // __FJCORE_CLOSESTPAIR2D__HH__
<span class="lineNum">     824 </span>            : #include&lt;limits&gt;
<span class="lineNum">     825 </span>            : #include&lt;iostream&gt;
<span class="lineNum">     826 </span>            : #include&lt;iomanip&gt;
<span class="lineNum">     827 </span>            : #include&lt;algorithm&gt;
<span class="lineNum">     828 </span>            : FJCORE_BEGIN_NAMESPACE      // defined in fastjet/internal/base.hh
<span class="lineNum">     829 </span>            : // Next line commented out, by author agreement, to avoid compiler warning.
<span class="lineNum">     830 </span>            : //const unsigned int huge_unsigned = 4294967295U;
<a name="831"><span class="lineNum">     831 </span>            : const unsigned int twopow31      = 2147483648U;</a>
<span class="lineNum">     832 </span>            : using namespace std;
<span class="lineNum">     833 </span>            : void ClosestPair2D::_point2shuffle(Point &amp; point, Shuffle &amp; shuffle,
<span class="lineNum">     834 </span>            :                                   unsigned int shift) {
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :   Coord2D renorm_point = (point.coord - _left_corner)/_range;</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :   assert(renorm_point.x &gt;=0);</span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :   assert(renorm_point.x &lt;=1);</span>
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :   assert(renorm_point.y &gt;=0);</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :   assert(renorm_point.y &lt;=1);</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :   shuffle.x = static_cast&lt;unsigned int&gt;(twopow31 * renorm_point.x) + shift;</span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :   shuffle.y = static_cast&lt;unsigned int&gt;(twopow31 * renorm_point.y) + shift;</span>
<a name="842"><span class="lineNum">     842 </span><span class="lineNoCov">          0 :   shuffle.point = &amp;point;</span></a>
<span class="lineNum">     843 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     844 </span>            : bool ClosestPair2D::Shuffle::operator&lt;(const Shuffle &amp; q) const {
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :   if (floor_ln2_less(x ^ q.x, y ^ q.y)) {</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :     return (y &lt; q.y);</span>
<span class="lineNum">     847 </span>            :   } else {
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :     return (x &lt; q.x);</span>
<a name="849"><span class="lineNum">     849 </span>            :   }</a>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     851 </span>            : void ClosestPair2D::_initialize(const std::vector&lt;Coord2D&gt; &amp; positions,
<span class="lineNum">     852 </span>            :                              const Coord2D &amp; left_corner,
<span class="lineNum">     853 </span>            :                              const Coord2D &amp; right_corner,
<span class="lineNum">     854 </span>            :                              unsigned int max_size) {
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :   unsigned int n_positions = positions.size();</span>
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :   assert(max_size &gt;= n_positions);</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :   _points.resize(max_size);</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :   for (unsigned int i = n_positions; i &lt; max_size; i++) {</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :     _available_points.push(&amp;(_points[i]));</span>
<span class="lineNum">     860 </span>            :   }
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :   _left_corner = left_corner;</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :   _range       = max((right_corner.x - left_corner.x),</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :                      (right_corner.y - left_corner.y));</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :   vector&lt;Shuffle&gt; shuffles(n_positions);</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :   for (unsigned int i = 0; i &lt; n_positions; i++) {</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :     _points[i].coord = positions[i];</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :     _points[i].neighbour_dist2 = numeric_limits&lt;double&gt;::max();</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :     _points[i].review_flag = 0;</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :     _point2shuffle(_points[i], shuffles[i], 0);</span>
<span class="lineNum">     870 </span>            :   }
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :   for (unsigned ishift = 0; ishift &lt; _nshift; ishift++) {</span>
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :    _shifts[ishift] = static_cast&lt;unsigned int&gt;(((twopow31*1.0)*ishift)/_nshift);</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :     if (ishift == 0) {_rel_shifts[ishift] = 0;}</span>
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :     else {_rel_shifts[ishift] = _shifts[ishift] - _shifts[ishift-1];}</span>
<span class="lineNum">     875 </span>            :   }
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :   _cp_search_range = 30;</span>
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :   _points_under_review.reserve(_nshift * _cp_search_range);</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :   for (unsigned int ishift = 0; ishift &lt; _nshift; ishift++) {</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :     if (ishift &gt; 0) {</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :       unsigned rel_shift = _rel_shifts[ishift];</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :       for (unsigned int i = 0; i &lt; shuffles.size(); i++) {</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :         shuffles[i] += rel_shift; }</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :     sort(shuffles.begin(), shuffles.end());</span>
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :     _trees[ishift] = auto_ptr&lt;Tree&gt;(new Tree(shuffles, max_size));</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :     circulator circ = _trees[ishift]-&gt;somewhere(), start=circ;</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :     unsigned int CP_range = min(_cp_search_range, n_positions-1);</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :     do {</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :       Point * this_point = circ-&gt;point;</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :       this_point-&gt;circ[ishift] = circ;</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :       circulator other = circ;</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :       for (unsigned i=0; i &lt; CP_range; i++) {</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :         ++other;</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :         double dist2 = this_point-&gt;distance2(*other-&gt;point);</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :         if (dist2 &lt; this_point-&gt;neighbour_dist2) {</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :           this_point-&gt;neighbour_dist2 = dist2;</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :           this_point-&gt;neighbour       = other-&gt;point;</span>
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     899 </span>            :       }
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :     } while (++circ != start);</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :   vector&lt;double&gt; mindists2(n_positions);</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :   for (unsigned int i = 0; i &lt; n_positions; i++) {</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :     mindists2[i] = _points[i].neighbour_dist2;}</span>
<a name="905"><span class="lineNum">     905 </span><span class="lineNoCov">          0 :   _heap = auto_ptr&lt;MinHeap&gt;(new MinHeap(mindists2, max_size));</span></a>
<span class="lineNum">     906 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     907 </span>            : void ClosestPair2D::closest_pair(unsigned int &amp; ID1, unsigned int &amp; ID2,
<span class="lineNum">     908 </span>            :                                  double &amp; distance2) const {
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :   ID1 = _heap-&gt;minloc();</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :   ID2 = _ID(_points[ID1].neighbour);</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :   distance2 = _points[ID1].neighbour_dist2;</span>
<a name="912"><span class="lineNum">     912 </span><span class="lineNoCov">          0 :   if (ID1 &gt; ID2) std::swap(ID1,ID2);</span></a>
<span class="lineNum">     913 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     914 </span>            : inline void ClosestPair2D::_add_label(Point * point, unsigned int review_flag) {
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :   if (point-&gt;review_flag == 0) _points_under_review.push_back(point);</span>
<a name="916"><span class="lineNum">     916 </span><span class="lineNoCov">          0 :   point-&gt;review_flag |= review_flag;</span></a>
<span class="lineNum">     917 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     918 </span>            : inline void ClosestPair2D::_set_label(Point * point, unsigned int review_flag) {
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :   if (point-&gt;review_flag == 0) _points_under_review.push_back(point);</span>
<a name="920"><span class="lineNum">     920 </span><span class="lineNoCov">          0 :   point-&gt;review_flag = review_flag;</span></a>
<span class="lineNum">     921 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     922 </span>            : void ClosestPair2D::remove(unsigned int ID) {
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :   Point * point_to_remove = &amp; (_points[ID]);</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :   _remove_from_search_tree(point_to_remove);</span>
<a name="925"><span class="lineNum">     925 </span><span class="lineNoCov">          0 :   _deal_with_points_to_review();</span></a>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     927 </span>            : void ClosestPair2D::_remove_from_search_tree(Point * point_to_remove) {
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :   _available_points.push(point_to_remove);</span>
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :   _set_label(point_to_remove, _remove_heap_entry);</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :   unsigned int CP_range = min(_cp_search_range, size()-1);</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :   for (unsigned int ishift = 0; ishift &lt; _nshift; ishift++) {</span>
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :     circulator removed_circ = point_to_remove-&gt;circ[ishift];</span>
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :     circulator right_end = removed_circ.next();</span>
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :     _trees[ishift]-&gt;remove(removed_circ);</span>
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :     circulator left_end  = right_end, orig_right_end = right_end;</span>
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :     for (unsigned int i = 0; i &lt; CP_range; i++) {left_end--;}</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :     if (size()-1 &lt; _cp_search_range) {</span>
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :       left_end--; right_end--;</span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     940 </span>            :     do {
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :       Point * left_point = left_end-&gt;point;</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :       if (left_point-&gt;neighbour == point_to_remove) {</span>
<span class="lineNum">     943 </span>            :         // we'll deal with it later...
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :         _add_label(left_point, _review_neighbour);</span>
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :       } else {</span>
<span class="lineNum">     946 </span>            :         // check to see if right point has become its closest neighbour
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :         double dist2 = left_point-&gt;distance2(*right_end-&gt;point);</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :         if (dist2 &lt; left_point-&gt;neighbour_dist2) {</span>
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :           left_point-&gt;neighbour = right_end-&gt;point;</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :           left_point-&gt;neighbour_dist2 = dist2;</span>
<span class="lineNum">     951 </span>            :           // NB: (LESSER) REVIEW NEEDED HERE TOO...
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :           _add_label(left_point, _review_heap_entry);</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     954 </span>            :       }
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :       ++right_end;</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :     } while (++left_end != orig_right_end);</span>
<a name="957"><span class="lineNum">     957 </span><span class="lineNoCov">          0 :   } // ishift...</span></a>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     959 </span>            : void ClosestPair2D::_deal_with_points_to_review() {
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :   unsigned int CP_range = min(_cp_search_range, size()-1);</span>
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :   while(_points_under_review.size() &gt; 0) {</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :     Point * this_point = _points_under_review.back();</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :     _points_under_review.pop_back();</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :     if (this_point-&gt;review_flag &amp; _remove_heap_entry) {</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :       assert(!(this_point-&gt;review_flag ^ _remove_heap_entry));</span>
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :       _heap-&gt;remove(_ID(this_point));</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     968 </span>            :     else {
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :       if (this_point-&gt;review_flag &amp; _review_neighbour) {</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :         this_point-&gt;neighbour_dist2 = numeric_limits&lt;double&gt;::max();</span>
<span class="lineNum">     971 </span>            :         // among all three shifts
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :         for (unsigned int ishift = 0; ishift &lt; _nshift; ishift++) {</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :           circulator other = this_point-&gt;circ[ishift];</span>
<span class="lineNum">     974 </span>            :           // among points within CP_range
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :           for (unsigned i=0; i &lt; CP_range; i++) {</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :             ++other;</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :             double dist2 = this_point-&gt;distance2(*other-&gt;point);</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :             if (dist2 &lt; this_point-&gt;neighbour_dist2) {</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :               this_point-&gt;neighbour_dist2 = dist2;</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :               this_point-&gt;neighbour       = other-&gt;point;</span>
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">     982 </span>            :           }
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :       _heap-&gt;update(_ID(this_point), this_point-&gt;neighbour_dist2);</span>
<span class="lineNum">     986 </span>            :     }
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :     this_point-&gt;review_flag = 0;</span>
<a name="988"><span class="lineNum">     988 </span>            :   }</a>
<span class="lineNum">     989 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     990 </span>            : unsigned int ClosestPair2D::insert(const Coord2D &amp; new_coord) {
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :   assert(_available_points.size() &gt; 0);</span>
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :   Point * new_point = _available_points.top();</span>
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :   _available_points.pop();</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :   new_point-&gt;coord = new_coord;</span>
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :   _insert_into_search_tree(new_point);</span>
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :   _deal_with_points_to_review();</span>
<a name="997"><span class="lineNum">     997 </span><span class="lineNoCov">          0 :   return _ID(new_point);</span></a>
<span class="lineNum">     998 </span>            : }
<span class="lineNum">     999 </span>            : unsigned int ClosestPair2D::replace(unsigned int ID1, unsigned int ID2,
<span class="lineNum">    1000 </span>            :                                     const Coord2D &amp; position) {
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :   Point * point_to_remove = &amp; (_points[ID1]);</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :   _remove_from_search_tree(point_to_remove);</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :   point_to_remove = &amp; (_points[ID2]);</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :   _remove_from_search_tree(point_to_remove);</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :   Point * new_point = _available_points.top();</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :   _available_points.pop();</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :   new_point-&gt;coord = position;</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :   _insert_into_search_tree(new_point);</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :   _deal_with_points_to_review();</span>
<a name="1010"><span class="lineNum">    1010 </span><span class="lineNoCov">          0 :   return _ID(new_point);</span></a>
<span class="lineNum">    1011 </span>            : }
<span class="lineNum">    1012 </span>            : void ClosestPair2D::replace_many(
<span class="lineNum">    1013 </span>            :                   const std::vector&lt;unsigned int&gt; &amp; IDs_to_remove,
<span class="lineNum">    1014 </span>            :                   const std::vector&lt;Coord2D&gt; &amp; new_positions,
<span class="lineNum">    1015 </span>            :                   std::vector&lt;unsigned int&gt; &amp; new_IDs) {
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :   for (unsigned int i = 0; i &lt; IDs_to_remove.size(); i++) {</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :     _remove_from_search_tree(&amp; (_points[IDs_to_remove[i]]));</span>
<span class="lineNum">    1018 </span>            :   }
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :   new_IDs.resize(0);</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :   for (unsigned int i = 0; i &lt; new_positions.size(); i++) {</span>
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :     Point * new_point = _available_points.top();</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :     _available_points.pop();</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :     new_point-&gt;coord = new_positions[i];</span>
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :     _insert_into_search_tree(new_point);</span>
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :     new_IDs.push_back(_ID(new_point));</span>
<span class="lineNum">    1026 </span>            :   }
<a name="1027"><span class="lineNum">    1027 </span><span class="lineNoCov">          0 :   _deal_with_points_to_review();</span></a>
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1029 </span>            : void ClosestPair2D::_insert_into_search_tree(Point * new_point) {
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :   _set_label(new_point, _review_heap_entry);</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :   new_point-&gt;neighbour_dist2 = numeric_limits&lt;double&gt;::max();</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :   unsigned int CP_range = min(_cp_search_range, size()-1);</span>
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :   for (unsigned ishift = 0; ishift &lt; _nshift; ishift++) {</span>
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :     Shuffle new_shuffle;</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :     _point2shuffle(*new_point, new_shuffle, _shifts[ishift]);</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :     circulator new_circ = _trees[ishift]-&gt;insert(new_shuffle);</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :     new_point-&gt;circ[ishift] = new_circ;</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :     circulator right_edge = new_circ; right_edge++;</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :     circulator left_edge  = new_circ;</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :     for (unsigned int i = 0; i &lt; CP_range; i++) {left_edge--;}</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :     do {</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :       Point * left_point  = left_edge-&gt;point;</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :       Point * right_point = right_edge-&gt;point;</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :       double new_dist2 = left_point-&gt;distance2(*new_point);</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :       if (new_dist2 &lt; left_point-&gt;neighbour_dist2) {</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :         left_point-&gt;neighbour_dist2 = new_dist2;</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :         left_point-&gt;neighbour       = new_point;</span>
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :         _add_label(left_point, _review_heap_entry);</span>
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :       new_dist2 = new_point-&gt;distance2(*right_point);</span>
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :       if (new_dist2 &lt; new_point-&gt;neighbour_dist2) {</span>
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :         new_point-&gt;neighbour_dist2 = new_dist2;</span>
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :         new_point-&gt;neighbour = right_point;</span>
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :       if (left_point-&gt;neighbour == right_point) {</span>
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :         _add_label(left_point, _review_neighbour);</span>
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :       right_edge++;</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :     } while (++left_edge != new_circ);</span>
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1062 </span>            : FJCORE_END_NAMESPACE
<span class="lineNum">    1063 </span>            : #include&lt;iostream&gt;
<span class="lineNum">    1064 </span>            : #include&lt;sstream&gt;
<span class="lineNum">    1065 </span>            : #include&lt;fstream&gt;
<span class="lineNum">    1066 </span>            : #include&lt;cmath&gt;
<span class="lineNum">    1067 </span>            : #include&lt;cstdlib&gt;
<span class="lineNum">    1068 </span>            : #include&lt;cassert&gt;
<span class="lineNum">    1069 </span>            : #include&lt;string&gt;
<span class="lineNum">    1070 </span>            : #include&lt;set&gt;
<span class="lineNum">    1071 </span>            : FJCORE_BEGIN_NAMESPACE      // defined in fastjet/internal/base.hh
<a name="1072"><span class="lineNum">    1072 </span>            : using namespace std;</a>
<span class="lineNum">    1073 </span>            : std::ostream * ClusterSequence::_fastjet_banner_ostr = &amp;cout;
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 : ClusterSequence::~ClusterSequence () {</span>
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :   if (_structure_shared_ptr()){</span>
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :     ClusterSequenceStructure* csi = dynamic_cast&lt;ClusterSequenceStructure*&gt;(_structure_shared_ptr());</span>
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :     assert(csi != NULL);</span>
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :     csi-&gt;set_associated_cs(NULL);</span>
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :     if (_deletes_self_when_unused) {</span>
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :       _structure_shared_ptr.set_count(_structure_shared_ptr.use_count()</span>
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :                                         + _structure_use_count_after_construction);</span>
<span class="lineNum">    1082 </span>            :     }
<a name="1083"><span class="lineNum">    1083 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1085 </span>            : void ClusterSequence::signal_imminent_self_deletion() const {
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :   assert(_deletes_self_when_unused);</span>
<a name="1087"><span class="lineNum">    1087 </span><span class="lineNoCov">          0 :   _deletes_self_when_unused = false;</span></a>
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1089 </span>            : void ClusterSequence::_initialise_and_run (
<span class="lineNum">    1090 </span>            :                                   const JetDefinition &amp; jet_def_in,
<span class="lineNum">    1091 </span>            :                                   const bool &amp; writeout_combinations) {
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :   _decant_options(jet_def_in, writeout_combinations);</span>
<a name="1093"><span class="lineNum">    1093 </span><span class="lineNoCov">          0 :   _initialise_and_run_no_decant();</span></a>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1095 </span>            : void ClusterSequence::_initialise_and_run_no_decant () {
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :   _fill_initial_history();</span>
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :   if (n_particles() == 0) return;</span>
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :   if (_jet_algorithm == plugin_algorithm) {</span>
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :     _plugin_activated = true;</span>
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :     _jet_def.plugin()-&gt;run_clustering( (*this) );</span>
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :     _plugin_activated = false;</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :     _update_structure_use_count();</span>
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :   } else if (_jet_algorithm == ee_kt_algorithm ||</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :              _jet_algorithm == ee_genkt_algorithm) {</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :     _strategy = N2Plain;</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :     if (_jet_algorithm == ee_kt_algorithm) {</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :       assert(_Rparam &gt; 2.0);</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :       _invR2 = 1.0;</span>
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :       if (_Rparam &gt; pi) {</span>
<span class="lineNum">    1112 </span>            :         // choose a value that ensures that back-to-back particles will
<span class="lineNum">    1113 </span>            :         // always recombine
<span class="lineNum">    1114 </span>            :         //_R2 = 4.0000000000001;
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :         _R2 = 2 * ( 3.0 + cos(_Rparam) );</span>
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :       } else {</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :         _R2    = 2 * ( 1.0 - cos(_Rparam) );</span>
<span class="lineNum">    1118 </span>            :       }
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :       _invR2 = 1.0/_R2;</span>
<span class="lineNum">    1120 </span>            :     }
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :     _simple_N2_cluster_EEBriefJet();</span>
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :   } else if (_jet_algorithm == undefined_jet_algorithm) {</span>
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :     throw Error(&quot;A ClusterSequence cannot be created with an uninitialised JetDefinition&quot;);</span>
<span class="lineNum">    1125 </span>            :   }
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :   if (_strategy == Best) {</span>
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :     int N = _jets.size();</span>
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :     if (min(1.0,max(0.1,_Rparam)*3.3)*N &lt;= 30) {</span>
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :       _strategy = N2Plain;</span>
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :     } else if (N &gt; 6200/pow(_Rparam,2.0) &amp;&amp; _jet_def.jet_algorithm() == cambridge_algorithm) {</span>
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :       _strategy = NlnNCam;</span>
<span class="lineNum">    1132 </span>            : #ifndef __FJCORE_DROP_CGAL
<span class="lineNum">    1133 </span>            :     } else if ((N &gt; 16000/pow(_Rparam,1.15) &amp;&amp; _jet_def.jet_algorithm() != antikt_algorithm)
<span class="lineNum">    1134 </span>            :                || N &gt; 35000/pow(_Rparam,1.15)) {
<span class="lineNum">    1135 </span>            :       _strategy = NlnN;
<span class="lineNum">    1136 </span>            : #endif  // __FJCORE_DROP_CGAL
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :     } else if (N &lt;= 450) {</span>
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :       _strategy = N2Tiled;</span>
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :       _strategy = N2MinHeapTiled;</span>
<span class="lineNum">    1141 </span>            :     }
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :   if (_Rparam &gt;= twopi) {</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :     if (   _strategy == NlnN</span>
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :         || _strategy == NlnN3pi</span>
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :         || _strategy == NlnNCam</span>
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :         || _strategy == NlnNCam2pi2R</span>
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :         || _strategy == NlnNCam4pi) {</span>
<span class="lineNum">    1149 </span>            : #ifdef __FJCORE_DROP_CGAL
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :       _strategy = N2MinHeapTiled;</span>
<span class="lineNum">    1151 </span>            : #else
<span class="lineNum">    1152 </span>            :       _strategy = NlnN4pi;
<span class="lineNum">    1153 </span>            : #endif
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :     if (_jet_def.strategy() != Best &amp;&amp; _strategy != _jet_def.strategy()) {</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :       ostringstream oss;</span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :       oss &lt;&lt; &quot;Cluster strategy &quot; &lt;&lt; strategy_string(_jet_def.strategy())</span>
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot; automatically changed to &quot; &lt;&lt; strategy_string()</span>
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot; because the former is not supported for R = &quot; &lt;&lt; _Rparam</span>
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot; &gt;= 2pi&quot;;</span>
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :       _changed_strategy_warning.warn(oss.str());</span>
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1163 </span>            :   }
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :   if (_strategy == N2Plain) {</span>
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :     this-&gt;_simple_N2_cluster_BriefJet();</span>
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :   } else if (_strategy == N2Tiled) {</span>
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :     this-&gt;_faster_tiled_N2_cluster();</span>
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :   } else if (_strategy == N2MinHeapTiled) {</span>
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :     this-&gt;_minheap_faster_tiled_N2_cluster();</span>
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :   } else if (_strategy == NlnN) {</span>
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :     this-&gt;_delaunay_cluster();</span>
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :   } else if (_strategy == NlnNCam) {</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :     this-&gt;_CP2DChan_cluster_2piMultD();</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :   } else if (_strategy == NlnN3pi || _strategy == NlnN4pi ) {</span>
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :     this-&gt;_delaunay_cluster();</span>
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 :   } else if (_strategy ==  N3Dumb ) {</span>
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :     this-&gt;_really_dumb_cluster();</span>
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :   } else if (_strategy == N2PoorTiled) {</span>
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :     this-&gt;_tiled_N2_cluster();</span>
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :   } else if (_strategy == NlnNCam4pi) {</span>
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :     this-&gt;_CP2DChan_cluster();</span>
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :   } else if (_strategy == NlnNCam2pi2R) {</span>
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :     this-&gt;_CP2DChan_cluster_2pi2R();</span>
<span class="lineNum">    1184 </span>            :   } else {
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :     ostringstream err;</span>
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :     err &lt;&lt; &quot;Unrecognised value for strategy: &quot;&lt;&lt;_strategy;</span>
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :     throw Error(err.str());</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 : }</span>
<a name="1190"><span class="lineNum">    1190 </span>            : bool ClusterSequence::_first_time = true;</a>
<span class="lineNum">    1191 </span>            : int ClusterSequence::_n_exclusive_warnings = 0;
<span class="lineNum">    1192 </span>            : string fastjet_version_string() {
<a name="1193"><span class="lineNum">    1193 </span><span class="lineNoCov">          0 :   return &quot;FastJet version &quot;+string(fastjet_version)+&quot; [fjcore]&quot;;</span></a>
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1195 </span>            : void ClusterSequence::print_banner() {
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :   if (!_first_time) {return;}</span>
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :   _first_time = false;</span>
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :   ostream * ostr = _fastjet_banner_ostr;</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :   if (!ostr) return;</span>
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :   (*ostr) &lt;&lt; &quot;#--------------------------------------------------------------------------\n&quot;;</span>
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :   (*ostr) &lt;&lt; &quot;#                     FastJet release &quot; &lt;&lt; fastjet_version &lt;&lt; &quot; [fjcore]&quot; &lt;&lt; endl;</span>
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :   (*ostr) &lt;&lt; &quot;#                 M. Cacciari, G.P. Salam and G. Soyez                  \n&quot;;</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :   (*ostr) &lt;&lt; &quot;#     A software package for jet finding and analysis at colliders      \n&quot;;</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :   (*ostr) &lt;&lt; &quot;#                           http://fastjet.fr                           \n&quot;;</span>
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 :   (*ostr) &lt;&lt; &quot;#                                                                            \n&quot;;</span>
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :   (*ostr) &lt;&lt; &quot;# Please cite EPJC72(2012)1896 [arXiv:1111.6097] if you use this package\n&quot;;</span>
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :   (*ostr) &lt;&lt; &quot;# for scientific work and optionally PLB641(2006)57 [hep-ph/0512210].   \n&quot;;</span>
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :   (*ostr) &lt;&lt; &quot;#                                                                       \n&quot;;</span>
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :   (*ostr) &lt;&lt; &quot;# FastJet is provided without warranty under the terms of the GNU GPLv2.\n&quot;;</span>
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :   (*ostr) &lt;&lt; &quot;# It uses T. Chan's closest pair algorithm, S. Fortune's Voronoi code&quot;;</span>
<span class="lineNum">    1211 </span>            : #ifndef __FJCORE_DROP_CGAL
<span class="lineNum">    1212 </span>            :   (*ostr) &lt;&lt; &quot;,\n# CGAL &quot;;
<span class="lineNum">    1213 </span>            : #else
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :   (*ostr) &lt;&lt; &quot;\n# &quot;;</span>
<span class="lineNum">    1215 </span>            : #endif  // __FJCORE_DROP_CGAL
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :   (*ostr) &lt;&lt; &quot;and 3rd party plugin jet algorithms. See COPYING file for details.\n&quot;;</span>
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :   (*ostr) &lt;&lt; &quot;#--------------------------------------------------------------------------\n&quot;;</span>
<a name="1218"><span class="lineNum">    1218 </span><span class="lineNoCov">          0 :   ostr-&gt;flush();</span></a>
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1220 </span>            : void ClusterSequence::_decant_options(const JetDefinition &amp; jet_def_in,
<span class="lineNum">    1221 </span>            :                                       const bool &amp; writeout_combinations) {
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :   _jet_def = jet_def_in;</span>
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :   _writeout_combinations = writeout_combinations;</span>
<span class="lineNum">    1224 </span><span class="lineNoCov">          0 :   _structure_shared_ptr.reset(new ClusterSequenceStructure(this));</span>
<a name="1225"><span class="lineNum">    1225 </span><span class="lineNoCov">          0 :   _decant_options_partial();</span></a>
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1227 </span>            : void ClusterSequence::_decant_options_partial() {
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :   print_banner();</span>
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :   _jet_algorithm = _jet_def.jet_algorithm();</span>
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :   _Rparam = _jet_def.R();  _R2 = _Rparam*_Rparam; _invR2 = 1.0/_R2;</span>
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :   _strategy = _jet_def.strategy();</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :   _plugin_activated = false;</span>
<a name="1233"><span class="lineNum">    1233 </span><span class="lineNoCov">          0 :   _update_structure_use_count(); // make sure it's correct already here</span></a>
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1235 </span>            : void ClusterSequence::_fill_initial_history () {
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 :   _jets.reserve(_jets.size()*2);</span>
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :   _history.reserve(_jets.size()*2);</span>
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :   _Qtot = 0;</span>
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; static_cast&lt;int&gt;(_jets.size()) ; i++) {</span>
<span class="lineNum">    1240 </span><span class="lineNoCov">          0 :     history_element element;</span>
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :     element.parent1 = InexistentParent;</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :     element.parent2 = InexistentParent;</span>
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :     element.child   = Invalid;</span>
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 :     element.jetp_index = i;</span>
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :     element.dij     = 0.0;</span>
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 :     element.max_dij_so_far = 0.0;</span>
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :     _history.push_back(element);</span>
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :     _jet_def.recombiner()-&gt;preprocess(_jets[i]);</span>
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :     _jets[i].set_cluster_hist_index(i);</span>
<span class="lineNum">    1250 </span><span class="lineNoCov">          0 :     _set_structure_shared_ptr(_jets[i]);</span>
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :     _Qtot += _jets[i].E();</span>
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :   _initial_n = _jets.size();</span>
<a name="1254"><span class="lineNum">    1254 </span><span class="lineNoCov">          0 :   _deletes_self_when_unused = false;</span></a>
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1256 </span>            : string ClusterSequence::strategy_string (Strategy strategy_in)  const {
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :   string strategy;</span>
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :   switch(strategy_in) {</span>
<span class="lineNum">    1259 </span>            :   case NlnN:
<span class="lineNum">    1260 </span><span class="lineNoCov">          0 :     strategy = &quot;NlnN&quot;; break;</span>
<span class="lineNum">    1261 </span>            :   case NlnN3pi:
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :     strategy = &quot;NlnN3pi&quot;; break;</span>
<span class="lineNum">    1263 </span>            :   case NlnN4pi:
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :     strategy = &quot;NlnN4pi&quot;; break;</span>
<span class="lineNum">    1265 </span>            :   case N2Plain:
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :     strategy = &quot;N2Plain&quot;; break;</span>
<span class="lineNum">    1267 </span>            :   case N2Tiled:
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :     strategy = &quot;N2Tiled&quot;; break;</span>
<span class="lineNum">    1269 </span>            :   case N2MinHeapTiled:
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :     strategy = &quot;N2MinHeapTiled&quot;; break;</span>
<span class="lineNum">    1271 </span>            :   case N2PoorTiled:
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :     strategy = &quot;N2PoorTiled&quot;; break;</span>
<span class="lineNum">    1273 </span>            :   case N3Dumb:
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 :     strategy = &quot;N3Dumb&quot;; break;</span>
<span class="lineNum">    1275 </span>            :   case NlnNCam4pi:
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :     strategy = &quot;NlnNCam4pi&quot;; break;</span>
<span class="lineNum">    1277 </span>            :   case NlnNCam2pi2R:
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :     strategy = &quot;NlnNCam2pi2R&quot;; break;</span>
<span class="lineNum">    1279 </span>            :   case NlnNCam:
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :     strategy = &quot;NlnNCam&quot;; break; // 2piMultD</span>
<span class="lineNum">    1281 </span>            :   case plugin_strategy:
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :     strategy = &quot;plugin strategy&quot;; break;</span>
<span class="lineNum">    1283 </span>            :   default:
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :     strategy = &quot;Unrecognized&quot;;</span>
<span class="lineNum">    1285 </span>            :   }
<a name="1286"><span class="lineNum">    1286 </span>            :   return strategy;</a>
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1288 </span>            : double ClusterSequence::jet_scale_for_algorithm(
<span class="lineNum">    1289 </span>            :                                   const PseudoJet &amp; jet) const {
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :   if (_jet_algorithm == kt_algorithm)             {return jet.kt2();}</span>
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :   else if (_jet_algorithm == cambridge_algorithm) {return 1.0;}</span>
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :   else if (_jet_algorithm == antikt_algorithm) {</span>
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :     double kt2=jet.kt2();</span>
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 :     return kt2 &gt; 1e-300 ? 1.0/kt2 : 1e300;</span>
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 :   } else if (_jet_algorithm == genkt_algorithm) {</span>
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :     double kt2 = jet.kt2();</span>
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 :     double p   = jet_def().extra_param();</span>
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :     if (p &lt;= 0 &amp;&amp; kt2 &lt; 1e-300) kt2 = 1e-300; // dodgy safety check</span>
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 :     return pow(kt2, p);</span>
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :   } else if (_jet_algorithm == cambridge_for_passive_algorithm) {</span>
<span class="lineNum">    1301 </span><span class="lineNoCov">          0 :     double kt2 = jet.kt2();</span>
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 :     double lim = _jet_def.extra_param();</span>
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :     if (kt2 &lt; lim*lim &amp;&amp; kt2 != 0.0) {</span>
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 :       return 1.0/kt2;</span>
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 :     } else {return 1.0;}</span>
<a name="1306"><span class="lineNum">    1306 </span><span class="lineNoCov">          0 :   } else {throw Error(&quot;Unrecognised jet algorithm&quot;);}</span></a>
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1308 </span>            : void ClusterSequence::transfer_from_sequence(const ClusterSequence &amp; from_seq,
<span class="lineNum">    1309 </span>            :                                              const FunctionOfPseudoJet&lt;PseudoJet&gt; * action_on_jets){
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :   if (will_delete_self_when_unused())</span>
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 :     throw(Error(&quot;cannot use CS::transfer_from_sequence after a call to delete_self_when_unused()&quot;));</span>
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :   _jet_def                 = from_seq._jet_def                ;</span>
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :   _writeout_combinations   = from_seq._writeout_combinations  ;</span>
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :   _initial_n               = from_seq._initial_n              ;</span>
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :   _Rparam                  = from_seq._Rparam                 ;</span>
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :   _R2                      = from_seq._R2                     ;</span>
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :   _invR2                   = from_seq._invR2                  ;</span>
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :   _strategy                = from_seq._strategy               ;</span>
<span class="lineNum">    1319 </span><span class="lineNoCov">          0 :   _jet_algorithm           = from_seq._jet_algorithm          ;</span>
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :   _plugin_activated        = from_seq._plugin_activated       ;</span>
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :   if (action_on_jets)</span>
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :     _jets     = (*action_on_jets)(from_seq._jets);</span>
<span class="lineNum">    1323 </span>            :   else
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :     _jets     = from_seq._jets;</span>
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :   _history  = from_seq._history;</span>
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :   _extras   = from_seq._extras;</span>
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :   if (_structure_shared_ptr()) {</span>
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :     if (_deletes_self_when_unused) throw Error(&quot;transfer_from_sequence cannot be used for a cluster sequence that deletes self when unused&quot;);</span>
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :     ClusterSequenceStructure* csi = dynamic_cast&lt;ClusterSequenceStructure*&gt;(_structure_shared_ptr());</span>
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :     assert(csi != NULL);</span>
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :     csi-&gt;set_associated_cs(NULL);</span>
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 :   _structure_shared_ptr.reset(new ClusterSequenceStructure(this));</span>
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 :   _update_structure_use_count();</span>
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :   for (unsigned int i=0; i&lt;_jets.size(); i++){</span>
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :     _jets[i].set_cluster_hist_index(from_seq._jets[i].cluster_hist_index());</span>
<span class="lineNum">    1337 </span><span class="lineNoCov">          0 :     _set_structure_shared_ptr(_jets[i]);</span>
<a name="1338"><span class="lineNum">    1338 </span>            :   }</a>
<span class="lineNum">    1339 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1340 </span>            : void ClusterSequence::plugin_record_ij_recombination(
<span class="lineNum">    1341 </span>            :            int jet_i, int jet_j, double dij,
<span class="lineNum">    1342 </span>            :            const PseudoJet &amp; newjet, int &amp; newjet_k) {
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :   plugin_record_ij_recombination(jet_i, jet_j, dij, newjet_k);</span>
<span class="lineNum">    1344 </span><span class="lineNoCov">          0 :   int tmp_index = _jets[newjet_k].cluster_hist_index();</span>
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :   _jets[newjet_k] = newjet;</span>
<span class="lineNum">    1346 </span><span class="lineNoCov">          0 :   _jets[newjet_k].set_cluster_hist_index(tmp_index);</span>
<a name="1347"><span class="lineNum">    1347 </span><span class="lineNoCov">          0 :   _set_structure_shared_ptr(_jets[newjet_k]);</span></a>
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1349 </span>            : vector&lt;PseudoJet&gt; ClusterSequence::inclusive_jets (const double &amp; ptmin) const{
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :   double dcut = ptmin*ptmin;</span>
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :   int i = _history.size() - 1; // last jet</span>
<span class="lineNum">    1352 </span><span class="lineNoCov">          0 :   vector&lt;PseudoJet&gt; jets_local;</span>
<span class="lineNum">    1353 </span><span class="lineNoCov">          0 :   if (_jet_algorithm == kt_algorithm) {</span>
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 :     while (i &gt;= 0) {</span>
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :       if (_history[i].max_dij_so_far &lt; dcut) {break;}</span>
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 :       if (_history[i].parent2 == BeamJet &amp;&amp; _history[i].dij &gt;= dcut) {</span>
<span class="lineNum">    1357 </span>            :         // for beam jets
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 :         int parent1 = _history[i].parent1;</span>
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :         jets_local.push_back(_jets[_history[parent1].jetp_index]);}</span>
<span class="lineNum">    1360 </span><span class="lineNoCov">          0 :       i--;</span>
<span class="lineNum">    1361 </span>            :     }
<span class="lineNum">    1362 </span><span class="lineNoCov">          0 :   } else if (_jet_algorithm == cambridge_algorithm) {</span>
<span class="lineNum">    1363 </span><span class="lineNoCov">          0 :     while (i &gt;= 0) {</span>
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :       if (_history[i].parent2 != BeamJet) {break;}</span>
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :       int parent1 = _history[i].parent1;</span>
<span class="lineNum">    1366 </span><span class="lineNoCov">          0 :       const PseudoJet &amp; jet = _jets[_history[parent1].jetp_index];</span>
<span class="lineNum">    1367 </span><span class="lineNoCov">          0 :       if (jet.perp2() &gt;= dcut) {jets_local.push_back(jet);}</span>
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :       i--;</span>
<span class="lineNum">    1369 </span>            :     }
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :   } else if (_jet_algorithm == plugin_algorithm</span>
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :              || _jet_algorithm == ee_kt_algorithm</span>
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :              || _jet_algorithm == antikt_algorithm</span>
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 :              || _jet_algorithm == genkt_algorithm</span>
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :              || _jet_algorithm == ee_genkt_algorithm</span>
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :              || _jet_algorithm == cambridge_for_passive_algorithm) {</span>
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 :     while (i &gt;= 0) {</span>
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :       if (_history[i].parent2 == BeamJet) {</span>
<span class="lineNum">    1378 </span><span class="lineNoCov">          0 :         int parent1 = _history[i].parent1;</span>
<span class="lineNum">    1379 </span><span class="lineNoCov">          0 :         const PseudoJet &amp; jet = _jets[_history[parent1].jetp_index];</span>
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :         if (jet.perp2() &gt;= dcut) {jets_local.push_back(jet);}</span>
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 :       i--;</span>
<span class="lineNum">    1383 </span>            :     }
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 :   } else {throw Error(&quot;cs::inclusive_jets(...): Unrecognized jet algorithm&quot;);}</span>
<a name="1385"><span class="lineNum">    1385 </span>            :   return jets_local;</a>
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1387 </span>            : int ClusterSequence::n_exclusive_jets (const double &amp; dcut) const {
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 :   int i = _history.size() - 1; // last jet</span>
<span class="lineNum">    1389 </span><span class="lineNoCov">          0 :   while (i &gt;= 0) {</span>
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :     if (_history[i].max_dij_so_far &lt;= dcut) {break;}</span>
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :     i--;</span>
<span class="lineNum">    1392 </span>            :   }
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :   int stop_point = i + 1;</span>
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 :   int njets = 2*_initial_n - stop_point;</span>
<a name="1395"><span class="lineNum">    1395 </span><span class="lineNoCov">          0 :   return njets;</span></a>
<span class="lineNum">    1396 </span>            : }
<span class="lineNum">    1397 </span>            : vector&lt;PseudoJet&gt; ClusterSequence::exclusive_jets (const double &amp; dcut) const {
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :   int njets = n_exclusive_jets(dcut);</span>
<a name="1399"><span class="lineNum">    1399 </span><span class="lineNoCov">          0 :   return exclusive_jets(njets);</span></a>
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1401 </span>            : vector&lt;PseudoJet&gt; ClusterSequence::exclusive_jets (const int &amp; njets) const {
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 :   if (njets &gt; _initial_n) {</span>
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :     ostringstream err;</span>
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 :     err &lt;&lt; &quot;Requested &quot; &lt;&lt; njets &lt;&lt; &quot; exclusive jets, but there were only &quot;</span>
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 :         &lt;&lt; _initial_n &lt;&lt; &quot; particles in the event&quot;;</span>
<span class="lineNum">    1406 </span><span class="lineNoCov">          0 :     throw Error(err.str());</span>
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :   }</span>
<a name="1408"><span class="lineNum">    1408 </span><span class="lineNoCov">          0 :   return exclusive_jets_up_to(njets);</span></a>
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1410 </span>            : vector&lt;PseudoJet&gt; ClusterSequence::exclusive_jets_up_to (const int &amp; njets) const {
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :   if (( _jet_def.jet_algorithm() != kt_algorithm) &amp;&amp;</span>
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :       ( _jet_def.jet_algorithm() != cambridge_algorithm) &amp;&amp;</span>
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :       ( _jet_def.jet_algorithm() != ee_kt_algorithm) &amp;&amp;</span>
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :       (((_jet_def.jet_algorithm() != genkt_algorithm) &amp;&amp;</span>
<span class="lineNum">    1415 </span><span class="lineNoCov">          0 :         (_jet_def.jet_algorithm() != ee_genkt_algorithm)) ||</span>
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :        (_jet_def.extra_param() &lt;0)) &amp;&amp;</span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :       ((_jet_def.jet_algorithm() != plugin_algorithm) ||</span>
<span class="lineNum">    1418 </span><span class="lineNoCov">          0 :        (!_jet_def.plugin()-&gt;exclusive_sequence_meaningful())) &amp;&amp;</span>
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :       (_n_exclusive_warnings &lt; 5)) {</span>
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :     _n_exclusive_warnings++;</span>
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 :     cerr &lt;&lt; &quot;FastJet WARNING: dcut and exclusive jets for jet-finders other than kt should be interpreted with care.&quot; &lt;&lt; endl;</span>
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :   int stop_point = 2*_initial_n - njets;</span>
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :   if (stop_point &lt; _initial_n) stop_point = _initial_n;</span>
<span class="lineNum">    1425 </span><span class="lineNoCov">          0 :   if (2*_initial_n != static_cast&lt;int&gt;(_history.size())) {</span>
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 :     ostringstream err;</span>
<span class="lineNum">    1427 </span><span class="lineNoCov">          0 :     err &lt;&lt; &quot;2*_initial_n != _history.size() -- this endangers internal assumptions!\n&quot;;</span>
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :     throw Error(err.str());</span>
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :   vector&lt;PseudoJet&gt; jets_local;</span>
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 :   for (unsigned int i = stop_point; i &lt; _history.size(); i++) {</span>
<span class="lineNum">    1432 </span><span class="lineNoCov">          0 :     int parent1 = _history[i].parent1;</span>
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :     if (parent1 &lt; stop_point) {</span>
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :       jets_local.push_back(_jets[_history[parent1].jetp_index]);</span>
<span class="lineNum">    1435 </span>            :     }
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :     int parent2 = _history[i].parent2;</span>
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :     if (parent2 &lt; stop_point &amp;&amp; parent2 &gt; 0) {</span>
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :       jets_local.push_back(_jets[_history[parent2].jetp_index]);</span>
<span class="lineNum">    1439 </span>            :     }
<span class="lineNum">    1440 </span>            :   }
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :   if (int(jets_local.size()) != min(_initial_n, njets)) {</span>
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :     ostringstream err;</span>
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :     err &lt;&lt; &quot;ClusterSequence::exclusive_jets: size of returned vector (&quot;</span>
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :          &lt;&lt;jets_local.size()&lt;&lt;&quot;) does not coincide with requested number of jets (&quot;</span>
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :          &lt;&lt;njets&lt;&lt;&quot;)&quot;;</span>
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :     throw Error(err.str());</span>
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 :   }</span>
<a name="1448"><span class="lineNum">    1448 </span>            :   return jets_local;</a>
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1450 </span>            : double ClusterSequence::exclusive_dmerge (const int &amp; njets) const {
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :   assert(njets &gt;= 0);</span>
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :   if (njets &gt;= _initial_n) {return 0.0;}</span>
<a name="1453"><span class="lineNum">    1453 </span><span class="lineNoCov">          0 :   return _history[2*_initial_n-njets-1].dij;</span></a>
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1455 </span>            : double ClusterSequence::exclusive_dmerge_max (const int &amp; njets) const {
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 :   assert(njets &gt;= 0);</span>
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :   if (njets &gt;= _initial_n) {return 0.0;}</span>
<a name="1458"><span class="lineNum">    1458 </span><span class="lineNoCov">          0 :   return _history[2*_initial_n-njets-1].max_dij_so_far;</span></a>
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1460 </span>            : std::vector&lt;PseudoJet&gt; ClusterSequence::exclusive_subjets
<span class="lineNum">    1461 </span>            :    (const PseudoJet &amp; jet, const double &amp; dcut) const {
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :   set&lt;const history_element*&gt; subhist;</span>
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :   get_subhist_set(subhist, jet, dcut, 0);</span>
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 :   vector&lt;PseudoJet&gt; subjets;</span>
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :   subjets.reserve(subhist.size());</span>
<span class="lineNum">    1466 </span><span class="lineNoCov">          0 :   for (set&lt;const history_element*&gt;::iterator elem = subhist.begin();</span>
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 :        elem != subhist.end(); elem++) {</span>
<span class="lineNum">    1468 </span><span class="lineNoCov">          0 :     subjets.push_back(_jets[(*elem)-&gt;jetp_index]);</span>
<span class="lineNum">    1469 </span>            :   }
<a name="1470"><span class="lineNum">    1470 </span>            :   return subjets;</a>
<span class="lineNum">    1471 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1472 </span>            : int ClusterSequence::n_exclusive_subjets(const PseudoJet &amp; jet,
<span class="lineNum">    1473 </span>            :                         const double &amp; dcut) const {
<span class="lineNum">    1474 </span><span class="lineNoCov">          0 :   set&lt;const history_element*&gt; subhist;</span>
<span class="lineNum">    1475 </span><span class="lineNoCov">          0 :   get_subhist_set(subhist, jet, dcut, 0);</span>
<a name="1476"><span class="lineNum">    1476 </span><span class="lineNoCov">          0 :   return subhist.size();</span></a>
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1478 </span>            : std::vector&lt;PseudoJet&gt; ClusterSequence::exclusive_subjets
<span class="lineNum">    1479 </span>            :    (const PseudoJet &amp; jet, int nsub) const {
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :   vector&lt;PseudoJet&gt; subjets = exclusive_subjets_up_to(jet, nsub);</span>
<span class="lineNum">    1481 </span><span class="lineNoCov">          0 :   if (int(subjets.size()) &lt; nsub) {</span>
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 :     ostringstream err;</span>
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 :     err &lt;&lt; &quot;Requested &quot; &lt;&lt; nsub &lt;&lt; &quot; exclusive subjets, but there were only &quot;</span>
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :         &lt;&lt; subjets.size() &lt;&lt; &quot; particles in the jet&quot;;</span>
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :     throw Error(err.str());</span>
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :   }</span>
<a name="1487"><span class="lineNum">    1487 </span>            :   return subjets;</a>
<span class="lineNum">    1488 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1489 </span>            : std::vector&lt;PseudoJet&gt; ClusterSequence::exclusive_subjets_up_to
<span class="lineNum">    1490 </span>            :    (const PseudoJet &amp; jet, int nsub) const {
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 :   set&lt;const history_element*&gt; subhist;</span>
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :   vector&lt;PseudoJet&gt; subjets;</span>
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :   if (nsub &lt;  0) throw Error(&quot;Requested a negative number of subjets. This is nonsensical.&quot;);</span>
<span class="lineNum">    1494 </span><span class="lineNoCov">          0 :   if (nsub == 0) return subjets;</span>
<span class="lineNum">    1495 </span><span class="lineNoCov">          0 :   get_subhist_set(subhist, jet, -1.0, nsub);</span>
<span class="lineNum">    1496 </span><span class="lineNoCov">          0 :   subjets.reserve(subhist.size());</span>
<span class="lineNum">    1497 </span><span class="lineNoCov">          0 :   for (set&lt;const history_element*&gt;::iterator elem = subhist.begin();</span>
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 :        elem != subhist.end(); elem++) {</span>
<span class="lineNum">    1499 </span><span class="lineNoCov">          0 :     subjets.push_back(_jets[(*elem)-&gt;jetp_index]);</span>
<span class="lineNum">    1500 </span>            :   }
<a name="1501"><span class="lineNum">    1501 </span><span class="lineNoCov">          0 :   return subjets;</span></a>
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1503 </span>            : double ClusterSequence::exclusive_subdmerge(const PseudoJet &amp; jet, int nsub) const {
<span class="lineNum">    1504 </span><span class="lineNoCov">          0 :   set&lt;const history_element*&gt; subhist;</span>
<span class="lineNum">    1505 </span><span class="lineNoCov">          0 :   get_subhist_set(subhist, jet, -1.0, nsub);</span>
<span class="lineNum">    1506 </span><span class="lineNoCov">          0 :   set&lt;const history_element*&gt;::iterator highest = subhist.end();</span>
<span class="lineNum">    1507 </span><span class="lineNoCov">          0 :   highest--;</span>
<a name="1508"><span class="lineNum">    1508 </span><span class="lineNoCov">          0 :   return (*highest)-&gt;dij;</span></a>
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1510 </span>            : double ClusterSequence::exclusive_subdmerge_max(const PseudoJet &amp; jet, int nsub) const {
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :   set&lt;const history_element*&gt; subhist;</span>
<span class="lineNum">    1512 </span><span class="lineNoCov">          0 :   get_subhist_set(subhist, jet, -1.0, nsub);</span>
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :   set&lt;const history_element*&gt;::iterator highest = subhist.end();</span>
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 :   highest--;</span>
<a name="1515"><span class="lineNum">    1515 </span><span class="lineNoCov">          0 :   return (*highest)-&gt;max_dij_so_far;</span></a>
<span class="lineNum">    1516 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1517 </span>            : void ClusterSequence::get_subhist_set(set&lt;const history_element*&gt; &amp; subhist,
<span class="lineNum">    1518 </span>            :                                      const  PseudoJet &amp; jet,
<span class="lineNum">    1519 </span>            :                                      double dcut, int maxjet) const {
<span class="lineNum">    1520 </span><span class="lineNoCov">          0 :   assert(contains(jet));</span>
<span class="lineNum">    1521 </span><span class="lineNoCov">          0 :   subhist.clear();</span>
<span class="lineNum">    1522 </span><span class="lineNoCov">          0 :   subhist.insert(&amp;(_history[jet.cluster_hist_index()]));</span>
<span class="lineNum">    1523 </span>            :   int njet = 1;
<span class="lineNum">    1524 </span><span class="lineNoCov">          0 :   while (true) {</span>
<span class="lineNum">    1525 </span><span class="lineNoCov">          0 :     set&lt;const history_element*&gt;::iterator highest = subhist.end();</span>
<span class="lineNum">    1526 </span><span class="lineNoCov">          0 :     assert (highest != subhist.begin());</span>
<span class="lineNum">    1527 </span><span class="lineNoCov">          0 :     highest--;</span>
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 :     const history_element* elem = *highest;</span>
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 :     if (njet == maxjet) break;</span>
<span class="lineNum">    1530 </span><span class="lineNoCov">          0 :     if (elem-&gt;parent1 &lt; 0)            break;</span>
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :     if (elem-&gt;max_dij_so_far &lt;= dcut) break;</span>
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :     subhist.erase(highest);</span>
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 :     subhist.insert(&amp;(_history[elem-&gt;parent1]));</span>
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :     subhist.insert(&amp;(_history[elem-&gt;parent2]));</span>
<span class="lineNum">    1535 </span><span class="lineNoCov">          0 :     njet++;</span>
<a name="1536"><span class="lineNum">    1536 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    1537 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1538 </span>            : bool ClusterSequence::object_in_jet(const PseudoJet &amp; object,
<span class="lineNum">    1539 </span>            :                                     const PseudoJet &amp; jet) const {
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :   assert(contains(object) &amp;&amp; contains(jet));</span>
<span class="lineNum">    1541 </span>            :   const PseudoJet * this_object = &amp;object;
<span class="lineNum">    1542 </span><span class="lineNoCov">          0 :   const PseudoJet * childp;</span>
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :   while(true) {</span>
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :     if (this_object-&gt;cluster_hist_index() == jet.cluster_hist_index()) {</span>
<span class="lineNum">    1545 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">    1546 </span><span class="lineNoCov">          0 :     } else if (has_child(*this_object, childp)) {</span>
<span class="lineNum">    1547 </span><span class="lineNoCov">          0 :       this_object = childp;</span>
<span class="lineNum">    1548 </span>            :     } else {
<span class="lineNum">    1549 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    1550 </span>            :     }
<a name="1551"><span class="lineNum">    1551 </span>            :   }</a>
<span class="lineNum">    1552 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1553 </span>            : bool ClusterSequence::has_parents(const PseudoJet &amp; jet, PseudoJet &amp; parent1,
<span class="lineNum">    1554 </span>            :                               PseudoJet &amp; parent2) const {
<span class="lineNum">    1555 </span><span class="lineNoCov">          0 :   const history_element &amp; hist = _history[jet.cluster_hist_index()];</span>
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 :   assert ((hist.parent1 &gt;= 0 &amp;&amp; hist.parent2 &gt;= 0) ||</span>
<span class="lineNum">    1557 </span>            :           (hist.parent1 &lt; 0 &amp;&amp; hist.parent2 &lt; 0));
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 :   if (hist.parent1 &lt; 0) {</span>
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :     parent1 = PseudoJet(0.0,0.0,0.0,0.0);</span>
<span class="lineNum">    1560 </span><span class="lineNoCov">          0 :     parent2 = parent1;</span>
<span class="lineNum">    1561 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1562 </span>            :   } else {
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :     parent1 = _jets[_history[hist.parent1].jetp_index];</span>
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :     parent2 = _jets[_history[hist.parent2].jetp_index];</span>
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :     if (parent1.perp2() &lt; parent2.perp2()) std::swap(parent1,parent2);</span>
<span class="lineNum">    1566 </span><span class="lineNoCov">          0 :     return true;</span>
<a name="1567"><span class="lineNum">    1567 </span>            :   }</a>
<span class="lineNum">    1568 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1569 </span>            : bool ClusterSequence::has_child(const PseudoJet &amp; jet, PseudoJet &amp; child) const {
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :   const PseudoJet * childp;</span>
<span class="lineNum">    1571 </span><span class="lineNoCov">          0 :   bool res = has_child(jet, childp);</span>
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :   if (res) {</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :     child = *childp;</span>
<span class="lineNum">    1574 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1575 </span>            :   } else {
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 :     child = PseudoJet(0.0,0.0,0.0,0.0);</span>
<span class="lineNum">    1577 </span><span class="lineNoCov">          0 :     return false;</span>
<a name="1578"><span class="lineNum">    1578 </span>            :   }</a>
<span class="lineNum">    1579 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1580 </span>            : bool ClusterSequence::has_child(const PseudoJet &amp; jet, const PseudoJet * &amp; childp) const {
<span class="lineNum">    1581 </span><span class="lineNoCov">          0 :   const history_element &amp; hist = _history[jet.cluster_hist_index()];</span>
<span class="lineNum">    1582 </span><span class="lineNoCov">          0 :   if (hist.child &gt;= 0 &amp;&amp; _history[hist.child].jetp_index &gt;= 0) {</span>
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :     childp = &amp;(_jets[_history[hist.child].jetp_index]);</span>
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1585 </span>            :   } else {
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :     childp = NULL;</span>
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :     return false;</span>
<a name="1588"><span class="lineNum">    1588 </span>            :   }</a>
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1590 </span>            : bool ClusterSequence::has_partner(const PseudoJet &amp; jet,
<span class="lineNum">    1591 </span>            :                               PseudoJet &amp; partner) const {
<span class="lineNum">    1592 </span><span class="lineNoCov">          0 :   const history_element &amp; hist = _history[jet.cluster_hist_index()];</span>
<span class="lineNum">    1593 </span><span class="lineNoCov">          0 :   if (hist.child &gt;= 0 &amp;&amp; _history[hist.child].parent2 &gt;= 0) {</span>
<span class="lineNum">    1594 </span><span class="lineNoCov">          0 :     const history_element &amp; child_hist = _history[hist.child];</span>
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 :     if (child_hist.parent1 == jet.cluster_hist_index()) {</span>
<span class="lineNum">    1596 </span><span class="lineNoCov">          0 :       partner = _jets[_history[child_hist.parent2].jetp_index];</span>
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">    1598 </span><span class="lineNoCov">          0 :       partner = _jets[_history[child_hist.parent1].jetp_index];</span>
<span class="lineNum">    1599 </span>            :     }
<span class="lineNum">    1600 </span>            :     return true;
<span class="lineNum">    1601 </span>            :   } else {
<span class="lineNum">    1602 </span><span class="lineNoCov">          0 :     partner = PseudoJet(0.0,0.0,0.0,0.0);</span>
<span class="lineNum">    1603 </span><span class="lineNoCov">          0 :     return false;</span>
<a name="1604"><span class="lineNum">    1604 </span>            :   }</a>
<span class="lineNum">    1605 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1606 </span>            : vector&lt;PseudoJet&gt; ClusterSequence::constituents (const PseudoJet &amp; jet) const {
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 :   vector&lt;PseudoJet&gt; subjets;</span>
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 :   add_constituents(jet, subjets);</span>
<a name="1609"><span class="lineNum">    1609 </span>            :   return subjets;</a>
<span class="lineNum">    1610 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1611 </span>            : void ClusterSequence::print_jets_for_root(const std::vector&lt;PseudoJet&gt; &amp; jets_in,
<span class="lineNum">    1612 </span>            :                                           ostream &amp; ostr) const {
<span class="lineNum">    1613 </span><span class="lineNoCov">          0 :   for (unsigned i = 0; i &lt; jets_in.size(); i++) {</span>
<span class="lineNum">    1614 </span><span class="lineNoCov">          0 :     ostr &lt;&lt; i  &lt;&lt; &quot; &quot;</span>
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :          &lt;&lt; jets_in[i].px() &lt;&lt; &quot; &quot;</span>
<span class="lineNum">    1616 </span><span class="lineNoCov">          0 :          &lt;&lt; jets_in[i].py() &lt;&lt; &quot; &quot;</span>
<span class="lineNum">    1617 </span><span class="lineNoCov">          0 :          &lt;&lt; jets_in[i].pz() &lt;&lt; &quot; &quot;</span>
<span class="lineNum">    1618 </span><span class="lineNoCov">          0 :          &lt;&lt; jets_in[i].E() &lt;&lt; endl;</span>
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :     vector&lt;PseudoJet&gt; cst = constituents(jets_in[i]);</span>
<span class="lineNum">    1620 </span><span class="lineNoCov">          0 :     for (unsigned j = 0; j &lt; cst.size() ; j++) {</span>
<span class="lineNum">    1621 </span><span class="lineNoCov">          0 :       ostr &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot;</span>
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 :            &lt;&lt; cst[j].rap() &lt;&lt; &quot; &quot;</span>
<span class="lineNum">    1623 </span><span class="lineNoCov">          0 :            &lt;&lt; cst[j].phi() &lt;&lt; &quot; &quot;</span>
<span class="lineNum">    1624 </span><span class="lineNoCov">          0 :            &lt;&lt; cst[j].perp() &lt;&lt; endl;</span>
<span class="lineNum">    1625 </span>            :     }
<span class="lineNum">    1626 </span><span class="lineNoCov">          0 :     ostr &lt;&lt; &quot;#END&quot; &lt;&lt; endl;</span>
<a name="1627"><span class="lineNum">    1627 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    1628 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1629 </span>            : void ClusterSequence::print_jets_for_root(const std::vector&lt;PseudoJet&gt; &amp; jets_in,
<span class="lineNum">    1630 </span>            :                                           const std::string &amp; filename,
<span class="lineNum">    1631 </span>            :                                           const std::string &amp; comment ) const {
<span class="lineNum">    1632 </span><span class="lineNoCov">          0 :   std::ofstream ostr(filename.c_str());</span>
<span class="lineNum">    1633 </span><span class="lineNoCov">          0 :   if (comment != &quot;&quot;) ostr &lt;&lt; &quot;# &quot; &lt;&lt; comment &lt;&lt; endl;</span>
<a name="1634"><span class="lineNum">    1634 </span><span class="lineNoCov">          0 :   print_jets_for_root(jets_in, ostr);</span></a>
<span class="lineNum">    1635 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1636 </span>            : vector&lt;int&gt; ClusterSequence::particle_jet_indices(
<span class="lineNum">    1637 </span>            :                         const vector&lt;PseudoJet&gt; &amp; jets_in) const {
<span class="lineNum">    1638 </span><span class="lineNoCov">          0 :   vector&lt;int&gt; indices(n_particles());</span>
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 :   for (unsigned ipart = 0; ipart &lt; n_particles(); ipart++)</span>
<span class="lineNum">    1640 </span><span class="lineNoCov">          0 :     indices[ipart] = -1;</span>
<span class="lineNum">    1641 </span><span class="lineNoCov">          0 :   for (unsigned ijet = 0; ijet &lt; jets_in.size(); ijet++) {</span>
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 :     vector&lt;PseudoJet&gt; jet_constituents(constituents(jets_in[ijet]));</span>
<span class="lineNum">    1643 </span><span class="lineNoCov">          0 :     for (unsigned ip = 0; ip &lt; jet_constituents.size(); ip++) {</span>
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :       unsigned iclust = jet_constituents[ip].cluster_hist_index();</span>
<span class="lineNum">    1645 </span><span class="lineNoCov">          0 :       unsigned ipart = history()[iclust].jetp_index;</span>
<span class="lineNum">    1646 </span><span class="lineNoCov">          0 :       indices[ipart] = ijet;</span>
<span class="lineNum">    1647 </span>            :     }
<span class="lineNum">    1648 </span><span class="lineNoCov">          0 :   }</span>
<a name="1649"><span class="lineNum">    1649 </span>            :   return indices;</a>
<span class="lineNum">    1650 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1651 </span>            : void ClusterSequence::add_constituents (
<span class="lineNum">    1652 </span>            :            const PseudoJet &amp; jet, vector&lt;PseudoJet&gt; &amp; subjet_vector) const {
<span class="lineNum">    1653 </span><span class="lineNoCov">          0 :   int i = jet.cluster_hist_index();</span>
<span class="lineNum">    1654 </span><span class="lineNoCov">          0 :   int parent1 = _history[i].parent1;</span>
<span class="lineNum">    1655 </span><span class="lineNoCov">          0 :   int parent2 = _history[i].parent2;</span>
<span class="lineNum">    1656 </span><span class="lineNoCov">          0 :   if (parent1 == InexistentParent) {</span>
<span class="lineNum">    1657 </span><span class="lineNoCov">          0 :     subjet_vector.push_back(_jets[i]);</span>
<span class="lineNum">    1658 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1659 </span>            :   }
<span class="lineNum">    1660 </span><span class="lineNoCov">          0 :   add_constituents(_jets[_history[parent1].jetp_index], subjet_vector);</span>
<span class="lineNum">    1661 </span><span class="lineNoCov">          0 :   if (parent2 != BeamJet) {</span>
<span class="lineNum">    1662 </span><span class="lineNoCov">          0 :     add_constituents(_jets[_history[parent2].jetp_index], subjet_vector);</span>
<a name="1663"><span class="lineNum">    1663 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    1664 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1665 </span>            : void ClusterSequence::_add_step_to_history (
<span class="lineNum">    1666 </span>            :                const int &amp; step_number, const int &amp; parent1,
<span class="lineNum">    1667 </span>            :                const int &amp; parent2, const int &amp; jetp_index,
<span class="lineNum">    1668 </span>            :                const double &amp; dij) {
<span class="lineNum">    1669 </span><span class="lineNoCov">          0 :   history_element element;</span>
<span class="lineNum">    1670 </span><span class="lineNoCov">          0 :   element.parent1 = parent1;</span>
<span class="lineNum">    1671 </span><span class="lineNoCov">          0 :   element.parent2 = parent2;</span>
<span class="lineNum">    1672 </span><span class="lineNoCov">          0 :   element.jetp_index = jetp_index;</span>
<span class="lineNum">    1673 </span><span class="lineNoCov">          0 :   element.child = Invalid;</span>
<span class="lineNum">    1674 </span><span class="lineNoCov">          0 :   element.dij   = dij;</span>
<span class="lineNum">    1675 </span><span class="lineNoCov">          0 :   element.max_dij_so_far = max(dij,_history[_history.size()-1].max_dij_so_far);</span>
<span class="lineNum">    1676 </span><span class="lineNoCov">          0 :   _history.push_back(element);</span>
<span class="lineNum">    1677 </span><span class="lineNoCov">          0 :   int local_step = _history.size()-1;</span>
<span class="lineNum">    1678 </span><span class="lineNoCov">          0 :   assert(local_step == step_number);</span>
<span class="lineNum">    1679 </span><span class="lineNoCov">          0 :   assert(parent1 &gt;= 0);</span>
<span class="lineNum">    1680 </span><span class="lineNoCov">          0 :   _history[parent1].child = local_step;</span>
<span class="lineNum">    1681 </span><span class="lineNoCov">          0 :   if (parent2 &gt;= 0) {_history[parent2].child = local_step;}</span>
<span class="lineNum">    1682 </span><span class="lineNoCov">          0 :   if (jetp_index != Invalid) {</span>
<span class="lineNum">    1683 </span><span class="lineNoCov">          0 :     assert(jetp_index &gt;= 0);</span>
<span class="lineNum">    1684 </span><span class="lineNoCov">          0 :     _jets[jetp_index].set_cluster_hist_index(local_step);</span>
<span class="lineNum">    1685 </span><span class="lineNoCov">          0 :     _set_structure_shared_ptr(_jets[jetp_index]);</span>
<span class="lineNum">    1686 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1687 </span><span class="lineNoCov">          0 :   if (_writeout_combinations) {</span>
<span class="lineNum">    1688 </span><span class="lineNoCov">          0 :     cout &lt;&lt; local_step &lt;&lt; &quot;: &quot;</span>
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 :          &lt;&lt; parent1 &lt;&lt; &quot; with &quot; &lt;&lt; parent2</span>
<span class="lineNum">    1690 </span><span class="lineNoCov">          0 :          &lt;&lt; &quot;; y = &quot;&lt;&lt; dij&lt;&lt;endl;</span>
<a name="1691"><span class="lineNum">    1691 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    1692 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1693 </span>            : vector&lt;int&gt; ClusterSequence::unique_history_order() const {
<span class="lineNum">    1694 </span><span class="lineNoCov">          0 :   valarray&lt;int&gt; lowest_constituent(_history.size());</span>
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :   int hist_n = _history.size();</span>
<span class="lineNum">    1696 </span><span class="lineNoCov">          0 :   lowest_constituent = hist_n; // give it a large number</span>
<span class="lineNum">    1697 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; hist_n; i++) {</span>
<span class="lineNum">    1698 </span><span class="lineNoCov">          0 :     lowest_constituent[i] = min(lowest_constituent[i],i);</span>
<span class="lineNum">    1699 </span><span class="lineNoCov">          0 :     if (_history[i].child &gt; 0) lowest_constituent[_history[i].child]</span>
<span class="lineNum">    1700 </span><span class="lineNoCov">          0 :       = min(lowest_constituent[_history[i].child],lowest_constituent[i]);</span>
<span class="lineNum">    1701 </span>            :   }
<span class="lineNum">    1702 </span><span class="lineNoCov">          0 :   valarray&lt;bool&gt; extracted(_history.size()); extracted = false;</span>
<span class="lineNum">    1703 </span><span class="lineNoCov">          0 :   vector&lt;int&gt; unique_tree;</span>
<span class="lineNum">    1704 </span><span class="lineNoCov">          0 :   unique_tree.reserve(_history.size());</span>
<span class="lineNum">    1705 </span><span class="lineNoCov">          0 :   for (unsigned i = 0; i &lt; n_particles(); i++) {</span>
<span class="lineNum">    1706 </span><span class="lineNoCov">          0 :     if (!extracted[i]) {</span>
<span class="lineNum">    1707 </span><span class="lineNoCov">          0 :       unique_tree.push_back(i);</span>
<span class="lineNum">    1708 </span><span class="lineNoCov">          0 :       extracted[i] = true;</span>
<span class="lineNum">    1709 </span><span class="lineNoCov">          0 :       _extract_tree_children(i, extracted, lowest_constituent, unique_tree);</span>
<span class="lineNum">    1710 </span>            :     }
<span class="lineNum">    1711 </span>            :   }
<a name="1712"><span class="lineNum">    1712 </span>            :   return unique_tree;</a>
<span class="lineNum">    1713 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1714 </span>            : void ClusterSequence::_extract_tree_children(
<span class="lineNum">    1715 </span>            :        int position,
<span class="lineNum">    1716 </span>            :        valarray&lt;bool&gt; &amp; extracted,
<span class="lineNum">    1717 </span>            :        const valarray&lt;int&gt; &amp; lowest_constituent,
<span class="lineNum">    1718 </span>            :        vector&lt;int&gt; &amp; unique_tree) const {
<span class="lineNum">    1719 </span><span class="lineNoCov">          0 :   if (!extracted[position]) {</span>
<span class="lineNum">    1720 </span><span class="lineNoCov">          0 :     _extract_tree_parents(position,extracted,lowest_constituent,unique_tree);</span>
<span class="lineNum">    1721 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1722 </span><span class="lineNoCov">          0 :   int child = _history[position].child;</span>
<a name="1723"><span class="lineNum">    1723 </span><span class="lineNoCov">          0 :   if (child  &gt;= 0) _extract_tree_children(child,extracted,lowest_constituent,unique_tree);</span></a>
<span class="lineNum">    1724 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1725 </span>            : vector&lt;PseudoJet&gt; ClusterSequence::unclustered_particles() const {
<span class="lineNum">    1726 </span><span class="lineNoCov">          0 :   vector&lt;PseudoJet&gt; unclustered;</span>
<span class="lineNum">    1727 </span><span class="lineNoCov">          0 :   for (unsigned i = 0; i &lt; n_particles() ; i++) {</span>
<span class="lineNum">    1728 </span><span class="lineNoCov">          0 :     if (_history[i].child == Invalid)</span>
<span class="lineNum">    1729 </span><span class="lineNoCov">          0 :       unclustered.push_back(_jets[_history[i].jetp_index]);</span>
<span class="lineNum">    1730 </span>            :   }
<a name="1731"><span class="lineNum">    1731 </span>            :   return unclustered;</a>
<span class="lineNum">    1732 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1733 </span>            : vector&lt;PseudoJet&gt; ClusterSequence::childless_pseudojets() const {
<span class="lineNum">    1734 </span><span class="lineNoCov">          0 :   vector&lt;PseudoJet&gt; unclustered;</span>
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 :   for (unsigned i = 0; i &lt; _history.size() ; i++) {</span>
<span class="lineNum">    1736 </span><span class="lineNoCov">          0 :     if ((_history[i].child == Invalid) &amp;&amp; (_history[i].parent2 != BeamJet))</span>
<span class="lineNum">    1737 </span><span class="lineNoCov">          0 :       unclustered.push_back(_jets[_history[i].jetp_index]);</span>
<span class="lineNum">    1738 </span>            :   }
<a name="1739"><span class="lineNum">    1739 </span>            :   return unclustered;</a>
<span class="lineNum">    1740 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1741 </span>            : bool ClusterSequence::contains(const PseudoJet &amp; jet) const {
<span class="lineNum">    1742 </span><span class="lineNoCov">          0 :   return jet.cluster_hist_index() &gt;= 0</span>
<span class="lineNum">    1743 </span><span class="lineNoCov">          0 :     &amp;&amp;   jet.cluster_hist_index() &lt; int(_history.size())</span>
<span class="lineNum">    1744 </span><span class="lineNoCov">          0 :     &amp;&amp;   jet.has_valid_cluster_sequence()</span>
<a name="1745"><span class="lineNum">    1745 </span><span class="lineNoCov">          0 :     &amp;&amp;   jet.associated_cluster_sequence() == this;</span></a>
<span class="lineNum">    1746 </span>            : }
<span class="lineNum">    1747 </span>            : void ClusterSequence::_extract_tree_parents(
<span class="lineNum">    1748 </span>            :        int position,
<span class="lineNum">    1749 </span>            :        valarray&lt;bool&gt; &amp; extracted,
<span class="lineNum">    1750 </span>            :        const valarray&lt;int&gt; &amp; lowest_constituent,
<span class="lineNum">    1751 </span>            :        vector&lt;int&gt; &amp; unique_tree) const {
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :   if (!extracted[position]) {</span>
<span class="lineNum">    1753 </span><span class="lineNoCov">          0 :     int parent1 = _history[position].parent1;</span>
<span class="lineNum">    1754 </span><span class="lineNoCov">          0 :     int parent2 = _history[position].parent2;</span>
<span class="lineNum">    1755 </span><span class="lineNoCov">          0 :     if (parent1 &gt;= 0 &amp;&amp; parent2 &gt;= 0) {</span>
<span class="lineNum">    1756 </span><span class="lineNoCov">          0 :       if (lowest_constituent[parent1] &gt; lowest_constituent[parent2])</span>
<span class="lineNum">    1757 </span><span class="lineNoCov">          0 :         std::swap(parent1, parent2);</span>
<span class="lineNum">    1758 </span>            :     }
<span class="lineNum">    1759 </span><span class="lineNoCov">          0 :     if (parent1 &gt;= 0 &amp;&amp; !extracted[parent1])</span>
<span class="lineNum">    1760 </span><span class="lineNoCov">          0 :       _extract_tree_parents(parent1,extracted,lowest_constituent,unique_tree);</span>
<span class="lineNum">    1761 </span><span class="lineNoCov">          0 :     if (parent2 &gt;= 0 &amp;&amp; !extracted[parent2])</span>
<span class="lineNum">    1762 </span><span class="lineNoCov">          0 :       _extract_tree_parents(parent2,extracted,lowest_constituent,unique_tree);</span>
<span class="lineNum">    1763 </span><span class="lineNoCov">          0 :     unique_tree.push_back(position);</span>
<span class="lineNum">    1764 </span><span class="lineNoCov">          0 :     extracted[position] = true;</span>
<a name="1765"><span class="lineNum">    1765 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    1766 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1767 </span>            : void ClusterSequence::_do_ij_recombination_step(
<span class="lineNum">    1768 </span>            :                                const int &amp; jet_i, const int &amp; jet_j,
<span class="lineNum">    1769 </span>            :                                const double &amp; dij,
<span class="lineNum">    1770 </span>            :                                int &amp; newjet_k) {
<span class="lineNum">    1771 </span><span class="lineNoCov">          0 :   PseudoJet newjet(false);</span>
<span class="lineNum">    1772 </span><span class="lineNoCov">          0 :   _jet_def.recombiner()-&gt;recombine(_jets[jet_i], _jets[jet_j], newjet);</span>
<span class="lineNum">    1773 </span><span class="lineNoCov">          0 :   _jets.push_back(newjet);</span>
<span class="lineNum">    1774 </span><span class="lineNoCov">          0 :   newjet_k = _jets.size()-1;</span>
<span class="lineNum">    1775 </span><span class="lineNoCov">          0 :   int newstep_k = _history.size();</span>
<span class="lineNum">    1776 </span><span class="lineNoCov">          0 :   _jets[newjet_k].set_cluster_hist_index(newstep_k);</span>
<span class="lineNum">    1777 </span><span class="lineNoCov">          0 :   int hist_i = _jets[jet_i].cluster_hist_index();</span>
<span class="lineNum">    1778 </span><span class="lineNoCov">          0 :   int hist_j = _jets[jet_j].cluster_hist_index();</span>
<span class="lineNum">    1779 </span><span class="lineNoCov">          0 :   _add_step_to_history(newstep_k, min(hist_i, hist_j), max(hist_i,hist_j),</span>
<a name="1780"><span class="lineNum">    1780 </span>            :                        newjet_k, dij);</a>
<span class="lineNum">    1781 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1782 </span>            : void ClusterSequence::_do_iB_recombination_step(
<span class="lineNum">    1783 </span>            :                                   const int &amp; jet_i, const double &amp; diB) {
<span class="lineNum">    1784 </span><span class="lineNoCov">          0 :   int newstep_k = _history.size();</span>
<span class="lineNum">    1785 </span><span class="lineNoCov">          0 :   _add_step_to_history(newstep_k,_jets[jet_i].cluster_hist_index(),BeamJet,</span>
<a name="1786"><span class="lineNum">    1786 </span><span class="lineNoCov">          0 :                        Invalid, diB);</span></a>
<a name="1787"><span class="lineNum">    1787 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1788 </span><span class="lineCov">          6 : LimitedWarning ClusterSequence::_changed_strategy_warning;</span>
<span class="lineNum">    1789 </span>            : void ClusterSequence::_set_structure_shared_ptr(PseudoJet &amp; j) {
<span class="lineNum">    1790 </span><span class="lineNoCov">          0 :   j.set_structure_shared_ptr(_structure_shared_ptr);</span>
<a name="1791"><span class="lineNum">    1791 </span><span class="lineNoCov">          0 :   _update_structure_use_count();</span></a>
<span class="lineNum">    1792 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1793 </span>            : void ClusterSequence::_update_structure_use_count() {
<a name="1794"><span class="lineNum">    1794 </span><span class="lineNoCov">          0 :   _structure_use_count_after_construction = _structure_shared_ptr.use_count();</span></a>
<span class="lineNum">    1795 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1796 </span>            : void ClusterSequence::delete_self_when_unused() {
<span class="lineNum">    1797 </span><span class="lineNoCov">          0 :   int new_count = _structure_shared_ptr.use_count() - _structure_use_count_after_construction;</span>
<span class="lineNum">    1798 </span><span class="lineNoCov">          0 :   if (new_count &lt;= 0) {</span>
<span class="lineNum">    1799 </span><span class="lineNoCov">          0 :     throw Error(&quot;delete_self_when_unused may only be called if at least one object outside the CS (e.g. a jet) is already associated with the CS&quot;);</span>
<span class="lineNum">    1800 </span>            :   }
<span class="lineNum">    1801 </span><span class="lineNoCov">          0 :   _structure_shared_ptr.set_count(new_count);</span>
<span class="lineNum">    1802 </span><span class="lineNoCov">          0 :   _deletes_self_when_unused = true;</span>
<span class="lineNum">    1803 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1804 </span>            : FJCORE_END_NAMESPACE
<span class="lineNum">    1805 </span>            : #include&lt;limits&gt;
<span class="lineNum">    1806 </span>            : #include&lt;vector&gt;
<span class="lineNum">    1807 </span>            : #include&lt;cmath&gt;
<span class="lineNum">    1808 </span>            : #include&lt;iostream&gt;
<span class="lineNum">    1809 </span>            : FJCORE_BEGIN_NAMESPACE      // defined in fastjet/internal/base.hh
<span class="lineNum">    1810 </span>            : using namespace std;
<span class="lineNum">    1811 </span>            : namespace Private {
<span class="lineNum">    1812 </span>            :   class MirrorInfo{
<a name="1813"><span class="lineNum">    1813 </span>            :   public:</a>
<a name="1814"><span class="lineNum">    1814 </span>            :     int orig, mirror;</a>
<span class="lineNum">    1815 </span><span class="lineNoCov">          0 :     MirrorInfo(int a, int b) : orig(a), mirror(b) {};</span>
<a name="1816"><span class="lineNum">    1816 </span><span class="lineNoCov">          0 :     MirrorInfo() {};</span></a>
<span class="lineNum">    1817 </span>            :   };
<span class="lineNum">    1818 </span>            :   bool make_mirror(Coord2D &amp; point, double Dlim) {
<span class="lineNum">    1819 </span><span class="lineNoCov">          0 :     if (point.y &lt; Dlim)       {point.y += twopi; return true;}</span>
<span class="lineNum">    1820 </span><span class="lineNoCov">          0 :     if (twopi-point.y &lt; Dlim) {point.y -= twopi; return true;}</span>
<span class="lineNum">    1821 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1822 </span><span class="lineNoCov">          0 :   }</span>
<a name="1823"><span class="lineNum">    1823 </span>            : }</a>
<span class="lineNum">    1824 </span>            : using namespace Private;
<span class="lineNum">    1825 </span>            : void ClusterSequence::_CP2DChan_limited_cluster (double Dlim) {
<span class="lineNum">    1826 </span><span class="lineNoCov">          0 :   unsigned int n = _initial_n;</span>
<span class="lineNum">    1827 </span><span class="lineNoCov">          0 :   vector&lt;MirrorInfo&gt;   coordIDs(2*n); // coord IDs of a given jetID</span>
<span class="lineNum">    1828 </span><span class="lineNoCov">          0 :   vector&lt;int&gt;          jetIDs(2*n);   // jet ID for a given coord ID</span>
<span class="lineNum">    1829 </span><span class="lineNoCov">          0 :   vector&lt;Coord2D&gt;      coords(2*n);   // our coordinates (and copies)</span>
<span class="lineNum">    1830 </span><span class="lineNoCov">          0 :   double Dlim4mirror = min(Dlim,pi);</span>
<span class="lineNum">    1831 </span><span class="lineNoCov">          0 :   double minrap = numeric_limits&lt;double&gt;::max();</span>
<span class="lineNum">    1832 </span><span class="lineNoCov">          0 :   double maxrap = -minrap;</span>
<span class="lineNum">    1833 </span>            :   int coord_index = -1;
<span class="lineNum">    1834 </span>            :   int n_active = 0;
<span class="lineNum">    1835 </span><span class="lineNoCov">          0 :   for (unsigned jet_i = 0; jet_i &lt; _jets.size(); jet_i++) {</span>
<span class="lineNum">    1836 </span><span class="lineNoCov">          0 :     if (_history[_jets[jet_i].cluster_hist_index()].child != Invalid ||</span>
<span class="lineNum">    1837 </span><span class="lineNoCov">          0 :         (_jets[jet_i].E() == abs(_jets[jet_i].pz()) &amp;&amp;</span>
<span class="lineNum">    1838 </span><span class="lineNoCov">          0 :          _jets[jet_i].perp2() == 0.0)</span>
<span class="lineNum">    1839 </span>            :         ) {continue;}
<span class="lineNum">    1840 </span><span class="lineNoCov">          0 :     n_active++;</span>
<span class="lineNum">    1841 </span><span class="lineNoCov">          0 :     coordIDs[jet_i].orig = ++coord_index;</span>
<span class="lineNum">    1842 </span><span class="lineNoCov">          0 :     coords[coord_index]  = Coord2D(_jets[jet_i].rap(), _jets[jet_i].phi_02pi());</span>
<span class="lineNum">    1843 </span><span class="lineNoCov">          0 :     jetIDs[coord_index]  = jet_i;</span>
<span class="lineNum">    1844 </span><span class="lineNoCov">          0 :     minrap = min(coords[coord_index].x,minrap);</span>
<span class="lineNum">    1845 </span><span class="lineNoCov">          0 :     maxrap = max(coords[coord_index].x,maxrap);</span>
<span class="lineNum">    1846 </span><span class="lineNoCov">          0 :     Coord2D mirror_point(coords[coord_index]);</span>
<span class="lineNum">    1847 </span><span class="lineNoCov">          0 :     if (make_mirror(mirror_point, Dlim4mirror)) {</span>
<span class="lineNum">    1848 </span><span class="lineNoCov">          0 :       coordIDs[jet_i].mirror = ++coord_index;</span>
<span class="lineNum">    1849 </span><span class="lineNoCov">          0 :       coords[coord_index] = mirror_point;</span>
<span class="lineNum">    1850 </span><span class="lineNoCov">          0 :       jetIDs[coord_index] = jet_i;</span>
<span class="lineNum">    1851 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">    1852 </span><span class="lineNoCov">          0 :       coordIDs[jet_i].mirror = Invalid;</span>
<span class="lineNum">    1853 </span>            :     }
<span class="lineNum">    1854 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1855 </span><span class="lineNoCov">          0 :   coords.resize(coord_index+1);</span>
<span class="lineNum">    1856 </span><span class="lineNoCov">          0 :   Coord2D left_edge(minrap-1.0, -3.15); // a security margin below  -pi</span>
<span class="lineNum">    1857 </span><span class="lineNoCov">          0 :   Coord2D right_edge(maxrap+1.0, 9.45); // a security margin above 3*pi</span>
<span class="lineNum">    1858 </span><span class="lineNoCov">          0 :   ClosestPair2D cp(coords, left_edge, right_edge);</span>
<span class="lineNum">    1859 </span><span class="lineNoCov">          0 :   vector&lt;Coord2D&gt; new_points(2);</span>
<span class="lineNum">    1860 </span><span class="lineNoCov">          0 :   vector&lt;unsigned int&gt; cIDs_to_remove(4);</span>
<span class="lineNum">    1861 </span><span class="lineNoCov">          0 :   vector&lt;unsigned int&gt; new_cIDs(2);</span>
<span class="lineNum">    1862 </span>            :   do {
<span class="lineNum">    1863 </span><span class="lineNoCov">          0 :     unsigned int cID1, cID2;</span>
<span class="lineNum">    1864 </span><span class="lineNoCov">          0 :     double distance2;</span>
<span class="lineNum">    1865 </span><span class="lineNoCov">          0 :     cp.closest_pair(cID1,cID2,distance2);</span>
<span class="lineNum">    1866 </span><span class="lineNoCov">          0 :     if (distance2 &gt; Dlim*Dlim) {break;}</span>
<span class="lineNum">    1867 </span><span class="lineNoCov">          0 :     distance2 *= _invR2;</span>
<span class="lineNum">    1868 </span><span class="lineNoCov">          0 :     int jet_i = jetIDs[cID1];</span>
<span class="lineNum">    1869 </span><span class="lineNoCov">          0 :     int jet_j = jetIDs[cID2];</span>
<span class="lineNum">    1870 </span><span class="lineNoCov">          0 :     assert (jet_i != jet_j); // to catch issue of recombining with mirror point</span>
<span class="lineNum">    1871 </span><span class="lineNoCov">          0 :     int newjet_k;</span>
<span class="lineNum">    1872 </span><span class="lineNoCov">          0 :     _do_ij_recombination_step(jet_i, jet_j, distance2, newjet_k);</span>
<span class="lineNum">    1873 </span><span class="lineNoCov">          0 :     if (--n_active == 1) {break;}</span>
<span class="lineNum">    1874 </span><span class="lineNoCov">          0 :     cIDs_to_remove.resize(0);</span>
<span class="lineNum">    1875 </span><span class="lineNoCov">          0 :     cIDs_to_remove.push_back(coordIDs[jet_i].orig);</span>
<span class="lineNum">    1876 </span><span class="lineNoCov">          0 :     cIDs_to_remove.push_back(coordIDs[jet_j].orig);</span>
<span class="lineNum">    1877 </span><span class="lineNoCov">          0 :     if (coordIDs[jet_i].mirror != Invalid)</span>
<span class="lineNum">    1878 </span><span class="lineNoCov">          0 :       cIDs_to_remove.push_back(coordIDs[jet_i].mirror);</span>
<span class="lineNum">    1879 </span><span class="lineNoCov">          0 :     if (coordIDs[jet_j].mirror != Invalid)</span>
<span class="lineNum">    1880 </span><span class="lineNoCov">          0 :       cIDs_to_remove.push_back(coordIDs[jet_j].mirror);</span>
<span class="lineNum">    1881 </span><span class="lineNoCov">          0 :     Coord2D new_point(_jets[newjet_k].rap(),_jets[newjet_k].phi_02pi());</span>
<span class="lineNum">    1882 </span><span class="lineNoCov">          0 :     new_points.resize(0);</span>
<span class="lineNum">    1883 </span><span class="lineNoCov">          0 :     new_points.push_back(new_point);</span>
<span class="lineNum">    1884 </span><span class="lineNoCov">          0 :     if (make_mirror(new_point, Dlim4mirror)) new_points.push_back(new_point);  //&lt; same warning as before concerning the mirroring</span>
<span class="lineNum">    1885 </span><span class="lineNoCov">          0 :     cp.replace_many(cIDs_to_remove, new_points, new_cIDs);</span>
<span class="lineNum">    1886 </span><span class="lineNoCov">          0 :     coordIDs[newjet_k].orig = new_cIDs[0];</span>
<span class="lineNum">    1887 </span><span class="lineNoCov">          0 :     jetIDs[new_cIDs[0]]       = newjet_k;</span>
<span class="lineNum">    1888 </span><span class="lineNoCov">          0 :     if (new_cIDs.size() == 2) {</span>
<span class="lineNum">    1889 </span><span class="lineNoCov">          0 :       coordIDs[newjet_k].mirror = new_cIDs[1];</span>
<span class="lineNum">    1890 </span><span class="lineNoCov">          0 :       jetIDs[new_cIDs[1]]         = newjet_k;</span>
<span class="lineNum">    1891 </span><span class="lineNoCov">          0 :     } else {coordIDs[newjet_k].mirror = Invalid;}</span>
<a name="1892"><span class="lineNum">    1892 </span><span class="lineNoCov">          0 :   } while(true);</span></a>
<span class="lineNum">    1893 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1894 </span>            : void ClusterSequence::_CP2DChan_cluster_2pi2R () {
<span class="lineNum">    1895 </span><span class="lineNoCov">          0 :   if (_jet_algorithm != cambridge_algorithm) throw Error(&quot;CP2DChan clustering method called for a jet-finder that is not the cambridge algorithm&quot;);</span>
<span class="lineNum">    1896 </span><span class="lineNoCov">          0 :   _CP2DChan_limited_cluster(_Rparam);</span>
<a name="1897"><span class="lineNum">    1897 </span><span class="lineNoCov">          0 :   _do_Cambridge_inclusive_jets();</span></a>
<span class="lineNum">    1898 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1899 </span>            : void ClusterSequence::_CP2DChan_cluster_2piMultD () {
<span class="lineNum">    1900 </span><span class="lineNoCov">          0 :   if (_Rparam &gt;= 0.39) {</span>
<span class="lineNum">    1901 </span><span class="lineNoCov">          0 :     _CP2DChan_limited_cluster(min(_Rparam/2,0.3));</span>
<span class="lineNum">    1902 </span><span class="lineNoCov">          0 :   }</span>
<a name="1903"><span class="lineNum">    1903 </span><span class="lineNoCov">          0 :   _CP2DChan_cluster_2pi2R ();</span></a>
<span class="lineNum">    1904 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1905 </span>            : void ClusterSequence::_CP2DChan_cluster () {
<span class="lineNum">    1906 </span><span class="lineNoCov">          0 :   if (_jet_algorithm != cambridge_algorithm) throw Error(&quot;_CP2DChan_cluster called for a jet-finder that is not the cambridge algorithm&quot;);</span>
<span class="lineNum">    1907 </span><span class="lineNoCov">          0 :   unsigned int n = _jets.size();</span>
<span class="lineNum">    1908 </span><span class="lineNoCov">          0 :   vector&lt;MirrorInfo&gt;   coordIDs(2*n);  // link from original to mirror indices</span>
<span class="lineNum">    1909 </span><span class="lineNoCov">          0 :   vector&lt;int&gt;          jetIDs(2*n);     // link from mirror to original indices</span>
<span class="lineNum">    1910 </span><span class="lineNoCov">          0 :   vector&lt;Coord2D&gt;      coords(2*n);   // our coordinates (and copies)</span>
<span class="lineNum">    1911 </span><span class="lineNoCov">          0 :   double minrap = numeric_limits&lt;double&gt;::max();</span>
<span class="lineNum">    1912 </span><span class="lineNoCov">          0 :   double maxrap = -minrap;</span>
<span class="lineNum">    1913 </span>            :   int coord_index = 0;
<span class="lineNum">    1914 </span><span class="lineNoCov">          0 :   for (unsigned i = 0; i &lt; n; i++) {</span>
<span class="lineNum">    1915 </span><span class="lineNoCov">          0 :     if (_jets[i].E() == abs(_jets[i].pz()) &amp;&amp; _jets[i].perp2() == 0.0) {</span>
<span class="lineNum">    1916 </span><span class="lineNoCov">          0 :       coordIDs[i] = MirrorInfo(BeamJet,BeamJet);</span>
<span class="lineNum">    1917 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">    1918 </span><span class="lineNoCov">          0 :       coordIDs[i].orig   = coord_index;</span>
<span class="lineNum">    1919 </span><span class="lineNoCov">          0 :       coordIDs[i].mirror = coord_index+1;</span>
<span class="lineNum">    1920 </span><span class="lineNoCov">          0 :       coords[coord_index]   = Coord2D(_jets[i].rap(), _jets[i].phi_02pi());</span>
<span class="lineNum">    1921 </span><span class="lineNoCov">          0 :       coords[coord_index+1] = Coord2D(_jets[i].rap(), _jets[i].phi_02pi()+twopi);</span>
<span class="lineNum">    1922 </span><span class="lineNoCov">          0 :       jetIDs[coord_index]   = i;</span>
<span class="lineNum">    1923 </span><span class="lineNoCov">          0 :       jetIDs[coord_index+1] = i;</span>
<span class="lineNum">    1924 </span><span class="lineNoCov">          0 :       minrap = min(coords[coord_index].x,minrap);</span>
<span class="lineNum">    1925 </span><span class="lineNoCov">          0 :       maxrap = max(coords[coord_index].x,maxrap);</span>
<span class="lineNum">    1926 </span><span class="lineNoCov">          0 :       coord_index += 2;</span>
<span class="lineNum">    1927 </span>            :     }
<span class="lineNum">    1928 </span>            :   }
<span class="lineNum">    1929 </span><span class="lineNoCov">          0 :   for (unsigned i = n; i &lt; 2*n; i++) {coordIDs[i].orig = Invalid;}</span>
<span class="lineNum">    1930 </span><span class="lineNoCov">          0 :   coords.resize(coord_index);</span>
<span class="lineNum">    1931 </span><span class="lineNoCov">          0 :   Coord2D left_edge(minrap-1.0, 0.0);</span>
<span class="lineNum">    1932 </span><span class="lineNoCov">          0 :   Coord2D right_edge(maxrap+1.0, 2*twopi);</span>
<span class="lineNum">    1933 </span><span class="lineNoCov">          0 :   ClosestPair2D cp(coords, left_edge, right_edge);</span>
<span class="lineNum">    1934 </span><span class="lineNoCov">          0 :   vector&lt;Coord2D&gt; new_points(2);</span>
<span class="lineNum">    1935 </span><span class="lineNoCov">          0 :   vector&lt;unsigned int&gt; cIDs_to_remove(4);</span>
<span class="lineNum">    1936 </span><span class="lineNoCov">          0 :   vector&lt;unsigned int&gt; new_cIDs(2);</span>
<span class="lineNum">    1937 </span>            :   do {
<span class="lineNum">    1938 </span><span class="lineNoCov">          0 :     unsigned int cID1, cID2;</span>
<span class="lineNum">    1939 </span><span class="lineNoCov">          0 :     double distance2;</span>
<span class="lineNum">    1940 </span><span class="lineNoCov">          0 :     cp.closest_pair(cID1,cID2,distance2);</span>
<span class="lineNum">    1941 </span><span class="lineNoCov">          0 :     distance2 *= _invR2;</span>
<span class="lineNum">    1942 </span><span class="lineNoCov">          0 :     if (distance2 &gt; 1.0) {break;}</span>
<span class="lineNum">    1943 </span><span class="lineNoCov">          0 :     int jet_i = jetIDs[cID1];</span>
<span class="lineNum">    1944 </span><span class="lineNoCov">          0 :     int jet_j = jetIDs[cID2];</span>
<span class="lineNum">    1945 </span><span class="lineNoCov">          0 :     assert (jet_i != jet_j); // to catch issue of recombining with mirror point</span>
<span class="lineNum">    1946 </span><span class="lineNoCov">          0 :     int newjet_k;</span>
<span class="lineNum">    1947 </span><span class="lineNoCov">          0 :     _do_ij_recombination_step(jet_i, jet_j, distance2, newjet_k);</span>
<span class="lineNum">    1948 </span><span class="lineNoCov">          0 :     cIDs_to_remove[0] = coordIDs[jet_i].orig;</span>
<span class="lineNum">    1949 </span><span class="lineNoCov">          0 :     cIDs_to_remove[1] = coordIDs[jet_i].mirror;</span>
<span class="lineNum">    1950 </span><span class="lineNoCov">          0 :     cIDs_to_remove[2] = coordIDs[jet_j].orig;</span>
<span class="lineNum">    1951 </span><span class="lineNoCov">          0 :     cIDs_to_remove[3] = coordIDs[jet_j].mirror;</span>
<span class="lineNum">    1952 </span><span class="lineNoCov">          0 :     new_points[0] = Coord2D(_jets[newjet_k].rap(),_jets[newjet_k].phi_02pi());</span>
<span class="lineNum">    1953 </span><span class="lineNoCov">          0 :     new_points[1] = Coord2D(_jets[newjet_k].rap(),_jets[newjet_k].phi_02pi()+twopi);</span>
<span class="lineNum">    1954 </span><span class="lineNoCov">          0 :     new_cIDs[0] = cp.replace(cIDs_to_remove[0], cIDs_to_remove[2], new_points[0]);</span>
<span class="lineNum">    1955 </span><span class="lineNoCov">          0 :     new_cIDs[1] = cp.replace(cIDs_to_remove[1], cIDs_to_remove[3], new_points[1]);</span>
<span class="lineNum">    1956 </span><span class="lineNoCov">          0 :     coordIDs[jet_i].orig = Invalid;</span>
<span class="lineNum">    1957 </span><span class="lineNoCov">          0 :     coordIDs[jet_j].orig = Invalid;</span>
<span class="lineNum">    1958 </span><span class="lineNoCov">          0 :     coordIDs[newjet_k] = MirrorInfo(new_cIDs[0], new_cIDs[1]);</span>
<span class="lineNum">    1959 </span><span class="lineNoCov">          0 :     jetIDs[new_cIDs[0]] = newjet_k;</span>
<span class="lineNum">    1960 </span><span class="lineNoCov">          0 :     jetIDs[new_cIDs[1]] = newjet_k;</span>
<span class="lineNum">    1961 </span><span class="lineNoCov">          0 :     n--;</span>
<span class="lineNum">    1962 </span><span class="lineNoCov">          0 :     if (n == 1) {break;}</span>
<span class="lineNum">    1963 </span><span class="lineNoCov">          0 :   } while(true);</span>
<a name="1964"><span class="lineNum">    1964 </span><span class="lineNoCov">          0 :   _do_Cambridge_inclusive_jets();</span></a>
<span class="lineNum">    1965 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1966 </span>            : void ClusterSequence::_do_Cambridge_inclusive_jets () {
<span class="lineNum">    1967 </span><span class="lineNoCov">          0 :   unsigned int n = _history.size();</span>
<span class="lineNum">    1968 </span><span class="lineNoCov">          0 :   for (unsigned int hist_i = 0; hist_i &lt; n; hist_i++) {</span>
<span class="lineNum">    1969 </span><span class="lineNoCov">          0 :     if (_history[hist_i].child == Invalid) {</span>
<span class="lineNum">    1970 </span><span class="lineNoCov">          0 :       _do_iB_recombination_step(_history[hist_i].jetp_index, 1.0);</span>
<span class="lineNum">    1971 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1972 </span>            :   }
<span class="lineNum">    1973 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1974 </span>            : FJCORE_END_NAMESPACE
<span class="lineNum">    1975 </span>            : #include&lt;iostream&gt;
<span class="lineNum">    1976 </span>            : #include&lt;sstream&gt;
<span class="lineNum">    1977 </span>            : #include&lt;cmath&gt;
<span class="lineNum">    1978 </span>            : #include &lt;cstdlib&gt;
<span class="lineNum">    1979 </span>            : #include&lt;cassert&gt;
<span class="lineNum">    1980 </span>            : #include&lt;memory&gt;
<span class="lineNum">    1981 </span>            : #ifndef __FJCORE_DROP_CGAL // in case we do not have the code for CGAL
<span class="lineNum">    1982 </span>            : #include &quot;fastjet/internal/Dnn4piCylinder.hh&quot;
<span class="lineNum">    1983 </span>            : #include &quot;fastjet/internal/Dnn3piCylinder.hh&quot;
<span class="lineNum">    1984 </span>            : #include &quot;fastjet/internal/Dnn2piCylinder.hh&quot;
<span class="lineNum">    1985 </span>            : #endif //  __FJCORE_DROP_CGAL
<a name="1986"><span class="lineNum">    1986 </span>            : FJCORE_BEGIN_NAMESPACE      // defined in fastjet/internal/base.hh</a>
<span class="lineNum">    1987 </span>            : using namespace std;
<span class="lineNum">    1988 </span>            : void ClusterSequence::_delaunay_cluster () {
<span class="lineNum">    1989 </span><span class="lineNoCov">          0 :   int n = _jets.size();</span>
<span class="lineNum">    1990 </span><span class="lineNoCov">          0 :   vector&lt;EtaPhi&gt; points(n); // recall EtaPhi is just a typedef'd pair&lt;double&gt;</span>
<span class="lineNum">    1991 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; n; i++) {</span>
<span class="lineNum">    1992 </span><span class="lineNoCov">          0 :     points[i] = EtaPhi(_jets[i].rap(),_jets[i].phi_02pi());</span>
<span class="lineNum">    1993 </span><span class="lineNoCov">          0 :     points[i].sanitize(); // make sure things are in the right range</span>
<span class="lineNum">    1994 </span>            :   }
<span class="lineNum">    1995 </span><span class="lineNoCov">          0 :   auto_ptr&lt;DynamicNearestNeighbours&gt; DNN;</span>
<span class="lineNum">    1996 </span>            : #ifndef __FJCORE_DROP_CGAL // strategy = NlnN* are not supported if we drop CGAL...
<span class="lineNum">    1997 </span>            :   bool verbose = false;
<span class="lineNum">    1998 </span>            :   bool ignore_nearest_is_mirror = (_Rparam &lt; twopi);
<span class="lineNum">    1999 </span>            :   if (_strategy == NlnN4pi) {
<span class="lineNum">    2000 </span>            :     DNN.reset(new Dnn4piCylinder(points,verbose));
<span class="lineNum">    2001 </span>            :   } else if (_strategy == NlnN3pi) {
<span class="lineNum">    2002 </span>            :     DNN.reset(new Dnn3piCylinder(points,ignore_nearest_is_mirror,verbose));
<span class="lineNum">    2003 </span>            :   } else if (_strategy == NlnN) {
<span class="lineNum">    2004 </span>            :     DNN.reset(new Dnn2piCylinder(points,ignore_nearest_is_mirror,verbose));
<span class="lineNum">    2005 </span>            :   } else
<span class="lineNum">    2006 </span>            : #else
<span class="lineNum">    2007 </span><span class="lineNoCov">          0 :   if (_strategy == NlnN4pi || _strategy == NlnN3pi || _strategy == NlnN) {</span>
<span class="lineNum">    2008 </span><span class="lineNoCov">          0 :     ostringstream err;</span>
<span class="lineNum">    2009 </span><span class="lineNoCov">          0 :     err &lt;&lt; &quot;ERROR: Requested strategy &quot;&lt;&lt;strategy_string()&lt;&lt;&quot; but it is not&quot;&lt;&lt;endl;</span>
<span class="lineNum">    2010 </span><span class="lineNoCov">          0 :     err &lt;&lt; &quot;       supported because FastJet was compiled without CGAL&quot;&lt;&lt;endl;</span>
<span class="lineNum">    2011 </span><span class="lineNoCov">          0 :     throw Error(err.str());</span>
<span class="lineNum">    2012 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2013 </span>            : #endif // __FJCORE_DROP_CGAL
<span class="lineNum">    2014 </span>            :   {
<span class="lineNum">    2015 </span><span class="lineNoCov">          0 :     ostringstream err;</span>
<span class="lineNum">    2016 </span><span class="lineNoCov">          0 :     err &lt;&lt; &quot;ERROR: Unrecognized value for strategy: &quot;&lt;&lt;_strategy&lt;&lt;endl;</span>
<span class="lineNum">    2017 </span><span class="lineNoCov">          0 :     assert(false);</span>
<span class="lineNum">    2018 </span>            :     throw Error(err.str());
<span class="lineNum">    2019 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2020 </span>            :   DistMap DijMap;
<span class="lineNum">    2021 </span>            :   for (int ii = 0; ii &lt; n; ii++) {
<span class="lineNum">    2022 </span>            :     _add_ktdistance_to_map(ii, DijMap, DNN.get());
<span class="lineNum">    2023 </span>            :   }
<span class="lineNum">    2024 </span>            :   for (int i=0;i&lt;n;i++) {
<span class="lineNum">    2025 </span>            :     TwoVertices SmallestDijPair;
<span class="lineNum">    2026 </span>            :     int jet_i, jet_j;
<span class="lineNum">    2027 </span>            :     double SmallestDij;
<span class="lineNum">    2028 </span>            :     bool Valid2;
<span class="lineNum">    2029 </span>            :     bool recombine_with_beam;
<span class="lineNum">    2030 </span>            :     do {
<span class="lineNum">    2031 </span>            :       SmallestDij = DijMap.begin()-&gt;first;
<span class="lineNum">    2032 </span>            :       SmallestDijPair = DijMap.begin()-&gt;second;
<span class="lineNum">    2033 </span>            :       jet_i = SmallestDijPair.first;
<span class="lineNum">    2034 </span>            :       jet_j = SmallestDijPair.second;
<span class="lineNum">    2035 </span>            :       DijMap.erase(DijMap.begin());
<span class="lineNum">    2036 </span>            :       recombine_with_beam = (jet_j == BeamJet);
<span class="lineNum">    2037 </span>            :       if (!recombine_with_beam) {Valid2 = DNN-&gt;Valid(jet_j);}
<span class="lineNum">    2038 </span>            :       else {Valid2 = true;}
<span class="lineNum">    2039 </span>            :     } while ( !DNN-&gt;Valid(jet_i) || !Valid2);
<span class="lineNum">    2040 </span>            :     if (! recombine_with_beam) {
<span class="lineNum">    2041 </span>            :       int nn; // will be index of new jet
<span class="lineNum">    2042 </span>            :       _do_ij_recombination_step(jet_i, jet_j, SmallestDij, nn);
<span class="lineNum">    2043 </span>            :       EtaPhi newpoint(_jets[nn].rap(), _jets[nn].phi_02pi());
<span class="lineNum">    2044 </span>            :       newpoint.sanitize(); // make sure it is in correct range
<span class="lineNum">    2045 </span>            :       points.push_back(newpoint);
<span class="lineNum">    2046 </span>            :     } else {
<span class="lineNum">    2047 </span>            :       _do_iB_recombination_step(jet_i, SmallestDij);
<span class="lineNum">    2048 </span>            :     }
<span class="lineNum">    2049 </span>            :     if (i == n-1) {break;}
<span class="lineNum">    2050 </span>            :     vector&lt;int&gt; updated_neighbours;
<span class="lineNum">    2051 </span>            :     if (! recombine_with_beam) {
<span class="lineNum">    2052 </span>            :       int point3;
<span class="lineNum">    2053 </span>            :       DNN-&gt;RemoveCombinedAddCombination(jet_i, jet_j,
<span class="lineNum">    2054 </span>            :                                        points[points.size()-1], point3,
<span class="lineNum">    2055 </span>            :                                        updated_neighbours);
<span class="lineNum">    2056 </span>            :       if (static_cast&lt;unsigned int&gt; (point3) != points.size()-1) {
<span class="lineNum">    2057 </span>            :         throw Error(&quot;INTERNAL ERROR: point3 != points.size()-1&quot;);}
<span class="lineNum">    2058 </span>            :     } else {
<span class="lineNum">    2059 </span>            :       DNN-&gt;RemovePoint(jet_i, updated_neighbours);
<span class="lineNum">    2060 </span>            :     }
<span class="lineNum">    2061 </span>            :     vector&lt;int&gt;::iterator it = updated_neighbours.begin();
<span class="lineNum">    2062 </span>            :     for (; it != updated_neighbours.end(); ++it) {
<span class="lineNum">    2063 </span>            :       int ii = *it;
<span class="lineNum">    2064 </span>            :       _add_ktdistance_to_map(ii, DijMap, DNN.get());
<span class="lineNum">    2065 </span>            :     }
<a name="2066"><span class="lineNum">    2066 </span>            :   } // end clustering loop</a>
<span class="lineNum">    2067 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2068 </span>            : void ClusterSequence::_add_ktdistance_to_map(
<span class="lineNum">    2069 </span>            :                           const int &amp; ii,
<span class="lineNum">    2070 </span>            :                           DistMap &amp; DijMap,
<span class="lineNum">    2071 </span>            :                           const DynamicNearestNeighbours * DNN) {
<span class="lineNum">    2072 </span><span class="lineNoCov">          0 :   double yiB = jet_scale_for_algorithm(_jets[ii]);</span>
<span class="lineNum">    2073 </span><span class="lineNoCov">          0 :   if (yiB == 0.0) {</span>
<span class="lineNum">    2074 </span><span class="lineNoCov">          0 :     DijMap.insert(DijEntry(yiB,  TwoVertices(ii,-1)));</span>
<span class="lineNum">    2075 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">    2076 </span><span class="lineNoCov">          0 :     double DeltaR2 = DNN-&gt;NearestNeighbourDistance(ii) * _invR2;</span>
<span class="lineNum">    2077 </span><span class="lineNoCov">          0 :     if (DeltaR2 &gt; 1.0) {</span>
<span class="lineNum">    2078 </span><span class="lineNoCov">          0 :       DijMap.insert(DijEntry(yiB,  TwoVertices(ii,-1)));</span>
<span class="lineNum">    2079 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">    2080 </span><span class="lineNoCov">          0 :       double kt2i = jet_scale_for_algorithm(_jets[ii]);</span>
<span class="lineNum">    2081 </span><span class="lineNoCov">          0 :       int jj = DNN-&gt;NearestNeighbourIndex(ii);</span>
<span class="lineNum">    2082 </span><span class="lineNoCov">          0 :       if (kt2i &lt;= jet_scale_for_algorithm(_jets[jj])) {</span>
<span class="lineNum">    2083 </span><span class="lineNoCov">          0 :         double dij = DeltaR2 * kt2i;</span>
<span class="lineNum">    2084 </span><span class="lineNoCov">          0 :         DijMap.insert(DijEntry(dij, TwoVertices(ii,jj)));</span>
<span class="lineNum">    2085 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    2086 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2087 </span>            :   }
<span class="lineNum">    2088 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2089 </span>            : FJCORE_END_NAMESPACE
<span class="lineNum">    2090 </span>            : #include&lt;iostream&gt;
<span class="lineNum">    2091 </span>            : #include&lt;cmath&gt;
<span class="lineNum">    2092 </span>            : #include &lt;cstdlib&gt;
<span class="lineNum">    2093 </span>            : #include&lt;cassert&gt;
<a name="2094"><span class="lineNum">    2094 </span>            : FJCORE_BEGIN_NAMESPACE      // defined in fastjet/internal/base.hh</a>
<span class="lineNum">    2095 </span>            : using namespace std;
<span class="lineNum">    2096 </span>            : void ClusterSequence::_really_dumb_cluster () {
<span class="lineNum">    2097 </span><span class="lineNoCov">          0 :   vector&lt;PseudoJet *&gt; jetsp(_jets.size());</span>
<span class="lineNum">    2098 </span><span class="lineNoCov">          0 :   vector&lt;int&gt;         indices(_jets.size());</span>
<span class="lineNum">    2099 </span><span class="lineNoCov">          0 :   for (size_t i = 0; i&lt;_jets.size(); i++) {</span>
<span class="lineNum">    2100 </span><span class="lineNoCov">          0 :     jetsp[i] = &amp; _jets[i];</span>
<span class="lineNum">    2101 </span><span class="lineNoCov">          0 :     indices[i] = i;</span>
<span class="lineNum">    2102 </span>            :   }
<span class="lineNum">    2103 </span><span class="lineNoCov">          0 :   for (int n = jetsp.size(); n &gt; 0; n--) {</span>
<span class="lineNum">    2104 </span>            :     int ii, jj;
<span class="lineNum">    2105 </span><span class="lineNoCov">          0 :     double ymin = jet_scale_for_algorithm(*(jetsp[0]));</span>
<span class="lineNum">    2106 </span>            :     ii = 0; jj = -2;
<span class="lineNum">    2107 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; n; i++) {</span>
<span class="lineNum">    2108 </span><span class="lineNoCov">          0 :       double yiB = jet_scale_for_algorithm(*(jetsp[i]));</span>
<span class="lineNum">    2109 </span><span class="lineNoCov">          0 :       if (yiB &lt; ymin) {</span>
<span class="lineNum">    2110 </span><span class="lineNoCov">          0 :         ymin = yiB; ii = i; jj = -2;}</span>
<span class="lineNum">    2111 </span>            :     }
<span class="lineNum">    2112 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; n-1; i++) {</span>
<span class="lineNum">    2113 </span><span class="lineNoCov">          0 :       for (int j = i+1; j &lt; n; j++) {</span>
<span class="lineNum">    2114 </span>            :         //double y = jetsp[i]-&gt;kt_distance(*jetsp[j])*_invR2;
<span class="lineNum">    2115 </span><span class="lineNoCov">          0 :         double y = min(jet_scale_for_algorithm(*(jetsp[i])),</span>
<span class="lineNum">    2116 </span><span class="lineNoCov">          0 :                        jet_scale_for_algorithm(*(jetsp[j])))</span>
<span class="lineNum">    2117 </span><span class="lineNoCov">          0 :                     * jetsp[i]-&gt;plain_distance(*jetsp[j])*_invR2;</span>
<span class="lineNum">    2118 </span><span class="lineNoCov">          0 :         if (y &lt; ymin) {ymin = y; ii = i; jj = j;}</span>
<span class="lineNum">    2119 </span>            :       }
<span class="lineNum">    2120 </span>            :     }
<span class="lineNum">    2121 </span><span class="lineNoCov">          0 :     int newn = 2*jetsp.size() - n;</span>
<span class="lineNum">    2122 </span><span class="lineNoCov">          0 :     if (jj &gt;= 0) {</span>
<span class="lineNum">    2123 </span><span class="lineNoCov">          0 :       int nn; // new jet index</span>
<span class="lineNum">    2124 </span><span class="lineNoCov">          0 :       _do_ij_recombination_step(jetsp[ii]-&amp;_jets[0],</span>
<span class="lineNum">    2125 </span><span class="lineNoCov">          0 :                                 jetsp[jj]-&amp;_jets[0], ymin, nn);</span>
<span class="lineNum">    2126 </span><span class="lineNoCov">          0 :       jetsp[ii] = &amp;_jets[nn];</span>
<span class="lineNum">    2127 </span><span class="lineNoCov">          0 :       jetsp[jj] = jetsp[n-1];</span>
<span class="lineNum">    2128 </span><span class="lineNoCov">          0 :       indices[ii] = newn;</span>
<span class="lineNum">    2129 </span><span class="lineNoCov">          0 :       indices[jj] = indices[n-1];</span>
<span class="lineNum">    2130 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">    2131 </span><span class="lineNoCov">          0 :       _do_iB_recombination_step(jetsp[ii]-&amp;_jets[0], ymin);</span>
<span class="lineNum">    2132 </span><span class="lineNoCov">          0 :       jetsp[ii] = jetsp[n-1];</span>
<span class="lineNum">    2133 </span><span class="lineNoCov">          0 :       indices[ii] = indices[n-1];</span>
<span class="lineNum">    2134 </span>            :     }
<span class="lineNum">    2135 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2136 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2137 </span>            : FJCORE_END_NAMESPACE
<span class="lineNum">    2138 </span>            : #include&lt;iostream&gt;
<a name="2139"><span class="lineNum">    2139 </span>            : FJCORE_BEGIN_NAMESPACE      // defined in fastjet/internal/base.hh</a>
<span class="lineNum">    2140 </span>            : using namespace std;
<span class="lineNum">    2141 </span>            : template&lt;&gt; inline void ClusterSequence::_bj_set_jetinfo(
<span class="lineNum">    2142 </span>            :                            EEBriefJet * const jetA, const int _jets_index) const {
<span class="lineNum">    2143 </span><span class="lineNoCov">          0 :   double E = _jets[_jets_index].E();</span>
<span class="lineNum">    2144 </span><span class="lineNoCov">          0 :   double scale = E*E; // the default energy scale for the kt alg</span>
<span class="lineNum">    2145 </span><span class="lineNoCov">          0 :   double p  = jet_def().extra_param(); // in case we're ee_genkt</span>
<span class="lineNum">    2146 </span><span class="lineNoCov">          0 :   switch (_jet_algorithm) {</span>
<span class="lineNum">    2147 </span>            :   case ee_kt_algorithm:
<span class="lineNum">    2148 </span><span class="lineNoCov">          0 :     assert(_Rparam &gt; 2.0); // force this to be true! [not best place, but works]</span>
<span class="lineNum">    2149 </span>            :     break;
<span class="lineNum">    2150 </span>            :   case ee_genkt_algorithm:
<span class="lineNum">    2151 </span><span class="lineNoCov">          0 :     if (p &lt;= 0 &amp;&amp; scale &lt; 1e-300) scale = 1e-300; // same dodgy safety as genkt</span>
<span class="lineNum">    2152 </span><span class="lineNoCov">          0 :     scale = pow(scale,p);</span>
<span class="lineNum">    2153 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    2154 </span>            :   default:
<span class="lineNum">    2155 </span><span class="lineNoCov">          0 :     throw Error(&quot;Unrecognised jet algorithm&quot;);</span>
<span class="lineNum">    2156 </span>            :   }
<span class="lineNum">    2157 </span><span class="lineNoCov">          0 :   jetA-&gt;kt2  = scale; // &quot;kt2&quot; might one day be renamed as &quot;scale&quot; or some such</span>
<span class="lineNum">    2158 </span><span class="lineNoCov">          0 :   double norm = _jets[_jets_index].modp2();</span>
<span class="lineNum">    2159 </span><span class="lineNoCov">          0 :   if (norm &gt; 0) {</span>
<span class="lineNum">    2160 </span><span class="lineNoCov">          0 :     norm = 1.0/sqrt(norm);</span>
<span class="lineNum">    2161 </span><span class="lineNoCov">          0 :     jetA-&gt;nx = norm * _jets[_jets_index].px();</span>
<span class="lineNum">    2162 </span><span class="lineNoCov">          0 :     jetA-&gt;ny = norm * _jets[_jets_index].py();</span>
<span class="lineNum">    2163 </span><span class="lineNoCov">          0 :     jetA-&gt;nz = norm * _jets[_jets_index].pz();</span>
<span class="lineNum">    2164 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">    2165 </span><span class="lineNoCov">          0 :     jetA-&gt;nx = 0.0;</span>
<span class="lineNum">    2166 </span><span class="lineNoCov">          0 :     jetA-&gt;ny = 0.0;</span>
<span class="lineNum">    2167 </span><span class="lineNoCov">          0 :     jetA-&gt;nz = 1.0;</span>
<span class="lineNum">    2168 </span>            :   }
<span class="lineNum">    2169 </span><span class="lineNoCov">          0 :   jetA-&gt;_jets_index = _jets_index;</span>
<span class="lineNum">    2170 </span><span class="lineNoCov">          0 :   jetA-&gt;NN_dist = _R2;</span>
<a name="2171"><span class="lineNum">    2171 </span><span class="lineNoCov">          0 :   jetA-&gt;NN      = NULL;</span></a>
<span class="lineNum">    2172 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2173 </span>            : template&lt;&gt; double ClusterSequence::_bj_dist(
<span class="lineNum">    2174 </span>            :                 const EEBriefJet * const jeta,
<span class="lineNum">    2175 </span>            :                 const EEBriefJet * const jetb) const {
<span class="lineNum">    2176 </span>            :   double dist = 1.0
<span class="lineNum">    2177 </span><span class="lineNoCov">          0 :     - jeta-&gt;nx*jetb-&gt;nx</span>
<span class="lineNum">    2178 </span><span class="lineNoCov">          0 :     - jeta-&gt;ny*jetb-&gt;ny</span>
<span class="lineNum">    2179 </span><span class="lineNoCov">          0 :     - jeta-&gt;nz*jetb-&gt;nz;</span>
<span class="lineNum">    2180 </span><span class="lineNoCov">          0 :   dist *= 2; // distance is _2_*min(Ei^2,Ej^2)*(1-cos theta)</span>
<a name="2181"><span class="lineNum">    2181 </span><span class="lineNoCov">          0 :   return dist;</span></a>
<span class="lineNum">    2182 </span>            : }
<span class="lineNum">    2183 </span>            : void ClusterSequence::_simple_N2_cluster_BriefJet() {
<a name="2184"><span class="lineNum">    2184 </span><span class="lineNoCov">          0 :   _simple_N2_cluster&lt;BriefJet&gt;();</span></a>
<span class="lineNum">    2185 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2186 </span>            : void ClusterSequence::_simple_N2_cluster_EEBriefJet() {
<span class="lineNum">    2187 </span><span class="lineNoCov">          0 :   _simple_N2_cluster&lt;EEBriefJet&gt;();</span>
<span class="lineNum">    2188 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2189 </span>            : FJCORE_END_NAMESPACE
<span class="lineNum">    2190 </span>            : #include &lt;iostream&gt;
<a name="2191"><span class="lineNum">    2191 </span>            : FJCORE_BEGIN_NAMESPACE      // defined in fastjet/internal/base.hh</a>
<span class="lineNum">    2192 </span>            : using namespace std;
<span class="lineNum">    2193 </span><span class="lineNoCov">          0 : ClusterSequenceStructure::~ClusterSequenceStructure(){</span>
<span class="lineNum">    2194 </span><span class="lineNoCov">          0 :   if (_associated_cs != NULL</span>
<span class="lineNum">    2195 </span><span class="lineNoCov">          0 :       &amp;&amp; _associated_cs-&gt;will_delete_self_when_unused()) {</span>
<span class="lineNum">    2196 </span><span class="lineNoCov">          0 :     _associated_cs-&gt;signal_imminent_self_deletion();</span>
<span class="lineNum">    2197 </span><span class="lineNoCov">          0 :     delete _associated_cs;</span>
<a name="2198"><span class="lineNum">    2198 </span>            :   }</a>
<span class="lineNum">    2199 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2200 </span>            : bool ClusterSequenceStructure::has_valid_cluster_sequence() const{
<a name="2201"><span class="lineNum">    2201 </span><span class="lineNoCov">          0 :   return (_associated_cs != NULL);</span></a>
<span class="lineNum">    2202 </span>            : }
<span class="lineNum">    2203 </span>            : const ClusterSequence* ClusterSequenceStructure::associated_cluster_sequence() const{
<a name="2204"><span class="lineNum">    2204 </span><span class="lineNoCov">          0 :   return _associated_cs;</span></a>
<span class="lineNum">    2205 </span>            : }
<span class="lineNum">    2206 </span>            : const ClusterSequence * ClusterSequenceStructure::validated_cs() const {
<span class="lineNum">    2207 </span><span class="lineNoCov">          0 :   if (!_associated_cs)</span>
<span class="lineNum">    2208 </span><span class="lineNoCov">          0 :     throw Error(&quot;you requested information about the internal structure of a jet, but its associated ClusterSequence has gone out of scope.&quot;);</span>
<a name="2209"><span class="lineNum">    2209 </span><span class="lineNoCov">          0 :   return _associated_cs;</span></a>
<span class="lineNum">    2210 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2211 </span>            : bool ClusterSequenceStructure::has_partner(const PseudoJet &amp;reference, PseudoJet &amp;partner) const{
<a name="2212"><span class="lineNum">    2212 </span><span class="lineNoCov">          0 :   return validated_cs()-&gt;has_partner(reference, partner);</span></a>
<span class="lineNum">    2213 </span>            : }
<span class="lineNum">    2214 </span>            : bool ClusterSequenceStructure::has_child(const PseudoJet &amp;reference, PseudoJet &amp;child) const{
<a name="2215"><span class="lineNum">    2215 </span><span class="lineNoCov">          0 :   return validated_cs()-&gt;has_child(reference, child);</span></a>
<span class="lineNum">    2216 </span>            : }
<span class="lineNum">    2217 </span>            : bool ClusterSequenceStructure::has_parents(const PseudoJet &amp;reference, PseudoJet &amp;parent1, PseudoJet &amp;parent2) const{
<a name="2218"><span class="lineNum">    2218 </span><span class="lineNoCov">          0 :   return validated_cs()-&gt;has_parents(reference, parent1, parent2);</span></a>
<span class="lineNum">    2219 </span>            : }
<span class="lineNum">    2220 </span>            : bool ClusterSequenceStructure::object_in_jet(const PseudoJet &amp;reference, const PseudoJet &amp;jet) const{
<span class="lineNum">    2221 </span><span class="lineNoCov">          0 :   if ((!has_associated_cluster_sequence()) || (!jet.has_associated_cluster_sequence()))</span>
<span class="lineNum">    2222 </span><span class="lineNoCov">          0 :     throw Error(&quot;you requested information about the internal structure of a jet, but it is not associated with a ClusterSequence or its associated ClusterSequence has gone out of scope.&quot;);</span>
<span class="lineNum">    2223 </span><span class="lineNoCov">          0 :   if (reference.associated_cluster_sequence() != jet.associated_cluster_sequence()) return false;</span>
<a name="2224"><span class="lineNum">    2224 </span><span class="lineNoCov">          0 :   return validated_cs()-&gt;object_in_jet(reference, jet);</span></a>
<span class="lineNum">    2225 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2226 </span>            : bool ClusterSequenceStructure::has_constituents() const{
<span class="lineNum">    2227 </span><span class="lineNoCov">          0 :   if (!has_associated_cluster_sequence())</span>
<span class="lineNum">    2228 </span><span class="lineNoCov">          0 :     throw Error(&quot;you requested information about the internal structure of a jet, but it is not associated with a ClusterSequence or its associated ClusterSequence has gone out of scope.&quot;);</span>
<a name="2229"><span class="lineNum">    2229 </span><span class="lineNoCov">          0 :   return true;</span></a>
<span class="lineNum">    2230 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2231 </span>            : vector&lt;PseudoJet&gt; ClusterSequenceStructure::constituents(const PseudoJet &amp;reference) const{
<a name="2232"><span class="lineNum">    2232 </span><span class="lineNoCov">          0 :   return validated_cs()-&gt;constituents(reference);</span></a>
<span class="lineNum">    2233 </span>            : }
<span class="lineNum">    2234 </span>            : bool ClusterSequenceStructure::has_exclusive_subjets() const{
<span class="lineNum">    2235 </span><span class="lineNoCov">          0 :   if (!has_associated_cluster_sequence())</span>
<span class="lineNum">    2236 </span><span class="lineNoCov">          0 :     throw Error(&quot;you requested information about the internal structure of a jet, but it is not associated with a ClusterSequence or its associated ClusterSequence has gone out of scope.&quot;);</span>
<a name="2237"><span class="lineNum">    2237 </span><span class="lineNoCov">          0 :   return true;</span></a>
<span class="lineNum">    2238 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2239 </span>            : std::vector&lt;PseudoJet&gt; ClusterSequenceStructure::exclusive_subjets (const PseudoJet &amp;reference, const double &amp; dcut) const {
<a name="2240"><span class="lineNum">    2240 </span><span class="lineNoCov">          0 :   return validated_cs()-&gt;exclusive_subjets(reference, dcut);</span></a>
<span class="lineNum">    2241 </span>            : }
<span class="lineNum">    2242 </span>            : int ClusterSequenceStructure::n_exclusive_subjets(const PseudoJet &amp;reference, const double &amp; dcut) const {
<a name="2243"><span class="lineNum">    2243 </span><span class="lineNoCov">          0 :   return validated_cs()-&gt;n_exclusive_subjets(reference, dcut);</span></a>
<span class="lineNum">    2244 </span>            : }
<span class="lineNum">    2245 </span>            : std::vector&lt;PseudoJet&gt; ClusterSequenceStructure::exclusive_subjets_up_to (const PseudoJet &amp;reference, int nsub) const {
<a name="2246"><span class="lineNum">    2246 </span><span class="lineNoCov">          0 :   return validated_cs()-&gt;exclusive_subjets_up_to(reference, nsub);</span></a>
<span class="lineNum">    2247 </span>            : }
<span class="lineNum">    2248 </span>            : double ClusterSequenceStructure::exclusive_subdmerge(const PseudoJet &amp;reference, int nsub) const {
<a name="2249"><span class="lineNum">    2249 </span><span class="lineNoCov">          0 :   return validated_cs()-&gt;exclusive_subdmerge(reference, nsub);</span></a>
<span class="lineNum">    2250 </span>            : }
<span class="lineNum">    2251 </span>            : double ClusterSequenceStructure::exclusive_subdmerge_max(const PseudoJet &amp;reference, int nsub) const {
<a name="2252"><span class="lineNum">    2252 </span><span class="lineNoCov">          0 :   return validated_cs()-&gt;exclusive_subdmerge_max(reference, nsub);</span></a>
<span class="lineNum">    2253 </span>            : }
<span class="lineNum">    2254 </span>            : bool ClusterSequenceStructure::has_pieces(const PseudoJet &amp;reference) const{
<span class="lineNum">    2255 </span><span class="lineNoCov">          0 :   PseudoJet dummy1, dummy2;</span>
<a name="2256"><span class="lineNum">    2256 </span><span class="lineNoCov">          0 :   return has_parents(reference, dummy1, dummy2);</span></a>
<span class="lineNum">    2257 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2258 </span>            : vector&lt;PseudoJet&gt; ClusterSequenceStructure::pieces(const PseudoJet &amp;reference) const{
<span class="lineNum">    2259 </span><span class="lineNoCov">          0 :   PseudoJet j1, j2;</span>
<span class="lineNum">    2260 </span><span class="lineNoCov">          0 :   vector&lt;PseudoJet&gt; res;</span>
<span class="lineNum">    2261 </span><span class="lineNoCov">          0 :   if (has_parents(reference, j1, j2)){</span>
<span class="lineNum">    2262 </span><span class="lineNoCov">          0 :     res.push_back(j1);</span>
<span class="lineNum">    2263 </span><span class="lineNoCov">          0 :     res.push_back(j2);</span>
<span class="lineNum">    2264 </span>            :   }
<span class="lineNum">    2265 </span>            :   return res;
<span class="lineNum">    2266 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2267 </span>            : FJCORE_END_NAMESPACE
<span class="lineNum">    2268 </span>            : #include&lt;iostream&gt;
<span class="lineNum">    2269 </span>            : #include&lt;vector&gt;
<span class="lineNum">    2270 </span>            : #include&lt;cmath&gt;
<span class="lineNum">    2271 </span>            : #include&lt;algorithm&gt;
<a name="2272"><span class="lineNum">    2272 </span>            : FJCORE_BEGIN_NAMESPACE      // defined in fastjet/internal/base.hh</a>
<span class="lineNum">    2273 </span>            : using namespace std;
<span class="lineNum">    2274 </span>            : void ClusterSequence::_bj_remove_from_tiles(TiledJet * const jet) {
<span class="lineNum">    2275 </span><span class="lineNoCov">          0 :   Tile * tile = &amp; _tiles[jet-&gt;tile_index];</span>
<span class="lineNum">    2276 </span><span class="lineNoCov">          0 :   if (jet-&gt;previous == NULL) {</span>
<span class="lineNum">    2277 </span><span class="lineNoCov">          0 :     tile-&gt;head = jet-&gt;next;</span>
<span class="lineNum">    2278 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">    2279 </span><span class="lineNoCov">          0 :     jet-&gt;previous-&gt;next = jet-&gt;next;</span>
<span class="lineNum">    2280 </span>            :   }
<span class="lineNum">    2281 </span><span class="lineNoCov">          0 :   if (jet-&gt;next != NULL) {</span>
<span class="lineNum">    2282 </span><span class="lineNoCov">          0 :     jet-&gt;next-&gt;previous = jet-&gt;previous;</span>
<a name="2283"><span class="lineNum">    2283 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    2284 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2285 </span>            : void ClusterSequence::_initialise_tiles() {
<span class="lineNum">    2286 </span><span class="lineNoCov">          0 :   double default_size = max(0.1,_Rparam);</span>
<span class="lineNum">    2287 </span><span class="lineNoCov">          0 :   _tile_size_eta = default_size;</span>
<span class="lineNum">    2288 </span><span class="lineNoCov">          0 :   _n_tiles_phi   = max(3,int(floor(twopi/default_size)));</span>
<span class="lineNum">    2289 </span><span class="lineNoCov">          0 :   _tile_size_phi = twopi / _n_tiles_phi; // &gt;= _Rparam and fits in 2pi</span>
<span class="lineNum">    2290 </span><span class="lineNoCov">          0 :   _tiles_eta_min = 0.0;</span>
<span class="lineNum">    2291 </span><span class="lineNoCov">          0 :   _tiles_eta_max = 0.0;</span>
<span class="lineNum">    2292 </span>            :   const double maxrap = 7.0;
<span class="lineNum">    2293 </span><span class="lineNoCov">          0 :   for(unsigned int i = 0; i &lt; _jets.size(); i++) {</span>
<span class="lineNum">    2294 </span><span class="lineNoCov">          0 :     double eta = _jets[i].rap();</span>
<span class="lineNum">    2295 </span><span class="lineNoCov">          0 :     if (abs(eta) &lt; maxrap) {</span>
<span class="lineNum">    2296 </span><span class="lineNoCov">          0 :       if (eta &lt; _tiles_eta_min) {_tiles_eta_min = eta;}</span>
<span class="lineNum">    2297 </span><span class="lineNoCov">          0 :       if (eta &gt; _tiles_eta_max) {_tiles_eta_max = eta;}</span>
<span class="lineNum">    2298 </span>            :     }
<span class="lineNum">    2299 </span>            :   }
<span class="lineNum">    2300 </span><span class="lineNoCov">          0 :   _tiles_ieta_min = int(floor(_tiles_eta_min/_tile_size_eta));</span>
<span class="lineNum">    2301 </span><span class="lineNoCov">          0 :   _tiles_ieta_max = int(floor( _tiles_eta_max/_tile_size_eta));</span>
<span class="lineNum">    2302 </span><span class="lineNoCov">          0 :   _tiles_eta_min = _tiles_ieta_min * _tile_size_eta;</span>
<span class="lineNum">    2303 </span><span class="lineNoCov">          0 :   _tiles_eta_max = _tiles_ieta_max * _tile_size_eta;</span>
<span class="lineNum">    2304 </span><span class="lineNoCov">          0 :   _tiles.resize((_tiles_ieta_max-_tiles_ieta_min+1)*_n_tiles_phi);</span>
<span class="lineNum">    2305 </span><span class="lineNoCov">          0 :   for (int ieta = _tiles_ieta_min; ieta &lt;= _tiles_ieta_max; ieta++) {</span>
<span class="lineNum">    2306 </span><span class="lineNoCov">          0 :     for (int iphi = 0; iphi &lt; _n_tiles_phi; iphi++) {</span>
<span class="lineNum">    2307 </span><span class="lineNoCov">          0 :       Tile * tile = &amp; _tiles[_tile_index(ieta,iphi)];</span>
<span class="lineNum">    2308 </span><span class="lineNoCov">          0 :       tile-&gt;head = NULL; // first element of tiles points to itself</span>
<span class="lineNum">    2309 </span><span class="lineNoCov">          0 :       tile-&gt;begin_tiles[0] =  tile;</span>
<span class="lineNum">    2310 </span>            :       Tile ** pptile = &amp; (tile-&gt;begin_tiles[0]);
<span class="lineNum">    2311 </span><span class="lineNoCov">          0 :       pptile++;</span>
<span class="lineNum">    2312 </span><span class="lineNoCov">          0 :       tile-&gt;surrounding_tiles = pptile;</span>
<span class="lineNum">    2313 </span><span class="lineNoCov">          0 :       if (ieta &gt; _tiles_ieta_min) {</span>
<span class="lineNum">    2314 </span>            :         // with the itile subroutine, we can safely run tiles from
<span class="lineNum">    2315 </span>            :         // idphi=-1 to idphi=+1, because it takes care of
<span class="lineNum">    2316 </span>            :         // negative and positive boundaries
<span class="lineNum">    2317 </span><span class="lineNoCov">          0 :         for (int idphi = -1; idphi &lt;=+1; idphi++) {</span>
<span class="lineNum">    2318 </span><span class="lineNoCov">          0 :           *pptile = &amp; _tiles[_tile_index(ieta-1,iphi+idphi)];</span>
<span class="lineNum">    2319 </span><span class="lineNoCov">          0 :           pptile++;</span>
<span class="lineNum">    2320 </span>            :         }
<span class="lineNum">    2321 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    2322 </span><span class="lineNoCov">          0 :       *pptile = &amp; _tiles[_tile_index(ieta,iphi-1)];</span>
<span class="lineNum">    2323 </span><span class="lineNoCov">          0 :       pptile++;</span>
<span class="lineNum">    2324 </span><span class="lineNoCov">          0 :       tile-&gt;RH_tiles = pptile;</span>
<span class="lineNum">    2325 </span><span class="lineNoCov">          0 :       *pptile = &amp; _tiles[_tile_index(ieta,iphi+1)];</span>
<span class="lineNum">    2326 </span><span class="lineNoCov">          0 :       pptile++;</span>
<span class="lineNum">    2327 </span><span class="lineNoCov">          0 :       if (ieta &lt; _tiles_ieta_max) {</span>
<span class="lineNum">    2328 </span><span class="lineNoCov">          0 :         for (int idphi = -1; idphi &lt;= +1; idphi++) {</span>
<span class="lineNum">    2329 </span><span class="lineNoCov">          0 :           *pptile = &amp; _tiles[_tile_index(ieta+1,iphi+idphi)];</span>
<span class="lineNum">    2330 </span><span class="lineNoCov">          0 :           pptile++;</span>
<span class="lineNum">    2331 </span>            :         }
<span class="lineNum">    2332 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    2333 </span><span class="lineNoCov">          0 :       tile-&gt;end_tiles = pptile;</span>
<span class="lineNum">    2334 </span><span class="lineNoCov">          0 :       tile-&gt;tagged = false;</span>
<span class="lineNum">    2335 </span>            :     }
<a name="2336"><span class="lineNum">    2336 </span>            :   }</a>
<span class="lineNum">    2337 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2338 </span>            : int ClusterSequence::_tile_index(const double &amp; eta, const double &amp; phi) const {
<span class="lineNum">    2339 </span>            :   int ieta, iphi;
<span class="lineNum">    2340 </span><span class="lineNoCov">          0 :   if      (eta &lt;= _tiles_eta_min) {ieta = 0;}</span>
<span class="lineNum">    2341 </span><span class="lineNoCov">          0 :   else if (eta &gt;= _tiles_eta_max) {ieta = _tiles_ieta_max-_tiles_ieta_min;}</span>
<span class="lineNum">    2342 </span>            :   else {
<span class="lineNum">    2343 </span><span class="lineNoCov">          0 :     ieta = int(((eta - _tiles_eta_min) / _tile_size_eta));</span>
<span class="lineNum">    2344 </span><span class="lineNoCov">          0 :     if (ieta &gt; _tiles_ieta_max-_tiles_ieta_min) {</span>
<span class="lineNum">    2345 </span><span class="lineNoCov">          0 :       ieta = _tiles_ieta_max-_tiles_ieta_min;}</span>
<span class="lineNum">    2346 </span>            :   }
<span class="lineNum">    2347 </span><span class="lineNoCov">          0 :   iphi = int((phi+twopi)/_tile_size_phi) % _n_tiles_phi;</span>
<a name="2348"><span class="lineNum">    2348 </span><span class="lineNoCov">          0 :   return (iphi + ieta * _n_tiles_phi);</span></a>
<span class="lineNum">    2349 </span>            : }
<span class="lineNum">    2350 </span>            : inline void ClusterSequence::_tj_set_jetinfo( TiledJet * const jet,
<span class="lineNum">    2351 </span>            :                                               const int _jets_index) {
<span class="lineNum">    2352 </span><span class="lineNoCov">          0 :   _bj_set_jetinfo&lt;&gt;(jet, _jets_index);</span>
<span class="lineNum">    2353 </span><span class="lineNoCov">          0 :   jet-&gt;tile_index = _tile_index(jet-&gt;eta, jet-&gt;phi);</span>
<span class="lineNum">    2354 </span><span class="lineNoCov">          0 :   Tile * tile = &amp;_tiles[jet-&gt;tile_index];</span>
<span class="lineNum">    2355 </span><span class="lineNoCov">          0 :   jet-&gt;previous   = NULL;</span>
<span class="lineNum">    2356 </span><span class="lineNoCov">          0 :   jet-&gt;next       = tile-&gt;head;</span>
<span class="lineNum">    2357 </span><span class="lineNoCov">          0 :   if (jet-&gt;next != NULL) {jet-&gt;next-&gt;previous = jet;}</span>
<a name="2358"><span class="lineNum">    2358 </span><span class="lineNoCov">          0 :   tile-&gt;head      = jet;</span></a>
<span class="lineNum">    2359 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2360 </span>            : void ClusterSequence::_print_tiles(TiledJet * briefjets ) const {
<span class="lineNum">    2361 </span><span class="lineNoCov">          0 :   for (vector&lt;Tile&gt;::const_iterator tile = _tiles.begin();</span>
<span class="lineNum">    2362 </span><span class="lineNoCov">          0 :        tile &lt; _tiles.end(); tile++) {</span>
<span class="lineNum">    2363 </span><span class="lineNoCov">          0 :     cout &lt;&lt; &quot;Tile &quot; &lt;&lt; tile - _tiles.begin()&lt;&lt;&quot; = &quot;;</span>
<span class="lineNum">    2364 </span><span class="lineNoCov">          0 :     vector&lt;int&gt; list;</span>
<span class="lineNum">    2365 </span><span class="lineNoCov">          0 :     for (TiledJet * jetI = tile-&gt;head; jetI != NULL; jetI = jetI-&gt;next) {</span>
<span class="lineNum">    2366 </span><span class="lineNoCov">          0 :       list.push_back(jetI-briefjets);</span>
<span class="lineNum">    2367 </span>            :     }
<span class="lineNum">    2368 </span><span class="lineNoCov">          0 :     sort(list.begin(),list.end());</span>
<span class="lineNum">    2369 </span><span class="lineNoCov">          0 :     for (unsigned int i = 0; i &lt; list.size(); i++) {cout &lt;&lt;&quot; &quot;&lt;&lt;list[i];}</span>
<span class="lineNum">    2370 </span><span class="lineNoCov">          0 :     cout &lt;&lt;&quot;\n&quot;;</span>
<a name="2371"><span class="lineNum">    2371 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    2372 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2373 </span>            : void ClusterSequence::_add_neighbours_to_tile_union(const int tile_index,
<span class="lineNum">    2374 </span>            :                vector&lt;int&gt; &amp; tile_union, int &amp; n_near_tiles) const {
<span class="lineNum">    2375 </span><span class="lineNoCov">          0 :   for (Tile * const * near_tile = _tiles[tile_index].begin_tiles;</span>
<span class="lineNum">    2376 </span><span class="lineNoCov">          0 :        near_tile != _tiles[tile_index].end_tiles; near_tile++){</span>
<span class="lineNum">    2377 </span><span class="lineNoCov">          0 :     tile_union[n_near_tiles] = *near_tile - &amp; _tiles[0];</span>
<span class="lineNum">    2378 </span><span class="lineNoCov">          0 :     n_near_tiles++;</span>
<a name="2379"><span class="lineNum">    2379 </span>            :   }</a>
<span class="lineNum">    2380 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2381 </span>            : inline void ClusterSequence::_add_untagged_neighbours_to_tile_union(
<span class="lineNum">    2382 </span>            :                const int tile_index,
<span class="lineNum">    2383 </span>            :                vector&lt;int&gt; &amp; tile_union, int &amp; n_near_tiles)  {
<span class="lineNum">    2384 </span><span class="lineNoCov">          0 :   for (Tile ** near_tile = _tiles[tile_index].begin_tiles;</span>
<span class="lineNum">    2385 </span><span class="lineNoCov">          0 :        near_tile != _tiles[tile_index].end_tiles; near_tile++){</span>
<span class="lineNum">    2386 </span><span class="lineNoCov">          0 :     if (! (*near_tile)-&gt;tagged) {</span>
<span class="lineNum">    2387 </span><span class="lineNoCov">          0 :       (*near_tile)-&gt;tagged = true;</span>
<span class="lineNum">    2388 </span><span class="lineNoCov">          0 :       tile_union[n_near_tiles] = *near_tile - &amp; _tiles[0];</span>
<span class="lineNum">    2389 </span><span class="lineNoCov">          0 :       n_near_tiles++;</span>
<span class="lineNum">    2390 </span><span class="lineNoCov">          0 :     }</span>
<a name="2391"><span class="lineNum">    2391 </span>            :   }</a>
<span class="lineNum">    2392 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2393 </span>            : void ClusterSequence::_tiled_N2_cluster() {
<span class="lineNum">    2394 </span><span class="lineNoCov">          0 :   _initialise_tiles();</span>
<span class="lineNum">    2395 </span><span class="lineNoCov">          0 :   int n = _jets.size();</span>
<span class="lineNum">    2396 </span><span class="lineNoCov">          0 :   TiledJet * briefjets = new TiledJet[n];</span>
<span class="lineNum">    2397 </span><span class="lineNoCov">          0 :   TiledJet * jetA = briefjets, * jetB;</span>
<span class="lineNum">    2398 </span><span class="lineNoCov">          0 :   TiledJet oldB;</span>
<span class="lineNum">    2399 </span>            :   oldB.tile_index=0; // prevents a gcc warning
<span class="lineNum">    2400 </span><span class="lineNoCov">          0 :   vector&lt;int&gt; tile_union(3*n_tile_neighbours);</span>
<span class="lineNum">    2401 </span><span class="lineNoCov">          0 :   for (int i = 0; i&lt; n; i++) {</span>
<span class="lineNum">    2402 </span><span class="lineNoCov">          0 :     _tj_set_jetinfo(jetA, i);</span>
<span class="lineNum">    2403 </span><span class="lineNoCov">          0 :     jetA++; // move on to next entry of briefjets</span>
<span class="lineNum">    2404 </span>            :   }
<span class="lineNum">    2405 </span><span class="lineNoCov">          0 :   TiledJet * tail = jetA; // a semaphore for the end of briefjets</span>
<span class="lineNum">    2406 </span>            :   TiledJet * head = briefjets; // a nicer way of naming start
<span class="lineNum">    2407 </span><span class="lineNoCov">          0 :   vector&lt;Tile&gt;::const_iterator tile;</span>
<span class="lineNum">    2408 </span><span class="lineNoCov">          0 :   for (tile = _tiles.begin(); tile != _tiles.end(); tile++) {</span>
<span class="lineNum">    2409 </span><span class="lineNoCov">          0 :     for (jetA = tile-&gt;head; jetA != NULL; jetA = jetA-&gt;next) {</span>
<span class="lineNum">    2410 </span><span class="lineNoCov">          0 :       for (jetB = tile-&gt;head; jetB != jetA; jetB = jetB-&gt;next) {</span>
<span class="lineNum">    2411 </span><span class="lineNoCov">          0 :         double dist = _bj_dist(jetA,jetB);</span>
<span class="lineNum">    2412 </span><span class="lineNoCov">          0 :         if (dist &lt; jetA-&gt;NN_dist) {jetA-&gt;NN_dist = dist; jetA-&gt;NN = jetB;}</span>
<span class="lineNum">    2413 </span><span class="lineNoCov">          0 :         if (dist &lt; jetB-&gt;NN_dist) {jetB-&gt;NN_dist = dist; jetB-&gt;NN = jetA;}</span>
<span class="lineNum">    2414 </span>            :       }
<span class="lineNum">    2415 </span>            :     }
<span class="lineNum">    2416 </span><span class="lineNoCov">          0 :     for (Tile ** RTile = tile-&gt;RH_tiles; RTile != tile-&gt;end_tiles; RTile++) {</span>
<span class="lineNum">    2417 </span><span class="lineNoCov">          0 :       for (jetA = tile-&gt;head; jetA != NULL; jetA = jetA-&gt;next) {</span>
<span class="lineNum">    2418 </span><span class="lineNoCov">          0 :         for (jetB = (*RTile)-&gt;head; jetB != NULL; jetB = jetB-&gt;next) {</span>
<span class="lineNum">    2419 </span><span class="lineNoCov">          0 :           double dist = _bj_dist(jetA,jetB);</span>
<span class="lineNum">    2420 </span><span class="lineNoCov">          0 :           if (dist &lt; jetA-&gt;NN_dist) {jetA-&gt;NN_dist = dist; jetA-&gt;NN = jetB;}</span>
<span class="lineNum">    2421 </span><span class="lineNoCov">          0 :           if (dist &lt; jetB-&gt;NN_dist) {jetB-&gt;NN_dist = dist; jetB-&gt;NN = jetA;}</span>
<span class="lineNum">    2422 </span>            :         }
<span class="lineNum">    2423 </span>            :       }
<span class="lineNum">    2424 </span>            :     }
<span class="lineNum">    2425 </span>            :   }
<span class="lineNum">    2426 </span><span class="lineNoCov">          0 :   double * diJ = new double[n];</span>
<span class="lineNum">    2427 </span><span class="lineNoCov">          0 :   jetA = head;</span>
<span class="lineNum">    2428 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; n; i++) {</span>
<span class="lineNum">    2429 </span><span class="lineNoCov">          0 :     diJ[i] = _bj_diJ(jetA);</span>
<span class="lineNum">    2430 </span><span class="lineNoCov">          0 :     jetA++; // have jetA follow i</span>
<span class="lineNum">    2431 </span>            :   }
<span class="lineNum">    2432 </span><span class="lineNoCov">          0 :   int history_location = n-1;</span>
<span class="lineNum">    2433 </span><span class="lineNoCov">          0 :   while (tail != head) {</span>
<span class="lineNum">    2434 </span><span class="lineNoCov">          0 :     double diJ_min = diJ[0];</span>
<span class="lineNum">    2435 </span>            :     int diJ_min_jet = 0;
<span class="lineNum">    2436 </span><span class="lineNoCov">          0 :     for (int i = 1; i &lt; n; i++) {</span>
<span class="lineNum">    2437 </span><span class="lineNoCov">          0 :       if (diJ[i] &lt; diJ_min) {diJ_min_jet = i; diJ_min  = diJ[i];}</span>
<span class="lineNum">    2438 </span>            :     }
<span class="lineNum">    2439 </span><span class="lineNoCov">          0 :     history_location++;</span>
<span class="lineNum">    2440 </span><span class="lineNoCov">          0 :     jetA = &amp; briefjets[diJ_min_jet];</span>
<span class="lineNum">    2441 </span><span class="lineNoCov">          0 :     jetB = jetA-&gt;NN;</span>
<span class="lineNum">    2442 </span><span class="lineNoCov">          0 :     diJ_min *= _invR2;</span>
<span class="lineNum">    2443 </span><span class="lineNoCov">          0 :     if (jetB != NULL) {</span>
<span class="lineNum">    2444 </span><span class="lineNoCov">          0 :       if (jetA &lt; jetB) {std::swap(jetA,jetB);}</span>
<span class="lineNum">    2445 </span><span class="lineNoCov">          0 :       int nn; // new jet index</span>
<span class="lineNum">    2446 </span><span class="lineNoCov">          0 :       _do_ij_recombination_step(jetA-&gt;_jets_index, jetB-&gt;_jets_index, diJ_min, nn);</span>
<span class="lineNum">    2447 </span><span class="lineNoCov">          0 :       _bj_remove_from_tiles(jetA);</span>
<span class="lineNum">    2448 </span><span class="lineNoCov">          0 :       oldB = * jetB;  // take a copy because we will need it...</span>
<span class="lineNum">    2449 </span><span class="lineNoCov">          0 :       _bj_remove_from_tiles(jetB);</span>
<span class="lineNum">    2450 </span><span class="lineNoCov">          0 :       _tj_set_jetinfo(jetB, nn); // also registers the jet in the tiling</span>
<span class="lineNum">    2451 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">    2452 </span><span class="lineNoCov">          0 :       _do_iB_recombination_step(jetA-&gt;_jets_index, diJ_min);</span>
<span class="lineNum">    2453 </span><span class="lineNoCov">          0 :       _bj_remove_from_tiles(jetA);</span>
<span class="lineNum">    2454 </span>            :     }
<span class="lineNum">    2455 </span><span class="lineNoCov">          0 :     int n_near_tiles = 0;</span>
<span class="lineNum">    2456 </span><span class="lineNoCov">          0 :     _add_neighbours_to_tile_union(jetA-&gt;tile_index, tile_union, n_near_tiles);</span>
<span class="lineNum">    2457 </span><span class="lineNoCov">          0 :     if (jetB != NULL) {</span>
<span class="lineNum">    2458 </span>            :       bool sort_it = false;
<span class="lineNum">    2459 </span><span class="lineNoCov">          0 :       if (jetB-&gt;tile_index != jetA-&gt;tile_index) {</span>
<span class="lineNum">    2460 </span>            :         sort_it = true;
<span class="lineNum">    2461 </span><span class="lineNoCov">          0 :         _add_neighbours_to_tile_union(jetB-&gt;tile_index,tile_union,n_near_tiles);</span>
<span class="lineNum">    2462 </span>            :       }
<span class="lineNum">    2463 </span><span class="lineNoCov">          0 :       if (oldB.tile_index != jetA-&gt;tile_index &amp;&amp;</span>
<span class="lineNum">    2464 </span><span class="lineNoCov">          0 :           oldB.tile_index != jetB-&gt;tile_index) {</span>
<span class="lineNum">    2465 </span>            :         sort_it = true;
<span class="lineNum">    2466 </span><span class="lineNoCov">          0 :         _add_neighbours_to_tile_union(oldB.tile_index,tile_union,n_near_tiles);</span>
<span class="lineNum">    2467 </span>            :       }
<span class="lineNum">    2468 </span><span class="lineNoCov">          0 :       if (sort_it) {</span>
<span class="lineNum">    2469 </span>            :         // sort the tiles before then compressing the list
<span class="lineNum">    2470 </span><span class="lineNoCov">          0 :         sort(tile_union.begin(), tile_union.begin()+n_near_tiles);</span>
<span class="lineNum">    2471 </span>            :         // and now condense the list
<span class="lineNum">    2472 </span>            :         int nnn = 1;
<span class="lineNum">    2473 </span><span class="lineNoCov">          0 :         for (int i = 1; i &lt; n_near_tiles; i++) {</span>
<span class="lineNum">    2474 </span><span class="lineNoCov">          0 :           if (tile_union[i] != tile_union[nnn-1]) {</span>
<span class="lineNum">    2475 </span><span class="lineNoCov">          0 :             tile_union[nnn] = tile_union[i];</span>
<span class="lineNum">    2476 </span><span class="lineNoCov">          0 :             nnn++;</span>
<span class="lineNum">    2477 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    2478 </span>            :         }
<span class="lineNum">    2479 </span><span class="lineNoCov">          0 :         n_near_tiles = nnn;</span>
<span class="lineNum">    2480 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    2481 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2482 </span><span class="lineNoCov">          0 :     tail--; n--;</span>
<span class="lineNum">    2483 </span><span class="lineNoCov">          0 :     if (jetA == tail) {</span>
<span class="lineNum">    2484 </span>            :     } else {
<span class="lineNum">    2485 </span><span class="lineNoCov">          0 :       *jetA = *tail;</span>
<span class="lineNum">    2486 </span><span class="lineNoCov">          0 :       diJ[jetA - head] = diJ[tail-head];</span>
<span class="lineNum">    2487 </span><span class="lineNoCov">          0 :       if (jetA-&gt;previous == NULL) {</span>
<span class="lineNum">    2488 </span><span class="lineNoCov">          0 :         _tiles[jetA-&gt;tile_index].head = jetA;</span>
<span class="lineNum">    2489 </span><span class="lineNoCov">          0 :       } else {</span>
<span class="lineNum">    2490 </span><span class="lineNoCov">          0 :         jetA-&gt;previous-&gt;next = jetA;</span>
<span class="lineNum">    2491 </span>            :       }
<span class="lineNum">    2492 </span><span class="lineNoCov">          0 :       if (jetA-&gt;next != NULL) {jetA-&gt;next-&gt;previous = jetA;}</span>
<span class="lineNum">    2493 </span>            :     }
<span class="lineNum">    2494 </span><span class="lineNoCov">          0 :     for (int itile = 0; itile &lt; n_near_tiles; itile++) {</span>
<span class="lineNum">    2495 </span><span class="lineNoCov">          0 :       Tile * tile_ptr = &amp;_tiles[tile_union[itile]];</span>
<span class="lineNum">    2496 </span><span class="lineNoCov">          0 :       for (TiledJet * jetI = tile_ptr-&gt;head; jetI != NULL; jetI = jetI-&gt;next) {</span>
<span class="lineNum">    2497 </span>            :         // see if jetI had jetA or jetB as a NN -- if so recalculate the NN
<span class="lineNum">    2498 </span><span class="lineNoCov">          0 :         if (jetI-&gt;NN == jetA || (jetI-&gt;NN == jetB &amp;&amp; jetB != NULL)) {</span>
<span class="lineNum">    2499 </span><span class="lineNoCov">          0 :           jetI-&gt;NN_dist = _R2;</span>
<span class="lineNum">    2500 </span><span class="lineNoCov">          0 :           jetI-&gt;NN      = NULL;</span>
<span class="lineNum">    2501 </span>            :           // now go over tiles that are neighbours of I (include own tile)
<span class="lineNum">    2502 </span><span class="lineNoCov">          0 :           for (Tile ** near_tile  = tile_ptr-&gt;begin_tiles;</span>
<span class="lineNum">    2503 </span><span class="lineNoCov">          0 :                        near_tile != tile_ptr-&gt;end_tiles; near_tile++) {</span>
<span class="lineNum">    2504 </span>            :             // and then over the contents of that tile
<span class="lineNum">    2505 </span><span class="lineNoCov">          0 :             for (TiledJet * jetJ  = (*near_tile)-&gt;head;</span>
<span class="lineNum">    2506 </span><span class="lineNoCov">          0 :                             jetJ != NULL; jetJ = jetJ-&gt;next) {</span>
<span class="lineNum">    2507 </span><span class="lineNoCov">          0 :               double dist = _bj_dist(jetI,jetJ);</span>
<span class="lineNum">    2508 </span><span class="lineNoCov">          0 :               if (dist &lt; jetI-&gt;NN_dist &amp;&amp; jetJ != jetI) {</span>
<span class="lineNum">    2509 </span><span class="lineNoCov">          0 :                 jetI-&gt;NN_dist = dist; jetI-&gt;NN = jetJ;</span>
<span class="lineNum">    2510 </span><span class="lineNoCov">          0 :               }</span>
<span class="lineNum">    2511 </span>            :             }
<span class="lineNum">    2512 </span>            :           }
<span class="lineNum">    2513 </span><span class="lineNoCov">          0 :           diJ[jetI-head] = _bj_diJ(jetI); // update diJ</span>
<span class="lineNum">    2514 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2515 </span>            :         // check whether new jetB is closer than jetI's current NN and
<span class="lineNum">    2516 </span>            :         // if need to update things
<span class="lineNum">    2517 </span><span class="lineNoCov">          0 :         if (jetB != NULL) {</span>
<span class="lineNum">    2518 </span><span class="lineNoCov">          0 :           double dist = _bj_dist(jetI,jetB);</span>
<span class="lineNum">    2519 </span><span class="lineNoCov">          0 :           if (dist &lt; jetI-&gt;NN_dist) {</span>
<span class="lineNum">    2520 </span><span class="lineNoCov">          0 :             if (jetI != jetB) {</span>
<span class="lineNum">    2521 </span><span class="lineNoCov">          0 :               jetI-&gt;NN_dist = dist;</span>
<span class="lineNum">    2522 </span><span class="lineNoCov">          0 :               jetI-&gt;NN = jetB;</span>
<span class="lineNum">    2523 </span><span class="lineNoCov">          0 :               diJ[jetI-head] = _bj_diJ(jetI); // update diJ...</span>
<span class="lineNum">    2524 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    2525 </span>            :           }
<span class="lineNum">    2526 </span><span class="lineNoCov">          0 :           if (dist &lt; jetB-&gt;NN_dist) {</span>
<span class="lineNum">    2527 </span><span class="lineNoCov">          0 :             if (jetI != jetB) {</span>
<span class="lineNum">    2528 </span><span class="lineNoCov">          0 :               jetB-&gt;NN_dist = dist;</span>
<span class="lineNum">    2529 </span><span class="lineNoCov">          0 :               jetB-&gt;NN      = jetI;}</span>
<span class="lineNum">    2530 </span>            :           }
<span class="lineNum">    2531 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2532 </span>            :       }
<span class="lineNum">    2533 </span>            :     }
<span class="lineNum">    2534 </span><span class="lineNoCov">          0 :     if (jetB != NULL) {diJ[jetB-head] = _bj_diJ(jetB);}</span>
<span class="lineNum">    2535 </span><span class="lineNoCov">          0 :     for (Tile ** near_tile = _tiles[tail-&gt;tile_index].begin_tiles;</span>
<span class="lineNum">    2536 </span><span class="lineNoCov">          0 :                  near_tile!= _tiles[tail-&gt;tile_index].end_tiles; near_tile++){</span>
<span class="lineNum">    2537 </span><span class="lineNoCov">          0 :       for (TiledJet * jetJ = (*near_tile)-&gt;head;</span>
<span class="lineNum">    2538 </span><span class="lineNoCov">          0 :                      jetJ != NULL; jetJ = jetJ-&gt;next) {</span>
<span class="lineNum">    2539 </span><span class="lineNoCov">          0 :         if (jetJ-&gt;NN == tail) {jetJ-&gt;NN = jetA;}</span>
<span class="lineNum">    2540 </span>            :       }
<span class="lineNum">    2541 </span>            :     }
<span class="lineNum">    2542 </span><span class="lineNoCov">          0 :     if (jetB != NULL) {diJ[jetB-head] = _bj_diJ(jetB);}</span>
<span class="lineNum">    2543 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2544 </span><span class="lineNoCov">          0 :   delete[] diJ;</span>
<a name="2545"><span class="lineNum">    2545 </span><span class="lineNoCov">          0 :   delete[] briefjets;</span></a>
<span class="lineNum">    2546 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2547 </span>            : void ClusterSequence::_faster_tiled_N2_cluster() {
<span class="lineNum">    2548 </span><span class="lineNoCov">          0 :   _initialise_tiles();</span>
<span class="lineNum">    2549 </span><span class="lineNoCov">          0 :   int n = _jets.size();</span>
<span class="lineNum">    2550 </span><span class="lineNoCov">          0 :   TiledJet * briefjets = new TiledJet[n];</span>
<span class="lineNum">    2551 </span><span class="lineNoCov">          0 :   TiledJet * jetA = briefjets, * jetB;</span>
<span class="lineNum">    2552 </span><span class="lineNoCov">          0 :   TiledJet oldB;</span>
<span class="lineNum">    2553 </span>            :   oldB.tile_index=0; // prevents a gcc warning
<span class="lineNum">    2554 </span><span class="lineNoCov">          0 :   vector&lt;int&gt; tile_union(3*n_tile_neighbours);</span>
<span class="lineNum">    2555 </span><span class="lineNoCov">          0 :   for (int i = 0; i&lt; n; i++) {</span>
<span class="lineNum">    2556 </span><span class="lineNoCov">          0 :     _tj_set_jetinfo(jetA, i);</span>
<span class="lineNum">    2557 </span><span class="lineNoCov">          0 :     jetA++; // move on to next entry of briefjets</span>
<span class="lineNum">    2558 </span>            :   }
<span class="lineNum">    2559 </span>            :   TiledJet * head = briefjets; // a nicer way of naming start
<span class="lineNum">    2560 </span><span class="lineNoCov">          0 :   vector&lt;Tile&gt;::const_iterator tile;</span>
<span class="lineNum">    2561 </span><span class="lineNoCov">          0 :   for (tile = _tiles.begin(); tile != _tiles.end(); tile++) {</span>
<span class="lineNum">    2562 </span><span class="lineNoCov">          0 :     for (jetA = tile-&gt;head; jetA != NULL; jetA = jetA-&gt;next) {</span>
<span class="lineNum">    2563 </span><span class="lineNoCov">          0 :       for (jetB = tile-&gt;head; jetB != jetA; jetB = jetB-&gt;next) {</span>
<span class="lineNum">    2564 </span><span class="lineNoCov">          0 :         double dist = _bj_dist(jetA,jetB);</span>
<span class="lineNum">    2565 </span><span class="lineNoCov">          0 :         if (dist &lt; jetA-&gt;NN_dist) {jetA-&gt;NN_dist = dist; jetA-&gt;NN = jetB;}</span>
<span class="lineNum">    2566 </span><span class="lineNoCov">          0 :         if (dist &lt; jetB-&gt;NN_dist) {jetB-&gt;NN_dist = dist; jetB-&gt;NN = jetA;}</span>
<span class="lineNum">    2567 </span>            :       }
<span class="lineNum">    2568 </span>            :     }
<span class="lineNum">    2569 </span><span class="lineNoCov">          0 :     for (Tile ** RTile = tile-&gt;RH_tiles; RTile != tile-&gt;end_tiles; RTile++) {</span>
<span class="lineNum">    2570 </span><span class="lineNoCov">          0 :       for (jetA = tile-&gt;head; jetA != NULL; jetA = jetA-&gt;next) {</span>
<span class="lineNum">    2571 </span><span class="lineNoCov">          0 :         for (jetB = (*RTile)-&gt;head; jetB != NULL; jetB = jetB-&gt;next) {</span>
<span class="lineNum">    2572 </span><span class="lineNoCov">          0 :           double dist = _bj_dist(jetA,jetB);</span>
<span class="lineNum">    2573 </span><span class="lineNoCov">          0 :           if (dist &lt; jetA-&gt;NN_dist) {jetA-&gt;NN_dist = dist; jetA-&gt;NN = jetB;}</span>
<span class="lineNum">    2574 </span><span class="lineNoCov">          0 :           if (dist &lt; jetB-&gt;NN_dist) {jetB-&gt;NN_dist = dist; jetB-&gt;NN = jetA;}</span>
<span class="lineNum">    2575 </span>            :         }
<span class="lineNum">    2576 </span>            :       }
<span class="lineNum">    2577 </span>            :     }
<span class="lineNum">    2578 </span>            :   }
<span class="lineNum">    2579 </span>            :   struct diJ_plus_link {
<span class="lineNum">    2580 </span>            :     double     diJ; // the distance
<span class="lineNum">    2581 </span>            :     TiledJet * jet; // the jet (i) for which we've found this distance
<span class="lineNum">    2582 </span>            :   };
<span class="lineNum">    2583 </span><span class="lineNoCov">          0 :   diJ_plus_link * diJ = new diJ_plus_link[n];</span>
<span class="lineNum">    2584 </span><span class="lineNoCov">          0 :   jetA = head;</span>
<span class="lineNum">    2585 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; n; i++) {</span>
<span class="lineNum">    2586 </span><span class="lineNoCov">          0 :     diJ[i].diJ = _bj_diJ(jetA); // kt distance * R^2</span>
<span class="lineNum">    2587 </span><span class="lineNoCov">          0 :     diJ[i].jet = jetA;  // our compact diJ table will not be in</span>
<span class="lineNum">    2588 </span><span class="lineNoCov">          0 :     jetA-&gt;diJ_posn = i; // one-to-one corresp. with non-compact jets,</span>
<span class="lineNum">    2589 </span><span class="lineNoCov">          0 :     jetA++; // have jetA follow i</span>
<span class="lineNum">    2590 </span>            :   }
<span class="lineNum">    2591 </span><span class="lineNoCov">          0 :   int history_location = n-1;</span>
<span class="lineNum">    2592 </span><span class="lineNoCov">          0 :   while (n &gt; 0) {</span>
<span class="lineNum">    2593 </span>            :     diJ_plus_link * best, *stop; // pointers a bit faster than indices
<span class="lineNum">    2594 </span><span class="lineNoCov">          0 :     double diJ_min = diJ[0].diJ; // initialise the best one here.</span>
<span class="lineNum">    2595 </span>            :     best = diJ;                  // and here
<span class="lineNum">    2596 </span><span class="lineNoCov">          0 :     stop = diJ+n;</span>
<span class="lineNum">    2597 </span><span class="lineNoCov">          0 :     for (diJ_plus_link * here = diJ+1; here != stop; here++) {</span>
<span class="lineNum">    2598 </span><span class="lineNoCov">          0 :       if (here-&gt;diJ &lt; diJ_min) {best = here; diJ_min  = here-&gt;diJ;}</span>
<span class="lineNum">    2599 </span>            :     }
<span class="lineNum">    2600 </span><span class="lineNoCov">          0 :     history_location++;</span>
<span class="lineNum">    2601 </span><span class="lineNoCov">          0 :     jetA = best-&gt;jet;</span>
<span class="lineNum">    2602 </span><span class="lineNoCov">          0 :     jetB = jetA-&gt;NN;</span>
<span class="lineNum">    2603 </span><span class="lineNoCov">          0 :     diJ_min *= _invR2;</span>
<span class="lineNum">    2604 </span><span class="lineNoCov">          0 :     if (jetB != NULL) {</span>
<span class="lineNum">    2605 </span><span class="lineNoCov">          0 :       if (jetA &lt; jetB) {std::swap(jetA,jetB);}</span>
<span class="lineNum">    2606 </span><span class="lineNoCov">          0 :       int nn; // new jet index</span>
<span class="lineNum">    2607 </span><span class="lineNoCov">          0 :       _do_ij_recombination_step(jetA-&gt;_jets_index, jetB-&gt;_jets_index, diJ_min, nn);</span>
<span class="lineNum">    2608 </span><span class="lineNoCov">          0 :       _bj_remove_from_tiles(jetA);</span>
<span class="lineNum">    2609 </span><span class="lineNoCov">          0 :       oldB = * jetB;  // take a copy because we will need it...</span>
<span class="lineNum">    2610 </span><span class="lineNoCov">          0 :       _bj_remove_from_tiles(jetB);</span>
<span class="lineNum">    2611 </span><span class="lineNoCov">          0 :       _tj_set_jetinfo(jetB, nn); // cause jetB to become _jets[nn]</span>
<span class="lineNum">    2612 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">    2613 </span><span class="lineNoCov">          0 :       _do_iB_recombination_step(jetA-&gt;_jets_index, diJ_min);</span>
<span class="lineNum">    2614 </span><span class="lineNoCov">          0 :       _bj_remove_from_tiles(jetA);</span>
<span class="lineNum">    2615 </span>            :     }
<span class="lineNum">    2616 </span><span class="lineNoCov">          0 :     int n_near_tiles = 0;</span>
<span class="lineNum">    2617 </span><span class="lineNoCov">          0 :     _add_untagged_neighbours_to_tile_union(jetA-&gt;tile_index,</span>
<span class="lineNum">    2618 </span>            :                                            tile_union, n_near_tiles);
<span class="lineNum">    2619 </span><span class="lineNoCov">          0 :     if (jetB != NULL) {</span>
<span class="lineNum">    2620 </span><span class="lineNoCov">          0 :       if (jetB-&gt;tile_index != jetA-&gt;tile_index) {</span>
<span class="lineNum">    2621 </span><span class="lineNoCov">          0 :         _add_untagged_neighbours_to_tile_union(jetB-&gt;tile_index,</span>
<span class="lineNum">    2622 </span>            :                                                tile_union,n_near_tiles);
<span class="lineNum">    2623 </span>            :       }
<span class="lineNum">    2624 </span><span class="lineNoCov">          0 :       if (oldB.tile_index != jetA-&gt;tile_index &amp;&amp;</span>
<span class="lineNum">    2625 </span><span class="lineNoCov">          0 :           oldB.tile_index != jetB-&gt;tile_index) {</span>
<span class="lineNum">    2626 </span><span class="lineNoCov">          0 :         _add_untagged_neighbours_to_tile_union(oldB.tile_index,</span>
<span class="lineNum">    2627 </span>            :                                                tile_union,n_near_tiles);
<span class="lineNum">    2628 </span>            :       }
<span class="lineNum">    2629 </span>            :     }
<span class="lineNum">    2630 </span><span class="lineNoCov">          0 :     n--;</span>
<span class="lineNum">    2631 </span><span class="lineNoCov">          0 :     diJ[n].jet-&gt;diJ_posn = jetA-&gt;diJ_posn;</span>
<span class="lineNum">    2632 </span><span class="lineNoCov">          0 :     diJ[jetA-&gt;diJ_posn] = diJ[n];</span>
<span class="lineNum">    2633 </span><span class="lineNoCov">          0 :     for (int itile = 0; itile &lt; n_near_tiles; itile++) {</span>
<span class="lineNum">    2634 </span><span class="lineNoCov">          0 :       Tile * tile_ptr = &amp;_tiles[tile_union[itile]];</span>
<span class="lineNum">    2635 </span><span class="lineNoCov">          0 :       tile_ptr-&gt;tagged = false; // reset tag, since we're done with unions</span>
<span class="lineNum">    2636 </span><span class="lineNoCov">          0 :       for (TiledJet * jetI = tile_ptr-&gt;head; jetI != NULL; jetI = jetI-&gt;next) {</span>
<span class="lineNum">    2637 </span>            :         // see if jetI had jetA or jetB as a NN -- if so recalculate the NN
<span class="lineNum">    2638 </span><span class="lineNoCov">          0 :         if (jetI-&gt;NN == jetA || (jetI-&gt;NN == jetB &amp;&amp; jetB != NULL)) {</span>
<span class="lineNum">    2639 </span><span class="lineNoCov">          0 :           jetI-&gt;NN_dist = _R2;</span>
<span class="lineNum">    2640 </span><span class="lineNoCov">          0 :           jetI-&gt;NN      = NULL;</span>
<span class="lineNum">    2641 </span>            :           // now go over tiles that are neighbours of I (include own tile)
<span class="lineNum">    2642 </span><span class="lineNoCov">          0 :           for (Tile ** near_tile  = tile_ptr-&gt;begin_tiles;</span>
<span class="lineNum">    2643 </span><span class="lineNoCov">          0 :                        near_tile != tile_ptr-&gt;end_tiles; near_tile++) {</span>
<span class="lineNum">    2644 </span>            :             // and then over the contents of that tile
<span class="lineNum">    2645 </span><span class="lineNoCov">          0 :             for (TiledJet * jetJ  = (*near_tile)-&gt;head;</span>
<span class="lineNum">    2646 </span><span class="lineNoCov">          0 :                             jetJ != NULL; jetJ = jetJ-&gt;next) {</span>
<span class="lineNum">    2647 </span><span class="lineNoCov">          0 :               double dist = _bj_dist(jetI,jetJ);</span>
<span class="lineNum">    2648 </span><span class="lineNoCov">          0 :               if (dist &lt; jetI-&gt;NN_dist &amp;&amp; jetJ != jetI) {</span>
<span class="lineNum">    2649 </span><span class="lineNoCov">          0 :                 jetI-&gt;NN_dist = dist; jetI-&gt;NN = jetJ;</span>
<span class="lineNum">    2650 </span><span class="lineNoCov">          0 :               }</span>
<span class="lineNum">    2651 </span>            :             }
<span class="lineNum">    2652 </span>            :           }
<span class="lineNum">    2653 </span><span class="lineNoCov">          0 :           diJ[jetI-&gt;diJ_posn].diJ = _bj_diJ(jetI); // update diJ kt-dist</span>
<span class="lineNum">    2654 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2655 </span>            :         // check whether new jetB is closer than jetI's current NN and
<span class="lineNum">    2656 </span>            :         // if jetI is closer than jetB's current (evolving) nearest
<span class="lineNum">    2657 </span>            :         // neighbour. Where relevant update things
<span class="lineNum">    2658 </span><span class="lineNoCov">          0 :         if (jetB != NULL) {</span>
<span class="lineNum">    2659 </span><span class="lineNoCov">          0 :           double dist = _bj_dist(jetI,jetB);</span>
<span class="lineNum">    2660 </span><span class="lineNoCov">          0 :           if (dist &lt; jetI-&gt;NN_dist) {</span>
<span class="lineNum">    2661 </span><span class="lineNoCov">          0 :             if (jetI != jetB) {</span>
<span class="lineNum">    2662 </span><span class="lineNoCov">          0 :               jetI-&gt;NN_dist = dist;</span>
<span class="lineNum">    2663 </span><span class="lineNoCov">          0 :               jetI-&gt;NN = jetB;</span>
<span class="lineNum">    2664 </span><span class="lineNoCov">          0 :               diJ[jetI-&gt;diJ_posn].diJ = _bj_diJ(jetI); // update diJ...</span>
<span class="lineNum">    2665 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    2666 </span>            :           }
<span class="lineNum">    2667 </span><span class="lineNoCov">          0 :           if (dist &lt; jetB-&gt;NN_dist) {</span>
<span class="lineNum">    2668 </span><span class="lineNoCov">          0 :             if (jetI != jetB) {</span>
<span class="lineNum">    2669 </span><span class="lineNoCov">          0 :               jetB-&gt;NN_dist = dist;</span>
<span class="lineNum">    2670 </span><span class="lineNoCov">          0 :               jetB-&gt;NN      = jetI;}</span>
<span class="lineNum">    2671 </span>            :           }
<span class="lineNum">    2672 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2673 </span>            :       }
<span class="lineNum">    2674 </span>            :     }
<span class="lineNum">    2675 </span><span class="lineNoCov">          0 :     if (jetB != NULL) {diJ[jetB-&gt;diJ_posn].diJ = _bj_diJ(jetB);}</span>
<span class="lineNum">    2676 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2677 </span><span class="lineNoCov">          0 :   delete[] diJ;</span>
<a name="2678"><span class="lineNum">    2678 </span><span class="lineNoCov">          0 :   delete[] briefjets;</span></a>
<span class="lineNum">    2679 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2680 </span>            : void ClusterSequence::_minheap_faster_tiled_N2_cluster() {
<span class="lineNum">    2681 </span><span class="lineNoCov">          0 :   _initialise_tiles();</span>
<span class="lineNum">    2682 </span><span class="lineNoCov">          0 :   int n = _jets.size();</span>
<span class="lineNum">    2683 </span><span class="lineNoCov">          0 :   TiledJet * briefjets = new TiledJet[n];</span>
<span class="lineNum">    2684 </span><span class="lineNoCov">          0 :   TiledJet * jetA = briefjets, * jetB;</span>
<span class="lineNum">    2685 </span><span class="lineNoCov">          0 :   TiledJet oldB;</span>
<span class="lineNum">    2686 </span>            :   oldB.tile_index=0; // prevents a gcc warning
<span class="lineNum">    2687 </span><span class="lineNoCov">          0 :   vector&lt;int&gt; tile_union(3*n_tile_neighbours);</span>
<span class="lineNum">    2688 </span><span class="lineNoCov">          0 :   for (int i = 0; i&lt; n; i++) {</span>
<span class="lineNum">    2689 </span><span class="lineNoCov">          0 :     _tj_set_jetinfo(jetA, i);</span>
<span class="lineNum">    2690 </span><span class="lineNoCov">          0 :     jetA++; // move on to next entry of briefjets</span>
<span class="lineNum">    2691 </span>            :   }
<span class="lineNum">    2692 </span>            :   TiledJet * head = briefjets; // a nicer way of naming start
<span class="lineNum">    2693 </span><span class="lineNoCov">          0 :   vector&lt;Tile&gt;::const_iterator tile;</span>
<span class="lineNum">    2694 </span><span class="lineNoCov">          0 :   for (tile = _tiles.begin(); tile != _tiles.end(); tile++) {</span>
<span class="lineNum">    2695 </span><span class="lineNoCov">          0 :     for (jetA = tile-&gt;head; jetA != NULL; jetA = jetA-&gt;next) {</span>
<span class="lineNum">    2696 </span><span class="lineNoCov">          0 :       for (jetB = tile-&gt;head; jetB != jetA; jetB = jetB-&gt;next) {</span>
<span class="lineNum">    2697 </span><span class="lineNoCov">          0 :         double dist = _bj_dist(jetA,jetB);</span>
<span class="lineNum">    2698 </span><span class="lineNoCov">          0 :         if (dist &lt; jetA-&gt;NN_dist) {jetA-&gt;NN_dist = dist; jetA-&gt;NN = jetB;}</span>
<span class="lineNum">    2699 </span><span class="lineNoCov">          0 :         if (dist &lt; jetB-&gt;NN_dist) {jetB-&gt;NN_dist = dist; jetB-&gt;NN = jetA;}</span>
<span class="lineNum">    2700 </span>            :       }
<span class="lineNum">    2701 </span>            :     }
<span class="lineNum">    2702 </span><span class="lineNoCov">          0 :     for (Tile ** RTile = tile-&gt;RH_tiles; RTile != tile-&gt;end_tiles; RTile++) {</span>
<span class="lineNum">    2703 </span><span class="lineNoCov">          0 :       for (jetA = tile-&gt;head; jetA != NULL; jetA = jetA-&gt;next) {</span>
<span class="lineNum">    2704 </span><span class="lineNoCov">          0 :         for (jetB = (*RTile)-&gt;head; jetB != NULL; jetB = jetB-&gt;next) {</span>
<span class="lineNum">    2705 </span><span class="lineNoCov">          0 :           double dist = _bj_dist(jetA,jetB);</span>
<span class="lineNum">    2706 </span><span class="lineNoCov">          0 :           if (dist &lt; jetA-&gt;NN_dist) {jetA-&gt;NN_dist = dist; jetA-&gt;NN = jetB;}</span>
<span class="lineNum">    2707 </span><span class="lineNoCov">          0 :           if (dist &lt; jetB-&gt;NN_dist) {jetB-&gt;NN_dist = dist; jetB-&gt;NN = jetA;}</span>
<span class="lineNum">    2708 </span>            :         }
<span class="lineNum">    2709 </span>            :       }
<span class="lineNum">    2710 </span>            :     }
<span class="lineNum">    2711 </span>            :   }
<span class="lineNum">    2712 </span><span class="lineNoCov">          0 :   vector&lt;double&gt; diJs(n);</span>
<span class="lineNum">    2713 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; n; i++) {</span>
<span class="lineNum">    2714 </span><span class="lineNoCov">          0 :     diJs[i] = _bj_diJ(&amp;briefjets[i]);</span>
<span class="lineNum">    2715 </span><span class="lineNoCov">          0 :     briefjets[i].label_minheap_update_done();</span>
<span class="lineNum">    2716 </span>            :   }
<span class="lineNum">    2717 </span><span class="lineNoCov">          0 :   MinHeap minheap(diJs);</span>
<span class="lineNum">    2718 </span><span class="lineNoCov">          0 :   vector&lt;TiledJet *&gt; jets_for_minheap;</span>
<span class="lineNum">    2719 </span><span class="lineNoCov">          0 :   jets_for_minheap.reserve(n);</span>
<span class="lineNum">    2720 </span><span class="lineNoCov">          0 :   int history_location = n-1;</span>
<span class="lineNum">    2721 </span><span class="lineNoCov">          0 :   while (n &gt; 0) {</span>
<span class="lineNum">    2722 </span><span class="lineNoCov">          0 :     double diJ_min = minheap.minval() *_invR2;</span>
<span class="lineNum">    2723 </span><span class="lineNoCov">          0 :     jetA = head + minheap.minloc();</span>
<span class="lineNum">    2724 </span><span class="lineNoCov">          0 :     history_location++;</span>
<span class="lineNum">    2725 </span><span class="lineNoCov">          0 :     jetB = jetA-&gt;NN;</span>
<span class="lineNum">    2726 </span><span class="lineNoCov">          0 :     if (jetB != NULL) {</span>
<span class="lineNum">    2727 </span><span class="lineNoCov">          0 :       if (jetA &lt; jetB) {std::swap(jetA,jetB);}</span>
<span class="lineNum">    2728 </span><span class="lineNoCov">          0 :       int nn; // new jet index</span>
<span class="lineNum">    2729 </span><span class="lineNoCov">          0 :       _do_ij_recombination_step(jetA-&gt;_jets_index, jetB-&gt;_jets_index, diJ_min, nn);</span>
<span class="lineNum">    2730 </span><span class="lineNoCov">          0 :       _bj_remove_from_tiles(jetA);</span>
<span class="lineNum">    2731 </span><span class="lineNoCov">          0 :       oldB = * jetB;  // take a copy because we will need it...</span>
<span class="lineNum">    2732 </span><span class="lineNoCov">          0 :       _bj_remove_from_tiles(jetB);</span>
<span class="lineNum">    2733 </span><span class="lineNoCov">          0 :       _tj_set_jetinfo(jetB, nn); // cause jetB to become _jets[nn]</span>
<span class="lineNum">    2734 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">    2735 </span><span class="lineNoCov">          0 :       _do_iB_recombination_step(jetA-&gt;_jets_index, diJ_min);</span>
<span class="lineNum">    2736 </span><span class="lineNoCov">          0 :       _bj_remove_from_tiles(jetA);</span>
<span class="lineNum">    2737 </span>            :     }
<span class="lineNum">    2738 </span><span class="lineNoCov">          0 :     minheap.remove(jetA-head);</span>
<span class="lineNum">    2739 </span><span class="lineNoCov">          0 :     int n_near_tiles = 0;</span>
<span class="lineNum">    2740 </span><span class="lineNoCov">          0 :     _add_untagged_neighbours_to_tile_union(jetA-&gt;tile_index,</span>
<span class="lineNum">    2741 </span>            :                                            tile_union, n_near_tiles);
<span class="lineNum">    2742 </span><span class="lineNoCov">          0 :     if (jetB != NULL) {</span>
<span class="lineNum">    2743 </span><span class="lineNoCov">          0 :       if (jetB-&gt;tile_index != jetA-&gt;tile_index) {</span>
<span class="lineNum">    2744 </span><span class="lineNoCov">          0 :         _add_untagged_neighbours_to_tile_union(jetB-&gt;tile_index,</span>
<span class="lineNum">    2745 </span>            :                                                tile_union,n_near_tiles);
<span class="lineNum">    2746 </span>            :       }
<span class="lineNum">    2747 </span><span class="lineNoCov">          0 :       if (oldB.tile_index != jetA-&gt;tile_index &amp;&amp;</span>
<span class="lineNum">    2748 </span><span class="lineNoCov">          0 :           oldB.tile_index != jetB-&gt;tile_index) {</span>
<span class="lineNum">    2749 </span>            :         // GS: the line below generates a warning that oldB.tile_index
<span class="lineNum">    2750 </span>            :         // may be used uninitialised. However, to reach this point, we
<span class="lineNum">    2751 </span>            :         // ned jetB != NULL (see test a few lines above) and is jetB
<span class="lineNum">    2752 </span>            :         // !=NULL, one would have gone through &quot;oldB = *jetB before
<span class="lineNum">    2753 </span>            :         // (see piece of code ~20 line above), so the index is
<span class="lineNum">    2754 </span>            :         // initialised. We do not do anything to avoid the warning to
<span class="lineNum">    2755 </span>            :         // avoid any potential speed impact.
<span class="lineNum">    2756 </span><span class="lineNoCov">          0 :         _add_untagged_neighbours_to_tile_union(oldB.tile_index,</span>
<span class="lineNum">    2757 </span>            :                                                tile_union,n_near_tiles);
<span class="lineNum">    2758 </span>            :       }
<span class="lineNum">    2759 </span><span class="lineNoCov">          0 :       jetB-&gt;label_minheap_update_needed();</span>
<span class="lineNum">    2760 </span><span class="lineNoCov">          0 :       jets_for_minheap.push_back(jetB);</span>
<span class="lineNum">    2761 </span>            :     }
<span class="lineNum">    2762 </span><span class="lineNoCov">          0 :     for (int itile = 0; itile &lt; n_near_tiles; itile++) {</span>
<span class="lineNum">    2763 </span><span class="lineNoCov">          0 :       Tile * tile_ptr = &amp;_tiles[tile_union[itile]];</span>
<span class="lineNum">    2764 </span><span class="lineNoCov">          0 :       tile_ptr-&gt;tagged = false; // reset tag, since we're done with unions</span>
<span class="lineNum">    2765 </span><span class="lineNoCov">          0 :       for (TiledJet * jetI = tile_ptr-&gt;head; jetI != NULL; jetI = jetI-&gt;next) {</span>
<span class="lineNum">    2766 </span>            :         // see if jetI had jetA or jetB as a NN -- if so recalculate the NN
<span class="lineNum">    2767 </span><span class="lineNoCov">          0 :         if (jetI-&gt;NN == jetA || (jetI-&gt;NN == jetB &amp;&amp; jetB != NULL)) {</span>
<span class="lineNum">    2768 </span><span class="lineNoCov">          0 :           jetI-&gt;NN_dist = _R2;</span>
<span class="lineNum">    2769 </span><span class="lineNoCov">          0 :           jetI-&gt;NN      = NULL;</span>
<span class="lineNum">    2770 </span>            :           // label jetI as needing heap action...
<span class="lineNum">    2771 </span><span class="lineNoCov">          0 :           if (!jetI-&gt;minheap_update_needed()) {</span>
<span class="lineNum">    2772 </span><span class="lineNoCov">          0 :             jetI-&gt;label_minheap_update_needed();</span>
<span class="lineNum">    2773 </span><span class="lineNoCov">          0 :             jets_for_minheap.push_back(jetI);}</span>
<span class="lineNum">    2774 </span>            :           // now go over tiles that are neighbours of I (include own tile)
<span class="lineNum">    2775 </span><span class="lineNoCov">          0 :           for (Tile ** near_tile  = tile_ptr-&gt;begin_tiles;</span>
<span class="lineNum">    2776 </span><span class="lineNoCov">          0 :                        near_tile != tile_ptr-&gt;end_tiles; near_tile++) {</span>
<span class="lineNum">    2777 </span>            :             // and then over the contents of that tile
<span class="lineNum">    2778 </span><span class="lineNoCov">          0 :             for (TiledJet * jetJ  = (*near_tile)-&gt;head;</span>
<span class="lineNum">    2779 </span><span class="lineNoCov">          0 :                             jetJ != NULL; jetJ = jetJ-&gt;next) {</span>
<span class="lineNum">    2780 </span><span class="lineNoCov">          0 :               double dist = _bj_dist(jetI,jetJ);</span>
<span class="lineNum">    2781 </span><span class="lineNoCov">          0 :               if (dist &lt; jetI-&gt;NN_dist &amp;&amp; jetJ != jetI) {</span>
<span class="lineNum">    2782 </span><span class="lineNoCov">          0 :                 jetI-&gt;NN_dist = dist; jetI-&gt;NN = jetJ;</span>
<span class="lineNum">    2783 </span><span class="lineNoCov">          0 :               }</span>
<span class="lineNum">    2784 </span>            :             }
<span class="lineNum">    2785 </span>            :           }
<span class="lineNum">    2786 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2787 </span>            :         // check whether new jetB is closer than jetI's current NN and
<span class="lineNum">    2788 </span>            :         // if jetI is closer than jetB's current (evolving) nearest
<span class="lineNum">    2789 </span>            :         // neighbour. Where relevant update things
<span class="lineNum">    2790 </span><span class="lineNoCov">          0 :         if (jetB != NULL) {</span>
<span class="lineNum">    2791 </span><span class="lineNoCov">          0 :           double dist = _bj_dist(jetI,jetB);</span>
<span class="lineNum">    2792 </span><span class="lineNoCov">          0 :           if (dist &lt; jetI-&gt;NN_dist) {</span>
<span class="lineNum">    2793 </span><span class="lineNoCov">          0 :             if (jetI != jetB) {</span>
<span class="lineNum">    2794 </span><span class="lineNoCov">          0 :               jetI-&gt;NN_dist = dist;</span>
<span class="lineNum">    2795 </span><span class="lineNoCov">          0 :               jetI-&gt;NN = jetB;</span>
<span class="lineNum">    2796 </span>            :               // label jetI as needing heap action...
<span class="lineNum">    2797 </span><span class="lineNoCov">          0 :               if (!jetI-&gt;minheap_update_needed()) {</span>
<span class="lineNum">    2798 </span><span class="lineNoCov">          0 :                 jetI-&gt;label_minheap_update_needed();</span>
<span class="lineNum">    2799 </span><span class="lineNoCov">          0 :                 jets_for_minheap.push_back(jetI);}</span>
<span class="lineNum">    2800 </span>            :             }
<span class="lineNum">    2801 </span>            :           }
<span class="lineNum">    2802 </span><span class="lineNoCov">          0 :           if (dist &lt; jetB-&gt;NN_dist) {</span>
<span class="lineNum">    2803 </span><span class="lineNoCov">          0 :             if (jetI != jetB) {</span>
<span class="lineNum">    2804 </span><span class="lineNoCov">          0 :               jetB-&gt;NN_dist = dist;</span>
<span class="lineNum">    2805 </span><span class="lineNoCov">          0 :               jetB-&gt;NN      = jetI;}</span>
<span class="lineNum">    2806 </span>            :           }
<span class="lineNum">    2807 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2808 </span>            :       }
<span class="lineNum">    2809 </span>            :     }
<span class="lineNum">    2810 </span><span class="lineNoCov">          0 :     while (jets_for_minheap.size() &gt; 0) {</span>
<span class="lineNum">    2811 </span><span class="lineNoCov">          0 :       TiledJet * jetI = jets_for_minheap.back();</span>
<span class="lineNum">    2812 </span><span class="lineNoCov">          0 :       jets_for_minheap.pop_back();</span>
<span class="lineNum">    2813 </span><span class="lineNoCov">          0 :       minheap.update(jetI-head, _bj_diJ(jetI));</span>
<span class="lineNum">    2814 </span><span class="lineNoCov">          0 :       jetI-&gt;label_minheap_update_done();</span>
<span class="lineNum">    2815 </span>            :     }
<span class="lineNum">    2816 </span><span class="lineNoCov">          0 :     n--;</span>
<span class="lineNum">    2817 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2818 </span><span class="lineNoCov">          0 :   delete[] briefjets;</span>
<span class="lineNum">    2819 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2820 </span>            : FJCORE_END_NAMESPACE
<a name="2821"><span class="lineNum">    2821 </span>            : FJCORE_BEGIN_NAMESPACE      // defined in fastjet/internal/base.hh</a>
<span class="lineNum">    2822 </span>            : using namespace std;
<span class="lineNum">    2823 </span><span class="lineNoCov">          0 : CompositeJetStructure::CompositeJetStructure(const std::vector&lt;PseudoJet&gt; &amp; initial_pieces,</span>
<span class="lineNum">    2824 </span>            :                                              const JetDefinition::Recombiner * recombiner)
<span class="lineNum">    2825 </span><span class="lineNoCov">          0 :   : _pieces(initial_pieces){</span>
<span class="lineNum">    2826 </span>            :   if (recombiner){};  // ugly trick to prevent a gcc warning
<a name="2827"><span class="lineNum">    2827 </span><span class="lineNoCov">          0 :   _area_4vector_ptr = 0;</span></a>
<span class="lineNum">    2828 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2829 </span>            : std::string CompositeJetStructure::description() const{
<span class="lineNum">    2830 </span><span class="lineNoCov">          0 :   string str = &quot;Composite PseudoJet&quot;;</span>
<a name="2831"><span class="lineNum">    2831 </span>            :   return str;</a>
<span class="lineNum">    2832 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2833 </span>            : bool CompositeJetStructure::has_constituents() const{
<a name="2834"><span class="lineNum">    2834 </span><span class="lineNoCov">          0 :   return _pieces.size()!=0;</span></a>
<span class="lineNum">    2835 </span>            : }
<span class="lineNum">    2836 </span>            : std::vector&lt;PseudoJet&gt; CompositeJetStructure::constituents(const PseudoJet &amp; /*jet*/) const{
<span class="lineNum">    2837 </span><span class="lineNoCov">          0 :   vector&lt;PseudoJet&gt; all_constituents;</span>
<span class="lineNum">    2838 </span><span class="lineNoCov">          0 :   for (unsigned i = 0; i &lt; _pieces.size(); i++) {</span>
<span class="lineNum">    2839 </span><span class="lineNoCov">          0 :     if (_pieces[i].has_constituents()){</span>
<span class="lineNum">    2840 </span><span class="lineNoCov">          0 :       vector&lt;PseudoJet&gt; constits = _pieces[i].constituents();</span>
<span class="lineNum">    2841 </span><span class="lineNoCov">          0 :       copy(constits.begin(), constits.end(), back_inserter(all_constituents));</span>
<span class="lineNum">    2842 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">    2843 </span><span class="lineNoCov">          0 :       all_constituents.push_back(_pieces[i]);</span>
<span class="lineNum">    2844 </span>            :     }
<span class="lineNum">    2845 </span>            :   }
<a name="2846"><span class="lineNum">    2846 </span>            :   return all_constituents;</a>
<span class="lineNum">    2847 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2848 </span>            : std::vector&lt;PseudoJet&gt; CompositeJetStructure::pieces(const PseudoJet &amp; /*jet*/) const{
<span class="lineNum">    2849 </span><span class="lineNoCov">          0 :   return _pieces;</span>
<span class="lineNum">    2850 </span>            : }
<span class="lineNum">    2851 </span>            : FJCORE_END_NAMESPACE      // defined in fastjet/internal/base.hh
<span class="lineNum">    2852 </span>            : #include &lt;sstream&gt;
<span class="lineNum">    2853 </span>            : #ifdef FJCORE_HAVE_EXECINFO_H
<span class="lineNum">    2854 </span>            : #include &lt;execinfo.h&gt;
<span class="lineNum">    2855 </span>            : #include &lt;cstdlib&gt;
<span class="lineNum">    2856 </span>            : #endif
<span class="lineNum">    2857 </span>            : FJCORE_BEGIN_NAMESPACE      // defined in fastjet/internal/base.hh
<span class="lineNum">    2858 </span>            : using namespace std;
<span class="lineNum">    2859 </span>            : bool Error::_print_errors = true;
<a name="2860"><span class="lineNum">    2860 </span>            : bool Error::_print_backtrace = false;</a>
<span class="lineNum">    2861 </span>            : ostream * Error::_default_ostr = &amp; cerr;
<span class="lineNum">    2862 </span><span class="lineNoCov">          0 : Error::Error(const std::string &amp; message_in) {</span>
<span class="lineNum">    2863 </span><span class="lineNoCov">          0 :   _message = message_in;</span>
<span class="lineNum">    2864 </span><span class="lineNoCov">          0 :   if (_print_errors &amp;&amp; _default_ostr){</span>
<span class="lineNum">    2865 </span><span class="lineNoCov">          0 :     ostringstream oss;</span>
<span class="lineNum">    2866 </span><span class="lineNoCov">          0 :     oss &lt;&lt; &quot;fjcore::Error:  &quot;&lt;&lt; message_in &lt;&lt; endl;</span>
<span class="lineNum">    2867 </span>            : #ifdef FJCORE_HAVE_EXECINFO_H
<span class="lineNum">    2868 </span><span class="lineNoCov">          0 :     if (_print_backtrace){</span>
<span class="lineNum">    2869 </span><span class="lineNoCov">          0 :       void * array[10];</span>
<span class="lineNum">    2870 </span>            :       char ** messages;
<span class="lineNum">    2871 </span><span class="lineNoCov">          0 :       int size = backtrace(array, 10);</span>
<span class="lineNum">    2872 </span><span class="lineNoCov">          0 :       messages = backtrace_symbols(array, size);</span>
<span class="lineNum">    2873 </span><span class="lineNoCov">          0 :       oss &lt;&lt; &quot;stack:&quot; &lt;&lt; endl;</span>
<span class="lineNum">    2874 </span><span class="lineNoCov">          0 :       for (int i = 1; i &lt; size &amp;&amp; messages != NULL; ++i){</span>
<span class="lineNum">    2875 </span><span class="lineNoCov">          0 :         oss &lt;&lt; &quot;  #&quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; messages[i] &lt;&lt; endl;</span>
<span class="lineNum">    2876 </span>            :       }
<span class="lineNum">    2877 </span><span class="lineNoCov">          0 :       free(messages);</span>
<span class="lineNum">    2878 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2879 </span>            : #endif
<span class="lineNum">    2880 </span><span class="lineNoCov">          0 :     *_default_ostr &lt;&lt; oss.str();</span>
<span class="lineNum">    2881 </span><span class="lineNoCov">          0 :     _default_ostr-&gt;flush();</span>
<span class="lineNum">    2882 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2883 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2884 </span>            : FJCORE_END_NAMESPACE
<span class="lineNum">    2885 </span>            : #include &lt;string&gt;
<span class="lineNum">    2886 </span>            : #include &lt;sstream&gt;
<span class="lineNum">    2887 </span>            : using namespace std;
<span class="lineNum">    2888 </span>            : FJCORE_BEGIN_NAMESPACE
<span class="lineNum">    2889 </span>            : FJCORE_END_NAMESPACE
<span class="lineNum">    2890 </span>            : #include&lt;sstream&gt;
<span class="lineNum">    2891 </span>            : FJCORE_BEGIN_NAMESPACE      // defined in fastjet/internal/base.hh
<a name="2892"><span class="lineNum">    2892 </span>            : using namespace std;</a>
<span class="lineNum">    2893 </span>            : const double JetDefinition::max_allowable_R = 1000.0;
<span class="lineNum">    2894 </span><span class="lineNoCov">          0 : JetDefinition::JetDefinition(JetAlgorithm jet_algorithm_in,</span>
<span class="lineNum">    2895 </span>            :                              double R_in,
<span class="lineNum">    2896 </span>            :                              Strategy strategy_in,
<span class="lineNum">    2897 </span>            :                              RecombinationScheme recomb_scheme_in,
<span class="lineNum">    2898 </span>            :                              int nparameters) :
<span class="lineNum">    2899 </span><span class="lineNoCov">          0 :   _jet_algorithm(jet_algorithm_in), _Rparam(R_in), _strategy(strategy_in) {</span>
<span class="lineNum">    2900 </span><span class="lineNoCov">          0 :   if (_jet_algorithm == ee_kt_algorithm) {</span>
<span class="lineNum">    2901 </span><span class="lineNoCov">          0 :     _Rparam = 4.0; // introduce a fictional R that ensures that</span>
<span class="lineNum">    2902 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">    2903 </span><span class="lineNoCov">          0 :     if (R_in &gt; max_allowable_R) {</span>
<span class="lineNum">    2904 </span><span class="lineNoCov">          0 :       ostringstream oss;</span>
<span class="lineNum">    2905 </span><span class="lineNoCov">          0 :       oss &lt;&lt; &quot;Requested R = &quot; &lt;&lt; R_in &lt;&lt; &quot; for jet definition is larger than max_allowable_R = &quot; &lt;&lt; max_allowable_R;</span>
<span class="lineNum">    2906 </span><span class="lineNoCov">          0 :       throw Error(oss.str());</span>
<span class="lineNum">    2907 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2908 </span>            :   }
<span class="lineNum">    2909 </span><span class="lineNoCov">          0 :   switch (jet_algorithm_in) {</span>
<span class="lineNum">    2910 </span>            :   case ee_kt_algorithm:
<span class="lineNum">    2911 </span><span class="lineNoCov">          0 :     if (nparameters != 0) {</span>
<span class="lineNum">    2912 </span><span class="lineNoCov">          0 :       ostringstream oss;</span>
<span class="lineNum">    2913 </span><span class="lineNoCov">          0 :       oss &lt;&lt; &quot;ee_kt_algorithm should be constructed with 0 parameters but was called with &quot;</span>
<span class="lineNum">    2914 </span><span class="lineNoCov">          0 :           &lt;&lt; nparameters &lt;&lt; &quot; parameter(s)\n&quot;;</span>
<span class="lineNum">    2915 </span><span class="lineNoCov">          0 :       throw Error(oss.str());</span>
<span class="lineNum">    2916 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2917 </span>            :     break;
<span class="lineNum">    2918 </span>            :   case genkt_algorithm:
<span class="lineNum">    2919 </span>            :   case ee_genkt_algorithm:
<span class="lineNum">    2920 </span><span class="lineNoCov">          0 :     if (nparameters != 2) {</span>
<span class="lineNum">    2921 </span><span class="lineNoCov">          0 :       ostringstream oss;</span>
<span class="lineNum">    2922 </span><span class="lineNoCov">          0 :       oss &lt;&lt; &quot;(ee_)genkt_algorithm should be constructed with 2 parameters but was called with &quot;</span>
<span class="lineNum">    2923 </span><span class="lineNoCov">          0 :           &lt;&lt; nparameters &lt;&lt; &quot; parameter(s)\n&quot;;</span>
<span class="lineNum">    2924 </span><span class="lineNoCov">          0 :       throw Error(oss.str());</span>
<span class="lineNum">    2925 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2926 </span>            :     break;
<span class="lineNum">    2927 </span>            :   default:
<span class="lineNum">    2928 </span><span class="lineNoCov">          0 :     if (nparameters != 1) {</span>
<span class="lineNum">    2929 </span><span class="lineNoCov">          0 :       ostringstream oss;</span>
<span class="lineNum">    2930 </span><span class="lineNoCov">          0 :       oss &lt;&lt; &quot;The jet algorithm you requested (&quot;</span>
<span class="lineNum">    2931 </span><span class="lineNoCov">          0 :           &lt;&lt; jet_algorithm_in &lt;&lt; &quot;) should be constructed with 1 parameter but was called with &quot;</span>
<span class="lineNum">    2932 </span><span class="lineNoCov">          0 :           &lt;&lt; nparameters &lt;&lt; &quot; parameter(s)\n&quot;;</span>
<span class="lineNum">    2933 </span><span class="lineNoCov">          0 :       throw Error(oss.str());</span>
<span class="lineNum">    2934 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2935 </span>            :   }
<span class="lineNum">    2936 </span><span class="lineNoCov">          0 :   assert (_strategy  != plugin_strategy);</span>
<span class="lineNum">    2937 </span><span class="lineNoCov">          0 :   _plugin = NULL;</span>
<span class="lineNum">    2938 </span><span class="lineNoCov">          0 :   set_recombination_scheme(recomb_scheme_in);</span>
<a name="2939"><span class="lineNum">    2939 </span><span class="lineNoCov">          0 :   set_extra_param(0.0); // make sure it's defined</span></a>
<span class="lineNum">    2940 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2941 </span>            : string JetDefinition::description() const {
<span class="lineNum">    2942 </span><span class="lineNoCov">          0 :   ostringstream name;</span>
<span class="lineNum">    2943 </span><span class="lineNoCov">          0 :   if (jet_algorithm() == plugin_algorithm) {</span>
<span class="lineNum">    2944 </span><span class="lineNoCov">          0 :     return plugin()-&gt;description();</span>
<span class="lineNum">    2945 </span><span class="lineNoCov">          0 :   } else if (jet_algorithm() == kt_algorithm) {</span>
<span class="lineNum">    2946 </span><span class="lineNoCov">          0 :     name &lt;&lt; &quot;Longitudinally invariant kt algorithm with R = &quot; &lt;&lt; R();</span>
<span class="lineNum">    2947 </span><span class="lineNoCov">          0 :     name &lt;&lt; &quot; and &quot; &lt;&lt; recombiner()-&gt;description();</span>
<span class="lineNum">    2948 </span><span class="lineNoCov">          0 :   } else if (jet_algorithm() == cambridge_algorithm) {</span>
<span class="lineNum">    2949 </span><span class="lineNoCov">          0 :     name &lt;&lt; &quot;Longitudinally invariant Cambridge/Aachen algorithm with R = &quot;</span>
<span class="lineNum">    2950 </span><span class="lineNoCov">          0 :          &lt;&lt; R() ;</span>
<span class="lineNum">    2951 </span><span class="lineNoCov">          0 :     name &lt;&lt; &quot; and &quot; &lt;&lt; recombiner()-&gt;description();</span>
<span class="lineNum">    2952 </span><span class="lineNoCov">          0 :   } else if (jet_algorithm() == antikt_algorithm) {</span>
<span class="lineNum">    2953 </span><span class="lineNoCov">          0 :     name &lt;&lt; &quot;Longitudinally invariant anti-kt algorithm with R = &quot;</span>
<span class="lineNum">    2954 </span><span class="lineNoCov">          0 :          &lt;&lt; R() ;</span>
<span class="lineNum">    2955 </span><span class="lineNoCov">          0 :     name &lt;&lt; &quot; and &quot; &lt;&lt; recombiner()-&gt;description();</span>
<span class="lineNum">    2956 </span><span class="lineNoCov">          0 :   } else if (jet_algorithm() == genkt_algorithm) {</span>
<span class="lineNum">    2957 </span><span class="lineNoCov">          0 :     name &lt;&lt; &quot;Longitudinally invariant generalised kt algorithm with R = &quot;</span>
<span class="lineNum">    2958 </span><span class="lineNoCov">          0 :          &lt;&lt; R() &lt;&lt; &quot;, p = &quot; &lt;&lt; extra_param();</span>
<span class="lineNum">    2959 </span><span class="lineNoCov">          0 :     name &lt;&lt; &quot; and &quot; &lt;&lt; recombiner()-&gt;description();</span>
<span class="lineNum">    2960 </span><span class="lineNoCov">          0 :   } else if (jet_algorithm() == cambridge_for_passive_algorithm) {</span>
<span class="lineNum">    2961 </span><span class="lineNoCov">          0 :     name &lt;&lt; &quot;Longitudinally invariant Cambridge/Aachen algorithm with R = &quot;</span>
<span class="lineNum">    2962 </span><span class="lineNoCov">          0 :          &lt;&lt; R() &lt;&lt; &quot;and a special hack whereby particles with kt &lt; &quot;</span>
<span class="lineNum">    2963 </span><span class="lineNoCov">          0 :          &lt;&lt; extra_param() &lt;&lt; &quot;are treated as passive ghosts&quot;;</span>
<span class="lineNum">    2964 </span><span class="lineNoCov">          0 :   } else if (jet_algorithm() == ee_kt_algorithm) {</span>
<span class="lineNum">    2965 </span><span class="lineNoCov">          0 :     name &lt;&lt; &quot;e+e- kt (Durham) algorithm (NB: no R)&quot;;</span>
<span class="lineNum">    2966 </span><span class="lineNoCov">          0 :     name &lt;&lt; &quot; with &quot; &lt;&lt; recombiner()-&gt;description();</span>
<span class="lineNum">    2967 </span><span class="lineNoCov">          0 :   } else if (jet_algorithm() == ee_genkt_algorithm) {</span>
<span class="lineNum">    2968 </span><span class="lineNoCov">          0 :     name &lt;&lt; &quot;e+e- generalised kt algorithm with R = &quot;</span>
<span class="lineNum">    2969 </span><span class="lineNoCov">          0 :          &lt;&lt; R() &lt;&lt; &quot;, p = &quot; &lt;&lt; extra_param();</span>
<span class="lineNum">    2970 </span><span class="lineNoCov">          0 :     name &lt;&lt; &quot; and &quot; &lt;&lt; recombiner()-&gt;description();</span>
<span class="lineNum">    2971 </span><span class="lineNoCov">          0 :   } else if (jet_algorithm() == undefined_jet_algorithm) {</span>
<span class="lineNum">    2972 </span><span class="lineNoCov">          0 :     name &lt;&lt; &quot;uninitialised JetDefinition (jet_algorithm=undefined_jet_algorithm)&quot; ;</span>
<span class="lineNum">    2973 </span>            :   } else {
<span class="lineNum">    2974 </span><span class="lineNoCov">          0 :     throw Error(&quot;JetDefinition::description(): unrecognized jet_algorithm&quot;);</span>
<span class="lineNum">    2975 </span>            :   }
<a name="2976"><span class="lineNum">    2976 </span><span class="lineNoCov">          0 :   return name.str();</span></a>
<span class="lineNum">    2977 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2978 </span>            : void JetDefinition::set_recombination_scheme(
<span class="lineNum">    2979 </span>            :                                RecombinationScheme recomb_scheme) {
<span class="lineNum">    2980 </span><span class="lineNoCov">          0 :   _default_recombiner = JetDefinition::DefaultRecombiner(recomb_scheme);</span>
<span class="lineNum">    2981 </span><span class="lineNoCov">          0 :   if (_recombiner_shared()) _recombiner_shared.reset();</span>
<a name="2982"><span class="lineNum">    2982 </span><span class="lineNoCov">          0 :   _recombiner = 0;</span></a>
<span class="lineNum">    2983 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2984 </span>            : bool JetDefinition::has_same_recombiner(const JetDefinition &amp;other_jd) const{
<span class="lineNum">    2985 </span><span class="lineNoCov">          0 :   const RecombinationScheme &amp; scheme = recombination_scheme();</span>
<span class="lineNum">    2986 </span><span class="lineNoCov">          0 :   if (other_jd.recombination_scheme() != scheme) return false;</span>
<span class="lineNum">    2987 </span><span class="lineNoCov">          0 :   return (scheme != external_scheme)</span>
<a name="2988"><span class="lineNum">    2988 </span><span class="lineNoCov">          0 :     || (recombiner() == other_jd.recombiner());</span></a>
<span class="lineNum">    2989 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2990 </span>            : void JetDefinition::delete_recombiner_when_unused(){
<span class="lineNum">    2991 </span><span class="lineNoCov">          0 :   if (_recombiner == 0){</span>
<span class="lineNum">    2992 </span><span class="lineNoCov">          0 :     throw Error(&quot;tried to call JetDefinition::delete_recombiner_when_unused() for a JetDefinition without a user-defined recombination scheme&quot;);</span>
<span class="lineNum">    2993 </span>            :   }
<a name="2994"><span class="lineNum">    2994 </span><span class="lineNoCov">          0 :   _recombiner_shared.reset(_recombiner);</span></a>
<span class="lineNum">    2995 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2996 </span>            : void JetDefinition::delete_plugin_when_unused(){
<span class="lineNum">    2997 </span><span class="lineNoCov">          0 :   if (_plugin == 0){</span>
<span class="lineNum">    2998 </span><span class="lineNoCov">          0 :     throw Error(&quot;tried to call JetDefinition::delete_plugin_when_unused() for a JetDefinition without a plugin&quot;);</span>
<span class="lineNum">    2999 </span>            :   }
<a name="3000"><span class="lineNum">    3000 </span><span class="lineNoCov">          0 :   _plugin_shared.reset(_plugin);</span></a>
<span class="lineNum">    3001 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3002 </span>            : string JetDefinition::DefaultRecombiner::description() const {
<span class="lineNum">    3003 </span><span class="lineNoCov">          0 :   switch(_recomb_scheme) {</span>
<span class="lineNum">    3004 </span>            :   case E_scheme:
<span class="lineNum">    3005 </span><span class="lineNoCov">          0 :     return &quot;E scheme recombination&quot;;</span>
<span class="lineNum">    3006 </span>            :   case pt_scheme:
<span class="lineNum">    3007 </span><span class="lineNoCov">          0 :     return &quot;pt scheme recombination&quot;;</span>
<span class="lineNum">    3008 </span>            :   case pt2_scheme:
<span class="lineNum">    3009 </span><span class="lineNoCov">          0 :     return &quot;pt2 scheme recombination&quot;;</span>
<span class="lineNum">    3010 </span>            :   case Et_scheme:
<span class="lineNum">    3011 </span><span class="lineNoCov">          0 :     return &quot;Et scheme recombination&quot;;</span>
<span class="lineNum">    3012 </span>            :   case Et2_scheme:
<span class="lineNum">    3013 </span><span class="lineNoCov">          0 :     return &quot;Et2 scheme recombination&quot;;</span>
<span class="lineNum">    3014 </span>            :   case BIpt_scheme:
<span class="lineNum">    3015 </span><span class="lineNoCov">          0 :     return &quot;boost-invariant pt scheme recombination&quot;;</span>
<span class="lineNum">    3016 </span>            :   case BIpt2_scheme:
<span class="lineNum">    3017 </span><span class="lineNoCov">          0 :     return &quot;boost-invariant pt2 scheme recombination&quot;;</span>
<span class="lineNum">    3018 </span>            :   default:
<span class="lineNum">    3019 </span><span class="lineNoCov">          0 :     ostringstream err;</span>
<span class="lineNum">    3020 </span><span class="lineNoCov">          0 :     err &lt;&lt; &quot;DefaultRecombiner: unrecognized recombination scheme &quot;</span>
<span class="lineNum">    3021 </span><span class="lineNoCov">          0 :         &lt;&lt; _recomb_scheme;</span>
<span class="lineNum">    3022 </span><span class="lineNoCov">          0 :     throw Error(err.str());</span>
<a name="3023"><span class="lineNum">    3023 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    3024 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3025 </span>            : void JetDefinition::DefaultRecombiner::recombine(
<span class="lineNum">    3026 </span>            :            const PseudoJet &amp; pa, const PseudoJet &amp; pb,
<span class="lineNum">    3027 </span>            :            PseudoJet &amp; pab) const {
<span class="lineNum">    3028 </span>            :   double weighta, weightb;
<span class="lineNum">    3029 </span><span class="lineNoCov">          0 :   switch(_recomb_scheme) {</span>
<span class="lineNum">    3030 </span>            :   case E_scheme:
<span class="lineNum">    3031 </span><span class="lineNoCov">          0 :     pab.reset(pa.px()+pb.px(),</span>
<span class="lineNum">    3032 </span><span class="lineNoCov">          0 :               pa.py()+pb.py(),</span>
<span class="lineNum">    3033 </span><span class="lineNoCov">          0 :               pa.pz()+pb.pz(),</span>
<span class="lineNum">    3034 </span><span class="lineNoCov">          0 :               pa.E ()+pb.E ());</span>
<span class="lineNum">    3035 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    3036 </span>            :   case pt_scheme:
<span class="lineNum">    3037 </span>            :   case Et_scheme:
<span class="lineNum">    3038 </span>            :   case BIpt_scheme:
<span class="lineNum">    3039 </span><span class="lineNoCov">          0 :     weighta = pa.perp();</span>
<span class="lineNum">    3040 </span><span class="lineNoCov">          0 :     weightb = pb.perp();</span>
<span class="lineNum">    3041 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    3042 </span>            :   case pt2_scheme:
<span class="lineNum">    3043 </span>            :   case Et2_scheme:
<span class="lineNum">    3044 </span>            :   case BIpt2_scheme:
<span class="lineNum">    3045 </span><span class="lineNoCov">          0 :     weighta = pa.perp2();</span>
<span class="lineNum">    3046 </span><span class="lineNoCov">          0 :     weightb = pb.perp2();</span>
<span class="lineNum">    3047 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    3048 </span>            :   default:
<span class="lineNum">    3049 </span><span class="lineNoCov">          0 :     ostringstream err;</span>
<span class="lineNum">    3050 </span><span class="lineNoCov">          0 :     err &lt;&lt; &quot;DefaultRecombiner: unrecognized recombination scheme &quot;</span>
<span class="lineNum">    3051 </span><span class="lineNoCov">          0 :         &lt;&lt; _recomb_scheme;</span>
<span class="lineNum">    3052 </span><span class="lineNoCov">          0 :     throw Error(err.str());</span>
<span class="lineNum">    3053 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3054 </span><span class="lineNoCov">          0 :   double perp_ab = pa.perp() + pb.perp();</span>
<span class="lineNum">    3055 </span><span class="lineNoCov">          0 :   if (perp_ab != 0.0) { // weights also non-zero...</span>
<span class="lineNum">    3056 </span><span class="lineNoCov">          0 :     double y_ab    = (weighta * pa.rap() + weightb * pb.rap())/(weighta+weightb);</span>
<span class="lineNum">    3057 </span><span class="lineNoCov">          0 :     double phi_a = pa.phi(), phi_b = pb.phi();</span>
<span class="lineNum">    3058 </span><span class="lineNoCov">          0 :     if (phi_a - phi_b &gt; pi)  phi_b += twopi;</span>
<span class="lineNum">    3059 </span><span class="lineNoCov">          0 :     if (phi_a - phi_b &lt; -pi) phi_b -= twopi;</span>
<span class="lineNum">    3060 </span><span class="lineNoCov">          0 :     double phi_ab = (weighta * phi_a + weightb * phi_b)/(weighta+weightb);</span>
<span class="lineNum">    3061 </span><span class="lineNoCov">          0 :     pab.reset_PtYPhiM(perp_ab,y_ab,phi_ab);</span>
<span class="lineNum">    3062 </span><span class="lineNoCov">          0 :   } else { // weights are zero</span>
<span class="lineNum">    3063 </span><span class="lineNoCov">          0 :     pab.reset(0.0, 0.0, 0.0, 0.0);</span>
<a name="3064"><span class="lineNum">    3064 </span>            :   }</a>
<span class="lineNum">    3065 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3066 </span>            : void JetDefinition::DefaultRecombiner::preprocess(PseudoJet &amp; p) const {
<span class="lineNum">    3067 </span><span class="lineNoCov">          0 :   switch(_recomb_scheme) {</span>
<span class="lineNum">    3068 </span>            :   case E_scheme:
<span class="lineNum">    3069 </span>            :   case BIpt_scheme:
<span class="lineNum">    3070 </span>            :   case BIpt2_scheme:
<span class="lineNum">    3071 </span>            :     break;
<span class="lineNum">    3072 </span>            :   case pt_scheme:
<span class="lineNum">    3073 </span>            :   case pt2_scheme:
<span class="lineNum">    3074 </span>            :     {
<span class="lineNum">    3075 </span><span class="lineNoCov">          0 :       double newE = sqrt(p.perp2()+p.pz()*p.pz());</span>
<span class="lineNum">    3076 </span><span class="lineNoCov">          0 :       p.reset_momentum(p.px(), p.py(), p.pz(), newE);</span>
<span class="lineNum">    3077 </span>            :     }
<span class="lineNum">    3078 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    3079 </span>            :   case Et_scheme:
<span class="lineNum">    3080 </span>            :   case Et2_scheme:
<span class="lineNum">    3081 </span>            :     {
<span class="lineNum">    3082 </span><span class="lineNoCov">          0 :       double rescale = p.E()/sqrt(p.perp2()+p.pz()*p.pz());</span>
<span class="lineNum">    3083 </span><span class="lineNoCov">          0 :       p.reset_momentum(rescale*p.px(), rescale*p.py(), rescale*p.pz(), p.E());</span>
<span class="lineNum">    3084 </span>            :     }
<span class="lineNum">    3085 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    3086 </span>            :   default:
<span class="lineNum">    3087 </span><span class="lineNoCov">          0 :     ostringstream err;</span>
<span class="lineNum">    3088 </span><span class="lineNoCov">          0 :     err &lt;&lt; &quot;DefaultRecombiner: unrecognized recombination scheme &quot;</span>
<span class="lineNum">    3089 </span><span class="lineNoCov">          0 :         &lt;&lt; _recomb_scheme;</span>
<span class="lineNum">    3090 </span><span class="lineNoCov">          0 :     throw Error(err.str());</span>
<a name="3091"><span class="lineNum">    3091 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    3092 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3093 </span>            : void JetDefinition::Plugin::set_ghost_separation_scale(double /*scale*/) const {
<a name="3094"><span class="lineNum">    3094 </span><span class="lineNoCov">          0 :   throw Error(&quot;set_ghost_separation_scale not supported&quot;);</span></a>
<span class="lineNum">    3095 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3096 </span>            : PseudoJet join(const vector&lt;PseudoJet&gt; &amp; pieces, const JetDefinition::Recombiner &amp; recombiner){
<span class="lineNum">    3097 </span><span class="lineNoCov">          0 :   PseudoJet result;  // automatically initialised to 0</span>
<span class="lineNum">    3098 </span><span class="lineNoCov">          0 :   if (pieces.size()&gt;0){</span>
<span class="lineNum">    3099 </span><span class="lineNoCov">          0 :     result = pieces[0];</span>
<span class="lineNum">    3100 </span><span class="lineNoCov">          0 :     for (unsigned int i=1; i&lt;pieces.size(); i++)</span>
<span class="lineNum">    3101 </span><span class="lineNoCov">          0 :       recombiner.plus_equal(result, pieces[i]);</span>
<span class="lineNum">    3102 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3103 </span><span class="lineNoCov">          0 :   CompositeJetStructure *cj_struct = new CompositeJetStructure(pieces, &amp;recombiner);</span>
<span class="lineNum">    3104 </span><span class="lineNoCov">          0 :   result.set_structure_shared_ptr(SharedPtr&lt;PseudoJetStructureBase&gt;(cj_struct));</span>
<a name="3105"><span class="lineNum">    3105 </span>            :   return result;</a>
<span class="lineNum">    3106 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3107 </span>            : PseudoJet join(const PseudoJet &amp; j1,
<span class="lineNum">    3108 </span>            :                const JetDefinition::Recombiner &amp; recombiner){
<a name="3109"><span class="lineNum">    3109 </span><span class="lineNoCov">          0 :   return join(vector&lt;PseudoJet&gt;(1,j1), recombiner);</span></a>
<span class="lineNum">    3110 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3111 </span>            : PseudoJet join(const PseudoJet &amp; j1, const PseudoJet &amp; j2,
<span class="lineNum">    3112 </span>            :                const JetDefinition::Recombiner &amp; recombiner){
<span class="lineNum">    3113 </span><span class="lineNoCov">          0 :   vector&lt;PseudoJet&gt; pieces;</span>
<span class="lineNum">    3114 </span><span class="lineNoCov">          0 :   pieces.push_back(j1);</span>
<span class="lineNum">    3115 </span><span class="lineNoCov">          0 :   pieces.push_back(j2);</span>
<a name="3116"><span class="lineNum">    3116 </span><span class="lineNoCov">          0 :   return join(pieces, recombiner);</span></a>
<span class="lineNum">    3117 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3118 </span>            : PseudoJet join(const PseudoJet &amp; j1, const PseudoJet &amp; j2, const PseudoJet &amp; j3,
<span class="lineNum">    3119 </span>            :                const JetDefinition::Recombiner &amp; recombiner){
<span class="lineNum">    3120 </span><span class="lineNoCov">          0 :   vector&lt;PseudoJet&gt; pieces;</span>
<span class="lineNum">    3121 </span><span class="lineNoCov">          0 :   pieces.push_back(j1);</span>
<span class="lineNum">    3122 </span><span class="lineNoCov">          0 :   pieces.push_back(j2);</span>
<span class="lineNum">    3123 </span><span class="lineNoCov">          0 :   pieces.push_back(j3);</span>
<a name="3124"><span class="lineNum">    3124 </span><span class="lineNoCov">          0 :   return join(pieces, recombiner);</span></a>
<span class="lineNum">    3125 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3126 </span>            : PseudoJet join(const PseudoJet &amp; j1, const PseudoJet &amp; j2, const PseudoJet &amp; j3, const PseudoJet &amp; j4,
<span class="lineNum">    3127 </span>            :                const JetDefinition::Recombiner &amp; recombiner){
<span class="lineNum">    3128 </span><span class="lineNoCov">          0 :   vector&lt;PseudoJet&gt; pieces;</span>
<span class="lineNum">    3129 </span><span class="lineNoCov">          0 :   pieces.push_back(j1);</span>
<span class="lineNum">    3130 </span><span class="lineNoCov">          0 :   pieces.push_back(j2);</span>
<span class="lineNum">    3131 </span><span class="lineNoCov">          0 :   pieces.push_back(j3);</span>
<span class="lineNum">    3132 </span><span class="lineNoCov">          0 :   pieces.push_back(j4);</span>
<span class="lineNum">    3133 </span><span class="lineNoCov">          0 :   return join(pieces, recombiner);</span>
<span class="lineNum">    3134 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3135 </span>            : FJCORE_END_NAMESPACE
<span class="lineNum">    3136 </span>            : #include &lt;sstream&gt;
<span class="lineNum">    3137 </span>            : #include &lt;limits&gt;
<span class="lineNum">    3138 </span>            : using namespace std;
<a name="3139"><span class="lineNum">    3139 </span>            : FJCORE_BEGIN_NAMESPACE</a>
<span class="lineNum">    3140 </span>            : ostream * LimitedWarning::_default_ostr = &amp;cerr;
<a name="3141"><span class="lineNum">    3141 </span><span class="lineCov">          6 : std::list&lt; LimitedWarning::Summary &gt; LimitedWarning::_global_warnings_summary;</span></a>
<span class="lineNum">    3142 </span>            : int LimitedWarning::_max_warn_default = 5;
<span class="lineNum">    3143 </span>            : void LimitedWarning::warn(const std::string &amp; warning) {
<a name="3144"><span class="lineNum">    3144 </span><span class="lineNoCov">          0 :   warn(warning, _default_ostr);</span></a>
<span class="lineNum">    3145 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3146 </span>            : void LimitedWarning::warn(const std::string &amp; warning, std::ostream * ostr) {
<span class="lineNum">    3147 </span><span class="lineNoCov">          0 :   if (_this_warning_summary == 0) {</span>
<span class="lineNum">    3148 </span><span class="lineNoCov">          0 :     _global_warnings_summary.push_back(Summary(warning, 0));</span>
<span class="lineNum">    3149 </span><span class="lineNoCov">          0 :     _this_warning_summary = &amp; (_global_warnings_summary.back());</span>
<span class="lineNum">    3150 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3151 </span><span class="lineNoCov">          0 :   if (_n_warn_so_far &lt; _max_warn) {</span>
<span class="lineNum">    3152 </span><span class="lineNoCov">          0 :     ostringstream warnstr;</span>
<span class="lineNum">    3153 </span><span class="lineNoCov">          0 :     warnstr &lt;&lt; &quot;WARNING: &quot;;</span>
<span class="lineNum">    3154 </span><span class="lineNoCov">          0 :     warnstr &lt;&lt; warning;</span>
<span class="lineNum">    3155 </span><span class="lineNoCov">          0 :     _n_warn_so_far++;</span>
<span class="lineNum">    3156 </span><span class="lineNoCov">          0 :     if (_n_warn_so_far == _max_warn) warnstr &lt;&lt; &quot; (LAST SUCH WARNING)&quot;;</span>
<span class="lineNum">    3157 </span><span class="lineNoCov">          0 :     warnstr &lt;&lt; std::endl;</span>
<span class="lineNum">    3158 </span><span class="lineNoCov">          0 :     if (ostr) {</span>
<span class="lineNum">    3159 </span><span class="lineNoCov">          0 :       (*ostr) &lt;&lt; warnstr.str();</span>
<span class="lineNum">    3160 </span><span class="lineNoCov">          0 :       ostr-&gt;flush(); // get something written to file even if the program aborts</span>
<span class="lineNum">    3161 </span>            :     }
<span class="lineNum">    3162 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3163 </span><span class="lineNoCov">          0 :   if (_this_warning_summary-&gt;second &lt; numeric_limits&lt;unsigned&gt;::max()) {</span>
<span class="lineNum">    3164 </span><span class="lineNoCov">          0 :     _this_warning_summary-&gt;second++;</span>
<a name="3165"><span class="lineNum">    3165 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    3166 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3167 </span>            : string LimitedWarning::summary() {
<span class="lineNum">    3168 </span><span class="lineNoCov">          0 :   ostringstream str;</span>
<span class="lineNum">    3169 </span><span class="lineNoCov">          0 :   for (list&lt;Summary&gt;::const_iterator it = _global_warnings_summary.begin();</span>
<span class="lineNum">    3170 </span><span class="lineNoCov">          0 :        it != _global_warnings_summary.end(); it++) {</span>
<span class="lineNum">    3171 </span><span class="lineNoCov">          0 :     str &lt;&lt; it-&gt;second &lt;&lt; &quot; times: &quot; &lt;&lt; it-&gt;first &lt;&lt; endl;</span>
<span class="lineNum">    3172 </span>            :   }
<span class="lineNum">    3173 </span><span class="lineNoCov">          0 :   return str.str();</span>
<span class="lineNum">    3174 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3175 </span>            : FJCORE_END_NAMESPACE
<span class="lineNum">    3176 </span>            : #include&lt;iostream&gt;
<span class="lineNum">    3177 </span>            : #include&lt;cmath&gt;
<span class="lineNum">    3178 </span>            : #include&lt;limits&gt;
<a name="3179"><span class="lineNum">    3179 </span>            : FJCORE_BEGIN_NAMESPACE      // defined in fastjet/internal/base.hh</a>
<span class="lineNum">    3180 </span>            : using namespace std;
<span class="lineNum">    3181 </span>            : void MinHeap::_initialise(const std::vector&lt;double&gt; &amp; values){
<span class="lineNum">    3182 </span><span class="lineNoCov">          0 :   for (unsigned i = values.size(); i &lt; _heap.size(); i++) {</span>
<span class="lineNum">    3183 </span><span class="lineNoCov">          0 :     _heap[i].value = std::numeric_limits&lt;double&gt;::max();</span>
<span class="lineNum">    3184 </span><span class="lineNoCov">          0 :     _heap[i].minloc = &amp;(_heap[i]);</span>
<span class="lineNum">    3185 </span>            :   }
<span class="lineNum">    3186 </span><span class="lineNoCov">          0 :   for (unsigned i = 0; i &lt; values.size(); i++) {</span>
<span class="lineNum">    3187 </span><span class="lineNoCov">          0 :     _heap[i].value = values[i];</span>
<span class="lineNum">    3188 </span><span class="lineNoCov">          0 :     _heap[i].minloc = &amp;(_heap[i]);</span>
<span class="lineNum">    3189 </span>            :   }
<span class="lineNum">    3190 </span><span class="lineNoCov">          0 :   for (unsigned i = _heap.size()-1; i &gt; 0; i--) {</span>
<span class="lineNum">    3191 </span><span class="lineNoCov">          0 :     ValueLoc * parent = &amp;(_heap[(i-1)/2]);</span>
<span class="lineNum">    3192 </span><span class="lineNoCov">          0 :     ValueLoc * here   = &amp;(_heap[i]);</span>
<span class="lineNum">    3193 </span><span class="lineNoCov">          0 :     if (here-&gt;minloc-&gt;value &lt; parent-&gt;minloc-&gt;value) {</span>
<span class="lineNum">    3194 </span><span class="lineNoCov">          0 :       parent-&gt;minloc = here-&gt;minloc;</span>
<span class="lineNum">    3195 </span><span class="lineNoCov">          0 :     }</span>
<a name="3196"><span class="lineNum">    3196 </span>            :   }</a>
<span class="lineNum">    3197 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3198 </span>            : void MinHeap::update(unsigned int loc, double new_value) {
<span class="lineNum">    3199 </span><span class="lineNoCov">          0 :   assert(loc &lt; _heap.size());</span>
<span class="lineNum">    3200 </span><span class="lineNoCov">          0 :   ValueLoc * start = &amp;(_heap[loc]);</span>
<span class="lineNum">    3201 </span><span class="lineNoCov">          0 :   if (start-&gt;minloc != start &amp;&amp; !(new_value &lt; start-&gt;minloc-&gt;value)) {</span>
<span class="lineNum">    3202 </span><span class="lineNoCov">          0 :     start-&gt;value = new_value;</span>
<span class="lineNum">    3203 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    3204 </span>            :   }
<span class="lineNum">    3205 </span><span class="lineNoCov">          0 :   start-&gt;value = new_value;</span>
<span class="lineNum">    3206 </span><span class="lineNoCov">          0 :   start-&gt;minloc = start;</span>
<span class="lineNum">    3207 </span>            :   bool change_made = true;
<span class="lineNum">    3208 </span><span class="lineNoCov">          0 :   ValueLoc * heap_end = (&amp;(_heap[0])) + _heap.size();</span>
<span class="lineNum">    3209 </span><span class="lineNoCov">          0 :   while(change_made) {</span>
<span class="lineNum">    3210 </span><span class="lineNoCov">          0 :     ValueLoc * here = &amp;(_heap[loc]);</span>
<span class="lineNum">    3211 </span>            :     change_made     = false;
<span class="lineNum">    3212 </span><span class="lineNoCov">          0 :     if (here-&gt;minloc == start) {</span>
<span class="lineNum">    3213 </span><span class="lineNoCov">          0 :       here-&gt;minloc = here; change_made = true;</span>
<span class="lineNum">    3214 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    3215 </span><span class="lineNoCov">          0 :     ValueLoc * child = &amp;(_heap[2*loc+1]);</span>
<span class="lineNum">    3216 </span><span class="lineNoCov">          0 :     if (child &lt; heap_end &amp;&amp; child-&gt;minloc-&gt;value &lt; here-&gt;minloc-&gt;value ) {</span>
<span class="lineNum">    3217 </span><span class="lineNoCov">          0 :       here-&gt;minloc = child-&gt;minloc;</span>
<span class="lineNum">    3218 </span><span class="lineNoCov">          0 :       change_made = true;}</span>
<span class="lineNum">    3219 </span><span class="lineNoCov">          0 :     child++;</span>
<span class="lineNum">    3220 </span><span class="lineNoCov">          0 :     if (child &lt; heap_end &amp;&amp; child-&gt;minloc-&gt;value &lt; here-&gt;minloc-&gt;value ) {</span>
<span class="lineNum">    3221 </span><span class="lineNoCov">          0 :       here-&gt;minloc = child-&gt;minloc;</span>
<span class="lineNum">    3222 </span><span class="lineNoCov">          0 :       change_made = true;}</span>
<span class="lineNum">    3223 </span><span class="lineNoCov">          0 :     if (loc == 0) {break;}</span>
<span class="lineNum">    3224 </span><span class="lineNoCov">          0 :     loc = (loc-1)/2;</span>
<span class="lineNum">    3225 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3226 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3227 </span>            : FJCORE_END_NAMESPACE
<span class="lineNum">    3228 </span>            : #include&lt;valarray&gt;
<span class="lineNum">    3229 </span>            : #include&lt;iostream&gt;
<span class="lineNum">    3230 </span>            : #include&lt;sstream&gt;
<span class="lineNum">    3231 </span>            : #include&lt;cmath&gt;
<span class="lineNum">    3232 </span>            : #include&lt;algorithm&gt;
<span class="lineNum">    3233 </span>            : #include &lt;cstdarg&gt;
<a name="3234"><span class="lineNum">    3234 </span>            : FJCORE_BEGIN_NAMESPACE      // defined in fastjet/internal/base.hh</a>
<span class="lineNum">    3235 </span>            : using namespace std;
<span class="lineNum">    3236 </span><span class="lineNoCov">          0 : PseudoJet::PseudoJet(const double px_in, const double py_in, const double pz_in, const double E_in) {</span>
<span class="lineNum">    3237 </span><span class="lineNoCov">          0 :   _E  = E_in ;</span>
<span class="lineNum">    3238 </span><span class="lineNoCov">          0 :   _px = px_in;</span>
<span class="lineNum">    3239 </span><span class="lineNoCov">          0 :   _py = py_in;</span>
<span class="lineNum">    3240 </span><span class="lineNoCov">          0 :   _pz = pz_in;</span>
<span class="lineNum">    3241 </span><span class="lineNoCov">          0 :   this-&gt;_finish_init();</span>
<a name="3242"><span class="lineNum">    3242 </span><span class="lineNoCov">          0 :   _reset_indices();</span></a>
<span class="lineNum">    3243 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3244 </span>            : void PseudoJet::_finish_init () {
<span class="lineNum">    3245 </span><span class="lineNoCov">          0 :   _kt2 = this-&gt;px()*this-&gt;px() + this-&gt;py()*this-&gt;py();</span>
<span class="lineNum">    3246 </span><span class="lineNoCov">          0 :   _phi = pseudojet_invalid_phi;</span>
<a name="3247"><span class="lineNum">    3247 </span><span class="lineNoCov">          0 :   _rap = pseudojet_invalid_rap;</span></a>
<span class="lineNum">    3248 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3249 </span>            : void PseudoJet::_set_rap_phi() const {
<span class="lineNum">    3250 </span><span class="lineNoCov">          0 :   if (_kt2 == 0.0) {</span>
<span class="lineNum">    3251 </span><span class="lineNoCov">          0 :     _phi = 0.0; }</span>
<span class="lineNum">    3252 </span>            :   else {
<span class="lineNum">    3253 </span><span class="lineNoCov">          0 :     _phi = atan2(this-&gt;py(),this-&gt;px());</span>
<span class="lineNum">    3254 </span>            :   }
<span class="lineNum">    3255 </span><span class="lineNoCov">          0 :   if (_phi &lt; 0.0) {_phi += twopi;}</span>
<span class="lineNum">    3256 </span><span class="lineNoCov">          0 :   if (_phi &gt;= twopi) {_phi -= twopi;} // can happen if phi=-|eps&lt;1e-15|?</span>
<span class="lineNum">    3257 </span><span class="lineNoCov">          0 :   if (this-&gt;E() == abs(this-&gt;pz()) &amp;&amp; _kt2 == 0) {</span>
<span class="lineNum">    3258 </span><span class="lineNoCov">          0 :     double MaxRapHere = MaxRap + abs(this-&gt;pz());</span>
<span class="lineNum">    3259 </span><span class="lineNoCov">          0 :     if (this-&gt;pz() &gt;= 0.0) {_rap = MaxRapHere;} else {_rap = -MaxRapHere;}</span>
<span class="lineNum">    3260 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">    3261 </span><span class="lineNoCov">          0 :     double effective_m2 = max(0.0,m2()); // force non tachyonic mass</span>
<span class="lineNum">    3262 </span><span class="lineNoCov">          0 :     double E_plus_pz    = _E + abs(_pz); // the safer of p+, p-</span>
<span class="lineNum">    3263 </span><span class="lineNoCov">          0 :     _rap = 0.5*log((_kt2 + effective_m2)/(E_plus_pz*E_plus_pz));</span>
<span class="lineNum">    3264 </span><span class="lineNoCov">          0 :     if (_pz &gt; 0) {_rap = - _rap;}</span>
<a name="3265"><span class="lineNum">    3265 </span>            :   }</a>
<span class="lineNum">    3266 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3267 </span>            : valarray&lt;double&gt; PseudoJet::four_mom() const {
<span class="lineNum">    3268 </span><span class="lineNoCov">          0 :   valarray&lt;double&gt; mom(4);</span>
<span class="lineNum">    3269 </span><span class="lineNoCov">          0 :   mom[0] = _px;</span>
<span class="lineNum">    3270 </span><span class="lineNoCov">          0 :   mom[1] = _py;</span>
<span class="lineNum">    3271 </span><span class="lineNoCov">          0 :   mom[2] = _pz;</span>
<span class="lineNum">    3272 </span><span class="lineNoCov">          0 :   mom[3] = _E ;</span>
<a name="3273"><span class="lineNum">    3273 </span>            :   return mom;</a>
<span class="lineNum">    3274 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3275 </span>            : double PseudoJet::operator () (int i) const {
<span class="lineNum">    3276 </span><span class="lineNoCov">          0 :   switch(i) {</span>
<span class="lineNum">    3277 </span>            :   case X:
<span class="lineNum">    3278 </span><span class="lineNoCov">          0 :     return px();</span>
<span class="lineNum">    3279 </span>            :   case Y:
<span class="lineNum">    3280 </span><span class="lineNoCov">          0 :     return py();</span>
<span class="lineNum">    3281 </span>            :   case Z:
<span class="lineNum">    3282 </span><span class="lineNoCov">          0 :     return pz();</span>
<span class="lineNum">    3283 </span>            :   case T:
<span class="lineNum">    3284 </span><span class="lineNoCov">          0 :     return e();</span>
<span class="lineNum">    3285 </span>            :   default:
<span class="lineNum">    3286 </span><span class="lineNoCov">          0 :     ostringstream err;</span>
<span class="lineNum">    3287 </span><span class="lineNoCov">          0 :     err &lt;&lt; &quot;PseudoJet subscripting: bad index (&quot; &lt;&lt; i &lt;&lt; &quot;)&quot;;</span>
<span class="lineNum">    3288 </span><span class="lineNoCov">          0 :     throw Error(err.str());</span>
<span class="lineNum">    3289 </span><span class="lineNoCov">          0 :   }</span>
<a name="3290"><span class="lineNum">    3290 </span>            :   return 0.;</a>
<span class="lineNum">    3291 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3292 </span>            : double PseudoJet::pseudorapidity() const {
<span class="lineNum">    3293 </span><span class="lineNoCov">          0 :   if (px() == 0.0 &amp;&amp; py() ==0.0) return MaxRap;</span>
<span class="lineNum">    3294 </span><span class="lineNoCov">          0 :   if (pz() == 0.0) return 0.0;</span>
<span class="lineNum">    3295 </span><span class="lineNoCov">          0 :   double theta = atan(perp()/pz());</span>
<span class="lineNum">    3296 </span><span class="lineNoCov">          0 :   if (theta &lt; 0) theta += pi;</span>
<a name="3297"><span class="lineNum">    3297 </span><span class="lineNoCov">          0 :   return -log(tan(theta/2));</span></a>
<span class="lineNum">    3298 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3299 </span>            : PseudoJet operator+ (const PseudoJet &amp; jet1, const PseudoJet &amp; jet2) {
<span class="lineNum">    3300 </span><span class="lineNoCov">          0 :   return PseudoJet(jet1.px()+jet2.px(),</span>
<span class="lineNum">    3301 </span><span class="lineNoCov">          0 :                    jet1.py()+jet2.py(),</span>
<span class="lineNum">    3302 </span><span class="lineNoCov">          0 :                    jet1.pz()+jet2.pz(),</span>
<a name="3303"><span class="lineNum">    3303 </span><span class="lineNoCov">          0 :                    jet1.E() +jet2.E()  );</span></a>
<span class="lineNum">    3304 </span>            : }
<span class="lineNum">    3305 </span>            : PseudoJet operator- (const PseudoJet &amp; jet1, const PseudoJet &amp; jet2) {
<span class="lineNum">    3306 </span><span class="lineNoCov">          0 :   return PseudoJet(jet1.px()-jet2.px(),</span>
<span class="lineNum">    3307 </span><span class="lineNoCov">          0 :                    jet1.py()-jet2.py(),</span>
<span class="lineNum">    3308 </span><span class="lineNoCov">          0 :                    jet1.pz()-jet2.pz(),</span>
<a name="3309"><span class="lineNum">    3309 </span><span class="lineNoCov">          0 :                    jet1.E() -jet2.E()  );</span></a>
<span class="lineNum">    3310 </span>            : }
<span class="lineNum">    3311 </span>            : PseudoJet operator* (double coeff, const PseudoJet &amp; jet) {
<span class="lineNum">    3312 </span><span class="lineNoCov">          0 :   PseudoJet coeff_times_jet(jet);</span>
<span class="lineNum">    3313 </span><span class="lineNoCov">          0 :   coeff_times_jet *= coeff;</span>
<a name="3314"><span class="lineNum">    3314 </span>            :   return coeff_times_jet;</a>
<span class="lineNum">    3315 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3316 </span>            : PseudoJet operator* (const PseudoJet &amp; jet, double coeff) {
<a name="3317"><span class="lineNum">    3317 </span><span class="lineNoCov">          0 :   return coeff*jet;</span></a>
<span class="lineNum">    3318 </span>            : }
<span class="lineNum">    3319 </span>            : PseudoJet operator/ (const PseudoJet &amp; jet, double coeff) {
<a name="3320"><span class="lineNum">    3320 </span><span class="lineNoCov">          0 :   return (1.0/coeff)*jet;</span></a>
<span class="lineNum">    3321 </span>            : }
<span class="lineNum">    3322 </span>            : void PseudoJet::operator*=(double coeff) {
<span class="lineNum">    3323 </span><span class="lineNoCov">          0 :   _px *= coeff;</span>
<span class="lineNum">    3324 </span><span class="lineNoCov">          0 :   _py *= coeff;</span>
<span class="lineNum">    3325 </span><span class="lineNoCov">          0 :   _pz *= coeff;</span>
<span class="lineNum">    3326 </span><span class="lineNoCov">          0 :   _E  *= coeff;</span>
<a name="3327"><span class="lineNum">    3327 </span><span class="lineNoCov">          0 :   _kt2*= coeff*coeff;</span></a>
<span class="lineNum">    3328 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3329 </span>            : void PseudoJet::operator/=(double coeff) {
<a name="3330"><span class="lineNum">    3330 </span><span class="lineNoCov">          0 :   (*this) *= 1.0/coeff;</span></a>
<span class="lineNum">    3331 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3332 </span>            : void PseudoJet::operator+=(const PseudoJet &amp; other_jet) {
<span class="lineNum">    3333 </span><span class="lineNoCov">          0 :   _px += other_jet._px;</span>
<span class="lineNum">    3334 </span><span class="lineNoCov">          0 :   _py += other_jet._py;</span>
<span class="lineNum">    3335 </span><span class="lineNoCov">          0 :   _pz += other_jet._pz;</span>
<span class="lineNum">    3336 </span><span class="lineNoCov">          0 :   _E  += other_jet._E ;</span>
<a name="3337"><span class="lineNum">    3337 </span><span class="lineNoCov">          0 :   _finish_init(); // we need to recalculate phi,rap,kt2</span></a>
<span class="lineNum">    3338 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3339 </span>            : void PseudoJet::operator-=(const PseudoJet &amp; other_jet) {
<span class="lineNum">    3340 </span><span class="lineNoCov">          0 :   _px -= other_jet._px;</span>
<span class="lineNum">    3341 </span><span class="lineNoCov">          0 :   _py -= other_jet._py;</span>
<span class="lineNum">    3342 </span><span class="lineNoCov">          0 :   _pz -= other_jet._pz;</span>
<span class="lineNum">    3343 </span><span class="lineNoCov">          0 :   _E  -= other_jet._E ;</span>
<a name="3344"><span class="lineNum">    3344 </span><span class="lineNoCov">          0 :   _finish_init(); // we need to recalculate phi,rap,kt2</span></a>
<span class="lineNum">    3345 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3346 </span>            : bool operator==(const PseudoJet &amp; a, const PseudoJet &amp; b) {
<span class="lineNum">    3347 </span><span class="lineNoCov">          0 :   if (a.px() != b.px()) return false;</span>
<span class="lineNum">    3348 </span><span class="lineNoCov">          0 :   if (a.py() != b.py()) return false;</span>
<span class="lineNum">    3349 </span><span class="lineNoCov">          0 :   if (a.pz() != b.pz()) return false;</span>
<span class="lineNum">    3350 </span><span class="lineNoCov">          0 :   if (a.E () != b.E ()) return false;</span>
<span class="lineNum">    3351 </span><span class="lineNoCov">          0 :   if (a.user_index()    != b.user_index()) return false;</span>
<span class="lineNum">    3352 </span><span class="lineNoCov">          0 :   if (a.cluster_hist_index() != b.cluster_hist_index()) return false;</span>
<span class="lineNum">    3353 </span><span class="lineNoCov">          0 :   if (a.user_info_ptr() != b.user_info_ptr()) return false;</span>
<span class="lineNum">    3354 </span><span class="lineNoCov">          0 :   if (a.structure_ptr() != b.structure_ptr()) return false;</span>
<a name="3355"><span class="lineNum">    3355 </span><span class="lineNoCov">          0 :   return true;</span></a>
<span class="lineNum">    3356 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3357 </span>            : bool operator==(const PseudoJet &amp; jet, const double val) {
<span class="lineNum">    3358 </span><span class="lineNoCov">          0 :   if (val != 0)</span>
<span class="lineNum">    3359 </span><span class="lineNoCov">          0 :     throw Error(&quot;comparing a PseudoJet with a non-zero constant (double) is not allowed.&quot;);</span>
<span class="lineNum">    3360 </span><span class="lineNoCov">          0 :   return (jet.px() == 0 &amp;&amp; jet.py() == 0 &amp;&amp;</span>
<a name="3361"><span class="lineNum">    3361 </span><span class="lineNoCov">          0 :           jet.pz() == 0 &amp;&amp; jet.E() == 0);</span></a>
<span class="lineNum">    3362 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3363 </span>            : PseudoJet &amp; PseudoJet::boost(const PseudoJet &amp; prest) {
<span class="lineNum">    3364 </span><span class="lineNoCov">          0 :   if (prest.px() == 0.0 &amp;&amp; prest.py() == 0.0 &amp;&amp; prest.pz() == 0.0)</span>
<span class="lineNum">    3365 </span><span class="lineNoCov">          0 :     return *this;</span>
<span class="lineNum">    3366 </span><span class="lineNoCov">          0 :   double m_local = prest.m();</span>
<span class="lineNum">    3367 </span><span class="lineNoCov">          0 :   assert(m_local != 0);</span>
<span class="lineNum">    3368 </span><span class="lineNoCov">          0 :   double pf4  = (  px()*prest.px() + py()*prest.py()</span>
<span class="lineNum">    3369 </span><span class="lineNoCov">          0 :                  + pz()*prest.pz() + E()*prest.E() )/m_local;</span>
<span class="lineNum">    3370 </span><span class="lineNoCov">          0 :   double fn   = (pf4 + E()) / (prest.E() + m_local);</span>
<span class="lineNum">    3371 </span><span class="lineNoCov">          0 :   _px +=  fn*prest.px();</span>
<span class="lineNum">    3372 </span><span class="lineNoCov">          0 :   _py +=  fn*prest.py();</span>
<span class="lineNum">    3373 </span><span class="lineNoCov">          0 :   _pz +=  fn*prest.pz();</span>
<span class="lineNum">    3374 </span><span class="lineNoCov">          0 :   _E = pf4;</span>
<span class="lineNum">    3375 </span><span class="lineNoCov">          0 :   _finish_init(); // we need to recalculate phi,rap,kt2</span>
<a name="3376"><span class="lineNum">    3376 </span>            :   return *this;</a>
<span class="lineNum">    3377 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3378 </span>            : PseudoJet &amp; PseudoJet::unboost(const PseudoJet &amp; prest) {
<span class="lineNum">    3379 </span><span class="lineNoCov">          0 :   if (prest.px() == 0.0 &amp;&amp; prest.py() == 0.0 &amp;&amp; prest.pz() == 0.0)</span>
<span class="lineNum">    3380 </span><span class="lineNoCov">          0 :     return *this;</span>
<span class="lineNum">    3381 </span><span class="lineNoCov">          0 :   double m_local = prest.m();</span>
<span class="lineNum">    3382 </span><span class="lineNoCov">          0 :   assert(m_local != 0);</span>
<span class="lineNum">    3383 </span><span class="lineNoCov">          0 :   double pf4  = ( -px()*prest.px() - py()*prest.py()</span>
<span class="lineNum">    3384 </span><span class="lineNoCov">          0 :                  - pz()*prest.pz() + E()*prest.E() )/m_local;</span>
<span class="lineNum">    3385 </span><span class="lineNoCov">          0 :   double fn   = (pf4 + E()) / (prest.E() + m_local);</span>
<span class="lineNum">    3386 </span><span class="lineNoCov">          0 :   _px -=  fn*prest.px();</span>
<span class="lineNum">    3387 </span><span class="lineNoCov">          0 :   _py -=  fn*prest.py();</span>
<span class="lineNum">    3388 </span><span class="lineNoCov">          0 :   _pz -=  fn*prest.pz();</span>
<span class="lineNum">    3389 </span><span class="lineNoCov">          0 :   _E = pf4;</span>
<span class="lineNum">    3390 </span><span class="lineNoCov">          0 :   _finish_init(); // we need to recalculate phi,rap,kt2</span>
<a name="3391"><span class="lineNum">    3391 </span>            :   return *this;</a>
<span class="lineNum">    3392 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3393 </span>            : bool have_same_momentum(const PseudoJet &amp; jeta, const PseudoJet &amp; jetb) {
<span class="lineNum">    3394 </span><span class="lineNoCov">          0 :   return jeta.px() == jetb.px()</span>
<span class="lineNum">    3395 </span><span class="lineNoCov">          0 :     &amp;&amp;   jeta.py() == jetb.py()</span>
<span class="lineNum">    3396 </span><span class="lineNoCov">          0 :     &amp;&amp;   jeta.pz() == jetb.pz()</span>
<a name="3397"><span class="lineNum">    3397 </span><span class="lineNoCov">          0 :     &amp;&amp;   jeta.E()  == jetb.E();</span></a>
<span class="lineNum">    3398 </span>            : }
<span class="lineNum">    3399 </span>            : void PseudoJet::set_cached_rap_phi(double rap_in, double phi_in) {
<span class="lineNum">    3400 </span><span class="lineNoCov">          0 :   _rap = rap_in; _phi = phi_in;</span>
<span class="lineNum">    3401 </span><span class="lineNoCov">          0 :   if (_phi &gt;= twopi) _phi -= twopi;</span>
<a name="3402"><span class="lineNum">    3402 </span><span class="lineNoCov">          0 :   if (_phi &lt; 0)      _phi += twopi;</span></a>
<span class="lineNum">    3403 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3404 </span>            : void PseudoJet::reset_momentum_PtYPhiM(double pt_in, double y_in, double phi_in, double m_in) {
<span class="lineNum">    3405 </span><span class="lineNoCov">          0 :   assert(phi_in &lt; 2*twopi &amp;&amp; phi_in &gt; -twopi);</span>
<span class="lineNum">    3406 </span><span class="lineNoCov">          0 :   double ptm = (m_in == 0) ? pt_in : sqrt(pt_in*pt_in+m_in*m_in);</span>
<span class="lineNum">    3407 </span><span class="lineNoCov">          0 :   double exprap = exp(y_in);</span>
<span class="lineNum">    3408 </span><span class="lineNoCov">          0 :   double pminus = ptm/exprap;</span>
<span class="lineNum">    3409 </span><span class="lineNoCov">          0 :   double pplus  = ptm*exprap;</span>
<span class="lineNum">    3410 </span><span class="lineNoCov">          0 :   double px_local = pt_in*cos(phi_in);</span>
<span class="lineNum">    3411 </span><span class="lineNoCov">          0 :   double py_local = pt_in*sin(phi_in);</span>
<span class="lineNum">    3412 </span><span class="lineNoCov">          0 :   reset_momentum(px_local,py_local,0.5*(pplus-pminus),0.5*(pplus+pminus));</span>
<a name="3413"><span class="lineNum">    3413 </span><span class="lineNoCov">          0 :   set_cached_rap_phi(y_in,phi_in);</span></a>
<span class="lineNum">    3414 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3415 </span>            : PseudoJet PtYPhiM(double pt, double y, double phi, double m) {
<span class="lineNum">    3416 </span><span class="lineNoCov">          0 :   assert(phi &lt; 2*twopi &amp;&amp; phi &gt; -twopi);</span>
<span class="lineNum">    3417 </span><span class="lineNoCov">          0 :   double ptm = (m == 0) ? pt : sqrt(pt*pt+m*m);</span>
<span class="lineNum">    3418 </span><span class="lineNoCov">          0 :   double exprap = exp(y);</span>
<span class="lineNum">    3419 </span><span class="lineNoCov">          0 :   double pminus = ptm/exprap;</span>
<span class="lineNum">    3420 </span><span class="lineNoCov">          0 :   double pplus  = ptm*exprap;</span>
<span class="lineNum">    3421 </span><span class="lineNoCov">          0 :   double px = pt*cos(phi);</span>
<span class="lineNum">    3422 </span><span class="lineNoCov">          0 :   double py = pt*sin(phi);</span>
<span class="lineNum">    3423 </span><span class="lineNoCov">          0 :   PseudoJet mom(px,py,0.5*(pplus-pminus),0.5*(pplus+pminus));</span>
<span class="lineNum">    3424 </span><span class="lineNoCov">          0 :   mom.set_cached_rap_phi(y,phi);</span>
<a name="3425"><span class="lineNum">    3425 </span>            :   return mom;</a>
<span class="lineNum">    3426 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3427 </span>            : double PseudoJet::kt_distance(const PseudoJet &amp; other) const {
<span class="lineNum">    3428 </span><span class="lineNoCov">          0 :   double distance = min(_kt2, other._kt2);</span>
<span class="lineNum">    3429 </span><span class="lineNoCov">          0 :   double dphi = abs(phi() - other.phi());</span>
<span class="lineNum">    3430 </span><span class="lineNoCov">          0 :   if (dphi &gt; pi) {dphi = twopi - dphi;}</span>
<span class="lineNum">    3431 </span><span class="lineNoCov">          0 :   double drap = rap() - other.rap();</span>
<span class="lineNum">    3432 </span><span class="lineNoCov">          0 :   distance = distance * (dphi*dphi + drap*drap);</span>
<a name="3433"><span class="lineNum">    3433 </span><span class="lineNoCov">          0 :   return distance;</span></a>
<span class="lineNum">    3434 </span>            : }
<span class="lineNum">    3435 </span>            : double PseudoJet::plain_distance(const PseudoJet &amp; other) const {
<span class="lineNum">    3436 </span><span class="lineNoCov">          0 :   double dphi = abs(phi() - other.phi());</span>
<span class="lineNum">    3437 </span><span class="lineNoCov">          0 :   if (dphi &gt; pi) {dphi = twopi - dphi;}</span>
<span class="lineNum">    3438 </span><span class="lineNoCov">          0 :   double drap = rap() - other.rap();</span>
<a name="3439"><span class="lineNum">    3439 </span><span class="lineNoCov">          0 :   return (dphi*dphi + drap*drap);</span></a>
<span class="lineNum">    3440 </span>            : }
<span class="lineNum">    3441 </span>            : double PseudoJet::delta_phi_to(const PseudoJet &amp; other) const {
<span class="lineNum">    3442 </span><span class="lineNoCov">          0 :   double dphi = other.phi() - phi();</span>
<span class="lineNum">    3443 </span><span class="lineNoCov">          0 :   if (dphi &gt;  pi) dphi -= twopi;</span>
<span class="lineNum">    3444 </span><span class="lineNoCov">          0 :   if (dphi &lt; -pi) dphi += twopi;</span>
<a name="3445"><span class="lineNum">    3445 </span><span class="lineNoCov">          0 :   return dphi;</span></a>
<span class="lineNum">    3446 </span>            : }
<span class="lineNum">    3447 </span>            : string PseudoJet::description() const{
<span class="lineNum">    3448 </span><span class="lineNoCov">          0 :   if (!_structure())</span>
<span class="lineNum">    3449 </span><span class="lineNoCov">          0 :     return &quot;standard PseudoJet (with no associated clustering information)&quot;;</span>
<a name="3450"><span class="lineNum">    3450 </span><span class="lineNoCov">          0 :   return _structure()-&gt;description();</span></a>
<span class="lineNum">    3451 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3452 </span>            : bool PseudoJet::has_associated_cluster_sequence() const{
<a name="3453"><span class="lineNum">    3453 </span><span class="lineNoCov">          0 :   return (_structure()) &amp;&amp; (_structure-&gt;has_associated_cluster_sequence());</span></a>
<span class="lineNum">    3454 </span>            : }
<span class="lineNum">    3455 </span>            : const ClusterSequence* PseudoJet::associated_cluster_sequence() const{
<span class="lineNum">    3456 </span><span class="lineNoCov">          0 :   if (! has_associated_cluster_sequence()) return NULL;</span>
<a name="3457"><span class="lineNum">    3457 </span><span class="lineNoCov">          0 :   return _structure-&gt;associated_cluster_sequence();</span></a>
<span class="lineNum">    3458 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3459 </span>            : bool PseudoJet::has_valid_cluster_sequence() const{
<a name="3460"><span class="lineNum">    3460 </span><span class="lineNoCov">          0 :   return (_structure()) &amp;&amp; (_structure-&gt;has_valid_cluster_sequence());</span></a>
<span class="lineNum">    3461 </span>            : }
<span class="lineNum">    3462 </span>            : const ClusterSequence * PseudoJet::validated_cs() const {
<a name="3463"><span class="lineNum">    3463 </span><span class="lineNoCov">          0 :   return validated_structure_ptr()-&gt;validated_cs();</span></a>
<span class="lineNum">    3464 </span>            : }
<span class="lineNum">    3465 </span>            : void PseudoJet::set_structure_shared_ptr(const SharedPtr&lt;PseudoJetStructureBase&gt; &amp;structure_in){
<a name="3466"><span class="lineNum">    3466 </span><span class="lineNoCov">          0 :   _structure = structure_in;</span></a>
<span class="lineNum">    3467 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3468 </span>            : bool PseudoJet::has_structure() const{
<a name="3469"><span class="lineNum">    3469 </span><span class="lineNoCov">          0 :   return _structure();</span></a>
<span class="lineNum">    3470 </span>            : }
<span class="lineNum">    3471 </span>            : const PseudoJetStructureBase* PseudoJet::structure_ptr() const {
<span class="lineNum">    3472 </span><span class="lineNoCov">          0 :   if (!_structure()) return NULL;</span>
<a name="3473"><span class="lineNum">    3473 </span><span class="lineNoCov">          0 :   return _structure();</span></a>
<span class="lineNum">    3474 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3475 </span>            : PseudoJetStructureBase* PseudoJet::structure_non_const_ptr(){
<span class="lineNum">    3476 </span><span class="lineNoCov">          0 :   if (!_structure()) return NULL;</span>
<a name="3477"><span class="lineNum">    3477 </span><span class="lineNoCov">          0 :   return _structure();</span></a>
<span class="lineNum">    3478 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3479 </span>            : const PseudoJetStructureBase* PseudoJet::validated_structure_ptr() const {
<span class="lineNum">    3480 </span><span class="lineNoCov">          0 :   if (!_structure())</span>
<span class="lineNum">    3481 </span><span class="lineNoCov">          0 :     throw Error(&quot;Trying to access the structure of a PseudoJet which has no associated structure&quot;);</span>
<a name="3482"><span class="lineNum">    3482 </span><span class="lineNoCov">          0 :   return _structure();</span></a>
<span class="lineNum">    3483 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3484 </span>            : const SharedPtr&lt;PseudoJetStructureBase&gt; &amp; PseudoJet::structure_shared_ptr() const {
<a name="3485"><span class="lineNum">    3485 </span><span class="lineNoCov">          0 :   return _structure;</span></a>
<span class="lineNum">    3486 </span>            : }
<span class="lineNum">    3487 </span>            : bool PseudoJet::has_partner(PseudoJet &amp;partner) const{
<a name="3488"><span class="lineNum">    3488 </span><span class="lineNoCov">          0 :   return validated_structure_ptr()-&gt;has_partner(*this, partner);</span></a>
<span class="lineNum">    3489 </span>            : }
<span class="lineNum">    3490 </span>            : bool PseudoJet::has_child(PseudoJet &amp;child) const{
<a name="3491"><span class="lineNum">    3491 </span><span class="lineNoCov">          0 :   return validated_structure_ptr()-&gt;has_child(*this, child);</span></a>
<span class="lineNum">    3492 </span>            : }
<span class="lineNum">    3493 </span>            : bool PseudoJet::has_parents(PseudoJet &amp;parent1, PseudoJet &amp;parent2) const{
<a name="3494"><span class="lineNum">    3494 </span><span class="lineNoCov">          0 :   return validated_structure_ptr()-&gt;has_parents(*this, parent1, parent2);</span></a>
<span class="lineNum">    3495 </span>            : }
<span class="lineNum">    3496 </span>            : bool PseudoJet::contains(const PseudoJet &amp;constituent) const{
<a name="3497"><span class="lineNum">    3497 </span><span class="lineNoCov">          0 :   return validated_structure_ptr()-&gt;object_in_jet(constituent, *this);</span></a>
<span class="lineNum">    3498 </span>            : }
<span class="lineNum">    3499 </span>            : bool PseudoJet::is_inside(const PseudoJet &amp;jet) const{
<a name="3500"><span class="lineNum">    3500 </span><span class="lineNoCov">          0 :   return validated_structure_ptr()-&gt;object_in_jet(*this, jet);</span></a>
<span class="lineNum">    3501 </span>            : }
<span class="lineNum">    3502 </span>            : bool PseudoJet::has_constituents() const{
<a name="3503"><span class="lineNum">    3503 </span><span class="lineNoCov">          0 :   return (_structure()) &amp;&amp; (_structure-&gt;has_constituents());</span></a>
<span class="lineNum">    3504 </span>            : }
<span class="lineNum">    3505 </span>            : vector&lt;PseudoJet&gt; PseudoJet::constituents() const{
<a name="3506"><span class="lineNum">    3506 </span><span class="lineNoCov">          0 :   return validated_structure_ptr()-&gt;constituents(*this);</span></a>
<span class="lineNum">    3507 </span>            : }
<span class="lineNum">    3508 </span>            : bool PseudoJet::has_exclusive_subjets() const{
<a name="3509"><span class="lineNum">    3509 </span><span class="lineNoCov">          0 :   return (_structure()) &amp;&amp; (_structure-&gt;has_exclusive_subjets());</span></a>
<span class="lineNum">    3510 </span>            : }
<span class="lineNum">    3511 </span>            : std::vector&lt;PseudoJet&gt; PseudoJet::exclusive_subjets (const double &amp; dcut) const {
<a name="3512"><span class="lineNum">    3512 </span><span class="lineNoCov">          0 :   return validated_structure_ptr()-&gt;exclusive_subjets(*this, dcut);</span></a>
<span class="lineNum">    3513 </span>            : }
<span class="lineNum">    3514 </span>            : int PseudoJet::n_exclusive_subjets(const double &amp; dcut) const {
<a name="3515"><span class="lineNum">    3515 </span><span class="lineNoCov">          0 :   return validated_structure_ptr()-&gt;n_exclusive_subjets(*this, dcut);</span></a>
<span class="lineNum">    3516 </span>            : }
<span class="lineNum">    3517 </span>            : std::vector&lt;PseudoJet&gt; PseudoJet::exclusive_subjets_up_to (int nsub) const {
<a name="3518"><span class="lineNum">    3518 </span><span class="lineNoCov">          0 :   return validated_structure_ptr()-&gt;exclusive_subjets_up_to(*this, nsub);</span></a>
<span class="lineNum">    3519 </span>            : }
<span class="lineNum">    3520 </span>            : std::vector&lt;PseudoJet&gt; PseudoJet::exclusive_subjets (int nsub) const {
<span class="lineNum">    3521 </span><span class="lineNoCov">          0 :   vector&lt;PseudoJet&gt; subjets = exclusive_subjets_up_to(nsub);</span>
<span class="lineNum">    3522 </span><span class="lineNoCov">          0 :   if (int(subjets.size()) &lt; nsub) {</span>
<span class="lineNum">    3523 </span><span class="lineNoCov">          0 :     ostringstream err;</span>
<span class="lineNum">    3524 </span><span class="lineNoCov">          0 :     err &lt;&lt; &quot;Requested &quot; &lt;&lt; nsub &lt;&lt; &quot; exclusive subjets, but there were only &quot;</span>
<span class="lineNum">    3525 </span><span class="lineNoCov">          0 :         &lt;&lt; subjets.size() &lt;&lt; &quot; particles in the jet&quot;;</span>
<span class="lineNum">    3526 </span><span class="lineNoCov">          0 :     throw Error(err.str());</span>
<span class="lineNum">    3527 </span><span class="lineNoCov">          0 :   }</span>
<a name="3528"><span class="lineNum">    3528 </span>            :   return subjets;</a>
<span class="lineNum">    3529 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3530 </span>            : double PseudoJet::exclusive_subdmerge(int nsub) const {
<a name="3531"><span class="lineNum">    3531 </span><span class="lineNoCov">          0 :   return validated_structure_ptr()-&gt;exclusive_subdmerge(*this, nsub);</span></a>
<span class="lineNum">    3532 </span>            : }
<span class="lineNum">    3533 </span>            : double PseudoJet::exclusive_subdmerge_max(int nsub) const {
<a name="3534"><span class="lineNum">    3534 </span><span class="lineNoCov">          0 :   return validated_structure_ptr()-&gt;exclusive_subdmerge_max(*this, nsub);</span></a>
<span class="lineNum">    3535 </span>            : }
<span class="lineNum">    3536 </span>            : bool PseudoJet::has_pieces() const{
<a name="3537"><span class="lineNum">    3537 </span><span class="lineNoCov">          0 :   return ((_structure()) &amp;&amp; (_structure-&gt;has_pieces(*this)));</span></a>
<span class="lineNum">    3538 </span>            : }
<span class="lineNum">    3539 </span>            : std::vector&lt;PseudoJet&gt; PseudoJet::pieces() const{
<a name="3540"><span class="lineNum">    3540 </span><span class="lineNoCov">          0 :   return validated_structure_ptr()-&gt;pieces(*this);</span></a>
<span class="lineNum">    3541 </span>            : }
<a name="3542"><span class="lineNum">    3542 </span><span class="lineNoCov">          0 : PseudoJet::InexistentUserInfo::InexistentUserInfo() : Error(&quot;you attempted to perform a dynamic cast of a PseudoJet's extra info, but the extra info pointer was null&quot;)</span></a>
<span class="lineNum">    3543 </span><span class="lineNoCov">          0 : {}</span>
<span class="lineNum">    3544 </span>            : void sort_indices(vector&lt;int&gt; &amp; indices,
<span class="lineNum">    3545 </span>            :                          const vector&lt;double&gt; &amp; values) {
<span class="lineNum">    3546 </span><span class="lineNoCov">          0 :   IndexedSortHelper index_sort_helper(&amp;values);</span>
<a name="3547"><span class="lineNum">    3547 </span><span class="lineNoCov">          0 :   sort(indices.begin(), indices.end(), index_sort_helper);</span></a>
<span class="lineNum">    3548 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3549 </span>            : template&lt;class T&gt; vector&lt;T&gt;  objects_sorted_by_values(
<span class="lineNum">    3550 </span>            :                        const vector&lt;T&gt; &amp; objects,
<span class="lineNum">    3551 </span>            :                        const vector&lt;double&gt; &amp; values) {
<span class="lineNum">    3552 </span><span class="lineNoCov">          0 :   assert(objects.size() == values.size());</span>
<span class="lineNum">    3553 </span><span class="lineNoCov">          0 :   vector&lt;int&gt; indices(values.size());</span>
<span class="lineNum">    3554 </span><span class="lineNoCov">          0 :   for (size_t i = 0; i &lt; indices.size(); i++) {indices[i] = i;}</span>
<span class="lineNum">    3555 </span><span class="lineNoCov">          0 :   sort_indices(indices, values);</span>
<span class="lineNum">    3556 </span><span class="lineNoCov">          0 :   vector&lt;T&gt; objects_sorted(objects.size());</span>
<span class="lineNum">    3557 </span><span class="lineNoCov">          0 :   for (size_t i = 0; i &lt; indices.size(); i++) {</span>
<span class="lineNum">    3558 </span><span class="lineNoCov">          0 :     objects_sorted[i] = objects[indices[i]];</span>
<span class="lineNum">    3559 </span>            :   }
<a name="3560"><span class="lineNum">    3560 </span>            :   return objects_sorted;</a>
<span class="lineNum">    3561 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3562 </span>            : vector&lt;PseudoJet&gt; sorted_by_pt(const vector&lt;PseudoJet&gt; &amp; jets) {
<span class="lineNum">    3563 </span><span class="lineNoCov">          0 :   vector&lt;double&gt; minus_kt2(jets.size());</span>
<span class="lineNum">    3564 </span><span class="lineNoCov">          0 :   for (size_t i = 0; i &lt; jets.size(); i++) {minus_kt2[i] = -jets[i].kt2();}</span>
<a name="3565"><span class="lineNum">    3565 </span><span class="lineNoCov">          0 :   return objects_sorted_by_values(jets, minus_kt2);</span></a>
<span class="lineNum">    3566 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3567 </span>            : vector&lt;PseudoJet&gt; sorted_by_rapidity(const vector&lt;PseudoJet&gt; &amp; jets) {
<span class="lineNum">    3568 </span><span class="lineNoCov">          0 :   vector&lt;double&gt; rapidities(jets.size());</span>
<span class="lineNum">    3569 </span><span class="lineNoCov">          0 :   for (size_t i = 0; i &lt; jets.size(); i++) {rapidities[i] = jets[i].rap();}</span>
<a name="3570"><span class="lineNum">    3570 </span><span class="lineNoCov">          0 :   return objects_sorted_by_values(jets, rapidities);</span></a>
<span class="lineNum">    3571 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3572 </span>            : vector&lt;PseudoJet&gt; sorted_by_E(const vector&lt;PseudoJet&gt; &amp; jets) {
<span class="lineNum">    3573 </span><span class="lineNoCov">          0 :   vector&lt;double&gt; energies(jets.size());</span>
<span class="lineNum">    3574 </span><span class="lineNoCov">          0 :   for (size_t i = 0; i &lt; jets.size(); i++) {energies[i] = -jets[i].E();}</span>
<a name="3575"><span class="lineNum">    3575 </span><span class="lineNoCov">          0 :   return objects_sorted_by_values(jets, energies);</span></a>
<span class="lineNum">    3576 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3577 </span>            : vector&lt;PseudoJet&gt; sorted_by_pz(const vector&lt;PseudoJet&gt; &amp; jets) {
<span class="lineNum">    3578 </span><span class="lineNoCov">          0 :   vector&lt;double&gt; pz(jets.size());</span>
<span class="lineNum">    3579 </span><span class="lineNoCov">          0 :   for (size_t i = 0; i &lt; jets.size(); i++) {pz[i] = jets[i].pz();}</span>
<a name="3580"><span class="lineNum">    3580 </span><span class="lineNoCov">          0 :   return objects_sorted_by_values(jets, pz);</span></a>
<span class="lineNum">    3581 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3582 </span>            : PseudoJet join(const vector&lt;PseudoJet&gt; &amp; pieces){
<span class="lineNum">    3583 </span><span class="lineNoCov">          0 :   PseudoJet result;  // automatically initialised to 0</span>
<span class="lineNum">    3584 </span><span class="lineNoCov">          0 :   for (unsigned int i=0; i&lt;pieces.size(); i++)</span>
<span class="lineNum">    3585 </span><span class="lineNoCov">          0 :     result += pieces[i];</span>
<span class="lineNum">    3586 </span><span class="lineNoCov">          0 :   CompositeJetStructure *cj_struct = new CompositeJetStructure(pieces);</span>
<span class="lineNum">    3587 </span><span class="lineNoCov">          0 :   result.set_structure_shared_ptr(SharedPtr&lt;PseudoJetStructureBase&gt;(cj_struct));</span>
<a name="3588"><span class="lineNum">    3588 </span>            :   return result;</a>
<span class="lineNum">    3589 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3590 </span>            : PseudoJet join(const PseudoJet &amp; j1){
<a name="3591"><span class="lineNum">    3591 </span><span class="lineNoCov">          0 :   return join(vector&lt;PseudoJet&gt;(1,j1));</span></a>
<span class="lineNum">    3592 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3593 </span>            : PseudoJet join(const PseudoJet &amp; j1, const PseudoJet &amp; j2){
<span class="lineNum">    3594 </span><span class="lineNoCov">          0 :   vector&lt;PseudoJet&gt; pieces;</span>
<span class="lineNum">    3595 </span><span class="lineNoCov">          0 :   pieces.push_back(j1);</span>
<span class="lineNum">    3596 </span><span class="lineNoCov">          0 :   pieces.push_back(j2);</span>
<a name="3597"><span class="lineNum">    3597 </span><span class="lineNoCov">          0 :   return join(pieces);</span></a>
<span class="lineNum">    3598 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3599 </span>            : PseudoJet join(const PseudoJet &amp; j1, const PseudoJet &amp; j2, const PseudoJet &amp; j3){
<span class="lineNum">    3600 </span><span class="lineNoCov">          0 :   vector&lt;PseudoJet&gt; pieces;</span>
<span class="lineNum">    3601 </span><span class="lineNoCov">          0 :   pieces.push_back(j1);</span>
<span class="lineNum">    3602 </span><span class="lineNoCov">          0 :   pieces.push_back(j2);</span>
<span class="lineNum">    3603 </span><span class="lineNoCov">          0 :   pieces.push_back(j3);</span>
<a name="3604"><span class="lineNum">    3604 </span><span class="lineNoCov">          0 :   return join(pieces);</span></a>
<span class="lineNum">    3605 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3606 </span>            : PseudoJet join(const PseudoJet &amp; j1, const PseudoJet &amp; j2, const PseudoJet &amp; j3, const PseudoJet &amp; j4){
<span class="lineNum">    3607 </span><span class="lineNoCov">          0 :   vector&lt;PseudoJet&gt; pieces;</span>
<span class="lineNum">    3608 </span><span class="lineNoCov">          0 :   pieces.push_back(j1);</span>
<span class="lineNum">    3609 </span><span class="lineNoCov">          0 :   pieces.push_back(j2);</span>
<span class="lineNum">    3610 </span><span class="lineNoCov">          0 :   pieces.push_back(j3);</span>
<span class="lineNum">    3611 </span><span class="lineNoCov">          0 :   pieces.push_back(j4);</span>
<span class="lineNum">    3612 </span><span class="lineNoCov">          0 :   return join(pieces);</span>
<span class="lineNum">    3613 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3614 </span>            : FJCORE_END_NAMESPACE
<a name="3615"><span class="lineNum">    3615 </span>            : using namespace std;</a>
<span class="lineNum">    3616 </span>            : FJCORE_BEGIN_NAMESPACE      // defined in fastjet/internal/base.hh
<span class="lineNum">    3617 </span>            : const ClusterSequence* PseudoJetStructureBase::associated_cluster_sequence() const{
<a name="3618"><span class="lineNum">    3618 </span><span class="lineNoCov">          0 :   return NULL;</span></a>
<span class="lineNum">    3619 </span>            : }
<span class="lineNum">    3620 </span>            : const ClusterSequence * PseudoJetStructureBase::validated_cs() const{
<a name="3621"><span class="lineNum">    3621 </span><span class="lineNoCov">          0 :   throw Error(&quot;This PseudoJet structure is not associated with a valid ClusterSequence&quot;);</span></a>
<span class="lineNum">    3622 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3623 </span>            : bool PseudoJetStructureBase::has_partner(const PseudoJet &amp; /*reference */, PseudoJet &amp; /*partner*/) const{
<a name="3624"><span class="lineNum">    3624 </span><span class="lineNoCov">          0 :   throw Error(&quot;This PseudoJet structure has no implementation for has_partner&quot;);</span></a>
<span class="lineNum">    3625 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3626 </span>            : bool PseudoJetStructureBase::has_child(const PseudoJet &amp; /*reference*/, PseudoJet &amp; /*child*/) const{
<a name="3627"><span class="lineNum">    3627 </span><span class="lineNoCov">          0 :   throw Error(&quot;This PseudoJet structure has no implementation for has_child&quot;);</span></a>
<span class="lineNum">    3628 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3629 </span>            : bool PseudoJetStructureBase::has_parents(const PseudoJet &amp; /*reference*/, PseudoJet &amp;/*parent1*/, PseudoJet &amp;/*parent2*/) const{
<a name="3630"><span class="lineNum">    3630 </span><span class="lineNoCov">          0 :   throw Error(&quot;This PseudoJet structure has no implementation for has_parents&quot;);</span></a>
<span class="lineNum">    3631 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3632 </span>            : bool PseudoJetStructureBase::object_in_jet(const PseudoJet &amp; /*reference*/, const PseudoJet &amp; /*jet*/) const{
<a name="3633"><span class="lineNum">    3633 </span><span class="lineNoCov">          0 :   throw Error(&quot;This PseudoJet structure has no implementation for is_inside&quot;);</span></a>
<span class="lineNum">    3634 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3635 </span>            : vector&lt;PseudoJet&gt; PseudoJetStructureBase::constituents(const PseudoJet &amp;/*reference*/) const{
<a name="3636"><span class="lineNum">    3636 </span><span class="lineNoCov">          0 :   throw Error(&quot;This PseudoJet structure has no implementation for constituents&quot;);</span></a>
<span class="lineNum">    3637 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3638 </span>            : vector&lt;PseudoJet&gt; PseudoJetStructureBase::exclusive_subjets (const PseudoJet &amp; /*reference*/, const double &amp; /*dcut*/) const{
<a name="3639"><span class="lineNum">    3639 </span><span class="lineNoCov">          0 :   throw Error(&quot;This PseudoJet structure has no implementation for exclusive_subjets&quot;);</span></a>
<span class="lineNum">    3640 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3641 </span>            : int PseudoJetStructureBase::n_exclusive_subjets(const PseudoJet &amp; /*reference*/, const double &amp; /*dcut*/) const{
<a name="3642"><span class="lineNum">    3642 </span><span class="lineNoCov">          0 :   throw Error(&quot;This PseudoJet structure has no implementation for n_exclusive_subjets&quot;);</span></a>
<span class="lineNum">    3643 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3644 </span>            : vector&lt;PseudoJet&gt; PseudoJetStructureBase::exclusive_subjets_up_to (const PseudoJet &amp; /*reference*/, int /*nsub*/) const{
<a name="3645"><span class="lineNum">    3645 </span><span class="lineNoCov">          0 :   throw Error(&quot;This PseudoJet structure has no implementation for exclusive_subjets&quot;);</span></a>
<span class="lineNum">    3646 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3647 </span>            : double PseudoJetStructureBase::exclusive_subdmerge(const PseudoJet &amp; /*reference*/, int /*nsub*/) const{
<a name="3648"><span class="lineNum">    3648 </span><span class="lineNoCov">          0 :   throw Error(&quot;This PseudoJet structure has no implementation for exclusive_submerge&quot;);</span></a>
<span class="lineNum">    3649 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3650 </span>            : double PseudoJetStructureBase::exclusive_subdmerge_max(const PseudoJet &amp; /*reference*/, int /*nsub*/) const{
<a name="3651"><span class="lineNum">    3651 </span><span class="lineNoCov">          0 :   throw Error(&quot;This PseudoJet structure has no implementation for exclusive_submerge_max&quot;);</span></a>
<span class="lineNum">    3652 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3653 </span>            : std::vector&lt;PseudoJet&gt; PseudoJetStructureBase::pieces(const PseudoJet &amp; /*reference*/) const{
<span class="lineNum">    3654 </span><span class="lineNoCov">          0 :   throw Error(&quot;This PseudoJet structure has no implementation for pieces&quot;);</span>
<span class="lineNum">    3655 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3656 </span>            : FJCORE_END_NAMESPACE
<span class="lineNum">    3657 </span>            : #include &lt;sstream&gt;
<span class="lineNum">    3658 </span>            : #include &lt;algorithm&gt;
<a name="3659"><span class="lineNum">    3659 </span>            : using namespace std;</a>
<span class="lineNum">    3660 </span>            : FJCORE_BEGIN_NAMESPACE      // defined in fastjet/internal/base.hh
<span class="lineNum">    3661 </span>            : std::vector&lt;PseudoJet&gt; Selector::operator()(const std::vector&lt;PseudoJet&gt; &amp; jets) const {
<span class="lineNum">    3662 </span><span class="lineNoCov">          0 :   std::vector&lt;PseudoJet&gt; result;</span>
<span class="lineNum">    3663 </span><span class="lineNoCov">          0 :   const SelectorWorker * worker_local = validated_worker();</span>
<span class="lineNum">    3664 </span><span class="lineNoCov">          0 :   if (worker_local-&gt;applies_jet_by_jet()) {</span>
<span class="lineNum">    3665 </span><span class="lineNoCov">          0 :     for (std::vector&lt;PseudoJet&gt;::const_iterator jet = jets.begin();</span>
<span class="lineNum">    3666 </span><span class="lineNoCov">          0 :          jet != jets.end(); jet++) {</span>
<span class="lineNum">    3667 </span><span class="lineNoCov">          0 :       if (worker_local-&gt;pass(*jet)) result.push_back(*jet);</span>
<span class="lineNum">    3668 </span>            :     }
<span class="lineNum">    3669 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">    3670 </span><span class="lineNoCov">          0 :     std::vector&lt;const PseudoJet *&gt; jetptrs(jets.size());</span>
<span class="lineNum">    3671 </span><span class="lineNoCov">          0 :     for (unsigned i = 0; i &lt; jets.size(); i++) {</span>
<span class="lineNum">    3672 </span><span class="lineNoCov">          0 :       jetptrs[i] = &amp; jets[i];</span>
<span class="lineNum">    3673 </span>            :     }
<span class="lineNum">    3674 </span><span class="lineNoCov">          0 :     worker_local-&gt;terminator(jetptrs);</span>
<span class="lineNum">    3675 </span><span class="lineNoCov">          0 :     for (unsigned i = 0; i &lt; jetptrs.size(); i++) {</span>
<span class="lineNum">    3676 </span><span class="lineNoCov">          0 :       if (jetptrs[i]) result.push_back(jets[i]);</span>
<span class="lineNum">    3677 </span>            :     }
<span class="lineNum">    3678 </span><span class="lineNoCov">          0 :   }</span>
<a name="3679"><span class="lineNum">    3679 </span>            :   return result;</a>
<span class="lineNum">    3680 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3681 </span>            : unsigned int Selector::count(const std::vector&lt;PseudoJet&gt; &amp; jets) const {
<span class="lineNum">    3682 </span>            :   unsigned n = 0;
<span class="lineNum">    3683 </span><span class="lineNoCov">          0 :   const SelectorWorker * worker_local = validated_worker();</span>
<span class="lineNum">    3684 </span><span class="lineNoCov">          0 :   if (worker_local-&gt;applies_jet_by_jet()) {</span>
<span class="lineNum">    3685 </span><span class="lineNoCov">          0 :     for (unsigned i = 0; i &lt; jets.size(); i++) {</span>
<span class="lineNum">    3686 </span><span class="lineNoCov">          0 :       if (worker_local-&gt;pass(jets[i])) n++;</span>
<span class="lineNum">    3687 </span>            :     }
<span class="lineNum">    3688 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">    3689 </span><span class="lineNoCov">          0 :     std::vector&lt;const PseudoJet *&gt; jetptrs(jets.size());</span>
<span class="lineNum">    3690 </span><span class="lineNoCov">          0 :     for (unsigned i = 0; i &lt; jets.size(); i++) {</span>
<span class="lineNum">    3691 </span><span class="lineNoCov">          0 :       jetptrs[i] = &amp; jets[i];</span>
<span class="lineNum">    3692 </span>            :     }
<span class="lineNum">    3693 </span><span class="lineNoCov">          0 :     worker_local-&gt;terminator(jetptrs);</span>
<span class="lineNum">    3694 </span><span class="lineNoCov">          0 :     for (unsigned i = 0; i &lt; jetptrs.size(); i++) {</span>
<span class="lineNum">    3695 </span><span class="lineNoCov">          0 :       if (jetptrs[i]) n++;</span>
<span class="lineNum">    3696 </span>            :     }
<span class="lineNum">    3697 </span><span class="lineNoCov">          0 :   }</span>
<a name="3698"><span class="lineNum">    3698 </span><span class="lineNoCov">          0 :   return n;</span></a>
<span class="lineNum">    3699 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3700 </span>            : void Selector::sift(const std::vector&lt;PseudoJet&gt; &amp; jets,
<span class="lineNum">    3701 </span>            :                     std::vector&lt;PseudoJet&gt; &amp; jets_that_pass,
<span class="lineNum">    3702 </span>            :                     std::vector&lt;PseudoJet&gt; &amp; jets_that_fail
<span class="lineNum">    3703 </span>            :                     ) const {
<span class="lineNum">    3704 </span><span class="lineNoCov">          0 :   const SelectorWorker * worker_local = validated_worker();</span>
<span class="lineNum">    3705 </span><span class="lineNoCov">          0 :   jets_that_pass.clear();</span>
<span class="lineNum">    3706 </span><span class="lineNoCov">          0 :   jets_that_fail.clear();</span>
<span class="lineNum">    3707 </span><span class="lineNoCov">          0 :   if (worker_local-&gt;applies_jet_by_jet()) {</span>
<span class="lineNum">    3708 </span><span class="lineNoCov">          0 :     for (unsigned i = 0; i &lt; jets.size(); i++) {</span>
<span class="lineNum">    3709 </span><span class="lineNoCov">          0 :       if (worker_local-&gt;pass(jets[i])) {</span>
<span class="lineNum">    3710 </span><span class="lineNoCov">          0 :         jets_that_pass.push_back(jets[i]);</span>
<span class="lineNum">    3711 </span><span class="lineNoCov">          0 :       } else {</span>
<span class="lineNum">    3712 </span><span class="lineNoCov">          0 :         jets_that_fail.push_back(jets[i]);</span>
<span class="lineNum">    3713 </span>            :       }
<span class="lineNum">    3714 </span>            :     }
<span class="lineNum">    3715 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">    3716 </span><span class="lineNoCov">          0 :     std::vector&lt;const PseudoJet *&gt; jetptrs(jets.size());</span>
<span class="lineNum">    3717 </span><span class="lineNoCov">          0 :     for (unsigned i = 0; i &lt; jets.size(); i++) {</span>
<span class="lineNum">    3718 </span><span class="lineNoCov">          0 :       jetptrs[i] = &amp; jets[i];</span>
<span class="lineNum">    3719 </span>            :     }
<span class="lineNum">    3720 </span><span class="lineNoCov">          0 :     worker_local-&gt;terminator(jetptrs);</span>
<span class="lineNum">    3721 </span><span class="lineNoCov">          0 :     for (unsigned i = 0; i &lt; jetptrs.size(); i++) {</span>
<span class="lineNum">    3722 </span><span class="lineNoCov">          0 :       if (jetptrs[i]) {</span>
<span class="lineNum">    3723 </span><span class="lineNoCov">          0 :         jets_that_pass.push_back(jets[i]);</span>
<span class="lineNum">    3724 </span>            :       } else {
<span class="lineNum">    3725 </span><span class="lineNoCov">          0 :         jets_that_fail.push_back(jets[i]);</span>
<span class="lineNum">    3726 </span>            :       }
<span class="lineNum">    3727 </span>            :     }
<a name="3728"><span class="lineNum">    3728 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    3729 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3730 </span>            : bool SelectorWorker::has_finite_area() const {
<span class="lineNum">    3731 </span><span class="lineNoCov">          0 :   if (! is_geometric()) return false;</span>
<span class="lineNum">    3732 </span><span class="lineNoCov">          0 :   double rapmin, rapmax;</span>
<span class="lineNum">    3733 </span><span class="lineNoCov">          0 :   get_rapidity_extent(rapmin, rapmax);</span>
<span class="lineNum">    3734 </span><span class="lineNoCov">          0 :   return (rapmax != std::numeric_limits&lt;double&gt;::infinity())</span>
<a name="3735"><span class="lineNum">    3735 </span><span class="lineNoCov">          0 :     &amp;&amp;  (-rapmin != std::numeric_limits&lt;double&gt;::infinity());</span></a>
<span class="lineNum">    3736 </span><span class="lineNoCov">          0 : }</span>
<a name="3737"><span class="lineNum">    3737 </span><span class="lineNoCov">          0 : class SW_Identity : public SelectorWorker {</span></a>
<a name="3738"><span class="lineNum">    3738 </span>            : public:</a>
<span class="lineNum">    3739 </span><span class="lineNoCov">          0 :   SW_Identity(){}</span>
<span class="lineNum">    3740 </span>            :   virtual bool pass(const PseudoJet &amp;) const {
<a name="3741"><span class="lineNum">    3741 </span><span class="lineNoCov">          0 :     return true;</span></a>
<span class="lineNum">    3742 </span>            :   }
<span class="lineNum">    3743 </span>            :   virtual void terminator(vector&lt;const PseudoJet *&gt; &amp;) const {
<a name="3744"><span class="lineNum">    3744 </span><span class="lineNoCov">          0 :     return;</span></a>
<a name="3745"><span class="lineNum">    3745 </span>            :   }</a>
<span class="lineNum">    3746 </span><span class="lineNoCov">          0 :   virtual string description() const { return &quot;Identity&quot;;}</span>
<a name="3747"><span class="lineNum">    3747 </span><span class="lineNoCov">          0 :   virtual bool is_geometric() const { return true;}</span></a>
<span class="lineNum">    3748 </span>            : };
<span class="lineNum">    3749 </span>            : Selector SelectorIdentity() {
<a name="3750"><span class="lineNum">    3750 </span><span class="lineNoCov">          0 :   return Selector(new SW_Identity);</span></a>
<span class="lineNum">    3751 </span><span class="lineNoCov">          0 : }</span>
<a name="3752"><span class="lineNum">    3752 </span><span class="lineNoCov">          0 : class SW_Not : public SelectorWorker {</span></a>
<a name="3753"><span class="lineNum">    3753 </span>            : public:</a>
<a name="3754"><span class="lineNum">    3754 </span><span class="lineNoCov">          0 :   SW_Not(const Selector &amp; s) : _s(s) {}</span></a>
<span class="lineNum">    3755 </span><span class="lineNoCov">          0 :   virtual SelectorWorker* copy(){ return new SW_Not(*this);}</span>
<span class="lineNum">    3756 </span>            :   virtual bool pass(const PseudoJet &amp; jet) const {
<span class="lineNum">    3757 </span><span class="lineNoCov">          0 :     if (!applies_jet_by_jet())</span>
<span class="lineNum">    3758 </span><span class="lineNoCov">          0 :       throw Error(&quot;Cannot apply this selector worker to an individual jet&quot;);</span>
<a name="3759"><span class="lineNum">    3759 </span><span class="lineNoCov">          0 :     return ! _s.pass(jet);</span></a>
<a name="3760"><span class="lineNum">    3760 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    3761 </span><span class="lineNoCov">          0 :   virtual bool applies_jet_by_jet() const {return _s.applies_jet_by_jet();}</span>
<span class="lineNum">    3762 </span>            :   virtual void terminator(vector&lt;const PseudoJet *&gt; &amp; jets) const {
<span class="lineNum">    3763 </span><span class="lineNoCov">          0 :     if (applies_jet_by_jet()){</span>
<span class="lineNum">    3764 </span><span class="lineNoCov">          0 :       SelectorWorker::terminator(jets);</span>
<span class="lineNum">    3765 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    3766 </span>            :     }
<span class="lineNum">    3767 </span><span class="lineNoCov">          0 :     vector&lt;const PseudoJet *&gt; s_jets = jets;</span>
<span class="lineNum">    3768 </span><span class="lineNoCov">          0 :     _s.worker()-&gt;terminator(s_jets);</span>
<span class="lineNum">    3769 </span><span class="lineNoCov">          0 :     for (unsigned int i=0; i&lt;s_jets.size(); i++){</span>
<span class="lineNum">    3770 </span><span class="lineNoCov">          0 :       if (s_jets[i]) jets[i] = NULL;</span>
<a name="3771"><span class="lineNum">    3771 </span>            :     }</a>
<span class="lineNum">    3772 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3773 </span>            :   virtual string description() const {
<span class="lineNum">    3774 </span><span class="lineNoCov">          0 :     ostringstream ostr;</span>
<span class="lineNum">    3775 </span><span class="lineNoCov">          0 :     ostr &lt;&lt; &quot;!(&quot; &lt;&lt; _s.description() &lt;&lt; &quot;)&quot;;</span>
<a name="3776"><span class="lineNum">    3776 </span><span class="lineNoCov">          0 :     return ostr.str();</span></a>
<a name="3777"><span class="lineNum">    3777 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="3778"><span class="lineNum">    3778 </span><span class="lineNoCov">          0 :   virtual bool is_geometric() const { return _s.is_geometric();}</span></a>
<span class="lineNum">    3779 </span><span class="lineNoCov">          0 :   virtual bool takes_reference() const { return _s.takes_reference();}</span>
<span class="lineNum">    3780 </span><span class="lineNoCov">          0 :   virtual void set_reference(const PseudoJet &amp;ref) { _s.set_reference(ref);}</span>
<span class="lineNum">    3781 </span>            : protected:
<a name="3782"><span class="lineNum">    3782 </span>            :   Selector _s;</a>
<span class="lineNum">    3783 </span>            : };
<span class="lineNum">    3784 </span>            : Selector operator!(const Selector &amp; s) {
<a name="3785"><span class="lineNum">    3785 </span><span class="lineNoCov">          0 :   return Selector(new SW_Not(s));</span></a>
<span class="lineNum">    3786 </span><span class="lineNoCov">          0 : }</span>
<a name="3787"><span class="lineNum">    3787 </span><span class="lineNoCov">          0 : class SW_BinaryOperator: public SelectorWorker {</span></a>
<span class="lineNum">    3788 </span>            : public:
<span class="lineNum">    3789 </span><span class="lineNoCov">          0 :   SW_BinaryOperator(const Selector &amp; s1, const Selector &amp; s2) : _s1(s1), _s2(s2) {</span>
<span class="lineNum">    3790 </span><span class="lineNoCov">          0 :     _applies_jet_by_jet = _s1.applies_jet_by_jet() &amp;&amp; _s2.applies_jet_by_jet();</span>
<span class="lineNum">    3791 </span><span class="lineNoCov">          0 :     _takes_reference = _s1.takes_reference() || _s2.takes_reference();</span>
<a name="3792"><span class="lineNum">    3792 </span><span class="lineNoCov">          0 :     _is_geometric = _s1.is_geometric() &amp;&amp; _s2.is_geometric();</span></a>
<a name="3793"><span class="lineNum">    3793 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    3794 </span><span class="lineNoCov">          0 :   virtual bool applies_jet_by_jet() const {return _applies_jet_by_jet;}</span>
<span class="lineNum">    3795 </span>            :   virtual bool takes_reference() const{
<a name="3796"><span class="lineNum">    3796 </span><span class="lineNoCov">          0 :     return _takes_reference;</span></a>
<span class="lineNum">    3797 </span>            :   }
<span class="lineNum">    3798 </span>            :   virtual void set_reference(const PseudoJet &amp;centre){
<span class="lineNum">    3799 </span><span class="lineNoCov">          0 :     _s1.set_reference(centre);</span>
<a name="3800"><span class="lineNum">    3800 </span><span class="lineNoCov">          0 :     _s2.set_reference(centre);</span></a>
<span class="lineNum">    3801 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3802 </span><span class="lineNoCov">          0 :   virtual bool is_geometric() const { return _is_geometric;}</span>
<span class="lineNum">    3803 </span>            : protected:
<span class="lineNum">    3804 </span>            :   Selector _s1, _s2;
<span class="lineNum">    3805 </span>            :   bool _applies_jet_by_jet;
<span class="lineNum">    3806 </span>            :   bool _takes_reference;
<a name="3807"><span class="lineNum">    3807 </span>            :   bool _is_geometric;</a>
<span class="lineNum">    3808 </span>            : };
<a name="3809"><span class="lineNum">    3809 </span><span class="lineNoCov">          0 : class SW_And: public SW_BinaryOperator {</span></a>
<a name="3810"><span class="lineNum">    3810 </span>            : public:</a>
<a name="3811"><span class="lineNum">    3811 </span><span class="lineNoCov">          0 :   SW_And(const Selector &amp; s1, const Selector &amp; s2) : SW_BinaryOperator(s1,s2){}</span></a>
<span class="lineNum">    3812 </span><span class="lineNoCov">          0 :   virtual SelectorWorker* copy(){ return new SW_And(*this);}</span>
<span class="lineNum">    3813 </span>            :   virtual bool pass(const PseudoJet &amp; jet) const {
<span class="lineNum">    3814 </span><span class="lineNoCov">          0 :     if (!applies_jet_by_jet())</span>
<span class="lineNum">    3815 </span><span class="lineNoCov">          0 :       throw Error(&quot;Cannot apply this selector worker to an individual jet&quot;);</span>
<a name="3816"><span class="lineNum">    3816 </span><span class="lineNoCov">          0 :     return _s1.pass(jet) &amp;&amp; _s2.pass(jet);</span></a>
<span class="lineNum">    3817 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3818 </span>            :   virtual void terminator(vector&lt;const PseudoJet *&gt; &amp; jets) const {
<span class="lineNum">    3819 </span><span class="lineNoCov">          0 :     if (applies_jet_by_jet()){</span>
<span class="lineNum">    3820 </span><span class="lineNoCov">          0 :       SelectorWorker::terminator(jets);</span>
<span class="lineNum">    3821 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    3822 </span>            :     }
<span class="lineNum">    3823 </span><span class="lineNoCov">          0 :     vector&lt;const PseudoJet *&gt; s1_jets = jets;</span>
<span class="lineNum">    3824 </span><span class="lineNoCov">          0 :     _s1.worker()-&gt;terminator(s1_jets);</span>
<span class="lineNum">    3825 </span><span class="lineNoCov">          0 :     _s2.worker()-&gt;terminator(jets);</span>
<span class="lineNum">    3826 </span><span class="lineNoCov">          0 :     for (unsigned int i=0; i&lt;jets.size(); i++){</span>
<span class="lineNum">    3827 </span><span class="lineNoCov">          0 :       if (! s1_jets[i]) jets[i] = NULL;</span>
<a name="3828"><span class="lineNum">    3828 </span>            :     }</a>
<span class="lineNum">    3829 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3830 </span>            :   virtual void get_rapidity_extent(double &amp; rapmin, double &amp; rapmax) const {
<span class="lineNum">    3831 </span><span class="lineNoCov">          0 :     double s1min, s1max, s2min, s2max;</span>
<span class="lineNum">    3832 </span><span class="lineNoCov">          0 :     _s1.get_rapidity_extent(s1min, s1max);</span>
<span class="lineNum">    3833 </span><span class="lineNoCov">          0 :     _s2.get_rapidity_extent(s2min, s2max);</span>
<span class="lineNum">    3834 </span><span class="lineNoCov">          0 :     rapmax = min(s1max, s2max);</span>
<a name="3835"><span class="lineNum">    3835 </span><span class="lineNoCov">          0 :     rapmin = max(s1min, s2min);</span></a>
<span class="lineNum">    3836 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3837 </span>            :   virtual string description() const {
<span class="lineNum">    3838 </span><span class="lineNoCov">          0 :     ostringstream ostr;</span>
<span class="lineNum">    3839 </span><span class="lineNoCov">          0 :     ostr &lt;&lt; &quot;(&quot; &lt;&lt; _s1.description() &lt;&lt; &quot; &amp;&amp; &quot; &lt;&lt; _s2.description() &lt;&lt; &quot;)&quot;;</span>
<span class="lineNum">    3840 </span><span class="lineNoCov">          0 :     return ostr.str();</span>
<a name="3841"><span class="lineNum">    3841 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    3842 </span>            : };
<span class="lineNum">    3843 </span>            : Selector operator&amp;&amp;(const Selector &amp; s1, const Selector &amp; s2) {
<a name="3844"><span class="lineNum">    3844 </span><span class="lineNoCov">          0 :   return Selector(new SW_And(s1,s2));</span></a>
<span class="lineNum">    3845 </span><span class="lineNoCov">          0 : }</span>
<a name="3846"><span class="lineNum">    3846 </span><span class="lineNoCov">          0 : class SW_Or: public SW_BinaryOperator {</span></a>
<a name="3847"><span class="lineNum">    3847 </span>            : public:</a>
<a name="3848"><span class="lineNum">    3848 </span><span class="lineNoCov">          0 :   SW_Or(const Selector &amp; s1, const Selector &amp; s2) : SW_BinaryOperator(s1,s2) {}</span></a>
<span class="lineNum">    3849 </span><span class="lineNoCov">          0 :   virtual SelectorWorker* copy(){ return new SW_Or(*this);}</span>
<span class="lineNum">    3850 </span>            :   virtual bool pass(const PseudoJet &amp; jet) const {
<span class="lineNum">    3851 </span><span class="lineNoCov">          0 :     if (!applies_jet_by_jet())</span>
<span class="lineNum">    3852 </span><span class="lineNoCov">          0 :       throw Error(&quot;Cannot apply this selector worker to an individual jet&quot;);</span>
<a name="3853"><span class="lineNum">    3853 </span><span class="lineNoCov">          0 :     return _s1.pass(jet) || _s2.pass(jet);</span></a>
<span class="lineNum">    3854 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3855 </span>            :   virtual bool applies_jet_by_jet() const {
<a name="3856"><span class="lineNum">    3856 </span><span class="lineNoCov">          0 :     return _s1.applies_jet_by_jet() &amp;&amp; _s2.applies_jet_by_jet();</span></a>
<span class="lineNum">    3857 </span>            :   }
<span class="lineNum">    3858 </span>            :   virtual void terminator(vector&lt;const PseudoJet *&gt; &amp; jets) const {
<span class="lineNum">    3859 </span><span class="lineNoCov">          0 :     if (applies_jet_by_jet()){</span>
<span class="lineNum">    3860 </span><span class="lineNoCov">          0 :       SelectorWorker::terminator(jets);</span>
<span class="lineNum">    3861 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    3862 </span>            :     }
<span class="lineNum">    3863 </span><span class="lineNoCov">          0 :     vector&lt;const PseudoJet *&gt; s1_jets = jets;</span>
<span class="lineNum">    3864 </span><span class="lineNoCov">          0 :     _s1.worker()-&gt;terminator(s1_jets);</span>
<span class="lineNum">    3865 </span><span class="lineNoCov">          0 :     _s2.worker()-&gt;terminator(jets);</span>
<span class="lineNum">    3866 </span><span class="lineNoCov">          0 :     for (unsigned int i=0; i&lt;jets.size(); i++){</span>
<span class="lineNum">    3867 </span><span class="lineNoCov">          0 :       if (s1_jets[i]) jets[i] = s1_jets[i];</span>
<a name="3868"><span class="lineNum">    3868 </span>            :     }</a>
<span class="lineNum">    3869 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3870 </span>            :   virtual string description() const {
<span class="lineNum">    3871 </span><span class="lineNoCov">          0 :     ostringstream ostr;</span>
<span class="lineNum">    3872 </span><span class="lineNoCov">          0 :     ostr &lt;&lt; &quot;(&quot; &lt;&lt; _s1.description() &lt;&lt; &quot; || &quot; &lt;&lt; _s2.description() &lt;&lt; &quot;)&quot;;</span>
<a name="3873"><span class="lineNum">    3873 </span><span class="lineNoCov">          0 :     return ostr.str();</span></a>
<span class="lineNum">    3874 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3875 </span>            :   virtual void get_rapidity_extent(double &amp; rapmin, double &amp; rapmax) const {
<span class="lineNum">    3876 </span><span class="lineNoCov">          0 :     double s1min, s1max, s2min, s2max;</span>
<span class="lineNum">    3877 </span><span class="lineNoCov">          0 :     _s1.get_rapidity_extent(s1min, s1max);</span>
<span class="lineNum">    3878 </span><span class="lineNoCov">          0 :     _s2.get_rapidity_extent(s2min, s2max);</span>
<span class="lineNum">    3879 </span><span class="lineNoCov">          0 :     rapmax = max(s1max, s2max);</span>
<span class="lineNum">    3880 </span><span class="lineNoCov">          0 :     rapmin = min(s1min, s2min);</span>
<a name="3881"><span class="lineNum">    3881 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    3882 </span>            : };
<span class="lineNum">    3883 </span>            : Selector operator ||(const Selector &amp; s1, const Selector &amp; s2) {
<a name="3884"><span class="lineNum">    3884 </span><span class="lineNoCov">          0 :   return Selector(new SW_Or(s1,s2));</span></a>
<span class="lineNum">    3885 </span><span class="lineNoCov">          0 : }</span>
<a name="3886"><span class="lineNum">    3886 </span><span class="lineNoCov">          0 : class SW_Mult: public SW_And {</span></a>
<a name="3887"><span class="lineNum">    3887 </span>            : public:</a>
<a name="3888"><span class="lineNum">    3888 </span><span class="lineNoCov">          0 :   SW_Mult(const Selector &amp; s1, const Selector &amp; s2) : SW_And(s1,s2) {}</span></a>
<span class="lineNum">    3889 </span><span class="lineNoCov">          0 :   virtual SelectorWorker* copy(){ return new SW_Mult(*this);}</span>
<span class="lineNum">    3890 </span>            :   virtual void terminator(vector&lt;const PseudoJet *&gt; &amp; jets) const {
<span class="lineNum">    3891 </span><span class="lineNoCov">          0 :     if (applies_jet_by_jet()){</span>
<span class="lineNum">    3892 </span><span class="lineNoCov">          0 :       SelectorWorker::terminator(jets);</span>
<span class="lineNum">    3893 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    3894 </span>            :     }
<span class="lineNum">    3895 </span><span class="lineNoCov">          0 :     _s2.worker()-&gt;terminator(jets);</span>
<a name="3896"><span class="lineNum">    3896 </span><span class="lineNoCov">          0 :     _s1.worker()-&gt;terminator(jets);</span></a>
<span class="lineNum">    3897 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3898 </span>            :   virtual string description() const {
<span class="lineNum">    3899 </span><span class="lineNoCov">          0 :     ostringstream ostr;</span>
<span class="lineNum">    3900 </span><span class="lineNoCov">          0 :     ostr &lt;&lt; &quot;(&quot; &lt;&lt; _s1.description() &lt;&lt; &quot; * &quot; &lt;&lt; _s2.description() &lt;&lt; &quot;)&quot;;</span>
<span class="lineNum">    3901 </span><span class="lineNoCov">          0 :     return ostr.str();</span>
<a name="3902"><span class="lineNum">    3902 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    3903 </span>            : };
<span class="lineNum">    3904 </span>            : Selector operator*(const Selector &amp; s1, const Selector &amp; s2) {
<span class="lineNum">    3905 </span><span class="lineNoCov">          0 :   return Selector(new SW_Mult(s1,s2));</span>
<span class="lineNum">    3906 </span><span class="lineNoCov">          0 : }</span>
<a name="3907"><span class="lineNum">    3907 </span>            : class QuantityBase{</a>
<a name="3908"><span class="lineNum">    3908 </span>            : public:</a>
<span class="lineNum">    3909 </span><span class="lineNoCov">          0 :   QuantityBase(double q) : _q(q){}</span>
<span class="lineNum">    3910 </span><span class="lineNoCov">          0 :   virtual ~QuantityBase(){}</span>
<a name="3911"><span class="lineNum">    3911 </span>            :   virtual double operator()(const PseudoJet &amp; jet ) const =0;</a>
<a name="3912"><span class="lineNum">    3912 </span>            :   virtual string description() const =0;</a>
<a name="3913"><span class="lineNum">    3913 </span><span class="lineNoCov">          0 :   virtual bool is_geometric() const { return false;}</span></a>
<span class="lineNum">    3914 </span><span class="lineNoCov">          0 :   virtual double comparison_value() const {return _q;}</span>
<span class="lineNum">    3915 </span><span class="lineNoCov">          0 :   virtual double description_value() const {return comparison_value();}</span>
<span class="lineNum">    3916 </span>            : protected:
<a name="3917"><span class="lineNum">    3917 </span>            :   double _q;</a>
<span class="lineNum">    3918 </span>            : };
<a name="3919"><span class="lineNum">    3919 </span><span class="lineNoCov">          0 : class QuantitySquareBase : public QuantityBase{</span></a>
<a name="3920"><span class="lineNum">    3920 </span>            : public:</a>
<span class="lineNum">    3921 </span><span class="lineNoCov">          0 :   QuantitySquareBase(double sqrtq) : QuantityBase(sqrtq*sqrtq), _sqrtq(sqrtq){}</span>
<span class="lineNum">    3922 </span><span class="lineNoCov">          0 :   virtual double description_value() const {return _sqrtq;}</span>
<span class="lineNum">    3923 </span>            : protected:
<span class="lineNum">    3924 </span>            :   double _sqrtq;
<a name="3925"><span class="lineNum">    3925 </span>            : };</a>
<span class="lineNum">    3926 </span>            : template&lt;typename QuantityType&gt;
<a name="3927"><span class="lineNum">    3927 </span><span class="lineNoCov">          0 : class SW_QuantityMin : public SelectorWorker{</span></a>
<a name="3928"><span class="lineNum">    3928 </span>            : public:</a>
<a name="3929"><span class="lineNum">    3929 </span><span class="lineNoCov">          0 :   SW_QuantityMin(double qmin) : _qmin(qmin) {}</span></a>
<span class="lineNum">    3930 </span><span class="lineNoCov">          0 :   virtual bool pass(const PseudoJet &amp; jet) const {return _qmin(jet) &gt;= _qmin.comparison_value();}</span>
<span class="lineNum">    3931 </span>            :   virtual string description() const {
<span class="lineNum">    3932 </span><span class="lineNoCov">          0 :     ostringstream ostr;</span>
<span class="lineNum">    3933 </span><span class="lineNoCov">          0 :     ostr &lt;&lt; _qmin.description() &lt;&lt; &quot; &gt;= &quot; &lt;&lt; _qmin.description_value();</span>
<a name="3934"><span class="lineNum">    3934 </span><span class="lineNoCov">          0 :     return ostr.str();</span></a>
<span class="lineNum">    3935 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3936 </span><span class="lineNoCov">          0 :   virtual bool is_geometric() const { return _qmin.is_geometric();}</span>
<span class="lineNum">    3937 </span>            : protected:
<span class="lineNum">    3938 </span>            :   QuantityType _qmin;     ///&lt; the cut
<a name="3939"><span class="lineNum">    3939 </span>            : };</a>
<span class="lineNum">    3940 </span>            : template&lt;typename QuantityType&gt;
<a name="3941"><span class="lineNum">    3941 </span><span class="lineNoCov">          0 : class SW_QuantityMax : public SelectorWorker {</span></a>
<a name="3942"><span class="lineNum">    3942 </span>            : public:</a>
<a name="3943"><span class="lineNum">    3943 </span><span class="lineNoCov">          0 :   SW_QuantityMax(double qmax) : _qmax(qmax) {}</span></a>
<span class="lineNum">    3944 </span><span class="lineNoCov">          0 :   virtual bool pass(const PseudoJet &amp; jet) const {return _qmax(jet) &lt;= _qmax.comparison_value();}</span>
<span class="lineNum">    3945 </span>            :   virtual string description() const {
<span class="lineNum">    3946 </span><span class="lineNoCov">          0 :     ostringstream ostr;</span>
<span class="lineNum">    3947 </span><span class="lineNoCov">          0 :     ostr &lt;&lt; _qmax.description() &lt;&lt; &quot; &lt;= &quot; &lt;&lt; _qmax.description_value();</span>
<a name="3948"><span class="lineNum">    3948 </span><span class="lineNoCov">          0 :     return ostr.str();</span></a>
<span class="lineNum">    3949 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3950 </span><span class="lineNoCov">          0 :   virtual bool is_geometric() const { return _qmax.is_geometric();}</span>
<span class="lineNum">    3951 </span>            : protected:
<span class="lineNum">    3952 </span>            :   QuantityType _qmax;   ///&lt; the cut
<a name="3953"><span class="lineNum">    3953 </span>            : };</a>
<span class="lineNum">    3954 </span>            : template&lt;typename QuantityType&gt;
<a name="3955"><span class="lineNum">    3955 </span><span class="lineNoCov">          0 : class SW_QuantityRange : public SelectorWorker {</span></a>
<a name="3956"><span class="lineNum">    3956 </span>            : public:</a>
<span class="lineNum">    3957 </span><span class="lineNoCov">          0 :   SW_QuantityRange(double qmin, double qmax) : _qmin(qmin), _qmax(qmax) {}</span>
<span class="lineNum">    3958 </span>            :   virtual bool pass(const PseudoJet &amp; jet) const {
<span class="lineNum">    3959 </span><span class="lineNoCov">          0 :     double q = _qmin(jet); // we could identically use _qmax</span>
<a name="3960"><span class="lineNum">    3960 </span><span class="lineNoCov">          0 :     return (q &gt;= _qmin.comparison_value()) &amp;&amp; (q &lt;= _qmax.comparison_value());</span></a>
<span class="lineNum">    3961 </span>            :   }
<span class="lineNum">    3962 </span>            :   virtual string description() const {
<span class="lineNum">    3963 </span><span class="lineNoCov">          0 :     ostringstream ostr;</span>
<span class="lineNum">    3964 </span><span class="lineNoCov">          0 :     ostr &lt;&lt; _qmin.description_value() &lt;&lt; &quot; &lt;= &quot; &lt;&lt; _qmin.description() &lt;&lt; &quot; &lt;= &quot; &lt;&lt; _qmax.description_value();</span>
<a name="3965"><span class="lineNum">    3965 </span><span class="lineNoCov">          0 :     return ostr.str();</span></a>
<span class="lineNum">    3966 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3967 </span><span class="lineNoCov">          0 :   virtual bool is_geometric() const { return _qmin.is_geometric();}</span>
<span class="lineNum">    3968 </span>            : protected:
<span class="lineNum">    3969 </span>            :   QuantityType _qmin;   // the lower cut
<a name="3970"><span class="lineNum">    3970 </span>            :   QuantityType _qmax;   // the upper cut</a>
<span class="lineNum">    3971 </span>            : };
<a name="3972"><span class="lineNum">    3972 </span><span class="lineNoCov">          0 : class QuantityPt2 : public QuantitySquareBase{</span></a>
<a name="3973"><span class="lineNum">    3973 </span>            : public:</a>
<a name="3974"><span class="lineNum">    3974 </span><span class="lineNoCov">          0 :   QuantityPt2(double pt) : QuantitySquareBase(pt){}</span></a>
<span class="lineNum">    3975 </span><span class="lineNoCov">          0 :   virtual double operator()(const PseudoJet &amp; jet ) const { return jet.perp2();}</span>
<a name="3976"><span class="lineNum">    3976 </span><span class="lineNoCov">          0 :   virtual string description() const {return &quot;pt&quot;;}</span></a>
<span class="lineNum">    3977 </span>            : };
<span class="lineNum">    3978 </span>            : Selector SelectorPtMin(double ptmin) {
<a name="3979"><span class="lineNum">    3979 </span><span class="lineNoCov">          0 :   return Selector(new SW_QuantityMin&lt;QuantityPt2&gt;(ptmin));</span></a>
<span class="lineNum">    3980 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3981 </span>            : Selector SelectorPtMax(double ptmax) {
<a name="3982"><span class="lineNum">    3982 </span><span class="lineNoCov">          0 :   return Selector(new SW_QuantityMax&lt;QuantityPt2&gt;(ptmax));</span></a>
<span class="lineNum">    3983 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3984 </span>            : Selector SelectorPtRange(double ptmin, double ptmax) {
<a name="3985"><span class="lineNum">    3985 </span><span class="lineNoCov">          0 :   return Selector(new SW_QuantityRange&lt;QuantityPt2&gt;(ptmin, ptmax));</span></a>
<span class="lineNum">    3986 </span><span class="lineNoCov">          0 : }</span>
<a name="3987"><span class="lineNum">    3987 </span><span class="lineNoCov">          0 : class QuantityEt2 : public QuantitySquareBase{</span></a>
<a name="3988"><span class="lineNum">    3988 </span>            : public:</a>
<a name="3989"><span class="lineNum">    3989 </span><span class="lineNoCov">          0 :   QuantityEt2(double Et) : QuantitySquareBase(Et){}</span></a>
<span class="lineNum">    3990 </span><span class="lineNoCov">          0 :   virtual double operator()(const PseudoJet &amp; jet ) const { return jet.Et2();}</span>
<a name="3991"><span class="lineNum">    3991 </span><span class="lineNoCov">          0 :   virtual string description() const {return &quot;Et&quot;;}</span></a>
<span class="lineNum">    3992 </span>            : };
<span class="lineNum">    3993 </span>            : Selector SelectorEtMin(double Etmin) {
<a name="3994"><span class="lineNum">    3994 </span><span class="lineNoCov">          0 :   return Selector(new SW_QuantityMin&lt;QuantityEt2&gt;(Etmin));</span></a>
<span class="lineNum">    3995 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3996 </span>            : Selector SelectorEtMax(double Etmax) {
<a name="3997"><span class="lineNum">    3997 </span><span class="lineNoCov">          0 :   return Selector(new SW_QuantityMax&lt;QuantityEt2&gt;(Etmax));</span></a>
<span class="lineNum">    3998 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3999 </span>            : Selector SelectorEtRange(double Etmin, double Etmax) {
<a name="4000"><span class="lineNum">    4000 </span><span class="lineNoCov">          0 :   return Selector(new SW_QuantityRange&lt;QuantityEt2&gt;(Etmin, Etmax));</span></a>
<span class="lineNum">    4001 </span><span class="lineNoCov">          0 : }</span>
<a name="4002"><span class="lineNum">    4002 </span><span class="lineNoCov">          0 : class QuantityE : public QuantityBase{</span></a>
<a name="4003"><span class="lineNum">    4003 </span>            : public:</a>
<a name="4004"><span class="lineNum">    4004 </span><span class="lineNoCov">          0 :   QuantityE(double E) : QuantityBase(E){}</span></a>
<span class="lineNum">    4005 </span><span class="lineNoCov">          0 :   virtual double operator()(const PseudoJet &amp; jet ) const { return jet.E();}</span>
<a name="4006"><span class="lineNum">    4006 </span><span class="lineNoCov">          0 :   virtual string description() const {return &quot;E&quot;;}</span></a>
<span class="lineNum">    4007 </span>            : };
<span class="lineNum">    4008 </span>            : Selector SelectorEMin(double Emin) {
<a name="4009"><span class="lineNum">    4009 </span><span class="lineNoCov">          0 :   return Selector(new SW_QuantityMin&lt;QuantityE&gt;(Emin));</span></a>
<span class="lineNum">    4010 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4011 </span>            : Selector SelectorEMax(double Emax) {
<a name="4012"><span class="lineNum">    4012 </span><span class="lineNoCov">          0 :   return Selector(new SW_QuantityMax&lt;QuantityE&gt;(Emax));</span></a>
<span class="lineNum">    4013 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4014 </span>            : Selector SelectorERange(double Emin, double Emax) {
<a name="4015"><span class="lineNum">    4015 </span><span class="lineNoCov">          0 :   return Selector(new SW_QuantityRange&lt;QuantityE&gt;(Emin, Emax));</span></a>
<span class="lineNum">    4016 </span><span class="lineNoCov">          0 : }</span>
<a name="4017"><span class="lineNum">    4017 </span><span class="lineNoCov">          0 : class QuantityM2 : public QuantitySquareBase{</span></a>
<a name="4018"><span class="lineNum">    4018 </span>            : public:</a>
<a name="4019"><span class="lineNum">    4019 </span><span class="lineNoCov">          0 :   QuantityM2(double m) : QuantitySquareBase(m){}</span></a>
<span class="lineNum">    4020 </span><span class="lineNoCov">          0 :   virtual double operator()(const PseudoJet &amp; jet ) const { return jet.m2();}</span>
<a name="4021"><span class="lineNum">    4021 </span><span class="lineNoCov">          0 :   virtual string description() const {return &quot;mass&quot;;}</span></a>
<span class="lineNum">    4022 </span>            : };
<span class="lineNum">    4023 </span>            : Selector SelectorMassMin(double mmin) {
<a name="4024"><span class="lineNum">    4024 </span><span class="lineNoCov">          0 :   return Selector(new SW_QuantityMin&lt;QuantityM2&gt;(mmin));</span></a>
<span class="lineNum">    4025 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4026 </span>            : Selector SelectorMassMax(double mmax) {
<a name="4027"><span class="lineNum">    4027 </span><span class="lineNoCov">          0 :   return Selector(new SW_QuantityMax&lt;QuantityM2&gt;(mmax));</span></a>
<span class="lineNum">    4028 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4029 </span>            : Selector SelectorMassRange(double mmin, double mmax) {
<a name="4030"><span class="lineNum">    4030 </span><span class="lineNoCov">          0 :   return Selector(new SW_QuantityRange&lt;QuantityM2&gt;(mmin, mmax));</span></a>
<span class="lineNum">    4031 </span><span class="lineNoCov">          0 : }</span>
<a name="4032"><span class="lineNum">    4032 </span><span class="lineNoCov">          0 : class QuantityRap : public QuantityBase{</span></a>
<a name="4033"><span class="lineNum">    4033 </span>            : public:</a>
<a name="4034"><span class="lineNum">    4034 </span><span class="lineNoCov">          0 :   QuantityRap(double rap) : QuantityBase(rap){}</span></a>
<a name="4035"><span class="lineNum">    4035 </span><span class="lineNoCov">          0 :   virtual double operator()(const PseudoJet &amp; jet ) const { return jet.rap();}</span></a>
<span class="lineNum">    4036 </span><span class="lineNoCov">          0 :   virtual string description() const {return &quot;rap&quot;;}</span>
<a name="4037"><span class="lineNum">    4037 </span><span class="lineNoCov">          0 :   virtual bool is_geometric() const { return true;}</span></a>
<span class="lineNum">    4038 </span>            : };
<a name="4039"><span class="lineNum">    4039 </span><span class="lineNoCov">          0 : class SW_RapMin : public SW_QuantityMin&lt;QuantityRap&gt;{</span></a>
<a name="4040"><span class="lineNum">    4040 </span>            : public:</a>
<span class="lineNum">    4041 </span><span class="lineNoCov">          0 :   SW_RapMin(double rapmin) : SW_QuantityMin&lt;QuantityRap&gt;(rapmin){}</span>
<span class="lineNum">    4042 </span>            :   virtual void get_rapidity_extent(double &amp;rapmin, double &amp; rapmax) const{
<span class="lineNum">    4043 </span><span class="lineNoCov">          0 :     rapmax = std::numeric_limits&lt;double&gt;::max();</span>
<span class="lineNum">    4044 </span><span class="lineNoCov">          0 :     rapmin = _qmin.comparison_value();</span>
<a name="4045"><span class="lineNum">    4045 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    4046 </span>            : };
<a name="4047"><span class="lineNum">    4047 </span><span class="lineNoCov">          0 : class SW_RapMax : public SW_QuantityMax&lt;QuantityRap&gt;{</span></a>
<a name="4048"><span class="lineNum">    4048 </span>            : public:</a>
<span class="lineNum">    4049 </span><span class="lineNoCov">          0 :   SW_RapMax(double rapmax) : SW_QuantityMax&lt;QuantityRap&gt;(rapmax){}</span>
<span class="lineNum">    4050 </span>            :   virtual void get_rapidity_extent(double &amp;rapmin, double &amp; rapmax) const{
<span class="lineNum">    4051 </span><span class="lineNoCov">          0 :     rapmax = _qmax.comparison_value();</span>
<span class="lineNum">    4052 </span><span class="lineNoCov">          0 :     rapmin = -std::numeric_limits&lt;double&gt;::max();</span>
<a name="4053"><span class="lineNum">    4053 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    4054 </span>            : };
<a name="4055"><span class="lineNum">    4055 </span><span class="lineNoCov">          0 : class SW_RapRange : public SW_QuantityRange&lt;QuantityRap&gt;{</span></a>
<span class="lineNum">    4056 </span>            : public:
<span class="lineNum">    4057 </span><span class="lineNoCov">          0 :   SW_RapRange(double rapmin, double rapmax) : SW_QuantityRange&lt;QuantityRap&gt;(rapmin, rapmax){</span>
<a name="4058"><span class="lineNum">    4058 </span><span class="lineNoCov">          0 :     assert(rapmin&lt;=rapmax);</span></a>
<span class="lineNum">    4059 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    4060 </span>            :   virtual void get_rapidity_extent(double &amp;rapmin, double &amp; rapmax) const{
<span class="lineNum">    4061 </span><span class="lineNoCov">          0 :     rapmax = _qmax.comparison_value();</span>
<a name="4062"><span class="lineNum">    4062 </span><span class="lineNoCov">          0 :     rapmin = _qmin.comparison_value();</span></a>
<a name="4063"><span class="lineNum">    4063 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    4064 </span><span class="lineNoCov">          0 :   virtual bool has_known_area() const { return true;} ///&lt; the area is analytically known</span>
<span class="lineNum">    4065 </span>            :   virtual double known_area() const {
<span class="lineNum">    4066 </span><span class="lineNoCov">          0 :     return twopi * (_qmax.comparison_value()-_qmin.comparison_value());</span>
<a name="4067"><span class="lineNum">    4067 </span>            :   }</a>
<span class="lineNum">    4068 </span>            : };
<span class="lineNum">    4069 </span>            : Selector SelectorRapMin(double rapmin) {
<a name="4070"><span class="lineNum">    4070 </span><span class="lineNoCov">          0 :   return Selector(new SW_RapMin(rapmin));</span></a>
<span class="lineNum">    4071 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4072 </span>            : Selector SelectorRapMax(double rapmax) {
<a name="4073"><span class="lineNum">    4073 </span><span class="lineNoCov">          0 :   return Selector(new SW_RapMax(rapmax));</span></a>
<span class="lineNum">    4074 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4075 </span>            : Selector SelectorRapRange(double rapmin, double rapmax) {
<a name="4076"><span class="lineNum">    4076 </span><span class="lineNoCov">          0 :   return Selector(new SW_RapRange(rapmin, rapmax));</span></a>
<span class="lineNum">    4077 </span><span class="lineNoCov">          0 : }</span>
<a name="4078"><span class="lineNum">    4078 </span><span class="lineNoCov">          0 : class QuantityAbsRap : public QuantityBase{</span></a>
<a name="4079"><span class="lineNum">    4079 </span>            : public:</a>
<a name="4080"><span class="lineNum">    4080 </span><span class="lineNoCov">          0 :   QuantityAbsRap(double absrap) : QuantityBase(absrap){}</span></a>
<a name="4081"><span class="lineNum">    4081 </span><span class="lineNoCov">          0 :   virtual double operator()(const PseudoJet &amp; jet ) const { return abs(jet.rap());}</span></a>
<span class="lineNum">    4082 </span><span class="lineNoCov">          0 :   virtual string description() const {return &quot;|rap|&quot;;}</span>
<a name="4083"><span class="lineNum">    4083 </span><span class="lineNoCov">          0 :   virtual bool is_geometric() const { return true;}</span></a>
<span class="lineNum">    4084 </span>            : };
<a name="4085"><span class="lineNum">    4085 </span><span class="lineNoCov">          0 : class SW_AbsRapMax : public SW_QuantityMax&lt;QuantityAbsRap&gt;{</span></a>
<a name="4086"><span class="lineNum">    4086 </span>            : public:</a>
<span class="lineNum">    4087 </span><span class="lineNoCov">          0 :   SW_AbsRapMax(double absrapmax) : SW_QuantityMax&lt;QuantityAbsRap&gt;(absrapmax){}</span>
<span class="lineNum">    4088 </span>            :   virtual void get_rapidity_extent(double &amp;rapmin, double &amp; rapmax) const{
<span class="lineNum">    4089 </span><span class="lineNoCov">          0 :     rapmax =  _qmax.comparison_value();</span>
<a name="4090"><span class="lineNum">    4090 </span><span class="lineNoCov">          0 :     rapmin = -_qmax.comparison_value();</span></a>
<a name="4091"><span class="lineNum">    4091 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    4092 </span><span class="lineNoCov">          0 :   virtual bool has_known_area() const { return true;}   ///&lt; the area is analytically known</span>
<span class="lineNum">    4093 </span>            :   virtual double known_area() const {
<span class="lineNum">    4094 </span><span class="lineNoCov">          0 :     return twopi * 2 * _qmax.comparison_value();</span>
<a name="4095"><span class="lineNum">    4095 </span>            :   }</a>
<span class="lineNum">    4096 </span>            : };
<a name="4097"><span class="lineNum">    4097 </span><span class="lineNoCov">          0 : class SW_AbsRapRange : public SW_QuantityRange&lt;QuantityAbsRap&gt;{</span></a>
<a name="4098"><span class="lineNum">    4098 </span>            : public:</a>
<span class="lineNum">    4099 </span><span class="lineNoCov">          0 :   SW_AbsRapRange(double absrapmin, double absrapmax) : SW_QuantityRange&lt;QuantityAbsRap&gt;(absrapmin, absrapmax){}</span>
<span class="lineNum">    4100 </span>            :   virtual void get_rapidity_extent(double &amp;rapmin, double &amp; rapmax) const{
<span class="lineNum">    4101 </span><span class="lineNoCov">          0 :     rapmax =  _qmax.comparison_value();</span>
<a name="4102"><span class="lineNum">    4102 </span><span class="lineNoCov">          0 :     rapmin = -_qmax.comparison_value();</span></a>
<a name="4103"><span class="lineNum">    4103 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    4104 </span><span class="lineNoCov">          0 :   virtual bool has_known_area() const { return true;} ///&lt; the area is analytically known</span>
<span class="lineNum">    4105 </span>            :   virtual double known_area() const {
<span class="lineNum">    4106 </span><span class="lineNoCov">          0 :     return twopi * 2 * (_qmax.comparison_value()-max(_qmin.comparison_value(),0.0)); // this should handle properly absrapmin&lt;0</span>
<a name="4107"><span class="lineNum">    4107 </span>            :   }</a>
<span class="lineNum">    4108 </span>            : };
<span class="lineNum">    4109 </span>            : Selector SelectorAbsRapMin(double absrapmin) {
<a name="4110"><span class="lineNum">    4110 </span><span class="lineNoCov">          0 :   return Selector(new SW_QuantityMin&lt;QuantityAbsRap&gt;(absrapmin));</span></a>
<span class="lineNum">    4111 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4112 </span>            : Selector SelectorAbsRapMax(double absrapmax) {
<a name="4113"><span class="lineNum">    4113 </span><span class="lineNoCov">          0 :   return Selector(new SW_AbsRapMax(absrapmax));</span></a>
<span class="lineNum">    4114 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4115 </span>            : Selector SelectorAbsRapRange(double rapmin, double rapmax) {
<a name="4116"><span class="lineNum">    4116 </span><span class="lineNoCov">          0 :   return Selector(new SW_AbsRapRange(rapmin, rapmax));</span></a>
<span class="lineNum">    4117 </span><span class="lineNoCov">          0 : }</span>
<a name="4118"><span class="lineNum">    4118 </span><span class="lineNoCov">          0 : class QuantityEta : public QuantityBase{</span></a>
<a name="4119"><span class="lineNum">    4119 </span>            : public:</a>
<a name="4120"><span class="lineNum">    4120 </span><span class="lineNoCov">          0 :   QuantityEta(double eta) : QuantityBase(eta){}</span></a>
<span class="lineNum">    4121 </span><span class="lineNoCov">          0 :   virtual double operator()(const PseudoJet &amp; jet ) const { return jet.eta();}</span>
<a name="4122"><span class="lineNum">    4122 </span><span class="lineNoCov">          0 :   virtual string description() const {return &quot;eta&quot;;}</span></a>
<span class="lineNum">    4123 </span>            : };
<span class="lineNum">    4124 </span>            : Selector SelectorEtaMin(double etamin) {
<a name="4125"><span class="lineNum">    4125 </span><span class="lineNoCov">          0 :   return Selector(new SW_QuantityMin&lt;QuantityEta&gt;(etamin));</span></a>
<span class="lineNum">    4126 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4127 </span>            : Selector SelectorEtaMax(double etamax) {
<a name="4128"><span class="lineNum">    4128 </span><span class="lineNoCov">          0 :   return Selector(new SW_QuantityMax&lt;QuantityEta&gt;(etamax));</span></a>
<span class="lineNum">    4129 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4130 </span>            : Selector SelectorEtaRange(double etamin, double etamax) {
<a name="4131"><span class="lineNum">    4131 </span><span class="lineNoCov">          0 :   return Selector(new SW_QuantityRange&lt;QuantityEta&gt;(etamin, etamax));</span></a>
<span class="lineNum">    4132 </span><span class="lineNoCov">          0 : }</span>
<a name="4133"><span class="lineNum">    4133 </span><span class="lineNoCov">          0 : class QuantityAbsEta : public QuantityBase{</span></a>
<a name="4134"><span class="lineNum">    4134 </span>            : public:</a>
<a name="4135"><span class="lineNum">    4135 </span><span class="lineNoCov">          0 :   QuantityAbsEta(double abseta) : QuantityBase(abseta){}</span></a>
<a name="4136"><span class="lineNum">    4136 </span><span class="lineNoCov">          0 :   virtual double operator()(const PseudoJet &amp; jet ) const { return abs(jet.eta());}</span></a>
<span class="lineNum">    4137 </span><span class="lineNoCov">          0 :   virtual string description() const {return &quot;|eta|&quot;;}</span>
<a name="4138"><span class="lineNum">    4138 </span><span class="lineNoCov">          0 :   virtual bool is_geometric() const { return true;}</span></a>
<span class="lineNum">    4139 </span>            : };
<span class="lineNum">    4140 </span>            : Selector SelectorAbsEtaMin(double absetamin) {
<a name="4141"><span class="lineNum">    4141 </span><span class="lineNoCov">          0 :   return Selector(new SW_QuantityMin&lt;QuantityAbsEta&gt;(absetamin));</span></a>
<span class="lineNum">    4142 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4143 </span>            : Selector SelectorAbsEtaMax(double absetamax) {
<a name="4144"><span class="lineNum">    4144 </span><span class="lineNoCov">          0 :   return Selector(new SW_QuantityMax&lt;QuantityAbsEta&gt;(absetamax));</span></a>
<span class="lineNum">    4145 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4146 </span>            : Selector SelectorAbsEtaRange(double absetamin, double absetamax) {
<a name="4147"><span class="lineNum">    4147 </span><span class="lineNoCov">          0 :   return Selector(new SW_QuantityRange&lt;QuantityAbsEta&gt;(absetamin, absetamax));</span></a>
<span class="lineNum">    4148 </span><span class="lineNoCov">          0 : }</span>
<a name="4149"><span class="lineNum">    4149 </span><span class="lineNoCov">          0 : class SW_PhiRange : public SelectorWorker {</span></a>
<span class="lineNum">    4150 </span>            : public:
<span class="lineNum">    4151 </span><span class="lineNoCov">          0 :   SW_PhiRange(double phimin, double phimax) : _phimin(phimin), _phimax(phimax){</span>
<span class="lineNum">    4152 </span><span class="lineNoCov">          0 :     assert(_phimin&lt;_phimax);</span>
<span class="lineNum">    4153 </span><span class="lineNoCov">          0 :     assert(_phimin&gt;-twopi);</span>
<span class="lineNum">    4154 </span><span class="lineNoCov">          0 :     assert(_phimax&lt;2*twopi);</span>
<a name="4155"><span class="lineNum">    4155 </span><span class="lineNoCov">          0 :     _phispan = _phimax - _phimin;</span></a>
<span class="lineNum">    4156 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    4157 </span>            :   virtual bool pass(const PseudoJet &amp; jet) const {
<span class="lineNum">    4158 </span><span class="lineNoCov">          0 :     double dphi=jet.phi()-_phimin;</span>
<span class="lineNum">    4159 </span><span class="lineNoCov">          0 :     if (dphi &gt;= twopi) dphi -= twopi;</span>
<span class="lineNum">    4160 </span><span class="lineNoCov">          0 :     if (dphi &lt; 0)      dphi += twopi;</span>
<a name="4161"><span class="lineNum">    4161 </span><span class="lineNoCov">          0 :     return (dphi &lt;= _phispan);</span></a>
<span class="lineNum">    4162 </span>            :   }
<span class="lineNum">    4163 </span>            :   virtual string description() const {
<span class="lineNum">    4164 </span><span class="lineNoCov">          0 :     ostringstream ostr;</span>
<span class="lineNum">    4165 </span><span class="lineNoCov">          0 :     ostr &lt;&lt; _phimin &lt;&lt; &quot; &lt;= phi &lt;= &quot; &lt;&lt; _phimax;</span>
<a name="4166"><span class="lineNum">    4166 </span><span class="lineNoCov">          0 :     return ostr.str();</span></a>
<span class="lineNum">    4167 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    4168 </span><span class="lineNoCov">          0 :   virtual bool is_geometric() const { return true;}</span>
<span class="lineNum">    4169 </span>            : protected:
<span class="lineNum">    4170 </span>            :   double _phimin;   // the lower cut
<span class="lineNum">    4171 </span>            :   double _phimax;   // the upper cut
<a name="4172"><span class="lineNum">    4172 </span>            :   double _phispan;  // the span of the range</a>
<span class="lineNum">    4173 </span>            : };
<span class="lineNum">    4174 </span>            : Selector SelectorPhiRange(double phimin, double phimax) {
<a name="4175"><span class="lineNum">    4175 </span><span class="lineNoCov">          0 :   return Selector(new SW_PhiRange(phimin, phimax));</span></a>
<span class="lineNum">    4176 </span><span class="lineNoCov">          0 : }</span>
<a name="4177"><span class="lineNum">    4177 </span><span class="lineNoCov">          0 : class SW_RapPhiRange : public SW_And{</span></a>
<span class="lineNum">    4178 </span>            : public:
<span class="lineNum">    4179 </span>            :   SW_RapPhiRange(double rapmin, double rapmax, double phimin, double phimax)
<span class="lineNum">    4180 </span><span class="lineNoCov">          0 :     : SW_And(SelectorRapRange(rapmin, rapmax), SelectorPhiRange(phimin, phimax)){</span>
<a name="4181"><span class="lineNum">    4181 </span><span class="lineNoCov">          0 :     _known_area = ((phimax-phimin &gt; twopi) ? twopi : phimax-phimin) * (rapmax-rapmin);</span></a>
<span class="lineNum">    4182 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    4183 </span>            :   virtual double known_area() const{
<span class="lineNum">    4184 </span><span class="lineNoCov">          0 :     return _known_area;</span>
<span class="lineNum">    4185 </span>            :   }
<span class="lineNum">    4186 </span>            : protected:
<a name="4187"><span class="lineNum">    4187 </span>            :   double _known_area;</a>
<span class="lineNum">    4188 </span>            : };
<span class="lineNum">    4189 </span>            : Selector SelectorRapPhiRange(double rapmin, double rapmax, double phimin, double phimax) {
<a name="4190"><span class="lineNum">    4190 </span><span class="lineNoCov">          0 :   return Selector(new SW_RapPhiRange(rapmin, rapmax, phimin, phimax));</span></a>
<span class="lineNum">    4191 </span><span class="lineNoCov">          0 : }</span>
<a name="4192"><span class="lineNum">    4192 </span><span class="lineNoCov">          0 : class SW_NHardest : public SelectorWorker {</span></a>
<a name="4193"><span class="lineNum">    4193 </span>            : public:</a>
<span class="lineNum">    4194 </span><span class="lineNoCov">          0 :   SW_NHardest(unsigned int n) : _n(n) {};</span>
<span class="lineNum">    4195 </span>            :   virtual bool pass(const PseudoJet &amp;) const {
<span class="lineNum">    4196 </span><span class="lineNoCov">          0 :     if (!applies_jet_by_jet())</span>
<span class="lineNum">    4197 </span><span class="lineNoCov">          0 :       throw Error(&quot;Cannot apply this selector worker to an individual jet&quot;);</span>
<a name="4198"><span class="lineNum">    4198 </span><span class="lineNoCov">          0 :     return false;</span></a>
<span class="lineNum">    4199 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    4200 </span>            :   virtual void terminator(vector&lt;const PseudoJet *&gt; &amp; jets) const {
<span class="lineNum">    4201 </span><span class="lineNoCov">          0 :     if (jets.size() &lt; _n) return;</span>
<span class="lineNum">    4202 </span><span class="lineNoCov">          0 :     vector&lt;double&gt; minus_pt2(jets.size());</span>
<span class="lineNum">    4203 </span><span class="lineNoCov">          0 :     vector&lt;unsigned int&gt; indices(jets.size());</span>
<span class="lineNum">    4204 </span><span class="lineNoCov">          0 :     for (unsigned int i=0; i&lt;jets.size(); i++){</span>
<span class="lineNum">    4205 </span><span class="lineNoCov">          0 :       indices[i] = i;</span>
<span class="lineNum">    4206 </span><span class="lineNoCov">          0 :       minus_pt2[i] = jets[i] ? -jets[i]-&gt;perp2() : 0.0;</span>
<span class="lineNum">    4207 </span>            :     }
<span class="lineNum">    4208 </span><span class="lineNoCov">          0 :     IndexedSortHelper sort_helper(&amp; minus_pt2);</span>
<span class="lineNum">    4209 </span><span class="lineNoCov">          0 :     partial_sort(indices.begin(), indices.begin()+_n, indices.end(), sort_helper);</span>
<span class="lineNum">    4210 </span><span class="lineNoCov">          0 :     for (unsigned int i=_n; i&lt;jets.size(); i++)</span>
<a name="4211"><span class="lineNum">    4211 </span><span class="lineNoCov">          0 :       jets[indices[i]] = NULL;</span></a>
<a name="4212"><span class="lineNum">    4212 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    4213 </span><span class="lineNoCov">          0 :   virtual bool applies_jet_by_jet() const {return false;}</span>
<span class="lineNum">    4214 </span>            :   virtual string description() const {
<span class="lineNum">    4215 </span><span class="lineNoCov">          0 :     ostringstream ostr;</span>
<span class="lineNum">    4216 </span><span class="lineNoCov">          0 :     ostr &lt;&lt; _n &lt;&lt; &quot; hardest&quot;;</span>
<span class="lineNum">    4217 </span><span class="lineNoCov">          0 :     return ostr.str();</span>
<span class="lineNum">    4218 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    4219 </span>            : protected:
<a name="4220"><span class="lineNum">    4220 </span>            :   unsigned int _n;</a>
<span class="lineNum">    4221 </span>            : };
<span class="lineNum">    4222 </span>            : Selector SelectorNHardest(unsigned int n) {
<a name="4223"><span class="lineNum">    4223 </span><span class="lineNoCov">          0 :   return Selector(new SW_NHardest(n));</span></a>
<span class="lineNum">    4224 </span><span class="lineNoCov">          0 : }</span>
<a name="4225"><span class="lineNum">    4225 </span><span class="lineNoCov">          0 : class SW_WithReference : public SelectorWorker{</span></a>
<a name="4226"><span class="lineNum">    4226 </span>            : public:</a>
<a name="4227"><span class="lineNum">    4227 </span><span class="lineNoCov">          0 :   SW_WithReference() : _is_initialised(false){};</span></a>
<span class="lineNum">    4228 </span><span class="lineNoCov">          0 :   virtual bool takes_reference() const { return true;}</span>
<span class="lineNum">    4229 </span>            :   virtual void set_reference(const PseudoJet &amp;centre){
<span class="lineNum">    4230 </span><span class="lineNoCov">          0 :     _is_initialised = true;</span>
<span class="lineNum">    4231 </span><span class="lineNoCov">          0 :     _reference = centre;</span>
<span class="lineNum">    4232 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    4233 </span>            : protected:
<span class="lineNum">    4234 </span>            :   PseudoJet _reference;
<a name="4235"><span class="lineNum">    4235 </span>            :   bool _is_initialised;</a>
<span class="lineNum">    4236 </span>            : };
<a name="4237"><span class="lineNum">    4237 </span><span class="lineNoCov">          0 : class SW_Circle : public SW_WithReference {</span></a>
<a name="4238"><span class="lineNum">    4238 </span>            : public:</a>
<a name="4239"><span class="lineNum">    4239 </span><span class="lineNoCov">          0 :   SW_Circle(const double &amp;radius) : _radius2(radius*radius) {}</span></a>
<span class="lineNum">    4240 </span><span class="lineNoCov">          0 :   virtual SelectorWorker* copy(){ return new SW_Circle(*this);}</span>
<span class="lineNum">    4241 </span>            :   virtual bool pass(const PseudoJet &amp; jet) const {
<span class="lineNum">    4242 </span><span class="lineNoCov">          0 :     if (! _is_initialised)</span>
<span class="lineNum">    4243 </span><span class="lineNoCov">          0 :       throw Error(&quot;To use a SelectorCircle (or any selector that requires a reference), you first have to call set_reference(...)&quot;);</span>
<a name="4244"><span class="lineNum">    4244 </span><span class="lineNoCov">          0 :     return jet.squared_distance(_reference) &lt;= _radius2;</span></a>
<span class="lineNum">    4245 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    4246 </span>            :   virtual string description() const {
<span class="lineNum">    4247 </span><span class="lineNoCov">          0 :     ostringstream ostr;</span>
<span class="lineNum">    4248 </span><span class="lineNoCov">          0 :     ostr &lt;&lt; &quot;distance from the centre &lt;= &quot; &lt;&lt; sqrt(_radius2);</span>
<a name="4249"><span class="lineNum">    4249 </span><span class="lineNoCov">          0 :     return ostr.str();</span></a>
<span class="lineNum">    4250 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    4251 </span>            :   virtual void get_rapidity_extent(double &amp; rapmin, double &amp; rapmax) const{
<span class="lineNum">    4252 </span><span class="lineNoCov">          0 :     if (! _is_initialised)</span>
<span class="lineNum">    4253 </span><span class="lineNoCov">          0 :       throw Error(&quot;To use a SelectorCircle (or any selector that requires a reference), you first have to call set_reference(...)&quot;);</span>
<span class="lineNum">    4254 </span><span class="lineNoCov">          0 :     rapmax = _reference.rap()+sqrt(_radius2);</span>
<a name="4255"><span class="lineNum">    4255 </span><span class="lineNoCov">          0 :     rapmin = _reference.rap()-sqrt(_radius2);</span></a>
<a name="4256"><span class="lineNum">    4256 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="4257"><span class="lineNum">    4257 </span><span class="lineNoCov">          0 :   virtual bool is_geometric() const { return true;}    ///&lt; implies a finite area</span></a>
<a name="4258"><span class="lineNum">    4258 </span><span class="lineNoCov">          0 :   virtual bool has_finite_area() const { return true;} ///&lt; regardless of the reference</span></a>
<span class="lineNum">    4259 </span><span class="lineNoCov">          0 :   virtual bool has_known_area() const { return true;}  ///&lt; the area is analytically known</span>
<span class="lineNum">    4260 </span>            :   virtual double known_area() const {
<span class="lineNum">    4261 </span><span class="lineNoCov">          0 :     return pi * _radius2;</span>
<span class="lineNum">    4262 </span>            :   }
<span class="lineNum">    4263 </span>            : protected:
<a name="4264"><span class="lineNum">    4264 </span>            :   double _radius2;</a>
<span class="lineNum">    4265 </span>            : };
<span class="lineNum">    4266 </span>            : Selector SelectorCircle(const double &amp; radius) {
<a name="4267"><span class="lineNum">    4267 </span><span class="lineNoCov">          0 :   return Selector(new SW_Circle(radius));</span></a>
<span class="lineNum">    4268 </span><span class="lineNoCov">          0 : }</span>
<a name="4269"><span class="lineNum">    4269 </span><span class="lineNoCov">          0 : class SW_Doughnut : public SW_WithReference {</span></a>
<span class="lineNum">    4270 </span>            : public:
<a name="4271"><span class="lineNum">    4271 </span><span class="lineNoCov">          0 :   SW_Doughnut(const double &amp;radius_in, const double &amp;radius_out)</span></a>
<a name="4272"><span class="lineNum">    4272 </span><span class="lineNoCov">          0 :     : _radius_in2(radius_in*radius_in), _radius_out2(radius_out*radius_out) {}</span></a>
<span class="lineNum">    4273 </span><span class="lineNoCov">          0 :   virtual SelectorWorker* copy(){ return new SW_Doughnut(*this);}</span>
<span class="lineNum">    4274 </span>            :   virtual bool pass(const PseudoJet &amp; jet) const {
<span class="lineNum">    4275 </span><span class="lineNoCov">          0 :     if (! _is_initialised)</span>
<span class="lineNum">    4276 </span><span class="lineNoCov">          0 :       throw Error(&quot;To use a SelectorDoughnut (or any selector that requires a reference), you first have to call set_reference(...)&quot;);</span>
<span class="lineNum">    4277 </span><span class="lineNoCov">          0 :     double distance2 = jet.squared_distance(_reference);</span>
<a name="4278"><span class="lineNum">    4278 </span><span class="lineNoCov">          0 :     return (distance2 &lt;= _radius_out2) &amp;&amp; (distance2 &gt;= _radius_in2);</span></a>
<span class="lineNum">    4279 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    4280 </span>            :   virtual string description() const {
<span class="lineNum">    4281 </span><span class="lineNoCov">          0 :     ostringstream ostr;</span>
<span class="lineNum">    4282 </span><span class="lineNoCov">          0 :     ostr &lt;&lt; sqrt(_radius_in2) &lt;&lt; &quot; &lt;= distance from the centre &lt;= &quot; &lt;&lt; sqrt(_radius_out2);</span>
<a name="4283"><span class="lineNum">    4283 </span><span class="lineNoCov">          0 :     return ostr.str();</span></a>
<span class="lineNum">    4284 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    4285 </span>            :   virtual void get_rapidity_extent(double &amp; rapmin, double &amp; rapmax) const{
<span class="lineNum">    4286 </span><span class="lineNoCov">          0 :     if (! _is_initialised)</span>
<span class="lineNum">    4287 </span><span class="lineNoCov">          0 :       throw Error(&quot;To use a SelectorDoughnut (or any selector that requires a reference), you first have to call set_reference(...)&quot;);</span>
<span class="lineNum">    4288 </span><span class="lineNoCov">          0 :     rapmax = _reference.rap()+sqrt(_radius_out2);</span>
<a name="4289"><span class="lineNum">    4289 </span><span class="lineNoCov">          0 :     rapmin = _reference.rap()-sqrt(_radius_out2);</span></a>
<a name="4290"><span class="lineNum">    4290 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="4291"><span class="lineNum">    4291 </span><span class="lineNoCov">          0 :   virtual bool is_geometric() const { return true;}    ///&lt; implies a finite area</span></a>
<a name="4292"><span class="lineNum">    4292 </span><span class="lineNoCov">          0 :   virtual bool has_finite_area() const { return true;} ///&lt; regardless of the reference</span></a>
<span class="lineNum">    4293 </span><span class="lineNoCov">          0 :   virtual bool has_known_area() const { return true;}  ///&lt; the area is analytically known</span>
<span class="lineNum">    4294 </span>            :   virtual double known_area() const {
<span class="lineNum">    4295 </span><span class="lineNoCov">          0 :     return pi * (_radius_out2-_radius_in2);</span>
<span class="lineNum">    4296 </span>            :   }
<span class="lineNum">    4297 </span>            : protected:
<a name="4298"><span class="lineNum">    4298 </span>            :   double _radius_in2, _radius_out2;</a>
<span class="lineNum">    4299 </span>            : };
<span class="lineNum">    4300 </span>            : Selector SelectorDoughnut(const double &amp; radius_in, const double &amp; radius_out) {
<a name="4301"><span class="lineNum">    4301 </span><span class="lineNoCov">          0 :   return Selector(new SW_Doughnut(radius_in, radius_out));</span></a>
<span class="lineNum">    4302 </span><span class="lineNoCov">          0 : }</span>
<a name="4303"><span class="lineNum">    4303 </span><span class="lineNoCov">          0 : class SW_Strip : public SW_WithReference {</span></a>
<a name="4304"><span class="lineNum">    4304 </span>            : public:</a>
<a name="4305"><span class="lineNum">    4305 </span><span class="lineNoCov">          0 :   SW_Strip(const double &amp;delta) : _delta(delta) {}</span></a>
<span class="lineNum">    4306 </span><span class="lineNoCov">          0 :   virtual SelectorWorker* copy(){ return new SW_Strip(*this);}</span>
<span class="lineNum">    4307 </span>            :   virtual bool pass(const PseudoJet &amp; jet) const {
<span class="lineNum">    4308 </span><span class="lineNoCov">          0 :     if (! _is_initialised)</span>
<span class="lineNum">    4309 </span><span class="lineNoCov">          0 :       throw Error(&quot;To use a SelectorStrip (or any selector that requires a reference), you first have to call set_reference(...)&quot;);</span>
<a name="4310"><span class="lineNum">    4310 </span><span class="lineNoCov">          0 :     return abs(jet.rap()-_reference.rap()) &lt;= _delta;</span></a>
<span class="lineNum">    4311 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    4312 </span>            :   virtual string description() const {
<span class="lineNum">    4313 </span><span class="lineNoCov">          0 :     ostringstream ostr;</span>
<span class="lineNum">    4314 </span><span class="lineNoCov">          0 :     ostr &lt;&lt; &quot;|rap - rap_reference| &lt;= &quot; &lt;&lt; _delta;</span>
<a name="4315"><span class="lineNum">    4315 </span><span class="lineNoCov">          0 :     return ostr.str();</span></a>
<span class="lineNum">    4316 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    4317 </span>            :   virtual void get_rapidity_extent(double &amp; rapmin, double &amp; rapmax) const{
<span class="lineNum">    4318 </span><span class="lineNoCov">          0 :     if (! _is_initialised)</span>
<span class="lineNum">    4319 </span><span class="lineNoCov">          0 :       throw Error(&quot;To use a SelectorStrip (or any selector that requires a reference), you first have to call set_reference(...)&quot;);</span>
<span class="lineNum">    4320 </span><span class="lineNoCov">          0 :     rapmax = _reference.rap()+_delta;</span>
<a name="4321"><span class="lineNum">    4321 </span><span class="lineNoCov">          0 :     rapmin = _reference.rap()-_delta;</span></a>
<a name="4322"><span class="lineNum">    4322 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="4323"><span class="lineNum">    4323 </span><span class="lineNoCov">          0 :   virtual bool is_geometric() const { return true;}    ///&lt; implies a finite area</span></a>
<a name="4324"><span class="lineNum">    4324 </span><span class="lineNoCov">          0 :   virtual bool has_finite_area() const { return true;} ///&lt; regardless of the reference</span></a>
<span class="lineNum">    4325 </span><span class="lineNoCov">          0 :   virtual bool has_known_area() const { return true;}  ///&lt; the area is analytically known</span>
<span class="lineNum">    4326 </span>            :   virtual double known_area() const {
<span class="lineNum">    4327 </span><span class="lineNoCov">          0 :     return twopi * 2 * _delta;</span>
<span class="lineNum">    4328 </span>            :   }
<span class="lineNum">    4329 </span>            : protected:
<a name="4330"><span class="lineNum">    4330 </span>            :   double _delta;</a>
<span class="lineNum">    4331 </span>            : };
<span class="lineNum">    4332 </span>            : Selector SelectorStrip(const double &amp; half_width) {
<a name="4333"><span class="lineNum">    4333 </span><span class="lineNoCov">          0 :   return Selector(new SW_Strip(half_width));</span></a>
<span class="lineNum">    4334 </span><span class="lineNoCov">          0 : }</span>
<a name="4335"><span class="lineNum">    4335 </span><span class="lineNoCov">          0 : class SW_Rectangle : public SW_WithReference {</span></a>
<span class="lineNum">    4336 </span>            : public:
<a name="4337"><span class="lineNum">    4337 </span><span class="lineNoCov">          0 :   SW_Rectangle(const double &amp;delta_rap, const double &amp;delta_phi)</span></a>
<a name="4338"><span class="lineNum">    4338 </span><span class="lineNoCov">          0 :     : _delta_rap(delta_rap),  _delta_phi(delta_phi) {}</span></a>
<span class="lineNum">    4339 </span><span class="lineNoCov">          0 :   virtual SelectorWorker* copy(){ return new SW_Rectangle(*this);}</span>
<span class="lineNum">    4340 </span>            :   virtual bool pass(const PseudoJet &amp; jet) const {
<span class="lineNum">    4341 </span><span class="lineNoCov">          0 :     if (! _is_initialised)</span>
<span class="lineNum">    4342 </span><span class="lineNoCov">          0 :       throw Error(&quot;To use a SelectorRectangle (or any selector that requires a reference), you first have to call set_reference(...)&quot;);</span>
<a name="4343"><span class="lineNum">    4343 </span><span class="lineNoCov">          0 :     return (abs(jet.rap()-_reference.rap()) &lt;= _delta_rap) &amp;&amp; (abs(jet.delta_phi_to(_reference)) &lt;= _delta_phi);</span></a>
<span class="lineNum">    4344 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    4345 </span>            :   virtual string description() const {
<span class="lineNum">    4346 </span><span class="lineNoCov">          0 :     ostringstream ostr;</span>
<span class="lineNum">    4347 </span><span class="lineNoCov">          0 :     ostr &lt;&lt; &quot;|rap - rap_reference| &lt;= &quot; &lt;&lt; _delta_rap &lt;&lt; &quot; &amp;&amp; |phi - phi_reference| &lt;= &quot; &lt;&lt; _delta_phi ;</span>
<a name="4348"><span class="lineNum">    4348 </span><span class="lineNoCov">          0 :     return ostr.str();</span></a>
<span class="lineNum">    4349 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    4350 </span>            :   virtual void get_rapidity_extent(double &amp; rapmin, double &amp; rapmax) const{
<span class="lineNum">    4351 </span><span class="lineNoCov">          0 :     if (! _is_initialised)</span>
<span class="lineNum">    4352 </span><span class="lineNoCov">          0 :       throw Error(&quot;To use a SelectorRectangle (or any selector that requires a reference), you first have to call set_reference(...)&quot;);</span>
<span class="lineNum">    4353 </span><span class="lineNoCov">          0 :     rapmax = _reference.rap()+_delta_rap;</span>
<a name="4354"><span class="lineNum">    4354 </span><span class="lineNoCov">          0 :     rapmin = _reference.rap()-_delta_rap;</span></a>
<a name="4355"><span class="lineNum">    4355 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="4356"><span class="lineNum">    4356 </span><span class="lineNoCov">          0 :   virtual bool is_geometric() const { return true;}    ///&lt; implies a finite area</span></a>
<a name="4357"><span class="lineNum">    4357 </span><span class="lineNoCov">          0 :   virtual bool has_finite_area() const { return true;} ///&lt; regardless of the reference</span></a>
<span class="lineNum">    4358 </span><span class="lineNoCov">          0 :   virtual bool has_known_area() const { return true;}  ///&lt; the area is analytically known</span>
<span class="lineNum">    4359 </span>            :   virtual double known_area() const {
<span class="lineNum">    4360 </span><span class="lineNoCov">          0 :     return 4 * _delta_rap * _delta_phi;</span>
<span class="lineNum">    4361 </span>            :   }
<span class="lineNum">    4362 </span>            : protected:
<a name="4363"><span class="lineNum">    4363 </span>            :   double _delta_rap, _delta_phi;</a>
<span class="lineNum">    4364 </span>            : };
<span class="lineNum">    4365 </span>            : Selector SelectorRectangle(const double &amp; half_rap_width, const double &amp; half_phi_width) {
<a name="4366"><span class="lineNum">    4366 </span><span class="lineNoCov">          0 :   return Selector(new SW_Rectangle(half_rap_width, half_phi_width));</span></a>
<span class="lineNum">    4367 </span><span class="lineNoCov">          0 : }</span>
<a name="4368"><span class="lineNum">    4368 </span><span class="lineNoCov">          0 : class SW_PtFractionMin : public SW_WithReference {</span></a>
<a name="4369"><span class="lineNum">    4369 </span>            : public:</a>
<a name="4370"><span class="lineNum">    4370 </span><span class="lineNoCov">          0 :   SW_PtFractionMin(double fraction) : _fraction2(fraction*fraction){}</span></a>
<span class="lineNum">    4371 </span><span class="lineNoCov">          0 :   virtual SelectorWorker* copy(){ return new SW_PtFractionMin(*this);}</span>
<span class="lineNum">    4372 </span>            :   virtual bool pass(const PseudoJet &amp; jet) const {
<span class="lineNum">    4373 </span><span class="lineNoCov">          0 :     if (! _is_initialised)</span>
<span class="lineNum">    4374 </span><span class="lineNoCov">          0 :       throw Error(&quot;To use a SelectorPtFractionMin (or any selector that requires a reference), you first have to call set_reference(...)&quot;);</span>
<a name="4375"><span class="lineNum">    4375 </span><span class="lineNoCov">          0 :     return (jet.perp2() &gt;= _fraction2*_reference.perp2());</span></a>
<span class="lineNum">    4376 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    4377 </span>            :   virtual string description() const {
<span class="lineNum">    4378 </span><span class="lineNoCov">          0 :     ostringstream ostr;</span>
<span class="lineNum">    4379 </span><span class="lineNoCov">          0 :     ostr &lt;&lt; &quot;pt &gt;= &quot; &lt;&lt; sqrt(_fraction2) &lt;&lt; &quot;* pt_ref&quot;;</span>
<span class="lineNum">    4380 </span><span class="lineNoCov">          0 :     return ostr.str();</span>
<span class="lineNum">    4381 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    4382 </span>            : protected:
<a name="4383"><span class="lineNum">    4383 </span>            :   double _fraction2;</a>
<span class="lineNum">    4384 </span>            : };
<span class="lineNum">    4385 </span>            : Selector SelectorPtFractionMin(double fraction){
<a name="4386"><span class="lineNum">    4386 </span><span class="lineNoCov">          0 :   return Selector(new SW_PtFractionMin(fraction));</span></a>
<span class="lineNum">    4387 </span><span class="lineNoCov">          0 : }</span>
<a name="4388"><span class="lineNum">    4388 </span><span class="lineNoCov">          0 : class SW_IsZero : public SelectorWorker {</span></a>
<a name="4389"><span class="lineNum">    4389 </span>            : public:</a>
<span class="lineNum">    4390 </span><span class="lineNoCov">          0 :   SW_IsZero(){}</span>
<span class="lineNum">    4391 </span>            :   virtual bool pass(const PseudoJet &amp; jet) const {
<a name="4392"><span class="lineNum">    4392 </span><span class="lineNoCov">          0 :     return jet==0;</span></a>
<span class="lineNum">    4393 </span>            :   }
<a name="4394"><span class="lineNum">    4394 </span><span class="lineNoCov">          0 :   virtual string description() const { return &quot;zero&quot;;}</span></a>
<span class="lineNum">    4395 </span>            : };
<span class="lineNum">    4396 </span>            : Selector SelectorIsZero(){
<a name="4397"><span class="lineNum">    4397 </span><span class="lineNoCov">          0 :   return Selector(new SW_IsZero());</span></a>
<span class="lineNum">    4398 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4399 </span>            : Selector &amp; Selector::operator &amp;=(const Selector &amp; b){
<span class="lineNum">    4400 </span><span class="lineNoCov">          0 :   _worker.reset(new SW_And(*this, b));</span>
<a name="4401"><span class="lineNum">    4401 </span><span class="lineNoCov">          0 :   return *this;</span></a>
<span class="lineNum">    4402 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4403 </span>            : Selector &amp; Selector::operator |=(const Selector &amp; b){
<span class="lineNum">    4404 </span><span class="lineNoCov">          0 :   _worker.reset(new SW_Or(*this, b));</span>
<span class="lineNum">    4405 </span><span class="lineNoCov">          0 :   return *this;</span>
<span class="lineNum">    4406 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4407 </span>            : FJCORE_END_NAMESPACE      // defined in fastjet/internal/base.hh
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
