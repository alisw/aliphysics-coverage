<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - PYTHIA8/pythia8210dev/src/Basics.cc</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">PYTHIA8/pythia8210dev/src</a> - Basics.cc<span style="font-size: 80%;"> (source / <a href="Basics.cc.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">641</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-14 17:26:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">73</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // Basics.cc is a part of the PYTHIA event generator.</a>
<span class="lineNum">       2 </span>            : // Copyright (C) 2015 Torbjorn Sjostrand.
<span class="lineNum">       3 </span>            : // PYTHIA is licenced under the GNU GPL version 2, see COPYING for details.
<span class="lineNum">       4 </span>            : // Please respect the MCnet Guidelines, see GUIDELINES for details.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : // Function definitions (not found in the header) for the Rndm, Vec4,
<span class="lineNum">       7 </span>            : // RotBstMatrix and Hist classes, and some related global functions.
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;Pythia8/Basics.h&quot;
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : // Access time information.
<span class="lineNum">      12 </span>            : #include &lt;ctime&gt;
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : namespace Pythia8 {
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : //==========================================================================
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : // Rndm class.
<span class="lineNum">      19 </span>            : // This class handles random number generation according to the
<span class="lineNum">      20 </span>            : // Marsaglia-Zaman-Tsang algorithm
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : // Constants: could be changed here if desired, but normally should not.
<span class="lineNum">      25 </span>            : // These are of technical nature, as described for each.
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : // The default seed, i.e. the Marsaglia-Zaman random number sequence.
<span class="lineNum">      28 </span>            : const int Rndm::DEFAULTSEED     = 19780503;
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      31 </span>            : 
<a name="32"><span class="lineNum">      32 </span>            : // Method to pass in pointer for external random number generation.</a>
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : bool Rndm::rndmEnginePtr( RndmEngine* rndmEngPtrIn) {
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            :   // Save pointer.
<span class="lineNum">      37 </span><span class="lineNoCov">          0 :   if (rndmEngPtrIn == 0) return false;</span>
<span class="lineNum">      38 </span><span class="lineNoCov">          0 :   rndmEngPtr      = rndmEngPtrIn;</span>
<span class="lineNum">      39 </span><span class="lineNoCov">          0 :   useExternalRndm = true;</span>
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            :   // Done.
<span class="lineNum">      42 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      47 </span>            : 
<a name="48"><span class="lineNum">      48 </span>            : // Initialize, normally at construction or in first call.</a>
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            : void Rndm::init(int seedIn) {
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            :   // Pick seed in convenient way. Assure it to be non-negative.
<span class="lineNum">      53 </span>            :   int seed = seedIn;
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :   if (seedIn &lt; 0) seed = DEFAULTSEED;</span>
<span class="lineNum">      55 </span><span class="lineNoCov">          0 :   else if (seedIn == 0) seed = int(time(0));</span>
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :   if (seed &lt; 0) seed = -seed;</span>
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            :   // Unpack seed.
<span class="lineNum">      59 </span><span class="lineNoCov">          0 :   int ij = (seed/30082) % 31329;</span>
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :   int kl = seed % 30082;</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :   int i  = (ij/177) % 177 + 2;</span>
<span class="lineNum">      62 </span><span class="lineNoCov">          0 :   int j  = ij % 177 + 2;</span>
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :   int k  = (kl/169) % 178 + 1;</span>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :   int l  =  kl % 169;</span>
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            :   // Initialize random number array.
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :   for (int ii = 0; ii &lt; 97; ++ii) {</span>
<span class="lineNum">      68 </span>            :     double s = 0.;
<span class="lineNum">      69 </span>            :     double t = 0.5;
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :     for (int jj = 0; jj &lt; 48; ++jj) {</span>
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :       int m = (( (i*j)%179 )*k) % 179;</span>
<span class="lineNum">      72 </span>            :       i = j;
<span class="lineNum">      73 </span>            :       j = k;
<span class="lineNum">      74 </span>            :       k = m;
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :       l = (53*l+1) % 169;</span>
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :       if ( (l*m) % 64 &gt;= 32) s += t;</span>
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :       t *= 0.5;</span>
<span class="lineNum">      78 </span>            :     }
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :     u[ii] = s;</span>
<span class="lineNum">      80 </span>            :   }
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            :   // Initialize other variables.
<span class="lineNum">      83 </span>            :   double twom24 = 1.;
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :   for (int i24 = 0; i24 &lt; 24; ++i24) twom24 *= 0.5;</span>
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :   c   = 362436. * twom24;</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :   cd  = 7654321. * twom24;</span>
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :   cm  = 16777213. * twom24;</span>
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :   i97 = 96;</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :   j97 = 32;</span>
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            :   // Finished.
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :   initRndm  = true;</span>
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :   seedSave  = seed;</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :   sequence  = 0;</span>
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">      99 </span>            : 
<a name="100"><span class="lineNum">     100 </span>            : // Generate next random number uniformly between 0 and 1.</a>
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            : double Rndm::flat() {
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            :   // Use external random number generator if such has been linked.
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :   if (useExternalRndm) return rndmEngPtr-&gt;flat();</span>
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span>            :   // Ensure that already initialized.
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :   if (!initRndm) init(DEFAULTSEED);</span>
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span>            :   // Find next random number and update saved state.
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :   ++sequence;</span>
<span class="lineNum">     112 </span>            :   double uni;
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :   do {</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :     uni = u[i97] - u[j97];</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :     if (uni &lt; 0.) uni += 1.;</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :     u[i97] = uni;</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :     if (--i97 &lt; 0) i97 = 96;</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :     if (--j97 &lt; 0) j97 = 96;</span>
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :     c -= cd;</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :     if (c &lt; 0.) c += cm;</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :     uni -= c;</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :     if(uni &lt; 0.) uni += 1.;</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :    } while (uni &lt;= 0. || uni &gt;= 1.);</span>
<span class="lineNum">     124 </span>            :   return uni;
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     129 </span>            : 
<a name="130"><span class="lineNum">     130 </span>            : // Pick one option among  vector of (positive) probabilities.</a>
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            : int Rndm::pick(const vector&lt;double&gt;&amp; prob) {
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            :   double work = 0.;
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; int(prob.size()); ++i) work += prob[i];</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :   work *= flat();</span>
<span class="lineNum">     137 </span>            :   int index = -1;
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :   do work -= prob[++index];</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :   while (work &gt; 0. &amp;&amp; index &lt; int(prob.size()));</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :   return index;</span>
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            : }
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     145 </span>            : 
<a name="146"><span class="lineNum">     146 </span>            : // Save current state of the random number generator to a binary file.</a>
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            : bool Rndm::dumpState(string fileName) {
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span>            :   // Open file as output stream.
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :   const char* fn = fileName.c_str();</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :   ofstream ofs(fn, ios::binary);</span>
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :   if (!ofs.good()) {</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :     cout &lt;&lt; &quot; Rndm::dumpState: could not open output file&quot; &lt;&lt; endl;</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     157 </span>            :   }
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span>            :   // Write the state of the generator on the file.
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :   ofs.write((char *) &amp;seedSave, sizeof(int));</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :   ofs.write((char *) &amp;sequence, sizeof(long));</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :   ofs.write((char *) &amp;i97,      sizeof(int));</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :   ofs.write((char *) &amp;j97,      sizeof(int));</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :   ofs.write((char *) &amp;c,        sizeof(double));</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :   ofs.write((char *) &amp;cd,       sizeof(double));</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :   ofs.write((char *) &amp;cm,       sizeof(double));</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :   ofs.write((char *) &amp;u,        sizeof(double) * 97);</span>
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span>            :   // Write confirmation on cout.
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :   cout &lt;&lt; &quot; PYTHIA Rndm::dumpState: seed = &quot; &lt;&lt; seedSave</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :        &lt;&lt; &quot;, sequence no = &quot; &lt;&lt; sequence &lt;&lt; endl;</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     177 </span>            : 
<a name="178"><span class="lineNum">     178 </span>            : // Read in the state of the random number generator from a binary file.</a>
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span>            : bool Rndm::readState(string fileName) {
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            :   // Open file as input stream.
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :   const char* fn = fileName.c_str();</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :   ifstream ifs(fn, ios::binary);</span>
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :   if (!ifs.good()) {</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :     cout &lt;&lt; &quot; Rndm::readState: could not open input file&quot; &lt;&lt; endl;</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     189 </span>            :   }
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span>            :   // Read the state of the generator from the file.
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :   ifs.read((char *) &amp;seedSave, sizeof(int));</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :   ifs.read((char *) &amp;sequence, sizeof(long));</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :   ifs.read((char *) &amp;i97,      sizeof(int));</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :   ifs.read((char *) &amp;j97,      sizeof(int));</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :   ifs.read((char *) &amp;c,        sizeof(double));</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :   ifs.read((char *) &amp;cd,       sizeof(double));</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :   ifs.read((char *) &amp;cm,       sizeof(double));</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :   ifs.read((char *) &amp;u,        sizeof(double) *97);</span>
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            :   // Write confirmation on cout.
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :   cout &lt;&lt; &quot; PYTHIA Rndm::readState: seed &quot; &lt;&lt; seedSave</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :        &lt;&lt; &quot;, sequence no = &quot; &lt;&lt; sequence &lt;&lt; endl;</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span>            : //==========================================================================
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span>            : // Vec4 class.
<span class="lineNum">     211 </span>            : // This class implements four-vectors, in energy-momentum space.
<span class="lineNum">     212 </span>            : // (But could also be used to hold space-time four-vectors.)
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span>            : // Constants: could be changed here if desired, but normally should not.
<span class="lineNum">     217 </span>            : // These are of technical nature, as described for each.
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            : // Small number to avoid division by zero.
<span class="lineNum">     220 </span>            : const double Vec4::TINY = 1e-20;
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     223 </span>            : 
<a name="224"><span class="lineNum">     224 </span>            : // Rotation (simple).</a>
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            : void Vec4::rot(double thetaIn, double phiIn) {
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :   double cthe = cos(thetaIn);</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :   double sthe = sin(thetaIn);</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :   double cphi = cos(phiIn);</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :   double sphi = sin(phiIn);</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :   double tmpx =  cthe * cphi * xx -    sphi * yy + sthe * cphi * zz;</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :   double tmpy =  cthe * sphi * xx +    cphi * yy + sthe * sphi * zz;</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :   double tmpz = -sthe *        xx +                cthe *        zz;</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :   xx          = tmpx;</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :   yy          = tmpy;</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :   zz          = tmpz;</span>
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     242 </span>            : 
<a name="243"><span class="lineNum">     243 </span>            : // Azimuthal rotation phi around an arbitrary axis (nz, ny, nz).</a>
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            : void Vec4::rotaxis(double phiIn, double nx, double ny, double nz) {
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :   double norm = 1./sqrt(nx*nx + ny*ny + nz*nz);</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :   nx         *= norm;</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :   ny         *= norm;</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :   nz         *= norm;</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :   double cphi = cos(phiIn);</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :   double sphi = sin(phiIn);</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :   double comb = (nx * xx + ny * yy + nz * zz) * (1. - cphi);</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :   double tmpx = cphi * xx + comb * nx + sphi * (ny * zz - nz * yy);</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :   double tmpy = cphi * yy + comb * ny + sphi * (nz * xx - nx * zz);</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :   double tmpz = cphi * zz + comb * nz + sphi * (nx * yy - ny * xx);</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :   xx          = tmpx;</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :   yy          = tmpy;</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :   zz          = tmpz;</span>
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     264 </span>            : 
<a name="265"><span class="lineNum">     265 </span>            : // Azimuthal rotation phi around an arbitrary (3-vector component of) axis.</a>
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            : void Vec4::rotaxis(double phiIn, const Vec4&amp; n) {
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :   double nx   = n.xx;</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :   double ny   = n.yy;</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :   double nz   = n.zz;</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :   double norm = 1./sqrt(nx*nx + ny*ny + nz*nz);</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :   nx         *= norm;</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :   ny          *=norm;</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :   nz          *=norm;</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :   double cphi = cos(phiIn);</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :   double sphi = sin(phiIn);</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :   double comb = (nx * xx + ny * yy + nz * zz) * (1. - cphi);</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :   double tmpx = cphi * xx + comb * nx + sphi * (ny * zz - nz * yy);</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :   double tmpy = cphi * yy + comb * ny + sphi * (nz * xx - nx * zz);</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :   double tmpz = cphi * zz + comb * nz + sphi * (nx * yy - ny * xx);</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :   xx          = tmpx;</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :   yy          = tmpy;</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :   zz          = tmpz;</span>
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     289 </span>            : 
<a name="290"><span class="lineNum">     290 </span>            : // Boost (simple).</a>
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            : void Vec4::bst(double betaX, double betaY, double betaZ) {
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :   double beta2 = betaX*betaX + betaY*betaY + betaZ*betaZ;</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :   double gamma = 1. / sqrt(1. - beta2);</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :   double prod1 = betaX * xx + betaY * yy + betaZ * zz;</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :   double prod2 = gamma * (gamma * prod1 / (1. + gamma) + tt);</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :   xx += prod2 * betaX;</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :   yy += prod2 * betaY;</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :   zz += prod2 * betaZ;</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :   tt = gamma * (tt + prod1);</span>
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     306 </span>            : 
<a name="307"><span class="lineNum">     307 </span>            : // Boost (simple, given gamma).</a>
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span>            : void Vec4::bst(double betaX, double betaY, double betaZ, double gamma) {
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :   double prod1 = betaX * xx + betaY * yy + betaZ * zz;</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :   double prod2 = gamma * (gamma * prod1 / (1. + gamma) + tt);</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :   xx += prod2 * betaX;</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :   yy += prod2 * betaY;</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :   zz += prod2 * betaZ;</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :   tt = gamma * (tt + prod1);</span>
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     321 </span>            : 
<a name="322"><span class="lineNum">     322 </span>            : // Boost given by a Vec4 p.</a>
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span>            : void Vec4::bst(const Vec4&amp; pIn) {
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :   double betaX = pIn.xx / pIn.tt;</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :   double betaY = pIn.yy / pIn.tt;</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :   double betaZ = pIn.zz / pIn.tt;</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :   double beta2 = betaX*betaX + betaY*betaY + betaZ*betaZ;</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :   double gamma = 1. / sqrt(1. - beta2);</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :   double prod1 = betaX * xx + betaY * yy + betaZ * zz;</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :   double prod2 = gamma * (gamma * prod1 / (1. + gamma) + tt);</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :   xx          += prod2 * betaX;</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :   yy          += prod2 * betaY;</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :   zz          += prod2 * betaZ;</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :   tt           = gamma * (tt + prod1);</span>
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     341 </span>            : 
<a name="342"><span class="lineNum">     342 </span>            : // Boost given by a Vec4 p and double m.</a>
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span>            : void Vec4::bst(const Vec4&amp; pIn, double mIn) {
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :   double betaX = pIn.xx / pIn.tt;</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :   double betaY = pIn.yy / pIn.tt;</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :   double betaZ = pIn.zz / pIn.tt;</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :   double gamma = pIn.tt / mIn;</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :   double prod1 = betaX * xx + betaY * yy + betaZ * zz;</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :   double prod2 = gamma * (gamma * prod1 / (1. + gamma) + tt);</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :   xx          += prod2 * betaX;</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :   yy          += prod2 * betaY;</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :   zz          += prod2 * betaZ;</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :   tt           = gamma * (tt + prod1);</span>
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     360 </span>            : 
<a name="361"><span class="lineNum">     361 </span>            : // Boost given by a Vec4 p; boost in opposite direction.</a>
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span>            : void Vec4::bstback(const Vec4&amp; pIn) {
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :   double betaX = -pIn.xx / pIn.tt;</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :   double betaY = -pIn.yy / pIn.tt;</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :   double betaZ = -pIn.zz / pIn.tt;</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :   double beta2 = betaX*betaX + betaY*betaY + betaZ*betaZ;</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :   if(beta2 &gt;= 1.) beta2 = 0.9999;</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :   double gamma = 1. / sqrt(1. - beta2);</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :   double prod1 = betaX * xx + betaY * yy + betaZ * zz;</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :   double prod2 = gamma * (gamma * prod1 / (1. + gamma) + tt);</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :   xx          += prod2 * betaX;</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :   yy          += prod2 * betaY;</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :   zz          += prod2 * betaZ;</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :   tt           = gamma * (tt + prod1);</span>
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     381 </span>            : 
<a name="382"><span class="lineNum">     382 </span>            : // Boost given by a Vec4 p and double m; boost in opposite direction.</a>
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span>            : void Vec4::bstback(const Vec4&amp; pIn, double mIn) {
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :   double betaX = -pIn.xx / pIn.tt;</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :   double betaY = -pIn.yy / pIn.tt;</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :   double betaZ = -pIn.zz / pIn.tt;</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :   double gamma = pIn.tt / mIn;</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :   double prod1 = betaX * xx + betaY * yy + betaZ * zz;</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :   double prod2 = gamma * (gamma * prod1 / (1. + gamma) + tt);</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :   xx          += prod2 * betaX;</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :   yy          += prod2 * betaY;</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :   zz          += prod2 * betaZ;</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :   tt           = gamma * (tt + prod1);</span>
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     400 </span>            : 
<a name="401"><span class="lineNum">     401 </span>            : // Arbitrary combination of rotations and boosts defined by 4 * 4 matrix.</a>
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span>            : void Vec4::rotbst(const RotBstMatrix&amp; M) {
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :   double x = xx; double y = yy; double z = zz; double t = tt;</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :   tt = M.M[0][0] * t + M.M[0][1] * x + M.M[0][2] * y +  M.M[0][3] * z;</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :   xx = M.M[1][0] * t + M.M[1][1] * x + M.M[1][2] * y +  M.M[1][3] * z;</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :   yy = M.M[2][0] * t + M.M[2][1] * x + M.M[2][2] * y +  M.M[2][3] * z;</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :   zz = M.M[3][0] * t + M.M[3][1] * x + M.M[3][2] * y +  M.M[3][3] * z;</span>
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     414 </span>            : 
<a name="415"><span class="lineNum">     415 </span>            : // The invariant mass of two four-vectors.</a>
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span>            : double m(const Vec4&amp; v1, const Vec4&amp; v2) {
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :   double m2 = pow2(v1.tt + v2.tt) - pow2(v1.xx + v2.xx)</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :      - pow2(v1.yy + v2.yy) - pow2(v1.zz + v2.zz);</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :   return (m2 &gt; 0.) ? sqrt(m2) : 0.;</span>
<span class="lineNum">     421 </span>            : }
<span class="lineNum">     422 </span>            : 
<span class="lineNum">     423 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     424 </span>            : 
<a name="425"><span class="lineNum">     425 </span>            : // The squared invariant mass of two four-vectors.</a>
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span>            : double m2(const Vec4&amp; v1, const Vec4&amp; v2) {
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :   double m2 = pow2(v1.tt + v2.tt) - pow2(v1.xx + v2.xx)</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :      - pow2(v1.yy + v2.yy) - pow2(v1.zz + v2.zz);</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :   return m2;</span>
<span class="lineNum">     431 </span>            : }
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     434 </span>            : 
<a name="435"><span class="lineNum">     435 </span>            : // The scalar product of two three-vectors.</a>
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span>            : double dot3(const Vec4&amp; v1, const Vec4&amp; v2) {
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :   return v1.xx*v2.xx + v1.yy*v2.yy + v1.zz*v2.zz;</span>
<span class="lineNum">     439 </span>            : }
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     442 </span>            : 
<a name="443"><span class="lineNum">     443 </span>            : // The cross product of two three-vectors.</a>
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span>            : Vec4 cross3(const Vec4&amp; v1, const Vec4&amp; v2) {
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :   Vec4 v;</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :   v.xx = v1.yy * v2.zz - v1.zz * v2.yy;</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :   v.yy = v1.zz * v2.xx - v1.xx * v2.zz;</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :   v.zz = v1.xx * v2.yy - v1.yy * v2.xx; return v;</span>
<span class="lineNum">     450 </span>            : }
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     453 </span>            : 
<a name="454"><span class="lineNum">     454 </span>            : // Opening angle between two three-vectors.</a>
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span>            : double theta(const Vec4&amp; v1, const Vec4&amp; v2) {
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :   double cthe = (v1.xx * v2.xx + v1.yy * v2.yy + v1.zz * v2.zz)</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :     / sqrt( (v1.xx*v1.xx + v1.yy*v1.yy + v1.zz*v1.zz)</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :     * (v2.xx*v2.xx + v2.yy*v2.yy + v2.zz*v2.zz) );</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :   cthe = max(-1., min(1., cthe));</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :   return acos(cthe);</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     465 </span>            : 
<a name="466"><span class="lineNum">     466 </span>            : // Cosine of the opening angle between two three-vectors.</a>
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span>            : double costheta(const Vec4&amp; v1, const Vec4&amp; v2) {
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :   double cthe = 0;</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :   if( (v1.xx*v1.xx + v1.yy*v1.yy + v1.zz*v1.zz) &gt; 1e-06 &amp;&amp;  (v2.xx*v2.xx + v2.yy*v2.yy + v2.zz*v2.zz) &gt; 1e-06) {</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :     cthe = (v1.xx * v2.xx + v1.yy * v2.yy + v1.zz * v2.zz)</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :     / sqrt( (v1.xx*v1.xx + v1.yy*v1.yy + v1.zz*v1.zz)</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :     * (v2.xx*v2.xx + v2.yy*v2.yy + v2.zz*v2.zz) );</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :     cthe = max(-1., min(1., cthe));}</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :   return cthe;</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     479 </span>            : 
<a name="480"><span class="lineNum">     480 </span>            : // Azimuthal angle between two three-vectors.</a>
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span>            : double phi(const Vec4&amp; v1, const Vec4&amp; v2) {
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :   double cphi = (v1.xx * v2.xx + v1.yy * v2.yy) / sqrt( max( Vec4::TINY,</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :     (v1.xx*v1.xx + v1.yy*v1.yy) * (v2.xx*v2.xx + v2.yy*v2.yy) ));</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :   cphi = max(-1., min(1., cphi));</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :   return acos(cphi);</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     490 </span>            : 
<a name="491"><span class="lineNum">     491 </span>            : // Cosine of the azimuthal angle between two three-vectors.</a>
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span>            : double cosphi(const Vec4&amp; v1, const Vec4&amp; v2) {
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :   double cphi = (v1.xx * v2.xx + v1.yy * v2.yy) / sqrt( max( Vec4::TINY,</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :     (v1.xx*v1.xx + v1.yy*v1.yy) * (v2.xx*v2.xx + v2.yy*v2.yy) ));</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :   cphi = max(-1., min(1., cphi));</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :   return cphi;</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     501 </span>            : 
<a name="502"><span class="lineNum">     502 </span>            : // Azimuthal angle between two three-vectors around a third.</a>
<span class="lineNum">     503 </span>            : 
<span class="lineNum">     504 </span>            : double phi(const Vec4&amp; v1, const Vec4&amp; v2, const Vec4&amp; n) {
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :   double nx = n.xx; double ny = n.yy; double nz = n.zz;</span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :   double norm = 1. / sqrt(nx*nx + ny*ny + nz*nz);</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :   nx *= norm; ny *=norm; nz *=norm;</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :   double v1s = v1.xx * v1.xx + v1.yy * v1.yy + v1.zz * v1.zz;</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :   double v2s = v2.xx * v2.xx + v2.yy * v2.yy + v2.zz * v2.zz;</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :   double v1v2 = v1.xx * v2.xx + v1.yy * v2.yy + v1.zz * v2.zz;</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :   double v1n = v1.xx * nx + v1.yy * ny + v1.zz * nz;</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :   double v2n = v2.xx * nx + v2.yy * ny + v2.zz * nz;</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :   double cphi = (v1v2 - v1n * v2n) / sqrt( max( Vec4::TINY,</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :     (v1s - v1n*v1n) * (v2s - v2n*v2n) ));</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :   cphi = max(-1., min(1., cphi));</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :   return acos(cphi);</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     520 </span>            : 
<a name="521"><span class="lineNum">     521 </span>            : // Cosine of the azimuthal angle between two three-vectors around a third.</a>
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span>            : double cosphi(const Vec4&amp; v1, const Vec4&amp; v2, const Vec4&amp; n) {
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :   double nx = n.xx; double ny = n.yy; double nz = n.zz;</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :   double norm = 1. / sqrt(nx*nx + ny*ny + nz*nz);</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :   nx *= norm; ny *=norm; nz *=norm;</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :   double v1s = v1.xx * v1.xx + v1.yy * v1.yy + v1.zz * v1.zz;</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :   double v2s = v2.xx * v2.xx + v2.yy * v2.yy + v2.zz * v2.zz;</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :   double v1v2 = v1.xx * v2.xx + v1.yy * v2.yy + v1.zz * v2.zz;</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :   double v1n = v1.xx * nx + v1.yy * ny + v1.zz * nz;</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :   double v2n = v2.xx * nx + v2.yy * ny + v2.zz * nz;</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :   double cphi = (v1v2 - v1n * v2n) / sqrt( max( Vec4::TINY,</span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :     (v1s - v1n*v1n) * (v2s - v2n*v2n) ));</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :   cphi = max(-1., min(1., cphi));</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :   return cphi;</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     539 </span>            : 
<a name="540"><span class="lineNum">     540 </span>            : // Distance in cylindrical (y, phi) coordinates.</a>
<span class="lineNum">     541 </span>            : 
<span class="lineNum">     542 </span>            : double RRapPhi(const Vec4&amp; v1, const Vec4&amp; v2) {
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :   double dRap = abs(v1.rap() - v2.rap());</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :   double dPhi = abs(v1.phi() - v2.phi());</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :   if (dPhi &gt; M_PI) dPhi = 2. * M_PI - dPhi;</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :   return sqrt(dRap*dRap + dPhi*dPhi);</span>
<span class="lineNum">     547 </span>            : }
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     550 </span>            : 
<a name="551"><span class="lineNum">     551 </span>            : // Distance in cylindrical (eta, phi) coordinates.</a>
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span>            : double REtaPhi(const Vec4&amp; v1, const Vec4&amp; v2) {
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :   double dEta = abs(v1.eta() - v2.eta());</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :   double dPhi = abs(v1.phi() - v2.phi());</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :   if (dPhi &gt; M_PI) dPhi = 2. * M_PI - dPhi;</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :   return sqrt(dEta*dEta + dPhi*dPhi);</span>
<span class="lineNum">     558 </span>            : }
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     561 </span>            : 
<a name="562"><span class="lineNum">     562 </span>            : // Print a four-vector: also operator overloading with friend.</a>
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span>            : ostream&amp; operator&lt;&lt;(ostream&amp; os, const Vec4&amp; v) {
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :   os &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; &quot; &quot; &lt;&lt; setw(9) &lt;&lt; v.xx &lt;&lt; &quot; &quot;</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :      &lt;&lt; setw(9) &lt;&lt; v.yy &lt;&lt; &quot; &quot; &lt;&lt; setw(9) &lt;&lt; v.zz &lt;&lt; &quot; &quot; &lt;&lt; setw(9)</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :      &lt;&lt; v.tt &lt;&lt; &quot; (&quot; &lt;&lt; setw(9) &lt;&lt; v.mCalc() &lt;&lt; &quot;)\n&quot;;</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :   return os;</span>
<span class="lineNum">     569 </span>            : }
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span>            : //==========================================================================
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span>            : // RotBstMatrix class.
<span class="lineNum">     574 </span>            : // This class implements 4 * 4 matrices that encode an arbitrary combination
<span class="lineNum">     575 </span>            : // of rotations and boosts, that can be applied to Vec4 four-vectors.
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span>            : // Constants: could be changed here if desired, but normally should not.
<span class="lineNum">     580 </span>            : // These are of technical nature, as described for each.
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span>            : // Small number to avoid division by zero.
<span class="lineNum">     583 </span>            : const double RotBstMatrix::TINY = 1e-20;
<span class="lineNum">     584 </span>            : 
<span class="lineNum">     585 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     586 </span>            : 
<a name="587"><span class="lineNum">     587 </span>            : // Rotate by polar angle theta and azimuthal angle phi.</a>
<span class="lineNum">     588 </span>            : 
<span class="lineNum">     589 </span>            : void RotBstMatrix::rot(double theta, double phi) {
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span>            :   // Set up rotation matrix.
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :   double cthe = cos(theta);</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :   double sthe = sin(theta);</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :   double cphi = cos(phi);</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :   double sphi = sin(phi);</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :   double Mrot[4][4] = {</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :     {1.,           0.,         0.,          0.},</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :     {0.,  cthe * cphi,     - sphi, sthe * cphi},</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :     {0.,  cthe * sphi,       cphi, sthe * sphi},</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :     {0., -sthe,                0., cthe       } };</span>
<span class="lineNum">     601 </span>            : 
<span class="lineNum">     602 </span>            :   // Rotate current matrix accordingly.
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :   double Mtmp[4][4];</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; 4; ++i)</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :   for (int j = 0; j &lt; 4; ++j)</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :     Mtmp[i][j] = M[i][j];</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; 4; ++i)</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :   for (int j = 0; j &lt; 4; ++j)</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :     M[i][j] = Mrot[i][0] * Mtmp[0][j] + Mrot[i][1] * Mtmp[1][j]</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :             + Mrot[i][2] * Mtmp[2][j] + Mrot[i][3] * Mtmp[3][j];</span>
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     613 </span>            : 
<span class="lineNum">     614 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     615 </span>            : 
<a name="616"><span class="lineNum">     616 </span>            : // Rotate so that vector originally along z axis becomes parallel with p.</a>
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span>            : void RotBstMatrix::rot(const Vec4&amp; p) {
<span class="lineNum">     619 </span>            : 
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :   double theta = p.theta();</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :   double phi = p.phi();</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :   rot(0., -phi);</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :   rot(theta, phi);</span>
<span class="lineNum">     624 </span>            : 
<span class="lineNum">     625 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     626 </span>            : 
<span class="lineNum">     627 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     628 </span>            : 
<a name="629"><span class="lineNum">     629 </span>            : // Boost with velocity vector (betaX, betaY, betaZ).</a>
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span>            : void RotBstMatrix::bst(double betaX, double betaY, double betaZ) {
<span class="lineNum">     632 </span>            : 
<span class="lineNum">     633 </span>            :   // Set up boost matrix.
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :   double gm = 1. / sqrt( max( TINY, 1. - betaX*betaX - betaY*betaY</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :     - betaZ*betaZ ) );</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :   double gf = gm*gm / (1. + gm);</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :   double Mbst[4][4] = {</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :     { gm,           gm*betaX,           gm*betaY,          gm*betaZ },</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :     { gm*betaX, 1. + gf*betaX*betaX, gf*betaX*betaY, gf*betaX*betaZ },</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :     { gm*betaY, gf*betaY*betaX, 1. + gf*betaY*betaY, gf*betaY*betaZ },</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :     { gm*betaZ, gf*betaZ*betaX, gf*betaZ*betaY, 1. + gf*betaZ*betaZ } };</span>
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span>            :   // Boost current matrix correspondingly.
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :   double Mtmp[4][4];</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; 4; ++i)</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :   for (int j = 0; j &lt; 4; ++j)</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :     Mtmp[i][j] = M[i][j];</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; 4; ++i)</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :   for (int j = 0; j &lt; 4; ++j)</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :     M[i][j] = Mbst[i][0] * Mtmp[0][j] + Mbst[i][1] * Mtmp[1][j]</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :             + Mbst[i][2] * Mtmp[2][j] + Mbst[i][3] * Mtmp[3][j];</span>
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     654 </span>            : 
<span class="lineNum">     655 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     656 </span>            : 
<a name="657"><span class="lineNum">     657 </span>            : // Boost so that vector originally at rest obtains same velocity as p.</a>
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span>            : void RotBstMatrix::bst(const Vec4&amp; p) {
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :   double betaX = p.px() / p.e();</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :   double betaY = p.py() / p.e();</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :   double betaZ = p.pz() / p.e();</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :   bst(betaX, betaY, betaZ);</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     667 </span>            : 
<a name="668"><span class="lineNum">     668 </span>            : // Boost so vector originally with same velocity as p is brought to rest.</a>
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span>            : void RotBstMatrix::bstback(const Vec4&amp; p) {
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :   double betaX = -p.px() / p.e();</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :   double betaY = -p.py() / p.e();</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :   double betaZ = -p.pz() / p.e();</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :   bst(betaX, betaY, betaZ);</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     678 </span>            : 
<a name="679"><span class="lineNum">     679 </span>            : // Boost that transforms p1 to p2, where p1^2 = p2^2 is assumed.</a>
<span class="lineNum">     680 </span>            : 
<span class="lineNum">     681 </span>            : void RotBstMatrix::bst(const Vec4&amp; p1, const Vec4&amp; p2) {
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :   double eSum = p1.e() + p2.e();</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :   double betaX = (p2.px() - p1.px()) / eSum;</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :   double betaY = (p2.py() - p1.py()) / eSum;</span>
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :   double betaZ = (p2.pz() - p1.pz()) / eSum;</span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :   double fac = 2. / (1. + betaX*betaX + betaY*betaY + betaZ*betaZ);</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :   betaX *= fac; betaY *= fac; betaZ *= fac;</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :   bst(betaX, betaY, betaZ);</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     690 </span>            : 
<span class="lineNum">     691 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span>            : // Boost and rotation that transforms from p1 and p2
<a name="694"><span class="lineNum">     694 </span>            : // to their rest frame with p1 along +z axis.</a>
<span class="lineNum">     695 </span>            : 
<span class="lineNum">     696 </span>            : void RotBstMatrix::toCMframe(const Vec4&amp; p1, const Vec4&amp; p2) {
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :   Vec4 pSum = p1 + p2;</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :   Vec4 dir  = p1;</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :   dir.bstback(pSum);</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :   double theta = dir.theta();</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :   double phi   = dir.phi();</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :   bstback(pSum);</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :   rot(0., -phi);</span>
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :   rot(-theta, phi);</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span>            : // Rotation and boost that transforms from rest frame of p1 and p2
<a name="710"><span class="lineNum">     710 </span>            : // with p1 along +z axis to actual frame of p1 and p2. (Inverse of above.)</a>
<span class="lineNum">     711 </span>            : 
<span class="lineNum">     712 </span>            : void RotBstMatrix::fromCMframe(const Vec4&amp; p1, const Vec4&amp; p2) {
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :   Vec4 pSum = p1 + p2;</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :   Vec4 dir  = p1;</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :   dir.bstback(pSum);</span>
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :   double theta = dir.theta();</span>
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :   double phi   = dir.phi();</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :   rot(0., -phi);</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :   rot(theta, phi);</span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :   bst(pSum);</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     722 </span>            : 
<span class="lineNum">     723 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     724 </span>            : 
<a name="725"><span class="lineNum">     725 </span>            : // Combine existing rotation/boost matrix with another one.</a>
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span>            : void RotBstMatrix::rotbst(const RotBstMatrix&amp; Mrb) {
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :   double Mtmp[4][4];</span>
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; 4; ++i)</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :   for (int j = 0; j &lt; 4; ++j)</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :     Mtmp[i][j] = M[i][j];</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; 4; ++i)</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :   for (int j = 0; j &lt; 4; ++j)</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :     M[i][j] = Mrb.M[i][0] * Mtmp[0][j] + Mrb.M[i][1] * Mtmp[1][j]</span>
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :             + Mrb.M[i][2] * Mtmp[2][j] + Mrb.M[i][3] * Mtmp[3][j];</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     737 </span>            : 
<span class="lineNum">     738 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     739 </span>            : 
<a name="740"><span class="lineNum">     740 </span>            : // Invert the rotation and boost.</a>
<span class="lineNum">     741 </span>            : 
<span class="lineNum">     742 </span>            : void RotBstMatrix::invert() {
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :   double Mtmp[4][4];</span>
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; 4; ++i)</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :   for (int j = 0; j &lt; 4; ++j)</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :     Mtmp[i][j] = M[i][j];</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; 4; ++i)</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :   for (int j = 0; j &lt; 4; ++j)</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :     M[i][j] = ( (i == 0 &amp;&amp; j &gt; 0) || (i &gt; 0 &amp;&amp; j == 0) )</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :       ? - Mtmp[j][i] : Mtmp[j][i];</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     752 </span>            : 
<span class="lineNum">     753 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     754 </span>            : 
<a name="755"><span class="lineNum">     755 </span>            : // Reset to diagonal matrix.</a>
<span class="lineNum">     756 </span>            : 
<span class="lineNum">     757 </span>            : void RotBstMatrix::reset() {
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; 4; ++i)</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :   for (int j = 0; j &lt; 4; ++j)</span>
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :     M[i][j] = (i==j) ? 1. : 0.;</span>
<span class="lineNum">     761 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     764 </span>            : 
<a name="765"><span class="lineNum">     765 </span>            : // Crude estimate deviation from unit matrix.</a>
<span class="lineNum">     766 </span>            : 
<span class="lineNum">     767 </span>            : double RotBstMatrix::deviation() const {
<span class="lineNum">     768 </span>            :   double devSum = 0.;
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; 4; ++i)</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :   for (int j = 0; j &lt; 4; ++j)</span>
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :     devSum += (i==j) ? abs(M[i][j] - 1.) : abs(M[i][j]);</span>
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :   return devSum;</span>
<span class="lineNum">     773 </span>            : }
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     776 </span>            : 
<a name="777"><span class="lineNum">     777 </span>            : // Print a rotation and boost matrix: operator overloading with friend.</a>
<span class="lineNum">     778 </span>            : 
<span class="lineNum">     779 </span>            : ostream&amp; operator&lt;&lt;(ostream&amp; os, const RotBstMatrix&amp; M) {
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :   os &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; &quot;    Rotation/boost matrix: \n&quot;;</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt;4; ++i)</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :     os &lt;&lt; setw(10) &lt;&lt; M.M[i][0] &lt;&lt; setw(10) &lt;&lt; M.M[i][1]</span>
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :        &lt;&lt; setw(10) &lt;&lt; M.M[i][2] &lt;&lt; setw(10) &lt;&lt; M.M[i][3] &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :   return os;</span>
<span class="lineNum">     785 </span>            : }
<span class="lineNum">     786 </span>            : 
<span class="lineNum">     787 </span>            : //==========================================================================
<span class="lineNum">     788 </span>            : 
<span class="lineNum">     789 </span>            : // Hist class.
<span class="lineNum">     790 </span>            : // This class handles a single histogram at a time
<span class="lineNum">     791 </span>            : // (or a vector of histograms).
<span class="lineNum">     792 </span>            : 
<span class="lineNum">     793 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span>            : // Constants: could be changed here if desired, but normally should not.
<span class="lineNum">     796 </span>            : // These are of technical nature, as described for each.
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span>            : // Maximum number of bins in a histogram.
<span class="lineNum">     799 </span>            : const int    Hist::NBINMAX   = 1000;
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span>            : // Maximum number of columns that can be printed for a histogram.
<span class="lineNum">     802 </span>            : const int    Hist::NCOLMAX   = 100;
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span>            : // Maximum number of lines a histogram can use at output.
<span class="lineNum">     805 </span>            : const int    Hist::NLINES    = 30;
<span class="lineNum">     806 </span>            : 
<span class="lineNum">     807 </span>            : // Tolerance in deviation of xMin and xMax between two histograms.
<span class="lineNum">     808 </span>            : const double Hist::TOLERANCE = 0.001;
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span>            : // Small and large numbers to avoid division by zero and overflow.
<span class="lineNum">     811 </span>            : const double Hist::TINY      = 1e-20;
<span class="lineNum">     812 </span>            : const double Hist::LARGE     = 1e20;
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span>            : // When minbin/maxbin &lt; SMALLFRAC the y scale goes down to zero.
<span class="lineNum">     815 </span>            : const double Hist::SMALLFRAC = 0.1;
<span class="lineNum">     816 </span>            : 
<span class="lineNum">     817 </span>            : // Constants for printout: fixed steps on y scale; filling characters.
<span class="lineNum">     818 </span>            : const double DYAC[] = {0.04, 0.05, 0.06, 0.08, 0.10,
<span class="lineNum">     819 </span>            :   0.12, 0.15, 0.20, 0.25, 0.30};
<span class="lineNum">     820 </span>            : const char NUMBER[] = {'0', '1', '2', '3', '4', '5',
<span class="lineNum">     821 </span>            :   '6', '7', '8', '9', 'X' };
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     824 </span>            : 
<a name="825"><span class="lineNum">     825 </span>            : // Book a histogram.</a>
<span class="lineNum">     826 </span>            : 
<span class="lineNum">     827 </span>            : void Hist::book(string titleIn, int nBinIn, double xMinIn,
<span class="lineNum">     828 </span>            :   double xMaxIn) {
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :   title = titleIn;</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :   nBin  = nBinIn;</span>
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :   if (nBinIn &lt; 1) nBin = 1;</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :   if (nBinIn &gt; NBINMAX) nBin = NBINMAX;</span>
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :   xMin  = xMinIn;</span>
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :   xMax  = xMaxIn;</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :   dx    = (xMax - xMin)/nBin;</span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :   res.resize(nBin);</span>
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :   null();</span>
<span class="lineNum">     839 </span>            : 
<span class="lineNum">     840 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     843 </span>            : 
<a name="844"><span class="lineNum">     844 </span>            : // Reset bin contents.</a>
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span>            : void Hist::null() {
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :   nFill  = 0;</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :   under  = 0.;</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :   inside = 0.;</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :   over   = 0.;</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :   for (int ix = 0; ix &lt; nBin; ++ix) res[ix] = 0.;</span>
<span class="lineNum">     853 </span>            : 
<span class="lineNum">     854 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     855 </span>            : 
<span class="lineNum">     856 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     857 </span>            : 
<a name="858"><span class="lineNum">     858 </span>            : // Fill bin with weight.</a>
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span>            : void Hist::fill(double x, double w) {
<span class="lineNum">     861 </span>            : 
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :   ++nFill;</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :   int iBin = int(floor((x - xMin)/dx));</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :   if (iBin &lt; 0)          under += w;</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :   else if (iBin &gt;= nBin) over  += w;</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :   else                 {inside += w; res[iBin] += w; }</span>
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     869 </span>            : 
<span class="lineNum">     870 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">     871 </span>            : 
<a name="872"><span class="lineNum">     872 </span>            : // Print a histogram: also operator overloading with friend.</a>
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            : ostream&amp; operator&lt;&lt;(ostream&amp; os, const Hist&amp; h) {
<span class="lineNum">     875 </span>            : 
<span class="lineNum">     876 </span>            :   // Do not print empty histograms.
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :   if (h.nFill &lt;= 0) return os;</span>
<span class="lineNum">     878 </span>            : 
<span class="lineNum">     879 </span>            :   // Write time and title.
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :   time_t t = time(0);</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :   char date[18];</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :   strftime(date,18,&quot;%Y-%m-%d %H:%M&quot;,localtime(&amp;t));</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :   os &lt;&lt; &quot;\n\n  &quot; &lt;&lt; date &lt;&lt; &quot;       &quot; &lt;&lt; h.title &lt;&lt; &quot;\n\n&quot;;</span>
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span>            :   // Group bins, where required, to make printout have fewer columns.
<span class="lineNum">     886 </span>            :   // Avoid overflow.
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :   int nGroup = 1 + (h.nBin - 1) / Hist::NCOLMAX;</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :   int nCol   = 1 + (h.nBin - 1) / nGroup;</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :   vector&lt;double&gt; resCol(nCol);</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :   for (int iCol = 0; iCol &lt; nCol; ++iCol) {</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :     resCol[iCol] = 0.;</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :     for (int ix = nGroup * iCol; ix &lt; min( h.nBin, nGroup * (iCol + 1)); ++ix)</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :       resCol[iCol] += h.res[ix];</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :     resCol[iCol] = max( -Hist::LARGE, min( Hist::LARGE, resCol[iCol] ) );</span>
<span class="lineNum">     895 </span>            :   }
<span class="lineNum">     896 </span>            : 
<span class="lineNum">     897 </span>            :   // Find minimum and maximum bin content.
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :   double yMin = resCol[0];</span>
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :   double yMax = resCol[0];</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :   for (int iCol = 1; iCol &lt; nCol; ++iCol) {</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :     if (resCol[iCol] &lt; yMin) yMin = resCol[iCol];</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :     if (resCol[iCol] &gt; yMax) yMax = resCol[iCol];</span>
<span class="lineNum">     903 </span>            :   }
<span class="lineNum">     904 </span>            : 
<span class="lineNum">     905 </span>            :   // Determine scale and step size for y axis.
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :   if (yMax - yMin &gt; Hist::NLINES * DYAC[0] * 1e-9) {</span>
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :     if (yMin &gt; 0. &amp;&amp; yMin &lt; Hist::SMALLFRAC * yMax) yMin = 0.;</span>
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :     if (yMax &lt; 0. &amp;&amp; yMax &gt; Hist::SMALLFRAC * yMin) yMax = 0.;</span>
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :     int iPowY = int(floor( log10(yMax - yMin) ));</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :     if (yMax - yMin &lt; Hist::NLINES * DYAC[0] * pow(10.,iPowY))</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :       iPowY = iPowY - 1;</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :     if (yMax - yMin &gt; Hist::NLINES * DYAC[9] * pow(10.,iPowY))</span>
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :       iPowY = iPowY + 1;</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :     double nLinePow = Hist::NLINES * pow(10.,iPowY);</span>
<span class="lineNum">     915 </span>            :     double delY = DYAC[0];
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :     for (int idel = 0; idel &lt; 9; ++idel)</span>
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :       if (yMax - yMin &gt;= nLinePow * DYAC[idel]) delY = DYAC[idel+1];</span>
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :     double dy = delY * pow(10.,iPowY);</span>
<span class="lineNum">     919 </span>            : 
<span class="lineNum">     920 </span>            :     // Convert bin contents to integer form; fractional fill in top row.
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :     vector&lt;int&gt; row(nCol);</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :     vector&lt;int&gt; frac(nCol);</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :     for (int iCol = 0; iCol &lt; nCol ; ++iCol) {</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :       double cta = abs(resCol[iCol]) / dy;</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :       row[iCol] = int(cta + 0.95);</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :       if(resCol[iCol] &lt; 0.) row[iCol] = - row[iCol];</span>
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :       frac[iCol] = int(10. * (cta + 1.05 - floor(cta + 0.95)));</span>
<span class="lineNum">     928 </span>            :     }
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :     int rowMin = int(abs(yMin)/dy + 0.95);</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :     if ( yMin &lt; 0) rowMin = - rowMin;</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :     int rowMax = int(abs(yMax)/dy + 0.95);</span>
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :     if ( yMax &lt; 0) rowMax = - rowMax;</span>
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span>            :     // Print histogram row by row.
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :     os &lt;&lt; fixed &lt;&lt; setprecision(2);</span>
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :     for (int iRow = rowMax; iRow &gt;= rowMin; iRow--) if (iRow != 0) {</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :       os &lt;&lt; &quot;  &quot; &lt;&lt; setw(10) &lt;&lt; iRow*delY &lt;&lt; &quot;*10^&quot;</span>
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :          &lt;&lt; setw(2) &lt;&lt; iPowY &lt;&lt; &quot;  &quot;;</span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :       for (int iCol = 0; iCol &lt; nCol ; ++iCol) {</span>
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :         if (iRow == row[iCol])                  os &lt;&lt; NUMBER[frac[iCol]];</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :         else if (iRow * (row[iCol] - iRow) &gt; 0) os &lt;&lt; NUMBER[10];</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :         else                                    os &lt;&lt; &quot; &quot;;</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :       } os &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :     } os &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span>            :     // Print sign and value of bin contents
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :     double maxim = log10(max(yMax, -yMin));</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :     int iPowBin = int(floor(maxim + 0.0001));</span>
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :     os &lt;&lt; &quot;          Contents  &quot;;</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :     for (int iCol = 0; iCol &lt; nCol ; ++iCol) {</span>
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :       if (resCol[iCol] &lt; - pow(10., iPowBin - 4)) os &lt;&lt; &quot;-&quot;;</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :       else os &lt;&lt; &quot; &quot;;</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :       row[iCol] = int(abs(resCol[iCol]) * pow(10., 3 - iPowBin) + 0.5);</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :     } os &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :     for (int iRow = 3; iRow &gt;= 0; iRow--) {</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :       os &lt;&lt; &quot;            *10^&quot; &lt;&lt; setw(2) &lt;&lt; iPowBin + iRow - 3 &lt;&lt; &quot;  &quot;;</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :       int mask = int( pow(10., iRow) + 0.5);</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :       for (int iCol = 0; iCol &lt; nCol ; ++iCol) {</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :         os &lt;&lt; NUMBER[(row[iCol] / mask) % 10];</span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :       } os &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :     } os &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">     962 </span>            : 
<span class="lineNum">     963 </span>            :     // Print sign and value of lower bin edge.
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :     maxim = log10( max( -h.xMin, h.xMax - h.dx));</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :     int iPowExp = int(floor(maxim + 0.0001));</span>
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :     os &lt;&lt; &quot;          Low edge  &quot;;</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :     for (int iCol = 0; iCol &lt; nCol ; ++iCol) {</span>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :       if (h.xMin + iCol * nGroup * h.dx &lt; - pow(10., iPowExp - 3)) os &lt;&lt; &quot;-&quot;;</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :       else os &lt;&lt; &quot; &quot;;</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :       row[iCol] = int(abs(h.xMin + iCol * nGroup * h.dx)</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :         * pow(10., 2 - iPowExp) + 0.5);</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :     } os &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :     for (int iRow = 2; iRow &gt;= 0; iRow--) {</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :       os &lt;&lt; &quot;            *10^&quot; &lt;&lt; setw(2) &lt;&lt; iPowExp + iRow - 2 &lt;&lt; &quot;  &quot;;</span>
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :       int mask = int( pow(10., iRow) + 0.5);</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :       for (int iCol = 0; iCol &lt; nCol ; ++iCol)</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :         os &lt;&lt; NUMBER[(row[iCol] / mask) % 10];</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :       os &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :     } os &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">     980 </span>            : 
<span class="lineNum">     981 </span>            :   // Print explanation if histogram cannot be shown.
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :   } else os &lt;&lt; &quot;     Histogram not shown since lowest value&quot; &lt;&lt; scientific</span>
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :        &lt;&lt; setprecision(4) &lt;&lt; setw(12) &lt;&lt; yMin &lt;&lt; &quot; and highest value&quot;</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :        &lt;&lt; setw(12) &lt;&lt; yMax &lt;&lt; &quot; are too close \n \n&quot;;</span>
<span class="lineNum">     985 </span>            : 
<span class="lineNum">     986 </span>            :   // Calculate and print statistics.
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :   double cSum   = 0.;</span>
<span class="lineNum">     988 </span>            :   double cxSum  = 0.;
<span class="lineNum">     989 </span>            :   double cxxSum = 0.;
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :   for (int ix = 0; ix &lt; h.nBin ; ++ix) {</span>
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :     double cta = abs(h.res[ix]);</span>
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :     double x = h.xMin + (ix + 0.5) * h.dx;</span>
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :     cSum   = cSum   + cta;</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :     cxSum  = cxSum  + cta * x;</span>
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :     cxxSum = cxxSum + cta * x * x;</span>
<span class="lineNum">     996 </span>            :   }
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :   double xmean = cxSum / max(cSum, Hist::TINY);</span>
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :   double rms = sqrtpos( cxxSum / max(cSum, Hist::TINY) - xmean*xmean );</span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :   os &lt;&lt; scientific &lt;&lt; setprecision(4)</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :      &lt;&lt; &quot;   Entries  =&quot; &lt;&lt; setw(12) &lt;&lt; h.nFill</span>
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :      &lt;&lt; &quot;    Mean =&quot; &lt;&lt; setw(12) &lt;&lt; xmean</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :      &lt;&lt; &quot;    Underflow =&quot; &lt;&lt; setw(12) &lt;&lt; h.under</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :      &lt;&lt; &quot;    Low edge  =&quot; &lt;&lt; setw(12) &lt;&lt; h.xMin &lt;&lt; &quot;\n&quot;</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :      &lt;&lt; &quot;   All chan =&quot; &lt;&lt; setw(12) &lt;&lt; h.inside</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :      &lt;&lt; &quot;    Rms  =&quot; &lt;&lt; setw(12) &lt;&lt; rms</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :      &lt;&lt; &quot;    Overflow  =&quot; &lt;&lt; setw(12) &lt;&lt; h.over</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :      &lt;&lt; &quot;    High edge =&quot; &lt;&lt; setw(12) &lt;&lt; h.xMax &lt;&lt; endl;</span>
<span class="lineNum">    1008 </span>            :   return os;
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1010 </span>            : 
<span class="lineNum">    1011 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1012 </span>            : 
<a name="1013"><span class="lineNum">    1013 </span>            : // Print histogram contents as a table (e.g. for Gnuplot).</a>
<span class="lineNum">    1014 </span>            : 
<span class="lineNum">    1015 </span>            : void Hist::table(ostream&amp; os, bool printOverUnder, bool xMidBin) const {
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span>            :   // Print histogram vector bin by bin, with mean x as first column.
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :   os &lt;&lt; scientific &lt;&lt; setprecision(4);</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :   double xBeg = (xMidBin) ? xMin + 0.5 * dx : xMin;</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :   if (printOverUnder)</span>
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :     os &lt;&lt; setw(12) &lt;&lt; xBeg - dx &lt;&lt; setw(12) &lt;&lt; under &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :   for (int ix = 0; ix &lt; nBin; ++ix)</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :     os &lt;&lt; setw(12) &lt;&lt; xBeg + ix * dx &lt;&lt; setw(12) &lt;&lt; res[ix] &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :   if (printOverUnder)</span>
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :     os &lt;&lt; setw(12) &lt;&lt; xBeg + nBin * dx &lt;&lt; setw(12) &lt;&lt; over &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">    1026 </span>            : 
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1028 </span>            : 
<span class="lineNum">    1029 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1030 </span>            : 
<a name="1031"><span class="lineNum">    1031 </span>            : // Print a table out of two histograms with same x axis  (e.g. for Gnuplot).</a>
<span class="lineNum">    1032 </span>            : 
<span class="lineNum">    1033 </span>            : void table(const Hist&amp; h1, const Hist&amp; h2, ostream&amp; os, bool printOverUnder,
<span class="lineNum">    1034 </span>            :   bool xMidBin) {
<span class="lineNum">    1035 </span>            : 
<span class="lineNum">    1036 </span>            :   // Require histogram x axes to agree.
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :   if (h1.nBin != h2.nBin || abs(h1.xMin - h2.xMin) &gt; Hist::TOLERANCE * h1.dx</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :     || abs(h1.xMax - h2.xMax) &gt; Hist::TOLERANCE * h1.dx) return;</span>
<span class="lineNum">    1039 </span>            : 
<span class="lineNum">    1040 </span>            :   // Print histogram vectors bin by bin, with mean x as first column.
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :   os &lt;&lt; scientific &lt;&lt; setprecision(4);</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :   double xBeg = (xMidBin) ? h1.xMin + 0.5 * h1.dx : h1.xMin;</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :   if (printOverUnder)</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :     os &lt;&lt; setw(12) &lt;&lt; xBeg - h1.dx &lt;&lt; setw(12) &lt;&lt; h1.under</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :        &lt;&lt; setw(12) &lt;&lt; h2.under &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :   for (int ix = 0; ix &lt; h1.nBin; ++ix)</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :     os &lt;&lt; setw(12) &lt;&lt; xBeg + ix * h1.dx &lt;&lt; setw(12) &lt;&lt; h1.res[ix]</span>
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :        &lt;&lt; setw(12) &lt;&lt; h2.res[ix] &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :   if (printOverUnder)</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :     os &lt;&lt; setw(12) &lt;&lt; xBeg + h1.nBin * h1.dx &lt;&lt; setw(12) &lt;&lt; h1.over</span>
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :        &lt;&lt; setw(12) &lt;&lt; h2.over &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">    1052 </span>            : 
<a name="1053"><span class="lineNum">    1053 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1054 </span>            : 
<span class="lineNum">    1055 </span>            : void table(const Hist&amp; h1, const Hist&amp; h2, string fileName,
<span class="lineNum">    1056 </span>            :   bool printOverUnder, bool xMidBin) {
<span class="lineNum">    1057 </span>            : 
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :   ofstream streamName(fileName.c_str());</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :   table( h1, h2, streamName, printOverUnder, xMidBin);</span>
<span class="lineNum">    1060 </span>            : 
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1062 </span>            : 
<span class="lineNum">    1063 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1064 </span>            : 
<span class="lineNum">    1065 </span>            : // Get content of specific bin.
<span class="lineNum">    1066 </span>            : // Special values are bin 0 for underflow and bin nBin+1 for overflow.
<a name="1067"><span class="lineNum">    1067 </span>            : // All other bins outside proper histogram range return 0.</a>
<span class="lineNum">    1068 </span>            : 
<span class="lineNum">    1069 </span>            : double Hist::getBinContent(int iBin) const {
<span class="lineNum">    1070 </span>            : 
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :   if (iBin &gt; 0 &amp;&amp; iBin &lt;= nBin) return res[iBin - 1];</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :   else if (iBin == 0)           return under;</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :   else if (iBin == nBin + 1)    return over;</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :   else                          return 0.;</span>
<span class="lineNum">    1075 </span>            : 
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1079 </span>            : 
<a name="1080"><span class="lineNum">    1080 </span>            : // Check whether another histogram has same size and limits.</a>
<span class="lineNum">    1081 </span>            : 
<span class="lineNum">    1082 </span>            : bool Hist::sameSize(const Hist&amp; h) const {
<span class="lineNum">    1083 </span>            : 
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :   if (nBin == h.nBin &amp;&amp; abs(xMin - h.xMin) &lt; TOLERANCE * dx &amp;&amp;</span>
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :     abs(xMax - h.xMax) &lt; TOLERANCE * dx) return true;</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :   else return false;</span>
<span class="lineNum">    1087 </span>            : 
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1089 </span>            : 
<span class="lineNum">    1090 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1091 </span>            : 
<a name="1092"><span class="lineNum">    1092 </span>            : // Take 10-logarithm or natural logarithm of contents bin by bin.</a>
<span class="lineNum">    1093 </span>            : 
<span class="lineNum">    1094 </span>            : void Hist::takeLog(bool tenLog) {
<span class="lineNum">    1095 </span>            : 
<span class="lineNum">    1096 </span>            :   // Find smallest positive bin content, and put min a bit below.
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :   double yMin = Hist::LARGE;</span>
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :   for (int ix = 0; ix &lt; nBin; ++ix)</span>
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :     if (res[ix] &gt; Hist::TINY &amp;&amp; res[ix] &lt; yMin ) yMin = res[ix];</span>
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :   yMin *= 0.8;</span>
<span class="lineNum">    1101 </span>            : 
<span class="lineNum">    1102 </span>            :   // Take 10-logarithm bin by bin, but ensure positivity.
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :   if (tenLog) {</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :     for (int ix = 0; ix &lt; nBin; ++ix)</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :       res[ix] = log10( max( yMin, res[ix]) );</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :     under  =  log10( max( yMin, under) );</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :     inside =  log10( max( yMin, inside) );</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :     over   =  log10( max( yMin, over) );</span>
<span class="lineNum">    1109 </span>            : 
<span class="lineNum">    1110 </span>            :   // Take natural logarithm bin by bin, but ensure positivity.
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :     for (int ix = 0; ix &lt; nBin; ++ix)</span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :       res[ix] = log( max( yMin, res[ix]) );</span>
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :     under  =  log( max( yMin, under) );</span>
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :     inside =  log( max( yMin, inside) );</span>
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :     over   =  log( max( yMin, over) );</span>
<span class="lineNum">    1117 </span>            :   }
<span class="lineNum">    1118 </span>            : 
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1120 </span>            : 
<span class="lineNum">    1121 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1122 </span>            : 
<a name="1123"><span class="lineNum">    1123 </span>            : // Take square root of contents bin by bin; set 0 for negative content.</a>
<span class="lineNum">    1124 </span>            : 
<span class="lineNum">    1125 </span>            : void Hist::takeSqrt() {
<span class="lineNum">    1126 </span>            : 
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :   for (int ix = 0; ix &lt; nBin; ++ix) res[ix] = sqrtpos(res[ix]);</span>
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :   under  = sqrtpos(under);</span>
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :   inside = sqrtpos(inside);</span>
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :   over   = sqrtpos(over);</span>
<span class="lineNum">    1131 </span>            : 
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1133 </span>            : 
<span class="lineNum">    1134 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1135 </span>            : 
<a name="1136"><span class="lineNum">    1136 </span>            : // Add histogram to existing one.</a>
<span class="lineNum">    1137 </span>            : 
<span class="lineNum">    1138 </span>            : Hist&amp; Hist::operator+=(const Hist&amp; h) {
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :   if (!sameSize(h)) return *this;</span>
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :   nFill  += h.nFill;</span>
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :   under  += h.under;</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :   inside += h.inside;</span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :   over += h.over;</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :   for (int ix = 0; ix &lt; nBin; ++ix) res[ix] += h.res[ix];</span>
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :   return *this;</span>
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1147 </span>            : 
<span class="lineNum">    1148 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1149 </span>            : 
<a name="1150"><span class="lineNum">    1150 </span>            : // Subtract histogram from existing one.</a>
<span class="lineNum">    1151 </span>            : 
<span class="lineNum">    1152 </span>            : Hist&amp; Hist::operator-=(const Hist&amp; h) {
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :   if (!sameSize(h)) return *this;</span>
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :   nFill  += h.nFill;</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :   under  -= h.under;</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :   inside -= h.inside;</span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :   over -= h.over;</span>
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :   for (int ix = 0; ix &lt; nBin; ++ix) res[ix] -= h.res[ix];</span>
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :   return *this;</span>
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1161 </span>            : 
<span class="lineNum">    1162 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1163 </span>            : 
<a name="1164"><span class="lineNum">    1164 </span>            : // Multiply existing histogram by another one.</a>
<span class="lineNum">    1165 </span>            : 
<span class="lineNum">    1166 </span>            : Hist&amp; Hist::operator*=(const Hist&amp; h) {
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :   if (!sameSize(h)) return *this;</span>
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :   nFill   += h.nFill;</span>
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :   under  *= h.under;</span>
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :   inside *= h.inside;</span>
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :   over *= h.over;</span>
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :   for (int ix = 0; ix &lt; nBin; ++ix) res[ix] *= h.res[ix];</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :   return *this;</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1175 </span>            : 
<span class="lineNum">    1176 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1177 </span>            : 
<a name="1178"><span class="lineNum">    1178 </span>            : // Divide existing histogram by another one.</a>
<span class="lineNum">    1179 </span>            : 
<span class="lineNum">    1180 </span>            : Hist&amp; Hist::operator/=(const Hist&amp; h) {
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :   if (!sameSize(h)) return *this;</span>
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :   nFill += h.nFill;</span>
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :   under  = (abs(h.under) &lt; Hist::TINY) ? 0. : under/h.under;</span>
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :   inside = (abs(h.inside) &lt; Hist::TINY) ? 0. : inside/h.inside;</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :   over  = (abs(h.over) &lt; Hist::TINY) ? 0. : over/h.over;</span>
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :   for (int ix = 0; ix &lt; nBin; ++ix)</span>
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :     res[ix] = (abs(h.res[ix]) &lt; Hist::TINY) ? 0. : res[ix]/h.res[ix];</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :   return *this;</span>
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1190 </span>            : 
<span class="lineNum">    1191 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1192 </span>            : 
<a name="1193"><span class="lineNum">    1193 </span>            : // Add constant offset to histogram.</a>
<span class="lineNum">    1194 </span>            : 
<span class="lineNum">    1195 </span>            : Hist&amp; Hist::operator+=(double f) {
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :   under  += f;</span>
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :   inside += nBin * f;</span>
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :   over   += f;</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :   for (int ix = 0; ix &lt; nBin; ++ix) res[ix] += f;</span>
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :   return *this;</span>
<span class="lineNum">    1201 </span>            : }
<span class="lineNum">    1202 </span>            : 
<span class="lineNum">    1203 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1204 </span>            : 
<a name="1205"><span class="lineNum">    1205 </span>            : // Subtract constant offset from histogram.</a>
<span class="lineNum">    1206 </span>            : 
<span class="lineNum">    1207 </span>            : Hist&amp; Hist::operator-=(double f) {
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :   under  -= f;</span>
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :   inside -= nBin * f;</span>
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :   over   -= f;</span>
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :   for (int ix = 0; ix &lt; nBin; ++ix) res[ix] -= f;</span>
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :   return *this;</span>
<span class="lineNum">    1213 </span>            : }
<span class="lineNum">    1214 </span>            : 
<span class="lineNum">    1215 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1216 </span>            : 
<a name="1217"><span class="lineNum">    1217 </span>            : // Multiply histogram by constant.</a>
<span class="lineNum">    1218 </span>            : 
<span class="lineNum">    1219 </span>            : Hist&amp; Hist::operator*=(double f) {
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 :   under  *= f;</span>
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :   inside *= f;</span>
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :   over   *= f;</span>
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :   for (int ix = 0; ix &lt; nBin; ++ix) res[ix] *= f;</span>
<span class="lineNum">    1224 </span><span class="lineNoCov">          0 :   return *this;</span>
<span class="lineNum">    1225 </span>            : }
<span class="lineNum">    1226 </span>            : 
<span class="lineNum">    1227 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1228 </span>            : 
<a name="1229"><span class="lineNum">    1229 </span>            : // Divide histogram by constant.</a>
<span class="lineNum">    1230 </span>            : 
<span class="lineNum">    1231 </span>            : Hist&amp; Hist::operator/=(double f) {
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :   if (abs(f) &gt; Hist::TINY) {</span>
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :     under  /= f;</span>
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :     inside /= f;</span>
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :     over   /= f;</span>
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 :     for (int ix = 0; ix &lt; nBin; ++ix) res[ix] /= f;</span>
<span class="lineNum">    1237 </span>            :   // Set empty contents when division by zero.
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :   } else {</span>
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :     under  = 0.;</span>
<span class="lineNum">    1240 </span><span class="lineNoCov">          0 :     inside = 0.;</span>
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :     over   = 0.;</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :     for (int ix = 0; ix &lt; nBin; ++ix) res[ix] = 0.;</span>
<span class="lineNum">    1243 </span>            :   }
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 :   return *this;</span>
<span class="lineNum">    1245 </span>            : }
<span class="lineNum">    1246 </span>            : 
<span class="lineNum">    1247 </span>            : //--------------------------------------------------------------------------
<span class="lineNum">    1248 </span>            : 
<a name="1249"><span class="lineNum">    1249 </span>            : // Implementation of operator overloading with friends.</a>
<span class="lineNum">    1250 </span>            : 
<span class="lineNum">    1251 </span>            : Hist operator+(double f, const Hist&amp; h1) {
<a name="1252"><span class="lineNum">    1252 </span><span class="lineNoCov">          0 :   Hist h = h1; return h += f;}</span></a>
<span class="lineNum">    1253 </span>            : 
<span class="lineNum">    1254 </span>            : Hist operator+(const Hist&amp; h1, double f) {
<a name="1255"><span class="lineNum">    1255 </span><span class="lineNoCov">          0 :   Hist h = h1; return h += f;}</span></a>
<span class="lineNum">    1256 </span>            : 
<span class="lineNum">    1257 </span>            : Hist operator+(const Hist&amp; h1, const Hist&amp; h2) {
<a name="1258"><span class="lineNum">    1258 </span><span class="lineNoCov">          0 :   Hist h = h1; return h += h2;}</span></a>
<span class="lineNum">    1259 </span>            : 
<span class="lineNum">    1260 </span>            : Hist operator-(double f, const Hist&amp; h1) {
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :   Hist h   = h1;</span>
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :   h.under  = f - h1.under;</span>
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :   h.inside = h1.nBin * f - h1.inside;</span>
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :   h.over   = f - h1.over;</span>
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :   for (int ix = 0; ix &lt; h1.nBin; ++ix) h.res[ix] = f - h1.res[ix];</span>
<a name="1266"><span class="lineNum">    1266 </span><span class="lineNoCov">          0 :   return h;}</span></a>
<span class="lineNum">    1267 </span>            : 
<span class="lineNum">    1268 </span>            : Hist operator-(const Hist&amp; h1, double f) {
<a name="1269"><span class="lineNum">    1269 </span><span class="lineNoCov">          0 :   Hist h = h1; return h -= f;}</span></a>
<span class="lineNum">    1270 </span>            : 
<span class="lineNum">    1271 </span>            : Hist operator-(const Hist&amp; h1, const Hist&amp; h2) {
<a name="1272"><span class="lineNum">    1272 </span><span class="lineNoCov">          0 :   Hist h = h1; return h -= h2;}</span></a>
<span class="lineNum">    1273 </span>            : 
<span class="lineNum">    1274 </span>            : Hist operator*(double f, const Hist&amp; h1) {
<a name="1275"><span class="lineNum">    1275 </span><span class="lineNoCov">          0 :   Hist h = h1; return h *= f;}</span></a>
<span class="lineNum">    1276 </span>            : 
<span class="lineNum">    1277 </span>            : Hist operator*(const Hist&amp; h1, double f) {
<a name="1278"><span class="lineNum">    1278 </span><span class="lineNoCov">          0 :   Hist h = h1; return h *= f;}</span></a>
<span class="lineNum">    1279 </span>            : 
<span class="lineNum">    1280 </span>            : Hist operator*(const Hist&amp; h1, const Hist&amp; h2) {
<a name="1281"><span class="lineNum">    1281 </span><span class="lineNoCov">          0 :   Hist h = h1; return h *= h2;}</span></a>
<span class="lineNum">    1282 </span>            : 
<span class="lineNum">    1283 </span>            : Hist operator/(double f, const Hist&amp; h1) {
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :   Hist h = h1;</span>
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :   h.under  = (abs(h1.under)  &lt; Hist::TINY) ? 0. :  f/h1.under;</span>
<span class="lineNum">    1286 </span><span class="lineNoCov">          0 :   h.inside = (abs(h1.inside) &lt; Hist::TINY) ? 0. :  f/h1.inside;</span>
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 :   h.over   = (abs(h1.over)   &lt; Hist::TINY) ? 0. :  f/h1.over;</span>
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :   for (int ix = 0; ix &lt; h1.nBin; ++ix)</span>
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 :     h.res[ix] = (abs(h1.res[ix]) &lt; Hist::TINY) ? 0. : f/h1.res[ix];</span>
<span class="lineNum">    1290 </span>            :   return h;
<a name="1291"><span class="lineNum">    1291 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1292 </span>            : 
<span class="lineNum">    1293 </span>            : Hist operator/(const Hist&amp; h1, double f) {
<a name="1294"><span class="lineNum">    1294 </span><span class="lineNoCov">          0 :   Hist h = h1; return h /= f;}</span></a>
<span class="lineNum">    1295 </span>            : 
<span class="lineNum">    1296 </span>            : Hist operator/(const Hist&amp; h1, const Hist&amp; h2) {
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 :   Hist h = h1; return h /= h2;}</span>
<span class="lineNum">    1298 </span>            : 
<span class="lineNum">    1299 </span>            : //==========================================================================
<span class="lineNum">    1300 </span>            : 
<span class="lineNum">    1301 </span>            : } // end namespace Pythia8
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
